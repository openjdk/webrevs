{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import hat.dialect.HATVectorVarLoadOp;\n@@ -75,3 +74,2 @@\n-                .hashDefine(\"HAT_BARRIER\", _->keyword(\"__syncthreads\").ocparen());\n-                    \/\/    )\n-        \/\/);\n+                .hashDefine(\"HAT_BARRIER\", _->keyword(\"__syncthreads\").ocparen())\n+                .includeSys(\"cuda_fp16.h\");\n@@ -243,6 +241,0 @@\n-\n-    @Override\n-    public CudaHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n-        varName(hatVectorVarLoadOp);\n-        return self();\n-    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+                .pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_fp16\", \":\", \"enable\")                      \/\/ Enable Half type\n@@ -112,1 +113,0 @@\n-\n@@ -195,6 +195,0 @@\n-    @Override\n-    public OpenCLHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n-        varName(hatVectorVarLoadOp);\n-        return self();\n-    }\n-\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.ComputeContext;\n@@ -36,1 +35,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -38,1 +36,0 @@\n-import java.util.ArrayList;\n@@ -43,1 +40,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+public interface F16Array extends Buffer {\n+    int length();\n+\n+    interface F16 extends Struct {\n+        short value();\n+        void value(short value);\n+        static short float2half(float value) {\n+            return Float.floatToFloat16(value);\n+        }\n+        static float half2float(short value) {\n+            return Float.float16ToFloat(value);\n+        }\n+        static F16 add(F16 ha, F16 hb) {\n+            return null;\n+        }\n+\n+        static F16 sub(F16 ha, F16 hb) {\n+            return null;\n+        }\n+\n+        static F16 mul(F16 ha, F16 hb) {\n+            return null;\n+        }\n+\n+        static F16 div(F16 ha, F16 hb) {\n+            return null;\n+        }\n+\n+        String HAT_MAPPING_TYPE = \"half\";\n+    }\n+\n+    F16 array(long index);\n+\n+    Schema<F16Array> schema = Schema.of(F16Array.class, f16array ->\n+            f16array.arrayLen(\"length\")\n+                    .array(\"array\",\n+                            half -> half.fields(\"value\")));\n+\n+    static F16Array create(Accelerator accelerator, int length){\n+        return schema.allocate(accelerator, length);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F16Array.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -30,6 +30,0 @@\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n@@ -35,1 +33,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16VarLoadOp;\n+import hat.dialect.HATF16VarOp;\n@@ -132,0 +135,6 @@\n+    T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp);\n+\n+    T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp);\n+\n+    T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp);\n+\n@@ -174,0 +183,3 @@\n+            case HATF16VarOp $ -> hatF16VarOp(buildContext, $);\n+            case HATF16BinaryOp $ -> hatF16BinaryOp(buildContext, $);\n+            case HATF16VarLoadOp $ -> hatF16VarLoadOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n-import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16VarLoadOp;\n+import hat.dialect.HATF16VarOp;\n@@ -31,0 +33,1 @@\n+import hat.dialect.HATGlobalThreadIdOp;\n@@ -33,0 +36,1 @@\n+import hat.dialect.HATVectorVarLoadOp;\n@@ -36,0 +40,2 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n@@ -42,0 +48,1 @@\n+import java.util.List;\n@@ -218,0 +225,52 @@\n+    @Override\n+    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n+        varName(hatVectorVarLoadOp);\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp) {\n+        typeName(\"half\")\n+                .space()\n+                .identifier(hatF16VarOp.varName())\n+                .space().equals().space();\n+        Value operand = hatF16VarOp.operands().getFirst();\n+        if (operand instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp) {\n+        oparen();\n+        Value op1 = hatF16BinaryOp.operands().get(0);\n+        Value op2 = hatF16BinaryOp.operands().get(1);\n+        List<Boolean> references = hatF16BinaryOp.references();\n+\n+        if (op1 instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        if (references.getFirst()) {\n+            rarrow().identifier(\"value\");\n+        }\n+        space().identifier(hatF16BinaryOp.operationType().symbol()).space();\n+\n+        if (op2 instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        if (references.get(1)) {\n+            rarrow().identifier(\"value\");\n+        }\n+\n+        cparen();\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp) {\n+        identifier(hatF16VarLoadOp.varName());\n+        return self();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.dialect.HATF16VarOp;\n@@ -203,0 +204,5 @@\n+    public T varName(HATF16VarOp hatF16VarOp) {\n+        identifier(hatF16VarOp.varName());\n+        return self();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATF16VarOp;\n@@ -36,0 +32,6 @@\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorSelectLoadOp;\n+import hat.dialect.HATVectorSelectStoreOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n@@ -51,0 +53,2 @@\n+import static hat.buffer.F16Array.F16;\n+\n@@ -72,0 +76,1 @@\n+            case HATF16VarOp $ -> varName($);\n@@ -338,0 +343,3 @@\n+    private boolean isHalfType(Schema.IfaceType ifaceType) {\n+        return ifaceType.iface.getName().equals(F16.class.getName());\n+    }\n@@ -344,2 +352,2 @@\n-                    separated(ifaceType.fields,(_)->nl(), field->{\n-                        boolean isLast =fieldIdx.get() == fieldCount - 1;\n+                    separated(ifaceType.fields, (_) -> nl(), field -> {\n+                        boolean isLast = fieldIdx.get() == fieldCount - 1;\n@@ -347,1 +355,5 @@\n-                            typeName(primitiveField.type.getSimpleName());\n+                            if (isHalfType(ifaceType)) {\n+                                typeName(F16.HAT_MAPPING_TYPE);\n+                            } else {\n+                                typeName(primitiveField.type.getSimpleName());\n+                            }\n@@ -365,1 +377,1 @@\n-                                        }else {\n+                                        } else {\n@@ -394,2 +406,2 @@\n-                                        }else {\n-                                        throw new IllegalStateException(\"bound schema is null  !\");\n+                                        } else {\n+                                            throw new IllegalStateException(\"bound schema is null  !\");\n@@ -410,1 +422,1 @@\n-                        fieldIdx.set(fieldIdx.get()+1);\n+                        fieldIdx.set(fieldIdx.get() + 1);\n@@ -654,2 +666,0 @@\n-\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.dialect.HATF16VarOp;\n@@ -62,0 +63,4 @@\n+            }\n+\n+            if (value instanceof Op.Result result && result.op() instanceof HATF16VarOp hatf16VarOp) {\n+                return hatf16VarOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATF16BinaryOp extends HATF16Op {\n+\n+    private final TypeElement elementType;\n+    private final OpType operationType;\n+    private final List<Boolean> references;\n+\n+    public enum OpType {\n+        ADD(\"+\"),\n+        SUB(\"-\"),\n+        MUL(\"*\"),\n+        DIV(\"\/\");\n+\n+        String symbol;\n+\n+        OpType(String symbol) {\n+            this.symbol = symbol;\n+        }\n+\n+        public String symbol() {\n+            return symbol;\n+        }\n+    }\n+\n+    public HATF16BinaryOp(TypeElement typeElement, OpType operationType, List<Boolean> references, List<Value> operands) {\n+        super(\"\", operands);\n+        this.elementType = typeElement;\n+        this.operationType = operationType;\n+        this.references = references;\n+    }\n+\n+    public HATF16BinaryOp(HATF16BinaryOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.elementType = op.elementType;\n+        this.operationType = op.operationType;\n+        this.references = op.references;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16BinaryOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return this.elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.fp16.\" + varName(), operationType.symbol());\n+    }\n+\n+    public OpType operationType() {\n+        return operationType;\n+    }\n+\n+    public List<Boolean> references() {\n+        return references;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16BinaryOp.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HATF16Op extends HATOp {\n+\n+    private String varName;\n+\n+    public HATF16Op(String varName, List<Value> operands) {\n+        super(operands);\n+        this.varName = varName;\n+    }\n+\n+    protected HATF16Op(HATF16Op that, CopyContext cc) {\n+        super(that, cc);\n+        this.varName = that.varName;\n+    }\n+\n+    public String varName() {\n+        return varName;\n+    }\n+\n+    public void  varName(String varName) {\n+        this.varName = varName;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16Op.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATF16VarLoadOp extends HATF16Op {\n+\n+    private final VarType typeElement;\n+\n+    public HATF16VarLoadOp(String varName, VarType typeElement, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+    }\n+\n+    public HATF16VarLoadOp(HATF16VarLoadOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16VarLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.fp16VarOp.\" + varName(), typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16VarLoadOp.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATF16VarOp extends HATF16Op {\n+\n+    private final VarType typeElement;\n+\n+    public HATF16VarOp(String varName, VarType typeElement, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+    }\n+\n+    public HATF16VarOp(HATF16VarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATF16VarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.fp16varop.\" + varName(), typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16VarOp.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.dialect.HATF16VarOp;\n@@ -325,0 +326,1 @@\n+                        || (op instanceof HATF16VarOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.buffer.F16Array;\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16VarLoadOp;\n+import hat.dialect.HATF16VarOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyFP16Phase implements HATDialect {\n+\n+    private final String[] methodOps = new String[] {\"add\", \"sub\", \"mul\", \"div\"};\n+\n+    private final Accelerator accelerator;\n+    public HATDialectifyFP16Phase(Accelerator accelerator) {\n+        this.accelerator = accelerator;\n+    }\n+\n+    private boolean isFP16Operation(JavaOp.InvokeOp invokeOp, String methodName) {\n+        String invokeClassName = invokeOp.invokeDescriptor().refType().toString();\n+        boolean isFP16Operation = invokeClassName.replace(\"$\", \".\").startsWith(F16Array.F16.class.getCanonicalName());\n+        return isFP16Operation\n+                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n+                && invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private boolean findReference(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findReference(varLoadOp.operands().get(0));\n+    }\n+\n+    private boolean findReference(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findReference(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n+                Value first = varOp.operands().getFirst();\n+                return first instanceof Op.Result r2 && r2.op() instanceof JavaOp.InvokeOp invokeOp && invokeOp.invokeDescriptor().name().equals(\"array\");\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private CoreOp.FuncOp dialectifyF16Ops(CoreOp.FuncOp funcOp, String methodName) {\n+        if (accelerator.backend.config().showCompilationPhases())\n+            IO.println(\"[BEFORE] FP16 Phase: \" + funcOp.toText());\n+\n+        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n+                .mapMulti(((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isFP16Operation(invokeOp, methodName) && invokeOp.resultType() != JavaType.VOID) {\n+                            Set<Op.Result> uses = invokeOp.result().uses();\n+                            consumer.accept(invokeOp);\n+                            for (Op.Result result : uses) {\n+                                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                                    consumer.accept(varOp);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }));\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> operands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(operands);\n+                \/\/ Obtain the memory mapping for each operand\n+                \/\/ if it comes from global memory, HAT replaces with a global* pointer to the inner struct,\n+                \/\/ then, we will need to operate half using a->value, instead of ha directly.\n+                boolean isFirstOperandReference = findReference(invokeOp.operands().getFirst());\n+                boolean isSecondOperandReference = findReference(invokeOp.operands().get(1));\n+\n+                \/\/ Todo: subclassing to get this\n+                HATF16BinaryOp.OpType opType = switch (methodName) {\n+                    case \"add\" -> HATF16BinaryOp.OpType.ADD;\n+                    case \"sub\" -> HATF16BinaryOp.OpType.SUB;\n+                    case \"mul\" -> HATF16BinaryOp.OpType.MUL;\n+                    case \"div\" -> HATF16BinaryOp.OpType.DIV;\n+                    default -> throw new IllegalStateException(\"Unexpected value: \" + methodName);\n+                };\n+\n+                HATF16BinaryOp binaryOp = new HATF16BinaryOp(invokeOp.resultType(),\n+                        opType,\n+                        List.of(isFirstOperandReference, isSecondOperandReference),\n+                        outputOperands);\n+                Op.Result op1 = blockBuilder.op(binaryOp);\n+                binaryOp.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), op1);\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                List<Value> operands = varOp.operands();\n+                List<Value> outputOperands = context.getValues(operands);\n+                HATF16VarOp hatf16VarOp = new HATF16VarOp(varOp.varName(), varOp.resultType(), outputOperands);\n+                Op.Result op1 = blockBuilder.op(hatf16VarOp);\n+                hatf16VarOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), op1);\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (accelerator.backend.config().showCompilationPhases())\n+            IO.println(\"[AFTER] FP16 Phase: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyF16Stores(CoreOp.FuncOp funcOp) {\n+        if (accelerator.backend.config().showCompilationPhases())\n+            IO.println(\"[BEFORE] dialectifyF16Stores Phase: \" + funcOp.toText());\n+\n+        Stream<CodeElement<?, ?>> halfOps = funcOp.elements()\n+                .mapMulti(((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isFP16Operation(invokeOp, \"value\") && invokeOp.resultType() == JavaType.SHORT) {\n+                            Value value = invokeOp.operands().getFirst();\n+                            if (value instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                Value second = varLoadOp.operands().getFirst();\n+                                if (second instanceof Op.Result r1 && r1.op() instanceof HATF16VarOp) {\n+                                    consumer.accept(invokeOp);\n+                                    consumer.accept(varLoadOp);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }));\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = halfOps.collect(Collectors.toSet());\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                context.mapValue(invokeOp.result(), context.getValue(invokeOp.operands().getFirst()));\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                List<Value> operands = varLoadOp.operands();\n+                List<Value> outputOperands = context.getValues(operands);\n+                String nameVar = findName(varLoadOp);\n+                HATF16VarLoadOp hatf16VarLoadOp = new HATF16VarLoadOp(nameVar, varLoadOp.varType(), outputOperands);\n+                Op.Result op1 = blockBuilder.op(hatf16VarLoadOp);\n+                hatf16VarLoadOp.setLocation(varLoadOp.location());\n+                context.mapValue(varLoadOp.result(), op1);\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (accelerator.backend.config().showCompilationPhases())\n+            IO.println(\"[AFTER] dialectifyF16Stores Phase: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    private String findName(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findName(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findName(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findName(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATF16VarOp hatf16VarOp) {\n+                return hatf16VarOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        for (String methodName : methodOps)\n+            funcOp = dialectifyF16Ops(funcOp, methodName);\n+        funcOp = dialectifyF16Stores(funcOp);\n+        return funcOp;\n+    }\n+\n+    @Override\n+    public Accelerator accelerator() {\n+        return accelerator;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+        hatPhases.add(new HATDialectifyFP16Phase(accelerator));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-public class HATDialectifyVectorSelectPhase implements HATDialect{\n+public class HATDialectifyVectorSelectPhase implements HATDialect {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,1 +173,2 @@\n-                \"hat.test.TestVectorTypes\"\n+                \"hat.test.TestVectorTypes\",\n+                \"hat.test.TestFP16Type\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.test;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F16Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.test.annotation.HatTest;\n+import hat.test.engine.HatAsserts;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+import static hat.buffer.F16Array.F16;\n+\n+public class TestFP16Type {\n+\n+    @CodeReflection\n+    public static void copy01(@RO KernelContext kernelContext, @RO F16Array a, @RW F16Array b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            \/\/ The following expression does not work\n+            \/\/b.array(kernelContext.gix).value(ha.value());\n+\n+            hb.value(ha.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void fp16Ops_02(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            F16Array.F16 result = F16.add(ha, hb);\n+            F16Array.F16 hC = c.array(kernelContext.gix);\n+            hC.value(result.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void fp16Ops_03(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            F16Array.F16 result = F16.add(ha, F16.add(hb, hb));\n+            F16Array.F16 hC = c.array(kernelContext.gix);\n+            hC.value(result.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void fp16Ops_04(@RO KernelContext kernelContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            F16Array.F16 ha = a.array(kernelContext.gix);\n+            F16Array.F16 hb = b.array(kernelContext.gix);\n+\n+            F16Array.F16 r1 = F16.mul(ha, hb);\n+            F16Array.F16 r2 = F16.div(ha, hb);\n+            F16Array.F16 r3 = F16.sub(ha, hb);\n+            F16Array.F16 r4 = F16.add(r1, r2);\n+            F16Array.F16 r5 = F16.add(r4, r3);\n+            F16Array.F16 hC = c.array(kernelContext.gix);\n+            hC.value(r5.value());\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void compute01(@RO ComputeContext computeContext, @RO F16Array a, @RW F16Array b) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.copy01(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void compute02(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_02(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void compute03(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_03(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void compute04(@RO ComputeContext computeContext, @RO F16Array a, @RO F16Array b, @RW F16Array c) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(a.length()));\n+        computeContext.dispatchKernel(computeRange, kernelContext -> TestFP16Type.fp16Ops_04(kernelContext, a, b, c));\n+    }\n+\n+    @HatTest\n+    public void testF16_01() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.float2half(i));\n+        }\n+\n+        accelerator.compute(computeContext -> TestFP16Type.compute01(computeContext, arrayA, arrayB));\n+\n+        for (int i = 0; i < arrayB.length(); i++) {\n+            short val = arrayB.array(i).value();\n+            HatAsserts.assertEquals((float)i, F16.half2float(val), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_02() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+        F16Array arrayC = F16Array.create(accelerator, size);\n+\n+        Random random = new Random();\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestFP16Type.compute02(computeContext, arrayA, arrayB, arrayC);\n+        });\n+\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            short val = arrayC.array(i).value();\n+            float fa = Float.float16ToFloat(arrayA.array(i).value());\n+            float fb = Float.float16ToFloat(arrayB.array(i).value());\n+            HatAsserts.assertEquals((fa + fb), F16.half2float(val), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_03() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+        F16Array arrayC = F16Array.create(accelerator, size);\n+\n+        Random random = new Random();\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestFP16Type.compute03(computeContext, arrayA, arrayB, arrayC);\n+        });\n+\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            short val = arrayC.array(i).value();\n+            float fa = Float.float16ToFloat(arrayA.array(i).value());\n+            float fb = Float.float16ToFloat(arrayB.array(i).value());\n+            HatAsserts.assertEquals((fa + fb + fb), F16.half2float(val), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testF16_04() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\n+        final int size = 16;\n+        F16Array arrayA = F16Array.create(accelerator, size);\n+        F16Array arrayB = F16Array.create(accelerator, size);\n+        F16Array arrayC = F16Array.create(accelerator, size);\n+\n+        Random random = new Random();\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+            arrayA.array(i).value(F16.float2half(random.nextFloat()));\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestFP16Type.compute04(computeContext, arrayA, arrayB, arrayC);\n+        });\n+\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            short val = arrayC.array(i).value();\n+            F16Array.F16 ha = arrayA.array(i);\n+            F16Array.F16 hb = arrayB.array(i);\n+\n+            float fa = Float.float16ToFloat(ha.value());\n+            float fb = Float.float16ToFloat(hb.value());\n+            float r1 = fa * fb;\n+            float r2 = fa \/ fb;\n+            float r3 = fa - fb;\n+            float r4 = r1 + r2;\n+            float r5 = r4 + r3;\n+            HatAsserts.assertEquals(r5, Float.float16ToFloat(val), 0.001f);\n+        }\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestFP16Type.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -32,0 +32,3 @@\n+import hat.dialect.HATF16BinaryOp;\n+import hat.dialect.HATF16VarLoadOp;\n+import hat.dialect.HATF16VarOp;\n@@ -208,0 +211,18 @@\n+    @Override\n+    public T hatF16VarOp(ScopedCodeBuilderContext buildContext, HATF16VarOp hatF16VarOp) {\n+        blockComment(\"F16 Variable Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatF16BinaryOp(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatF16BinaryOp) {\n+        blockComment(\"Binary F16 Op Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatF16VarLoadOp(ScopedCodeBuilderContext buildContext, HATF16VarLoadOp hatF16VarLoadOp) {\n+        blockComment(\"F16 Load Op Not Implemented\");\n+        return self();\n+    }\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}