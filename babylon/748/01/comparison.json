{"files":[{"patch":"@@ -572,0 +572,4 @@\n+            \/\/ op method may throw UOE in case java compile time version doesn't match runtime version\n+            if (e.getCause() instanceof UnsupportedOperationException uoe) {\n+                throw uoe;\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.reflect.Method;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @summary Test that java version check we do in op building methods is working\n+ * @run main TestJavaVersionChecker\n+ * @run junit\/othervm TestJavaVersionChecker\n+ *\/\n+public class TestJavaVersionChecker {\n+\n+    public static void main(String[] args) throws IOException { \/\/ transform $CM classfile\n+        String testClassName = TestJavaVersionChecker.class.getName();\n+        Path testClassesDir = Path.of(System.getProperty(\"test.classes\"));\n+        Path innerClassPath = FileSystems.getDefault().getPath(testClassesDir.toString(), testClassName + \"$$CM.class\");\n+        byte[] newInnerBytes = changeCompileTimeVersion(innerClassPath, Runtime.version().feature() - 1);\n+        Files.write(innerClassPath, newInnerBytes);\n+    }\n+\n+    @Test\n+    void test() throws ReflectiveOperationException, IOException {\n+        Method m = this.getClass().getDeclaredMethod(\"max\", int.class, int.class);\n+        Assertions.assertThrows(UnsupportedOperationException.class, () -> Op.ofMethod(m));\n+    }\n+\n+    \/\/ change java compile time version that was embedded in the $checkJavaVersion method\n+    private static byte[] changeCompileTimeVersion(Path innerClassPath, int newCompileTimeVersion) {\n+        ClassModel inner = null;\n+        try {\n+            inner = ClassFile.of().parse(innerClassPath);\n+        } catch (IOException e) {\n+            Assertions.fail(\"Inner class holding the code model doesn't exist\");\n+        }\n+\n+        Optional<MethodModel> optional = inner.methods().stream().filter(m -> m.methodName().equalsString(\"$checkJavaVersion\")).findFirst();\n+        Assertions.assertTrue(optional.isPresent(), \"Helper method that checks the java version doesn't exist\");\n+        MethodModel checkerMethod = optional.get();\n+\n+        for (MethodModel m : inner.methods()) {\n+            if (m.methodName().stringValue().startsWith(\"$\")) { \/\/ not model building method\n+                continue;\n+            }\n+            Assertions.assertTrue(m.code().get().elementList().getFirst() instanceof InvokeInstruction i &&\n+                            i.method().owner().asSymbol().equals(inner.thisClass().asSymbol()) &&\n+                            i.name().equals(checkerMethod.methodName()) &&\n+                            i.type().equals(checkerMethod.methodType()),\n+                    \"model building method doesn't check Java version at the start\");\n+        }\n+\n+        \/\/ @@@ we may want to change the compile time version embedded in the error message ?\n+        CodeTransform codeTransform = (codeBuilder, codeElement) -> {\n+            if (codeElement instanceof ConstantInstruction.ArgumentConstantInstruction a) {\n+                codeBuilder.bipush(newCompileTimeVersion);\n+            } else {\n+                codeBuilder.with(codeElement);\n+            }\n+        };\n+        ClassTransform classTransform = (classBuilder, classElement) -> {\n+            if (classElement instanceof MethodModel m && m.equals(checkerMethod)) {\n+                classBuilder.transformMethod(m, MethodTransform.transformingCode(codeTransform));\n+            } else {\n+                classBuilder.with(classElement);\n+            }\n+        };\n+\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(inner, classTransform);\n+    }\n+\n+    @Reflect\n+    static int max(int a, int b) {\n+        return Math.max(a, b);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionChecker.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}