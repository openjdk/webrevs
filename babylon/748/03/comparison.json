{"files":[{"patch":"@@ -501,2 +501,0 @@\n-     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n-     *                                       is not the same as the Java version used at runtime to load the code model.\n@@ -572,0 +570,4 @@\n+            \/\/ op method may throw UOE in case java compile time version doesn't match runtime version\n+            if (e.getCause() instanceof UnsupportedOperationException uoe) {\n+                throw uoe;\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+import jdk.incubator.code.Reflect;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.IntBinaryOperator;\n+\n+\/*\n+ * @test\n+ * @summary Test that java version check we do in op building methods is working\n+ * @run main TestJavaVersionCheckerForLambdas\n+ * @run junit\/othervm TestJavaVersionCheckerForLambdas\n+ *\/\n+public class TestJavaVersionCheckerForLambdas {\n+\n+    public static void main(String[] args) throws IOException { \/\/ transform $CM classfile\n+        String testClassName = TestJavaVersionCheckerForLambdas.class.getName();\n+        Path testClassesDir = Path.of(System.getProperty(\"test.classes\"));\n+        Path innerClassPath = testClassesDir.resolve(testClassName + \"$$CM.class\");\n+        byte[] newInnerBytes = TestJavaVersionCheckerForMethods.changeCompileTimeVersion(innerClassPath, Runtime.version().feature() - 1);\n+        Files.write(innerClassPath, newInnerBytes);\n+    }\n+\n+    @Test\n+    void test() throws ReflectiveOperationException, IOException {\n+        \/\/ in the lambda class initializer <clinit>, we invoke lambda op method\n+        \/\/ after the changes we made to $CM classfile, the lambda op method throws UOE, causing <clinit> to fails\n+        \/\/ UOE -> ExceptionInInitializerError -> InternalError\n+        InternalError ie = null;\n+        try {\n+            IntBinaryOperator l = (@Reflect IntBinaryOperator) (a, b) -> Math.max(a, b);\n+        } catch (InternalError e) {\n+            Assertions.assertInstanceOf(ExceptionInInitializerError.class, e.getCause());\n+            Assertions.assertInstanceOf(UnsupportedOperationException.class, e.getCause().getCause());\n+            ie = e;\n+        }\n+        Assertions.assertNotNull(ie, \"Reflectable lambda creation didn't fail as expected\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionCheckerForLambdas.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @summary Test that java version check we do in op building methods is working\n+ * @run main TestJavaVersionCheckerForMethods\n+ * @run junit\/othervm TestJavaVersionCheckerForMethods\n+ *\/\n+public class TestJavaVersionCheckerForMethods {\n+\n+    public static void main(String[] args) throws IOException { \/\/ transform $CM classfile\n+        String testClassName = TestJavaVersionCheckerForMethods.class.getName();\n+        Path testClassesDir = Path.of(System.getProperty(\"test.classes\"));\n+        Path innerClassPath = testClassesDir.resolve(testClassName + \"$$CM.class\");\n+        byte[] newInnerBytes = changeCompileTimeVersion(innerClassPath, Runtime.version().feature() - 1);\n+        Files.write(innerClassPath, newInnerBytes);\n+    }\n+\n+    @Test\n+    void test() throws ReflectiveOperationException, IOException {\n+        Method m = this.getClass().getDeclaredMethod(\"max\", int.class, int.class);\n+        Assertions.assertThrows(UnsupportedOperationException.class, () -> Op.ofMethod(m));\n+    }\n+\n+    \/\/ change java compile time version that was embedded in the $checkJavaVersion method\n+    static byte[] changeCompileTimeVersion(Path innerClassPath, int newCompileTimeVersion) {\n+        ClassModel inner = null;\n+        try {\n+            inner = ClassFile.of().parse(innerClassPath);\n+        } catch (IOException e) {\n+            Assertions.fail(\"Inner class holding the code model doesn't exist in \" + innerClassPath);\n+        }\n+\n+        Optional<MethodModel> optional = inner.methods().stream().filter(m -> m.methodName().equalsString(\"$checkJavaVersion\")).findFirst();\n+        Assertions.assertTrue(optional.isPresent(), \"Helper method that checks the java version doesn't exist\");\n+        MethodModel checkerMethod = optional.get();\n+\n+        for (MethodModel m : inner.methods()) {\n+            if (m.methodName().stringValue().startsWith(\"$\")) { \/\/ not model building method\n+                continue;\n+            }\n+            Assertions.assertTrue(m.code().get().elementList().getFirst() instanceof InvokeInstruction i &&\n+                            i.method().owner().asSymbol().equals(inner.thisClass().asSymbol()) &&\n+                            i.name().equals(checkerMethod.methodName()) &&\n+                            i.type().equals(checkerMethod.methodType()),\n+                    \"model building method doesn't check Java version at the start\");\n+        }\n+\n+        \/\/ @@@ we may want to change the compile time version embedded in the error message ?\n+        CodeTransform codeTransform = (codeBuilder, codeElement) -> {\n+            if (codeElement instanceof ConstantInstruction.ArgumentConstantInstruction a) {\n+                codeBuilder.bipush(newCompileTimeVersion);\n+            } else {\n+                codeBuilder.with(codeElement);\n+            }\n+        };\n+        ClassTransform classTransform = (classBuilder, classElement) -> {\n+            if (classElement instanceof MethodModel m && m.equals(checkerMethod)) {\n+                classBuilder.transformMethod(m, MethodTransform.transformingCode(codeTransform));\n+            } else {\n+                classBuilder.with(classElement);\n+            }\n+        };\n+\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(inner, classTransform);\n+    }\n+\n+    @Reflect\n+    static int max(int a, int b) {\n+        return Math.max(a, b);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionCheckerForMethods.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}