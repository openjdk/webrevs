{"files":[{"patch":"@@ -501,2 +501,0 @@\n-     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n-     *                                       is not the same as the Java version used at runtime to load the code model.\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,0 @@\n-import java.nio.file.FileSystems;\n@@ -15,0 +14,1 @@\n+import java.util.function.IntBinaryOperator;\n@@ -27,1 +27,1 @@\n-        Path innerClassPath = FileSystems.getDefault().getPath(testClassesDir.toString(), testClassName + \"$$CM.class\");\n+        Path innerClassPath = testClassesDir.resolve(testClassName + \"$$CM.class\");\n@@ -36,0 +36,13 @@\n+\n+        \/\/ in the lambda class initializer <clinit>, we invoke lambda op method\n+        \/\/ after the changes we made to $CM classfile, the lambda op method throws UOE, causing <clinit> to fails\n+        \/\/ UOE -> ExceptionInInitializerError -> InternalError\n+        InternalError ie = null;\n+        try {\n+            IntBinaryOperator l = (@Reflect IntBinaryOperator) (a, b) -> Math.max(a, b);\n+        } catch (InternalError e) {\n+            Assertions.assertInstanceOf(ExceptionInInitializerError.class, e.getCause());\n+            Assertions.assertInstanceOf(UnsupportedOperationException.class, e.getCause().getCause());\n+            ie = e;\n+        }\n+        Assertions.assertNotNull(ie, \"Reflectable lambda creation didn't fail as expected\");\n@@ -44,1 +57,1 @@\n-            Assertions.fail(\"Inner class holding the code model doesn't exist\");\n+            Assertions.fail(\"Inner class holding the code model doesn't exist in \" + innerClassPath);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionChecker.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"}]}