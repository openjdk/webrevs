{"files":[{"patch":"@@ -572,0 +572,4 @@\n+            \/\/ op method may throw UOE in case java compile time version doesn't match runtime version\n+            if (e.getCause() instanceof UnsupportedOperationException uoe) {\n+                throw uoe;\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,2 +14,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -21,1 +19,2 @@\n- * @run junit TestJavaVersionChecker\n+ * @run main TestJavaVersionChecker\n+ * @run junit\/othervm TestJavaVersionChecker\n@@ -24,3 +23,7 @@\n-    @Reflect\n-    static int max(int a, int b) {\n-        return Math.max(a, b);\n+\n+    public static void main(String[] args) throws IOException { \/\/ transform $CM classfile\n+        String testClassName = TestJavaVersionChecker.class.getName();\n+        Path testClassesDir = Path.of(System.getProperty(\"test.classes\"));\n+        Path innerClassPath = FileSystems.getDefault().getPath(testClassesDir.toString(), testClassName + \"$$CM.class\");\n+        byte[] newInnerBytes = changeCompileTimeVersion(innerClassPath, Runtime.version().feature() - 1);\n+        Files.write(innerClassPath, newInnerBytes);\n@@ -31,41 +34,2 @@\n-        String testClassName = this.getClass().getName();\n-        String innerClassName = testClassName + \"$$CM\";\n-        Path testClassfilesDir = Path.of(\"\/Users\/mabbay\/babylon\/JTwork\/classes\/0\/java\/lang\/reflect\/code\/writer\/\" +\n-                testClassName + \".d\");\n-        Path innerClassPath = FileSystems.getDefault().getPath(testClassfilesDir.toString(), innerClassName + \".class\");\n-        Path testClassPath = FileSystems.getDefault().getPath(testClassfilesDir.toString(), testClassName + \".class\");\n-\n-        byte[] newInner = changeCompileTimeVersion(innerClassPath, Runtime.version().feature() - 1);\n-\n-        \/\/ we must choose a parent loader incapable of loading this test class and its inner class\n-        \/\/ so that we fall back to BytecodeLoader#findClass\n-        ByteClassLoader byteClassLoader = new ByteClassLoader(ClassLoader.getSystemClassLoader());\n-        byteClassLoader.registerClass(innerClassName, newInner);\n-        byteClassLoader.registerClass(testClassName, Files.readAllBytes(testClassPath));\n-\n-        Class<?> testClass = byteClassLoader.loadClass(this.getClass().getName());\n-        \/\/ using the testClass instance will cause the inner class $CM to be loaded by bytecodeLoader\n-        Method m = testClass.getDeclaredMethod(\"max\", int.class, int.class);\n-        Assertions.assertThrows(RuntimeException.class, () -> Op.ofMethod(m));\n-    }\n-\n-    public static class ByteClassLoader extends ClassLoader {\n-        private final Map<String, byte[]> classesBytes = new HashMap<>();\n-\n-        public ByteClassLoader(ClassLoader parent) {\n-            super(parent);\n-        }\n-\n-        public void registerClass(String className, byte[] classBytes) {\n-            classesBytes.put(className, classBytes);\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String className) throws ClassNotFoundException {\n-            System.out.println(\"findClass \" + className);\n-            byte[] bytes = classesBytes.get(className);\n-            if (bytes == null)\n-                throw new ClassNotFoundException(className + \" was not registered in \" + this.getClass().getName());\n-\n-            return defineClass(className, bytes, 0, bytes.length);\n-        }\n+        Method m = this.getClass().getDeclaredMethod(\"max\", int.class, int.class);\n+        Assertions.assertThrows(UnsupportedOperationException.class, () -> Op.ofMethod(m));\n@@ -98,0 +62,1 @@\n+        \/\/ @@@ we may want to change the compile time version embedded in the error message ?\n@@ -115,0 +80,5 @@\n+\n+    @Reflect\n+    static int max(int a, int b) {\n+        return Math.max(a, b);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionChecker.java","additions":17,"deletions":47,"binary":false,"changes":64,"status":"modified"}]}