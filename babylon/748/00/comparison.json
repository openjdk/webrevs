{"files":[{"patch":"@@ -0,0 +1,115 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.reflect.Method;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @summary Test that java version check we do in op building methods is working\n+ * @run junit TestJavaVersionChecker\n+ *\/\n+public class TestJavaVersionChecker {\n+    @Reflect\n+    static int max(int a, int b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Test\n+    void test() throws ReflectiveOperationException, IOException {\n+        String testClassName = this.getClass().getName();\n+        String innerClassName = testClassName + \"$$CM\";\n+        Path testClassfilesDir = Path.of(\"\/Users\/mabbay\/babylon\/JTwork\/classes\/0\/java\/lang\/reflect\/code\/writer\/\" +\n+                testClassName + \".d\");\n+        Path innerClassPath = FileSystems.getDefault().getPath(testClassfilesDir.toString(), innerClassName + \".class\");\n+        Path testClassPath = FileSystems.getDefault().getPath(testClassfilesDir.toString(), testClassName + \".class\");\n+\n+        byte[] newInner = changeCompileTimeVersion(innerClassPath, Runtime.version().feature() - 1);\n+\n+        \/\/ we must choose a parent loader incapable of loading this test class and its inner class\n+        \/\/ so that we fall back to BytecodeLoader#findClass\n+        ByteClassLoader byteClassLoader = new ByteClassLoader(ClassLoader.getSystemClassLoader());\n+        byteClassLoader.registerClass(innerClassName, newInner);\n+        byteClassLoader.registerClass(testClassName, Files.readAllBytes(testClassPath));\n+\n+        Class<?> testClass = byteClassLoader.loadClass(this.getClass().getName());\n+        \/\/ using the testClass instance will cause the inner class $CM to be loaded by bytecodeLoader\n+        Method m = testClass.getDeclaredMethod(\"max\", int.class, int.class);\n+        Assertions.assertThrows(RuntimeException.class, () -> Op.ofMethod(m));\n+    }\n+\n+    public static class ByteClassLoader extends ClassLoader {\n+        private final Map<String, byte[]> classesBytes = new HashMap<>();\n+\n+        public ByteClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        public void registerClass(String className, byte[] classBytes) {\n+            classesBytes.put(className, classBytes);\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String className) throws ClassNotFoundException {\n+            System.out.println(\"findClass \" + className);\n+            byte[] bytes = classesBytes.get(className);\n+            if (bytes == null)\n+                throw new ClassNotFoundException(className + \" was not registered in \" + this.getClass().getName());\n+\n+            return defineClass(className, bytes, 0, bytes.length);\n+        }\n+    }\n+\n+    \/\/ change java compile time version that was embedded in the $checkJavaVersion method\n+    private static byte[] changeCompileTimeVersion(Path innerClassPath, int newCompileTimeVersion) {\n+        ClassModel inner = null;\n+        try {\n+            inner = ClassFile.of().parse(innerClassPath);\n+        } catch (IOException e) {\n+            Assertions.fail(\"Inner class holding the code model doesn't exist\");\n+        }\n+\n+        Optional<MethodModel> optional = inner.methods().stream().filter(m -> m.methodName().equalsString(\"$checkJavaVersion\")).findFirst();\n+        Assertions.assertTrue(optional.isPresent(), \"Helper method that checks the java version doesn't exist\");\n+        MethodModel checkerMethod = optional.get();\n+\n+        for (MethodModel m : inner.methods()) {\n+            if (m.methodName().stringValue().startsWith(\"$\")) { \/\/ not model building method\n+                continue;\n+            }\n+            Assertions.assertTrue(m.code().get().elementList().getFirst() instanceof InvokeInstruction i &&\n+                            i.method().owner().asSymbol().equals(inner.thisClass().asSymbol()) &&\n+                            i.name().equals(checkerMethod.methodName()) &&\n+                            i.type().equals(checkerMethod.methodType()),\n+                    \"model building method doesn't check Java version at the start\");\n+        }\n+\n+        CodeTransform codeTransform = (codeBuilder, codeElement) -> {\n+            if (codeElement instanceof ConstantInstruction.ArgumentConstantInstruction a) {\n+                codeBuilder.bipush(newCompileTimeVersion);\n+            } else {\n+                codeBuilder.with(codeElement);\n+            }\n+        };\n+        ClassTransform classTransform = (classBuilder, classElement) -> {\n+            if (classElement instanceof MethodModel m && m.equals(checkerMethod)) {\n+                classBuilder.transformMethod(m, MethodTransform.transformingCode(codeTransform));\n+            } else {\n+                classBuilder.with(classElement);\n+            }\n+        };\n+\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(inner, classTransform);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionChecker.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}