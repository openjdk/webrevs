{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.code.analysis;\n+package oracle.code.triton;\n@@ -29,1 +29,0 @@\n-import jdk.incubator.code.Op;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -33,0 +33,1 @@\n+\n@@ -34,2 +35,2 @@\n-import java.util.function.*;\n-import java.util.stream.Gatherer;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Patterns.java","additions":6,"deletions":5,"binary":false,"changes":11,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Patterns.java","status":"copied"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.analysis.Patterns;\n@@ -38,1 +37,1 @@\n-import static jdk.incubator.code.analysis.Patterns.*;\n+import static oracle.code.triton.Patterns.*;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SimpleCountedForLoopInfo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import static jdk.incubator.code.analysis.Patterns.*;\n@@ -41,2 +40,2 @@\n-    static OpPattern negP(Pattern operand) {\n-        return opP(JavaOp.NegOp.class, operand);\n+    static Patterns.OpPattern negP(Patterns.Pattern operand) {\n+        return Patterns.opP(JavaOp.NegOp.class, operand);\n@@ -45,2 +44,2 @@\n-    static OpPattern addP(Pattern lhs, Pattern rhs) {\n-        return opP(JavaOp.AddOp.class, lhs, rhs);\n+    static Patterns.OpPattern addP(Patterns.Pattern lhs, Patterns.Pattern rhs) {\n+        return Patterns.opP(JavaOp.AddOp.class, lhs, rhs);\n@@ -49,2 +48,2 @@\n-    static OpPattern mulP(Pattern lhs, Pattern rhs) {\n-        return opP(JavaOp.MulOp.class, lhs, rhs);\n+    static Patterns.OpPattern mulP(Patterns.Pattern lhs, Patterns.Pattern rhs) {\n+        return Patterns.opP(JavaOp.MulOp.class, lhs, rhs);\n@@ -58,7 +57,7 @@\n-        var actions = multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n-                .pattern(mulP(_P(), valueP(constantP(0.0d))))\n-                .pattern(mulP(valueP(constantP(0.0d)), _P()))\n-                .pattern(addP(valueP(), constantP(0.0d)))\n-                .pattern(addP(constantP(0.0d), valueP()))\n-                .pattern(mulP(constantP(1.0d), valueP()))\n-                .pattern(mulP(valueP(), constantP(1.0d)))\n+        var actions = Patterns.multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n+                .pattern(mulP(Patterns._P(), Patterns.valueP(Patterns.constantP(0.0d))))\n+                .pattern(mulP(Patterns.valueP(Patterns.constantP(0.0d)), Patterns._P()))\n+                .pattern(addP(Patterns.valueP(), Patterns.constantP(0.0d)))\n+                .pattern(addP(Patterns.constantP(0.0d), Patterns.valueP()))\n+                .pattern(mulP(Patterns.constantP(1.0d), Patterns.valueP()))\n+                .pattern(mulP(Patterns.valueP(), Patterns.constantP(1.0d)))\n@@ -74,1 +73,1 @@\n-                .pattern(addP(negP(valueP()), valueP()))\n+                .pattern(addP(negP(Patterns.valueP()), Patterns.valueP()))\n@@ -108,1 +107,1 @@\n-            Set<Op> unused = matchUnusedPureOps(ef, testPure);\n+            Set<Op> unused = Patterns.matchUnusedPureOps(ef, testPure);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ExpressionElimination.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n@@ -26,2 +24,0 @@\n-package jdk.incubator.code.analysis;\n-\n@@ -29,1 +25,0 @@\n-import jdk.incubator.code.Op;\n@@ -31,0 +26,1 @@\n+import jdk.incubator.code.Op;\n@@ -33,0 +29,1 @@\n+\n@@ -34,2 +31,2 @@\n-import java.util.function.*;\n-import java.util.stream.Gatherer;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/Patterns.java","additions":6,"deletions":9,"binary":false,"changes":15,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Patterns.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,3 @@\n-import jdk.incubator.code.*;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestExpressionElimination.java","additions":4,"deletions":2,"binary":false,"changes":6,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","status":"renamed"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.util.HashMap;\n-import java.util.function.BiConsumer;\n-\n-import static jdk.incubator.code.dialect.java.JavaOp.sub;\n-import static jdk.incubator.code.analysis.Patterns.*;\n-\n-public final class ExpressionElimination {\n-    private ExpressionElimination() {\n-    }\n-\n-    static OpPattern negP(Pattern operand) {\n-        return opP(JavaOp.NegOp.class, operand);\n-    }\n-\n-    static OpPattern addP(Pattern lhs, Pattern rhs) {\n-        return opP(JavaOp.AddOp.class, lhs, rhs);\n-    }\n-\n-    static OpPattern mulP(Pattern lhs, Pattern rhs) {\n-        return opP(JavaOp.MulOp.class, lhs, rhs);\n-    }\n-\n-    public static <T extends Op> T eliminate(T f) {\n-        \/\/ Note expression elimination and other forms of analysis is simplified if first of all expressions\n-        \/\/ are normalized e.g. when they have an operand that is a constant expression\n-        \/\/ and the operation is associative such as add(0, x) -> add(x, 0)\n-\n-        var actions = multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n-                .pattern(mulP(_P(), valueP(constantP(0.0d))))\n-                .pattern(mulP(valueP(constantP(0.0d)), _P()))\n-                .pattern(addP(valueP(), constantP(0.0d)))\n-                .pattern(addP(constantP(0.0d), valueP()))\n-                .pattern(mulP(constantP(1.0d), valueP()))\n-                .pattern(mulP(valueP(), constantP(1.0d)))\n-                .target((ms, as) -> {\n-                    Value a = ms.matchedOperands().get(0);\n-                    as.put(ms.op().result(), (block, op) -> {\n-                        CodeContext cc = block.context();\n-                        cc.mapValue(ms.op().result(), cc.getValue(a));\n-                    });\n-                    return as;\n-                })\n-                \/\/ add(neg(x), y) -> sub(y, x)\n-                .pattern(addP(negP(valueP()), valueP()))\n-                .target((ms, as) -> {\n-                    Value x = ms.matchedOperands().get(0);\n-                    Value y = ms.matchedOperands().get(1);\n-\n-                    as.put(ms.op().result(), (block, op) -> {\n-                        CodeContext cc = block.context();\n-                        Op.Result r = block.op(sub(cc.getValue(y), cc.getValue(x)));\n-                        cc.mapValue(ms.op().result(), r);\n-                    });\n-                    return as;\n-                })\n-                .matchThenApply();\n-\n-        \/\/ Eliminate\n-        Op ef = f.transform(CodeContext.create(), (block, op) -> {\n-            BiConsumer<Block.Builder, Op> a = actions.get(op.result());\n-            if (a != null) {\n-                a.accept(block, op);\n-            } else {\n-                block.op(op);\n-            }\n-            return block;\n-        });\n-\n-        \/\/ Remove dead ops\n-        ef = ef.transform(CodeContext.create(), (block, op) -> {\n-            if (!(op instanceof Op.Pure) ||\n-                    !op.result().uses().isEmpty()) {\n-                block.op(op);\n-            }\n-            return block;\n-        });\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T t = (T) ef;\n-        return t;\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/ExpressionElimination.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"}]}