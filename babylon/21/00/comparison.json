{"files":[{"patch":"@@ -532,0 +532,24 @@\n+                    case AndOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::and(TypeKind)\n+                            case IntType, BooleanType -> cob.iand();\n+                            case LongType -> cob.land();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case OrOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::or(TypeKind)\n+                            case IntType, BooleanType -> cob.ior();\n+                            case LongType -> cob.lor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case XorOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::xor(TypeKind)\n+                            case IntType, BooleanType -> cob.ixor();\n+                            case LongType -> cob.lxor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -78,0 +78,8 @@\n+    public static int and(int l, int r) {\n+        return l & r;\n+    }\n+\n+    public static int xor(int l, int r) {\n+        return l ^ r;\n+    }\n+\n@@ -132,0 +140,9 @@\n+    public static long and(long l, long r) {\n+        return l & r;\n+    }\n+\n+    public static long xor(long l, long r) {\n+        return l ^ r;\n+    }\n+\n+\n@@ -180,0 +197,4 @@\n+    static float mod(float l, float r) {\n+        return l % r;\n+    }\n+\n@@ -228,0 +249,28 @@\n+    static double mod(double l, double r) {\n+        return l % r;\n+    }\n+\n+\n+\n+    \/\/ boolean\n+\n+    static boolean eq(boolean l, boolean r) {\n+        return l == r;\n+    }\n+\n+    static boolean neq(boolean l, boolean r) {\n+        return l != r;\n+    }\n+\n+    static boolean and(boolean l, boolean r) {\n+        return l & r;\n+    }\n+\n+    static boolean or(boolean l, boolean r) {\n+        return l | r;\n+    }\n+\n+    static boolean xor(boolean l, boolean r) {\n+        return l ^ r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.code.TypeElement;\n@@ -2554,1 +2553,1 @@\n-     * The dic operation, that can model the Java language binary {@code \/} operator for numeric types\n+     * The div operation, that can model the Java language binary {@code \/} operator for numeric types\n@@ -2579,1 +2578,1 @@\n-     * The div operation, that can model the Java language binary {@code %} operator for numeric types\n+     * The mod operation, that can model the Java language binary {@code %} operator for numeric types\n@@ -2603,0 +2602,78 @@\n+    \/**\n+     * The bitwise\/logical or operation, that can model the Java language binary {@code |} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpDeclaration(OrOp.NAME)\n+    public static final class OrOp extends BinaryOp {\n+        public static final String NAME = \"or\";\n+\n+        public OrOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        OrOp(OrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new OrOp(this, cc);\n+        }\n+\n+        OrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The bitwise\/logical and operation, that can model the Java language binary {@code &} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpDeclaration(AndOp.NAME)\n+    public static final class AndOp extends BinaryOp {\n+        public static final String NAME = \"and\";\n+\n+        public AndOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        AndOp(AndOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AndOp(this, cc);\n+        }\n+\n+        AndOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The xor operation, that can model the Java language binary {@code ^} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpDeclaration(XorOp.NAME)\n+    public static final class XorOp extends BinaryOp {\n+        public static final String NAME = \"xor\";\n+\n+        public XorOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        XorOp(XorOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public XorOp transform(CopyContext cc, OpTransformer ot) {\n+            return new XorOp(this, cc);\n+        }\n+\n+        XorOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n@@ -3467,0 +3544,33 @@\n+    \/**\n+     * Creates a bitwise\/logical or operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the or operation\n+     *\/\n+    public static BinaryOp or(Value lhs, Value rhs) {\n+        return new OrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical and operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the and operation\n+     *\/\n+    public static BinaryOp and(Value lhs, Value rhs) {\n+        return new AndOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical xor operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp xor(Value lhs, Value rhs) {\n+        return new XorOp(lhs, rhs);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":113,"deletions":3,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -430,0 +430,1 @@\n+                        Tag.BITOR, Tag.BITAND, Tag.BITXOR,\n@@ -2039,0 +2040,5 @@\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR -> append(CoreOps.or(lhs, rhs));\n+                    case BITAND -> append(CoreOps.and(lhs, rhs));\n+                    case BITXOR -> append(CoreOps.xor(lhs, rhs));\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,98 @@\n+    @CodeReflection\n+    public static int bitand(int a, int b) {\n+        return a & b;\n+    }\n+\n+    @Test\n+    public void testBitand() {\n+        CoreOps.FuncOp f = getFuncOp(\"bitand\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitand(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static int bitor(int a, int b) {\n+        return a | b;\n+    }\n+\n+    @Test\n+    public void testBitor() {\n+        CoreOps.FuncOp f = getFuncOp(\"bitor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitor(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static int bitxor(int a, int b) {\n+        return a ^ b;\n+    }\n+\n+    @Test\n+    public void testBitxor() {\n+        CoreOps.FuncOp f = getFuncOp(\"bitxor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitxor(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static boolean booland(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test\n+    public void testBooland() {\n+        CoreOps.FuncOp f = getFuncOp(\"booland\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, true, false), booland(true, false));\n+    }\n+\n+    @CodeReflection\n+    public static boolean boolor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test\n+    public void testBoolor() {\n+        CoreOps.FuncOp f = getFuncOp(\"boolor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, false, true), boolor(false, true));\n+    }\n+\n+    @CodeReflection\n+    public static boolean boolxor(boolean a, boolean b) {\n+        return a ^ b;\n+    }\n+\n+    @Test\n+    public void testBoolxor() {\n+        CoreOps.FuncOp f = getFuncOp(\"boolxor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, true, true), boolxor(true, true));\n+    }\n+\n+    @CodeReflection\n+    public static double doublemod(double a, double b) {\n+        return a % b;\n+    }\n+\n+    @Test\n+    public void testDoublemod() {\n+        CoreOps.FuncOp f = getFuncOp(\"doublemod\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 15.6, 2.1), doublemod(15.6, 2.1));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -231,0 +231,13 @@\n+    @CodeReflection\n+    public static boolean xor(boolean a, boolean b) {\n+        return a ^ b;\n+    }\n+\n+    @Test\n+    public void testXor() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"xor\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((boolean) mh.invoke(true, false), xor(true, false));\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}