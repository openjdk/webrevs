{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.classfile.ClassModel;\n@@ -35,0 +34,1 @@\n+import java.lang.classfile.instruction.SwitchCase;\n@@ -49,0 +49,10 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SequencedMap;\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -50,0 +60,2 @@\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeTransformer;\n@@ -55,0 +67,1 @@\n+import jdk.incubator.code.bytecode.impl.ExceptionTableCompactor;\n@@ -63,10 +76,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n@@ -74,2 +77,0 @@\n-import java.util.LinkedHashMap;\n-import java.util.SequencedMap;\n@@ -83,0 +84,50 @@\n+    static final class ConstantLabelSwitchOp extends Op implements Op.BlockTerminating {\n+\n+        final List<Integer> labels;\n+        final List<Block.Reference> targets;\n+\n+        ConstantLabelSwitchOp(Value intSelector, List<Integer> labels, List<Block.Reference> targets) {\n+            super(List.of(intSelector));\n+            assert targets.size() == labels.size() + 1; \/\/ last is the default target\n+            this.labels = labels;\n+            this.targets = targets;\n+        }\n+\n+        @Override\n+        public Op transform(CodeContext cc, CodeTransformer ot) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return targets;\n+        }\n+\n+        @Override\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", labels);\n+        }\n+    }\n+\n+    \/**\n+     * A transformer that lowers operations unsupported by BytecodeGenerator.\n+     *\/\n+    static CodeTransformer BYTECODE_LOWERING_TRANSFORMER = (block, op) -> {\n+        return switch (op) {\n+\/\/            case JavaOp.JavaSwitchOp swop when isConstantLabelSwitch(swop)-> {\n+\/\/               @@@ lower JavaOp.JavaSwitchOp to ConstantLabelSwitchOp\n+\/\/            }\n+            case Op.Lowerable lop ->\n+                lop.lower(block, null);\n+            default -> {\n+                block.op(op);\n+                yield block;\n+            }\n+        };\n+    };\n+\n@@ -139,3 +190,1 @@\n-        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, fop.funcName(), fop));\n-        \/\/ Compact locals of the generated bytecode\n-        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+        return generateClassData(lookup, fop.funcName(), fop);\n@@ -155,3 +204,1 @@\n-        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, clName, mop.functionTable()));\n-        \/\/ Compact locals of the generated bytecode\n-        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+        return generateClassData(lookup, clName, mop.functionTable());\n@@ -179,0 +226,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -182,2 +230,2 @@\n-\n-        byte[] classBytes = ClassFile.of().build(clName, clb -> {\n+        byte[] classBytes;\n+        classBytes = ClassFile.of().build(clName, clb -> {\n@@ -187,1 +235,2 @@\n-                generateMethod(lookup, clName, e.getKey(), e.getValue(), clb, ops, lambdaSink, quotable);\n+                O lowered = (O)e.getValue().transform(CodeContext.create(), BYTECODE_LOWERING_TRANSFORMER);\n+                generateMethod(lookup, clName, e.getKey(), lowered, clb, ops, lambdaSink, quotable);\n@@ -194,6 +243,6 @@\n-                        ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n-                                .loadConstant(Quoted.embedOp(lop).toText())\n-                                .invoke(Opcode.INVOKESTATIC, OpParser.class.describeConstable().get(),\n-                                        \"fromStringOfJavaCodeModel\",\n-                                        MethodTypeDesc.of(Op.class.describeConstable().get(), CD_String), false)\n-                                .areturn()));\n+                            ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n+                                    .loadConstant(Quoted.embedOp(lop).toText())\n+                                    .invoke(Opcode.INVOKESTATIC, OpParser.class.describeConstable().get(),\n+                                            \"fromStringOfJavaCodeModel\",\n+                                            MethodTypeDesc.of(Op.class.describeConstable().get(), CD_String), false)\n+                                    .areturn()));\n@@ -204,1 +253,3 @@\n-        return classBytes;\n+\n+        \/\/ Compact locals of the generated bytecode\n+        return LocalsCompactor.transform(classBytes);\n@@ -215,1 +266,0 @@\n-\n@@ -221,1 +271,1 @@\n-                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                cb -> cb.transforming(new BranchCompactor().andThen(new ExceptionTableCompactor()), cob ->\n@@ -1010,0 +1060,19 @@\n+                case ConstantLabelSwitchOp op -> {\n+                    op.targets.forEach(t -> setCatchStack(t, recentCatchBlocks));\n+                    var cases = new ArrayList<SwitchCase>();\n+                    int lo = Integer.MAX_VALUE;\n+                    int hi = Integer.MIN_VALUE;\n+                    for (int i = 0; i < op.labels.size(); i++) {\n+                        int val = op.labels.get(i);\n+                        cases.add(SwitchCase.of(val, getLabel(op.targets.get(i))));\n+                        if (val < lo) lo = val;\n+                        if (val > hi) hi = val;\n+                    }\n+                    Label defTarget = getLabel(op.targets.getLast());\n+                    processFirstOperand(op);\n+                    if (tableSwitchOverLookupSwitch(lo, hi, cases.size())) {\n+                        cob.tableswitch(defTarget, cases);\n+                    } else {\n+                        cob.lookupswitch(defTarget, cases);\n+                    }\n+                }\n@@ -1069,0 +1138,13 @@\n+    \/\/ Determine whether to issue a tableswitch or a lookupswitch\n+    \/\/ instruction.\n+    private static boolean tableSwitchOverLookupSwitch(long lo, long hi, long nlabels) {\n+            long table_space_cost = 4 + (hi - lo + 1); \/\/ words\n+            long table_time_cost = 3; \/\/ comparisons\n+            long lookup_space_cost = 3 + 2 * nlabels;\n+            long lookup_time_cost = nlabels;\n+            return\n+                nlabels > 0 &&\n+                table_space_cost + 3 * table_time_cost <=\n+                lookup_space_cost + 3 * lookup_time_cost;\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":113,"deletions":31,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.bytecode.impl;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.instruction.ExceptionCatch;\n+\n+\/**\n+ * ExceptionTableCompactor defragments exception table.\n+ *\/\n+public final class ExceptionTableCompactor implements CodeTransform {\n+\n+    ExceptionCatch last = null;\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        if (coe instanceof ExceptionCatch ec) {\n+            if (ec.tryStart() != ec.tryEnd()) {\n+                if (last != null) {\n+                    if (last.handler() == ec.handler() && last.catchType().equals(ec.catchType())) {\n+                        if (last.tryStart() == ec.tryEnd()) {\n+                            last = ExceptionCatch.of(last.handler(), ec.tryStart(), last.tryEnd(), last.catchType());\n+                            return;\n+                        } else if (last.tryEnd() == ec.tryStart()) {\n+                            last = ExceptionCatch.of(last.handler(), last.tryStart(), ec.tryEnd(), last.catchType());\n+                            return;\n+                        }\n+                    }\n+                    cob.with(last);\n+                }\n+                last = ec;\n+            }\n+        } else {\n+            cob.with(coe);\n+        }\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        if (last != null) {\n+            cob.with(last);\n+            last = null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/ExceptionTableCompactor.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n+import java.lang.classfile.ClassFile;\n@@ -32,1 +30,0 @@\n-import java.lang.classfile.CodeTransform;\n@@ -38,1 +35,0 @@\n-import java.lang.classfile.instruction.ExceptionCatch;\n@@ -108,15 +104,21 @@\n-    static class ExceptionTableCompactor implements CodeTransform {\n-        ExceptionCatch last = null;\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            if (coe instanceof ExceptionCatch ec) {\n-                if (ec.tryStart() != ec.tryEnd()) {\n-                    if (last != null) {\n-                        if (last.handler() == ec.handler() && last.catchType().equals(ec.catchType())) {\n-                            if (last.tryStart() == ec.tryEnd()) {\n-                                last = ExceptionCatch.of(last.handler(), ec.tryStart(), last.tryEnd(), last.catchType());\n-                                return;\n-                            } else if (last.tryEnd() == ec.tryStart()) {\n-                                last = ExceptionCatch.of(last.handler(), last.tryStart(), ec.tryEnd(), last.catchType());\n-                                return;\n+    \/**\n+     * LocalsCompactor transformation requires complete class file binary\n+     * @param classBytes class file binary to transform\n+     * @return transformed class file binary\n+     *\/\n+    public static byte[] transform(byte[] classBytes) {\n+        return ClassFile.of().transformClass(ClassFile.of().parse(classBytes), (clb,cle) -> {\n+            if (cle instanceof MethodModel mm) {\n+                clb.transformMethod(mm, (mb, me) -> {\n+                    if (me instanceof CodeModel com) {\n+                        int[] slotMap = new LocalsCompactor(com, countParamSlots(mm)).slotMap;\n+                        mb.transformCode(com, (cob, coe) -> {\n+                            switch (coe) {\n+                                case LoadInstruction li ->\n+                                    cob.loadLocal(li.typeKind(), slotMap[li.slot()]);\n+                                case StoreInstruction si ->\n+                                    cob.storeLocal(si.typeKind(), slotMap[si.slot()]);\n+                                case IncrementInstruction ii ->\n+                                    cob.iinc(slotMap[ii.slot()], ii.constant());\n+                                default ->\n+                                    cob.with(coe);\n@@ -124,2 +126,3 @@\n-                        }\n-                        cob.with(last);\n+                        });\n+                    } else {\n+                        mb.with(me);\n@@ -127,2 +130,1 @@\n-                    last = ec;\n-                }\n+                });\n@@ -130,9 +132,1 @@\n-                cob.with(coe);\n-            }\n-        }\n-\n-        @Override\n-        public void atEnd(CodeBuilder cob) {\n-            if (last != null) {\n-                cob.with(last);\n-                last = null;\n+                clb.with(cle);\n@@ -140,1 +134,1 @@\n-        }\n+        });\n@@ -143,27 +137,0 @@\n-    public static final ClassTransform INSTANCE = (clb,cle) -> {\n-        if (cle instanceof MethodModel mm) {\n-            clb.transformMethod(mm, (mb, me) -> {\n-                if (me instanceof CodeModel com) {\n-                    int[] slotMap = new LocalsCompactor(com, countParamSlots(mm)).slotMap;\n-                    \/\/ @@@ ExceptionTableCompactor can be chained on ClassTransform level when the recent Class-File API is merged into code-reflection\n-                    mb.transformCode(com, new ExceptionTableCompactor().andThen((cob, coe) -> {\n-                        switch (coe) {\n-                            case LoadInstruction li ->\n-                                cob.loadLocal(li.typeKind(), slotMap[li.slot()]);\n-                            case StoreInstruction si ->\n-                                cob.storeLocal(si.typeKind(), slotMap[si.slot()]);\n-                            case IncrementInstruction ii ->\n-                                cob.iinc(slotMap[ii.slot()], ii.constant());\n-                            default ->\n-                                cob.with(coe);\n-                        }\n-                    }));\n-                } else {\n-                    mb.with(me);\n-                }\n-            });\n-        } else {\n-            clb.with(cle);\n-        }\n-    };\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LocalsCompactor.java","additions":29,"deletions":62,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-        FuncOp funcOp = func(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class))).body(b -> {\n+        return func(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class))).body(b -> {\n@@ -402,1 +402,0 @@\n-        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,4 +104,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -645,1 +645,0 @@\n-        CoreOp.FuncOp lfunc;\n@@ -647,7 +646,1 @@\n-            lfunc = func.transform(CodeContext.create(), CodeTransformer.LOWERING_TRANSFORMER);\n-        } catch (UnsupportedOperationException uoe) {\n-            throw new TestSkippedException(\"lowering caused:\", uoe);\n-        }\n-\n-        try {\n-            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lfunc);\n+            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), func);\n@@ -670,1 +663,0 @@\n-            System.out.println(lfunc.toText());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,4 +82,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,4 +82,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,4 +145,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-        f = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -87,1 +86,0 @@\n-        f = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,4 +263,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -199,4 +199,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -222,4 +222,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-        var lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n@@ -40,1 +37,1 @@\n-        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-                module.functionTable().get(fExpected.funcName()));\n+                module.transform(CodeTransformer.LOWERING_TRANSFORMER).functionTable().get(fExpected.funcName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}