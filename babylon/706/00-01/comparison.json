{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.incubator.code.bytecode.impl.ConstantLabelSwitchOp;\n@@ -84,33 +85,0 @@\n-    static final class ConstantLabelSwitchOp extends Op implements Op.BlockTerminating {\n-\n-        final List<Integer> labels;\n-        final List<Block.Reference> targets;\n-\n-        ConstantLabelSwitchOp(Value intSelector, List<Integer> labels, List<Block.Reference> targets) {\n-            super(List.of(intSelector));\n-            assert targets.size() == labels.size() + 1; \/\/ last is the default target\n-            this.labels = labels;\n-            this.targets = targets;\n-        }\n-\n-        @Override\n-        public Op transform(CodeContext cc, CodeTransformer ot) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return targets;\n-        }\n-\n-        @Override\n-        public Map<String, Object> externalize() {\n-            return Map.of(\"\", labels);\n-        }\n-    }\n-\n@@ -1061,1 +1029,1 @@\n-                    op.targets.forEach(t -> setCatchStack(t, recentCatchBlocks));\n+                    op.successors().forEach(t -> setCatchStack(t, recentCatchBlocks));\n@@ -1065,3 +1033,3 @@\n-                    for (int i = 0; i < op.labels.size(); i++) {\n-                        int val = op.labels.get(i);\n-                        cases.add(SwitchCase.of(val, getLabel(op.targets.get(i))));\n+                    for (int i = 0; i < op.labels().size(); i++) {\n+                        int val = op.labels().get(i);\n+                        cases.add(SwitchCase.of(val, getLabel(op.successors().get(i))));\n@@ -1071,1 +1039,1 @@\n-                    Label defTarget = getLabel(op.targets.getLast());\n+                    Label defTarget = getLabel(op.successors().getLast());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":7,"deletions":39,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.bytecode.impl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+public final class ConstantLabelSwitchOp extends Op implements Op.BlockTerminating {\n+\n+    final List<Integer> labels;\n+    final List<Block.Reference> targets;\n+\n+    public ConstantLabelSwitchOp(Value intSelector, List<Integer> labels, List<Block.Reference> targets) {\n+        super(List.of(intSelector));\n+        assert targets.size() == labels.size() + 1; \/\/ last is the default target\n+        this.labels = labels;\n+        this.targets = targets;\n+    } \/\/ last is the default target\n+\n+    ConstantLabelSwitchOp(ConstantLabelSwitchOp that, CodeContext cc) {\n+        super(that, cc);\n+        this.labels = that.labels;\n+        this.targets = that.targets.stream().map(cc::getSuccessorOrCreate).toList();\n+    }\n+\n+    @Override\n+    public ConstantLabelSwitchOp transform(CodeContext cc, CodeTransformer ot) {\n+        return new ConstantLabelSwitchOp(this, cc);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return JavaType.VOID;\n+    }\n+\n+    public List<Integer> labels() {\n+        return labels;\n+    }\n+\n+    @Override\n+    public List<Block.Reference> successors() {\n+        return targets;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"\", labels);\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/ConstantLabelSwitchOp.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.bytecode.impl.ConstantLabelSwitchOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\/jdk.incubator.code.bytecode.impl\n+ * @run junit TestSwitch\n+ *\/\n+public class TestSwitch {\n+\n+    @Reflect\n+    static String switchExpression(int i) {\n+        return switch (i) {\n+            case 7 -> \"magic number\";\n+            case 42 -> \"Answer to the Ultimate Question of Life, the Universe, and Everything\";\n+            case 101 -> \"introduction to a subject\";\n+            default -> \"not important\";\n+        };\n+    }\n+\n+    @Test\n+    public void switchExpression() throws Throwable {\n+\/\/        CoreOp.FuncOp f = getFuncOp(\"switchExpression\");\n+\n+        \/\/ @@@ manually constructed:\n+        \/\/ func @\"switchExpression\" (%0 : java.type:\"int\")java.type:\"java.lang.String\" -> {\n+        \/\/    %1 : Var<java.type:\"int\"> = var %0 @\"i\";\n+        \/\/    %2 : java.type:\"int\" = var.load %1;\n+        \/\/    ConstantLabelSwitchOp %2 @\"[7,42,101]\" ^block_1 ^block_2 ^block_3 ^block_4;\n+        \/\/\n+        \/\/  ^block_1:\n+        \/\/    %3 : java.type:\"java.lang.String\" = constant @\"magic number\";\n+        \/\/    branch ^block_5(%3);\n+        \/\/\n+        \/\/  ^block_2:\n+        \/\/    %4 : java.type:\"java.lang.String\" = constant @\"Answer to the Ultimate Question of Life, the Universe, and Everything\";\n+        \/\/    branch ^block_5(%4);\n+        \/\/\n+        \/\/  ^block_3:\n+        \/\/    %5 : java.type:\"java.lang.String\" = constant @\"introduction to a subject\";\n+        \/\/    branch ^block_5(%5);\n+        \/\/\n+        \/\/  ^block_4:\n+        \/\/    %6 : java.type:\"java.lang.String\" = constant @\"not important\";\n+        \/\/    branch ^block_5(%6);\n+        \/\/\n+        \/\/  ^block_5(%7 : java.type:\"java.lang.String\"):\n+        \/\/    return %7;\n+        \/\/};\n+        JavaType stringType = JavaType.type(String.class);\n+        CoreOp.FuncOp f = CoreOp.FuncOp.func(\"switchExpression\",\n+                CoreType.functionType(stringType, JavaType.INT)).body(bb -> {\n+                    Block.Builder b0 = bb.entryBlock(),\n+                                  b1 = bb.block(),\n+                                  b2 = bb.block(),\n+                                  b3 = bb.block(),\n+                                  b4 = bb.block(),\n+                                  b5 = bb.block(stringType);\n+                    Value v1 = b0.op(CoreOp.var(\"i\", JavaType.INT, b0.parameters().getFirst()));\n+                    Value v2 = b0.op(CoreOp.varLoad(v1));\n+                    b0.op(new ConstantLabelSwitchOp(v2,\n+                            List.of(7, 42, 101),\n+                            List.of(b1.successor(), b2.successor(), b3.successor(), b4.successor())));\n+                    b1.op(CoreOp.branch(b5.successor(b1.op(CoreOp.constant(stringType, \"magic number\")))));\n+                    b2.op(CoreOp.branch(b5.successor(b2.op(CoreOp.constant(stringType, \"Answer to the Ultimate Question of Life, the Universe, and Everything\")))));\n+                    b3.op(CoreOp.branch(b5.successor(b3.op(CoreOp.constant(stringType, \"introduction to a subject\")))));\n+                    b4.op(CoreOp.branch(b5.successor(b4.op(CoreOp.constant(stringType, \"not important\")))));\n+                    b5.op(CoreOp.return_(b5.parameters().getFirst()));\n+                });\n+\n+        MethodHandle mh = generate(f);\n+\n+        for (int i = 0; i < 110; i++) {\n+            Assertions.assertEquals(switchExpression(i), (String)mh.invokeExact(i));\n+        }\n+    }\n+\n+    static MethodHandle generate(CoreOp.FuncOp f) {\n+        System.out.println(f.toText());\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return Op.ofMethod(m).get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}