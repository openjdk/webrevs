{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.ClassModel;\n@@ -35,0 +34,1 @@\n+import java.lang.classfile.instruction.SwitchCase;\n@@ -49,5 +49,4 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import jdk.incubator.code.*;\n@@ -55,0 +54,2 @@\n+import jdk.incubator.code.bytecode.impl.ConstantLabelSwitchOp;\n+import jdk.incubator.code.bytecode.impl.ExceptionTableCompactor;\n@@ -56,0 +57,1 @@\n+import jdk.incubator.code.bytecode.impl.LoweringTransform;\n@@ -63,10 +65,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n@@ -74,2 +66,0 @@\n-import java.util.LinkedHashMap;\n-import java.util.SequencedMap;\n@@ -139,3 +129,1 @@\n-        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, fop.funcName(), fop));\n-        \/\/ Compact locals of the generated bytecode\n-        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+        return generateClassData(lookup, fop.funcName(), fop);\n@@ -155,3 +143,1 @@\n-        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, clName, mop.functionTable()));\n-        \/\/ Compact locals of the generated bytecode\n-        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+        return generateClassData(lookup, clName, mop.functionTable());\n@@ -179,0 +165,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -182,1 +169,0 @@\n-\n@@ -186,0 +172,1 @@\n+            CodeTransformer lowering = LoweringTransform.getInstance(lookup);\n@@ -187,1 +174,2 @@\n-                generateMethod(lookup, clName, e.getKey(), e.getValue(), clb, ops, lambdaSink, quotable);\n+                O lowered = (O)e.getValue().transform(CodeContext.create(), lowering);\n+                generateMethod(lookup, clName, e.getKey(), lowered, clb, ops, lambdaSink, quotable);\n@@ -194,6 +182,6 @@\n-                        ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n-                                .loadConstant(Quoted.embedOp(lop).toText())\n-                                .invoke(Opcode.INVOKESTATIC, OpParser.class.describeConstable().get(),\n-                                        \"fromStringOfJavaCodeModel\",\n-                                        MethodTypeDesc.of(Op.class.describeConstable().get(), CD_String), false)\n-                                .areturn()));\n+                            ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n+                                    .loadConstant(Quoted.embedOp(lop).toText())\n+                                    .invoke(Opcode.INVOKESTATIC, OpParser.class.describeConstable().get(),\n+                                            \"fromStringOfJavaCodeModel\",\n+                                            MethodTypeDesc.of(Op.class.describeConstable().get(), CD_String), false)\n+                                    .areturn()));\n@@ -204,1 +192,3 @@\n-        return classBytes;\n+\n+        \/\/ Compact locals of the generated bytecode\n+        return LocalsCompactor.transform(classBytes);\n@@ -215,1 +205,0 @@\n-\n@@ -221,1 +210,1 @@\n-                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                cb -> cb.transforming(new BranchCompactor().andThen(new ExceptionTableCompactor()), cob ->\n@@ -1010,0 +999,27 @@\n+                case ConstantLabelSwitchOp op -> {\n+                    op.successors().forEach(t -> setCatchStack(t, recentCatchBlocks));\n+                    var cases = new ArrayList<SwitchCase>();\n+                    int lo = Integer.MAX_VALUE;\n+                    int hi = Integer.MIN_VALUE;\n+                    Label defTarget = null;\n+                    for (int i = 0; i < op.labels().size(); i++) {\n+                        Integer val = op.labels().get(i);\n+                        Label target = getLabel(op.successors().get(i));\n+                        if (val == null) { \/\/ default target has null label value\n+                            defTarget = target;\n+                        } else {\n+                            cases.add(SwitchCase.of(val, target));\n+                            if (val < lo) lo = val;\n+                            if (val > hi) hi = val;\n+                        }\n+                    }\n+                    if (defTarget == null) {\n+                        throw new IllegalArgumentException(\"Missing default target\");\n+                    }\n+                    processFirstOperand(op);\n+                    if (tableSwitchOverLookupSwitch(lo, hi, cases.size())) {\n+                        cob.tableswitch(defTarget, cases);\n+                    } else {\n+                        cob.lookupswitch(defTarget, cases);\n+                    }\n+                }\n@@ -1069,0 +1085,13 @@\n+    \/\/ Determine whether to issue a tableswitch or a lookupswitch\n+    \/\/ instruction.\n+    private static boolean tableSwitchOverLookupSwitch(long lo, long hi, long nlabels) {\n+            long table_space_cost = 4 + (hi - lo + 1); \/\/ words\n+            long table_time_cost = 3; \/\/ comparisons\n+            long lookup_space_cost = 3 + 2 * nlabels;\n+            long lookup_time_cost = nlabels;\n+            return\n+                nlabels > 0 &&\n+                table_space_cost + 3 * table_time_cost <=\n+                lookup_space_cost + 3 * lookup_time_cost;\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":65,"deletions":36,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.bytecode.impl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+\/**\n+ * The terminating conditional multi-branch operation modeling {@code tableswitch} and {@code lookupswitch} instructions.\n+ * <p>\n+ * This operation accepts an int operand, variable number of distinct constant labels\n+ * and the same number of successors.\n+ * When the operand is matching one of the labels, the relevant successor is selected.\n+ * If none of the labels is matching, the default successor is selected.\n+ * Default is a successor with corresponds null label value.\n+ * The selected successor refers to the next block to branch to.\n+ *\/\n+public final class ConstantLabelSwitchOp extends Op implements Op.BlockTerminating {\n+\n+    final List<Integer> labels;\n+    final List<Block.Reference> targets;\n+\n+    public ConstantLabelSwitchOp(Value intSelector, List<Integer> labels, List<Block.Reference> targets) {\n+        super(List.of(intSelector));\n+        assert targets.size() == labels.size();\n+        this.labels = labels;\n+        this.targets = targets;\n+    }\n+\n+    ConstantLabelSwitchOp(ConstantLabelSwitchOp that, CodeContext cc) {\n+        super(that, cc);\n+        this.labels = that.labels;\n+        this.targets = that.targets.stream().map(cc::getSuccessorOrCreate).toList();\n+    }\n+\n+    @Override\n+    public ConstantLabelSwitchOp transform(CodeContext cc, CodeTransformer ot) {\n+        return new ConstantLabelSwitchOp(this, cc);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return JavaType.VOID;\n+    }\n+\n+    public List<Integer> labels() {\n+        return labels;\n+    }\n+\n+    @Override\n+    public List<Block.Reference> successors() {\n+        return targets;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"\", labels);\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/ConstantLabelSwitchOp.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.bytecode.impl;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.instruction.ExceptionCatch;\n+\n+\/**\n+ * ExceptionTableCompactor defragments exception table.\n+ *\/\n+public final class ExceptionTableCompactor implements CodeTransform {\n+\n+    ExceptionCatch last = null;\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        if (coe instanceof ExceptionCatch ec) {\n+            if (ec.tryStart() != ec.tryEnd()) {\n+                if (last != null) {\n+                    if (last.handler() == ec.handler() && last.catchType().equals(ec.catchType())) {\n+                        if (last.tryStart() == ec.tryEnd()) {\n+                            last = ExceptionCatch.of(last.handler(), ec.tryStart(), last.tryEnd(), last.catchType());\n+                            return;\n+                        } else if (last.tryEnd() == ec.tryStart()) {\n+                            last = ExceptionCatch.of(last.handler(), last.tryStart(), ec.tryEnd(), last.catchType());\n+                            return;\n+                        }\n+                    }\n+                    cob.with(last);\n+                }\n+                last = ec;\n+            }\n+        } else {\n+            cob.with(coe);\n+        }\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        if (last != null) {\n+            cob.with(last);\n+            last = null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/ExceptionTableCompactor.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n+import java.lang.classfile.ClassFile;\n@@ -32,1 +30,0 @@\n-import java.lang.classfile.CodeTransform;\n@@ -38,1 +35,0 @@\n-import java.lang.classfile.instruction.ExceptionCatch;\n@@ -108,15 +104,21 @@\n-    static class ExceptionTableCompactor implements CodeTransform {\n-        ExceptionCatch last = null;\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            if (coe instanceof ExceptionCatch ec) {\n-                if (ec.tryStart() != ec.tryEnd()) {\n-                    if (last != null) {\n-                        if (last.handler() == ec.handler() && last.catchType().equals(ec.catchType())) {\n-                            if (last.tryStart() == ec.tryEnd()) {\n-                                last = ExceptionCatch.of(last.handler(), ec.tryStart(), last.tryEnd(), last.catchType());\n-                                return;\n-                            } else if (last.tryEnd() == ec.tryStart()) {\n-                                last = ExceptionCatch.of(last.handler(), last.tryStart(), ec.tryEnd(), last.catchType());\n-                                return;\n+    \/**\n+     * LocalsCompactor transformation requires complete class file binary\n+     * @param classBytes class file binary to transform\n+     * @return transformed class file binary\n+     *\/\n+    public static byte[] transform(byte[] classBytes) {\n+        return ClassFile.of().transformClass(ClassFile.of().parse(classBytes), (clb,cle) -> {\n+            if (cle instanceof MethodModel mm) {\n+                clb.transformMethod(mm, (mb, me) -> {\n+                    if (me instanceof CodeModel com) {\n+                        int[] slotMap = new LocalsCompactor(com, countParamSlots(mm)).slotMap;\n+                        mb.transformCode(com, (cob, coe) -> {\n+                            switch (coe) {\n+                                case LoadInstruction li ->\n+                                    cob.loadLocal(li.typeKind(), slotMap[li.slot()]);\n+                                case StoreInstruction si ->\n+                                    cob.storeLocal(si.typeKind(), slotMap[si.slot()]);\n+                                case IncrementInstruction ii ->\n+                                    cob.iinc(slotMap[ii.slot()], ii.constant());\n+                                default ->\n+                                    cob.with(coe);\n@@ -124,2 +126,3 @@\n-                        }\n-                        cob.with(last);\n+                        });\n+                    } else {\n+                        mb.with(me);\n@@ -127,2 +130,1 @@\n-                    last = ec;\n-                }\n+                });\n@@ -130,9 +132,1 @@\n-                cob.with(coe);\n-            }\n-        }\n-\n-        @Override\n-        public void atEnd(CodeBuilder cob) {\n-            if (last != null) {\n-                cob.with(last);\n-                last = null;\n+                clb.with(cle);\n@@ -140,1 +134,1 @@\n-        }\n+        });\n@@ -143,27 +137,0 @@\n-    public static final ClassTransform INSTANCE = (clb,cle) -> {\n-        if (cle instanceof MethodModel mm) {\n-            clb.transformMethod(mm, (mb, me) -> {\n-                if (me instanceof CodeModel com) {\n-                    int[] slotMap = new LocalsCompactor(com, countParamSlots(mm)).slotMap;\n-                    \/\/ @@@ ExceptionTableCompactor can be chained on ClassTransform level when the recent Class-File API is merged into code-reflection\n-                    mb.transformCode(com, new ExceptionTableCompactor().andThen((cob, coe) -> {\n-                        switch (coe) {\n-                            case LoadInstruction li ->\n-                                cob.loadLocal(li.typeKind(), slotMap[li.slot()]);\n-                            case StoreInstruction si ->\n-                                cob.storeLocal(si.typeKind(), slotMap[si.slot()]);\n-                            case IncrementInstruction ii ->\n-                                cob.iinc(slotMap[ii.slot()], ii.constant());\n-                            default ->\n-                                cob.with(coe);\n-                        }\n-                    }));\n-                } else {\n-                    mb.with(me);\n-                }\n-            });\n-        } else {\n-            clb.with(cle);\n-        }\n-    };\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LocalsCompactor.java","additions":29,"deletions":62,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.bytecode.impl;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import jdk.incubator.code.internal.BranchTarget;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import static jdk.incubator.code.dialect.core.CoreOp.YieldOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.branch;\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n+\n+\/**\n+ * Lowering transformer generates models supported by {@code BytecodeGenerator}.\n+ * Constant-labeled switch statements and switch expressions are lowered to\n+ * {@code ConstantLabelSwitchOp} with evaluated labels.\n+ *\/\n+public final class LoweringTransform {\n+\n+    private static Block.Builder lowerToConstantLabelSwitchOp(Block.Builder block, CodeTransformer transformer,\n+                                                              JavaOp.JavaSwitchOp swOp, LabelsAndTargets labelsAndTargets) {\n+        List<Block> targets = labelsAndTargets.targets();\n+        List<Block.Builder> blocks = new ArrayList<>();\n+        for (int i = 0; i < targets.size(); i++) {\n+            Block.Builder bb = block.block();\n+            blocks.add(bb);\n+        }\n+\n+        Block.Builder exit;\n+        if (targets.isEmpty()) {\n+            exit = block;\n+        } else {\n+            if (swOp.resultType() != VOID) {\n+                exit = block.block(swOp.resultType());\n+            } else {\n+                exit = block.block();\n+            }\n+            if (swOp instanceof JavaOp.SwitchExpressionOp) {\n+                exit.context().mapValue(swOp.result(), exit.parameters().get(0));\n+            }\n+        }\n+\n+        BranchTarget.setBranchTarget(block.context(), swOp, exit, null);\n+        \/\/ map statement body to nextExprBlock\n+        \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+        for (int i = 0; i < targets.size() - 1; i++) {\n+            BranchTarget.setBranchTarget(block.context(), targets.get(i).parent(), null, blocks.get(i+1));\n+        }\n+\n+        for (int i = 0; i < targets.size(); i++) {\n+            Block.Builder curr = blocks.get(i);\n+            curr.body(targets.get(i).parent(), blocks.get(i).parameters(), (b, op) -> switch (op) {\n+                case YieldOp _ when swOp instanceof JavaOp.SwitchStatementOp -> {\n+                    b.op(branch(exit.successor()));\n+                    yield b;\n+                }\n+                case YieldOp yop when swOp instanceof JavaOp.SwitchExpressionOp -> {\n+                    b.op(branch(exit.successor(b.context().getValue(yop.yieldValue()))));\n+                    yield b;\n+                }\n+                default -> transformer.acceptOp(b, op);\n+            });\n+        }\n+\n+        Value selector = block.context().getValue(swOp.operands().get(0));\n+        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), blocks.stream().map(Block.Builder::successor).toList()));\n+        return exit;\n+    }\n+\n+    public static CodeTransformer getInstance(MethodHandles.Lookup lookup) {\n+        return (block, op) -> switch (op) {\n+                    case JavaOp.JavaSwitchOp swOp when new ConstantLabelSwitchChecker(swOp, lookup).isCaseConstantSwitch() -> {\n+                        LabelsAndTargets labelsAndTargets = getLabelsAndTargets(lookup, swOp);\n+                        yield lowerToConstantLabelSwitchOp(block, block.transformer(), swOp, labelsAndTargets);\n+                    }\n+                    case Op.Lowerable lop -> lop.lower(block, null);\n+                    default -> {\n+                        block.op(op);\n+                        yield block;\n+                    }\n+                };\n+    }\n+\n+    public static final class ConstantLabelSwitchChecker {\n+        private final MethodHandles.Lookup lookup;\n+        private JavaOp.JavaSwitchOp swOp;\n+\n+        public ConstantLabelSwitchChecker(JavaOp.JavaSwitchOp swOp, MethodHandles.Lookup lookup) {\n+            this.swOp = swOp;\n+            this.lookup = lookup;\n+        }\n+\n+        private static boolean isFinalVar(CoreOp.VarOp varOp) {\n+            return varOp.initOperand() != null && varOp.result().uses().stream().noneMatch(u -> u.op() instanceof CoreOp.VarAccessOp.VarStoreOp);\n+        }\n+\n+        private static boolean isBoxingMethod(MethodRef mr) {\n+            return List.of(J_L_BYTE, J_L_CHARACTER, J_L_SHORT, J_L_INTEGER, J_L_LONG, J_L_FLOAT, J_L_DOUBLE).contains(mr.refType())\n+                    && mr.name().equals(\"valueOf\");\n+        }\n+\n+        private static boolean isIntegralType(TypeElement te) {\n+            return isIntegralPrimitiveType(te) || isIntegralReferenceType(te);\n+        }\n+\n+        private static boolean isIntegralPrimitiveType(TypeElement te) {\n+            return List.of(BYTE, SHORT, CHAR, INT).contains(te);\n+        }\n+\n+        private static boolean isIntegralReferenceType(TypeElement te) {\n+            return List.of(J_L_BYTE, J_L_SHORT, J_L_CHARACTER, J_L_INTEGER).contains(te);\n+        }\n+\n+        private boolean isConstantExpr(Value v) {\n+            if (!(v instanceof Op.Result opr)) {\n+                return false;\n+            }\n+            return switch (opr.op()) {\n+                case CoreOp.ConstantOp cop ->\n+                        cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n+                case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->\n+                        isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand());\n+                case JavaOp.ConvOp convOp ->\n+                        (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n+                                isConstantExpr(convOp.operands().get(0));\n+                case JavaOp.InvokeOp invokeOp ->\n+                        isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0));\n+                case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n+                    Field field;\n+                    try {\n+                        field = fieldLoadOp.fieldDescriptor().resolveToField(lookup);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    yield field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n+                }\n+                case JavaOp.UnaryOp unaryOp -> isConstantExpr(unaryOp.operands().get(0));\n+                case JavaOp.BinaryOp binaryOp -> binaryOp.operands().stream().allMatch(this::isConstantExpr);\n+                case JavaOp.BinaryTestOp binaryTestOp ->\n+                        binaryTestOp.operands().stream().allMatch(this::isConstantExpr);\n+                case JavaOp.ConditionalExpressionOp cexpr -> \/\/ bodies must yield constant expressions\n+                        isConstantExpr(((YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue());\n+\n+                case JavaOp.ConditionalAndOp cand ->\n+                        isConstantExpr(((YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+                case JavaOp.ConditionalOrOp cor ->\n+                    \/\/ we can have a method isBodyYieldConstantExpr(Body)\n+                        isConstantExpr(((YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+                default -> false;\n+            };\n+        }\n+\n+        private boolean isCaseConstantLabel(Body label) {\n+            if (label.blocks().size() != 1 || !(label.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                    !(yop.yieldValue() instanceof Op.Result r)) {\n+                return false;\n+            }\n+\n+            \/\/ EqOp for primitives, method invocation for Strings and Reference Types\n+            return switch (r.op()) {\n+                case JavaOp.EqOp eqOp -> isConstantExpr(eqOp.operands().get(1));\n+                case JavaOp.InvokeOp invokeOp when !invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS) -> false;\n+                case JavaOp.InvokeOp invokeOp -> {\n+                    \/\/ case null\n+                    if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n+                        yield false;\n+                    }\n+                    yield  isConstantExpr(invokeOp.operands().get(1));\n+                }\n+                case JavaOp.ConditionalOrOp cor -> cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b));\n+                default -> r.op() instanceof CoreOp.ConstantOp cop && cop.resultType().equals(BOOLEAN);\n+            };\n+        }\n+\n+        public boolean isCaseConstantSwitch() {\n+            if (!isIntegralType(swOp.operands().get(0).type())) {\n+                return false;\n+            }\n+            for (int i = 0; i < swOp.bodies().size(); i+=2) {\n+                Body label = swOp.bodies().get(i);\n+                if (!isCaseConstantLabel(label)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    record LabelsAndTargets(List<Integer> labels, List<Block> targets) {}\n+\n+    static LabelsAndTargets getLabelsAndTargets(MethodHandles.Lookup lookup, JavaOp.JavaSwitchOp swOp) {\n+        var labels = new ArrayList<Integer>();\n+        var targets = new ArrayList<Block>();\n+        for (int i = 0; i < swOp.bodies().size() - 1; i += 2) {\n+            List<Integer> ls = getLabels(lookup, swOp.bodies().get(i));\n+            labels.addAll(ls);\n+            \/\/ getLabels returns list with null, for case default\n+            targets.addAll(Collections.nCopies(ls.size(), swOp.bodies().get(i + 1).entryBlock()));\n+        }\n+        return new LabelsAndTargets(labels, targets);\n+    }\n+\n+    static final MethodRef OBJECTS_EQUALS = MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class);\n+\n+    static List<Integer> getLabels(MethodHandles.Lookup lookup, Body body) {\n+        if (body.blocks().size() != 1 || !(body.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                !(yop.yieldValue() instanceof Op.Result opr)) {\n+            throw new IllegalStateException(\"Body of a java switch fails the expected structure\");\n+        }\n+        var labels = new ArrayList<Integer>();\n+        switch (opr.op()) {\n+            case JavaOp.EqOp eqOp -> labels.add(extractConstantLabel(lookup, body, eqOp));\n+            case JavaOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS) ->\n+                    labels.add(extractConstantLabel(lookup, body, invokeOp));\n+            case JavaOp.ConditionalOrOp cor -> {\n+                for (Body corbody : cor.bodies()) {\n+                    labels.addAll(getLabels(lookup, corbody));\n+                }\n+            }\n+            case CoreOp.ConstantOp constantOp ->  \/\/ default label\n+                    labels.add(null);\n+            case null, default -> throw new IllegalStateException();\n+        }\n+        return labels;\n+    }\n+\n+    static Integer extractConstantLabel(MethodHandles.Lookup lookup, Body body, Op whenToStop) {\n+        Op lastOp = body.entryBlock().ops().get(body.entryBlock().ops().indexOf(whenToStop) - 1);\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", CoreType.functionType(lastOp.result().type())).body(block -> {\n+            \/\/ in case we refer to constant variables in the label\n+            for (Value capturedValue : body.capturedValues()) {\n+                if (!(capturedValue instanceof Op.Result r) || !(r.op() instanceof CoreOp.VarOp vop)) {\n+                    continue;\n+                }\n+                block.op(((Op.Result) vop.initOperand()).op());\n+                block.op(vop);\n+            }\n+            Op.Result last = null;\n+            for (Op op : body.entryBlock().ops()) {\n+                if (op.equals(whenToStop)) {\n+                    break;\n+                }\n+                last = block.op(op);\n+            }\n+            block.op(CoreOp.return_(last));\n+        });\n+        Object res = Interpreter.invoke(lookup, funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+        return switch (res) {\n+            case Byte b -> Integer.valueOf(b);\n+            case Short s -> Integer.valueOf(s);\n+            case Character c -> Integer.valueOf(c);\n+            case Integer i -> i;\n+            default -> throw new IllegalStateException(); \/\/ @@@ not going to happen\n+        };\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LoweringTransform.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.incubator.code.internal.BranchTarget;\n@@ -2073,1 +2074,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), opt);\n+            BranchTarget t = BranchTarget.getBranchTarget(b.context(), opt);\n@@ -2148,21 +2149,0 @@\n-    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n-    }\n-\n-    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n-\n-    static BranchTarget getBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n-        if (m != null) {\n-            return m.get(codeElement);\n-        }\n-        return null;\n-    }\n-\n-    static void setBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n-                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n-        x.put(codeElement, t);\n-    }\n-\n@@ -2220,1 +2200,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), opt);\n+            BranchTarget t = BranchTarget.getBranchTarget(b.context(), opt);\n@@ -2301,1 +2281,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2392,1 +2372,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2527,1 +2507,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2711,1 +2691,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2836,1 +2816,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2840,1 +2820,1 @@\n-                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+                BranchTarget.setBranchTarget(b.context(), bodies().get(i), null, blocks.get(i + 2));\n@@ -3017,1 +2997,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), ancestorBody());\n+            BranchTarget t = BranchTarget.getBranchTarget(b.context(), ancestorBody());\n@@ -3246,1 +3226,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, update);\n@@ -3463,1 +3443,1 @@\n-                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+                BranchTarget.setBranchTarget(b.context(), this, exit, update);\n@@ -3489,1 +3469,1 @@\n-                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+                BranchTarget.setBranchTarget(b.context(), this, exit, header);\n@@ -3621,1 +3601,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, header);\n@@ -3742,1 +3722,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, header);\n@@ -4030,1 +4010,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -4266,1 +4246,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":18,"deletions":38,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeElement;\n+\n+\n+public record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+\n+    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n+\n+    public static BranchTarget getBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget> m = (Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(codeElement);\n+        }\n+        return null;\n+    }\n+\n+    public static void setBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement, Block.Builder breakBlock, Block.Builder continueBlock) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget> x = (Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(codeElement, new BranchTarget(breakBlock, continueBlock));\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/BranchTarget.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -362,1 +362,1 @@\n-        FuncOp funcOp = func(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class))).body(b -> {\n+        return func(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class))).body(b -> {\n@@ -399,0 +399,9 @@\n+            \/\/ default case\n+            Body.Builder dl = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n+            Block.Parameter target = dl.entryBlock().parameter(INT);\n+            dl.entryBlock().op(core_yield(dl.entryBlock().op(constant(BOOLEAN, true))));\n+            Body.Builder de = Body.Builder.of(b.parentBody(), functionType(type(ExternalizedTypeElement.class)));\n+            de.entryBlock().op(throw_(de.entryBlock().op(new_(MethodRef.constructor(IllegalStateException.class)))));\n+            swBodies.add(dl);\n+            swBodies.add(de);\n+\n@@ -402,1 +411,0 @@\n-        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1549,2 +1549,1 @@\n-            Body.Builder defaultLabel = null;\n-            Body.Builder defaultBody = null;\n+            boolean hasDefaultCase = false;\n@@ -1554,9 +1553,4 @@\n-                Body.Builder caseBody = visitCaseBody(tree, c, caseBodyType);\n-\n-                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n-                    defaultLabel = caseLabel;\n-                    defaultBody = caseBody;\n-                } else {\n-                    bodies.add(caseLabel);\n-                    bodies.add(caseBody);\n-                }\n+                Body.Builder caseBody = visitCaseBody(tree, c, caseBodyType, cases.getLast() == c);\n+                bodies.add(caseLabel);\n+                bodies.add(caseBody);\n+                hasDefaultCase = c.labels.head instanceof JCTree.JCDefaultCaseLabel;\n@@ -1565,4 +1559,1 @@\n-            if (defaultLabel != null) {\n-                bodies.add(defaultLabel);\n-                bodies.add(defaultBody);\n-            } else if (isDefaultCaseNeeded) {\n+            if (!hasDefaultCase && isDefaultCaseNeeded) {\n@@ -1690,1 +1681,1 @@\n-        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c, FunctionType caseBodyType) {\n+        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c, FunctionType caseBodyType, boolean isLastCase) {\n@@ -1726,1 +1717,1 @@\n-                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::core_yield : JavaOp::switchFallthroughOp\n+                            isLastCase ? CoreOp::core_yield : JavaOp::switchFallthroughOp\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -104,4 +104,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -645,1 +645,0 @@\n-        CoreOp.FuncOp lfunc;\n@@ -647,7 +646,1 @@\n-            lfunc = func.transform(CodeContext.create(), CodeTransformer.LOWERING_TRANSFORMER);\n-        } catch (UnsupportedOperationException uoe) {\n-            throw new TestSkippedException(\"lowering caused:\", uoe);\n-        }\n-\n-        try {\n-            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lfunc);\n+            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), func);\n@@ -670,1 +663,0 @@\n-            System.out.println(lfunc.toText());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,4 +82,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.bytecode.impl.LoweringTransform;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\/jdk.incubator.code.bytecode.impl\n+ * @enablePreview\n+ * @compile TestIsCaseConstantSwitch.java\n+ * @run junit TestIsCaseConstantSwitch\n+ *\/\n+public class TestIsCaseConstantSwitch {\n+\n+    class C {\n+        static final int x = 26;\n+    }\n+\n+    @Reflect\n+    private static void caseConstantSwitchExpressions() {\n+        \/\/ switch label\n+        \/\/ case label\n+        \/\/ list of case constant\n+        \/\/ every case constant must be either a constant expression or the name of an enum constant\n+        \/\/ null literal\n+        \/\/ list of case patterns\n+        \/\/ default label\n+        final int fv = 25;\n+        int i = -1;\n+        String r = switch (i) {\n+            \/\/ literal of primitive type\n+            case 1 -> \"A\";\n+            \/\/ unary operators +, -, ~\n+            case +2 -> \"B\";\n+            case -2 -> \"BB\";\n+            case ~2 -> \"BBB\"; \/\/ -3\n+            \/\/ multiplicative operators *, \/, %\n+            case 3 * 4 -> \"E\";\n+            case 3 \/ 4 -> \"EE\";\n+            case 3 % 4 -> \"EEE\";\n+            \/\/ shift operators <<, >>, >>>\n+            case 4 << 5 -> \"F\"; \/\/ 128\n+            case 10 >> 1 -> \"FF\"; \/\/ 5\n+            case 8 >>> 1 -> \"FFF\"; \/\/ 4\n+            \/\/ relational operators <, <=, >, >= (and conditional operator)\n+            case 1 < 2 ? 9 : 10 -> \"G\"; \/\/ 9\n+            case 1 <= 2 ? 11 : 12 -> \"GG\"; \/\/ 11\n+            case 1 > 2 ? 13 : 14 -> \"GGG\"; \/\/ 14\n+            case 1 >= 2 ? 15 : 16 -> \"GGGG\"; \/\/ 16\n+            \/\/ equality operators ==, !=\n+            case 1 == 2 ? 17 : 18 -> \"H\"; \/\/ 18\n+            case 1 != 2 ? 19 : 20 -> \"HH\"; \/\/ 19\n+            \/\/ bitwise and logical operators &, ^, |\n+            case 6 & 6 -> \"I\"; \/\/ 6\n+            case 7 ^ 8 -> \"II\"; \/\/ 15\n+            case 8 | 10 -> \"III\"; \/\/ 10\n+            \/\/ conditional-and operator &&\n+            case 2 > 3 && 5 > 6 ? 21 : 22 -> \"J\"; \/\/ 22\n+            case 2 > 3 || 5 > 6 ? 23 : 24 -> \"JJ\"; \/\/ 24\n+            \/\/ parenthesized expressions whose contained expression is a constant expression\n+            case (20) -> \"K\";\n+            \/\/ simple names that refer to constant variables\n+            case fv -> \"L\";\n+            \/\/ qualified names of the form TypeName.Identifier that refer to constant variables\n+            case C.x -> \"M\";\n+            \/\/ list of case constants\n+            case 21, 30 -> null;\n+            \/\/ casts\n+            case (int) 31L -> \"N\";\n+            case (int) 34f -> \"NN\";\n+            \/\/ default\n+            default -> \"X\";\n+        };\n+\n+        \/\/ we can have a target of type Byte, Short, Character, Integer\n+        \/\/ as long as we don't introduce case null, javac will generate labels identical to what we have in source code\n+        Integer ii = -2;\n+        r = switch (ii) {\n+            case 1 -> \"A\";\n+            default -> \"X\";\n+        };\n+\n+        char c = '2';\n+        r = switch (c) {\n+            case '1' -> \"1\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    enum E {\n+        V;\n+    }\n+\n+    @Reflect\n+    static void nonCaseConstantSwitchExpressions() {\n+        int r;\n+\n+        String s = \"\";\n+        r = switch (s) {\n+            case \"A\" -> 1;\n+            default -> 0;\n+        };\n+\n+        E e = E.V;\n+        r = switch (e) {\n+            case V -> 1;\n+        };\n+\n+        boolean b = false;\n+        r = switch (b) {\n+            case true -> 1;\n+            default -> 0;\n+        };\n+\n+        long l = 5L;\n+        r = switch (l) {\n+            case 1L -> 1;\n+            default -> 0;\n+        };\n+\n+        float f = 5f;\n+        r = switch (f) {\n+            case 1f -> 1;\n+            default -> 0;\n+        };\n+\n+        double d = 5d;\n+        r = switch (d) {\n+            case 1d -> 1;\n+            default -> 0;\n+        };\n+\n+        Integer i = 4;\n+        r = switch (i) {\n+            case 1 -> 1;\n+            case null -> -1;\n+            default -> 0;\n+        };\n+    }\n+\n+    static Stream<Arguments> cases() {\n+        return Stream.of(\n+                Arguments.of(\"caseConstantSwitchExpressions\", true),\n+                Arguments.of(\"nonCaseConstantSwitchExpressions\", false)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    void testIsConstantLabelSwitch(String methodName, boolean expected) throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(methodName);\n+        CoreOp.FuncOp codeModel = Op.ofMethod(m).get();\n+        List<SwitchExpressionOp> swExprOps = codeModel.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof SwitchExpressionOp)\n+                .map(o -> ((SwitchExpressionOp) o)).toList();\n+        for (SwitchExpressionOp swExprOp : swExprOps) {\n+            Assertions.assertEquals(\n+                    new LoweringTransform.ConstantLabelSwitchChecker(swExprOp, MethodHandles.lookup()).isCaseConstantSwitch(),\n+                    expected,\n+                    swExprOp.toText());\n+        }\n+    }\n+\n+    @Test\n+    void testGettingLabels() throws NoSuchMethodException {\n+        var expectedLabels = List.of(1, +2, -2, ~2, 12, 3 \/ 4, 3 % 4, 4 << 5, 10 >> 1,\n+                8 >>> 1, 1 < 2 ? 9 : 10, 1 <= 2 ? 11 : 12, 1 > 2 ? 13 : 14, 1 >= 2 ? 15 : 16, 1 == 2 ? 17 : 18,\n+                1 != 2 ? 19 : 20, 6 & 6, 7 ^ 8, 8 | 10, 2 > 3 && 5 > 6 ? 21 : 22, 2 > 3 || 5 > 6 ? 23 : 24, (20), 25,\n+                C.x, 21, 30, (int) 31L, (int) 34f );\n+        var funcOp = Op.ofMethod(this.getClass().getDeclaredMethod(\"caseConstantSwitchExpressions\")).get();\n+        System.out.println(funcOp.toText());\n+        var swOp = (JavaSwitchOp) funcOp.body().entryBlock().ops().stream().filter(op -> op instanceof JavaSwitchOp).findFirst().get();\n+        List<Integer> actualLabels = getLabelsAndTargets(MethodHandles.lookup(), swOp);\n+        System.out.println(actualLabels);\n+        Assertions.assertEquals(expectedLabels, actualLabels);\n+    }\n+\n+    static ArrayList<Integer> getLabelsAndTargets(MethodHandles.Lookup lookup, JavaSwitchOp swOp) {\n+        var labels = new ArrayList<Integer>();\n+        for (int i = 0; i < swOp.bodies().size(); i += 2) {\n+            Body labelBody = swOp.bodies().get(i);\n+            labels.addAll(getLabels(lookup, labelBody));\n+        }\n+        return labels;\n+    }\n+\n+    static List<Integer> getLabels(MethodHandles.Lookup lookup, Body body) {\n+        if (body.blocks().size() != 1 || !(body.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                !(yop.yieldValue() instanceof Result opr)) {\n+            throw new IllegalStateException(\"Body of a java switch fails the expected structure\");\n+        }\n+        var labels = new ArrayList<Integer>();\n+        if (opr.op() instanceof EqOp eqOp) {\n+            labels.add(extractConstantLabel(lookup, body, eqOp));\n+        } else if (opr.op() instanceof InvokeOp invokeOp &&\n+                invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class))) {\n+            labels.add(extractConstantLabel(lookup, body, invokeOp));\n+        } else if (opr.op() instanceof ConditionalOrOp cor) {\n+            for (Body corbody : cor.bodies()) {\n+                labels.addAll(getLabels(lookup, corbody));\n+            }\n+        } else if (!(opr.op() instanceof CoreOp.ConstantOp)){ \/\/ not default label\n+            throw new IllegalStateException();\n+        }\n+        return labels;\n+    }\n+\n+    static Integer extractConstantLabel(MethodHandles.Lookup lookup, Body body, Op whenToStop) {\n+        Op lastOp = body.entryBlock().ops().get(body.entryBlock().ops().indexOf(whenToStop) - 1);\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", CoreType.functionType(lastOp.result().type())).body(block -> {\n+            \/\/ in case we refer to constant variables in the label\n+            for (Value capturedValue : body.capturedValues()) {\n+                if (!(capturedValue instanceof Result r) || !(r.op() instanceof CoreOp.VarOp vop)) {\n+                    continue;\n+                }\n+                block.op(((Result) vop.initOperand()).op());\n+                block.op(vop);\n+            }\n+            Result last = null;\n+            for (Op op : body.entryBlock().ops()) {\n+                if (op.equals(whenToStop)) {\n+                    break;\n+                }\n+                last = block.op(op);\n+            }\n+            block.op(CoreOp.return_(last));\n+        });\n+        Object res = Interpreter.invoke(lookup, funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+        return switch (res) {\n+            case Byte b -> Integer.valueOf(b);\n+            case Short s -> Integer.valueOf(s);\n+            case Character c -> Integer.valueOf(c);\n+            case Integer i -> i;\n+            default -> throw new IllegalStateException(); \/\/ @@@ not going to happen\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestIsCaseConstantSwitch.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -82,4 +82,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,4 +145,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.instruction.LookupSwitchInstruction;\n+import java.lang.classfile.instruction.TableSwitchInstruction;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\/jdk.incubator.code.bytecode.impl\n+ * @run junit TestSwitch\n+ *\/\n+public class TestSwitch {\n+\n+    @Reflect\n+    static String lookupSwitchExpression(int i) {\n+        return switch (i) {\n+            case 7,8 -> \"magic number\";\n+            case 42 -> \"Answer to the Ultimate Question of Life, the Universe, and Everything\";\n+            case 101 -> \"introduction to a subject\";\n+            default -> \"not important\";\n+        };\n+    }\n+\n+    @Reflect\n+    static String tableSwitchExpression(int i) {\n+        return switch (i) {\n+            case -1 -> \"?\";\n+            case 0 -> \"none\";\n+            case 1 -> \"one\";\n+            case 2 -> \"two\";\n+            case 3 -> \"three\";\n+            default -> \"many\";\n+        };\n+    }\n+\n+    @Reflect\n+    static String lookupSwitchStatement(int i) {\n+        String ret = null;\n+        switch (i) {\n+            case 7 : ret = \"magic number\"; break;\n+            case 42 : return \"Answer to the Ultimate Question of Life, the Universe, and Everything\";\n+            case 101 : ret = \"introduction to a subject\"; break;\n+            default : return \"not important\";\n+        }\n+        return ret;\n+    }\n+\n+    @Reflect\n+    static String tableSwitchStatement(int i) {\n+        String ret = null;\n+        switch (i) {\n+            case -1 : ret = \"?\"; break;\n+            case 0 : return \"none\";\n+            case 1 : ret = \"one\"; break;\n+            case 2 : return \"two\";\n+            case 3 : ret =\"three\"; break;\n+            default : return\"many\";\n+        }\n+        return ret;\n+    }\n+\n+    @Reflect\n+    static String outOfOrderFallThrought(int i) {\n+        String ret = \"\";\n+        switch (i) {\n+            default : ret += \"? \";\n+            case 4 : ret += \"four \";\n+            case 2 : ret += \"two \";\n+            case 3 : ret += \"three \";\n+            case 1 : ret += \"one\";\n+        }\n+        return ret;\n+    }\n+\n+    @Reflect\n+    static String nestedExpressions(int i) {\n+        return switch (i) {\n+            case -1 -> \"?\";\n+            case 0 -> \"none\";\n+            case 1 -> \"one\";\n+            case 2 -> \"two\";\n+            case 3 -> \"three\";\n+            default -> switch (i) {\n+                case 7,8 -> \"magic number\";\n+                case 42 -> \"Answer to the Ultimate Question of Life, the Universe, and Everything\";\n+                case 101 -> \"introduction to a subject\";\n+                default -> \"not important\";\n+            };\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"lookupSwitchExpression\",\n+        \"tableSwitchExpression\",\n+        \"lookupSwitchStatement\",\n+        \"tableSwitchStatement\",\n+        \"outOfOrderFallThrought\",\n+        \"nestedExpressions\"\n+    })\n+\n+    public void testSwitch(String methodName) throws Throwable {\n+        Method m = getMethod(methodName);\n+        CoreOp.FuncOp f = Op.ofMethod(m).orElseThrow();\n+\n+        Assertions.assertTrue(getModel(f).code().get().elementStream()\n+                .anyMatch(i -> i instanceof TableSwitchInstruction || i instanceof LookupSwitchInstruction));\n+\n+        MethodHandle mh = generate(f);\n+        for (int i = -1; i < 110; i++) {\n+            Assertions.assertEquals((String)m.invoke(null, i), (String)mh.invokeExact(i));\n+        }\n+    }\n+\n+    static MethodHandle generate(CoreOp.FuncOp f) {\n+        System.out.println(f.toText());\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n+    }\n+\n+    static MethodModel getModel(CoreOp.FuncOp f) {\n+        var clm = ClassFile.of().parse(BytecodeGenerator.generateClassData(MethodHandles.lookup(), f));\n+        var mm = clm.methods().getFirst();\n+        System.out.println(mm.toDebugString());\n+        return mm;\n+    }\n+\n+    static Method getMethod(String name) {\n+        Optional<Method> om = Stream.of(TestSwitch.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        return om.get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -68,1 +68,0 @@\n-        f = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -87,1 +86,0 @@\n-        f = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,4 +263,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -199,4 +199,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -222,4 +222,1 @@\n-        CoreOp.FuncOp lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-        var lf = f.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(lf.toText());\n-\n@@ -40,1 +37,1 @@\n-        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-                module.functionTable().get(fExpected.funcName()));\n+                module.transform(CodeTransformer.LOWERING_TRANSFORMER).functionTable().get(fExpected.funcName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -921,0 +921,8 @@\n+                    ()java.type:\"boolean\" -> {\n+                        %12 : java.type:\"boolean\" = constant @true;\n+                        yield %12;\n+                    }\n+                    ()java.type:\"java.lang.String\" -> {\n+                        %13 : java.type:\"java.lang.String\" = constant @\"else\";\n+                        yield %13;\n+                    }\n@@ -938,8 +946,0 @@\n-                    }\n-                    ()java.type:\"boolean\" -> {\n-                        %12 : java.type:\"boolean\" = constant @true;\n-                        yield %12;\n-                    }\n-                    ()java.type:\"java.lang.String\" -> {\n-                        %13 : java.type:\"java.lang.String\" = constant @\"else\";\n-                        yield %13;\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1962,0 +1962,11 @@\n+                    ()java.type:\"boolean\" -> {\n+                        %17 : java.type:\"boolean\" = constant @true;\n+                        yield %17;\n+                    }\n+                    ()java.type:\"void\" -> {\n+                        %18 : java.type:\"java.lang.String\" = var.load %3;\n+                        %19 : java.type:\"java.lang.String\" = constant @\"else\";\n+                        %20 : java.type:\"java.lang.String\" = concat %18 %19;\n+                        var.store %3 %20;\n+                        yield;\n+                    }\n@@ -1985,11 +1996,0 @@\n-                    }\n-                    ()java.type:\"boolean\" -> {\n-                        %17 : java.type:\"boolean\" = constant @true;\n-                        yield %17;\n-                    }\n-                    ()java.type:\"void\" -> {\n-                        %18 : java.type:\"java.lang.String\" = var.load %3;\n-                        %19 : java.type:\"java.lang.String\" = constant @\"else\";\n-                        %20 : java.type:\"java.lang.String\" = concat %18 %19;\n-                        var.store %3 %20;\n-                        yield;\n@@ -2039,0 +2039,88 @@\n+\n+    @IR(\"\"\"\n+            func @\"outOfOrderFallThrought\" (%0 : java.type:\"int\")java.type:\"java.lang.String\" -> {\n+                  %1 : Var<java.type:\"int\"> = var %0 @\"i\";\n+                  %2 : java.type:\"java.lang.String\" = constant @\"\";\n+                  %3 : Var<java.type:\"java.lang.String\"> = var %2 @\"ret\";\n+                  %4 : java.type:\"int\" = var.load %1;\n+                  java.switch.statement %4\n+                      ()java.type:\"boolean\" -> {\n+                          %5 : java.type:\"boolean\" = constant @true;\n+                          yield %5;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %6 : java.type:\"java.lang.String\" = var.load %3;\n+                          %7 : java.type:\"java.lang.String\" = constant @\"? \";\n+                          %8 : java.type:\"java.lang.String\" = concat %6 %7;\n+                          var.store %3 %8;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%9 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %10 : java.type:\"int\" = constant @4;\n+                          %11 : java.type:\"boolean\" = eq %9 %10;\n+                          yield %11;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %12 : java.type:\"java.lang.String\" = var.load %3;\n+                          %13 : java.type:\"java.lang.String\" = constant @\"four \";\n+                          %14 : java.type:\"java.lang.String\" = concat %12 %13;\n+                          var.store %3 %14;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%15 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %16 : java.type:\"int\" = constant @2;\n+                          %17 : java.type:\"boolean\" = eq %15 %16;\n+                          yield %17;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %18 : java.type:\"java.lang.String\" = var.load %3;\n+                          %19 : java.type:\"java.lang.String\" = constant @\"two \";\n+                          %20 : java.type:\"java.lang.String\" = concat %18 %19;\n+                          var.store %3 %20;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%21 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %22 : java.type:\"int\" = constant @3;\n+                          %23 : java.type:\"boolean\" = eq %21 %22;\n+                          yield %23;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %24 : java.type:\"java.lang.String\" = var.load %3;\n+                          %25 : java.type:\"java.lang.String\" = constant @\"three \";\n+                          %26 : java.type:\"java.lang.String\" = concat %24 %25;\n+                          var.store %3 %26;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%27 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %28 : java.type:\"int\" = constant @1;\n+                          %29 : java.type:\"boolean\" = eq %27 %28;\n+                          yield %29;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %30 : java.type:\"java.lang.String\" = var.load %3;\n+                          %31 : java.type:\"java.lang.String\" = constant @\"one\";\n+                          %32 : java.type:\"java.lang.String\" = concat %30 %31;\n+                          var.store %3 %32;\n+                          yield;\n+                      };\n+                  %33 : java.type:\"java.lang.String\" = var.load %3;\n+                  return %33;\n+              };\n+            \"\"\")\n+    @Reflect\n+    static String outOfOrderFallThrought(int i) {\n+        String ret = \"\";\n+        switch (i) {\n+            default:\n+                ret += \"? \";\n+            case 4:\n+                ret += \"four \";\n+            case 2:\n+                ret += \"two \";\n+            case 3:\n+                ret += \"three \";\n+            case 1:\n+                ret += \"one\";\n+        }\n+        return ret;\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":99,"deletions":11,"binary":false,"changes":110,"status":"modified"}]}