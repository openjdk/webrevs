{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.bytecode.impl.ConstantLabelSwitchOp;\n@@ -48,2 +47,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.reflect.Field;\n@@ -57,0 +54,1 @@\n+import jdk.incubator.code.bytecode.impl.ConstantLabelSwitchOp;\n@@ -59,1 +57,1 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.bytecode.impl.LoweringTransform;\n@@ -61,1 +59,0 @@\n-import jdk.incubator.code.dialect.core.CoreType;\n@@ -66,1 +63,0 @@\n-import jdk.incubator.code.interpreter.Interpreter;\n@@ -71,1 +67,0 @@\n-import static jdk.incubator.code.dialect.java.JavaType.*;\n@@ -78,17 +73,0 @@\n-    \/**\n-     * A transformer that lowers operations unsupported by BytecodeGenerator.\n-     *\/\n-\/\/    static CodeTransformer BYTECODE_LOWERING_TRANSFORMER = (block, op) -> {\n-\/\/        return switch (op) {\n-\/\/            case JavaOp.JavaSwitchOp swop when new ConstantLabelSwitchChecker(swop, lookup).isCaseConstantSwitch() -> {\n-\/\/               \/\/@@@ lower JavaOp.JavaSwitchOp to ConstantLabelSwitchOp\n-\/\/            }\n-\/\/            case Op.Lowerable lop ->\n-\/\/                lop.lower(block, null);\n-\/\/            default -> {\n-\/\/                block.op(op);\n-\/\/                yield block;\n-\/\/            }\n-\/\/        };\n-\/\/    };\n-\n@@ -141,128 +119,0 @@\n-    public static final class ConstantLabelSwitchChecker {\n-        private final MethodHandles.Lookup lookup;\n-        private JavaSwitchOp swOp;\n-\n-        public ConstantLabelSwitchChecker(JavaSwitchOp swOp, MethodHandles.Lookup lookup) {\n-            this.swOp = swOp;\n-            this.lookup = lookup;\n-        }\n-\n-        private static boolean isFinalVar(VarOp varOp) {\n-            return varOp.initOperand() != null && varOp.result().uses().stream().noneMatch(u -> u.op() instanceof VarAccessOp.VarStoreOp);\n-        }\n-\n-        private static boolean isBoxingMethod(MethodRef mr) {\n-            return List.of(J_L_BYTE, J_L_CHARACTER, J_L_SHORT, J_L_INTEGER, J_L_LONG, J_L_FLOAT, J_L_DOUBLE).contains(mr.refType())\n-                    && mr.name().equals(\"valueOf\");\n-        }\n-\n-        private static boolean isIntegralType(TypeElement te) {\n-            return isIntegralPrimitiveType(te) || isIntegralReferenceType(te);\n-        }\n-\n-        private static boolean isIntegralPrimitiveType(TypeElement te) {\n-            return List.of(BYTE, SHORT, CHAR, INT).contains(te);\n-        }\n-\n-        private static boolean isIntegralReferenceType(TypeElement te) {\n-            return List.of(J_L_BYTE, J_L_SHORT, J_L_CHARACTER, J_L_INTEGER).contains(te);\n-        }\n-\n-        private boolean isConstantExpr(Value v) {\n-            if (!(v instanceof Result opr)) {\n-                return false;\n-            }\n-            Op op = opr.op();\n-            if (op instanceof ConstantOp cop) {\n-                return cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n-            }\n-            if (op instanceof VarAccessOp.VarLoadOp varLoadOp) {\n-                return isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand());\n-            }\n-            if (op instanceof ConvOp convOp) {\n-                return (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n-                        isConstantExpr(convOp.operands().get(0));\n-            }\n-            if (op instanceof InvokeOp invokeOp) {\n-                return isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0));\n-            }\n-            if (op instanceof FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                Field field;\n-                try {\n-                    field = fieldLoadOp.fieldDescriptor().resolveToField(lookup);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                return field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n-            }\n-            if (op instanceof UnaryOp unaryOp) {\n-                return isConstantExpr(unaryOp.operands().get(0));\n-            }\n-            if (op instanceof BinaryOp binaryOp) {\n-                return binaryOp.operands().stream().allMatch(o -> isConstantExpr(o));\n-            }\n-            if (op instanceof BinaryTestOp binaryTestOp) {\n-                return binaryTestOp.operands().stream().allMatch(o -> isConstantExpr(o));\n-            }\n-            if (op instanceof ConditionalExpressionOp cexpr) {\n-                \/\/ bodies must yield constant expressions\n-                return isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue());\n-            }\n-            \/\/ conditional and, conditional or, example ?\n-            if (op instanceof ConditionalAndOp cand) {\n-                return isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n-            }\n-            if (op instanceof ConditionalOrOp cor) {\n-                \/\/ we can have a method isBodyYieldConstantExpr(Body)\n-                return isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n-            }\n-            return false;\n-        }\n-\n-        private boolean isCaseConstantLabel(Body label) {\n-            if (label.blocks().size() != 1 || !(label.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n-                    !(yop.yieldValue() instanceof Result r)) {\n-                return false;\n-            }\n-\n-            \/\/ EqOp for primitives, method invocation for Strings and Reference Types\n-            if (r.op() instanceof EqOp eqOp) {\n-                return isConstantExpr(eqOp.operands().get(1));\n-            }\n-            if (r.op() instanceof InvokeOp invokeOp) {\n-                MethodRef OBJECTS_EQUALS_METHOD = MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class);\n-                if (!invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS_METHOD)) {\n-                    return false;\n-                }\n-                \/\/ case null\n-                if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof ConstantOp cop && cop.value() == null) {\n-                    return false;\n-                }\n-                return isConstantExpr(invokeOp.operands().get(1));\n-            }\n-            if (r.op() instanceof ConditionalOrOp cor) { \/\/ list of case constant\n-                return cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b));\n-            }\n-            return r.op() instanceof ConstantOp cop && cop.resultType().equals(BOOLEAN); \/\/ default label\n-        }\n-\n-        public boolean isCaseConstantSwitch() {\n-            if (!isIntegralType(swOp.operands().get(0).type())) {\n-                return false;\n-            }\n-            for (int i = 0; i < swOp.bodies().size(); i+=2) {\n-                Body label = swOp.bodies().get(i);\n-                if (!isCaseConstantLabel(label)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-    }\n-\n-    \/\/\n-\n@@ -315,65 +165,0 @@\n-    record LabelsAndTargets(List<Integer> labels, List<Block> targets) {}\n-\n-    static LabelsAndTargets getLabelsAndTargets(MethodHandles.Lookup lookup, JavaSwitchOp swOp) {\n-        var labels = new ArrayList<Integer>();\n-        var targets = new ArrayList<Block>();\n-        for (int i = 0; i < swOp.bodies().size() - 1; i += 2) {\n-            List<Integer> ls = getLabels(lookup, swOp.bodies().get(i));\n-            labels.addAll(ls);\n-            \/\/ getLabels returns an empty list, for case default\n-            targets.addAll(Collections.nCopies(Math.max(ls.size(), 1), swOp.bodies().get(i + 1).entryBlock()));\n-        }\n-        return new LabelsAndTargets(labels, targets);\n-    }\n-\n-    static List<Integer> getLabels(MethodHandles.Lookup lookup, Body body) {\n-        if (body.blocks().size() != 1 || !(body.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n-                !(yop.yieldValue() instanceof Result opr)) {\n-            throw new IllegalStateException(\"Body of a java switch fails the expected structure\");\n-        }\n-        var labels = new ArrayList<Integer>();\n-        if (opr.op() instanceof EqOp eqOp) {\n-            labels.add(extractConstantLabel(lookup, body, eqOp));\n-        } else if (opr.op() instanceof InvokeOp invokeOp &&\n-                invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class))) {\n-            labels.add(extractConstantLabel(lookup, body, invokeOp));\n-        } else if (opr.op() instanceof ConditionalOrOp cor) {\n-            for (Body corbody : cor.bodies()) {\n-                labels.addAll(getLabels(lookup, corbody));\n-            }\n-        } else if (!(opr.op() instanceof CoreOp.ConstantOp)){ \/\/ not default label\n-            throw new IllegalStateException();\n-        }\n-        return labels;\n-    }\n-\n-    static Integer extractConstantLabel(MethodHandles.Lookup lookup, Body body, Op whenToStop) {\n-        Op lastOp = body.entryBlock().ops().get(body.entryBlock().ops().indexOf(whenToStop) - 1);\n-        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", CoreType.functionType(lastOp.result().type())).body(block -> {\n-            \/\/ in case we refer to constant variables in the label\n-            for (Value capturedValue : body.capturedValues()) {\n-                if (!(capturedValue instanceof Result r) || !(r.op() instanceof CoreOp.VarOp vop)) {\n-                    continue;\n-                }\n-                block.op(((Result) vop.initOperand()).op());\n-                block.op(vop);\n-            }\n-            Result last = null;\n-            for (Op op : body.entryBlock().ops()) {\n-                if (op.equals(whenToStop)) {\n-                    break;\n-                }\n-                last = block.op(op);\n-            }\n-            block.op(CoreOp.return_(last));\n-        });\n-        Object res = Interpreter.invoke(lookup, funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER));\n-        return switch (res) {\n-            case Byte b -> Integer.valueOf(b);\n-            case Short s -> Integer.valueOf(s);\n-            case Character c -> Integer.valueOf(c);\n-            case Integer i -> i;\n-            default -> throw new IllegalStateException(); \/\/ @@@ not going to happen\n-        };\n-    }\n-\n@@ -384,2 +169,1 @@\n-        byte[] classBytes;\n-        classBytes = ClassFile.of().build(clName, clb -> {\n+        byte[] classBytes = ClassFile.of().build(clName, clb -> {\n@@ -388,0 +172,1 @@\n+            CodeTransformer lowering = LoweringTransform.getInstance(lookup);\n@@ -389,29 +174,1 @@\n-                O lowered = (O)e.getValue().transform(CodeContext.create(), ((block, op) -> switch (op) {\n-                    case JavaSwitchOp swOp when new ConstantLabelSwitchChecker(swOp, lookup).isCaseConstantSwitch() -> {\n-                        LabelsAndTargets labelsAndTargets = getLabelsAndTargets(lookup, swOp);\n-                        List<Block.Reference> targets = new ArrayList<>();\n-                        \/\/ the targets need to be part of the block's body\n-                        Block.Builder end = block.block(swOp.resultType());\n-                        block.context().mapValue(swOp.result(), end.parameters().get(0));\n-                        for (Block t : labelsAndTargets.targets()) {\n-                            Block.Builder b = block.block();\n-                            for (Op o : t.ops()) {\n-                                if (o instanceof CoreOp.YieldOp yop) {\n-                                    b.op(CoreOp.branch(end.successor(b.context().getValue(yop.yieldValue()))));\n-                                } else {\n-                                    b.op(o);\n-                                }\n-                            }\n-                            targets.add(b.successor(List.of()));\n-                        }\n-                        Value selector = block.context().getValue(swOp.operands().get(0));\n-                        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), targets));\n-                        yield end;\n-                    }\n-                    case Lowerable lop ->\n-                            lop.lower(block, null);\n-                    default -> {\n-                        block.op(op);\n-                        yield block;\n-                    }\n-                }));\n+                O lowered = (O)e.getValue().transform(CodeContext.create(), lowering);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":5,"deletions":248,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.bytecode.impl;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n+\n+\/**\n+ * Lowering transformer generates models supported by {@code BytecodeGenerator}.\n+ * Constant-labeled switch statements and switch expressions are lowered to\n+ * {@code ConstantLabelSwitchOp} with evaluated labels.\n+ *\/\n+public final class LoweringTransform {\n+\n+    public static CodeTransformer getInstance(MethodHandles.Lookup lookup) {\n+        return (block, op) -> switch (op) {\n+                    case JavaOp.JavaSwitchOp swOp when new ConstantLabelSwitchChecker(swOp, lookup).isCaseConstantSwitch() -> {\n+                        LabelsAndTargets labelsAndTargets = getLabelsAndTargets(lookup, swOp);\n+                        List<Block.Reference> targets = new ArrayList<>();\n+                        \/\/ the targets need to be part of the block's body\n+                        Block.Builder end = block.block(swOp.resultType());\n+                        block.context().mapValue(swOp.result(), end.parameters().get(0));\n+                        for (Block t : labelsAndTargets.targets()) {\n+                            Block.Builder b = block.block();\n+                            for (Op o : t.ops()) {\n+                                if (o instanceof CoreOp.YieldOp yop) {\n+                                    b.op(CoreOp.branch(end.successor(b.context().getValue(yop.yieldValue()))));\n+                                } else {\n+                                    b.op(o);\n+                                }\n+                            }\n+                            targets.add(b.successor(List.of()));\n+                        }\n+                        Value selector = block.context().getValue(swOp.operands().get(0));\n+                        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), targets));\n+                        yield end;\n+                    }\n+                    case Op.Lowerable lop ->\n+                            lop.lower(block, null);\n+                    default -> {\n+                        block.op(op);\n+                        yield block;\n+                    }\n+                };\n+    }\n+\n+    public static final class ConstantLabelSwitchChecker {\n+        private final MethodHandles.Lookup lookup;\n+        private JavaOp.JavaSwitchOp swOp;\n+\n+        public ConstantLabelSwitchChecker(JavaOp.JavaSwitchOp swOp, MethodHandles.Lookup lookup) {\n+            this.swOp = swOp;\n+            this.lookup = lookup;\n+        }\n+\n+        private static boolean isFinalVar(CoreOp.VarOp varOp) {\n+            return varOp.initOperand() != null && varOp.result().uses().stream().noneMatch(u -> u.op() instanceof CoreOp.VarAccessOp.VarStoreOp);\n+        }\n+\n+        private static boolean isBoxingMethod(MethodRef mr) {\n+            return List.of(J_L_BYTE, J_L_CHARACTER, J_L_SHORT, J_L_INTEGER, J_L_LONG, J_L_FLOAT, J_L_DOUBLE).contains(mr.refType())\n+                    && mr.name().equals(\"valueOf\");\n+        }\n+\n+        private static boolean isIntegralType(TypeElement te) {\n+            return isIntegralPrimitiveType(te) || isIntegralReferenceType(te);\n+        }\n+\n+        private static boolean isIntegralPrimitiveType(TypeElement te) {\n+            return List.of(BYTE, SHORT, CHAR, INT).contains(te);\n+        }\n+\n+        private static boolean isIntegralReferenceType(TypeElement te) {\n+            return List.of(J_L_BYTE, J_L_SHORT, J_L_CHARACTER, J_L_INTEGER).contains(te);\n+        }\n+\n+        private boolean isConstantExpr(Value v) {\n+            if (!(v instanceof Op.Result opr)) {\n+                return false;\n+            }\n+            Op op = opr.op();\n+            if (op instanceof CoreOp.ConstantOp cop) {\n+                return cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n+            }\n+            if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                return isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand());\n+            }\n+            if (op instanceof JavaOp.ConvOp convOp) {\n+                return (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n+                        isConstantExpr(convOp.operands().get(0));\n+            }\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                return isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0));\n+            }\n+            if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                Field field;\n+                try {\n+                    field = fieldLoadOp.fieldDescriptor().resolveToField(lookup);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                return field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n+            }\n+            if (op instanceof JavaOp.UnaryOp unaryOp) {\n+                return isConstantExpr(unaryOp.operands().get(0));\n+            }\n+            if (op instanceof JavaOp.BinaryOp binaryOp) {\n+                return binaryOp.operands().stream().allMatch(o -> isConstantExpr(o));\n+            }\n+            if (op instanceof JavaOp.BinaryTestOp binaryTestOp) {\n+                return binaryTestOp.operands().stream().allMatch(o -> isConstantExpr(o));\n+            }\n+            if (op instanceof JavaOp.ConditionalExpressionOp cexpr) {\n+                \/\/ bodies must yield constant expressions\n+                return isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue());\n+            }\n+            \/\/ conditional and, conditional or, example ?\n+            if (op instanceof JavaOp.ConditionalAndOp cand) {\n+                return isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+            }\n+            if (op instanceof JavaOp.ConditionalOrOp cor) {\n+                \/\/ we can have a method isBodyYieldConstantExpr(Body)\n+                return isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+            }\n+            return false;\n+        }\n+\n+        private boolean isCaseConstantLabel(Body label) {\n+            if (label.blocks().size() != 1 || !(label.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                    !(yop.yieldValue() instanceof Op.Result r)) {\n+                return false;\n+            }\n+\n+            \/\/ EqOp for primitives, method invocation for Strings and Reference Types\n+            if (r.op() instanceof JavaOp.EqOp eqOp) {\n+                return isConstantExpr(eqOp.operands().get(1));\n+            }\n+            if (r.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                MethodRef OBJECTS_EQUALS_METHOD = MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class);\n+                if (!invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS_METHOD)) {\n+                    return false;\n+                }\n+                \/\/ case null\n+                if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n+                    return false;\n+                }\n+                return isConstantExpr(invokeOp.operands().get(1));\n+            }\n+            if (r.op() instanceof JavaOp.ConditionalOrOp cor) { \/\/ list of case constant\n+                return cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b));\n+            }\n+            return r.op() instanceof CoreOp.ConstantOp cop && cop.resultType().equals(BOOLEAN); \/\/ default label\n+        }\n+\n+        public boolean isCaseConstantSwitch() {\n+            if (!isIntegralType(swOp.operands().get(0).type())) {\n+                return false;\n+            }\n+            for (int i = 0; i < swOp.bodies().size(); i+=2) {\n+                Body label = swOp.bodies().get(i);\n+                if (!isCaseConstantLabel(label)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    record LabelsAndTargets(List<Integer> labels, List<Block> targets) {}\n+\n+    static LabelsAndTargets getLabelsAndTargets(MethodHandles.Lookup lookup, JavaOp.JavaSwitchOp swOp) {\n+        var labels = new ArrayList<Integer>();\n+        var targets = new ArrayList<Block>();\n+        for (int i = 0; i < swOp.bodies().size() - 1; i += 2) {\n+            List<Integer> ls = getLabels(lookup, swOp.bodies().get(i));\n+            labels.addAll(ls);\n+            \/\/ getLabels returns an empty list, for case default\n+            targets.addAll(Collections.nCopies(Math.max(ls.size(), 1), swOp.bodies().get(i + 1).entryBlock()));\n+        }\n+        return new LabelsAndTargets(labels, targets);\n+    }\n+\n+    static List<Integer> getLabels(MethodHandles.Lookup lookup, Body body) {\n+        if (body.blocks().size() != 1 || !(body.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                !(yop.yieldValue() instanceof Op.Result opr)) {\n+            throw new IllegalStateException(\"Body of a java switch fails the expected structure\");\n+        }\n+        var labels = new ArrayList<Integer>();\n+        if (opr.op() instanceof JavaOp.EqOp eqOp) {\n+            labels.add(extractConstantLabel(lookup, body, eqOp));\n+        } else if (opr.op() instanceof JavaOp.InvokeOp invokeOp &&\n+                invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class))) {\n+            labels.add(extractConstantLabel(lookup, body, invokeOp));\n+        } else if (opr.op() instanceof JavaOp.ConditionalOrOp cor) {\n+            for (Body corbody : cor.bodies()) {\n+                labels.addAll(getLabels(lookup, corbody));\n+            }\n+        } else if (!(opr.op() instanceof CoreOp.ConstantOp)){ \/\/ not default label\n+            throw new IllegalStateException();\n+        }\n+        return labels;\n+    }\n+\n+    static Integer extractConstantLabel(MethodHandles.Lookup lookup, Body body, Op whenToStop) {\n+        Op lastOp = body.entryBlock().ops().get(body.entryBlock().ops().indexOf(whenToStop) - 1);\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", CoreType.functionType(lastOp.result().type())).body(block -> {\n+            \/\/ in case we refer to constant variables in the label\n+            for (Value capturedValue : body.capturedValues()) {\n+                if (!(capturedValue instanceof Op.Result r) || !(r.op() instanceof CoreOp.VarOp vop)) {\n+                    continue;\n+                }\n+                block.op(((Op.Result) vop.initOperand()).op());\n+                block.op(vop);\n+            }\n+            Op.Result last = null;\n+            for (Op op : body.entryBlock().ops()) {\n+                if (op.equals(whenToStop)) {\n+                    break;\n+                }\n+                last = block.op(op);\n+            }\n+            block.op(CoreOp.return_(last));\n+        });\n+        Object res = Interpreter.invoke(lookup, funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+        return switch (res) {\n+            case Byte b -> Integer.valueOf(b);\n+            case Short s -> Integer.valueOf(s);\n+            case Character c -> Integer.valueOf(c);\n+            case Integer i -> i;\n+            default -> throw new IllegalStateException(); \/\/ @@@ not going to happen\n+        };\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LoweringTransform.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.bytecode.impl.LoweringTransform;\n@@ -22,1 +22,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code\/jdk.incubator.code.bytecode.impl\n@@ -172,1 +172,1 @@\n-                    new BytecodeGenerator.ConstantLabelSwitchChecker(swExprOp, MethodHandles.lookup()).isCaseConstantSwitch(),\n+                    new LoweringTransform.ConstantLabelSwitchChecker(swExprOp, MethodHandles.lookup()).isCaseConstantSwitch(),\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestIsCaseConstantSwitch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}