{"files":[{"patch":"@@ -48,0 +48,3 @@\n+import static jdk.incubator.code.dialect.core.CoreOp.Lowerable;\n+import static jdk.incubator.code.dialect.core.CoreOp.YieldOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.branch;\n@@ -57,0 +60,54 @@\n+    private static Block.Builder lowerToConstantLabelSwitchOp(Block.Builder block, JavaOp.JavaSwitchOp swOp,\n+                                                              LabelsAndTargets labelsAndTargets) {\n+        List<Block> targets = labelsAndTargets.targets();\n+        List<Block.Builder> blocks = new ArrayList<>();\n+        for (int i = 0; i < targets.size(); i++) {\n+            Block.Builder bb = block.block();\n+            blocks.add(bb);\n+        }\n+\n+        Block.Builder exit;\n+        if (targets.isEmpty()) {\n+            exit = block;\n+        } else {\n+            if (swOp.resultType() != VOID) {\n+                exit = block.block(swOp.resultType());\n+            } else {\n+                exit = block.block();\n+            }\n+            if (swOp instanceof JavaOp.SwitchExpressionOp) {\n+                exit.context().mapValue(swOp.result(), exit.parameters().get(0));\n+            }\n+        }\n+\n+        JavaOp.setBranchTarget(block.context(), swOp, new JavaOp.BranchTarget(exit, null));\n+        \/\/ map statement body to nextExprBlock\n+        \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+        for (int i = 0; i < targets.size() - 1; i++) {\n+            JavaOp.setBranchTarget(block.context(), targets.get(i).parent(), new JavaOp.BranchTarget(null, blocks.get(i+1)));\n+        }\n+\n+        for (int i = 0; i < targets.size(); i++) {\n+            Block.Builder curr = blocks.get(i);\n+            curr.body(targets.get(i).parent(), blocks.get(i).parameters(), (b, op) -> switch (op) {\n+                case YieldOp _ when swOp instanceof JavaOp.SwitchStatementOp -> {\n+                    b.op(branch(exit.successor()));\n+                    yield b;\n+                }\n+                case YieldOp yop when swOp instanceof JavaOp.SwitchExpressionOp -> {\n+                    b.op(branch(exit.successor(b.context().getValue(yop.yieldValue()))));\n+                    yield b;\n+                }\n+                case Lowerable lop -> lop.lower(b, null);\n+                default -> {\n+                    b.op(op);\n+                    yield b;\n+                }\n+            });\n+        }\n+\n+        Value selector = block.context().getValue(swOp.operands().get(0));\n+        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), blocks.stream().map(Block.Builder::successor).toList()));\n+        return exit;\n+    }\n+\n@@ -61,18 +118,1 @@\n-                        List<Block.Reference> targets = new ArrayList<>();\n-                        \/\/ the targets need to be part of the block's body\n-                        Block.Builder end = block.block(swOp.resultType());\n-                        block.context().mapValue(swOp.result(), end.parameters().get(0));\n-                        for (Block t : labelsAndTargets.targets()) {\n-                            Block.Builder b = block.block();\n-                            for (Op o : t.ops()) {\n-                                if (o instanceof CoreOp.YieldOp yop) {\n-                                    b.op(CoreOp.branch(end.successor(b.context().getValue(yop.yieldValue()))));\n-                                } else {\n-                                    b.op(o);\n-                                }\n-                            }\n-                            targets.add(b.successor(List.of()));\n-                        }\n-                        Value selector = block.context().getValue(swOp.operands().get(0));\n-                        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), targets));\n-                        yield end;\n+                        yield lowerToConstantLabelSwitchOp(block, swOp, labelsAndTargets);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LoweringTransform.java","additions":58,"deletions":18,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2148,1 +2148,1 @@\n-    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+    public record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n@@ -2153,1 +2153,1 @@\n-    static BranchTarget getBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement) {\n+    public static BranchTarget getBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement) {\n@@ -2162,1 +2162,1 @@\n-    static void setBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n+    public static void setBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1549,2 +1549,1 @@\n-            Body.Builder defaultLabel = null;\n-            Body.Builder defaultBody = null;\n+            boolean hasDefaultCase = false;\n@@ -1554,9 +1553,4 @@\n-                Body.Builder caseBody = visitCaseBody(tree, c, caseBodyType);\n-\n-                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n-                    defaultLabel = caseLabel;\n-                    defaultBody = caseBody;\n-                } else {\n-                    bodies.add(caseLabel);\n-                    bodies.add(caseBody);\n-                }\n+                Body.Builder caseBody = visitCaseBody(tree, c, caseBodyType, cases.getLast() == c);\n+                bodies.add(caseLabel);\n+                bodies.add(caseBody);\n+                hasDefaultCase = c.labels.head instanceof JCTree.JCDefaultCaseLabel;\n@@ -1565,4 +1559,1 @@\n-            if (defaultLabel != null) {\n-                bodies.add(defaultLabel);\n-                bodies.add(defaultBody);\n-            } else if (isDefaultCaseNeeded) {\n+            if (!hasDefaultCase && isDefaultCaseNeeded) {\n@@ -1690,1 +1681,1 @@\n-        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c, FunctionType caseBodyType) {\n+        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c, FunctionType caseBodyType, boolean isLastCase) {\n@@ -1726,1 +1717,1 @@\n-                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::core_yield : JavaOp::switchFallthroughOp\n+                            isLastCase ? CoreOp::core_yield : JavaOp::switchFallthroughOp\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -131,4 +131,4 @@\n-\/\/        \"lookupSwitchStatement\", @@@ lower BreakOp\n-\/\/        \"tableSwitchStatement\", @@@ lower BreakOp\n-\/\/        \"outOfOrderFallThrought\", @@@ lower SwitchFallthroughOp\n-\/\/        \"nestedExpressions\", @@@ lower recursively\n+        \"lookupSwitchStatement\",\n+        \"tableSwitchStatement\",\n+        \"outOfOrderFallThrought\",\n+        \"nestedExpressions\"\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSwitch.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -921,0 +921,8 @@\n+                    ()java.type:\"boolean\" -> {\n+                        %12 : java.type:\"boolean\" = constant @true;\n+                        yield %12;\n+                    }\n+                    ()java.type:\"java.lang.String\" -> {\n+                        %13 : java.type:\"java.lang.String\" = constant @\"else\";\n+                        yield %13;\n+                    }\n@@ -938,8 +946,0 @@\n-                    }\n-                    ()java.type:\"boolean\" -> {\n-                        %12 : java.type:\"boolean\" = constant @true;\n-                        yield %12;\n-                    }\n-                    ()java.type:\"java.lang.String\" -> {\n-                        %13 : java.type:\"java.lang.String\" = constant @\"else\";\n-                        yield %13;\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1962,0 +1962,11 @@\n+                    ()java.type:\"boolean\" -> {\n+                        %17 : java.type:\"boolean\" = constant @true;\n+                        yield %17;\n+                    }\n+                    ()java.type:\"void\" -> {\n+                        %18 : java.type:\"java.lang.String\" = var.load %3;\n+                        %19 : java.type:\"java.lang.String\" = constant @\"else\";\n+                        %20 : java.type:\"java.lang.String\" = concat %18 %19;\n+                        var.store %3 %20;\n+                        yield;\n+                    }\n@@ -1985,11 +1996,0 @@\n-                    }\n-                    ()java.type:\"boolean\" -> {\n-                        %17 : java.type:\"boolean\" = constant @true;\n-                        yield %17;\n-                    }\n-                    ()java.type:\"void\" -> {\n-                        %18 : java.type:\"java.lang.String\" = var.load %3;\n-                        %19 : java.type:\"java.lang.String\" = constant @\"else\";\n-                        %20 : java.type:\"java.lang.String\" = concat %18 %19;\n-                        var.store %3 %20;\n-                        yield;\n@@ -2039,0 +2039,88 @@\n+\n+    @IR(\"\"\"\n+            func @\"outOfOrderFallThrought\" (%0 : java.type:\"int\")java.type:\"java.lang.String\" -> {\n+                  %1 : Var<java.type:\"int\"> = var %0 @\"i\";\n+                  %2 : java.type:\"java.lang.String\" = constant @\"\";\n+                  %3 : Var<java.type:\"java.lang.String\"> = var %2 @\"ret\";\n+                  %4 : java.type:\"int\" = var.load %1;\n+                  java.switch.statement %4\n+                      ()java.type:\"boolean\" -> {\n+                          %5 : java.type:\"boolean\" = constant @true;\n+                          yield %5;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %6 : java.type:\"java.lang.String\" = var.load %3;\n+                          %7 : java.type:\"java.lang.String\" = constant @\"? \";\n+                          %8 : java.type:\"java.lang.String\" = concat %6 %7;\n+                          var.store %3 %8;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%9 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %10 : java.type:\"int\" = constant @4;\n+                          %11 : java.type:\"boolean\" = eq %9 %10;\n+                          yield %11;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %12 : java.type:\"java.lang.String\" = var.load %3;\n+                          %13 : java.type:\"java.lang.String\" = constant @\"four \";\n+                          %14 : java.type:\"java.lang.String\" = concat %12 %13;\n+                          var.store %3 %14;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%15 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %16 : java.type:\"int\" = constant @2;\n+                          %17 : java.type:\"boolean\" = eq %15 %16;\n+                          yield %17;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %18 : java.type:\"java.lang.String\" = var.load %3;\n+                          %19 : java.type:\"java.lang.String\" = constant @\"two \";\n+                          %20 : java.type:\"java.lang.String\" = concat %18 %19;\n+                          var.store %3 %20;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%21 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %22 : java.type:\"int\" = constant @3;\n+                          %23 : java.type:\"boolean\" = eq %21 %22;\n+                          yield %23;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %24 : java.type:\"java.lang.String\" = var.load %3;\n+                          %25 : java.type:\"java.lang.String\" = constant @\"three \";\n+                          %26 : java.type:\"java.lang.String\" = concat %24 %25;\n+                          var.store %3 %26;\n+                          java.switch.fallthrough;\n+                      }\n+                      (%27 : java.type:\"int\")java.type:\"boolean\" -> {\n+                          %28 : java.type:\"int\" = constant @1;\n+                          %29 : java.type:\"boolean\" = eq %27 %28;\n+                          yield %29;\n+                      }\n+                      ()java.type:\"void\" -> {\n+                          %30 : java.type:\"java.lang.String\" = var.load %3;\n+                          %31 : java.type:\"java.lang.String\" = constant @\"one\";\n+                          %32 : java.type:\"java.lang.String\" = concat %30 %31;\n+                          var.store %3 %32;\n+                          yield;\n+                      };\n+                  %33 : java.type:\"java.lang.String\" = var.load %3;\n+                  return %33;\n+              };\n+            \"\"\")\n+    @Reflect\n+    static String outOfOrderFallThrought(int i) {\n+        String ret = \"\";\n+        switch (i) {\n+            default:\n+                ret += \"? \";\n+            case 4:\n+                ret += \"four \";\n+            case 2:\n+                ret += \"two \";\n+            case 3:\n+                ret += \"three \";\n+            case 1:\n+                ret += \"one\";\n+        }\n+        return ret;\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":99,"deletions":11,"binary":false,"changes":110,"status":"modified"}]}