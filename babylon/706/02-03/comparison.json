{"files":[{"patch":"@@ -119,1 +119,1 @@\n-        Reference(Block target, List<? extends Value> arguments) {\n+        public Reference(Block target, List<? extends Value> arguments) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n@@ -50,9 +52,1 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.IdentityHashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.SequencedMap;\n-import java.util.Set;\n+import java.util.*;\n@@ -60,7 +54,2 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n+\n+import jdk.incubator.code.*;\n@@ -70,0 +59,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -71,0 +61,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -75,0 +66,1 @@\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -79,0 +71,1 @@\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n@@ -88,4 +81,4 @@\n-    static CodeTransformer BYTECODE_LOWERING_TRANSFORMER = (block, op) -> {\n-        return switch (op) {\n-\/\/            case JavaOp.JavaSwitchOp swop when isConstantLabelSwitch(swop)-> {\n-\/\/               @@@ lower JavaOp.JavaSwitchOp to ConstantLabelSwitchOp\n+\/\/    static CodeTransformer BYTECODE_LOWERING_TRANSFORMER = (block, op) -> {\n+\/\/        return switch (op) {\n+\/\/            case JavaOp.JavaSwitchOp swop when new ConstantLabelSwitchChecker(swop, lookup).isCaseConstantSwitch() -> {\n+\/\/               \/\/@@@ lower JavaOp.JavaSwitchOp to ConstantLabelSwitchOp\n@@ -93,8 +86,8 @@\n-            case Op.Lowerable lop ->\n-                lop.lower(block, null);\n-            default -> {\n-                block.op(op);\n-                yield block;\n-            }\n-        };\n-    };\n+\/\/            case Op.Lowerable lop ->\n+\/\/                lop.lower(block, null);\n+\/\/            default -> {\n+\/\/                block.op(op);\n+\/\/                yield block;\n+\/\/            }\n+\/\/        };\n+\/\/    };\n@@ -148,0 +141,128 @@\n+    public static final class ConstantLabelSwitchChecker {\n+        private final MethodHandles.Lookup lookup;\n+        private JavaSwitchOp swOp;\n+\n+        public ConstantLabelSwitchChecker(JavaSwitchOp swOp, MethodHandles.Lookup lookup) {\n+            this.swOp = swOp;\n+            this.lookup = lookup;\n+        }\n+\n+        private static boolean isFinalVar(VarOp varOp) {\n+            return varOp.initOperand() != null && varOp.result().uses().stream().noneMatch(u -> u.op() instanceof VarAccessOp.VarStoreOp);\n+        }\n+\n+        private static boolean isBoxingMethod(MethodRef mr) {\n+            return List.of(J_L_BYTE, J_L_CHARACTER, J_L_SHORT, J_L_INTEGER, J_L_LONG, J_L_FLOAT, J_L_DOUBLE).contains(mr.refType())\n+                    && mr.name().equals(\"valueOf\");\n+        }\n+\n+        private static boolean isIntegralType(TypeElement te) {\n+            return isIntegralPrimitiveType(te) || isIntegralReferenceType(te);\n+        }\n+\n+        private static boolean isIntegralPrimitiveType(TypeElement te) {\n+            return List.of(BYTE, SHORT, CHAR, INT).contains(te);\n+        }\n+\n+        private static boolean isIntegralReferenceType(TypeElement te) {\n+            return List.of(J_L_BYTE, J_L_SHORT, J_L_CHARACTER, J_L_INTEGER).contains(te);\n+        }\n+\n+        private boolean isConstantExpr(Value v) {\n+            if (!(v instanceof Result opr)) {\n+                return false;\n+            }\n+            Op op = opr.op();\n+            if (op instanceof ConstantOp cop) {\n+                return cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n+            }\n+            if (op instanceof VarAccessOp.VarLoadOp varLoadOp) {\n+                return isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand());\n+            }\n+            if (op instanceof ConvOp convOp) {\n+                return (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n+                        isConstantExpr(convOp.operands().get(0));\n+            }\n+            if (op instanceof InvokeOp invokeOp) {\n+                return isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0));\n+            }\n+            if (op instanceof FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                Field field;\n+                try {\n+                    field = fieldLoadOp.fieldDescriptor().resolveToField(lookup);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                return field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n+            }\n+            if (op instanceof UnaryOp unaryOp) {\n+                return isConstantExpr(unaryOp.operands().get(0));\n+            }\n+            if (op instanceof BinaryOp binaryOp) {\n+                return binaryOp.operands().stream().allMatch(o -> isConstantExpr(o));\n+            }\n+            if (op instanceof BinaryTestOp binaryTestOp) {\n+                return binaryTestOp.operands().stream().allMatch(o -> isConstantExpr(o));\n+            }\n+            if (op instanceof ConditionalExpressionOp cexpr) {\n+                \/\/ bodies must yield constant expressions\n+                return isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue());\n+            }\n+            \/\/ conditional and, conditional or, example ?\n+            if (op instanceof ConditionalAndOp cand) {\n+                return isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+            }\n+            if (op instanceof ConditionalOrOp cor) {\n+                \/\/ we can have a method isBodyYieldConstantExpr(Body)\n+                return isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+            }\n+            return false;\n+        }\n+\n+        private boolean isCaseConstantLabel(Body label) {\n+            if (label.blocks().size() != 1 || !(label.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                    !(yop.yieldValue() instanceof Result r)) {\n+                return false;\n+            }\n+\n+            \/\/ EqOp for primitives, method invocation for Strings and Reference Types\n+            if (r.op() instanceof EqOp eqOp) {\n+                return isConstantExpr(eqOp.operands().get(1));\n+            }\n+            if (r.op() instanceof InvokeOp invokeOp) {\n+                MethodRef OBJECTS_EQUALS_METHOD = MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class);\n+                if (!invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS_METHOD)) {\n+                    return false;\n+                }\n+                \/\/ case null\n+                if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof ConstantOp cop && cop.value() == null) {\n+                    return false;\n+                }\n+                return isConstantExpr(invokeOp.operands().get(1));\n+            }\n+            if (r.op() instanceof ConditionalOrOp cor) { \/\/ list of case constant\n+                return cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b));\n+            }\n+            return r.op() instanceof ConstantOp cop && cop.resultType().equals(BOOLEAN); \/\/ default label\n+        }\n+\n+        public boolean isCaseConstantSwitch() {\n+            if (!isIntegralType(swOp.operands().get(0).type())) {\n+                return false;\n+            }\n+            for (int i = 0; i < swOp.bodies().size(); i+=2) {\n+                Body label = swOp.bodies().get(i);\n+                if (!isCaseConstantLabel(label)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/\n+\n@@ -194,0 +315,65 @@\n+    record LabelsAndTargets(List<Integer> labels, List<Block.Reference> targets) {}\n+\n+    static LabelsAndTargets getLabelsAndTargets(MethodHandles.Lookup lookup, JavaSwitchOp swOp) {\n+        var labels = new ArrayList<Integer>();\n+        var targets = new ArrayList<Block.Reference>();\n+        for (int i = 0; i < swOp.bodies().size() - 1; i += 2) {\n+            List<Integer> ls = getLabels(lookup, swOp.bodies().get(i));\n+            labels.addAll(ls);\n+            \/\/ labels is empty for case default\n+            targets.addAll(Collections.nCopies(Math.max(ls.size(), 1), new Block.Reference(swOp.bodies().get(i + 1).entryBlock(), List.of())));\n+        }\n+        return new LabelsAndTargets(labels, targets);\n+    }\n+\n+    static List<Integer> getLabels(MethodHandles.Lookup lookup, Body body) {\n+        if (body.blocks().size() != 1 || !(body.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                !(yop.yieldValue() instanceof Result opr)) {\n+            throw new IllegalStateException(\"Body of a java switch fails the expected structure\");\n+        }\n+        var labels = new ArrayList<Integer>();\n+        if (opr.op() instanceof EqOp eqOp) {\n+            labels.add(extractConstantLabel(lookup, body, eqOp));\n+        } else if (opr.op() instanceof InvokeOp invokeOp &&\n+                invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class))) {\n+            labels.add(extractConstantLabel(lookup, body, invokeOp));\n+        } else if (opr.op() instanceof ConditionalOrOp cor) {\n+            for (Body corbody : cor.bodies()) {\n+                labels.addAll(getLabels(lookup, corbody));\n+            }\n+        } else if (!(opr.op() instanceof CoreOp.ConstantOp)){ \/\/ not default label\n+            throw new IllegalStateException();\n+        }\n+        return labels;\n+    }\n+\n+    static Integer extractConstantLabel(MethodHandles.Lookup lookup, Body body, Op whenToStop) {\n+        Op lastOp = body.entryBlock().ops().get(body.entryBlock().ops().indexOf(whenToStop) - 1);\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", CoreType.functionType(lastOp.result().type())).body(block -> {\n+            \/\/ in case we refer to constant variables in the label\n+            for (Value capturedValue : body.capturedValues()) {\n+                if (!(capturedValue instanceof Result r) || !(r.op() instanceof CoreOp.VarOp vop)) {\n+                    continue;\n+                }\n+                block.op(((Result) vop.initOperand()).op());\n+                block.op(vop);\n+            }\n+            Result last = null;\n+            for (Op op : body.entryBlock().ops()) {\n+                if (op.equals(whenToStop)) {\n+                    break;\n+                }\n+                last = block.op(op);\n+            }\n+            block.op(CoreOp.return_(last));\n+        });\n+        Object res = Interpreter.invoke(lookup, funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+        return switch (res) {\n+            case Byte b -> Integer.valueOf(b);\n+            case Short s -> Integer.valueOf(s);\n+            case Character c -> Integer.valueOf(c);\n+            case Integer i -> i;\n+            default -> throw new IllegalStateException(); \/\/ @@@ not going to happen\n+        };\n+    }\n+\n@@ -203,1 +389,29 @@\n-                O lowered = (O)e.getValue().transform(CodeContext.create(), BYTECODE_LOWERING_TRANSFORMER);\n+                O lowered = (O)e.getValue().transform(CodeContext.create(), ((block, op) -> switch (op) {\n+                    case JavaSwitchOp swOp when new ConstantLabelSwitchChecker(swOp, lookup).isCaseConstantSwitch() -> {\n+                        LabelsAndTargets labelsAndTargets = getLabelsAndTargets(lookup, swOp);\n+                        List<Block.Reference> targets = new ArrayList<>();\n+                        \/\/ the targets need to be part of the block's body\n+                        Block.Builder end = block.block(swOp.resultType());\n+                        block.context().mapValue(swOp.result(), end.parameters().get(0));\n+                        for (Block.Reference reference : labelsAndTargets.targets()) {\n+                            Block.Builder b = block.block();\n+                            for (Op o : reference.targetBlock().ops()) {\n+                                if (o instanceof CoreOp.YieldOp yop) {\n+                                    b.op(CoreOp.branch(end.successor(b.context().getValue(yop.yieldValue()))));\n+                                } else {\n+                                    b.op(o);\n+                                }\n+                            }\n+                            targets.add(b.successor(List.of()));\n+                        }\n+                        Value selector = block.context().getValue(swOp.operands().get(0));\n+                        block.op(new ConstantLabelSwitchOp(selector, labelsAndTargets.labels(), targets));\n+                        yield end;\n+                    }\n+                    case Lowerable lop ->\n+                            lop.lower(block, null);\n+                    default -> {\n+                        block.op(op);\n+                        yield block;\n+                    }\n+                }));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":243,"deletions":29,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -399,0 +399,9 @@\n+            \/\/ default case\n+            Body.Builder dl = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n+            Block.Parameter target = dl.entryBlock().parameter(INT);\n+            dl.entryBlock().op(core_yield(dl.entryBlock().op(constant(BOOLEAN, true))));\n+            Body.Builder de = Body.Builder.of(b.parentBody(), functionType(type(ExternalizedTypeElement.class)));\n+            de.entryBlock().op(throw_(de.entryBlock().op(new_(MethodRef.constructor(IllegalStateException.class)))));\n+            swBodies.add(dl);\n+            swBodies.add(de);\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @enablePreview\n+ * @compile TestIsCaseConstantSwitch.java\n+ * @run junit TestIsCaseConstantSwitch\n+ *\/\n+public class TestIsCaseConstantSwitch {\n+\n+    class C {\n+        static final int x = 26;\n+    }\n+\n+    @Reflect\n+    private static void caseConstantSwitchExpressions() {\n+        \/\/ switch label\n+        \/\/ case label\n+        \/\/ list of case constant\n+        \/\/ every case constant must be either a constant expression or the name of an enum constant\n+        \/\/ null literal\n+        \/\/ list of case patterns\n+        \/\/ default label\n+        final int fv = 25;\n+        int i = -1;\n+        String r = switch (i) {\n+            \/\/ literal of primitive type\n+            case 1 -> \"A\";\n+            \/\/ unary operators +, -, ~\n+            case +2 -> \"B\";\n+            case -2 -> \"BB\";\n+            case ~2 -> \"BBB\"; \/\/ -3\n+            \/\/ multiplicative operators *, \/, %\n+            case 3 * 4 -> \"E\";\n+            case 3 \/ 4 -> \"EE\";\n+            case 3 % 4 -> \"EEE\";\n+            \/\/ shift operators <<, >>, >>>\n+            case 4 << 5 -> \"F\"; \/\/ 128\n+            case 10 >> 1 -> \"FF\"; \/\/ 5\n+            case 8 >>> 1 -> \"FFF\"; \/\/ 4\n+            \/\/ relational operators <, <=, >, >= (and conditional operator)\n+            case 1 < 2 ? 9 : 10 -> \"G\"; \/\/ 9\n+            case 1 <= 2 ? 11 : 12 -> \"GG\"; \/\/ 11\n+            case 1 > 2 ? 13 : 14 -> \"GGG\"; \/\/ 14\n+            case 1 >= 2 ? 15 : 16 -> \"GGGG\"; \/\/ 16\n+            \/\/ equality operators ==, !=\n+            case 1 == 2 ? 17 : 18 -> \"H\"; \/\/ 18\n+            case 1 != 2 ? 19 : 20 -> \"HH\"; \/\/ 19\n+            \/\/ bitwise and logical operators &, ^, |\n+            case 6 & 6 -> \"I\"; \/\/ 6\n+            case 7 ^ 8 -> \"II\"; \/\/ 15\n+            case 8 | 10 -> \"III\"; \/\/ 10\n+            \/\/ conditional-and operator &&\n+            case 2 > 3 && 5 > 6 ? 21 : 22 -> \"J\"; \/\/ 22\n+            case 2 > 3 || 5 > 6 ? 23 : 24 -> \"JJ\"; \/\/ 24\n+            \/\/ parenthesized expressions whose contained expression is a constant expression\n+            case (20) -> \"K\";\n+            \/\/ simple names that refer to constant variables\n+            case fv -> \"L\";\n+            \/\/ qualified names of the form TypeName.Identifier that refer to constant variables\n+            case C.x -> \"M\";\n+            \/\/ list of case constants\n+            case 21, 30 -> null;\n+            \/\/ casts\n+            case (int) 31L -> \"N\";\n+            case (int) 34f -> \"NN\";\n+            \/\/ default\n+            default -> \"X\";\n+        };\n+\n+        \/\/ we can have a target of type Byte, Short, Character, Integer\n+        \/\/ as long as we don't introduce case null, javac will generate labels identical to what we have in source code\n+        Integer ii = -2;\n+        r = switch (ii) {\n+            case 1 -> \"A\";\n+            default -> \"X\";\n+        };\n+\n+        char c = '2';\n+        r = switch (c) {\n+            case '1' -> \"1\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    enum E {\n+        V;\n+    }\n+\n+    @Reflect\n+    static void nonCaseConstantSwitchExpressions() {\n+        int r;\n+\n+        String s = \"\";\n+        r = switch (s) {\n+            case \"A\" -> 1;\n+            default -> 0;\n+        };\n+\n+        E e = E.V;\n+        r = switch (e) {\n+            case V -> 1;\n+        };\n+\n+        boolean b = false;\n+        r = switch (b) {\n+            case true -> 1;\n+            default -> 0;\n+        };\n+\n+        long l = 5L;\n+        r = switch (l) {\n+            case 1L -> 1;\n+            default -> 0;\n+        };\n+\n+        float f = 5f;\n+        r = switch (f) {\n+            case 1f -> 1;\n+            default -> 0;\n+        };\n+\n+        double d = 5d;\n+        r = switch (d) {\n+            case 1d -> 1;\n+            default -> 0;\n+        };\n+\n+        Integer i = 4;\n+        r = switch (i) {\n+            case 1 -> 1;\n+            case null -> -1;\n+            default -> 0;\n+        };\n+    }\n+\n+    static Stream<Arguments> cases() {\n+        return Stream.of(\n+                Arguments.of(\"caseConstantSwitchExpressions\", true),\n+                Arguments.of(\"nonCaseConstantSwitchExpressions\", false)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    void testIsConstantLabelSwitch(String methodName, boolean expected) throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(methodName);\n+        CoreOp.FuncOp codeModel = Op.ofMethod(m).get();\n+        List<SwitchExpressionOp> swExprOps = codeModel.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof SwitchExpressionOp)\n+                .map(o -> ((SwitchExpressionOp) o)).toList();\n+        for (SwitchExpressionOp swExprOp : swExprOps) {\n+            Assertions.assertEquals(\n+                    new BytecodeGenerator.ConstantLabelSwitchChecker(swExprOp, MethodHandles.lookup()).isCaseConstantSwitch(),\n+                    expected,\n+                    swExprOp.toText());\n+        }\n+    }\n+\n+    @Test\n+    void testGettingLabels() throws NoSuchMethodException {\n+        var expectedLabels = List.of(1, +2, -2, ~2, 12, 3 \/ 4, 3 % 4, 4 << 5, 10 >> 1,\n+                8 >>> 1, 1 < 2 ? 9 : 10, 1 <= 2 ? 11 : 12, 1 > 2 ? 13 : 14, 1 >= 2 ? 15 : 16, 1 == 2 ? 17 : 18,\n+                1 != 2 ? 19 : 20, 6 & 6, 7 ^ 8, 8 | 10, 2 > 3 && 5 > 6 ? 21 : 22, 2 > 3 || 5 > 6 ? 23 : 24, (20), 25,\n+                C.x, 21, 30, (int) 31L, (int) 34f );\n+        var funcOp = Op.ofMethod(this.getClass().getDeclaredMethod(\"caseConstantSwitchExpressions\")).get();\n+        System.out.println(funcOp.toText());\n+        var swOp = (JavaSwitchOp) funcOp.body().entryBlock().ops().stream().filter(op -> op instanceof JavaSwitchOp).findFirst().get();\n+        List<Integer> actualLabels = getLabelsAndTargets(MethodHandles.lookup(), swOp);\n+        System.out.println(actualLabels);\n+        Assertions.assertEquals(expectedLabels, actualLabels);\n+    }\n+\n+    static ArrayList<Integer> getLabelsAndTargets(MethodHandles.Lookup lookup, JavaSwitchOp swOp) {\n+        var labels = new ArrayList<Integer>();\n+        for (int i = 0; i < swOp.bodies().size(); i += 2) {\n+            Body labelBody = swOp.bodies().get(i);\n+            labels.addAll(getLabels(lookup, labelBody));\n+        }\n+        return labels;\n+    }\n+\n+    static List<Integer> getLabels(MethodHandles.Lookup lookup, Body body) {\n+        if (body.blocks().size() != 1 || !(body.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                !(yop.yieldValue() instanceof Result opr)) {\n+            throw new IllegalStateException(\"Body of a java switch fails the expected structure\");\n+        }\n+        var labels = new ArrayList<Integer>();\n+        if (opr.op() instanceof EqOp eqOp) {\n+            labels.add(extractConstantLabel(lookup, body, eqOp));\n+        } else if (opr.op() instanceof InvokeOp invokeOp &&\n+                invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class))) {\n+            labels.add(extractConstantLabel(lookup, body, invokeOp));\n+        } else if (opr.op() instanceof ConditionalOrOp cor) {\n+            for (Body corbody : cor.bodies()) {\n+                labels.addAll(getLabels(lookup, corbody));\n+            }\n+        } else if (!(opr.op() instanceof CoreOp.ConstantOp)){ \/\/ not default label\n+            throw new IllegalStateException();\n+        }\n+        return labels;\n+    }\n+\n+    static Integer extractConstantLabel(MethodHandles.Lookup lookup, Body body, Op whenToStop) {\n+        Op lastOp = body.entryBlock().ops().get(body.entryBlock().ops().indexOf(whenToStop) - 1);\n+        CoreOp.FuncOp funcOp = CoreOp.func(\"f\", CoreType.functionType(lastOp.result().type())).body(block -> {\n+            \/\/ in case we refer to constant variables in the label\n+            for (Value capturedValue : body.capturedValues()) {\n+                if (!(capturedValue instanceof Result r) || !(r.op() instanceof CoreOp.VarOp vop)) {\n+                    continue;\n+                }\n+                block.op(((Result) vop.initOperand()).op());\n+                block.op(vop);\n+            }\n+            Result last = null;\n+            for (Op op : body.entryBlock().ops()) {\n+                if (op.equals(whenToStop)) {\n+                    break;\n+                }\n+                last = block.op(op);\n+            }\n+            block.op(CoreOp.return_(last));\n+        });\n+        Object res = Interpreter.invoke(lookup, funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+        return switch (res) {\n+            case Byte b -> Integer.valueOf(b);\n+            case Short s -> Integer.valueOf(s);\n+            case Character c -> Integer.valueOf(c);\n+            case Integer i -> i;\n+            default -> throw new IllegalStateException(); \/\/ @@@ not going to happen\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestIsCaseConstantSwitch.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}