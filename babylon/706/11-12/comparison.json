{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import jdk.incubator.code.internal.BranchTarget;\n@@ -48,1 +49,0 @@\n-import static jdk.incubator.code.dialect.core.CoreOp.Lowerable;\n@@ -83,1 +83,1 @@\n-        JavaOp.setBranchTarget(block.context(), swOp, new JavaOp.BranchTarget(exit, null));\n+        BranchTarget.setBranchTarget(block.context(), swOp, exit, null);\n@@ -87,1 +87,1 @@\n-            JavaOp.setBranchTarget(block.context(), targets.get(i).parent(), new JavaOp.BranchTarget(null, blocks.get(i+1)));\n+            BranchTarget.setBranchTarget(block.context(), targets.get(i).parent(), null, blocks.get(i+1));\n@@ -158,20 +158,18 @@\n-            Op op = opr.op();\n-            if (op instanceof CoreOp.ConstantOp cop) {\n-                return cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n-            }\n-            if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                return isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand());\n-            }\n-            if (op instanceof JavaOp.ConvOp convOp) {\n-                return (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n-                        isConstantExpr(convOp.operands().get(0));\n-            }\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                return isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0));\n-            }\n-            if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                Field field;\n-                try {\n-                    field = fieldLoadOp.fieldDescriptor().resolveToField(lookup);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new RuntimeException(e);\n+            return switch (opr.op()) {\n+                case CoreOp.ConstantOp cop ->\n+                        cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n+                case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->\n+                        isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand());\n+                case JavaOp.ConvOp convOp ->\n+                        (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n+                                isConstantExpr(convOp.operands().get(0));\n+                case JavaOp.InvokeOp invokeOp ->\n+                        isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0));\n+                case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n+                    Field field;\n+                    try {\n+                        field = fieldLoadOp.fieldDescriptor().resolveToField(lookup);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    yield field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n@@ -179,28 +177,18 @@\n-                return field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n-            }\n-            if (op instanceof JavaOp.UnaryOp unaryOp) {\n-                return isConstantExpr(unaryOp.operands().get(0));\n-            }\n-            if (op instanceof JavaOp.BinaryOp binaryOp) {\n-                return binaryOp.operands().stream().allMatch(o -> isConstantExpr(o));\n-            }\n-            if (op instanceof JavaOp.BinaryTestOp binaryTestOp) {\n-                return binaryTestOp.operands().stream().allMatch(o -> isConstantExpr(o));\n-            }\n-            if (op instanceof JavaOp.ConditionalExpressionOp cexpr) {\n-                \/\/ bodies must yield constant expressions\n-                return isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue());\n-            }\n-            \/\/ conditional and, conditional or, example ?\n-            if (op instanceof JavaOp.ConditionalAndOp cand) {\n-                return isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n-            }\n-            if (op instanceof JavaOp.ConditionalOrOp cor) {\n-                \/\/ we can have a method isBodyYieldConstantExpr(Body)\n-                return isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n-                        isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n-            }\n-            return false;\n+                case JavaOp.UnaryOp unaryOp -> isConstantExpr(unaryOp.operands().get(0));\n+                case JavaOp.BinaryOp binaryOp -> binaryOp.operands().stream().allMatch(this::isConstantExpr);\n+                case JavaOp.BinaryTestOp binaryTestOp ->\n+                        binaryTestOp.operands().stream().allMatch(this::isConstantExpr);\n+                case JavaOp.ConditionalExpressionOp cexpr -> \/\/ bodies must yield constant expressions\n+                        isConstantExpr(((YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue());\n+\n+                case JavaOp.ConditionalAndOp cand ->\n+                        isConstantExpr(((YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+                case JavaOp.ConditionalOrOp cor ->\n+                    \/\/ we can have a method isBodyYieldConstantExpr(Body)\n+                        isConstantExpr(((YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue()) &&\n+                                isConstantExpr(((YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue());\n+                default -> false;\n+            };\n@@ -216,11 +204,9 @@\n-            if (r.op() instanceof JavaOp.EqOp eqOp) {\n-                return isConstantExpr(eqOp.operands().get(1));\n-            }\n-            if (r.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                MethodRef OBJECTS_EQUALS_METHOD = MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class);\n-                if (!invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS_METHOD)) {\n-                    return false;\n-                }\n-                \/\/ case null\n-                if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n-                    return false;\n+            return switch (r.op()) {\n+                case JavaOp.EqOp eqOp -> isConstantExpr(eqOp.operands().get(1));\n+                case JavaOp.InvokeOp invokeOp when !invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS) -> false;\n+                case JavaOp.InvokeOp invokeOp -> {\n+                    \/\/ case null\n+                    if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n+                        yield false;\n+                    }\n+                    yield  isConstantExpr(invokeOp.operands().get(1));\n@@ -228,6 +214,3 @@\n-                return isConstantExpr(invokeOp.operands().get(1));\n-            }\n-            if (r.op() instanceof JavaOp.ConditionalOrOp cor) { \/\/ list of case constant\n-                return cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b));\n-            }\n-            return r.op() instanceof CoreOp.ConstantOp cop && cop.resultType().equals(BOOLEAN); \/\/ default label\n+                case JavaOp.ConditionalOrOp cor -> cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b));\n+                default -> r.op() instanceof CoreOp.ConstantOp cop && cop.resultType().equals(BOOLEAN);\n+            };\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/impl\/LoweringTransform.java","additions":51,"deletions":68,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.incubator.code.internal.BranchTarget;\n@@ -2073,1 +2074,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), opt);\n+            BranchTarget t = BranchTarget.getBranchTarget(b.context(), opt);\n@@ -2148,21 +2149,0 @@\n-    public record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n-    }\n-\n-    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n-\n-    public static BranchTarget getBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n-        if (m != null) {\n-            return m.get(codeElement);\n-        }\n-        return null;\n-    }\n-\n-    public static void setBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n-                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n-        x.put(codeElement, t);\n-    }\n-\n@@ -2220,1 +2200,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), opt);\n+            BranchTarget t = BranchTarget.getBranchTarget(b.context(), opt);\n@@ -2301,1 +2281,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2392,1 +2372,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2527,1 +2507,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2711,1 +2691,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2836,1 +2816,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -2840,1 +2820,1 @@\n-                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+                BranchTarget.setBranchTarget(b.context(), bodies().get(i), null, blocks.get(i + 2));\n@@ -3017,1 +2997,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), ancestorBody());\n+            BranchTarget t = BranchTarget.getBranchTarget(b.context(), ancestorBody());\n@@ -3246,1 +3226,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, update);\n@@ -3463,1 +3443,1 @@\n-                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+                BranchTarget.setBranchTarget(b.context(), this, exit, update);\n@@ -3489,1 +3469,1 @@\n-                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+                BranchTarget.setBranchTarget(b.context(), this, exit, header);\n@@ -3621,1 +3601,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, header);\n@@ -3742,1 +3722,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, header);\n@@ -4030,1 +4010,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n@@ -4266,1 +4246,1 @@\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            BranchTarget.setBranchTarget(b.context(), this, exit, null);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":18,"deletions":38,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeContext;\n+import jdk.incubator.code.CodeElement;\n+\n+\n+public record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+\n+    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n+\n+    public static BranchTarget getBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget> m = (Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(codeElement);\n+        }\n+        return null;\n+    }\n+\n+    public static void setBranchTarget(CodeContext cc, CodeElement<?, ?> codeElement, Block.Builder breakBlock, Block.Builder continueBlock) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget> x = (Map<jdk.incubator.code.CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(codeElement, new BranchTarget(breakBlock, continueBlock));\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/BranchTarget.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"}]}