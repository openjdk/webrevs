{"files":[{"patch":"@@ -30,2 +30,0 @@\n-import java.util.function.BiFunction;\n-import java.util.function.Predicate;\n@@ -178,0 +176,69 @@\n+    \/**\n+     * Compares two code elements by comparing their pre-order traversal positions in the code model.\n+     * <p>\n+     * The pre-order traversal position of a code element, {@code e} say, is equivalent to result of\n+     * the expression {@code root.elements().toList().indexOf(e)}, where {@code root} is the root\n+     * code element of the code model containing {@code e}.\n+     *\n+     * @param a the first code element to compare\n+     * @param b the second code element to compare\n+     * @return the value {@code 0} if {@code a == b}; {@code -1} if {@code a}'s pre-order traversal position\n+     * is less than {@code b}'s position; and {@code 1} if {@code a}'s pre-order traversal position\n+     * is greater than {@code b}'s position\n+     * @throws IllegalArgumentException if {@code a} and {@code b} are not present in the same code model\n+     *\/\n+    static int compare(CodeElement<?, ?> a, CodeElement<?, ?> b) {\n+        if (a == b) {\n+            return 0;\n+        }\n+\n+        \/\/ Find the common ancestor of a and b and the respective children\n+        int depthA = getDepth(a);\n+        int depthB = getDepth(b);\n+\n+        CodeElement<?, ?> childA = a;\n+        CodeElement<?, ?> childB = b;\n+        while (depthA > depthB) {\n+            childA = a;\n+            a = a.parent();\n+            depthA--;\n+        }\n+\n+        while (depthB > depthA) {\n+            childB = b;\n+            b = b.parent();\n+            depthB--;\n+        }\n+\n+        while (a != b) {\n+            childA = a;\n+            a = a.parent();\n+            childB = b;\n+            b = b.parent();\n+        }\n+\n+        if (a == null) {\n+            \/\/ No common ancestor, a and b are not in the same code model\n+            throw new IllegalArgumentException(\"Comparing code elements in different code models\");\n+        } else if (a == childA) {\n+            \/\/ a is an ancestor of b\n+            return -1;\n+        } else if (a == childB) {\n+            \/\/ b is an ancestor of a\n+            return 1;\n+        } else {\n+            \/\/ a and b share a common ancestor\n+            List<?> children = a.children();\n+            return Integer.compare(children.indexOf(childA), children.indexOf(childB));\n+        }\n+    }\n+\n+    private static int getDepth(CodeElement<?, ?> a) {\n+        int depth = 0;\n+        while (a.parent() != null) {\n+            a = a.parent();\n+            depth++;\n+        }\n+        return depth;\n+    }\n+\n@@ -180,2 +247,0 @@\n-\n-    \/\/ Des\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeElement.java","additions":69,"deletions":4,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.util.Collections;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.SequencedSet;\n+import java.util.*;\n@@ -37,1 +34,1 @@\n-public sealed abstract class Value implements Comparable<Value>, CodeItem\n+public sealed abstract class Value implements CodeItem\n@@ -66,0 +63,15 @@\n+    \/**\n+     * Returns this value's declaring code element.\n+     * <p>If the value is an operation result, then the declaring code element is the operation.\n+     * If the value is a block parameter then the declaring code element is this value's declaring block.\n+     *\n+     * @return the value's declaring code element.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public CodeElement<?, ?> declaringElement() {\n+        return switch (this) {\n+            case Block.Parameter _ -> block;\n+            case Op.Result r -> r.op();\n+        };\n+    }\n+\n@@ -169,43 +181,18 @@\n-\n-    @Override\n-    public int compareTo(Value o) {\n-        return compare(this, o);\n-    }\n-\n-    \/\/ @@@\n-    public static int compare(Value v1, Value v2) {\n-        if (v1 == v2) return 0;\n-\n-        Block b1 = v1.declaringBlock();\n-        Block b2 = v2.declaringBlock();\n-        if (b1 == b2) {\n-            if (v1 instanceof Op.Result or1 && v2 instanceof Op.Result or2) {\n-                List<Op> ops = b1.ops();\n-                return Integer.compare(ops.indexOf(or1.op()), ops.indexOf(or2.op()));\n-            } else if (v1 instanceof Op.Result) {\n-                \/\/ v2 instanceof BlockParameter\n-                return 1;\n-            } else if (v2 instanceof Op.Result) {\n-                \/\/ v1 instanceof BlockParameter\n-                return -1;\n-            } else { \/\/ v1 && v2 instanceof BlockParameter\n-                assert v1 instanceof Block.Parameter && v2 instanceof Block.Parameter;\n-                List<Block.Parameter> args = b1.parameters();\n-                return Integer.compare(args.indexOf(v1), args.indexOf(v2));\n-            }\n-        }\n-\n-        Body r1 = b1.ancestorBody();\n-        Body r2 = b2.ancestorBody();\n-        if (r1 == r2) {\n-            return Integer.compare(b1.index(), b2.index());\n-        }\n-\n-        Op o1 = r1.ancestorOp();\n-        Op o2 = r2.ancestorOp();\n-        if (o1 == o2) {\n-            List<Body> rs = o1.bodies();\n-            return Integer.compare(rs.indexOf(r1), rs.indexOf(r2));\n-        }\n-\n-        return compare(o1.result(), o2.result());\n+    \/**\n+     * Compares two values by comparing their declaring elements.\n+     *\n+     * @apiNote\n+     * This method behaves is if it returns the result of the following expression but may be implemented more\n+     * efficiently.\n+     * {@snippet :\n+     * Comparator.comparing(Value::declaringElement, CodeElement::compare).compare(a, b)\n+     * }\n+     * @param a the first value to compare\n+     * @param b the second value to compare\n+     * @return the value {@code 0} if {@code a == b}; {@code -1} if {@code a} is less than {@code b}; and {@code -1}\n+     * if {@code a} is greater than {@code b}.\n+     * @throws IllegalArgumentException if {@code a} and {@code b} are not present in the same code model\n+     * @see CodeElement#compare\n+     *\/\n+    public static int compare(Value a, Value b) {\n+        return CodeElement.compare(a.declaringElement(), b.declaringElement());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Value.java","additions":35,"deletions":48,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @enablePreview\n+ * @run junit TestCompareCodeItems\n+ *\/\n+\n+public class TestCompareCodeItems {\n+\n+    @Reflect\n+    IntBinaryOperator f = (a, b) -> {\n+        IntUnaryOperator u = v ->\n+                v + ((a > b) ? a : b + 42);\n+        int sum = 0;\n+        for (int i = 0; i < 10; i++) {\n+            sum += u.applyAsInt(i) + 42;\n+            if (sum instanceof byte _) {\n+                \/\/ Increment sum if it fits in a byte\n+                sum++;\n+            }\n+        }\n+        return sum;\n+    };\n+\n+    @Test\n+    public void testCompareCodeElements() {\n+        JavaOp.LambdaOp op = Op.ofLambda(f).orElseThrow().op();\n+\n+        testCompareCodeElements(op);\n+        op = op.transform(CodeContext.create(), CodeTransformer.LOWERING_TRANSFORMER);\n+        testCompareCodeElements(op);\n+    }\n+\n+    void testCompareCodeElements(Op op) {\n+        List<CodeElement<?, ?>> l = op.elements().toList();\n+\n+        for (int i = 0; i < l.size(); i++) {\n+            for (int j = 0; j < l.size(); j++) {\n+                CodeElement<?, ?> a = l.get(i);\n+                CodeElement<?, ?> b = l.get(j);\n+                Assertions.assertEquals(CodeElement.compare(a, b), Integer.compare(i, j));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCompareCodeElementsDifferentModels() {\n+        JavaOp.LambdaOp op1 = Op.ofLambda(f).orElseThrow().op();\n+        JavaOp.LambdaOp op2 = op1.transform(CodeContext.create(), CodeTransformer.COPYING_TRANSFORMER);\n+\n+        testCompareCodeElements(op1, op2);\n+    }\n+\n+    void testCompareCodeElements(Op op1, Op op2) {\n+        List<CodeElement<?, ?>> l1 = op1.elements().toList();\n+        List<CodeElement<?, ?>> l2 = op2.elements().toList();\n+\n+        for (int i = 0; i < l1.size(); i++) {\n+            for (int j = 0; j < l2.size(); j++) {\n+                CodeElement<?, ?> a = l1.get(i);\n+                CodeElement<?, ?> b = l2.get(j);\n+                Assertions.assertThrows(IllegalArgumentException.class, () -> CodeElement.compare(a, b));\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testCompareValues() {\n+        JavaOp.LambdaOp op = Op.ofLambda(f).orElseThrow().op();\n+\n+        testCompareValues(op);\n+        op = op.transform(CodeContext.create(), CodeTransformer.LOWERING_TRANSFORMER);\n+        testCompareValues(op);\n+        op = SSA.transform(op);\n+        testCompareValues(op);\n+    }\n+\n+    void testCompareValues(Op op) {\n+        List<Value> l = op.elements().<Value>mapMulti((e, c) -> {\n+            if (e instanceof Block b) {\n+                b.parameters().forEach(c);\n+            } else if (e instanceof Op o) {\n+                if (o.result() != null) {\n+                    c.accept(o.result());\n+                }\n+            }\n+        }).toList();\n+\n+        for (int i = 0; i < l.size(); i++) {\n+            for (int j = 0; j < l.size(); j++) {\n+                Value a = l.get(i);\n+                Value b = l.get(j);\n+                Assertions.assertEquals(Value.compare(a, b), CodeElement.compare(a.declaringElement(), b.declaringElement()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCompareCodeItems.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}