{"files":[{"patch":"@@ -18,8 +18,4 @@\n-### Code shared between `java.base` and `jdk.compiler` modules\n-\n-A subset of code in `java.base` is copied with package renaming into\n-the `jdk.compiler` module. This is the set of code required to build\n-and serialize code models. Due to bootstrapping constraints, compiling\n-the compiler it cannot depend on all code in `java.base`. In the future\n-we may come up with a better solution. For now the build has been modified\n-to copy the code, which leverages the script `cr-util\/copy-to-compiler.sh`.\n+The Babylon API and implementation resides in the incubating model\n+`jdk.incubator.code`. Compilation and execution of dependent code requires\n+that this module be made visible by explicitly adding to the list of modules\n+e.g., such as with the command line option `--add-modules jdk.incubator.code`.\n","filename":"README.md","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,9 +51,9 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,5 +30,5 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,11 +29,11 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOps.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,7 +32,7 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,2 +30,3 @@\n-import java.lang.runtime.CodeReflection;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.op.CoreOp;\n@@ -54,1 +55,1 @@\n-        CoreOp.FuncOp javaFunc = method.getCodeModel().get();\n+        CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n","filename":"cr-examples\/spirv\/src\/test\/java\/intel\/code\/spirv\/ExampleUseTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.*;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.*;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Float16.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -60,1 +61,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Functions.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,5 +28,5 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.*;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.TupleType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.*;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.TupleType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,8 +28,8 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.analysis.Patterns;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.CoreOp.VarAccessOp.VarLoadOp;\n-import java.lang.reflect.code.op.CoreOp.VarAccessOp.VarStoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.Patterns;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp.VarAccessOp.VarLoadOp;\n+import jdk.incubator.code.op.CoreOp.VarAccessOp.VarStoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.JavaType;\n@@ -39,1 +39,1 @@\n-import static java.lang.reflect.code.analysis.Patterns.*;\n+import static jdk.incubator.code.analysis.Patterns.*;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SimpleCountedForLoopInfo.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Triton.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.*;\n-import java.lang.reflect.code.type.*;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.*;\n+import jdk.incubator.code.type.*;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,7 +28,7 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,6 +32,6 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.VarType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.VarType;\n@@ -42,2 +42,2 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestAddKernel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestBroadcast.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCdiv.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCountedLoop.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestMatrix.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestSoftMax.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestVariables.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestZeros.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,5 +36,6 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n@@ -85,1 +86,1 @@\n-            test(m.getCodeModel().get(), argTypes, expectedTritonKernel(tcm), doSSA);\n+            test(Op.ofMethod(m).get(), argTypes, expectedTritonKernel(tcm), doSSA);\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-#!\/bin\/bash\n-#\n-# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# copy selected cr packages into jdk.compiler\n-\n-base=java\/lang\/reflect\/code\n-packages=\"\n-  $base \\\n-  $base\/writer \\\n-  $base\/op \\\n-  $base\/type \\\n-  $base\/type\/impl \\\n-  \"\n-\n-removeclasses=\"\"\n-\n-java_base_dir=$1\n-jdk_compiler_dir=$2\n-\n-for p in $packages; do\n-  mkdir -p $jdk_compiler_dir\/jdk\/internal\/$p\n-  cp -r $java_base_dir\/$p\/*.java $jdk_compiler_dir\/jdk\/internal\/$p\/.\n-done\n-\n-for f in $removeclasses; do\n-  rm $jdk_compiler_dir\/jdk\/internal\/$f\n-done\n-\n-find $jdk_compiler_dir\/jdk\/internal\/$base -name \"*.java\" -print \\\n-  | xargs sed -i'.bck' \\\n-  -e 's\/java\\.lang\\.reflect\\.code\/jdk\\.internal\\.java\\.lang\\.reflect\\.code\/g' \\\n-  -e 's\/^\\\/\\*__\\(.*\\)__\\*\\\/.*$\/\\1\/'\n-\n-find $jdk_compiler_dir\/jdk\/internal\/$base -name \"*.bck\" -exec rm {} \\;\n-\n","filename":"cr-util\/copy-to-compiler.sh","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -31,2 +31,2 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/backends\/cuda\/src\/main\/java\/hat\/backend\/CudaHatKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -52,1 +53,1 @@\n-            CoreOp.FuncOp javaFunc = method.getCodeModel().get();\n+            CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n","filename":"hat\/backends\/mock\/src\/main\/java\/hat\/backend\/TestIt.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLHatKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,6 +32,6 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXCodeBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.ExternalizableOp;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.ExternalizableOp;\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXPtrOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n@@ -53,1 +54,1 @@\n-            CoreOp.FuncOp javaFunc = method.getCodeModel().get();\n+            CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/TestIt.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/hat\/backend\/TestIt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,3 +51,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Value;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,10 +50,10 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.FunctionType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.FunctionType;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,12 +31,12 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,9 +33,9 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+         \"--add-modules\", \"jdk.incubator.code\",\n","filename":"hat\/bld","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n---enable-preview --source 24\n+--add-modules jdk.incubator.code --enable-preview --source 24\n","filename":"hat\/bldr\/args","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-java --enable-preview --source 24 bld\n+java --add-modules jdk.incubator.code --enable-preview --source 24 bld\n@@ -118,1 +118,1 @@\n-   --enable-preview --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.code --enable-preview --enable-native-access=ALL-UNNAMED \\\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-          --add-exports=java.base\/java.lang.reflect.code.descriptor.impl=ALL-UNNAMED\n","filename":"hat\/docs\/hat-01-04-intellij.md","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Chess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,8 +29,8 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n@@ -75,1 +75,1 @@\n-        var funcOp = method.getCodeModel().get();\n+        var funcOp = Op.ofMethod(method).get();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -158,1 +158,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DependencyTree.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ForTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,5 +34,6 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.CodeReflection;\n@@ -78,1 +79,1 @@\n-        CoreOp.FuncOp highLevelForm = m.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp highLevelForm = Op.ofMethod(m).orElseThrow();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,9 +37,9 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.CodeReflection;\n@@ -109,1 +109,1 @@\n-        CoreOp.FuncOp f= m.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp f= Op.ofMethod(m).orElseThrow();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,5 +40,6 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.CodeReflection;\n@@ -117,1 +118,1 @@\n-                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,5 +42,6 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.CodeReflection;\n@@ -120,1 +121,1 @@\n-                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,10 +31,10 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.CodeReflection;\n@@ -60,2 +60,2 @@\n-            CoreOp.FuncOp preFunc = pre.getCodeModel().get();\n-            CoreOp.FuncOp postFunc = post.getCodeModel().get();\n+            CoreOp.FuncOp preFunc = Op.ofMethod(pre).get();\n+            CoreOp.FuncOp postFunc = Op.ofMethod(post).get();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrePostInc.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,4 +31,4 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.op.CoreOp;\n@@ -36,7 +36,7 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.add;\n-import static java.lang.reflect.code.op.CoreOp.closureCall;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.op.CoreOp.func;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.INT;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.add;\n+import static jdk.incubator.code.op.CoreOp.closureCall;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.INT;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,9 +36,9 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.CodeReflection;\n@@ -134,1 +134,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,6 +28,6 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/TestQuoted.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,9 +30,9 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.CodeReflection;\n@@ -126,1 +126,1 @@\n-            CoreOp.FuncOp javaFunc = method.getCodeModel().get();\n+            CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.Quoted;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/Bad.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/GetBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Compute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,3 +38,3 @@\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,7 +40,7 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n@@ -127,1 +127,1 @@\n-        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(computeMethod.getCodeModel().orElseThrow());\n+        FuncOpWrapper funcOpWrapper = OpWrapper.wrap(Op.ofMethod(computeMethod).orElseThrow());\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,12 +42,12 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/OpsAndTypes.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,6 +34,7 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n@@ -127,1 +128,1 @@\n-                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n@@ -147,1 +148,1 @@\n-                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,7 +37,7 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,4 +34,4 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuildContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,6 +61,6 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Op;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilderInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatComputeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,3 +37,4 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n@@ -168,1 +169,1 @@\n-                Optional<CoreOp.FuncOp> optionalFuncOp = invokeWrapperCalledMethod.getCodeModel();\n+                Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeWrapperCalledMethod);\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n@@ -102,1 +103,1 @@\n-                Optional<CoreOp.FuncOp> optionalFuncOp = invokeOpCalledMethod.getCodeModel();\n+                Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeOpCalledMethod);\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,7 +30,7 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.CodeItem;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.CodeItem;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/opcodebuilders\/OpCodeBuilder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n","filename":"hat\/hat\/src\/main\/java\/hat\/opcodebuilders\/StyledOpCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Op;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BlockWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.Body;\n+import jdk.incubator.code.Body;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/BodyWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.CodeElement;\n+import jdk.incubator.code.CodeElement;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/CodeElementWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,6 +29,6 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.ClassType;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.ClassType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,10 +31,10 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,5 +33,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,5 +31,5 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Op;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,5 +29,5 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n@@ -55,1 +55,1 @@\n-        Optional<CoreOp.FuncOp> codeModel = entryPoint.getCodeModel();\n+        Optional<CoreOp.FuncOp> codeModel = Op.ofMethod(entryPoint);\n@@ -83,1 +83,1 @@\n-                                Optional<CoreOp.FuncOp> optionalInvokedFuncOp = invokedMethod.getCodeModel();\n+                                Optional<CoreOp.FuncOp> optionalInvokedFuncOp = Op.ofMethod(invokedMethod);\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,9 +29,9 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/RootSet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Op;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Op;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import jdk.incubator.code.op.ExtendedOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,6 +28,6 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n@@ -35,1 +35,1 @@\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/test\/hat\/CustomOpTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,7 +33,7 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat\/src\/main\/test\/hat\/SquaresTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+                    <arg>--add-modules<\/arg><arg>jdk.incubator.code<\/arg>\n","filename":"hat\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    jdk.incubator.code \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    jdk.code.tools \\\n","filename":"make\/conf\/module-loader-map.conf","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,23 +75,0 @@\n-\n-################################################################################\n-#\n-# Copy stubs of code reflection API in langtools\n-\n-GENSTUBS_DEST_ROOT := $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\n-\n-GENSTUBS_SRC := $(TOPDIR)\/src\/java.base\/share\/classes\/java\/lang\/reflect\/code\n-\n-GENSTUBS_DEST := $(GENSTUBS_DEST_ROOT)\/jdk\/internal\/java\/lang\/reflect\/code\n-\n-GENSTUBS_SCRIPT := $(TOPDIR)\/cr-util\/copy-to-compiler.sh\n-\n-GENSTUBS_CMD := $(BASH) $(GENSTUBS_SCRIPT) $(TOPDIR)\/src\/java.base\/share\/classes $(GENSTUBS_DEST_ROOT)\n-\n-$(eval $(call SetupExecute, GENSTUBS, \\\n-    WARN := Generating compiler stubs for code reflection, \\\n-    DEPS := $(call FindFiles, $(GENSTUBS_SRC), *.java), \\\n-    OUTPUT_DIR := $(GENSTUBS_DEST), \\\n-    COMMAND := $(GENSTUBS_CMD), \\\n-))\n-\n-TARGETS += $(GENSTUBS)\n","filename":"make\/modules\/jdk.compiler\/Gensrc.gmk","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+DISABLED_WARNINGS_java += dangling-doc-comments\n+\n+# DOCLINT += -Xdoclint:all\/protected\n","filename":"make\/modules\/jdk.incubator.code\/Java.gmk","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -47,0 +47,2 @@\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n@@ -48,4 +50,0 @@\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp.FuncOp;\n-import java.lang.reflect.code.parser.OpParser;\n@@ -54,0 +52,2 @@\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n@@ -97,2 +97,0 @@\n-    private static final ClassDesc CD_Quoted = Quoted.class.describeConstable().get();\n-    private static final MethodTypeDesc MTD_Quoted = MethodTypeDescImpl.ofValidated(CD_Quoted);\n@@ -100,1 +98,0 @@\n-    private static final MethodHandle HANDLE_MAKE_QUOTED;\n@@ -112,8 +109,0 @@\n-\n-        try {\n-            HANDLE_MAKE_QUOTED = MethodHandles.lookup().findStatic(\n-                    InnerClassLambdaMetafactory.class, \"makeQuoted\",\n-                    MethodType.methodType(Quoted.class, String.class, Object[].class));\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n@@ -351,1 +340,1 @@\n-                    clb.withField(quotedInstanceFieldName, CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n+                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n@@ -395,1 +384,1 @@\n-                        List.of(implementation, quotableOpField, HANDLE_MAKE_QUOTED);\n+                        List.of(implementation, quotableOpField, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n@@ -488,2 +477,33 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(HANDLE_MAKE_QUOTED.type()))\n-           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CD_Quoted);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted);\n+    }\n+\n+    static class CodeReflectionSupport {\n+        static final Class<?> QUOTED_CLASS;\n+        static final Class<?> QUOTABLE_CLASS;\n+        static final MethodHandle HANDLE_MAKE_QUOTED;\n+\n+        static {\n+            try {\n+                \/\/ we know jdk.incubator code is there, no need to check\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(ModuleFinder.of(), ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                ModuleLayer layer = parent.defineModulesWithOneLoader(cf, scl);\n+                QUOTED_CLASS = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.Quoted\");\n+                QUOTABLE_CLASS = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.Quotable\");\n+                Class<?> quotedHelper = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.internal.QuotedHelper\");\n+                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, String.class, Object[].class));\n+                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+\n+        static final ClassDesc CD_Quoted = QUOTED_CLASS.describeConstable().get();\n+        static final MethodTypeDesc MTD_Quoted = MethodTypeDescImpl.ofValidated(CD_Quoted);\n@@ -552,1 +572,1 @@\n-        clb.withMethod(NAME_METHOD_QUOTED, MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n@@ -556,1 +576,1 @@\n-                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CD_Quoted)\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n@@ -646,5 +666,0 @@\n-    private static Quoted makeQuoted(String opText, Object[] args) {\n-        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n-        return (Quoted)Interpreter.invoke(Lookup.IMPL_LOOKUP, op, args);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":41,"deletions":26,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.reflect.code.Quotable;\n-\n@@ -529,1 +527,1 @@\n-            altInterfaces[altInterfaces.length-1] = Quotable.class;\n+            altInterfaces[altInterfaces.length-1] = InnerClassLambdaMetafactory.CodeReflectionSupport.QUOTABLE_CLASS;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.parser.OpParser;\n@@ -52,1 +49,0 @@\n-import java.util.List;\n@@ -55,3 +51,1 @@\n-\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import java.lang.reflect.code.type.MethodRef;\n+import java.util.function.Function;\n@@ -108,1 +102,1 @@\n-    private volatile Optional<FuncOp>     codeModel;\n+    private volatile Optional<?>     codeModel;\n@@ -244,10 +238,3 @@\n-    \/**\n-     * Returns the code model of the method body, if present.\n-     * @return the code model of the method body.\n-     * @since 99\n-     *\/\n-    \/\/ @@@ Make caller sensitive with the same access control as invoke\n-    \/\/ and throwing IllegalAccessException\n-\/\/    @CallerSensitive\n-    public Optional<FuncOp> getCodeModel() {\n-        Optional<FuncOp> localRef = codeModel;\n+    \/* package *\/\n+    Optional<?> setCodeModelIfNeeded(Function<Method, Optional<?>> modelFactory) {\n+        Optional<?> localRef = codeModel;\n@@ -258,1 +245,1 @@\n-                    Optional<FuncOp> op = createCodeModel();\n+                    Optional<?> op = modelFactory.apply(this);\n@@ -266,36 +253,0 @@\n-    private Optional<FuncOp> createCodeModel() {\n-        Class<?> dc = getDeclaringClass();\n-        char[] sig = MethodRef.method(this).toString().toCharArray();\n-        for (int i = 0; i < sig.length; i++) {\n-            switch (sig[i]) {\n-                case '.', ';', '[', '\/': sig[i] = '$';\n-            }\n-        }\n-        String fieldName = new String(sig) + \"$\" + \"op\";\n-        Field f;\n-        try {\n-            f = dc.getDeclaredField(fieldName);\n-        } catch (NoSuchFieldException e) {\n-            return Optional.empty();\n-        }\n-\n-        String modelText;\n-        try {\n-            \/\/ @@@ Use method handle with full power mode\n-            f.setAccessible(true);\n-            modelText = (String) f.get(null);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        FuncOp op;\n-        try {\n-            List<Op> ops = OpParser.fromString(ExtendedOp.FACTORY, modelText);\n-            op = (FuncOp) ops.get(0);\n-        } catch (RuntimeException e) {\n-            \/\/ @@@ Error or Exception?\n-            throw e;\n-        }\n-        return Optional.of(op);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":6,"deletions":55,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n@@ -81,0 +84,5 @@\n+\n+    @Override\n+    public Optional<?> setCodeModelIfNeeded(Method method, Function<Method, Optional<?>> modelFactory) {\n+        return method.setCodeModelIfNeeded(modelFactory);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,455 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code;\n-\n-import java.io.OutputStream;\n-import java.io.OutputStreamWriter;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.function.BiFunction;\n-\n-\/**\n- * An operation modelling a unit of functionality.\n- * <p>\n- * An operation might model the addition of two 32-bit integers, or a Java method call.\n- * Alternatively an operation may model something more complex like method bodies, lambda bodies, or\n- * try\/catch\/finally statements. In this case such an operation will contain one or more bodies modelling\n- * the nested structure.\n- *\/\n-public non-sealed abstract class Op implements CodeElement<Op, Body> {\n-\n-    \/**\n-     * An operation characteristic indicating the operation is pure and has no side effects.\n-     *\/\n-    public interface Pure {\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation has one or more bodies.\n-     *\/\n-    public interface Nested {\n-        List<Body> bodies();\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation represents a loop\n-     *\/\n-    public interface Loop extends Nested {\n-        Body loopBody();\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation has one or more bodies,\n-     * all of which are isolated.\n-     *\/\n-    public interface Isolated extends Nested {\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation is invokable, so the operation may be interpreted\n-     * or compiled.\n-     *\/\n-    public interface Invokable extends Nested {\n-        \/**\n-         * {@return the body of the invokable operation.}\n-         *\/\n-        Body body();\n-\n-        \/**\n-         * {@return the function type describing the invokable operation's parameter types and return type.}\n-         *\/\n-        FunctionType invokableType();\n-\n-        \/**\n-         * {@return the entry block parameters of this operation's body}\n-         *\/\n-        default List<Block.Parameter> parameters() {\n-            return body().entryBlock().parameters();\n-        }\n-\n-        \/**\n-         * Computes values captured by this invokable operation's body.\n-         *\n-         * @return the captured values.\n-         * @see Body#capturedValues()\n-         *\/\n-        default List<Value> capturedValues() {\n-            return List.of();\n-        }\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation can replace itself with a lowered form,\n-     * consisting only of operations in the core dialect.\n-     *\/\n-    public interface Lowerable {\n-        default Block.Builder lower(Block.Builder b) {\n-            return lower(b, OpTransformer.NOOP_TRANSFORMER);\n-        }\n-\n-        Block.Builder lower(Block.Builder b, OpTransformer opT);\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation is a terminating operation\n-     * occurring as the last operation in a block.\n-     * <p>\n-     * A terminating operation passes control to either another block within the same parent body\n-     * or to that parent body.\n-     *\/\n-    public interface Terminating {\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation is a body terminating operation\n-     * occurring as the last operation in a block.\n-     * <p>\n-     * A body terminating operation passes control back to its nearest ancestor body.\n-     *\/\n-    public interface BodyTerminating extends Terminating {\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation is a block terminating operation\n-     * occurring as the last operation in a block.\n-     * <p>\n-     * The operation has one or more successors to other blocks within the same parent body, and passes\n-     * control to one of those blocks.\n-     *\/\n-    public interface BlockTerminating extends Terminating {\n-        List<Block.Reference> successors();\n-    }\n-\n-    \/**\n-     * A value that is the result of an operation.\n-     *\/\n-    public static final class Result extends Value {\n-        final Op op;\n-\n-        Result(Block block, Op op) {\n-            super(block, op.resultType());\n-\n-            this.op = op;\n-        }\n-\n-        @Override\n-        public Set<Value> dependsOn() {\n-            Set<Value> depends = new LinkedHashSet<>(op.operands());\n-            if (op instanceof Terminating) {\n-                op.successors().stream().flatMap(h -> h.arguments().stream()).forEach(depends::add);\n-            }\n-\n-            return Collections.unmodifiableSet(depends);\n-        }\n-\n-        \/**\n-         * Returns the result's operation.\n-         *\n-         * @return the result's operation.\n-         *\/\n-        public Op op() {\n-            return op;\n-        }\n-    }\n-\n-    \/\/ Set when op is bound to block, otherwise null when unbound\n-    Result result;\n-\n-    \/\/ null if not specified\n-    Location location;\n-\n-    final String name;\n-\n-    final List<Value> operands;\n-\n-    \/**\n-     * Constructs an operation by copying given operation.\n-     *\n-     * @param that the operation to copy.\n-     * @param cc   the copy context.\n-     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n-     * values computed, in order, by mapping the operation's operands using the copy context.\n-     *\/\n-    protected Op(Op that, CopyContext cc) {\n-        this(that.name, cc.getValues(that.operands));\n-        this.location = that.location;\n-    }\n-\n-    \/**\n-     * Copies this operation and its bodies, if any.\n-     * <p>\n-     * The returned operation is structurally identical to this operation and is otherwise independent\n-     * of the values declared and used.\n-     *\n-     * @return the copied operation.\n-     *\/\n-    public Op copy() {\n-        return transform(CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n-    }\n-\n-    \/**\n-     * Copies this operation and its bodies, if any.\n-     * <p>\n-     * The returned operation is structurally identical to this operation and is otherwise independent\n-     * of the values declared and used.\n-     *\n-     * @param cc the copy context.\n-     * @return the copied operation.\n-     *\/\n-    public Op copy(CopyContext cc) {\n-        return transform(cc, OpTransformer.COPYING_TRANSFORMER);\n-    }\n-\n-    \/**\n-     * Copies this operation and transforms its bodies, if any.\n-     * <p>\n-     * Bodies are {@link Body#transform(CopyContext, OpTransformer) transformed} with the given copy context and\n-     * operation transformer.\n-     *\n-     * @param cc the copy context.\n-     * @param ot the operation transformer.\n-     * @return the transformed operation.\n-     *\/\n-    public abstract Op transform(CopyContext cc, OpTransformer ot);\n-\n-    \/**\n-     * Constructs an operation with a name and list of operands.\n-     *\n-     * @param name       the operation name.\n-     * @param operands   the list of operands, a copy of the list is performed if required.\n-     *\/\n-    protected Op(String name, List<? extends Value> operands) {\n-        this.name = name;\n-        this.operands = List.copyOf(operands);\n-    }\n-\n-    \/**\n-     * Sets the originating source location of this operation, if unbound.\n-     *\n-     * @param l the location, the {@link Location#NO_LOCATION} value indicates the location is not specified.\n-     * @throws IllegalStateException if this operation is bound\n-     *\/\n-    public final void setLocation(Location l) {\n-        \/\/ @@@ Fail if location != null?\n-        if (result != null && result.block.isBound()) {\n-            throw new IllegalStateException();\n-        }\n-\n-        location = l;\n-    }\n-\n-    \/**\n-     * {@return the originating source location of this operation, otherwise {@code null} if not specified}\n-     *\/\n-    public final Location location() {\n-        return location;\n-    }\n-\n-    \/**\n-     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n-     *\n-     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n-     *\/\n-    @Override\n-    public final Block parent() {\n-        return parentBlock();\n-    }\n-\n-    \/**\n-     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n-     *\n-     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n-     *\/\n-    public final Block parentBlock() {\n-        if (result == null) {\n-            return null;\n-        }\n-\n-        if (!result.block.isBound()) {\n-            throw new IllegalStateException(\"Parent block is partially constructed\");\n-        }\n-\n-        return result.block;\n-    }\n-\n-    @Override\n-    public final List<Body> children() {\n-        return bodies();\n-    }\n-\n-    \/**\n-     * {@return the operation's bodies, as an unmodifiable list}\n-     * @implSpec this implementation returns an unmodifiable empty list.\n-     *\/\n-    public List<Body> bodies() {\n-        return List.of();\n-    }\n-\n-    \/**\n-     * Returns the operation's result, otherwise {@code null} if the operation is not assigned to a block.\n-     *\n-     * @return the operation's result, or {@code null} if not assigned to a block.\n-     *\/\n-    public final Result result() {\n-        return result;\n-    }\n-\n-\n-    \/**\n-     * Returns this operation's nearest ancestor body (the parent body of this operation's parent block),\n-     * otherwise {@code null} if the operation is not assigned to a block.\n-     *\n-     * @return operation's nearest ancestor body, or {@code null} if the operation is not assigned to a block.\n-     *\/\n-    public final Body ancestorBody() {\n-        if (result == null) {\n-            return null;\n-        }\n-\n-        if (!result.block.isBound()) {\n-            throw new IllegalStateException(\"Parent body is partially constructed\");\n-        }\n-\n-        return result.block.parentBody;\n-    }\n-\n-    \/**\n-     * {@return the operation name}\n-     *\/\n-    public String opName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * {@return the operation's operands, as an unmodifiable list}\n-     *\/\n-    public List<Value> operands() {\n-        return operands;\n-    }\n-\n-    \/**\n-     * {@return the operation's successors, as an unmodifiable list}\n-     *\/\n-    public List<Block.Reference> successors() {\n-        return List.of();\n-    }\n-\n-    \/**\n-     * {@return the operation's result type}\n-     *\/\n-    public abstract TypeElement resultType();\n-\n-    \/**\n-     * Returns the operation's function type.\n-     * <p>\n-     * The function type's result type is the operation's result type and the function type's parameter types are the\n-     * operation's operand types, in order.\n-     *\n-     * @return the function type\n-     *\/\n-    public FunctionType opType() {\n-        List<TypeElement> operandTypes = operands.stream().map(Value::type).toList();\n-        return FunctionType.functionType(resultType(), operandTypes);\n-    }\n-\n-    \/**\n-     * Traverse the operands of this operation that are the results of prior operations, recursively.\n-     * <p>\n-     * Traversal is performed in pre-order, reporting the operation of each operand to the visitor.\n-     *\n-     * @param t   the traversing accumulator\n-     * @param v   the visitor\n-     * @param <T> accumulator type\n-     * @return the traversing accumulator\n-     * @apiNote A visitor that implements the abstract method of {@code OpVisitor} and does not override any\n-     * other default method will only visit operations. As such a lambda expression or method reference\n-     * may be used to visit operations.\n-     *\/\n-    public final <T> T traverseOperands(T t, BiFunction<T, Op, T> v) {\n-        for (Value arg : operands()) {\n-            if (arg instanceof Result or) {\n-                t = v.apply(t, or.op);\n-                t = or.op.traverseOperands(t, v);\n-            }\n-        }\n-\n-        return t;\n-    }\n-\n-    \/**\n-     * Computes values captured by this operation. A captured value is a value that dominates\n-     * this operation and is used by a descendant operation.\n-     * <p>\n-     * The order of the captured values is first use encountered in depth\n-     * first search of this operation's descendant operations.\n-     *\n-     * @return the list of captured values, modifiable\n-     * @see Body#capturedValues()\n-     *\/\n-    public List<Value> capturedValues() {\n-        Set<Value> cvs = new LinkedHashSet<>();\n-\n-        capturedValues(cvs, new ArrayDeque<>(), this);\n-        return new ArrayList<>(cvs);\n-    }\n-\n-    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Op op) {\n-        for (Body childBody : op.bodies()) {\n-            Body.capturedValues(capturedValues, bodyStack, childBody);\n-        }\n-    }\n-\n-    \/**\n-     * Writes the textual form of this operation to the given output stream, using the UTF-8 character set.\n-     *\n-     * @param out the stream to write to.\n-     *\/\n-    public void writeTo(OutputStream out) {\n-        writeTo(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n-    }\n-\n-    \/**\n-     * Writes the textual form of this operation to the given writer.\n-     *\n-     * @param w the writer to write to.\n-     *\/\n-    public void writeTo(Writer w) {\n-        OpWriter.writeTo(w, this);\n-    }\n-\n-    \/**\n-     * Returns the textual form of this operation.\n-     *\n-     * @return the textual form of this operation.\n-     *\/\n-    public String toText() {\n-        return OpWriter.toText(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":0,"deletions":455,"binary":false,"changes":455,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.type;\n-\n-import java.lang.reflect.code.type.impl.FieldRefImpl;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.code.TypeElement;\n-\n-\/**\n- * The symbolic reference to a Java field.\n- *\/\n-public sealed interface FieldRef permits FieldRefImpl {\n-    TypeElement refType();\n-\n-    String name();\n-\n-    TypeElement type();\n-\n-    \/\/ Conversions\n-\n-    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    \/\/ Factories\n-\n-    static FieldRef field(Field f) {\n-        return field(f.getDeclaringClass(), f.getName(), f.getType());\n-    }\n-\n-    static FieldRef field(Class<?> refType, String name, Class<?> type) {\n-        return field(JavaType.type(refType), name, JavaType.type(type));\n-    }\n-\n-    static FieldRef field(TypeElement refType, String name, TypeElement type) {\n-        return new FieldRefImpl(refType, name, type);\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static FieldRef ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseFieldRef(s);\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FieldRef.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.type;\n-\n-import java.lang.reflect.code.type.impl.RecordTypeRefImpl;\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-import java.util.stream.Stream;\n-\n-\/**\n- * The symbolic reference to a Java record type.\n- *\/\n-public sealed interface RecordTypeRef permits RecordTypeRefImpl {\n-    TypeElement recordType();\n-\n-    \/**\n-     * The symbolic reference to a Java record component.\n-     * @param type the type of the component\n-     * @param name the name of the component\n-     *\/\n-    record ComponentRef(TypeElement type, String name) {}\n-\n-    List<ComponentRef> components();\n-\n-    MethodRef methodForComponent(int i);\n-\n-    \/\/ Factories\n-\n-    static RecordTypeRef recordType(Class<? extends Record> c) {\n-        List<ComponentRef> components = Stream.of(c.getRecordComponents())\n-                .map(rc -> new ComponentRef(JavaType.type(rc.getType()), rc.getName()))\n-                .toList();\n-        return recordType(JavaType.type(c), components);\n-    }\n-\n-    static RecordTypeRef recordType(TypeElement recordType, ComponentRef... components) {\n-        return recordType(recordType, List.of(components));\n-    }\n-\n-    static RecordTypeRef recordType(TypeElement recordType, List<ComponentRef> components) {\n-        return new RecordTypeRefImpl(recordType, components);\n-    }\n-\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    static RecordTypeRef ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseRecordTypeRef(s);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/RecordTypeRef.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -29,0 +29,3 @@\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n@@ -70,0 +73,3 @@\n+\n+    \/** Cache code model on the reflective method instance (if none is set already). *\/\n+    Optional<?> setCodeModelIfNeeded(Method method, Function<Method, Optional<?>> modelFactory);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,8 +93,0 @@\n-    exports java.lang.reflect.code;\n-    exports java.lang.reflect.code.analysis;\n-    exports java.lang.reflect.code.bytecode;\n-    exports java.lang.reflect.code.interpreter;\n-    exports java.lang.reflect.code.op;\n-    exports java.lang.reflect.code.parser;\n-    exports java.lang.reflect.code.type;\n-    exports java.lang.reflect.code.writer;\n@@ -171,1 +163,4 @@\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.jshell, \/\/ participates in preview features\n+        jdk.incubator.code; \/\/ participates in preview features\n+    exports jdk.internal.classfile.impl to\n+        jdk.incubator.code;\n@@ -186,1 +181,2 @@\n-        jdk.crypto.cryptoki;\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.code;\n@@ -322,1 +318,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.code;\n@@ -386,1 +383,0 @@\n-    exports java.lang.reflect.code.type.impl;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Optional;\n@@ -1045,16 +1044,0 @@\n-\n-    \/**\n-     * Returns the code model of provided executable element (if any).\n-     * <p>\n-     * If the executable element has a code model then it will be an instance of\n-     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n-     * Note: due to circular dependencies we cannot refer to the type explicitly.\n-     *\n-     * @implSpec The default implementation unconditionally returns an empty optional.\n-     * @param e the executable element.\n-     * @return the code model of the provided executable element (if any).\n-     * @since 99\n-     *\/\n-    default Optional<Object> getBody(ExecutableElement e) {\n-        return Optional.empty();\n-    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,28 +0,0 @@\n-package jdk.code.tools.renderer;\n-\n-\n-public final class TerminalColors {\n-    private TerminalColors() {\n-    }\n-\n-    public interface Colorizer {\n-        String colorize(String text);\n-    }\n-\n-    public enum Color implements Colorizer {\n-        \/\/ https:\/\/www.lihaoyi.com\/post\/BuildyourownCommandLinewithANSIescapecodes.html#8-colors\n-        NONE(\"0\"),\n-        BLACK(\"38;5;0\"), DARKGREEN(\"38;5;22\"), DARKBLUE(\"38;5;27\"),\n-        GREY(\"38;5;247\"), RED(\"38;5;1\"), GREEN(\"38;5;77\"), YELLOW(\"38;5;185\"),\n-        BLUE(\"38;5;31\"), WHITE(\"38;5;251\"), ORANGE(\"38;5;208\"), PURPLE(\"38;5;133\");\n-        final String escSequence;\n-\n-        Color(String seq) {\n-            escSequence = \"\\u001b[\" + seq + \"m\";\n-        }\n-\n-        public String colorize(String string) {\n-            return (this == NONE) ? string : escSequence + string + NONE.escSequence;\n-        }\n-    }\n-}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/TerminalColors.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Tools module for code reflection, providing useful ancillary functionality\n- * that may not be necessary in the java.base module.\n- *\n- *\/\n-module jdk.code.tools {\n-    exports jdk.code.tools.dot;\n-    exports jdk.code.tools.renderer;\n-}\n-\n","filename":"src\/jdk.code.tools\/share\/classes\/module-info.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n@@ -34,1 +36,0 @@\n-import java.util.stream.Collectors;\n@@ -219,1 +220,1 @@\n-        ServiceLoader<Plugin> sl = pEnv.getServiceLoader(Plugin.class);\n+\n@@ -221,0 +222,13 @@\n+\n+        if (CodeReflectionSupport.CODE_LAYER != null) {\n+            \/\/ first check for \"implicit\" plugins in the code reflection module (if present)\n+            var crp = ServiceLoader.load(CodeReflectionSupport.CODE_LAYER, Plugin.class);\n+            for (Plugin plugin : crp) {\n+                if (plugin.autoStart()) {\n+                    autoStart.add(plugin);\n+                }\n+            }\n+        }\n+\n+        \/\/ then check other plugins, as usual\n+        ServiceLoader<Plugin> sl = pEnv.getServiceLoader(Plugin.class);\n@@ -251,0 +265,24 @@\n+    static class CodeReflectionSupport {\n+        static final ModuleLayer CODE_LAYER;\n+\n+        static {\n+            if (ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent() &&\n+                    !ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(ModuleFinder.of(), ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                CODE_LAYER = parent.defineModulesWithOneLoader(cf, scl);\n+                Module codeReflectionModule = CODE_LAYER.findModule(\"jdk.incubator.code\").get();\n+                Module jdkCompilerModule = BasicJavacTask.class.getModule();\n+                \/\/ We need to add exports all jdk.compiler packages so that the plugin can use them\n+                for (String packageName : jdkCompilerModule.getPackages()) {\n+                    jdkCompilerModule.addExports(packageName, codeReflectionModule);\n+                }\n+            } else {\n+                \/\/ if we run javac in bootstrap mode, there might be no jdk.incubator.code\n+                CODE_LAYER = null;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/BasicJavacTask.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -248,13 +248,0 @@\n-    \/\/ For code reflection\n-    public final Type codeReflectionType;\n-    public final Type quotedType;\n-    public final Type quotableType;\n-    public final Type closureOpType;\n-    public final Type lambdaOpType;\n-    public final Type opInterpreterType;\n-    public final Type opParserType;\n-    public final Type opType;\n-    public final MethodSymbol methodHandlesLookup;\n-    public final MethodSymbol opInterpreterInvoke;\n-    public final MethodSymbol opParserFromString;\n-\n@@ -344,0 +331,12 @@\n+    \/** Enter a class into symbol table.\n+     *  @param s The name of the class.\n+     *\/\n+    public Type enterClass(ModuleSymbol moduleSymbol, String s) {\n+        try {\n+            return enterClass(moduleSymbol, names.fromString(s)).type;\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            return Type.noType;\n+        }\n+    }\n+\n@@ -646,24 +645,0 @@\n-        \/\/ For code reflection\n-        codeReflectionType = enterClass(\"java.lang.runtime.CodeReflection\");\n-        quotedType = enterClass(\"java.lang.reflect.code.Quoted\");\n-        quotableType = enterClass(\"java.lang.reflect.code.Quotable\");\n-        closureOpType = enterClass(\"java.lang.reflect.code.op.CoreOp$ClosureOp\");\n-        lambdaOpType = enterClass(\"java.lang.reflect.code.op.CoreOp$LambdaOp\");\n-        opInterpreterType = enterClass(\"java.lang.reflect.code.interpreter.Interpreter\");\n-        opType = enterClass(\"java.lang.reflect.code.Op\");\n-        methodHandlesLookup = new MethodSymbol(PUBLIC | STATIC,\n-                names.fromString(\"lookup\"),\n-                new MethodType(List.nil(), methodHandleLookupType,\n-                        List.nil(), methodClass),\n-                methodHandlesType.tsym);\n-        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n-                names.fromString(\"invoke\"),\n-                new MethodType(List.of(methodHandleLookupType, opType, new ArrayType(objectType, arrayClass)), objectType,\n-                        List.nil(), methodClass),\n-                opInterpreterType.tsym);\n-        opParserType = enterClass(\"java.lang.reflect.code.parser.OpParser\");\n-        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n-                names.fromString(\"fromStringOfFuncOp\"),\n-                new MethodType(List.of(stringType), opType,\n-                        List.nil(), methodClass),\n-                opParserType.tsym);\n@@ -676,2 +651,0 @@\n-        synthesizeEmptyInterfaceIfMissing(quotedType);\n-        synthesizeEmptyInterfaceIfMissing(quotableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":12,"deletions":39,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -5404,0 +5404,4 @@\n+    \/\/ The predicates below do not use a predefined symbol in Symtab.\n+    \/\/ This is deliberate, as we cannot initialize symbols in modules\n+    \/\/ other than java.base at startup.\n+\n@@ -5405,1 +5409,15 @@\n-        return type.tsym == syms.quotedType.tsym;\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quoted) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n+\n+    public boolean isQuotable(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quotable) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    List<Symbol.VarSymbol> analyzeCaptures() {\n+    public List<Symbol.VarSymbol> analyzeCaptures() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CaptureScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,1 +1121,1 @@\n-    abstract static class FilterScanner extends com.sun.tools.javac.tree.TreeScanner {\n+    public abstract static class FilterScanner extends com.sun.tools.javac.tree.TreeScanner {\n@@ -1125,1 +1125,1 @@\n-        FilterScanner(final Set<JCTree.Tag> validTags) {\n+        protected FilterScanner(final Set<JCTree.Tag> validTags) {\n@@ -1143,1 +1143,1 @@\n-        void skip(JCTree tree) {}\n+        protected void skip(JCTree tree) {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -851,1 +851,1 @@\n-                        t.tsym != syms.quotableType.tsym &&\n+                        !types.isQuotable(t) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-    class FreeVarCollector extends CaptureScanner {\n+    public class FreeVarCollector extends CaptureScanner {\n@@ -274,1 +274,1 @@\n-        FreeVarCollector(JCTree ownerTree) {\n+        protected FreeVarCollector(JCTree ownerTree) {\n@@ -278,1 +278,1 @@\n-        void addFreeVars(ClassSymbol c) {\n+        protected void addFreeVars(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1314,1 +1314,1 @@\n-                void skip(JCTree tree) {\n+                protected void skip(JCTree tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class TypeEnvs {\n+public class TypeEnvs {\n@@ -53,0 +53,2 @@\n+\n+    @SuppressWarnings(\"this-escape\")\n@@ -58,5 +60,5 @@\n-    Env<AttrContext> get(TypeSymbol sym) { return map.get(sym); }\n-    Env<AttrContext> put(TypeSymbol sym, Env<AttrContext> env) { return map.put(sym, env); }\n-    Env<AttrContext> remove(TypeSymbol sym) { return map.remove(sym); }\n-    Collection<Env<AttrContext>> values() { return map.values(); }\n-    void clear() { map.clear(); }\n+    public Env<AttrContext> get(TypeSymbol sym) { return map.get(sym); }\n+    public Env<AttrContext> put(TypeSymbol sym, Env<AttrContext> env) { return map.put(sym, env); }\n+    public Env<AttrContext> remove(TypeSymbol sym) { return map.remove(sym); }\n+    public Collection<Env<AttrContext>> values() { return map.values(); }\n+    public void clear() { map.clear(); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnvs.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -381,0 +381,2 @@\n+    private boolean hasCodeReflectionModule;\n+\n@@ -1057,0 +1059,9 @@\n+\n+        if (modules.modulesInitialized()) {\n+            \/\/ This has to happen precisely here. At this point, we have all we need to\n+            \/\/ determine whether jdk.incubator.module is part of the module graph\n+            \/\/ but we have yet to trigger an ENTER event. This gives the code reflection plugin\n+            \/\/ a window to check whether code reflection should be enabled for this compilation unit.\n+            hasCodeReflectionModule = modules.getObservableModule(names.jdk_incubator_code) != null;\n+        }\n+\n@@ -1609,4 +1620,0 @@\n-            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n-                env.tree = ReflectMethods.instance(context).translateTopLevelClass(env.tree, localMake);\n-            }\n-\n@@ -1823,0 +1830,4 @@\n+    public boolean hasCodeReflectionModule() {\n+        return hasCodeReflectionModule;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.Method;\n@@ -48,1 +47,0 @@\n-import com.sun.source.tree.Tree;\n@@ -50,1 +48,0 @@\n-import com.sun.tools.javac.api.JavacScope;\n@@ -68,1 +65,0 @@\n-import com.sun.tools.javac.comp.ReflectMethods;\n@@ -85,1 +81,0 @@\n-import com.sun.tools.javac.comp.Resolve;\n@@ -87,1 +82,0 @@\n-import jdk.internal.java.lang.reflect.code.op.CoreOp;\n@@ -109,2 +103,0 @@\n-    private final Resolve resolve;\n-    private final ReflectMethods reflectMethods;\n@@ -133,1 +125,0 @@\n-        resolve = Resolve.instance(context);\n@@ -135,1 +126,0 @@\n-        reflectMethods = ReflectMethods.instance(context);\n@@ -821,32 +811,0 @@\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public Optional<Object> getBody(ExecutableElement e) {\n-        if (e.getModifiers().contains(Modifier.ABSTRACT) ||\n-                e.getModifiers().contains(Modifier.NATIVE)) {\n-            return Optional.empty();\n-        }\n-\n-        CoreOp.FuncOp funcOp;\n-        try {\n-            JCMethodDecl methodTree = (JCMethodDecl)getTree(e);\n-            JavacScope scope = javacTrees.getScope(javacTrees.getPath(e));\n-            ClassSymbol enclosingClass = (ClassSymbol) scope.getEnclosingClass();\n-            funcOp = attr.runWithAttributedMethod(scope.getEnv(), methodTree,\n-                    attribBlock -> reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make));\n-        } catch (RuntimeException ex) {  \/\/ ReflectMethods.UnsupportedASTException\n-            \/\/ some other error occurred when attempting to attribute the method\n-            \/\/ @@@ better report of error\n-            ex.printStackTrace();\n-            return Optional.empty();\n-        }\n-\n-        \/\/ Reparse using API in java.base\n-        try {\n-            String opString = funcOp.toText();\n-            Class<?> opParserClass = Class.forName(\"java.lang.reflect.code.parser.OpParser\");\n-            Method fromStringMethod = opParserClass.getDeclaredMethod(\"fromStringOfFuncOp\", String.class);\n-            return Optional.of(fromStringMethod.invoke(null, opString));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -230,0 +230,5 @@\n+    \/\/ code reflection\n+    public final Name jdk_incubator_code;\n+    public final Name quoted;\n+    public final Name quotable;\n+\n@@ -413,0 +418,5 @@\n+\n+        \/\/ code reflection\n+        jdk_incubator_code = fromString(\"jdk.incubator.code\");\n+        quoted = fromString(\"Quoted\");\n+        quotable = fromString(\"Quotable\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -237,1 +237,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -242,1 +243,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -245,1 +247,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -250,1 +253,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -253,1 +257,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -255,1 +260,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -265,1 +271,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -270,1 +277,4 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n+    exports com.sun.tools.javac.processing to\n+        jdk.incubator.code;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp;\n@@ -34,2 +34,2 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.branch;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.branch;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.type.FunctionType;\n+import jdk.incubator.code.type.FunctionType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Body.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n@@ -55,1 +55,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return Stream.of(Void.class).gather(() -> (_, _, downstream) -> traversePreOrder(downstream::push));\n+        return Stream.of(Void.class).gather(() -> (_, _, downstream) -> traversePreOrder(downstream::push));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeElement.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeItem.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.runtime;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeReflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/CodeReflection.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CopyContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CopyContext.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CopyContextImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CopyContextImpl.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Location.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Location.java","status":"renamed"},{"patch":"@@ -0,0 +1,572 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code;\n+\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+\n+import com.sun.tools.javac.api.JavacScope;\n+import com.sun.tools.javac.api.JavacTrees;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.comp.Attr;\n+import com.sun.tools.javac.model.JavacElements;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.util.Context;\n+import jdk.incubator.code.compiler.CodeReflectionPlugin;\n+import jdk.incubator.code.internal.ReflectMethods;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.internal.access.SharedSecrets;\n+\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * An operation modelling a unit of functionality.\n+ * <p>\n+ * An operation might model the addition of two 32-bit integers, or a Java method call.\n+ * Alternatively an operation may model something more complex like method bodies, lambda bodies, or\n+ * try\/catch\/finally statements. In this case such an operation will contain one or more bodies modelling\n+ * the nested structure.\n+ *\/\n+public non-sealed abstract class Op implements CodeElement<Op, Body> {\n+\n+    \/**\n+     * An operation characteristic indicating the operation is pure and has no side effects.\n+     *\/\n+    public interface Pure {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation has one or more bodies.\n+     *\/\n+    public interface Nested {\n+        List<Body> bodies();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation represents a loop\n+     *\/\n+    public interface Loop extends Nested {\n+        Body loopBody();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation has one or more bodies,\n+     * all of which are isolated.\n+     *\/\n+    public interface Isolated extends Nested {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is invokable, so the operation may be interpreted\n+     * or compiled.\n+     *\/\n+    public interface Invokable extends Nested {\n+        \/**\n+         * {@return the body of the invokable operation.}\n+         *\/\n+        Body body();\n+\n+        \/**\n+         * {@return the function type describing the invokable operation's parameter types and return type.}\n+         *\/\n+        FunctionType invokableType();\n+\n+        \/**\n+         * {@return the entry block parameters of this operation's body}\n+         *\/\n+        default List<Block.Parameter> parameters() {\n+            return body().entryBlock().parameters();\n+        }\n+\n+        \/**\n+         * Computes values captured by this invokable operation's body.\n+         *\n+         * @return the captured values.\n+         * @see Body#capturedValues()\n+         *\/\n+        default List<Value> capturedValues() {\n+            return List.of();\n+        }\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation can replace itself with a lowered form,\n+     * consisting only of operations in the core dialect.\n+     *\/\n+    public interface Lowerable {\n+        default Block.Builder lower(Block.Builder b) {\n+            return lower(b, OpTransformer.NOOP_TRANSFORMER);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, OpTransformer opT);\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * A terminating operation passes control to either another block within the same parent body\n+     * or to that parent body.\n+     *\/\n+    public interface Terminating {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a body terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * A body terminating operation passes control back to its nearest ancestor body.\n+     *\/\n+    public interface BodyTerminating extends Terminating {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a block terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * The operation has one or more successors to other blocks within the same parent body, and passes\n+     * control to one of those blocks.\n+     *\/\n+    public interface BlockTerminating extends Terminating {\n+        List<Block.Reference> successors();\n+    }\n+\n+    \/**\n+     * A value that is the result of an operation.\n+     *\/\n+    public static final class Result extends Value {\n+        final Op op;\n+\n+        Result(Block block, Op op) {\n+            super(block, op.resultType());\n+\n+            this.op = op;\n+        }\n+\n+        @Override\n+        public Set<Value> dependsOn() {\n+            Set<Value> depends = new LinkedHashSet<>(op.operands());\n+            if (op instanceof Terminating) {\n+                op.successors().stream().flatMap(h -> h.arguments().stream()).forEach(depends::add);\n+            }\n+\n+            return Collections.unmodifiableSet(depends);\n+        }\n+\n+        \/**\n+         * Returns the result's operation.\n+         *\n+         * @return the result's operation.\n+         *\/\n+        public Op op() {\n+            return op;\n+        }\n+    }\n+\n+    \/\/ Set when op is bound to block, otherwise null when unbound\n+    Result result;\n+\n+    \/\/ null if not specified\n+    Location location;\n+\n+    final String name;\n+\n+    final List<Value> operands;\n+\n+    \/**\n+     * Constructs an operation by copying given operation.\n+     *\n+     * @param that the operation to copy.\n+     * @param cc   the copy context.\n+     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n+     * values computed, in order, by mapping the operation's operands using the copy context.\n+     *\/\n+    protected Op(Op that, CopyContext cc) {\n+        this(that.name, cc.getValues(that.operands));\n+        this.location = that.location;\n+    }\n+\n+    \/**\n+     * Copies this operation and its bodies, if any.\n+     * <p>\n+     * The returned operation is structurally identical to this operation and is otherwise independent\n+     * of the values declared and used.\n+     *\n+     * @return the copied operation.\n+     *\/\n+    public Op copy() {\n+        return transform(CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Copies this operation and its bodies, if any.\n+     * <p>\n+     * The returned operation is structurally identical to this operation and is otherwise independent\n+     * of the values declared and used.\n+     *\n+     * @param cc the copy context.\n+     * @return the copied operation.\n+     *\/\n+    public Op copy(CopyContext cc) {\n+        return transform(cc, OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Copies this operation and transforms its bodies, if any.\n+     * <p>\n+     * Bodies are {@link Body#transform(CopyContext, OpTransformer) transformed} with the given copy context and\n+     * operation transformer.\n+     *\n+     * @param cc the copy context.\n+     * @param ot the operation transformer.\n+     * @return the transformed operation.\n+     *\/\n+    public abstract Op transform(CopyContext cc, OpTransformer ot);\n+\n+    \/**\n+     * Constructs an operation with a name and list of operands.\n+     *\n+     * @param name       the operation name.\n+     * @param operands   the list of operands, a copy of the list is performed if required.\n+     *\/\n+    protected Op(String name, List<? extends Value> operands) {\n+        this.name = name;\n+        this.operands = List.copyOf(operands);\n+    }\n+\n+    \/**\n+     * Sets the originating source location of this operation, if unbound.\n+     *\n+     * @param l the location, the {@link Location#NO_LOCATION} value indicates the location is not specified.\n+     * @throws IllegalStateException if this operation is bound\n+     *\/\n+    public final void setLocation(Location l) {\n+        \/\/ @@@ Fail if location != null?\n+        if (result != null && result.block.isBound()) {\n+            throw new IllegalStateException();\n+        }\n+\n+        location = l;\n+    }\n+\n+    \/**\n+     * {@return the originating source location of this operation, otherwise {@code null} if not specified}\n+     *\/\n+    public final Location location() {\n+        return location;\n+    }\n+\n+    \/**\n+     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    @Override\n+    public final Block parent() {\n+        return parentBlock();\n+    }\n+\n+    \/**\n+     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    public final Block parentBlock() {\n+        if (result == null) {\n+            return null;\n+        }\n+\n+        if (!result.block.isBound()) {\n+            throw new IllegalStateException(\"Parent block is partially constructed\");\n+        }\n+\n+        return result.block;\n+    }\n+\n+    @Override\n+    public final List<Body> children() {\n+        return bodies();\n+    }\n+\n+    \/**\n+     * {@return the operation's bodies, as an unmodifiable list}\n+     * @implSpec this implementation returns an unmodifiable empty list.\n+     *\/\n+    public List<Body> bodies() {\n+        return List.of();\n+    }\n+\n+    \/**\n+     * Returns the operation's result, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return the operation's result, or {@code null} if not assigned to a block.\n+     *\/\n+    public final Result result() {\n+        return result;\n+    }\n+\n+\n+    \/**\n+     * Returns this operation's nearest ancestor body (the parent body of this operation's parent block),\n+     * otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's nearest ancestor body, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    public final Body ancestorBody() {\n+        if (result == null) {\n+            return null;\n+        }\n+\n+        if (!result.block.isBound()) {\n+            throw new IllegalStateException(\"Parent body is partially constructed\");\n+        }\n+\n+        return result.block.parentBody;\n+    }\n+\n+    \/**\n+     * {@return the operation name}\n+     *\/\n+    public String opName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * {@return the operation's operands, as an unmodifiable list}\n+     *\/\n+    public List<Value> operands() {\n+        return operands;\n+    }\n+\n+    \/**\n+     * {@return the operation's successors, as an unmodifiable list}\n+     *\/\n+    public List<Block.Reference> successors() {\n+        return List.of();\n+    }\n+\n+    \/**\n+     * {@return the operation's result type}\n+     *\/\n+    public abstract TypeElement resultType();\n+\n+    \/**\n+     * Returns the operation's function type.\n+     * <p>\n+     * The function type's result type is the operation's result type and the function type's parameter types are the\n+     * operation's operand types, in order.\n+     *\n+     * @return the function type\n+     *\/\n+    public FunctionType opType() {\n+        List<TypeElement> operandTypes = operands.stream().map(Value::type).toList();\n+        return FunctionType.functionType(resultType(), operandTypes);\n+    }\n+\n+    \/**\n+     * Traverse the operands of this operation that are the results of prior operations, recursively.\n+     * <p>\n+     * Traversal is performed in pre-order, reporting the operation of each operand to the visitor.\n+     *\n+     * @param t   the traversing accumulator\n+     * @param v   the visitor\n+     * @param <T> accumulator type\n+     * @return the traversing accumulator\n+     * @apiNote A visitor that implements the abstract method of {@code OpVisitor} and does not override any\n+     * other default method will only visit operations. As such a lambda expression or method reference\n+     * may be used to visit operations.\n+     *\/\n+    public final <T> T traverseOperands(T t, BiFunction<T, Op, T> v) {\n+        for (Value arg : operands()) {\n+            if (arg instanceof Result or) {\n+                t = v.apply(t, or.op);\n+                t = or.op.traverseOperands(t, v);\n+            }\n+        }\n+\n+        return t;\n+    }\n+\n+    \/**\n+     * Computes values captured by this operation. A captured value is a value that dominates\n+     * this operation and is used by a descendant operation.\n+     * <p>\n+     * The order of the captured values is first use encountered in depth\n+     * first search of this operation's descendant operations.\n+     *\n+     * @return the list of captured values, modifiable\n+     * @see Body#capturedValues()\n+     *\/\n+    public List<Value> capturedValues() {\n+        Set<Value> cvs = new LinkedHashSet<>();\n+\n+        capturedValues(cvs, new ArrayDeque<>(), this);\n+        return new ArrayList<>(cvs);\n+    }\n+\n+    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Op op) {\n+        for (Body childBody : op.bodies()) {\n+            Body.capturedValues(capturedValues, bodyStack, childBody);\n+        }\n+    }\n+\n+    \/**\n+     * Writes the textual form of this operation to the given output stream, using the UTF-8 character set.\n+     *\n+     * @param out the stream to write to.\n+     *\/\n+    public void writeTo(OutputStream out) {\n+        writeTo(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n+    }\n+\n+    \/**\n+     * Writes the textual form of this operation to the given writer.\n+     *\n+     * @param w the writer to write to.\n+     *\/\n+    public void writeTo(Writer w) {\n+        OpWriter.writeTo(w, this);\n+    }\n+\n+    \/**\n+     * Returns the textual form of this operation.\n+     *\n+     * @return the textual form of this operation.\n+     *\/\n+    public String toText() {\n+        return OpWriter.toText(this);\n+    }\n+\n+\n+\n+    \/**\n+     * Returns the code model of the method body, if present.\n+     * @return the code model of the method body.\n+     * @since 99\n+     *\/\n+    \/\/ @@@ Make caller sensitive with the same access control as invoke\n+    \/\/ and throwing IllegalAccessException\n+    \/\/ @CallerSensitive\n+    @SuppressWarnings(\"unchecked\")\n+    public static Optional<FuncOp> ofMethod(Method method) {\n+        return (Optional<FuncOp>)SharedSecrets.getJavaLangReflectAccess()\n+                .setCodeModelIfNeeded(method, Op::createCodeModel);\n+    }\n+\n+    private static Optional<FuncOp> createCodeModel(Method method) {\n+        Class<?> dc = method.getDeclaringClass();\n+        char[] sig = MethodRef.method(method).toString().toCharArray();\n+        for (int i = 0; i < sig.length; i++) {\n+            switch (sig[i]) {\n+                case '.', ';', '[', '\/': sig[i] = '$';\n+            }\n+        }\n+        String fieldName = new String(sig) + \"$\" + \"op\";\n+        Field f;\n+        try {\n+            f = dc.getDeclaredField(fieldName);\n+        } catch (NoSuchFieldException e) {\n+            return Optional.empty();\n+        }\n+\n+        String modelText;\n+        try {\n+            \/\/ @@@ Use method handle with full power mode\n+            f.setAccessible(true);\n+            modelText = (String) f.get(null);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        FuncOp op;\n+        try {\n+            List<jdk.incubator.code.Op> ops = OpParser.fromString(ExtendedOp.FACTORY, modelText);\n+            op = (FuncOp) ops.get(0);\n+        } catch (RuntimeException e) {\n+            \/\/ @@@ Error or Exception?\n+            throw e;\n+        }\n+        return Optional.of(op);\n+    }\n+\n+    \/**\n+     * Returns the code model of provided executable element (if any).\n+     * <p>\n+     * If the executable element has a code model then it will be an instance of\n+     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n+     * Note: due to circular dependencies we cannot refer to the type explicitly.\n+     *\n+     * @implSpec The default implementation unconditionally returns an empty optional.\n+     * @param e the executable element.\n+     * @return the code model of the provided executable element (if any).\n+     * @since 99\n+     *\/\n+    public static Optional<FuncOp> ofElement(ProcessingEnvironment processingEnvironment, ExecutableElement e) {\n+        if (e.getModifiers().contains(Modifier.ABSTRACT) ||\n+                e.getModifiers().contains(Modifier.NATIVE)) {\n+            return Optional.empty();\n+        }\n+\n+        Context context = ((JavacProcessingEnvironment)processingEnvironment).getContext();\n+        if (!CodeReflectionPlugin.isCodeReflectionAvailable(context)) {\n+            return Optional.empty();\n+        }\n+\n+        ReflectMethods reflectMethods = ReflectMethods.instance(context);\n+        Attr attr = Attr.instance(context);\n+        JavacElements elements = JavacElements.instance(context);\n+        JavacTrees javacTrees = JavacTrees.instance(context);\n+        TreeMaker make = TreeMaker.instance(context);\n+        try {\n+            JCMethodDecl methodTree = (JCMethodDecl)elements.getTree(e);\n+            JavacScope scope = javacTrees.getScope(javacTrees.getPath(e));\n+            ClassSymbol enclosingClass = (ClassSymbol) scope.getEnclosingClass();\n+            FuncOp op = attr.runWithAttributedMethod(scope.getEnv(), methodTree,\n+                    attribBlock -> reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make));\n+            return Optional.of(op);\n+        } catch (RuntimeException ex) {  \/\/ ReflectMethods.UnsupportedASTException\n+            \/\/ some other error occurred when attempting to attribute the method\n+            \/\/ @@@ better report of error\n+            ex.printStackTrace();\n+            return Optional.empty();\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":572,"deletions":0,"binary":false,"changes":572,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/OpTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/OpTransformer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quotable.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quotable.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quoted.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n@@ -3,1 +3,1 @@\n-import java.lang.reflect.code.type.TypeElementFactory;\n+import jdk.incubator.code.type.TypeElementFactory;\n@@ -100,3 +100,2 @@\n-        \/\/ Copied code in jdk.compiler module throws UOE\n-        public static ExternalizedTypeElement ofString(String s) {\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseExTypeElem(s);\n+            public static ExternalizedTypeElement ofString(String s) {\n+        return jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(s);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/TypeElement.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeElement.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Value.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Value.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -28,4 +28,4 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.AnfDialect;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.AnfDialect;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/AnfTransformer.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/AnfTransformer.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -31,2 +31,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.writer.OpWriter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.writer.OpWriter;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Liveness.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/NormalizeBlocksTransformer.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/NormalizeBlocksTransformer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -28,5 +28,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Patterns.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Patterns.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSA.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -3,7 +3,7 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSAConstruction.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSAConstruction.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.analysis;\n+package jdk.incubator.code.analysis;\n@@ -28,6 +28,6 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.PrimitiveType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.PrimitiveType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/StringConcatTransformer.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.analysis;\n\\ No newline at end of file\n+package jdk.incubator.code.analysis;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/package-info.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BranchCompactor.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n@@ -50,14 +50,14 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.CoreOp.*;\n-import java.lang.reflect.code.type.ArrayType;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.reflect.code.type.VarType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp.*;\n+import jdk.incubator.code.type.ArrayType;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.type.VarType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":15,"deletions":15,"binary":false,"changes":30,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n@@ -52,12 +52,12 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.reflect.code.type.VarType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.type.VarType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeLift.java","additions":13,"deletions":13,"binary":false,"changes":26,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/LocalsCompactor.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsCompactor.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n@@ -28,8 +28,8 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotOp.java","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotOp.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n@@ -29,9 +29,9 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotToVarTransformer.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotToVarTransformer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedType.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.reflect.code.bytecode;\n+package jdk.incubator.code.bytecode;\n@@ -27,12 +27,12 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.ArrayType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.reflect.code.type.VarType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.ArrayType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.type.VarType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":13,"deletions":13,"binary":false,"changes":26,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedTypesTransformer.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.bytecode;\n\\ No newline at end of file\n+package jdk.incubator.code.bytecode;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/package-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.compiler;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.Plugin;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskEvent.Kind;\n+import com.sun.tools.javac.api.BasicJavacTask;\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Log;\n+import jdk.incubator.code.internal.ReflectMethods;\n+\n+import javax.lang.model.element.TypeElement;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * A compiler plugin that processes methods annotated with the {@link jdk.incubator.codeReflection}\n+ * annotation, and saves their code model in the resulting AST.\n+ *\/\n+public class CodeReflectionPlugin implements Plugin {\n+\n+    Context context;\n+    TreeMaker treeMaker;\n+    Runnable dropListener;\n+\n+    \/**\n+     * Plugin constructor\n+     *\/\n+    public CodeReflectionPlugin() { }\n+\n+    @Override\n+    public String getName() {\n+        return \"CodeReflection Plugin\";\n+    }\n+\n+    @Override\n+    public void init(JavacTask task, String... args) {\n+        this.context = ((BasicJavacTask)task).getContext();\n+        TaskListener taskListener = new TaskListener();\n+        task.addTaskListener(taskListener);\n+        dropListener = () -> task.removeTaskListener(taskListener);\n+    }\n+\n+    @Override\n+    public boolean autoStart() {\n+        return true;\n+    }\n+\n+    class TaskListener implements com.sun.source.util.TaskListener {\n+        @Override\n+        public void started(TaskEvent e) {\n+            if (e.getKind() == Kind.ENTER) {\n+                if (dropListener != null && !isCodeReflectionAvailable(context)) {\n+                    \/\/ do not process further events if code reflection module is not enabled\n+                    dropListener.run();\n+                    dropListener = null;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void finished(TaskEvent e) {\n+            if (e.getKind() == Kind.ANALYZE) {\n+                JCCompilationUnit jcCompilationUnit = (JCCompilationUnit)e.getCompilationUnit();\n+                if (Log.instance(context).nerrors == 0) {\n+                    treeMaker = TreeMaker.instance(context);\n+                    TreeMaker localMake = treeMaker.forToplevel(jcCompilationUnit);\n+                    ClassDeclFinder classDeclFinder = new ClassDeclFinder(e.getTypeElement());\n+                    classDeclFinder.scan(jcCompilationUnit);\n+                    ReflectMethods.instance(context)\n+                                  .translateTopLevelClass(classDeclFinder.classDecl, localMake);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static boolean isCodeReflectionAvailable(Context context) {\n+        Source source = Source.instance(context);\n+        if (!Source.Feature.REFLECT_METHODS.allowedInSource(source)) {\n+            \/\/ if source level is not latest, return false\n+            return false;\n+        }\n+\n+        \/\/ if jdk.incubator.code is not in the module graph, skip\n+        return JavaCompiler.instance(context).hasCodeReflectionModule();\n+    }\n+\n+    \/\/ A simple tree scanner that finds a class declaration tree given its type element.\n+    static class ClassDeclFinder extends TreeScanner {\n+\n+        JCClassDecl classDecl;\n+        final TypeElement element;\n+\n+        public ClassDeclFinder(TypeElement element) {\n+            this.element = element;\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            if (tree.sym == element) {\n+                classDecl = tree;\n+            } else {\n+                super.visitClassDef(tree);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/compiler\/CodeReflectionPlugin.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Names;\n+\n+import static com.sun.tools.javac.code.Flags.PUBLIC;\n+import static com.sun.tools.javac.code.Flags.STATIC;\n+import static com.sun.tools.javac.code.Flags.VARARGS;\n+\n+public class CodeReflectionSymbols {\n+    public final Type quotedType;\n+    public final Type quotableType;\n+    public final Type codeReflectionType;\n+    public final MethodSymbol opInterpreterInvoke;\n+    public final MethodSymbol opParserFromString;\n+    public final MethodSymbol methodHandlesLookup;\n+\n+    CodeReflectionSymbols(Context context) {\n+        Symtab syms = Symtab.instance(context);\n+        Names names = Names.instance(context);\n+        ModuleSymbol jdk_incubator_code = syms.enterModule(names.jdk_incubator_code);\n+        codeReflectionType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.CodeReflection\");\n+        quotedType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Quoted\");\n+        quotableType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Quotable\");\n+        Type opInterpreterType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.interpreter.Interpreter\");\n+        Type opType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Op\");\n+        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n+                names.fromString(\"invoke\"),\n+                new MethodType(List.of(syms.methodHandleLookupType, opType, new ArrayType(syms.objectType, syms.arrayClass)), syms.objectType,\n+                        List.nil(), syms.methodClass),\n+                opInterpreterType.tsym);\n+        Type opParserType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.parser.OpParser\");\n+        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"fromStringOfFuncOp\"),\n+                new MethodType(List.of(syms.stringType), opType,\n+                        List.nil(), syms.methodClass),\n+                opParserType.tsym);\n+         methodHandlesLookup = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"lookup\"),\n+                new MethodType(List.nil(), syms.methodHandleLookupType,\n+                        List.nil(), syms.methodClass),\n+                syms.methodHandlesType.tsym);\n+        syms.synthesizeEmptyInterfaceIfMissing(quotedType);\n+        syms.synthesizeEmptyInterfaceIfMissing(quotableType);\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.internal;\n+\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.parser.OpParser;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class QuotedHelper {\n+    public static Quoted makeQuoted(MethodHandles.Lookup lookup, String opText, Object[] args) {\n+        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n+        return (Quoted)Interpreter.invoke(lookup, op, args);\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package com.sun.tools.javac.comp;\n+package jdk.incubator.code.internal;\n@@ -45,0 +45,1 @@\n+import com.sun.tools.javac.comp.CaptureScanner;\n@@ -46,0 +47,3 @@\n+import com.sun.tools.javac.comp.Flow;\n+import com.sun.tools.javac.comp.Lower;\n+import com.sun.tools.javac.comp.TypeEnvs;\n@@ -48,1 +52,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -66,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCModuleDecl;\n@@ -78,0 +82,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Note;\n@@ -83,5 +88,5 @@\n-import jdk.internal.java.lang.reflect.code.*;\n-import jdk.internal.java.lang.reflect.code.op.CoreOp;\n-import jdk.internal.java.lang.reflect.code.op.ExtendedOp;\n-import jdk.internal.java.lang.reflect.code.type.*;\n-import jdk.internal.java.lang.reflect.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.*;\n+import jdk.incubator.code.type.WildcardType.BoundKind;\n@@ -90,0 +95,1 @@\n+import javax.tools.JavaFileObject;\n@@ -129,0 +135,1 @@\n+    private final CodeReflectionSymbols crSyms;\n@@ -155,0 +162,1 @@\n+        crSyms = new CodeReflectionSymbols(context);\n@@ -188,1 +196,1 @@\n-        if (tree.sym.attribute(syms.codeReflectionType.tsym) != null) {\n+        if (tree.sym.attribute(crSyms.codeReflectionType.tsym) != null) {\n@@ -195,1 +203,1 @@\n-                    log.note(Notes.MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                    log.note(MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n@@ -202,1 +210,1 @@\n-                log.note(ex.tree, Notes.MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n+                log.note(ex.tree, MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n@@ -208,0 +216,5 @@\n+    @Override\n+    public void visitModuleDef(JCModuleDecl that) {\n+        \/\/ do nothing\n+    }\n+\n@@ -213,0 +226,1 @@\n+        JavaFileObject prev = log.useSource(tree.sym.sourcefile);\n@@ -224,0 +238,1 @@\n+            log.useSource(prev);\n@@ -237,1 +252,1 @@\n-                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                    log.note(QuotedIrDump(funcOp.toText()));\n@@ -252,1 +267,1 @@\n-                        JCMethodInvocation lookup = make.App(make.Ident(syms.methodHandlesLookup), com.sun.tools.javac.util.List.nil());\n+                        JCMethodInvocation lookup = make.App(make.Ident(crSyms.methodHandlesLookup), com.sun.tools.javac.util.List.nil());\n@@ -255,1 +270,1 @@\n-                        JCMethodInvocation parsedOp = make.App(make.Ident(syms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n+                        JCMethodInvocation parsedOp = make.App(make.Ident(crSyms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n@@ -262,1 +277,1 @@\n-                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(syms.opInterpreterInvoke), interpreterArgs.toList());\n+                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(crSyms.opInterpreterInvoke), interpreterArgs.toList());\n@@ -275,1 +290,1 @@\n-                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                log.note(ex.tree, QuotedIrSkip(ex.tree.getTag().toString()));\n@@ -299,1 +314,1 @@\n-                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                    log.note(QuotedIrDump(funcOp.toText()));\n@@ -312,1 +327,1 @@\n-                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                log.note(ex.tree, QuotedIrSkip(ex.tree.getTag().toString()));\n@@ -550,1 +565,1 @@\n-            MethodType mtype = new MethodType(capturedTypes.toList(), syms.quotedType,\n+            MethodType mtype = new MethodType(capturedTypes.toList(), crSyms.quotedType,\n@@ -627,1 +642,1 @@\n-                    !seenClasses.contains(tree.type.tsym)) {\n+                        !seenClasses.contains(tree.type.tsym)) {\n@@ -839,1 +854,1 @@\n-        void skip(JCTree tree) {\n+        protected void skip(JCTree tree) {\n@@ -1061,1 +1076,1 @@\n-                    result = loadVar(sym);\n+                        result = loadVar(sym);\n@@ -2138,1 +2153,1 @@\n-                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                        FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n@@ -2490,1 +2505,1 @@\n-                    void addFreeVars(ClassSymbol c) {\n+                    protected void addFreeVars(ClassSymbol c) {\n@@ -2549,1 +2564,1 @@\n-                                (jdk.internal.java.lang.reflect.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                                (jdk.incubator.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n@@ -2753,1 +2768,1 @@\n-        } else if (types.asSuper(functionalExpression.target, syms.quotableType.tsym) != null) {\n+        } else if (types.asSuper(functionalExpression.target, crSyms.quotableType.tsym) != null) {\n@@ -2925,0 +2940,34 @@\n+\n+    \/**\n+     * compiler.note.quoted.ir.dump=\\\n+     *    code reflection enabled for method quoted lambda\\n\\\n+     *    {0}\n+     *\/\n+    public static Note QuotedIrDump(String arg0) {\n+        return new Note(\"compiler\", \"quoted.ir.dump\", arg0);\n+    }\n+\n+    \/**\n+     * compiler.note.quoted.ir.skip=\\\n+     *    unsupported code reflection node {0} found in quoted lambda\n+     *\/\n+    public static Note QuotedIrSkip(String arg0) {\n+        return new Note(\"compiler\", \"quoted.ir.skip\", arg0);\n+    }\n+\n+    \/**\n+     * compiler.note.method.ir.dump=\\\n+     *    code reflection enabled for method {0}.{1}\\n\\\n+     *    {2}\n+     *\/\n+    public static Note MethodIrDump(Symbol arg0, Symbol arg1, String arg2) {\n+        return new Note(\"compiler\", \"method.ir.dump\", arg0, arg1, arg2);\n+    }\n+\n+    \/**\n+     * compiler.note.method.ir.skip=\\\n+     *    unsupported code reflection node {2} found in method {0}.{1}\n+     *\/\n+    public static Note MethodIrSkip(Symbol arg0, Symbol arg1, String arg2) {\n+        return new Note(\"compiler\", \"method.ir.skip\", arg0, arg1, arg2);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":74,"deletions":25,"binary":false,"changes":99,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.interpreter;\n+package jdk.incubator.code.interpreter;\n@@ -31,9 +31,9 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.ArrayType;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.VarType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.ArrayType;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.VarType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.interpreter;\n+package jdk.incubator.code.interpreter;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/InvokableLeafOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.interpreter;\n+package jdk.incubator.code.interpreter;\n@@ -29,4 +29,4 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.writer.OpWriter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.writer.OpWriter;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Verifier.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Verifier.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.interpreter;\n\\ No newline at end of file\n+package jdk.incubator.code.interpreter;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/package-info.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.op;\n+package jdk.incubator.code.op;\n@@ -31,2 +31,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.type.FunctionType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.type.FunctionType;\n@@ -36,1 +36,1 @@\n-import static java.lang.reflect.code.op.OpFactory.*;\n+import static jdk.incubator.code.op.OpFactory.*;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/AnfDialect.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/AnfDialect.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.op;\n+package jdk.incubator.code.op;\n@@ -29,4 +29,4 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.*;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.*;\n@@ -100,5 +100,1 @@\n-    \/\/ Split string to ensure the name does not get rewritten\n-    \/\/ when the script copies this source to the jdk.compiler module\n-    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n-\n-    static final String CoreOp_CLASS_NAME = PACKAGE_NAME + \".\" + CoreOp.class.getSimpleName();\n+    static final String PACKAGE_NAME = CodeReflection.class.getPackageName();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":6,"deletions":10,"binary":false,"changes":16,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.op;\n+package jdk.incubator.code.op;\n@@ -29,2 +29,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.type.*;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.type.*;\n@@ -37,2 +37,2 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.JavaType.*;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.JavaType.*;\n@@ -57,3 +57,2 @@\n-    \/\/ Split string to ensure the name does not get rewritten\n-    \/\/ when the script copies this source to the jdk.compiler module\n-    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n+\n+    static final String PACKAGE_NAME = ExtendedOp.class.getPackageName();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExtendedOp.java","additions":7,"deletions":8,"binary":false,"changes":15,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.op;\n+package jdk.incubator.code.op;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.*;\n+import jdk.incubator.code.*;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExternalizableOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExternalizableOp.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.op;\n+package jdk.incubator.code.op;\n@@ -37,1 +37,1 @@\n-import java.lang.reflect.code.Op;\n+import jdk.incubator.code.Op;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/OpFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpFactory.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.op;\n\\ No newline at end of file\n+package jdk.incubator.code.op;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/package-info.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code;\n+package jdk.incubator.code;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/package-info.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser;\n+package jdk.incubator.code.parser;\n@@ -30,9 +30,9 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.op.*;\n-import java.lang.reflect.code.parser.impl.DescParser;\n-import java.lang.reflect.code.parser.impl.Lexer;\n-import java.lang.reflect.code.parser.impl.Scanner;\n-import java.lang.reflect.code.parser.impl.Tokens;\n-import java.lang.reflect.code.type.CoreTypeFactory;\n-import java.lang.reflect.code.type.TypeElementFactory;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.op.*;\n+import jdk.incubator.code.parser.impl.DescParser;\n+import jdk.incubator.code.parser.impl.Lexer;\n+import jdk.incubator.code.parser.impl.Scanner;\n+import jdk.incubator.code.parser.impl.Tokens;\n+import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.type.TypeElementFactory;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/OpParser.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n@@ -28,8 +28,8 @@\n-import java.lang.reflect.code.parser.impl.Tokens.Token;\n-import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n-import java.lang.reflect.code.type.*;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.RecordTypeRef;\n-import java.lang.reflect.code.type.impl.FieldRefImpl;\n-import java.lang.reflect.code.type.impl.MethodRefImpl;\n-import java.lang.reflect.code.type.impl.RecordTypeRefImpl;\n+import jdk.incubator.code.parser.impl.Tokens.Token;\n+import jdk.incubator.code.parser.impl.Tokens.TokenKind;\n+import jdk.incubator.code.type.*;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.RecordTypeRef;\n+import jdk.incubator.code.type.impl.FieldRefImpl;\n+import jdk.incubator.code.type.impl.MethodRefImpl;\n+import jdk.incubator.code.type.impl.RecordTypeRefImpl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/DescParser.java","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/Errors.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Errors.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n+import jdk.incubator.code.parser.impl.Tokens.TokenKind;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/JavaBasedTokenizer.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/JavaBasedTokenizer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.parser.impl.Position.LineMap;\n-import java.lang.reflect.code.parser.impl.Tokens.Token;\n+import jdk.incubator.code.parser.impl.Position.LineMap;\n+import jdk.incubator.code.parser.impl.Tokens.Token;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/Lexer.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Lexer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/Log.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Log.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/Position.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Position.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.parser.impl.Position.LineMap;\n+import jdk.incubator.code.parser.impl.Position.LineMap;\n@@ -34,2 +34,2 @@\n-import static java.lang.reflect.code.parser.impl.Tokens.DUMMY;\n-import static java.lang.reflect.code.parser.impl.Tokens.Token;\n+import static jdk.incubator.code.parser.impl.Tokens.DUMMY;\n+import static jdk.incubator.code.parser.impl.Tokens.Token;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/Scanner.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Scanner.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/Tokens.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Tokens.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.parser.impl;\n+package jdk.incubator.code.parser.impl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/UnicodeReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/UnicodeReader.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.parser;\n\\ No newline at end of file\n+package jdk.incubator.code.parser;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/package-info.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.dot;\n+package jdk.incubator.code.tools.dot;\n@@ -28,4 +28,4 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Value;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/dot\/DotGenerator.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotGenerator.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.dot;\n+package jdk.incubator.code.tools.dot;\n@@ -28,1 +28,1 @@\n-import jdk.code.tools.renderer.CommonRenderer;\n+import jdk.incubator.code.tools.renderer.CommonRenderer;\n@@ -31,4 +31,4 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/dot\/DotRenderer.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotRenderer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.dot;\n+package jdk.incubator.code.tools.dot;\n@@ -28,1 +28,1 @@\n-import jdk.code.tools.renderer.ProcessRunner;\n+import jdk.incubator.code.tools.renderer.ProcessRunner;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/dot\/DotViewer.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotViewer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/CStyleRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/CStyleRenderer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/CommonRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/CommonRenderer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/Diff.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/Diff.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Value;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/GlobalValueBlockNaming.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/GlobalValueBlockNaming.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/ProcessRunner.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/ProcessRunner.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n@@ -28,5 +28,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n@@ -35,2 +35,2 @@\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/SRRenderer.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/SRRenderer.java","status":"renamed"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.tools.renderer;\n+\n+\n+public final class TerminalColors {\n+    private TerminalColors() {\n+    }\n+\n+    public interface Colorizer {\n+        String colorize(String text);\n+    }\n+\n+    public enum Color implements Colorizer {\n+        \/\/ https:\/\/www.lihaoyi.com\/post\/BuildyourownCommandLinewithANSIescapecodes.html#8-colors\n+        NONE(\"0\"),\n+        BLACK(\"38;5;0\"), DARKGREEN(\"38;5;22\"), DARKBLUE(\"38;5;27\"),\n+        GREY(\"38;5;247\"), RED(\"38;5;1\"), GREEN(\"38;5;77\"), YELLOW(\"38;5;185\"),\n+        BLUE(\"38;5;31\"), WHITE(\"38;5;251\"), ORANGE(\"38;5;208\"), PURPLE(\"38;5;133\");\n+        final String escSequence;\n+\n+        Color(String seq) {\n+            escSequence = \"\\u001b[\" + seq + \"m\";\n+        }\n+\n+        public String colorize(String string) {\n+            return (this == NONE) ? string : escSequence + string + NONE.escSequence;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/TerminalColors.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.code.tools.renderer;\n+package jdk.incubator.code.tools.renderer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/TextRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/TextRenderer.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -33,1 +33,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -57,1 +57,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -59,1 +58,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl.make(component);\n+        return sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl.make(component);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ArrayType.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -32,1 +32,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -82,1 +82,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -84,1 +83,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(base, typeArgs, owner);\n+        return sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(base, typeArgs, owner);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ClassType.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -4,3 +4,3 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.TypeElement.ExternalizedTypeElement;\n-import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.TypeElement.ExternalizedTypeElement;\n+import jdk.incubator.code.type.WildcardType.BoundKind;\n@@ -204,1 +204,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -206,1 +205,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(desc);\n+        return jdk.incubator.code.parser.impl.DescParser.parseMethodRef(desc);\n@@ -209,1 +208,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -211,1 +209,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseExTypeElem(desc);\n+        return jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(desc);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/CoreTypeFactory.java","additions":6,"deletions":8,"binary":false,"changes":14,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","status":"renamed"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.type;\n+\n+import jdk.incubator.code.type.impl.FieldRefImpl;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import jdk.incubator.code.TypeElement;\n+\n+\/**\n+ * The symbolic reference to a Java field.\n+ *\/\n+public sealed interface FieldRef permits FieldRefImpl {\n+    TypeElement refType();\n+\n+    String name();\n+\n+    TypeElement type();\n+\n+    \/\/ Conversions\n+\n+    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static FieldRef field(Field f) {\n+        return field(f.getDeclaringClass(), f.getName(), f.getType());\n+    }\n+\n+    static FieldRef field(Class<?> refType, String name, Class<?> type) {\n+        return field(JavaType.type(refType), name, JavaType.type(type));\n+    }\n+\n+    static FieldRef field(TypeElement refType, String name, TypeElement type) {\n+        return new FieldRefImpl(refType, name, type);\n+    }\n+\n+    static FieldRef ofString(String s) {\n+        return jdk.incubator.code.parser.impl.DescParser.parseFieldRef(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/FieldRef.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -3,1 +3,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/FunctionType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FunctionType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -38,2 +38,2 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.WildcardType.BoundKind;\n@@ -358,1 +358,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -360,1 +359,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseExTypeElem(s));\n+        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(s));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/JavaType.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -30,2 +30,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.impl.MethodRefImpl;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.impl.MethodRefImpl;\n@@ -37,1 +37,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -41,1 +41,1 @@\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n@@ -100,1 +100,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -102,1 +101,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(s);\n+        return jdk.incubator.code.parser.impl.DescParser.parseMethodRef(s);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/MethodRef.java","additions":6,"deletions":7,"binary":false,"changes":13,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/MethodRef.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/PrimitiveType.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","status":"renamed"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.type;\n+\n+import jdk.incubator.code.type.impl.RecordTypeRefImpl;\n+import jdk.incubator.code.TypeElement;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The symbolic reference to a Java record type.\n+ *\/\n+public sealed interface RecordTypeRef permits RecordTypeRefImpl {\n+    TypeElement recordType();\n+\n+    \/**\n+     * The symbolic reference to a Java record component.\n+     * @param type the type of the component\n+     * @param name the name of the component\n+     *\/\n+    record ComponentRef(TypeElement type, String name) {}\n+\n+    List<ComponentRef> components();\n+\n+    MethodRef methodForComponent(int i);\n+\n+    \/\/ Factories\n+\n+    static RecordTypeRef recordType(Class<? extends Record> c) {\n+        List<ComponentRef> components = Stream.of(c.getRecordComponents())\n+                .map(rc -> new ComponentRef(JavaType.type(rc.getType()), rc.getName()))\n+                .toList();\n+        return recordType(JavaType.type(c), components);\n+    }\n+\n+    static RecordTypeRef recordType(TypeElement recordType, ComponentRef... components) {\n+        return recordType(recordType, List.of(components));\n+    }\n+\n+    static RecordTypeRef recordType(TypeElement recordType, List<ComponentRef> components) {\n+        return new RecordTypeRefImpl(recordType, components);\n+    }\n+\n+    static RecordTypeRef ofString(String s) {\n+        return jdk.incubator.code.parser.impl.DescParser.parseRecordTypeRef(s);\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/RecordTypeRef.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -3,2 +3,2 @@\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TupleType.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TupleType.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -3,1 +3,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TypeElementFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeElementFactory.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TypeVarRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -3,1 +3,1 @@\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/VarType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/VarType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type;\n+package jdk.incubator.code.type;\n@@ -56,1 +56,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n@@ -58,1 +57,1 @@\n-\/*__throw new UnsupportedOperationException();__*\/        return sun.reflect.generics.reflectiveObjects.WildcardTypeImpl.make(upper, lower);\n+        return sun.reflect.generics.reflectiveObjects.WildcardTypeImpl.make(upper, lower);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/WildcardType.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/WildcardType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type.impl;\n+package jdk.incubator.code.type.impl;\n@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.type.FieldRef;\n+import jdk.incubator.code.type.FieldRef;\n@@ -32,2 +32,2 @@\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/FieldRefImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/FieldRefImpl.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type.impl;\n+package jdk.incubator.code.type.impl;\n@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n@@ -35,3 +35,3 @@\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/MethodRefImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.type.impl;\n+package jdk.incubator.code.type.impl;\n@@ -28,3 +28,3 @@\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.RecordTypeRef;\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.RecordTypeRef;\n+import jdk.incubator.code.TypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/RecordTypeRefImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/RecordTypeRefImpl.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.type;\n\\ No newline at end of file\n+package jdk.incubator.code.type;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/package-info.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.writer;\n+package jdk.incubator.code.writer;\n@@ -28,4 +28,4 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.type.*;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.type.*;\n@@ -34,3 +34,3 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.*;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.*;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.reflect.code.writer;\n+package jdk.incubator.code.writer;\n@@ -32,3 +32,3 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package java.lang.reflect.code.writer;\n+package jdk.incubator.code.writer;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/package-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * A module which provides classes and interfaces for obtaining reflective information about\n+ * classes and objects.\n+ * {@incubating}\n+ *\n+ * @moduleGraph\n+ *\/\n+\n+import jdk.incubator.code.compiler.CodeReflectionPlugin;\n+import jdk.internal.javac.ParticipatesInPreview;\n+\n+@ParticipatesInPreview\n+module jdk.incubator.code {\n+    requires transitive jdk.compiler;\n+\n+    exports jdk.incubator.code;\n+    exports jdk.incubator.code.parser;\n+    exports jdk.incubator.code.op;\n+    exports jdk.incubator.code.type;\n+    exports jdk.incubator.code.analysis;\n+    exports jdk.incubator.code.bytecode;\n+    exports jdk.incubator.code.interpreter;\n+    exports jdk.incubator.code.writer;\n+    exports jdk.incubator.code.tools.dot;\n+    exports jdk.incubator.code.tools.renderer;\n+\n+    opens jdk.incubator.code.internal to java.base;\n+\n+    provides com.sun.source.util.Plugin with\n+            CodeReflectionPlugin;\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/module-info.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.StringWriter;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-\n-\/**\n- * @test\n- * @summary Test symbolic access of method\n- * @run testng TreeAccessTest\n- *\/\n-\n-public class TreeAccessTest {\n-\n-    @CodeReflection\n-    public int m(String s) {\n-        return s.length();\n-    }\n-\n-    @Test\n-    void testTreeAccess() throws Exception {\n-        Method m = TreeAccessTest.class.getDeclaredMethod(\"m\", String.class);\n-\n-        Optional<CoreOp.FuncOp> tree = m.getCodeModel();\n-        Assert.assertTrue(tree.isPresent());\n-\n-        CoreOp.FuncOp methodTree = tree.get();\n-\n-        String expectedTree = \"\"\"\n-                func @\"m\" (%0 : TreeAccessTest, %1 : java.lang.String)int -> {\n-                      %2 : Var<java.lang.String> = var %1 @\"s\";\n-                      %3 : java.lang.String = var.load %2;\n-                      %4 : int = invoke %3 @\"java.lang.String::length()int\";\n-                      return %4;\n-                };\n-                \"\"\";\n-\n-        Assert.assertEquals(canonicalizeModel(methodTree), canonicalizeModel(expectedTree));\n-    }\n-\n-    @Test\n-    public int n(String s) {\n-        return s.length();\n-    }\n-\n-    @Test\n-    void testNoTree() throws Exception {\n-        Method m = TreeAccessTest.class.getDeclaredMethod(\"n\", String.class);\n-\n-        Optional<CoreOp.FuncOp> tree = m.getCodeModel();\n-        Assert.assertTrue(tree.isEmpty());\n-    }\n-\n-\n-    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n-    static String canonicalizeModel(Op o) {\n-        return canonicalizeModel(serialize(o));\n-    }\n-\n-    \/\/ parses, and then serializes, dropping location information\n-    static String canonicalizeModel(String d) {\n-        Op o;\n-        try {\n-            o = OpParser.fromString(ExtendedOp.FACTORY, d).get(0);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(e);\n-        }\n-        return serialize(o);\n-    }\n-\n-    \/\/ serializes, dropping location information\n-    static String serialize(Op o) {\n-        StringWriter w = new StringWriter();\n-        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n-        return w.toString();\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/cr\/TreeAccessTest.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.Op;\n@@ -48,9 +50,9 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n@@ -226,1 +228,1 @@\n-                        CoreOp.FuncOp funcOp = method.getCodeModel().orElseThrow(\n+                        CoreOp.FuncOp funcOp = Op.ofMethod(method).orElseThrow(\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.Op;\n@@ -28,2 +29,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -31,1 +32,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -37,0 +38,1 @@\n+ * @modules jdk.incubator.code\n@@ -89,1 +91,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.Op;\n@@ -27,0 +28,3 @@\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n@@ -28,2 +32,0 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n@@ -31,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -37,0 +39,1 @@\n+ * @modules jdk.incubator.code\n@@ -89,1 +92,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -32,0 +34,3 @@\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n@@ -33,2 +38,0 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n@@ -36,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -203,1 +206,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,5 +28,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -39,0 +39,1 @@\n+ * @modules jdk.incubator.code\n@@ -86,1 +87,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockIndexes.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,3 +28,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -38,0 +39,1 @@\n+ * @modules jdk.incubator.code\n@@ -64,1 +66,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,5 +33,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n@@ -38,3 +39,3 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.INT;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.INT;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockParameters.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,3 +34,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -37,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -227,1 +229,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.analysis.SSA;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n@@ -31,5 +31,5 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.FunctionType.VOID;\n-import static java.lang.reflect.code.type.JavaType.INT;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.FunctionType.VOID;\n+import static jdk.incubator.code.type.JavaType.INT;\n+import static jdk.incubator.code.type.JavaType.type;\n@@ -39,0 +39,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,6 +33,6 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -39,1 +40,1 @@\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.type.JavaType;\n@@ -43,10 +44,10 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.add;\n-import static java.lang.reflect.code.op.CoreOp.closure;\n-import static java.lang.reflect.code.op.CoreOp.closureCall;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.op.CoreOp.func;\n-import static java.lang.reflect.code.op.CoreOp.quoted;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.INT;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.add;\n+import static jdk.incubator.code.op.CoreOp.closure;\n+import static jdk.incubator.code.op.CoreOp.closureCall;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.op.CoreOp.quoted;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.INT;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.Op;\n@@ -31,3 +32,3 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -39,0 +40,1 @@\n+ * @modules jdk.incubator.code\n@@ -215,1 +217,1 @@\n-            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,3 +34,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -37,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -68,1 +70,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -33,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -41,0 +41,1 @@\n+ * @modules jdk.incubator.code\n@@ -74,1 +75,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -34,3 +35,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -38,1 +40,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -161,1 +163,1 @@\n-            CoreOp.FuncOp f = m.getCodeModel().get();\n+            CoreOp.FuncOp f = Op.ofMethod(m).get();\n@@ -197,1 +199,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,5 +34,5 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -75,1 +76,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n@@ -39,5 +39,5 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.branch;\n-import static java.lang.reflect.code.op.CoreOp.conditionalBranch;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.op.CoreOp.func;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.branch;\n+import static jdk.incubator.code.op.CoreOp.conditionalBranch;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.op.CoreOp.func;\n@@ -47,0 +47,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,3 +28,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -39,0 +40,1 @@\n+ * @modules jdk.incubator.code\n@@ -59,1 +61,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,3 +33,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -36,1 +37,1 @@\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.type.JavaType;\n@@ -42,10 +43,10 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp._throw;\n-import static java.lang.reflect.code.op.CoreOp.branch;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.op.CoreOp.exceptionRegionEnter;\n-import static java.lang.reflect.code.op.CoreOp.exceptionRegionExit;\n-import static java.lang.reflect.code.op.CoreOp.func;\n-import static java.lang.reflect.code.type.FunctionType.*;\n-import static java.lang.reflect.code.type.JavaType.*;\n-import static java.lang.reflect.code.type.JavaType.VOID;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp._throw;\n+import static jdk.incubator.code.op.CoreOp.branch;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.op.CoreOp.exceptionRegionEnter;\n+import static jdk.incubator.code.op.CoreOp.exceptionRegionExit;\n+import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.type.FunctionType.*;\n+import static jdk.incubator.code.type.JavaType.*;\n+import static jdk.incubator.code.type.JavaType.VOID;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,5 +34,5 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -93,1 +94,1 @@\n-        Optional<CoreOp.FuncOp> oModel = m.getCodeModel();\n+        Optional<CoreOp.FuncOp> oModel = Op.ofMethod(m);\n@@ -125,1 +126,1 @@\n-        Optional<CoreOp.FuncOp> oModel = m.getCodeModel();\n+        Optional<CoreOp.FuncOp> oModel = Op.ofMethod(m);\n@@ -674,1 +675,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExpressionGraphs.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,3 +28,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -38,0 +39,1 @@\n+ * @modules jdk.incubator.code\n@@ -119,1 +121,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,3 +28,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -38,0 +39,1 @@\n+ * @modules jdk.incubator.code\n@@ -66,1 +68,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -31,1 +31,1 @@\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.type.JavaType;\n@@ -34,3 +34,3 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.INT;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.INT;\n@@ -40,0 +40,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -34,4 +36,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -81,1 +83,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,6 +34,6 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.CoreOp.FuncOp;\n-import java.lang.reflect.code.op.CoreOp.LambdaOp;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.op.CoreOp.LambdaOp;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -41,1 +42,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -49,5 +50,5 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.INT;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.INT;\n+import static jdk.incubator.code.type.JavaType.type;\n@@ -265,1 +266,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -33,2 +33,2 @@\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.TypeElement;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.TypeElement;\n@@ -37,3 +37,3 @@\n-import static java.lang.reflect.code.type.MethodRef.method;\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.MethodRef.method;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n@@ -43,0 +43,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,8 +33,8 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.analysis.Liveness;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.parser.OpParser;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.analysis.Liveness;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.parser.OpParser;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,5 +28,5 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -45,6 +45,6 @@\n-import static java.lang.reflect.code.op.CoreOp.arrayStoreOp;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.op.CoreOp.fieldLoad;\n-import static java.lang.reflect.code.op.CoreOp.newArray;\n-import static java.lang.reflect.code.type.MethodRef.method;\n-import static java.lang.reflect.code.type.JavaType.*;\n+import static jdk.incubator.code.op.CoreOp.arrayStoreOp;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.op.CoreOp.fieldLoad;\n+import static jdk.incubator.code.op.CoreOp.newArray;\n+import static jdk.incubator.code.type.MethodRef.method;\n+import static jdk.incubator.code.type.JavaType.*;\n@@ -54,0 +54,1 @@\n+ * @modules jdk.incubator.code\n@@ -323,1 +324,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,4 +34,4 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.parser.OpParser;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestNormalizeBlocksTransformer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.Op;\n@@ -31,3 +32,3 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -39,0 +40,1 @@\n+ * @modules jdk.incubator.code\n@@ -91,1 +93,1 @@\n-            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOverloads.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -27,2 +28,1 @@\n- * @enablePreview\n- *\/\n+ * @enablePreview *\/\n@@ -33,4 +33,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -39,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -137,1 +137,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import jdk.incubator.code.Op;\n@@ -6,4 +7,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -15,0 +16,1 @@\n+ * @modules jdk.incubator.code\n@@ -16,2 +18,1 @@\n- * @enablePreview\n- *\/\n+ * @enablePreview *\/\n@@ -48,1 +49,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns2.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -33,2 +35,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -37,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -183,1 +185,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import jdk.incubator.code.Op;\n@@ -7,9 +8,9 @@\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.CodeReflection;\n@@ -21,5 +22,5 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.op.ExtendedOp.match;\n-import static java.lang.reflect.code.op.ExtendedOp.typePattern;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.PrimitiveType.*;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.op.ExtendedOp.match;\n+import static jdk.incubator.code.op.ExtendedOp.typePattern;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.PrimitiveType.*;\n@@ -29,0 +30,1 @@\n+ * @modules jdk.incubator.code\n@@ -364,1 +366,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -6,4 +6,4 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.CodeReflection;\n@@ -14,4 +14,4 @@\n-import static java.lang.reflect.code.op.CoreOp.FuncOp;\n-import static java.lang.reflect.code.op.CoreOp.VarAccessOp.VarLoadOp;\n-import static java.lang.reflect.code.op.CoreOp.VarAccessOp.VarStoreOp;\n-import static java.lang.reflect.code.op.CoreOp.VarOp;\n+import static jdk.incubator.code.op.CoreOp.FuncOp;\n+import static jdk.incubator.code.op.CoreOp.VarAccessOp.VarLoadOp;\n+import static jdk.incubator.code.op.CoreOp.VarAccessOp.VarStoreOp;\n+import static jdk.incubator.code.op.CoreOp.VarOp;\n@@ -21,0 +21,1 @@\n+ * @modules jdk.incubator.code\n@@ -95,1 +96,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,4 +28,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -33,1 +34,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -40,0 +41,1 @@\n+ * @modules jdk.incubator.code\n@@ -171,1 +173,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.Op;\n@@ -37,2 +39,2 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.StringConcatTransformer;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.StringConcatTransformer;\n@@ -41,4 +43,4 @@\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -98,1 +100,1 @@\n-        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp model = Op.ofMethod(method).orElseThrow();\n@@ -135,1 +137,1 @@\n-        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp model = Op.ofMethod(method).orElseThrow();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -9,5 +9,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -19,0 +19,1 @@\n+ * @modules jdk.incubator.code\n@@ -487,1 +488,1 @@\n-        return om.get().getCodeModel().get();\n+        return CoreOp.ofMethod(om.get()).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -9,5 +9,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -19,0 +19,1 @@\n+* @modules jdk.incubator.code\n@@ -537,1 +538,1 @@\n-        return om.get().getCodeModel().get();\n+        return CoreOp.ofMethod(om.get()).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.Op;\n@@ -35,6 +37,6 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.CodeReflection;\n@@ -85,1 +87,1 @@\n-        Optional<CoreOp.FuncOp> codeModel = m.getCodeModel();\n+        Optional<CoreOp.FuncOp> codeModel = Op.ofMethod(m);\n@@ -117,1 +119,1 @@\n-                        Optional<CoreOp.FuncOp> f = m.getCodeModel();\n+                        Optional<CoreOp.FuncOp> f = Op.ofMethod(m);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,6 +34,6 @@\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -91,1 +92,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTraverse.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,4 +33,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -38,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -241,1 +242,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,4 +33,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -38,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -215,1 +216,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -32,3 +34,3 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -37,1 +39,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -425,1 +427,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryNested.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -35,5 +37,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -106,1 +108,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUninitializedVariable.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,2 +33,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.parser.OpParser;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.parser.OpParser;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUsesDependsOn.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -34,5 +36,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n@@ -207,1 +209,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarArgsInvoke.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,9 +34,9 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.type.CoreTypeFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n@@ -98,1 +99,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarOp.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,3 +28,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -38,0 +39,1 @@\n+ * @modules jdk.incubator.code\n@@ -93,1 +95,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,4 +24,4 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ActiveSet.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,3 +24,3 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n@@ -32,2 +32,2 @@\n-import static java.lang.reflect.code.op.CoreOp.sub;\n-import static java.lang.reflect.code.analysis.Patterns.*;\n+import static jdk.incubator.code.op.CoreOp.sub;\n+import static jdk.incubator.code.analysis.Patterns.*;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ExpressionElimination.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,8 +24,8 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n@@ -38,2 +38,2 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.JavaType.DOUBLE;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.JavaType.DOUBLE;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,6 +27,7 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -36,1 +37,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -42,0 +43,1 @@\n+ * @modules jdk.incubator.code\n@@ -154,1 +156,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,6 +33,8 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.AnfTransformer;\n-import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.AnfTransformer;\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -63,1 +66,1 @@\n-            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfBasicFuns.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,6 +33,8 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.AnfTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.AnfTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -76,1 +79,1 @@\n-            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfTransform.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -34,1 +34,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -40,0 +40,1 @@\n+ * @modules jdk.incubator.code\n@@ -115,1 +116,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.reflect.code.bytecode.BranchCompactor;\n+import jdk.incubator.code.bytecode.BranchCompactor;\n@@ -38,0 +38,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,3 +38,4 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -42,4 +43,3 @@\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n@@ -56,0 +56,1 @@\n+ * @modules jdk.incubator.code\n@@ -645,1 +646,1 @@\n-            d.testMethod.getCodeModel().ifPresent(f -> f.writeTo(System.out));\n+            Op.ofMethod(d.testMethod).ifPresent(f -> f.writeTo(System.out));\n@@ -661,1 +662,1 @@\n-            d.testMethod.getCodeModel().ifPresent(f -> f.writeTo(System.out));\n+            Op.ofMethod(d.testMethod).ifPresent(f -> f.writeTo(System.out));\n@@ -690,1 +691,1 @@\n-        CoreOp.FuncOp func = d.testMethod.getCodeModel().get();\n+        CoreOp.FuncOp func = Op.ofMethod(d.testMethod).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -36,4 +38,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -92,1 +94,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.CodeReflection;\n@@ -42,0 +43,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -38,0 +38,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -35,5 +37,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -92,1 +94,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,6 +27,6 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -38,0 +38,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestQuoted.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,8 +25,8 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.bytecode.SlotOp;\n-import java.lang.reflect.code.bytecode.SlotSSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.MethodRef;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.bytecode.SlotOp;\n+import jdk.incubator.code.bytecode.SlotSSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.MethodRef;\n@@ -36,0 +36,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlotOps.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n@@ -34,1 +34,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -40,0 +40,1 @@\n+ * @modules jdk.incubator.code\n@@ -156,1 +157,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,4 +34,4 @@\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.interpreter.Verifier;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Verifier;\n+import jdk.incubator.code.op.CoreOp;\n@@ -52,0 +52,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.Op;\n@@ -41,4 +43,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -105,1 +107,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -45,0 +45,1 @@\n+ * @modules jdk.incubator.code\n@@ -289,1 +290,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -45,0 +45,1 @@\n+ * @modules jdk.incubator.code\n@@ -225,1 +226,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -35,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -45,0 +45,1 @@\n+ * @modules jdk.incubator.code\n@@ -256,1 +257,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n@@ -29,2 +29,2 @@\n-import static java.lang.reflect.code.op.CoreOp.sub;\n-import static java.lang.reflect.code.analysis.Patterns.*;\n+import static jdk.incubator.code.op.CoreOp.sub;\n+import static jdk.incubator.code.analysis.Patterns.*;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/ExpressionElimination.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,7 +28,7 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -38,0 +38,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -23,2 +23,2 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n@@ -28,3 +28,3 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -37,0 +37,1 @@\n+ * @modules jdk.incubator.code\n@@ -162,1 +163,1 @@\n-            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow();\n@@ -177,1 +178,1 @@\n-            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestAssert.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.runtime.CodeReflection;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.CodeReflection;\n@@ -35,0 +37,1 @@\n+ * @modules jdk.incubator.code\n@@ -43,1 +46,1 @@\n-        Assert.assertThrows(expectedExceptionType, () -> Interpreter.invoke(MethodHandles.lookup(), method.getCodeModel().orElseThrow()));\n+        Assert.assertThrows(expectedExceptionType, () -> Interpreter.invoke(MethodHandles.lookup(), Op.ofMethod(method).orElseThrow()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestThrowing.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryResult.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,4 +24,4 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.JavaType;\n@@ -30,5 +30,5 @@\n-import static java.lang.reflect.code.type.JavaType.parameterized;\n-import static java.lang.reflect.code.type.MethodRef.method;\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.type.JavaType.parameterized;\n+import static jdk.incubator.code.type.MethodRef.method;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.reflect.code.Quotable;\n+import jdk.incubator.code.Quotable;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotableFunction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.reflect.code.Quotable;\n+import jdk.incubator.code.Quotable;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotablePredicate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -33,0 +33,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestLinq.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,8 +24,8 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.JavaType;\n-\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.func;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.parameterized;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.JavaType;\n+\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.parameterized;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/ClassWithReflectedMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -34,8 +35,8 @@\n-import java.lang.reflect.code.Location;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Location;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -114,1 +115,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/TestLocation.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,8 +27,8 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -59,1 +59,1 @@\n-        CoreOp.FuncOp f = method.getCodeModel().orElseThrow(() ->\n+        CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow(() ->\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/CodeReflectionTester.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -28,0 +28,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/TestLoop.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/TestSynchronized.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @modules java.base\/java.lang.reflect.code.parser\n+ * @modules jdk.incubator.code\/jdk.incubator.code.parser.impl\n@@ -33,5 +33,5 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.parser.OpParser;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.parser.OpParser;\n@@ -41,8 +41,8 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.add;\n-import static java.lang.reflect.code.op.CoreOp.constant;\n-import static java.lang.reflect.code.op.CoreOp.func;\n-import static java.lang.reflect.code.op.CoreOp.lambda;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.INT;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.add;\n+import static jdk.incubator.code.op.CoreOp.constant;\n+import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.op.CoreOp.lambda;\n+import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.type.JavaType.INT;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import java.lang.reflect.code.parser.impl.Scanner;\n-import java.lang.reflect.code.parser.impl.Tokens;\n+import jdk.incubator.code.parser.impl.Scanner;\n+import jdk.incubator.code.parser.impl.Tokens;\n@@ -33,1 +33,1 @@\n-import static java.lang.reflect.code.parser.impl.Tokens.TokenKind.*;\n+import static jdk.incubator.code.parser.impl.Tokens.TokenKind.*;\n@@ -37,1 +37,1 @@\n- * @modules java.base\/java.lang.reflect.code.parser.impl\n+ * @modules jdk.incubator.code\/jdk.incubator.code.parser.impl\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestScanner.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,6 +24,6 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp.JavaEnhancedForOp;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp.JavaEnhancedForOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n@@ -37,5 +37,5 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.op.ExtendedOp._continue;\n-import static java.lang.reflect.code.op.ExtendedOp.enhancedFor;\n-import static java.lang.reflect.code.type.JavaType.parameterized;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.op.ExtendedOp._continue;\n+import static jdk.incubator.code.op.ExtendedOp.enhancedFor;\n+import static jdk.incubator.code.type.JavaType.parameterized;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -24,5 +24,5 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.ExtendedOp.JavaEnhancedForOp;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.ExtendedOp.JavaEnhancedForOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.JavaType;\n@@ -33,5 +33,5 @@\n-import static java.lang.reflect.code.op.CoreOp.*;\n-import static java.lang.reflect.code.op.ExtendedOp._continue;\n-import static java.lang.reflect.code.op.ExtendedOp.enhancedFor;\n-import static java.lang.reflect.code.type.JavaType.parameterized;\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.op.CoreOp.*;\n+import static jdk.incubator.code.op.ExtendedOp._continue;\n+import static jdk.incubator.code.op.ExtendedOp.enhancedFor;\n+import static jdk.incubator.code.type.JavaType.parameterized;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,4 +34,4 @@\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n@@ -41,1 +42,1 @@\n-import static java.lang.reflect.code.type.JavaType.type;\n+import static jdk.incubator.code.type.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -33,4 +34,4 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStreamUsingQuotable.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules jdk.incubator.code\n@@ -35,6 +36,6 @@\n-import java.lang.reflect.code.type.ArrayType;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.lang.reflect.code.type.TypeVarRef;\n-import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.type.ArrayType;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.type.TypeVarRef;\n+import jdk.incubator.code.type.WildcardType.BoundKind;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestErasure.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,4 +33,4 @@\n-import java.lang.reflect.code.type.ArrayType;\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.CoreTypeFactory;\n-import java.lang.reflect.code.type.JavaType;\n+import jdk.incubator.code.type.ArrayType;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.type.JavaType;\n@@ -45,0 +45,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,5 +29,5 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.type.FieldRef;\n-import java.lang.reflect.code.type.MethodRef;\n-import java.lang.reflect.code.type.RecordTypeRef;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.RecordTypeRef;\n+import jdk.incubator.code.CodeReflection;\n@@ -38,0 +38,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,9 +29,9 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.type.CoreTypeFactory;\n-import java.lang.reflect.code.writer.OpBuilder;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.writer.OpBuilder;\n+import jdk.incubator.code.CodeReflection;\n@@ -43,0 +43,1 @@\n+ * @modules jdk.incubator.code\n@@ -135,1 +136,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -34,7 +35,7 @@\n-import java.lang.reflect.code.CodeItem;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeItem;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -93,1 +94,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestNaming.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Op;\n@@ -33,3 +35,3 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -71,1 +73,1 @@\n-        return m.getCodeModel().get();\n+        return Op.ofMethod(m).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOptions.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,6 +71,6 @@\n-        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements java.util.List<TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements java.util.List<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements java.util.List<TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements java.util.List<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n","filename":"test\/langtools\/jdk\/jshell\/ComputeFQNsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/ArrayAccessTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/AssertTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/BinopTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -30,0 +30,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -30,0 +30,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/BreakContinueTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/CastInstanceOfTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import jdk.incubator.code.Op;\n@@ -5,1 +6,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -13,0 +14,1 @@\n+ * @modules jdk.incubator.code\n@@ -27,1 +29,1 @@\n-        Object[] codeModels = IntStream.range(0, 1024).mapToObj(_ -> m.getCodeModel()).toArray();\n+        Object[] codeModels = IntStream.range(0, 1024).mapToObj(_ -> Op.ofMethod(m)).toArray();\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeModelSameInstanceTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,5 +28,5 @@\n-import java.lang.reflect.code.*;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.writer.OpWriter;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.writer.OpWriter;\n+import jdk.incubator.code.CodeReflection;\n@@ -34,3 +34,3 @@\n-import static java.lang.reflect.code.op.CoreOp._return;\n-import static java.lang.reflect.code.op.CoreOp.func;\n-import static java.lang.reflect.code.type.FunctionType.VOID;\n+import static jdk.incubator.code.op.CoreOp._return;\n+import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.type.FunctionType.VOID;\n@@ -66,1 +66,1 @@\n-        String found = canonicalizeModel(method, method.getCodeModel().orElseThrow());\n+        String found = canonicalizeModel(method, Op.ofMethod(method).orElseThrow());\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalAndOrTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalExpressionTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConstantsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -30,0 +30,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -33,0 +33,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/EnumAccessTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -35,0 +35,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -30,0 +30,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n@@ -34,1 +35,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalClassTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalVarTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodCallTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -34,0 +34,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewArrayTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -5,0 +5,1 @@\n+ * @modules jdk.incubator.code\n@@ -19,3 +20,3 @@\n-                    ()java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> -> {\n-                        %6 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n-                        %7 : java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> = pattern.record %6 @\"(#PatternTest2$R::T<java.lang.Number> n)PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>\";\n+                    ()jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> -> {\n+                        %6 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                        %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> = pattern.record %6 @\"(#PatternTest2$R::T<java.lang.Number> n)PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternTest2.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -30,0 +30,1 @@\n+ * @modules jdk.incubator.code\n@@ -46,2 +47,2 @@\n-                    ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                        %7 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                    ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                        %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -72,2 +73,2 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                %7 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -111,2 +112,2 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                %7 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -169,6 +170,6 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> -> {\n-                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Type<PatternsTest$ConcretePoint> = pattern.type @\"p\";\n-                                %12 : java.lang.reflect.code.ExtendedOp$Pattern$Type<PatternsTest$Color> = pattern.type @\"c\";\n-                                %13 : java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternsTest$ColoredPoint> = pattern.record %11 %12 @\"(PatternsTest$ConcretePoint p, PatternsTest$Color c)PatternsTest$ColoredPoint\";\n-                                %14 : java.lang.reflect.code.ExtendedOp$Pattern$Type<PatternsTest$ColoredPoint> = pattern.type @\"lr\";\n-                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> = pattern.record %13 %14 @\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> -> {\n+                                %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$ConcretePoint> = pattern.type @\"p\";\n+                                %12 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$Color> = pattern.type @\"c\";\n+                                %13 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$ColoredPoint> = pattern.record %11 %12 @\"(PatternsTest$ConcretePoint p, PatternsTest$Color c)PatternsTest$ColoredPoint\";\n+                                %14 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$ColoredPoint> = pattern.type @\"lr\";\n+                                %15 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> = pattern.record %13 %14 @\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n@@ -230,2 +231,2 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                %7 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -268,2 +269,2 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                %7 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -315,2 +316,2 @@\n-                                    ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> -> {\n-                                        %14 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                                    ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> -> {\n+                                        %14 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n@@ -358,2 +359,2 @@\n-                       ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                           %7 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type;\n+                       ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                           %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type;\n@@ -381,4 +382,4 @@\n-                    ()java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> -> {\n-                        %7 : java.lang.reflect.code.ExtendedOp$Pattern$MatchAll = pattern.match.all;\n-                        %8 : java.lang.reflect.code.ExtendedOp$Pattern$Type<PatternsTest$ConcretePoint> = pattern.type @\"cp\";\n-                        %9 : java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> = pattern.record %7 %8 @\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n+                    ()jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> -> {\n+                        %7 : jdk.incubator.code.op.ExtendedOp$Pattern$MatchAll = pattern.match.all;\n+                        %8 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$ConcretePoint> = pattern.type @\"cp\";\n+                        %9 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle> = pattern.record %7 %8 @\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternsTest.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/PrimitiveCastTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,2 +33,2 @@\n-import java.lang.reflect.code.Quotable;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.CodeReflection;\n@@ -42,1 +43,1 @@\n-                  %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                  %0 : jdk.incubator.code.Quotable = lambda ()void -> {\n@@ -53,1 +54,1 @@\n-                %0 : java.lang.reflect.code.Quotable = lambda ()int -> {\n+                %0 : jdk.incubator.code.Quotable = lambda ()int -> {\n@@ -64,1 +65,1 @@\n-                  %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int -> {\n+                  %0 : jdk.incubator.code.Quotable = lambda (%1 : int)int -> {\n@@ -76,1 +77,1 @@\n-                %0 : java.lang.reflect.code.Quotable = lambda (%1 : int, %2 : int)int -> {\n+                %0 : jdk.incubator.code.Quotable = lambda (%1 : int, %2 : int)int -> {\n@@ -91,1 +92,1 @@\n-                %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                %0 : jdk.incubator.code.Quotable = lambda ()void -> {\n@@ -104,1 +105,1 @@\n-                %2 : java.lang.reflect.code.Quotable = lambda (%4 : int)int -> {\n+                %2 : jdk.incubator.code.Quotable = lambda (%4 : int)int -> {\n@@ -130,1 +131,1 @@\n-                %1 : java.lang.reflect.code.Quotable = lambda (%3 : int)int -> {\n+                %1 : jdk.incubator.code.Quotable = lambda (%3 : int)int -> {\n@@ -190,1 +191,1 @@\n-                  %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                  %0 : jdk.incubator.code.Quotable = lambda ()void -> {\n@@ -205,1 +206,1 @@\n-                  %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int -> {\n+                  %0 : jdk.incubator.code.Quotable = lambda (%1 : int)int -> {\n@@ -218,1 +219,1 @@\n-                %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int[] -> {\n+                %0 : jdk.incubator.code.Quotable = lambda (%1 : int)int[] -> {\n@@ -241,1 +242,1 @@\n-                %1 : java.lang.reflect.code.Quotable = lambda (%3 : int)int -> {\n+                %1 : jdk.incubator.code.Quotable = lambda (%3 : int)int -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,2 +33,2 @@\n-import java.lang.reflect.code.Quotable;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import java.lang.reflect.code.Quotable;\n+import jdk.incubator.code.Quotable;\n@@ -11,0 +11,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,2 +33,2 @@\n-import java.lang.reflect.code.Quoted;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.CodeReflection;\n@@ -146,1 +147,1 @@\n-                %2 : java.lang.reflect.code.Quoted = quoted ()void -> {\n+                %2 : jdk.incubator.code.Quoted = quoted ()void -> {\n@@ -156,1 +157,1 @@\n-                %9 : Var<java.lang.reflect.code.Quoted> = var %2 @\"op\";\n+                %9 : Var<jdk.incubator.code.Quoted> = var %2 @\"op\";\n@@ -169,1 +170,1 @@\n-                %1 : java.lang.reflect.code.Quoted = quoted ()void -> {\n+                %1 : jdk.incubator.code.Quoted = quoted ()void -> {\n@@ -181,1 +182,1 @@\n-                %10 : Var<java.lang.reflect.code.Quoted> = var %1 @\"op\";\n+                %10 : Var<jdk.incubator.code.Quoted> = var %1 @\"op\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -5,0 +5,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringConcatTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/SuperTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -31,0 +31,1 @@\n+ * @modules jdk.incubator.code\n@@ -346,3 +347,3 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> -> {\n-                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n-                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> = pattern.record %10 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> -> {\n+                                %10 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                                %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> = pattern.record %10 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n@@ -363,2 +364,2 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                %16 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                %16 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -416,3 +417,3 @@\n-                            ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> -> {\n-                                %12 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n-                                %13 : java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> = pattern.record %12 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                            ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> -> {\n+                                %12 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                                %13 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A> = pattern.record %12 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n@@ -435,2 +436,2 @@\n-                                    ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                        %19 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                                    ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                        %19 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -462,2 +463,2 @@\n-                                    ^pattern()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                        %29 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                                    ^pattern()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                        %29 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -5,0 +5,1 @@\n+ * @modules jdk.incubator.code\n@@ -827,2 +828,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Object> -> {\n-                                %12 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Object> = pattern.type @\"o\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object> -> {\n+                                %12 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object> = pattern.type @\"o\";\n@@ -866,2 +867,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<SwitchExpressionTest2$B> -> {\n-                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Type<SwitchExpressionTest2$B> = pattern.type @\"b\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchExpressionTest2$B> -> {\n+                                %10 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchExpressionTest2$B> = pattern.type @\"b\";\n@@ -882,2 +883,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> -> {\n-                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Type<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = pattern.type @\"c\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> -> {\n+                                %15 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<.<SwitchExpressionTest2, SwitchExpressionTest2$C>> = pattern.type @\"c\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -8,0 +8,1 @@\n+ * @modules jdk.incubator.code\n@@ -1089,2 +1090,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<SwitchStatementTest$K> -> {\n-                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Type<SwitchStatementTest$K> = pattern.type @\"k\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$K> -> {\n+                                %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$K> = pattern.type @\"k\";\n@@ -1108,2 +1109,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<SwitchStatementTest$J> -> {\n-                                %18 : java.lang.reflect.code.ExtendedOp$Pattern$Type<SwitchStatementTest$J> = pattern.type @\"j\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$J> -> {\n+                                %18 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$J> = pattern.type @\"j\";\n@@ -1170,2 +1171,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Object> -> {\n-                                %15 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Object> = pattern.type @\"o\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object> -> {\n+                                %15 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object> = pattern.type @\"o\";\n@@ -1214,2 +1215,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n-                                  %11 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n+                                  %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n@@ -1233,2 +1234,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                  %18 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                  %18 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -1289,2 +1290,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n-                                  %11 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n+                                  %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n@@ -1308,2 +1309,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                  %18 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                  %18 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -1370,2 +1371,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n-                                  %11 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n+                                  %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n@@ -1389,2 +1390,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                  %18 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                  %18 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -1450,2 +1451,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> -> {\n-                                %11 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> -> {\n+                                %11 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n@@ -1466,2 +1467,2 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                %16 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                %16 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -1550,2 +1551,2 @@\n-                                      ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n-                                          %19 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                                      ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n+                                          %19 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n@@ -1580,2 +1581,2 @@\n-                                      ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n-                                          %31 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                                      ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> -> {\n+                                          %31 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n@@ -1655,2 +1656,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                  %19 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type;\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                  %19 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type;\n@@ -1674,2 +1675,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.util.RandomAccess> -> {\n-                                  %26 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.util.RandomAccess> = pattern.type;\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.RandomAccess> -> {\n+                                  %26 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.RandomAccess> = pattern.type;\n@@ -1693,2 +1694,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<int[]> -> {\n-                                  %33 : java.lang.reflect.code.ExtendedOp$Pattern$Type<int[]> = pattern.type;\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<int[]> -> {\n+                                  %33 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<int[]> = pattern.type;\n@@ -1712,2 +1713,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.util.Stack[][]> -> {\n-                                  %40 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.util.Stack[][]> = pattern.type;\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Stack[][]> -> {\n+                                  %40 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Stack[][]> = pattern.type;\n@@ -1731,2 +1732,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.util.Collection[][][]> -> {\n-                                  %47 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.util.Collection[][][]> = pattern.type;\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Collection[][][]> -> {\n+                                  %47 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Collection[][][]> = pattern.type;\n@@ -1750,2 +1751,2 @@\n-                              ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> -> {\n-                                  %54 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                              ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> -> {\n+                                  %54 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n@@ -1809,3 +1810,3 @@\n-                            ()java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> -> {\n-                                %9 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n-                                %10 : java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> = pattern.record %9 @\"(java.lang.Number n)SwitchStatementTest$R\";\n+                            ()jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R> -> {\n+                                %9 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                                %10 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R> = pattern.record %9 @\"(java.lang.Number n)SwitchStatementTest$R\";\n@@ -1867,2 +1868,2 @@\n-                                    ()java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> -> {\n-                                        %12 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n+                                    ()jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> -> {\n+                                        %12 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String> = pattern.type @\"s\";\n@@ -1901,3 +1902,3 @@\n-                                    ()java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> -> {\n-                                        %28 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n-                                        %29 : java.lang.reflect.code.ExtendedOp$Pattern$Record<SwitchStatementTest$R> = pattern.record %28 @\"(java.lang.Number n)SwitchStatementTest$R\";\n+                                    ()jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R> -> {\n+                                        %28 : jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number> = pattern.type @\"n\";\n+                                        %29 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R> = pattern.record %28 @\"(java.lang.Number n)SwitchStatementTest$R\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":48,"deletions":47,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/SynchronizedTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.code\n@@ -38,5 +39,5 @@\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.op.CoreOp.FuncOp;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.writer.OpWriter;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.writer.OpWriter;\n@@ -100,0 +101,1 @@\n+                            \"--add-modules=jdk.incubator.code\",\n@@ -151,1 +153,1 @@\n-                    Optional<Object> body = elements.getBody(e);\n+                    Optional<FuncOp> body = Op.ofElement(processingEnv, e);\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.Op;\n@@ -34,3 +36,3 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp.FuncOp;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.CodeReflection;\n@@ -58,1 +60,1 @@\n-        FuncOp model = sum.getCodeModel().get();\n+        FuncOp model = Op.ofMethod(sum).get();\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestLocalCapture.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/ThrowTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/TryTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,1 +33,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnaryopTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,3 +24,3 @@\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.CodeReflection;\n@@ -32,0 +32,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnreachableTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.runtime.CodeReflection;\n+import jdk.incubator.code.CodeReflection;\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.code\n","filename":"test\/langtools\/tools\/javac\/reflect\/WhileLoopTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @compile\/fail\/ref=TestAssignment.out -XDrawDiagnostics TestAssignment.java\n+ * @modules jdk.incubator.code\n+ * @compile\/fail\/ref=TestAssignment.out -Xlint:-incubating -XDrawDiagnostics TestAssignment.java\n@@ -29,1 +30,1 @@\n-import java.lang.reflect.code.Quoted;\n+import jdk.incubator.code.Quoted;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,5 +1,4 @@\n-TestAssignment.java:43:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:44:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:45:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:46:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:47:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:44:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:45:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:46:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:47:26: compiler.err.quoted.lambda.must.be.explicit\n@@ -7,5 +6,5 @@\n-TestAssignment.java:52:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:53:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:54:28: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:55:26: compiler.err.quoted.lambda.must.be.explicit\n-TestAssignment.java:56:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:49:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:53:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:54:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:55:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:56:26: compiler.err.quoted.lambda.must.be.explicit\n@@ -13,3 +12,4 @@\n-TestAssignment.java:61:41: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n-TestAssignment.java:62:37: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n-14 errors\n\\ No newline at end of file\n+TestAssignment.java:58:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:62:41: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestAssignment.java:63:37: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.out","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -32,5 +33,5 @@\n-import java.lang.reflect.code.op.CoreOp.Var;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.op.CoreOp.Var;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.interpreter.Interpreter;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.code\n@@ -30,5 +31,5 @@\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.op.CoreOp.Var;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.interpreter.Interpreter;\n+import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.op.CoreOp.Var;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.interpreter.Interpreter;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @compile\/fail\/ref=TestGenericMethodCall.out -XDrawDiagnostics TestGenericMethodCall.java\n+ * @modules jdk.incubator.code\n+ * @compile\/fail\/ref=TestGenericMethodCall.out -Xlint:-incubating -XDrawDiagnostics TestGenericMethodCall.java\n@@ -29,1 +30,1 @@\n-import java.lang.reflect.code.Quoted;\n+import jdk.incubator.code.Quoted;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-TestGenericMethodCall.java:43:29: compiler.err.quoted.lambda.must.be.explicit\n@@ -7,1 +6,1 @@\n-TestGenericMethodCall.java:52:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:49:29: compiler.err.quoted.lambda.must.be.explicit\n@@ -13,3 +12,4 @@\n-TestGenericMethodCall.java:61:40: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n-TestGenericMethodCall.java:62:40: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n-14 errors\n\\ No newline at end of file\n+TestGenericMethodCall.java:58:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:62:40: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestGenericMethodCall.java:63:40: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @compile\/fail\/ref=TestMethodCall.out -XDrawDiagnostics TestMethodCall.java\n+ * @modules jdk.incubator.code\n+ * @compile\/fail\/ref=TestMethodCall.out -Xlint:-incubating -XDrawDiagnostics TestMethodCall.java\n@@ -29,1 +30,1 @@\n-import java.lang.reflect.code.Quoted;\n+import jdk.incubator.code.Quoted;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-TestMethodCall.java:43:15: compiler.err.quoted.lambda.must.be.explicit\n@@ -7,1 +6,1 @@\n-TestMethodCall.java:52:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:49:15: compiler.err.quoted.lambda.must.be.explicit\n@@ -13,3 +12,4 @@\n-TestMethodCall.java:61:26: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n-TestMethodCall.java:62:26: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n-14 errors\n\\ No newline at end of file\n+TestMethodCall.java:58:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:62:26: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestMethodCall.java:63:26: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @compile\/fail\/ref=TestRecovery.out -XDrawDiagnostics TestRecovery.java\n+ * @modules jdk.incubator.code\n+ * @compile\/fail\/ref=TestRecovery.out -Xlint:-incubating -XDrawDiagnostics TestRecovery.java\n@@ -29,1 +30,1 @@\n-import java.lang.reflect.code.Quoted;\n+import jdk.incubator.code.Quoted;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,6 +1,6 @@\n-TestRecovery.java:33:22: compiler.err.quoted.lambda.must.be.explicit\n-TestRecovery.java:33:50: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n-TestRecovery.java:37:15: compiler.err.quoted.lambda.must.be.explicit\n-TestRecovery.java:37:43: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n-TestRecovery.java:41:29: compiler.err.quoted.lambda.must.be.explicit\n-TestRecovery.java:41:57: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:34:22: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:34:50: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:38:15: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:38:43: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:42:29: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:42:57: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}