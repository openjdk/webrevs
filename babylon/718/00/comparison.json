{"files":[{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -33,1 +34,1 @@\n-public @interface Kernel {\n+public @interface After {\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/After.java","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Kernel.java","status":"copied"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -33,2 +34,2 @@\n-public @interface Kernel {\n-    String value();\n+public @interface Align {\n+    long value();\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Align.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Kernel.java","status":"copied"},{"patch":"@@ -33,3 +33,3 @@\n-@Target(ElementType.METHOD)\n-public @interface Preformatted {\n-    String value();\n+@Target(ElementType.FIELD)\n+public @interface Order {\n+    String[] value() default {};\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Order.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Preformatted.java","status":"copied"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -33,2 +34,2 @@\n-public @interface Kernel {\n-    String value();\n+public @interface Pad {\n+    long value();\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Pad.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Kernel.java","status":"copied"},{"patch":"@@ -34,1 +34,1 @@\n-public @interface Preformatted {\n+public @interface ProvidesDimFor {\n","filename":"hat\/core\/src\/main\/java\/hat\/annotations\/ProvidesDimFor.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/annotations\/Preformatted.java","status":"copied"},{"patch":"@@ -248,1 +248,1 @@\n-            case \"D\" -> \"F\";\n+            case \"D\" -> \"D\";\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,18 +54,0 @@\n-    \/\/  default boolean isDeviceDirty(){\n-    \/\/    return BufferState.of(this).isDeviceDirty();\n-   \/\/ }\n-   \/\/ default boolean isHostChecked(){\n-     \/\/   return BufferState.of(this).isHostChecked();\n-   \/\/ }\n-\n-   \/\/ default void clearDeviceDirty(){\n-   \/\/      BufferState.of(this).clearDeviceDirty();\n-   \/\/ }\n-    \/\/default void setHostDirty(){\n-      \/\/  BufferState.of(this).setHostDirty(true);\n-   \/\/ }\n-\n-   \/\/ default void setHostChecked(){\n-     \/\/   BufferState.of(this).setHostChecked(true);\n-   \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.annotations.ProvidesDimFor;\n@@ -33,0 +34,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -35,0 +37,1 @@\n+    @ProvidesDimFor(\"array\")\n@@ -39,1 +42,1 @@\n-    int ARRAY_OFFSET = 4;\n+    long ARRAY_OFFSET = JAVA_INT.byteSize();\n@@ -41,2 +44,1 @@\n-    Schema<F32Array> schema = Schema.of(F32Array.class, s32Array ->\n-            s32Array.arrayLen(\"length\").array(\"array\"));\n+    Schema<F32Array> schema = Schema.of(F32Array.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -38,2 +39,2 @@\n-\n-    int ARRAY_OFFSET = 16;\n+    long PAD_SIZE = 12;\n+    long ARRAY_OFFSET = JAVA_INT.byteSize()+PAD_SIZE;\n@@ -42,1 +43,1 @@\n-            .arrayLen(\"length\").pad(ARRAY_OFFSET-4).array(\"array\"));\n+            .arrayLen(\"length\").pad(PAD_SIZE).array(\"array\"));\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-public interface HATVector {\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/HATVector.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.annotations.Order;\n@@ -45,1 +46,1 @@\n-    void dimensions(int numDimensions);\n+    void dimensions(int dimensions);\n@@ -86,9 +87,6 @@\n-    Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class,\n-            kernelContext -> kernelContext\n-                    .fields(\"dimensions\",  \/\/ Dimension (1D, 2D or 3D)\n-                            \"gix\", \"giy\", \"giz\",   \/\/ global thread-id accesses\n-                            \"gsx\", \"gsy\", \"gsz\",   \/\/ global sizes\n-                            \"lix\", \"liy\", \"liz\",   \/\/ local (thread-ids)\n-                            \"lsx\", \"lsy\", \"lsz\",   \/\/ block size\n-                            \"bix\", \"biy\", \"biz\"    \/\/ block id\n-                    ));\n+    @Order({\"dimensions\",  \/\/ Dimension (1D, 2D or 3D)\n+            \"gix\", \"giy\", \"giz\",   \/\/ global thread-id accesses\n+            \"gsx\", \"gsy\", \"gsz\",   \/\/ global sizes\n+            \"lix\", \"liy\", \"liz\",   \/\/ local (thread-ids)\n+            \"lsx\", \"lsy\", \"lsz\",   \/\/ block size\n+            \"bix\", \"biy\", \"biz\"}  ) Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.annotations.ProvidesDimFor;\n@@ -36,2 +37,1 @@\n-\n-    int length();\n+    @ProvidesDimFor(\"array\") int length();\n@@ -41,4 +41,2 @@\n-    int HEADER_BYTES = 4;\n-\n-    Schema<S32Array> schema = Schema.of(S32Array.class, s32Array->s32Array\n-            .arrayLen(\"length\").array(\"array\"));\n+    long HEADER_BYTES = JAVA_INT.byteSize();\n+    Schema<S32Array> schema = Schema.of(S32Array.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import hat.annotations.Order;\n+import hat.annotations.ProvidesDimFor;\n@@ -34,0 +36,2 @@\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n@@ -36,0 +40,1 @@\n+import java.util.HashSet;\n@@ -38,0 +43,1 @@\n+import java.util.Set;\n@@ -47,1 +53,1 @@\n-            int len;\n+            long len;\n@@ -49,1 +55,1 @@\n-            Padding(IfaceType parent, int len) {\n+            Padding(IfaceType parent, long len) {\n@@ -127,0 +133,41 @@\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface) {\n+        \/\/ first lets try to find the Schema field\n+\n+        Field schema = null;\n+        try{\n+            schema = iface.getDeclaredField(\"schema\");\n+        }catch (NoSuchFieldException nsfe){\n+            throw new RuntimeException(nsfe);\n+        }\n+        if (!Modifier.isStatic(schema.getModifiers())){\n+            throw new RuntimeException(\"no static field called schema\");\n+        }\n+        String[] order = (schema.getAnnotation(Order.class) instanceof Order orderAnnotation)?orderAnnotation.value():null;\n+\n+\n+        Set<String> handled = new HashSet<>();\n+        return of(iface, (schemaBuilder)-> {\n+                    Arrays.stream(iface.getDeclaredMethods()).filter(m -> Modifier.isAbstract(m.getModifiers())).forEach(m -> {\n+                                if (m.getAnnotation(ProvidesDimFor.class) instanceof ProvidesDimFor providesDimFor) {\n+\n+                                    schemaBuilder.arrayLen(m.getName()).array(providesDimFor.value());\n+                                    if (!handled.contains(m.getName())) {\n+                                        handled.add(m.getName());\n+                                    }\n+                                    \/\/if (!handled.contains(providesDimFor.value())) {\n+                                        handled.add(providesDimFor.value());\n+                                   \/\/ }\n+                                } else if (order == null && !handled.contains(m.getName())) {\n+                                    System.out.println(m.getName());\n+                                    schemaBuilder.fields(m.getName());\n+                                    handled.add(m.getName());\n+                                }\n+                            }\n+                    );\n+                    if (order != null) {\n+                        schemaBuilder.fields(order);\n+                    }\n+                }\n+        );\n+}\n+\n@@ -274,1 +321,1 @@\n-            int padding = 0;\n+            long padding = 0;\n@@ -286,1 +333,1 @@\n-            public ArrayBuildState pad(int padding) {\n+            public ArrayBuildState pad(long padding) {\n","filename":"hat\/core\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"}]}