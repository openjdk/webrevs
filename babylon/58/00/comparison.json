{"files":[{"patch":"@@ -194,0 +194,1 @@\n+    private Op.Result oprOnStack;\n@@ -266,1 +267,1 @@\n-            cob.constantInstruction(fromValue(constantOp.value()));\n+            cob.constantInstruction(((Constable)constantOp.value()).describeConstable().orElseThrow());\n@@ -275,3 +276,10 @@\n-    private void processOperands(Op op, boolean isLastOpResultOnStack) {\n-        for (int i = isLastOpResultOnStack ? 1 : 0; i < op.operands().size(); i++) {\n-            load(op.operands().get(i));\n+    private void processFirstOperand(Op op) {\n+        processOperand(op.operands().getFirst());;\n+    }\n+\n+    private void processOperand(Value operand) {\n+        if (oprOnStack == null) {\n+            load(operand);\n+        } else {\n+            assert oprOnStack == operand;\n+            oprOnStack = null;\n@@ -281,6 +289,2 @@\n-    private static ConstantDesc fromValue(Object value) {\n-        return switch (value) {\n-            case ConstantDesc cd -> cd;\n-            case JavaType td -> td.toNominalDescriptor();\n-            default -> throw new IllegalArgumentException(\"Unsupported constant value: \" + value);\n-        };\n+    private void processOperands(Op op) {\n+        processOperands(op.operands());\n@@ -289,5 +293,9 @@\n-    \/\/ Determines if the operation result used only by the next operation as the first operand\n-    private static boolean isResultOnlyUse(Op.Result opr) {\n-        Set<Op.Result> uses = opr.uses();\n-        if (uses.size() != 1) {\n-            return false;\n+    private void processOperands(List<Value> operands) {\n+        if (oprOnStack == null) {\n+            operands.forEach(this::load);\n+        } else {\n+            assert !operands.isEmpty() && oprOnStack == operands.getFirst();\n+            oprOnStack = null;\n+            for (int i = 1; i < operands.size(); i++) {\n+                load(operands.get(i));\n+            }\n@@ -295,0 +303,1 @@\n+    }\n@@ -296,6 +305,9 @@\n-        \/\/ Pass over constant operations\n-        Op.Result use = uses.iterator().next();\n-        Op nextOp = opr.op();\n-        do {\n-            nextOp = opr.declaringBlock().nextOp(nextOp);\n-        } while (nextOp instanceof CoreOps.ConstantOp);\n+    \/\/ Some of the operations can be deferred\n+    private static boolean canDefer(Op op) {\n+        return switch (op) {\n+            case ConstantOp cop -> canDefer(cop);\n+            case VarOp vop -> canDefer(vop);\n+            case VarAccessOp.VarLoadOp vlop -> canDefer(vlop);\n+            default -> false;\n+        };\n+    }\n@@ -303,3 +315,4 @@\n-        if (nextOp == null || use != nextOp.result()) {\n-            return false;\n-        }\n+    \/\/ Constant can be deferred, except for loading of a class constant, which  may throw an exception\n+    private static boolean canDefer(ConstantOp op) {\n+        return !op.resultType().equals(JavaType.J_L_CLASS);\n+    }\n@@ -307,6 +320,4 @@\n-        \/\/ Check if used in successor\n-        for (Block.Reference s : nextOp.successors()) {\n-            if (s.arguments().contains(opr)) {\n-                return false;\n-            }\n-        }\n+    \/\/ Var with a single-use block parameter operand can be deferred\n+    private static boolean canDefer(VarOp op) {\n+        return op.operands().getFirst() instanceof Block.Parameter bp && bp.uses().size() == 1;\n+    }\n@@ -314,2 +325,36 @@\n-        List<Value> operands = nextOp.operands();\n-        return !operands.isEmpty() && opr == operands.get(0);\n+    \/\/ Var load can be deferred when not used as immediate operand\n+    private static boolean canDefer(VarAccessOp.VarLoadOp op) {\n+        return !isNextUse(op.result());\n+    }\n+\n+    \/\/ This method narrows the first operand inconveniences of some operations\n+    private static boolean isFirstOperand(Op nextOp, Op.Result opr) {\n+        return switch (nextOp) {\n+            \/\/ When there is no next operation\n+            case null -> false;\n+            \/\/ New object cannot use first operand from stack, new array fall through to the default\n+            case NewOp op when !(op.constructorType().returnType() instanceof ArrayType) ->\n+                false;\n+            \/\/ For lambda the effective operands are captured values\n+            case LambdaOp op ->\n+                !op.capturedValues().isEmpty() && op.capturedValues().getFirst() == opr;\n+            \/\/ Conditional branch may delegate to its binary test operation\n+            case ConditionalBranchOp op when getConditionForCondBrOp(op) instanceof CoreOps.BinaryTestOp bto ->\n+                isFirstOperand(bto, opr);\n+            \/\/ Var store effective first operand is not the first one\n+            case VarAccessOp.VarStoreOp op ->\n+                op.operands().get(1) == opr;\n+            \/\/ regular check of the first operand\n+            default ->\n+                !nextOp.operands().isEmpty() && nextOp.operands().getFirst() == opr;\n+        };\n+    }\n+\n+    \/\/ Determines if the operation result is immediatelly used by the next operation and so can stay on stack\n+    private static boolean isNextUse(Op.Result opr) {\n+        \/\/ Pass over deferred operations\n+        Op nextOp = opr.op();\n+        do {\n+            nextOp = opr.declaringBlock().nextOp(nextOp);\n+        } while (canDefer(nextOp));\n+        return isFirstOperand(nextOp, opr);\n@@ -477,3 +522,1 @@\n-            \/\/ True if the last result is retained on the stack for use as first operand of current operation\n-            boolean isLastOpResultOnStack = false;\n-            Op.Result oprOnStack = null;\n+            oprOnStack = null;\n@@ -481,3 +524,3 @@\n-                Op o = ops.get(i);\n-                TypeElement oprType = o.resultType();\n-                TypeKind rvt = toTypeKind(oprType);\n+                final Op o = ops.get(i);\n+                final TypeElement oprType = o.resultType();\n+                final TypeKind rvt = toTypeKind(oprType);\n@@ -486,7 +529,4 @@\n-                        if (op.resultType().equals(JavaType.J_L_CLASS)) {\n-                            \/\/ Loading a class constant may throw an exception so it cannot be deferred\n-                            cob.ldc(fromValue(op.value()));\n-                        } else {\n-                          \/\/ Defer process to use, where constants are inlined\n-                          \/\/ This applies to both operands and successor arguments\n-                          rvt = TypeKind.VoidType;\n+                        if (!canDefer(op)) {\n+                            \/\/ Constant can be deferred, except for a class constant, which  may throw an exception\n+                            cob.ldc(((JavaType)op.value()).toNominalDescriptor());\n+                            push(op.result());\n@@ -497,6 +537,8 @@\n-                        processOperands(op, isLastOpResultOnStack);\n-                        isLastOpResultOnStack = false;\n-                        \/\/ Use slot of variable result\n-                        storeIfUsed(op.result());\n-                        \/\/ Ignore result\n-                        rvt = TypeKind.VoidType;\n+                        if (canDefer(op)) {\n+                            \/\/ Var with a single-use block parameter operand can be deferred\n+                            slots.put(op.result(), slots.get(op.operands().getFirst()));\n+                        } else {\n+                            processOperand(op.operands().getFirst());\n+                            allocateSlot(op.result());\n+                            push(op.result());\n+                        }\n@@ -505,4 +547,6 @@\n-                        \/\/ Use slot of variable result\n-                        Slot slot = load(op.operands().get(0));\n-                        if (slot != null) {\n-                            slots.putIfAbsent(op.result(), slot);\n+                        if (canDefer(op)) {\n+                            \/\/ Var load can be deferred when not used as immediate operand\n+                            slots.computeIfAbsent(op.result(), r -> slots.get(op.operands().getFirst()));\n+                        } else {\n+                            processFirstOperand(op);\n+                            push(op.result());\n@@ -512,5 +556,1 @@\n-                        if (!isLastOpResultOnStack) {\n-                            load(op.operands().get(1));\n-                            isLastOpResultOnStack = false;\n-                        }\n-                        \/\/ Use slot of variable result\n+                        processOperand(op.operands().get(1));\n@@ -520,2 +560,3 @@\n-                        processOperands(op, isLastOpResultOnStack);\n-                        TypeKind tk = toTypeKind(op.operands().get(0).type());\n+                        Value first = op.operands().getFirst();\n+                        processOperand(first);\n+                        TypeKind tk = toTypeKind(first.type());\n@@ -523,0 +564,1 @@\n+                        push(op.result());\n@@ -525,1 +567,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processFirstOperand(op);\n@@ -533,0 +575,1 @@\n+                        push(op.result());\n@@ -535,1 +578,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processFirstOperand(op);\n@@ -537,0 +580,1 @@\n+                        push(op.result());\n@@ -539,1 +583,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -547,0 +591,1 @@\n+                        push(op.result());\n@@ -549,1 +594,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -557,0 +602,1 @@\n+                        push(op.result());\n@@ -559,1 +605,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -567,0 +613,1 @@\n+                        push(op.result());\n@@ -569,1 +616,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -577,0 +624,1 @@\n+                        push(op.result());\n@@ -579,1 +627,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -587,0 +635,1 @@\n+                        push(op.result());\n@@ -589,1 +638,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -595,0 +644,1 @@\n+                        push(op.result());\n@@ -597,1 +647,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -603,0 +653,1 @@\n+                        push(op.result());\n@@ -605,1 +656,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -611,0 +662,1 @@\n+                        push(op.result());\n@@ -613,1 +665,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -620,0 +672,1 @@\n+                        push(op.result());\n@@ -622,1 +675,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -625,1 +678,1 @@\n-                            case IntType -> cob.ishr();\n+                            case IntType, ByteType, ShortType, CharType -> cob.ishr();\n@@ -629,0 +682,1 @@\n+                        push(op.result());\n@@ -631,1 +685,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -634,1 +688,1 @@\n-                            case IntType -> cob.iushr();\n+                            case IntType, ByteType, ShortType, CharType -> cob.iushr();\n@@ -638,0 +692,1 @@\n+                        push(op.result());\n@@ -640,1 +695,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -642,0 +697,1 @@\n+                        push(op.result());\n@@ -644,3 +700,3 @@\n-                        processOperands(op, isLastOpResultOnStack);\n-                        TypeKind evt = toTypeKind(op.operands().get(2).type());\n-                        cob.arrayStoreInstruction(evt);\n+                        processOperands(op);\n+                        cob.arrayStoreInstruction(toTypeKind(op.operands().get(2).type()));\n+                        push(op.result());\n@@ -649,1 +705,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processFirstOperand(op);\n@@ -651,0 +707,1 @@\n+                        push(op.result());\n@@ -654,1 +711,1 @@\n-                            processOperands(op, isLastOpResultOnStack);\n+                            processOperands(op);\n@@ -656,3 +713,1 @@\n-                        } else {\n-                            \/\/ Processing is deferred to the CondBrOp, do not process the op result\n-                            rvt = TypeKind.VoidType;\n+                            push(op.result());\n@@ -660,0 +715,1 @@\n+                        \/\/ Processing is deferred to the CondBrOp, do not process the op result\n@@ -662,8 +718,10 @@\n-                        TypeElement t_ = op.constructorType().returnType();\n-                        JavaType t = (JavaType) t_;\n-                        switch (t) {\n-                            case ArrayType at when at.dimensions() == 1 -> {\n-                                processOperands(op, isLastOpResultOnStack);\n-                                ClassDesc ctd = at.componentType().toNominalDescriptor();\n-                                if (ctd.isPrimitive()) {\n-                                    cob.newarray(TypeKind.from(ctd));\n+                        switch (op.constructorType().returnType()) {\n+                            case ArrayType at -> {\n+                                processOperands(op);\n+                                if (at.dimensions() == 1) {\n+                                    ClassDesc ctd = at.componentType().toNominalDescriptor();\n+                                    if (ctd.isPrimitive()) {\n+                                        cob.newarray(TypeKind.from(ctd));\n+                                    } else {\n+                                        cob.anewarray(ctd);\n+                                    }\n@@ -671,1 +729,1 @@\n-                                    cob.anewarray(ctd);\n+                                    cob.multianewarray(at.toNominalDescriptor(), op.operands().size());\n@@ -674,13 +732,4 @@\n-                            case ArrayType at -> {\n-                                processOperands(op, isLastOpResultOnStack);\n-                                cob.multianewarray(t.toNominalDescriptor(), op.operands().size());\n-                            }\n-                            default -> {\n-                                if (isLastOpResultOnStack) {\n-                                    storeIfUsed(oprOnStack);\n-                                    isLastOpResultOnStack = false;\n-                                    oprOnStack = null;\n-                                }\n-                                cob.new_(t.toNominalDescriptor())\n-                                        .dup();\n-                                processOperands(op, false);\n+                            case JavaType jt -> {\n+                                cob.new_(jt.toNominalDescriptor())\n+                                    .dup();\n+                                processOperands(op);\n@@ -691,1 +740,1 @@\n-                                                .changeReturnType(ConstantDescs.CD_void));\n+                                                 .changeReturnType(ConstantDescs.CD_void));\n@@ -693,0 +742,3 @@\n+                            default ->\n+                                throw new IllegalArgumentException(\"Invalid return type: \"\n+                                                                    + op.constructorType().returnType());\n@@ -694,0 +746,1 @@\n+                        push(op.result());\n@@ -696,1 +749,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -732,3 +785,1 @@\n-                        if (op.resultType().equals(JavaType.VOID) && !op.operands().isEmpty()) {\n-                            isLastOpResultOnStack = false;\n-                        }\n+                        push(op.result());\n@@ -737,1 +788,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -750,0 +801,1 @@\n+                        push(op.result());\n@@ -752,2 +804,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n-                        isLastOpResultOnStack = false;\n+                        processOperands(op);\n@@ -768,1 +819,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processFirstOperand(op);\n@@ -770,0 +821,1 @@\n+                        push(op.result());\n@@ -772,1 +824,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processFirstOperand(op);\n@@ -774,0 +826,1 @@\n+                        push(op.result());\n@@ -777,0 +830,1 @@\n+                        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n@@ -779,4 +833,1 @@\n-                            for (Value cv : op.capturedValues()) {\n-                                load(cv);\n-                            }\n-                            MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                            processOperands(op.capturedValues());\n@@ -826,0 +877,1 @@\n+                        push(op.result());\n@@ -830,11 +882,0 @@\n-                \/\/ Assign slot to operation result\n-                if (rvt != TypeKind.VoidType) {\n-                    if (!isResultOnlyUse(o.result())) {\n-                        isLastOpResultOnStack = false;\n-                        oprOnStack = null;\n-                        storeIfUsed(o.result());\n-                    } else {\n-                        isLastOpResultOnStack = true;\n-                        oprOnStack = o.result();\n-                    }\n-                }\n@@ -849,1 +890,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processFirstOperand(op);\n@@ -854,1 +895,1 @@\n-                    processOperands(op, isLastOpResultOnStack);\n+                    processFirstOperand(op);\n@@ -864,1 +905,1 @@\n-                        processOperands(btop, isLastOpResultOnStack);\n+                        processOperands(btop);\n@@ -867,1 +908,1 @@\n-                        processOperands(op, isLastOpResultOnStack);\n+                        processOperands(op);\n@@ -884,0 +925,28 @@\n+    private boolean inBlockArgs(Op.Result res) {\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : res.declaringBlock().successors()) {\n+            if (s.arguments().contains(res)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void push(Op.Result res) {\n+        assert oprOnStack == null;\n+        if (res.type().equals(JavaType.VOID)) return;\n+        if (isNextUse(res)) {\n+            if (res.uses().size() > 1 || inBlockArgs(res)) {\n+                switch (toTypeKind(res.type()).slotSize()) {\n+                    case 1 -> cob.dup();\n+                    case 2 -> cob.dup2();\n+                }\n+                storeIfUsed(res);\n+            }\n+            oprOnStack = res;\n+        } else {\n+            storeIfUsed(res);\n+            oprOnStack = null;\n+        }\n+    }\n+\n@@ -1037,1 +1106,5 @@\n-                load(value);\n+                if (oprOnStack == value) {\n+                    oprOnStack = null;\n+                } else {\n+                    load(value);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":211,"deletions":138,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2306,0 +2306,1 @@\n+                case BYTE -> CoreOps.constant(typeToTypeElement(t), (byte)0);\n@@ -2319,0 +2320,1 @@\n+                case BYTE -> CoreOps.constant(typeToTypeElement(t), (byte)1);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.IOException;\n@@ -27,0 +28,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -48,0 +50,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -58,1 +62,1 @@\n- * @run testng TestBytecode\n+ * @run testng\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n@@ -71,0 +75,27 @@\n+    @CodeReflection\n+    @SkipLift\n+    static byte byteNumOps(byte i, byte j, byte k) {\n+        k++;\n+        i = (byte) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static short shortNumOps(short i, short j, short k) {\n+        k++;\n+        i = (short) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static char charNumOps(char i, char j, char k) {\n+        k++;\n+        i = (char) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n@@ -100,0 +131,18 @@\n+    @CodeReflection\n+    @SkipLift\n+    static byte byteBitOps(byte i, byte j, byte k) {\n+        return (byte) (i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static short shortBitOps(short i, short j, short k) {\n+        return (short) (i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static char charBitOps(char i, char j, char k) {\n+        return (char) (i & j | k ^ j);\n+    }\n+\n@@ -110,0 +159,41 @@\n+    @CodeReflection\n+    @SkipLift\n+    static int intShiftOps(int i, int j, int k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static byte byteShiftOps(byte i, byte j, byte k) {\n+        return (byte) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static short shortShiftOps(short i, short j, short k) {\n+        return (short) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static char charShiftOps(char i, char j, char k) {\n+        return (char) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static long longShiftOps(long i, long j, long k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static Object[] boxingAndUnboxing(int i, byte b, short s, char c, Integer ii, Byte bb, Short ss, Character cc) {\n+        ii += i; ii += b; ii += s; ii += c;\n+        i += ii; i += bb; i += ss; i += cc;\n+        b += ii; b += bb; b += ss; b += cc;\n+        s += ii; s += bb; s += ss; s += cc;\n+        c += ii; c += bb; c += ss; c += cc;\n+        return new Object[]{i, b, s, c};\n+    }\n+\n@@ -254,1 +344,7 @@\n-    static boolean not(int i, int j) {\n+    @SkipLift\n+    static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static boolean notCompare(int i, int j) {\n@@ -364,0 +460,1 @@\n+    private static ClassModel CLASS_MODEL;\n@@ -368,1 +465,1 @@\n-\/\/        ClassPrinter.toYaml(ClassFile.of().parse(CLASS_DATA), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        CLASS_MODEL = ClassFile.of().parse(CLASS_DATA);\n@@ -387,2 +484,4 @@\n-        initTestArgs(values(1, 2, 3, 4), int.class, Integer.class, byte.class,\n-                Byte.class, short.class, Short.class, char.class, Character.class);\n+        initTestArgs(values(1, 2, 3, 4), int.class, Integer.class);\n+        initTestArgs(values((byte)1, (byte)2, (byte)3, (byte)4), byte.class, Byte.class);\n+        initTestArgs(values((short)1, (short)2, (short)3, (short)4), short.class, Short.class);\n+        initTestArgs(values((char)1, (char)2, (char)3, (char)4), char.class, Character.class);\n@@ -480,0 +579,16 @@\n+            String methodName = d.testMethod().getName();\n+            for (var mm : CLASS_MODEL.methods()) {\n+                if (mm.methodName().equalsString(methodName)\n+                        || mm.methodName().stringValue().startsWith(\"lambda$\" + methodName + \"$\")) {\n+                    ClassPrinter.toYaml(mm,\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                }\n+            }\n+            Files.list(Path.of(\"DUMP_CLASS_FILES\")).forEach(p -> {\n+                if (p.getFileName().toString().matches(methodName + \"\\\\..+\\\\.class\")) try {\n+                    ClassPrinter.toYaml(ClassFile.of().parse(p),\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                } catch (IOException ignore) {}\n+            });\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":120,"deletions":5,"binary":false,"changes":125,"status":"modified"}]}