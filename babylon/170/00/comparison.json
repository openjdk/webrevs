{"files":[{"patch":"@@ -27,1 +27,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n@@ -29,5 +29,0 @@\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.CompleteBuffer;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.Arena;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Cascade.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ResultTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SchemaLayoutTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.Schema;\n@@ -32,2 +29,0 @@\n-import hat.backend.JavaMultiThreadedBackend;\n-import hat.backend.JavaSequentialBackend;\n@@ -35,1 +30,0 @@\n-import hat.buffer.F32Array2D;\n@@ -49,1 +43,0 @@\n-import java.lang.runtime.CodeReflection;\n@@ -55,1 +48,0 @@\n-\n@@ -64,1 +56,1 @@\n-        XMLHaarCascadeModel haarCascade = XMLHaarCascadeModel.load(\n+        XMLHaarCascadeModel xmlCascade = XMLHaarCascadeModel.load(\n@@ -70,3 +62,0 @@\n-        Cascade cascade = Cascade.create(accelerator, haarCascade);\n-\n-       var cascade2 = Cascade.schema.allocate(accelerator,haarCascade.featureCount(),haarCascade.stageCount(),haarCascade.treeCount());\n@@ -74,0 +63,6 @@\n+        var cascade = Cascade.schema.allocate(\n+                accelerator,\n+                xmlCascade.featureCount(),\n+                xmlCascade.stageCount(),\n+                xmlCascade.treeCount()\n+        ).copyFrom(xmlCascade);\n@@ -75,2 +70,0 @@\n-       System.out.println(\"Original   \"+Buffer.getLayout(cascade));\n-        System.out.println(\"Schema     \"+Buffer.getLayout(cascade2));\n@@ -78,1 +71,3 @@\n-        ResultTable resultTable = ResultTable.create(accelerator, 1000);\n+        ResultTable resultTable = ResultTable.schema.allocate(1000);\n+        resultTable.length(1000);\n+\n@@ -84,0 +79,4 @@\n+        ScaleTable.Constraints constraints = new ScaleTable.Constraints(cascade,rgbImage.width(),rgbImage.height());\n+        ScaleTable scaleTable = ScaleTable.schema.allocate(constraints.scales);\n+        scaleTable.length(constraints.scales);\n+        scaleTable.applyConstraints(constraints);\n@@ -85,1 +84,0 @@\n-        \/\/System.out.println(\"Compute units \"+((NativeBackend)accelerator.backend).getGetMaxComputeUnits());\n@@ -89,1 +87,1 @@\n-                    ViolaJonesCoreCompute.compute(cc, cascade, nasa1996, rgbImage, resultTable)\n+                    ViolaJonesCoreCompute.compute(cc, cascade, nasa1996, rgbImage, resultTable,scaleTable)\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCompute.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-    static public void compute(final ComputeContext cc, Cascade cascade, BufferedImage bufferedImage, RgbS08x3Image rgbS08x3Image, ResultTable resultTable) {\n+    static public void compute(final ComputeContext cc, Cascade cascade, BufferedImage bufferedImage, RgbS08x3Image rgbS08x3Image, ResultTable resultTable, ScaleTable scaleTable) {\n@@ -333,0 +333,2 @@\n+\n+\n@@ -334,1 +336,2 @@\n-        ScaleTable scaleTable = ScaleTable.create(cc, cascade, width, height);\n+\n+       \/\/ create(cc, constraints);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,2 +55,3 @@\n-        XMLHaarCascadeModel xmlHaarCascade = XMLHaarCascadeModel.load(ViolaJonesRaw.class.getResourceAsStream(\"\/cascades\/haarcascade_frontalface_default.xml\"));\n-        Cascade cascade = Cascade.create(accelerator, xmlHaarCascade);\n+        XMLHaarCascadeModel xmlCascade = XMLHaarCascadeModel.load(ViolaJonesRaw.class.getResourceAsStream(\"\/cascades\/haarcascade_frontalface_default.xml\"));\n+   \/\/     Cascade cascade = Cascade.create(accelerator, xmlHaarCascade);\n+        var cascade = Cascade.schema.allocate(accelerator,xmlCascade.featureCount(),xmlCascade.stageCount(),xmlCascade.treeCount()).copyFrom(xmlCascade);\n@@ -62,1 +63,6 @@\n-        var scaleTable = ScaleTable.create(accelerator, cascade, width, height);\/\/ multiScaleTable.multiScaleCount);\n+        ScaleTable.Constraints constraints = new ScaleTable.Constraints(cascade,width,height);\n+        \/\/ harViz.showIntegrals();\n+\n+        var scaleTable = ScaleTable.schema.allocate(constraints.scales);\n+        scaleTable.length(constraints.scales);\n+        scaleTable.applyConstraints(constraints);\n@@ -68,1 +74,2 @@\n-        var resultTable = ResultTable.create(accelerator, 1000);\n+        var resultTable = ResultTable.schema.allocate(accelerator, 1000);\n+        resultTable.length(1000);\n@@ -335,1 +342,1 @@\n-                                xmlHaarCascade,\/\/cascade,\/\/haarCascade, \/\/or cascade\n+                                xmlCascade,\/\/cascade,\/\/haarCascade, \/\/or cascade\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -37,1 +36,0 @@\n-\n@@ -42,1 +40,0 @@\n-\n@@ -46,1 +43,0 @@\n-\n@@ -48,1 +44,0 @@\n-\n@@ -50,8 +45,0 @@\n-\n-    default short get(int x, int y) {\n-        return data((long) y * width() + x);\n-    }\n-\n-    default void set(int x, int y, short v) {\n-        data((long) y * width() + x, v);\n-    }\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/buffers\/GreyU16Image.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -30,1 +29,0 @@\n-\n@@ -32,1 +30,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -48,1 +45,0 @@\n-\n@@ -53,8 +49,0 @@\n-    default byte get(int x, int y, int deltaMod3) {\n-        return data(((long) y * width() * 3 + x * 3) + deltaMod3);\n-    }\n-\n-    default void set(int x, int y, int deltaMod3, byte v) {\n-        data(((long) y * width() * 3 + x * 3) + deltaMod3, v);\n-    }\n-\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/buffers\/RgbS08x3Image.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import hat.Accelerator;\n-import hat.Schema;\n+import hat.ifacemapper.Schema;\n@@ -50,8 +49,0 @@\n-            StructLayout layout = MemoryLayout.structLayout(\n-                    JAVA_BYTE.withName(\"x\"),\n-                    JAVA_BYTE.withName(\"y\"),\n-                    JAVA_BYTE.withName(\"width\"),\n-                    JAVA_BYTE.withName(\"height\"),\n-                    JAVA_FLOAT.withName(\"weight\")\n-            ).withName(\"Rect\");\n-\n@@ -82,4 +73,0 @@\n-                MemoryLayout layout = MemoryLayout.unionLayout(\n-                        JAVA_INT.withName(\"featureId\"),\n-                        JAVA_FLOAT.withName(\"value\")\n-                ).withName(\"Anon\");\n@@ -95,7 +82,0 @@\n-\n-            StructLayout layout = MemoryLayout.structLayout(\n-                    JAVA_BOOLEAN.withName(\"hasValue\"),\n-                    MemoryLayout.paddingLayout(3),\n-                    Feature.LinkOrValue.Anon.layout.withName(\"anon\")\n-            ).withName(\"LinkOrValue\");\n-\n@@ -108,9 +88,0 @@\n-\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"id\"),\n-                JAVA_FLOAT.withName(\"threshold\"),\n-                Feature.LinkOrValue.layout.withName(\"left\"),\n-                Feature.LinkOrValue.layout.withName(\"right\"),\n-                MemoryLayout.sequenceLayout(3, Feature.Rect.layout).withName(\"rect\")\n-        ).withName(Feature.class.getSimpleName());\n-\n@@ -136,7 +107,0 @@\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"id\"),\n-                JAVA_FLOAT.withName(\"threshold\"),\n-                JAVA_SHORT.withName(\"firstTreeId\"),\n-                JAVA_SHORT.withName(\"treeCount\")\n-        ).withName(Stage.class.getSimpleName());\n-\n@@ -161,6 +125,0 @@\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"id\"),\n-                JAVA_SHORT.withName(\"firstFeatureId\"),\n-                JAVA_SHORT.withName(\"featureCount\")\n-        ).withName(Tree.class.getSimpleName());\n-\n@@ -182,67 +140,0 @@\n-    static Cascade create(BufferAllocator bufferAllocator, XMLHaarCascadeModel haarCascade) {\n-\n-        Cascade cascade = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), Cascade.class,\n-                JAVA_INT.withName(\"width\"),\n-                JAVA_INT.withName(\"height\"),\n-                JAVA_INT.withName(\"featureCount\"),\n-                sequenceLayout(haarCascade.features.size(), Feature.layout.withName(Feature.class.getSimpleName())).withName(\"feature\"),\n-                JAVA_INT.withName(\"stageCount\"),\n-                sequenceLayout(haarCascade.stages.size(), Stage.layout.withName(Stage.class.getSimpleName())).withName(\"stage\"),\n-                JAVA_INT.withName(\"treeCount\"),\n-                sequenceLayout(haarCascade.trees.size(), Tree.layout.withName(Tree.class.getSimpleName())).withName(\"tree\")\n-        ));\n-        cascade.width(haarCascade.width());\n-        cascade.height(haarCascade.height());\n-        cascade.featureCount(haarCascade.features.size());\n-        cascade.stageCount(haarCascade.stages.size());\n-        cascade.treeCount(haarCascade.trees.size());\n-        for (int idx = 0; idx < haarCascade.features.size(); idx++) {\n-            Cascade.Feature cascadeFeature = cascade.feature(idx);\n-            var haarfeature = haarCascade.features.get(idx);\n-            cascadeFeature.id(haarfeature.id());\n-            cascadeFeature.threshold(haarfeature.threshold());\n-            Cascade.Feature.LinkOrValue cascadeLeft = cascadeFeature.left();\n-            cascadeLeft.hasValue(haarfeature.left.hasValue());\n-            if (haarfeature.left.hasValue()) {\n-                cascadeLeft.anon().value(haarfeature.left.value());\n-            } else {\n-                cascadeLeft.anon().value(haarfeature.left.featureId());\n-            }\n-            Cascade.Feature.LinkOrValue cascadeRight = cascadeFeature.right();\n-            cascadeRight.hasValue(haarfeature.right.hasValue());\n-            if (haarfeature.right.hasValue()) {\n-                cascadeRight.anon().value(haarfeature.right.value());\n-            } else {\n-                cascadeRight.anon().featureId(haarfeature.right.featureId());\n-            }\n-            for (int r = 0; r < 3; r++) {\n-                var haarrect = haarfeature.rects[r];\n-                if (haarrect != null) {\n-                    Cascade.Feature.Rect cascadeRect = cascadeFeature.rect(r);\n-                    cascadeRect.x(haarrect.x());\n-                    cascadeRect.y(haarrect.y());\n-                    cascadeRect.width(haarrect.width());\n-                    cascadeRect.height(haarrect.height());\n-                    cascadeRect.weight(haarrect.weight());\n-                }\n-            }\n-        }\n-\n-\n-        for (XMLHaarCascadeModel.Stage haarstage : haarCascade.stages) {\n-            Cascade.Stage cascadeStage = cascade.stage(haarstage.id);\n-            cascadeStage.id(haarstage.id());\n-            cascadeStage.threshold(haarstage.threshold());\n-            cascadeStage.firstTreeId(haarstage.firstTreeId());\n-            cascadeStage.treeCount(haarstage.treeCount());\n-        }\n-\n-        for (XMLHaarCascadeModel.Tree haarTree : haarCascade.trees) {\n-            Cascade.Tree cascadeTree = cascade.tree(haarTree.id());\n-            cascadeTree.id(haarTree.id());\n-            cascadeTree.firstFeatureId(haarTree.firstFeatureId());\n-            cascadeTree.featureCount(haarTree.featureCount());\n-        }\n-        return cascade;\n-    }\n-\n@@ -285,1 +176,1 @@\n-            .arrayLen(\"stageCount\").array(\"stage\", stage->stage.fields(\"id\",\"threshold\",\"treeCount\",\"firstTreeId\"))\n+            .arrayLen(\"stageCount\").array(\"stage\", stage->stage.fields(\"id\",\"threshold\",\"firstTreeId\",\"treeCount\"))\n@@ -289,0 +180,56 @@\n+    default Cascade copyFrom(Cascade fromCascade){\n+        Cascade toCascade= this;\n+        toCascade.width(fromCascade.width());\n+        toCascade.height(fromCascade.height());\n+        toCascade.featureCount(fromCascade.featureCount());\n+        toCascade.stageCount(fromCascade.stageCount());\n+        toCascade.treeCount(fromCascade.treeCount());\n+        for (int idx = 0; idx < fromCascade.featureCount(); idx++) {\n+            Cascade.Feature toFeature =  toCascade.feature(idx);\n+            Cascade.Feature fromFeature = fromCascade.feature(idx);\n+            toFeature.id(fromFeature.id());\n+            toFeature.threshold(fromFeature.threshold());\n+            Cascade.Feature.LinkOrValue toLeftLinkOrValue = toFeature.left();\n+            toLeftLinkOrValue.hasValue(fromFeature.left().hasValue());\n+            if (fromFeature.left().hasValue()) {\n+                toLeftLinkOrValue.anon().value(fromFeature.left().anon().value());\n+            } else {\n+                toLeftLinkOrValue.anon().value(fromFeature.left().anon().featureId());\n+            }\n+            Cascade.Feature.LinkOrValue toRightLinkOrValue = toFeature.right();\n+            toRightLinkOrValue.hasValue(fromFeature.right().hasValue());\n+            if (fromFeature.right().hasValue()) {\n+                toRightLinkOrValue.anon().value(fromFeature.right().anon().value());\n+            } else {\n+                toRightLinkOrValue.anon().featureId(fromFeature.right().anon().featureId());\n+            }\n+            for (int r = 0; r < 3; r++) {\n+                var fromRect = fromFeature.rect(r);\n+                if (fromRect != null) {\n+                    var toRect = toFeature.rect(r);\n+                    toRect.x(fromRect.x());\n+                    toRect.y(fromRect.y());\n+                    toRect.width(fromRect.width());\n+                    toRect.height(fromRect.height());\n+                    toRect.weight(fromRect.weight());\n+                }\n+            }\n+        }\n+\n+        for (int stageIdx = 0; stageIdx<fromCascade.stageCount(); stageIdx++) {\n+            Cascade.Stage fromStage =  fromCascade.stage(stageIdx);\/\/ stage(haarstage.id);\n+            Cascade.Stage toStage =  toCascade.stage(stageIdx);\n+            toStage.id(fromStage.id());\n+            toStage.threshold(fromStage.threshold());\n+            toStage.firstTreeId(fromStage.firstTreeId());\n+            toStage.treeCount(fromStage.treeCount());\n+        }\n+        for (int treeIdx=0; treeIdx <fromCascade.treeCount(); treeIdx++) {\n+            Cascade.Tree toTree =  toCascade.tree(treeIdx);\n+            Cascade.Tree fromTree =  fromCascade.tree(treeIdx);\n+            toTree.id(fromTree.id());\n+            toTree.firstFeatureId(fromTree.firstFeatureId());\n+            toTree.featureCount(fromTree.featureCount());\n+        }\n+        return toCascade;\n+    }\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":58,"deletions":111,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import hat.Accelerator;\n-import hat.Schema;\n+import hat.buffer.IncompleteBuffer;\n+import hat.ifacemapper.Schema;\n@@ -41,9 +41,1 @@\n-public interface ResultTable extends Table<ResultTable.Result> {\n-\n-    interface Result {\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_FLOAT.withName(\"x\"),\n-                JAVA_FLOAT.withName(\"y\"),\n-                JAVA_FLOAT.withName(\"width\"),\n-                JAVA_FLOAT.withName(\"height\")\n-        ).withName(\"Result\");\n+public interface ResultTable extends IncompleteBuffer  {\n@@ -51,0 +43,1 @@\n+    interface Result extends Buffer.StructChild {\n@@ -52,1 +45,0 @@\n-\n@@ -54,1 +46,0 @@\n-\n@@ -56,1 +47,0 @@\n-\n@@ -58,2 +48,0 @@\n-\n-\n@@ -61,1 +49,0 @@\n-\n@@ -63,1 +50,0 @@\n-\n@@ -65,1 +51,0 @@\n-\n@@ -69,14 +54,2 @@\n-    StructLayout layout = MemoryLayout.structLayout(\n-            JAVA_INT.withName(\"length\"),\n-            JAVA_INT.withName(\"atomicResultTableCount\"),\n-            MemoryLayout.sequenceLayout(0, ResultTable.Result.layout).withName(\"result\")\n-    );\n-\n-    static ResultTable create(BufferAllocator bufferAllocator, int length) {\n-        return Buffer.setLength(\n-                bufferAllocator.allocate(SegmentMapper.ofIncomplete(MethodHandles.lookup(),ResultTable.class,layout,length)),length);\n-    }\n-\n-    default Result get(int i) {\n-        return result(i);\n-    }\n+    int length();\n+    void length(int length);\n@@ -87,1 +60,0 @@\n-\n@@ -96,1 +68,1 @@\n-    Schema<ResultTable> schema = null;\/*Schema.of(ResultTable.class, resultTable->resultTable\n+    Schema<ResultTable> schema = Schema.of(ResultTable.class, resultTable->resultTable\n@@ -99,6 +71,1 @@\n-                    .fields(\n-                            \"x\",\n-                            \"y\",\n-                            \"width\",\n-                            \"height\"\n-                    )\n+                    .fields(\"x\", \"y\", \"width\", \"height\")\n@@ -106,1 +73,1 @@\n-    );*\/\n+    );\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":9,"deletions":42,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import hat.Accelerator;\n-import hat.Schema;\n+import hat.buffer.IncompleteBuffer;\n+import hat.ifacemapper.Schema;\n@@ -35,1 +35,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -37,1 +36,0 @@\n-import java.lang.foreign.SequenceLayout;\n@@ -44,15 +42,2 @@\n-public interface ScaleTable extends Table<ScaleTable.Scale> {\n-    interface Scale extends Buffer {\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_FLOAT.withName(\"scaleValue\"),\n-                JAVA_FLOAT.withName(\"scaledXInc\"),\n-                JAVA_FLOAT.withName(\"scaledYInc\"),\n-                JAVA_FLOAT.withName(\"invArea\"),\n-                JAVA_INT.withName(\"scaledFeatureWidth\"),\n-                JAVA_INT.withName(\"scaledFeatureHeight\"),\n-                JAVA_INT.withName(\"gridWidth\"),\n-                JAVA_INT.withName(\"gridHeight\"),\n-                JAVA_INT.withName(\"gridSize\"),\n-                JAVA_INT.withName(\"accumGridSizeMin\"),\n-                JAVA_INT.withName(\"accumGridSizeMax\")\n-        ).withName(\"Scale\");\n+public interface ScaleTable extends IncompleteBuffer {\n+    interface Scale extends Buffer.StructChild {\n@@ -103,14 +88,0 @@\n-\n-        default void copyFrom(Scale s) {\n-            scaleValue(s.scaleValue());\n-            accumGridSizeMax(s.accumGridSizeMax());\n-            accumGridSizeMin(s.accumGridSizeMin());\n-            gridSize(s.gridSize());\n-            gridWidth(s.gridWidth());\n-            gridHeight(s.gridHeight());\n-            invArea(s.invArea());\n-            scaledFeatureWidth(s.scaledFeatureWidth());\n-            scaledFeatureHeight(s.scaledFeatureHeight());\n-            scaledXInc(s.scaledXInc());\n-            scaledYInc(s.scaledYInc());\n-        }\n@@ -118,11 +89,0 @@\n-    StructLayout layout =  MemoryLayout.structLayout(\n-            JAVA_INT.withName(\"length\"),\n-            JAVA_INT.withName(\"multiScaleAccumulativeRange\"),\n-            MemoryLayout.sequenceLayout(0, ScaleTable.Scale.layout).withName(\"scale\")\n-    ).withName(ScaleTable.class.getSimpleName());\n-    private static ScaleTable create(BufferAllocator bufferAllocator, int length) {\n-        return Buffer.setLength(\n-                bufferAllocator.allocate(SegmentMapper.ofIncomplete(MethodHandles.lookup(),ScaleTable.class,layout,length)),length);\n-    }\n-\n-    static ScaleTable create(BufferAllocator bufferAllocator, Cascade cascade, int imageWidth, int imageHeight) {\n@@ -130,17 +90,23 @@\n-        final float startScale = 1f;\n-        final float scaleMultiplier = 2f;\n-        final float increment = 0.06f;\n-\n-        \/\/ We need to capture multi scale data\n-        \/\/ this is unique per image as it is\n-        \/\/ based on size, how many scales we want and the overlap desired\n-\n-        var maxScale = (Math.min(\n-                (float) imageWidth \/ cascade.width(),\n-                (float) imageHeight \/ cascade.height()));\n-\n-        \/\/System.out.println(\"Image \" + imageWidth + \"x\" + imageHeight);\n-        \/\/ Alas we need to do this twice. We need a count to allocate the segment size\n-        int multiScaleCountVar = 0;\n-        for (float scale = startScale; scale < maxScale; scale *= scaleMultiplier) {\n-            multiScaleCountVar++;\n+     class Constraints{\n+        final float startScale;\n+        final float scaleMultiplier;\n+        final float increment;\n+        final int cascadeWidth; int cascadeHeight;  int imageWidth; int imageHeight;\n+        final float maxScale;\n+        public final int scales;\n+        Constraints(float startScale, float scaleMultiplier, float increment, int cascadeWidth, int cascadeHeight, int imageWidth, int imageHeight){\n+            this.startScale = startScale;\n+            this.scaleMultiplier = scaleMultiplier;\n+            this.increment = increment;\n+            this.cascadeWidth = cascadeWidth;\n+            this.cascadeHeight = cascadeHeight;\n+            this.imageWidth = imageWidth;\n+            this.imageHeight = imageHeight;\n+            this.maxScale  = (Math.min(\n+                    (float) imageWidth \/ cascadeWidth,\n+                    (float) imageHeight \/ cascadeHeight));\n+            int nonFinalScales = 0;\n+            for (float scale = this.startScale; scale < this.maxScale; scale *= scaleMultiplier) {\n+                nonFinalScales++;\n+            }\n+            this.scales = nonFinalScales;\n@@ -148,0 +114,7 @@\n+        Constraints( int cascadeWidth, int cascadeHeight, int imageWidth, int imageHeight){\n+           this(1f,2f,0.06f,cascadeWidth,cascadeHeight,imageWidth,imageHeight);\n+        }\n+        public Constraints(Cascade cascade, int imageWidth, int imageHeight){\n+            this(1f,2f,0.06f,cascade.width(),cascade.height(),imageWidth,imageHeight);\n+        }\n+    }\n@@ -149,4 +122,1 @@\n-        ScaleTable scaleTable = ScaleTable.create(bufferAllocator, multiScaleCountVar);\n-\n-        \/\/ now we know the size\n-\n+      default void applyConstraints ( Constraints constraints) {\n@@ -155,2 +125,2 @@\n-        for (float scaleValue = startScale; scaleValue < maxScale; scaleValue *= scaleMultiplier) {\n-            ScaleTable.Scale scale = scaleTable.scale(idx++);\n+        for (float scaleValue = constraints.startScale; scaleValue < constraints.maxScale; scaleValue *= constraints.scaleMultiplier) {\n+            ScaleTable.Scale scale = scale(idx++);\n@@ -159,2 +129,2 @@\n-            final int scaledFeatureWidth = (int) (cascade.width() * scaleValue);\n-            final int scaledFeatureHeight = (int) (cascade.height() * scaleValue);\n+            final int scaledFeatureWidth = (int) (constraints.cascadeWidth * scaleValue);\n+            final int scaledFeatureHeight = (int) (constraints.cascadeHeight * scaleValue);\n@@ -164,2 +134,2 @@\n-            final float scaledXInc = scaledFeatureWidth * increment;\n-            final float scaledYInc = scaledFeatureHeight * increment;\n+            final float scaledXInc = scaledFeatureWidth * constraints.increment;\n+            final float scaledYInc = scaledFeatureHeight * constraints.increment;\n@@ -169,2 +139,2 @@\n-            int gridWidth = (int) ((imageWidth - scaledFeatureWidth) \/ scaledXInc);\n-            int gridHeight = (int) ((imageHeight - scaledFeatureHeight) \/ scaledYInc);\n+            int gridWidth = (int) ((constraints.imageWidth - scaledFeatureWidth) \/ scaledXInc);\n+            int gridHeight = (int) ((constraints.imageHeight - scaledFeatureHeight) \/ scaledYInc);\n@@ -180,2 +150,2 @@\n-        scaleTable.multiScaleAccumulativeRange(multiScaleAccumulativeRangeVar);\n-        \/\/System.out.println(\"Scales \" + scaleTable.length());\n+        multiScaleAccumulativeRange(multiScaleAccumulativeRangeVar);\n+\n@@ -183,2 +153,4 @@\n-        return scaleTable;\n-    }\n+       }\n+\n+    int length();\n+    void length(int length);\n@@ -188,3 +160,0 @@\n-    default Scale get(int i) {\n-        return scale(i);\n-    }\n@@ -200,1 +169,1 @@\n-    Schema<ScaleTable> schema = null;\/*Schema.of(ScaleTable.class, scaleTable->scaleTable\n+    Schema<ScaleTable> schema = Schema.of(ScaleTable.class, scaleTable->scaleTable\n@@ -213,1 +182,1 @@\n-    );*\/\n+    );\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":51,"deletions":82,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1,682 +0,0 @@\n-package hat;\n-\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.function.Consumer;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n-public class Schema<T extends Buffer> {\n-    SchemaNode.TypeSchemaNode schemaRootField;\n-    public Class<T> iface;\n-\n-    static abstract sealed class LayoutToBoundFieldTreeNode permits ChildLayoutToBoundFieldTreeNode, BoundSchema {\n-        static class FieldLayoutBinding<T extends SchemaNode> {\n-            final T field;\n-            MemoryLayout layout;\n-            FieldLayoutBinding(T field, MemoryLayout layout) {\n-                this.field = field;\n-                this.layout = layout;\n-            }\n-        }\n-\n-        static class FieldControlledArrayBinding extends FieldLayoutBinding<SchemaNode.FieldControlledArray> {\n-            final int idx;\n-            final int len;\n-\n-            FieldControlledArrayBinding(int idx, int len, SchemaNode.FieldControlledArray fieldControlledArray) {\n-                super(fieldControlledArray, null);\n-                this.idx = idx;\n-                this.len = len;\n-            }\n-        }\n-\n-        final protected LayoutToBoundFieldTreeNode parent;\n-        final List<ChildLayoutToBoundFieldTreeNode> children = new ArrayList<>();\n-        final List<MemoryLayout> memoryLayouts = new ArrayList<>();\n-        final List<FieldLayoutBinding> fieldToLayoutBindings = new ArrayList<>();\n-\n-        LayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n-            this.parent = parent;\n-        }\n-\n-        abstract int takeArrayLen();\n-\n-        abstract FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout);\n-\n-        void bind(SchemaNode field, MemoryLayout memoryLayout) {\n-            FieldLayoutBinding fieldLayoutBinding = null;\n-            if (field instanceof SchemaNode.FieldControlledArray fieldControlledArray) {\n-                fieldLayoutBinding = createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n-            } else {\n-                fieldLayoutBinding = new FieldLayoutBinding(field, memoryLayout);\n-            }\n-            fieldToLayoutBindings.add(fieldLayoutBinding);\n-            memoryLayouts.add(memoryLayout);\n-        }\n-\n-        public MemoryLayout[] array() {\n-            return memoryLayouts.toArray(new MemoryLayout[0]);\n-        }\n-\n-        public ChildLayoutToBoundFieldTreeNode createChild() {\n-            var childLayoutCollector = new ChildLayoutToBoundFieldTreeNode(this);\n-            children.add(childLayoutCollector);\n-            return childLayoutCollector;\n-        }\n-    }\n-\n-    public static final class BoundSchema<T extends Buffer> extends LayoutToBoundFieldTreeNode {\n-        final private List<FieldControlledArrayBinding> arraySizeBindings;\n-        final private int[] arrayLengths;\n-        final Schema<T> schema;\n-        final public GroupLayout groupLayout;\n-        public BoundSchema(Schema<T> schema, int ...arrayLengths) {\n-            super(null);\n-            this.schema = schema;\n-            this.arrayLengths = arrayLengths;\n-            this.arraySizeBindings = new ArrayList<>();\n-            LayoutToBoundFieldTreeNode scope = createChild();\n-            schema.schemaRootField.fields.forEach(c -> c.collectLayouts(scope));\n-            MemoryLayout memoryLayout = isUnion(schema.schemaRootField.nameTypeAndMode.type)\n-                    ?MemoryLayout.unionLayout(scope.array())\n-                    :MemoryLayout.structLayout(scope.array());\n-            bind(schema.schemaRootField, memoryLayout.withName(schema.iface.getSimpleName()));\n-            this.groupLayout = (GroupLayout) memoryLayouts.getFirst();\n-        }\n-\n-        public T allocate(BufferAllocator bufferAllocator) {\n-            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), schema.iface, groupLayout));\n-        }\n-\n-        @Override\n-        int takeArrayLen() {\n-            return arrayLengths[arraySizeBindings.size()];\n-        }\n-\n-        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n-            int idx = arraySizeBindings.size();\n-            var arraySizeBinding = new FieldControlledArrayBinding(idx, arrayLengths[idx], fieldControlledArray);\n-            arraySizeBindings.add(arraySizeBinding);\n-            return arraySizeBinding;\n-        }\n-    }\n-\n-    public static final class ChildLayoutToBoundFieldTreeNode extends LayoutToBoundFieldTreeNode {\n-        ChildLayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n-            super(parent);\n-        }\n-\n-        @Override\n-        int takeArrayLen() {\n-            return parent.takeArrayLen();\n-        }\n-\n-        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n-            return parent.createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n-        }\n-    }\n-\n-    public static class NameTypeAndMode {\n-        enum Mode {\n-            ROOT,\n-            PRIMITIVE_GETTER_AND_SETTER,\n-            PRIMITIVE_GETTER,\n-            PRIMITIVE_SETTER,\n-            IFACE_GETTER,\n-            PRIMITIVE_ARRAY_SETTER,\n-            PRIMITIVE_ARRAY_GETTER,\n-            PRIMITIVE_ARRAY_GETTER_AND_SETTER,\n-            IFACE_ARRAY_GETTER;\n-\n-            \/**\n-             * From the iface mapper we get these mappings\n-             *\n-             * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n-             * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n-             * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n-             * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n-             *\n-             * @param m The reflected method\n-             * @return Class represeting the type this method is mapped to\n-             *\/\n-            static Mode of(Method m) {\n-                Class<?> returnType = m.getReturnType();\n-                Class<?>[] paramTypes = m.getParameterTypes();\n-                if (paramTypes.length == 0 && returnType.isInterface()) {\n-                    return IFACE_GETTER;\n-                } else if (paramTypes.length == 0 && returnType.isPrimitive()) {\n-                    return PRIMITIVE_GETTER;\n-                } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-                    return PRIMITIVE_SETTER;\n-                } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n-                    return IFACE_ARRAY_GETTER;\n-                } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n-                    return PRIMITIVE_ARRAY_GETTER;\n-                } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                        paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n-                    return PRIMITIVE_ARRAY_SETTER;\n-                } else {\n-                    System.out.println(\"skiping \" + m);\n-                    return null;\n-                }\n-            }\n-        }\n-\n-        Mode mode;\n-        Class<?> type;\n-        String name;\n-\n-        NameTypeAndMode(Mode mode, Class<?> type, String name) {\n-            this.mode = mode;\n-            this.type = type;\n-            this.name = name;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return mode.name() + \":\" + type.getSimpleName() + \":\" + name;\n-        }\n-\n-        \/**\n-         * From the iface mapper\n-         * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n-         * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n-         * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n-         * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n-         *\n-         * @param m The reflected method\n-         * @return Class represeting the type this method is mapped to\n-         *\/\n-        static Class<?> methodToType(Method m) {\n-            Class<?> returnType = m.getReturnType();\n-            Class<?>[] paramTypes = m.getParameterTypes();\n-            if (paramTypes.length == 0 && (returnType.isInterface() || returnType.isPrimitive())) {\n-                return returnType;\n-            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-                return paramTypes[0];\n-            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && (returnType.isInterface() || returnType.isPrimitive())) {\n-                return returnType;\n-            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n-                return paramTypes[1];\n-            } else {\n-                System.out.println(\"skipping \" + m);\n-                return null;\n-            }\n-        }\n-\n-        static NameTypeAndMode of(Class<?> iface, String name) {\n-            NameTypeAndMode accessStyle = new NameTypeAndMode(null, null, name);\n-            var methods = iface.getDeclaredMethods();\n-            Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n-                NameTypeAndMode.Mode mode = NameTypeAndMode.Mode.of(matchingMethod);\n-                Class<?> type = methodToType(matchingMethod);\n-                accessStyle.type = type;\n-                if (accessStyle.type == null) {\n-                    accessStyle.type = type;\n-                } else if (!accessStyle.type.equals(type)) {\n-                    throw new IllegalStateException(\"type mismatch for \" + name);\n-                }\n-                if (accessStyle.mode == null){\n-                    \/\/ We don't have one already\n-                    accessStyle.mode = mode;\n-                } else if ((accessStyle.mode.equals(Mode.PRIMITIVE_ARRAY_GETTER) && mode.equals(Mode.PRIMITIVE_ARRAY_SETTER))\n-                        || (accessStyle.mode.equals(Mode.PRIMITIVE_ARRAY_SETTER) && mode.equals(Mode.PRIMITIVE_ARRAY_GETTER))) {\n-                    \/\/ mode was already an array getter or setter and is now a GETTER_AND_SETTER\n-                    accessStyle.mode = Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER;\n-                } else if ((accessStyle.mode.equals(Mode.PRIMITIVE_GETTER) && mode.equals(Mode.PRIMITIVE_SETTER))\n-                        || (accessStyle.mode.equals(Mode.PRIMITIVE_SETTER) && mode.equals(Mode.PRIMITIVE_GETTER))) {\n-                    \/\/ mode was already a primitive getter or setter and is now a GETTER_AND_SETTER\n-                    accessStyle.mode= Mode.PRIMITIVE_GETTER_AND_SETTER;\n-                }\n-\n-            });\n-            if (accessStyle.type == null && accessStyle.mode == null) {\n-                accessStyle.type = iface;\n-                accessStyle.name = \"root\";\n-                accessStyle.mode = Mode.ROOT;\n-            }\n-            return accessStyle;\n-        }\n-    }\n-\n-    static boolean isBuffer(Class<?> clazz) {\n-        return clazz.isInterface() && Buffer.class.isAssignableFrom(clazz);\n-    }\n-\n-    static boolean isStruct(Class<?> clazz) {\n-        return clazz.isInterface() && Buffer.StructChild.class.isAssignableFrom(clazz);\n-    }\n-\n-    static boolean isStructOrBuffer(Class<?> clazz) {\n-        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.StructChild.class.isAssignableFrom(clazz));\n-    }\n-\n-    static boolean isUnion(Class<?> clazz) {\n-        return clazz.isInterface() && Buffer.UnionChild.class.isAssignableFrom(clazz);\n-    }\n-\n-    public static abstract class SchemaNode {\n-        TypeSchemaNode parent;\n-        SchemaNode(TypeSchemaNode parent) {\n-            this.parent = parent;\n-        }\n-        public abstract void toText(String indent, Consumer<String> stringConsumer);\n-\n-        public static abstract sealed class FieldSchemaNode extends SchemaNode permits Array, ArrayLen, AtomicField, Field, Padding {\n-            FieldSchemaNode(TypeSchemaNode parent) {\n-                super(parent);\n-            }\n-            public abstract void toText(String indent, Consumer<String> stringConsumer);\n-            abstract void collectLayouts(LayoutToBoundFieldTreeNode layoutCollector);\n-        }\n-\n-        public static final class Padding extends FieldSchemaNode {\n-            int len;\n-            Padding(TypeSchemaNode parent, int len) {\n-                super(parent);\n-                this.len = len;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"padding \" + len + \" bytes\");\n-            }\n-\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.paddingLayout(len));\n-            }\n-        }\n-\n-        public static final class ArrayLen extends FieldSchemaNode {\n-            NameTypeAndMode nameTypeAndMode;\n-\n-            ArrayLen(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n-                super(parent);\n-                this.nameTypeAndMode = nameTypeAndMode;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"arrayLen \" + nameTypeAndMode);\n-            }\n-\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(nameTypeAndMode, layoutToFieldBindingNode).withName(nameTypeAndMode.name));\n-            }\n-        }\n-\n-        public static final class AtomicField extends FieldSchemaNode {\n-            NameTypeAndMode nameTypeAndMode;\n-\n-            AtomicField(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n-                super(parent);\n-                this.nameTypeAndMode = nameTypeAndMode;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"atomic \" + nameTypeAndMode);\n-            }\n-\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(nameTypeAndMode, layoutToFieldBindingNode).withName(nameTypeAndMode.name));\n-            }\n-        }\n-\n-        public static final class Field extends FieldSchemaNode {\n-            NameTypeAndMode nameTypeAndMode;\n-\n-            Field(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n-                super(parent);\n-                this.nameTypeAndMode = nameTypeAndMode;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"field \" + nameTypeAndMode);\n-            }\n-\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, parent.getLayout(nameTypeAndMode, layoutToFieldBindingNode).withName(nameTypeAndMode.name));\n-            }\n-        }\n-\n-        public static abstract sealed class TypeSchemaNode extends SchemaNode permits Union,Struct {\n-            private List<FieldSchemaNode> fields = new ArrayList<>();\n-            private List<TypeSchemaNode> types = new ArrayList<>();\n-            NameTypeAndMode nameTypeAndMode;\n-\n-            <T extends FieldSchemaNode> T addField(T child) {\n-                fields.add(child);\n-                return child;\n-            }\n-            <T extends TypeSchemaNode> T addType(T child) {\n-                types.add(child);\n-                return child;\n-            }\n-\n-            TypeSchemaNode(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n-                super(parent);\n-                this.nameTypeAndMode = nameTypeAndMode;\n-            }\n-            \/**\n-             * Get a layout which describes the NameTypeAndMode.\n-             * <p>\n-             * If NameTypeAndMode holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n-             * Otherwise we look through the parent's children.  Which should include a type node struct\/union matching the type.\n-             *\n-             * @param nameTypeAndMode\n-             * @param layoutToFieldBindingNode\n-             * @return\n-             *\/\n-             MemoryLayout getLayout(NameTypeAndMode nameTypeAndMode, LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                MemoryLayout memoryLayout = null;\n-                if (nameTypeAndMode.type == Integer.TYPE) {\n-                    memoryLayout = JAVA_INT;\n-                } else if (nameTypeAndMode.type == Float.TYPE) {\n-                    memoryLayout = JAVA_FLOAT;\n-                } else if (nameTypeAndMode.type == Long.TYPE) {\n-                    memoryLayout = JAVA_LONG;\n-                } else if (nameTypeAndMode.type == Double.TYPE) {\n-                    memoryLayout = JAVA_DOUBLE;\n-                } else if (nameTypeAndMode.type == Short.TYPE) {\n-                    memoryLayout = JAVA_SHORT;\n-                } else if (nameTypeAndMode.type == Character.TYPE) {\n-                    memoryLayout = JAVA_CHAR;\n-                } else if (nameTypeAndMode.type == Byte.TYPE) {\n-                    memoryLayout = JAVA_BYTE;\n-                } else if (nameTypeAndMode.type == Boolean.TYPE) {\n-                    memoryLayout = JAVA_BOOLEAN;\n-                } else {\n-                    TypeSchemaNode o = types.stream()\n-                            .filter(p -> p.nameTypeAndMode.type.equals(nameTypeAndMode.type)).findFirst().get();\n-                    LayoutToBoundFieldTreeNode scope = layoutToFieldBindingNode.createChild();\n-                    o.fields.stream()\n-                            .forEach(fieldSchemaNode -> {\n-                                fieldSchemaNode.collectLayouts(scope);\n-                            });\n-                    if (isUnion(o.nameTypeAndMode.type)) {\n-                        memoryLayout = MemoryLayout.unionLayout(scope.array());\n-                    } else if (isStructOrBuffer(o.nameTypeAndMode.type)) {\n-                        memoryLayout = MemoryLayout.structLayout(scope.array());\n-                    } else {\n-                        throw new IllegalStateException(\"Recursing through layout collections and came across  \" + o.nameTypeAndMode.type);\n-                    }\n-                }\n-                return memoryLayout;\n-            }\n-\n-\n-            public TypeSchemaNode struct(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addType(new Struct(this, NameTypeAndMode.of(nameTypeAndMode.type, name))));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode union(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                parentSchemaNodeConsumer.accept(addType(new Union(this, NameTypeAndMode.of(nameTypeAndMode.type, name))));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode field(String name) {\n-                addField(new Field(this, NameTypeAndMode.of(nameTypeAndMode.type, name)));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode atomic(String name) {\n-                addField(new AtomicField(this, NameTypeAndMode.of(nameTypeAndMode.type, name)));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode pad(int len) {\n-                addField(new Padding(this, len));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode field(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                NameTypeAndMode newAccessStyle = NameTypeAndMode.of(nameTypeAndMode.type, name);\n-                addField(new Field(this, newAccessStyle));\n-                TypeSchemaNode field = isStruct(newAccessStyle.type)?new SchemaNode.Struct(this, newAccessStyle):new SchemaNode.Union(this, newAccessStyle);\n-                parentSchemaNodeConsumer.accept(addType(field));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode fields(String name1, String name2, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n-                NameTypeAndMode newAccessStyle1 = NameTypeAndMode.of(nameTypeAndMode.type, name1);\n-                NameTypeAndMode newAccessStyle2 = NameTypeAndMode.of(nameTypeAndMode.type, name2);\n-                addField(new Field(this, newAccessStyle1));\n-                addField(new Field(this, newAccessStyle2));\n-                TypeSchemaNode typeSchemaNode=isStruct(newAccessStyle1.type)\n-                        ? new SchemaNode.Struct(this, newAccessStyle1)\n-                        :new SchemaNode.Union(this, newAccessStyle2);\n-                parentSchemaNodeConsumer.accept(addType(typeSchemaNode));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode fields(String... names) {\n-                for (var name : names) {\n-                    field(name);\n-                }\n-                return this;\n-            }\n-\n-            public TypeSchemaNode array(String name, int len) {\n-                addField(new FixedArray(this, name, NameTypeAndMode.of(nameTypeAndMode.type, name), len));\n-                return this;\n-            }\n-\n-            public TypeSchemaNode array(String name, int len, Consumer<TypeSchemaNode> parentFieldConsumer) {\n-                NameTypeAndMode newAccessStyle = NameTypeAndMode.of(nameTypeAndMode.type, name);\n-                TypeSchemaNode typeSchemaNode = isStruct(nameTypeAndMode.type)\n-                                ?new SchemaNode.Struct(this, newAccessStyle)\n-                                :new SchemaNode.Union(this, newAccessStyle);\n-                parentFieldConsumer.accept(typeSchemaNode);\n-                addType(typeSchemaNode);\n-                addField(new FixedArray(this, name, NameTypeAndMode.of(nameTypeAndMode.type, name), len));\n-                return this;\n-            }\n-\n-            private TypeSchemaNode fieldControlledArray(String name, ArrayLen arrayLen) {\n-                addField(new FieldControlledArray(this, name, NameTypeAndMode.of(nameTypeAndMode.type, name), arrayLen));\n-                return this;\n-            }\n-\n-            public static class ArrayBuildState {\n-                TypeSchemaNode typeSchemaNode;\n-                ArrayLen arrayLenField;\n-\n-                public TypeSchemaNode array(String name) {\n-                    return typeSchemaNode.fieldControlledArray(name, arrayLenField);\n-                }\n-\n-                public TypeSchemaNode array(String name, Consumer<TypeSchemaNode> parentFieldConsumer) {\n-                    NameTypeAndMode newAccessStyle = NameTypeAndMode.of(typeSchemaNode.nameTypeAndMode.type, name);\n-                    this.typeSchemaNode.fieldControlledArray(name, arrayLenField);\n-                    TypeSchemaNode typeSchemaNode =isStruct(newAccessStyle.type)\n-                            ?new SchemaNode.Struct(this.typeSchemaNode, newAccessStyle)\n-                            :new SchemaNode.Union(this.typeSchemaNode, newAccessStyle);\n-                    parentFieldConsumer.accept(typeSchemaNode);\n-                    this.typeSchemaNode.addType(typeSchemaNode);\n-                    return this.typeSchemaNode;\n-                }\n-\n-                ArrayBuildState(TypeSchemaNode typeSchemaNode, ArrayLen arrayLenField) {\n-                    this.typeSchemaNode = typeSchemaNode;\n-                    this.arrayLenField = arrayLenField;\n-                }\n-            }\n-\n-            public ArrayBuildState arrayLen(String arrayLenFieldName) {\n-                var arrayLenField = new ArrayLen(this, NameTypeAndMode.of(nameTypeAndMode.type, arrayLenFieldName));\n-                addField(arrayLenField);\n-                return new ArrayBuildState(this, arrayLenField);\n-            }\n-\n-            public void flexArray(String name) {\n-                addField(new FlexArray(this, name, null));\n-            }\n-\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent);\n-                if (isUnion(nameTypeAndMode.type)) {\n-                    stringConsumer.accept(\"union\");\n-                } else if (isStructOrBuffer(nameTypeAndMode.type)) {\n-                    stringConsumer.accept(\"struct\");\n-                } else {\n-                    throw new IllegalStateException(\"Oh my \");\n-                }\n-                stringConsumer.accept(\" \" + nameTypeAndMode + \"{\");\n-                stringConsumer.accept(\"\\n\");\n-                types.forEach(c -> {\n-                    c.toText(indent + \" TYPE: \", stringConsumer);\n-                    stringConsumer.accept(\"\\n\");\n-                });\n-                fields.forEach(c -> {\n-                    c.toText(indent + \" FIELD: \", stringConsumer);\n-                    stringConsumer.accept(\"\\n\");\n-                });\n-\n-                stringConsumer.accept(indent);\n-                stringConsumer.accept(\"}\");\n-            }\n-        }\n-\n-        public static final class Struct extends TypeSchemaNode {\n-            Struct(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n-                super(parent, nameTypeAndMode);\n-            }\n-        }\n-\n-        public static final class Union extends TypeSchemaNode {\n-            Union(TypeSchemaNode parent, NameTypeAndMode nameTypeAndMode) {\n-                super(parent, nameTypeAndMode);\n-            }\n-        }\n-\n-        public abstract static sealed class Array extends FieldSchemaNode permits FieldControlledArray, FixedArray, FlexArray {\n-            String name;\n-            NameTypeAndMode elementAccessStyle;\n-            Array(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle) {\n-                super(parent);\n-                this.name = name;\n-                this.elementAccessStyle = elementAccessStyle;\n-            }\n-        }\n-\n-        public static final class FixedArray extends Array {\n-            int len;\n-\n-            FixedArray(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle, int len) {\n-                super(parent, name, elementAccessStyle);\n-                this.len = len;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n-            }\n-\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(len,\n-                        parent.getLayout(elementAccessStyle, layoutToFieldBindingNode).withName(elementAccessStyle.type.getSimpleName())\n-                ).withName(elementAccessStyle.name));\n-            }\n-        }\n-\n-        public static final  class FlexArray extends Array {\n-            FlexArray(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle) {\n-                super(parent, name, elementAccessStyle);\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"array [?] \");\n-            }\n-\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this,\n-                        MemoryLayout.sequenceLayout(0,\n-                                parent.getLayout(elementAccessStyle, layoutToFieldBindingNode).withName(elementAccessStyle.type.getSimpleName())\n-                        ).withName(elementAccessStyle.name));\n-            }\n-        }\n-\n-        public static final class FieldControlledArray extends Array {\n-            ArrayLen arrayLen;\n-\n-            FieldControlledArray(TypeSchemaNode parent, String name, NameTypeAndMode elementAccessStyle, ArrayLen arrayLen) {\n-                super(parent, name, elementAccessStyle);\n-                this.arrayLen = arrayLen;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + elementAccessStyle.name + \"[\" + elementAccessStyle + \"] where len defined by \" + arrayLen.nameTypeAndMode);\n-            }\n-\n-            @Override\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(\n-                        layoutToFieldBindingNode.takeArrayLen(),\n-                        parent.getLayout(elementAccessStyle, layoutToFieldBindingNode).withName(elementAccessStyle.type.getSimpleName())\n-                ).withName(elementAccessStyle.name));\n-            }\n-        }\n-    }\n-\n-    Schema(Class<T> iface, SchemaNode.TypeSchemaNode schemaRootField) {\n-        this.iface = iface;\n-        this.schemaRootField = schemaRootField;\n-    }\n-\n-    public final static BufferAllocator GlobalArenaAllocator = new BufferAllocator() {\n-        public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n-            return s.allocate(Arena.global());\n-        }\n-    };\n-    public BoundSchema<T> boundSchema(int... boundLengths) {\n-        return new BoundSchema<>(this, boundLengths);\n-    }\n-\n-    public T allocate(BufferAllocator bufferAllocator,int... boundLengths) {\n-        return boundSchema(boundLengths).allocate(bufferAllocator);\n-    }\n-    public T allocate(int... boundLengths) {\n-        return allocate(GlobalArenaAllocator,boundLengths);\n-    }\n-\n-    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<SchemaNode.TypeSchemaNode> parentFieldConsumer) {\n-        NameTypeAndMode nameTypeAndMode = NameTypeAndMode.of(iface, iface.getSimpleName());\n-        var struct = new SchemaNode.Struct(null, nameTypeAndMode);\n-        parentFieldConsumer.accept(struct);\n-        return new Schema<>(iface, struct);\n-    }\n-    public void toText(Consumer<String> stringConsumer) {\n-        schemaRootField.toText(\"\", stringConsumer);\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/Schema.java","additions":0,"deletions":682,"binary":false,"changes":682,"status":"deleted"},{"patch":"@@ -0,0 +1,680 @@\n+package hat.ifacemapper;\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+import hat.util.Result;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+public class Schema<T extends Buffer> {\n+    SchemaNode.TypeSchemaNode schemaRootField;\n+    public Class<T> iface;\n+\n+    static abstract sealed class LayoutToBoundFieldTreeNode permits ChildLayoutToBoundFieldTreeNode, BoundSchema {\n+        static class FieldToLayoutBinding<T extends SchemaNode> {\n+            final T field;\n+            MemoryLayout layout;\n+            FieldToLayoutBinding(T field, MemoryLayout layout) {\n+                this.field = field;\n+                this.layout = layout;\n+            }\n+        }\n+\n+        static class FieldControlledArrayBinding extends FieldToLayoutBinding<SchemaNode.FieldControlledArray> {\n+            final int idx;\n+            final int len;\n+\n+            FieldControlledArrayBinding(int idx, int len, SchemaNode.FieldControlledArray fieldControlledArray) {\n+                super(fieldControlledArray, null);\n+                this.idx = idx;\n+                this.len = len;\n+            }\n+        }\n+\n+        final protected LayoutToBoundFieldTreeNode parent;\n+        final List<ChildLayoutToBoundFieldTreeNode> children = new ArrayList<>();\n+        final List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+        final List<FieldToLayoutBinding<?>> fieldToLayoutBindings = new ArrayList<>();\n+\n+        LayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n+            this.parent = parent;\n+        }\n+\n+        abstract int takeArrayLen();\n+\n+        abstract FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout);\n+\n+        void bind(SchemaNode field, MemoryLayout memoryLayout) {\n+            FieldToLayoutBinding<?> fieldToLayoutBinding = null;\n+            if (field instanceof SchemaNode.FieldControlledArray fieldControlledArray) {\n+                fieldToLayoutBinding = createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n+            } else {\n+                fieldToLayoutBinding = new FieldToLayoutBinding(field, memoryLayout);\n+            }\n+            fieldToLayoutBindings.add(fieldToLayoutBinding);\n+            memoryLayouts.add(memoryLayout);\n+        }\n+\n+        public MemoryLayout[] array() {\n+            return memoryLayouts.toArray(new MemoryLayout[0]);\n+        }\n+\n+        public ChildLayoutToBoundFieldTreeNode createChild() {\n+            var childLayoutCollector = new ChildLayoutToBoundFieldTreeNode(this);\n+            children.add(childLayoutCollector);\n+            return childLayoutCollector;\n+        }\n+    }\n+\n+    public static final class BoundSchema<T extends Buffer> extends LayoutToBoundFieldTreeNode {\n+        final private List<FieldControlledArrayBinding> arraySizeBindings;\n+        final private int[] arrayLengths;\n+        final Schema<T> schema;\n+        final public GroupLayout groupLayout;\n+        public BoundSchema(Schema<T> schema, int ...arrayLengths) {\n+            super(null);\n+            this.schema = schema;\n+            this.arrayLengths = arrayLengths;\n+            this.arraySizeBindings = new ArrayList<>();\n+            LayoutToBoundFieldTreeNode scope = createChild();\n+            schema.schemaRootField.fields.forEach(c -> c.collectLayouts(scope));\n+            MemoryLayout memoryLayout = isUnion(schema.schemaRootField.type)\n+                    ?MemoryLayout.unionLayout(scope.array())\n+                    :MemoryLayout.structLayout(scope.array());\n+            bind(schema.schemaRootField, memoryLayout.withName(schema.iface.getSimpleName()));\n+            this.groupLayout = (GroupLayout) memoryLayouts.getFirst();\n+        }\n+\n+        public T allocate(BufferAllocator bufferAllocator) {\n+            return bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), schema.iface, groupLayout));\n+        }\n+\n+        @Override\n+        int takeArrayLen() {\n+            return arrayLengths[arraySizeBindings.size()];\n+        }\n+\n+        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n+            int idx = arraySizeBindings.size();\n+            var arraySizeBinding = new FieldControlledArrayBinding(idx, arrayLengths[idx], fieldControlledArray);\n+            arraySizeBindings.add(arraySizeBinding);\n+            return arraySizeBinding;\n+        }\n+    }\n+\n+    public static final class ChildLayoutToBoundFieldTreeNode extends LayoutToBoundFieldTreeNode {\n+        ChildLayoutToBoundFieldTreeNode(LayoutToBoundFieldTreeNode parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        int takeArrayLen() {\n+            return parent.takeArrayLen();\n+        }\n+\n+        FieldControlledArrayBinding createFieldControlledArrayBinding(SchemaNode.FieldControlledArray fieldControlledArray, MemoryLayout memoryLayout) {\n+            return parent.createFieldControlledArrayBinding(fieldControlledArray, memoryLayout);\n+        }\n+    }\n+    enum Mode {\n+        PRIMITIVE_GETTER_AND_SETTER,\n+        PRIMITIVE_GETTER,\n+        PRIMITIVE_SETTER,\n+        IFACE_GETTER,\n+        PRIMITIVE_ARRAY_SETTER,\n+        PRIMITIVE_ARRAY_GETTER,\n+        PRIMITIVE_ARRAY_GETTER_AND_SETTER,\n+        IFACE_ARRAY_GETTER;\n+\n+        \/**\n+         * From the iface mapper we get these mappings\n+         * <p>\n+         * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n+         * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n+         * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n+         * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n+         *\n+         * @param m The reflected method\n+         * @return Class represeting the type this method is mapped to\n+         *\/\n+        static Mode of(Method m) {\n+            Class<?> returnType = m.getReturnType();\n+            Class<?>[] paramTypes = m.getParameterTypes();\n+            if (paramTypes.length == 0 && returnType.isInterface()) {\n+                return IFACE_GETTER;\n+            } else if (paramTypes.length == 0 && returnType.isPrimitive()) {\n+                return PRIMITIVE_GETTER;\n+            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                return PRIMITIVE_SETTER;\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n+                return IFACE_ARRAY_GETTER;\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n+                return PRIMITIVE_ARRAY_GETTER;\n+            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n+                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n+                return PRIMITIVE_ARRAY_SETTER;\n+            } else {\n+                throw new IllegalStateException(\"no possible mode for \"+m);\n+            }\n+        }\n+    }\n+\n+    static Mode modeOf(Class<?> iface, String name) {\n+        var methods = iface.getDeclaredMethods();\n+        Result<Mode> modeResult = new Result<>();\n+        Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n+            var thisMode = Mode.of(matchingMethod);\n+            if (!modeResult.isPresent()){\n+                modeResult.of(thisMode);\n+            } else if (( modeResult.get().equals(Mode.PRIMITIVE_ARRAY_GETTER) && thisMode.equals(Mode.PRIMITIVE_ARRAY_SETTER))\n+                    || ( modeResult.get().equals(Mode.PRIMITIVE_ARRAY_SETTER) && thisMode.equals(Mode.PRIMITIVE_ARRAY_GETTER))) {\n+                modeResult.of(Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER);\n+            } else if (( modeResult.get().equals(Mode.PRIMITIVE_GETTER) && thisMode.equals(Mode.PRIMITIVE_SETTER))\n+                    || ( modeResult.get().equals(Mode.PRIMITIVE_SETTER) && thisMode.equals(Mode.PRIMITIVE_GETTER))) {\n+                modeResult.of(Mode.PRIMITIVE_GETTER_AND_SETTER);\n+            }\n+        });\n+        if ( !modeResult.isPresent() ) {\n+            throw new IllegalStateException(\"no possible mode for \"+iface+\" \"+name);\n+           \/\/ modeResult.of(Mode.PRIMITIVE_GETTER_AND_SETTER);\n+        }\n+        return modeResult.get();\n+    }\n+    \/**\n+     * From the iface mapper\n+     * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n+     * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n+     * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n+     * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n+     *\n+     * @param iface The reflected method\n+     * @return Class represeting the type this method is mapped to\n+     *\/\n+    static Class<?> typeOf(Class<?> iface, String name) {\n+        var methods = iface.getDeclaredMethods();\n+        Result<Class<?>> typeResult = new Result<>();\n+        Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n+            Class<?> returnType = matchingMethod.getReturnType();\n+            Class<?>[] paramTypes = matchingMethod.getParameterTypes();\n+            Class<?> thisType = null;\n+            if (paramTypes.length == 0 && (returnType.isInterface() || returnType.isPrimitive())) {\n+                thisType= returnType;\n+            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                thisType=  paramTypes[0];\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && (returnType.isInterface() || returnType.isPrimitive())) {\n+                thisType=  returnType;\n+            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n+                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n+                thisType=  paramTypes[1];\n+            } else {\n+                throw new IllegalStateException(\"Can't determine iface mapping type for \"+matchingMethod);\n+            }\n+            if (!typeResult.isPresent() || typeResult.get().equals(thisType)) {\n+                typeResult.of(thisType);\n+            } else  {\n+                throw new IllegalStateException(\"type mismatch for \" + name);\n+            }\n+        });\n+        if (!typeResult.isPresent()) {\n+            throw new IllegalStateException(\"No type mapping for \"+iface+\" \"+name);\n+\n+        }\n+        return typeResult.get();\n+    }\n+\n+    static boolean isBuffer(Class<?> clazz) {\n+        return clazz.isInterface() && Buffer.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isStruct(Class<?> clazz) {\n+        return clazz.isInterface() && Buffer.StructChild.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isStructOrBuffer(Class<?> clazz) {\n+        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.StructChild.class.isAssignableFrom(clazz));\n+    }\n+\n+    static boolean isUnion(Class<?> clazz) {\n+        return clazz.isInterface() && Buffer.UnionChild.class.isAssignableFrom(clazz);\n+    }\n+\n+    public static abstract class SchemaNode {\n+        TypeSchemaNode parent;\n+        SchemaNode(TypeSchemaNode parent) {\n+            this.parent = parent;\n+        }\n+        public abstract void toText(String indent, Consumer<String> stringConsumer);\n+\n+        public static abstract sealed class FieldSchemaNode extends SchemaNode permits NamedFieldSchemaNode, Padding {\n+            FieldSchemaNode(TypeSchemaNode parent) {\n+                super(parent);\n+            }\n+            public abstract void toText(String indent, Consumer<String> stringConsumer);\n+            abstract void collectLayouts(LayoutToBoundFieldTreeNode layoutCollector);\n+        }\n+        public static final class Padding extends FieldSchemaNode {\n+            int len;\n+            Padding(TypeSchemaNode parent, int len) {\n+                super(parent);\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"padding \" + len + \" bytes\");\n+            }\n+\n+            @Override\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.paddingLayout(len));\n+            }\n+        }\n+\n+        public static abstract sealed class NamedFieldSchemaNode extends FieldSchemaNode permits Array, ArrayLen, AtomicField, Field {\n+            Mode mode;\n+            Class<?> type;\n+            final String name;\n+            NamedFieldSchemaNode(TypeSchemaNode parent, Mode mode, Class<?> type, String name) {\n+                super(parent);\n+                this.mode = mode;\n+                 this.type = type;\n+                this.name = name;\n+            }\n+        }\n+\n+\n+        public static final class ArrayLen extends NamedFieldSchemaNode {\n+            ArrayLen(TypeSchemaNode parent, Mode mode, Class<?> type,  String name) {\n+                super(parent,mode,type, name);\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"arrayLen \" + mode+\":\"+type);\n+            }\n+\n+            @Override\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(type, layoutToFieldBindingNode).withName(name));\n+            }\n+        }\n+\n+        public static final class AtomicField extends NamedFieldSchemaNode {\n+\n+\n+            AtomicField(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n+                super(parent, mode, type,name);\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"atomic \" + mode+\":\"+type);\n+            }\n+\n+            @Override\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(type, layoutToFieldBindingNode).withName(name));\n+            }\n+        }\n+\n+        public static final class Field extends NamedFieldSchemaNode {\n+\n+\n+            Field(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n+                super(parent, mode, type,name);\n+\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"field \" + mode+\":\"+type);\n+            }\n+\n+            @Override\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, parent.getLayout(type, layoutToFieldBindingNode).withName(name));\n+            }\n+        }\n+\n+        public static abstract sealed class TypeSchemaNode extends SchemaNode permits Union,Struct {\n+            private List<FieldSchemaNode> fields = new ArrayList<>();\n+            private List<TypeSchemaNode> types = new ArrayList<>();\n+            Class<?> type;\n+\n+            <T extends FieldSchemaNode> T addField(T child) {\n+                fields.add(child);\n+                return child;\n+            }\n+            <T extends TypeSchemaNode> T addType(T child) {\n+                types.add(child);\n+                return child;\n+            }\n+\n+            TypeSchemaNode(TypeSchemaNode parent,  Class<?> type) {\n+                super(parent);\n+                this.type = type;\n+            }\n+            \/**\n+             * Get a layout which describes the NameTypeAndMode.\n+             * <p>\n+             * If NameTypeAndMode holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n+             * Otherwise we look through the parent's children.  Which should include a type node struct\/union matching the type.\n+             *\n+             * @param type\n+             * @param layoutToFieldBindingNode\n+             * @return\n+             *\/\n+             MemoryLayout getLayout(Class<?> type, LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                MemoryLayout memoryLayout = null;\n+                if (type == Integer.TYPE) {\n+                    memoryLayout = JAVA_INT;\n+                } else if (type == Float.TYPE) {\n+                    memoryLayout = JAVA_FLOAT;\n+                } else if (type == Long.TYPE) {\n+                    memoryLayout = JAVA_LONG;\n+                } else if (type == Double.TYPE) {\n+                    memoryLayout = JAVA_DOUBLE;\n+                } else if (type == Short.TYPE) {\n+                    memoryLayout = JAVA_SHORT;\n+                } else if (type == Character.TYPE) {\n+                    memoryLayout = JAVA_CHAR;\n+                } else if (type == Byte.TYPE) {\n+                    memoryLayout = JAVA_BYTE;\n+                } else if (type == Boolean.TYPE) {\n+                    memoryLayout = JAVA_BOOLEAN;\n+                } else {\n+                    TypeSchemaNode typeSchemaModeMatchingType = types.stream()\n+                            .filter(typeSchemaNode -> typeSchemaNode.type.equals(type)).findFirst().get();\n+                    LayoutToBoundFieldTreeNode scope = layoutToFieldBindingNode.createChild();\n+                    typeSchemaModeMatchingType.fields.stream()\n+                            .forEach(fieldSchemaNode ->\n+                                fieldSchemaNode.collectLayouts(scope)\n+                            );\n+                    if (isUnion(typeSchemaModeMatchingType.type)) {\n+                        memoryLayout = MemoryLayout.unionLayout(scope.array());\n+                    } else if (isStructOrBuffer(typeSchemaModeMatchingType.type)) {\n+                        memoryLayout = MemoryLayout.structLayout(scope.array());\n+                    } else {\n+                        throw new IllegalStateException(\"Recursing through layout collections and came across  \" + typeSchemaModeMatchingType.type);\n+                    }\n+                }\n+                return memoryLayout;\n+            }\n+\n+\n+            public TypeSchemaNode struct(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addType(new Struct(this,  typeOf(type,name))));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode union(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                parentSchemaNodeConsumer.accept(addType(new Union(this, typeOf(type,name))));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode field(String name) {\n+                addField(new Field(this, modeOf(type, name), typeOf(type, name), name));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode atomic(String name) {\n+                addField(new AtomicField(this, modeOf(type, name), typeOf(type, name), name));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode pad(int len) {\n+                addField(new Padding(this, len));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode field(String name, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                 Mode fieldMode = modeOf(type, name);\n+                 Class<?> fieldType = typeOf(type, name);\n+                addField(new Field(this,fieldMode, fieldType, name));\n+                TypeSchemaNode field = isStruct(fieldType)?new SchemaNode.Struct(this, fieldType):new SchemaNode.Union(this, fieldType);\n+                parentSchemaNodeConsumer.accept(addType(field));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode fields(String name1, String name2, Consumer<TypeSchemaNode> parentSchemaNodeConsumer) {\n+                Mode fieldMode1 = modeOf(type, name1);\n+                Mode fieldMode2 = modeOf(type, name2);\n+                if (!fieldMode1.equals(fieldMode2)){\n+                    throw new IllegalStateException(\"fields \"+name1+\" and \"+name2+\" have different modes\");\n+                }\n+                Class<?> structOrUnionType = typeOf(type, name1);\n+                Class<?> fieldTypeCheck = typeOf(type, name2);\n+                if (!structOrUnionType.equals(fieldTypeCheck)){\n+                    throw new IllegalStateException(\"fields \"+name1+\" and \"+name2+\" have different types\");\n+                }\n+                addField(new Field(this,fieldMode1, structOrUnionType, name1));\n+                addField(new Field(this,fieldMode2,  structOrUnionType, name2));\n+                TypeSchemaNode typeSchemaNode=isStruct(type)\n+                        ? new SchemaNode.Struct(this,  structOrUnionType)\n+                        :new SchemaNode.Union(this,  structOrUnionType);\n+                parentSchemaNodeConsumer.accept(addType(typeSchemaNode));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode fields(String... names) {\n+                for (var name : names) {\n+                    field(name);\n+                }\n+                return this;\n+            }\n+\n+            public TypeSchemaNode array(String name, int len) {\n+                addField(new FixedArray(this, modeOf(type,name), typeOf(type, name),name, len));\n+                return this;\n+            }\n+\n+            public TypeSchemaNode array(String name, int len, Consumer<TypeSchemaNode> parentFieldConsumer) {\n+                Mode arrayMode = modeOf(type, name);\n+                Class<?> structOrUnionType = typeOf(type, name);\n+               \/\/ ModeAndType newAccessStyle = ModeAndType.of(type, name);\n+                TypeSchemaNode typeSchemaNode = isStruct(type)\n+                                ?new SchemaNode.Struct(this, structOrUnionType)\n+                                :new SchemaNode.Union(this, structOrUnionType);\n+                parentFieldConsumer.accept(typeSchemaNode);\n+                addType(typeSchemaNode);\n+                addField(new FixedArray(this, arrayMode,structOrUnionType, name, len));\n+                return this;\n+            }\n+\n+            private TypeSchemaNode fieldControlledArray(String name, ArrayLen arrayLen) {\n+                addField(new FieldControlledArray(this,  modeOf(type, name), typeOf(type, name),name, arrayLen));\n+                return this;\n+            }\n+\n+            public static class ArrayBuildState {\n+                TypeSchemaNode typeSchemaNode;\n+                ArrayLen arrayLenField;\n+\n+                public TypeSchemaNode array(String name) {\n+                    return typeSchemaNode.fieldControlledArray(name, arrayLenField);\n+                }\n+\n+                public TypeSchemaNode array(String name, Consumer<TypeSchemaNode> parentFieldConsumer) {\n+                    Class<?> arrayType = typeOf(typeSchemaNode.type, name);\n+                    this.typeSchemaNode.fieldControlledArray(name, arrayLenField);\n+                    TypeSchemaNode typeSchemaNode =isStruct(arrayType)\n+                            ?new SchemaNode.Struct(this.typeSchemaNode, arrayType)\n+                            :new SchemaNode.Union(this.typeSchemaNode,arrayType);\n+                    parentFieldConsumer.accept(typeSchemaNode);\n+                    this.typeSchemaNode.addType(typeSchemaNode);\n+                    return this.typeSchemaNode;\n+                }\n+\n+                ArrayBuildState(TypeSchemaNode typeSchemaNode, ArrayLen arrayLenField) {\n+                    this.typeSchemaNode = typeSchemaNode;\n+                    this.arrayLenField = arrayLenField;\n+                }\n+            }\n+\n+            public ArrayBuildState arrayLen(String arrayLenFieldName) {\n+                var arrayLenField = new ArrayLen(this, modeOf(type, arrayLenFieldName), typeOf(type, arrayLenFieldName),arrayLenFieldName );\n+                addField(arrayLenField);\n+                return new ArrayBuildState(this, arrayLenField);\n+            }\n+\n+            public void flexArray(String name) {\n+                 throw new IllegalStateException(\"flex array\");\n+              \/\/  addField(new FlexArray(this,null, name));\n+            }\n+\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent);\n+                if (isUnion(type)) {\n+                    stringConsumer.accept(\"union\");\n+                } else if (isStructOrBuffer(type)) {\n+                    stringConsumer.accept(\"struct\");\n+                } else {\n+                    throw new IllegalStateException(\"Oh my \");\n+                }\n+                stringConsumer.accept(\" \" + type + \"{\");\n+                stringConsumer.accept(\"\\n\");\n+                types.forEach(c -> {\n+                    c.toText(indent + \" TYPE: \", stringConsumer);\n+                    stringConsumer.accept(\"\\n\");\n+                });\n+                fields.forEach(c -> {\n+                    c.toText(indent + \" FIELD: \", stringConsumer);\n+                    stringConsumer.accept(\"\\n\");\n+                });\n+\n+                stringConsumer.accept(indent);\n+                stringConsumer.accept(\"}\");\n+            }\n+        }\n+\n+        public static final class Struct extends TypeSchemaNode {\n+            Struct(TypeSchemaNode parent,  Class<?> type) {\n+                super(parent, type);\n+            }\n+        }\n+\n+        public static final class Union extends TypeSchemaNode {\n+            Union(TypeSchemaNode parent,  Class<?> type) {\n+                super(parent,  type);\n+            }\n+        }\n+\n+        public abstract static sealed class Array extends NamedFieldSchemaNode permits FieldControlledArray, FixedArray, FlexArray {\n+          \/\/  ModeAndType elementAccessStyle;\n+            Array(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n+                super(parent, mode,type, name);\n+            \/\/\/    this.elementAccessStyle = elementAccessStyle;\n+            }\n+        }\n+\n+        public static final class FixedArray extends Array {\n+            int len;\n+\n+            FixedArray(TypeSchemaNode parent,Mode mode, Class<?> type, String name, int len) {\n+                super(parent,  mode, type, name);\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n+            }\n+\n+            @Override\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(len,\n+                        parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+                ).withName(name));\n+            }\n+        }\n+\n+        public static final  class FlexArray extends Array {\n+            FlexArray(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n+                super(parent,  mode,type, name);\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"array [?] \");\n+            }\n+\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this,\n+                        MemoryLayout.sequenceLayout(0,\n+                                parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+                        ).withName(name));\n+            }\n+        }\n+\n+        public static final class FieldControlledArray extends Array {\n+            ArrayLen arrayLen;\n+\n+            FieldControlledArray(TypeSchemaNode parent,   Mode mode, Class<?> type,String name, ArrayLen arrayLen) {\n+                super(parent, mode, type, name);\n+                this.arrayLen = arrayLen;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + name + \"[\" + mode+\":\"+type + \"] where len defined by \" + arrayLen.type);\n+            }\n+\n+            @Override\n+            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(\n+                        layoutToFieldBindingNode.takeArrayLen(),\n+                        parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n+                ).withName(name));\n+            }\n+        }\n+    }\n+\n+    Schema(Class<T> iface, SchemaNode.TypeSchemaNode schemaRootField) {\n+        this.iface = iface;\n+        this.schemaRootField = schemaRootField;\n+    }\n+\n+    public final static BufferAllocator GlobalArenaAllocator = new BufferAllocator() {\n+        public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n+            return s.allocate(Arena.global());\n+        }\n+    };\n+    public BoundSchema<T> boundSchema(int... boundLengths) {\n+        return new BoundSchema<>(this, boundLengths);\n+    }\n+\n+    public T allocate(BufferAllocator bufferAllocator,int... boundLengths) {\n+        return boundSchema(boundLengths).allocate(bufferAllocator);\n+    }\n+    public T allocate(int... boundLengths) {\n+        return allocate(GlobalArenaAllocator,boundLengths);\n+    }\n+\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<SchemaNode.TypeSchemaNode> parentFieldConsumer) {\n+        var struct = new SchemaNode.Struct(null, iface);\n+        parentFieldConsumer.accept(struct);\n+        return new Schema<>(iface, struct);\n+    }\n+    public void toText(Consumer<String> stringConsumer) {\n+        schemaRootField.toText(\"\", stringConsumer);\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":680,"deletions":0,"binary":false,"changes":680,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.Schema;\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}