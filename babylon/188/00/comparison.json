{"files":[{"patch":"@@ -49,62 +49,2 @@\n-    Ptx *ptx = nullptr;\n-    uint64_t time = timeSinceEpochMillisec();\n-    std::stringstream timestampPtx;\n-    timestampPtx << \".\/tmp\" << time << \".ptx\";\n-    const char *ptxPath = strdup(timestampPtx.str().c_str());\n-   \/\/ std::cout << \"ptx \" << ptxPath << std::endl;\n-    \/\/ we are going to fork exec nvcc\n-    int pid;\n-    if ((pid = fork()) == 0) {\n-        std::ofstream ptx;\n-        std::stringstream timestampPtx;\n-        timestampPtx << \".\/tmp\" << time << \".cu\";\n-        const char *ptxPath = strdup(timestampPtx.str().c_str());\n-        std::cout << \"ptx \" << ptxPath << std::endl;\n-        ptx.open(ptxPath, std::ofstream::trunc);\n-        ptx.write(ptxSource, len);\n-        ptx.close();\n-        const char *path = \"\/usr\/bin\/nvcc\";\n-        \/\/const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n-        const char *argv[]{\"nvcc\", \"-ptx\", ptxPath, \"-o\", ptxPath, nullptr};\n-        \/\/ we can't free ptxPath or ptxpath in child because we need them in exec, no prob through\n-        \/\/ because we get a new proc so they are released to os\n-        execvp(path, (char *const *) argv);\n-\n-    } else if (pid < 0) {\n-        \/\/ fork failed.\n-        std::cerr << \"fork of nvcc failed\" << std::endl;\n-        std::exit(1);\n-    } else {\n-        int status;\n-     \/\/   std::cerr << \"fork suceeded waiting for child\" << std::endl;\n-        pid_t result = wait(&status);\n-        std::cerr << \"child finished\" << std::endl;\n-        std::ifstream ptxStream;\n-        ptxStream.open(ptxPath);\n-      \/\/  if (ptxStream.is_open()) {\n-            ptxStream.seekg(0, std::ios::end);\n-            size_t ptxLen = ptxStream.tellg();\n-            ptxStream.close();\n-            ptxStream.open(ptxPath);\n-            free((void *) ptxPath);\n-            ptxPath = nullptr;\n-            if (ptxLen > 0) {\n-                std::cerr << \"ptx len \"<< ptxLen << std::endl;\n-                ptx = new Ptx(ptxLen + 1);\n-                std::cerr << \"about to read  \"<< ptx->len << std::endl;\n-                ptxStream.read(ptx->text, ptx->len);\n-                ptxStream.close();\n-                std::cerr << \"about to read  \"<< ptx->len << std::endl;\n-                ptx->text[ptx->len - 1] = '\\0';\n-                std::cerr << \"read text \"<< ptx->text << std::endl;\n-\n-            } else {\n-                std::cerr << \"no ptx! ptxLen == 0?\";\n-                exit(1);\n-            }\n-      \/\/  }else{\n-        \/\/    std::cerr << \"no ptx!\";\n-       \/\/     exit(1);\n-      \/\/  }\n-    }\n-    std::cout << \"returning PTX\" << std::endl;\n+    Ptx * ptx = new Ptx(len);\n+    strcpy(ptx->text,ptxSource);\n@@ -112,0 +52,64 @@\n+\n+\/\/     Ptx *ptx = nullptr;\n+\/\/     uint64_t time = timeSinceEpochMillisec();\n+\/\/     std::stringstream timestampPtx;\n+\/\/     timestampPtx << \".\/tmp\" << time << \".ptx\";\n+\/\/     const char *ptxPath = strdup(timestampPtx.str().c_str());\n+\/\/    \/\/ std::cout << \"ptx \" << ptxPath << std::endl;\n+\/\/     \/\/ we are going to fork exec nvcc\n+\/\/     int pid;\n+\/\/     if ((pid = fork()) == 0) {\n+\/\/         std::ofstream ptx;\n+\/\/         std::stringstream timestampPtx;\n+\/\/         timestampPtx << \".\/tmp\" << time << \".cu\";\n+\/\/         const char *ptxPath = strdup(timestampPtx.str().c_str());\n+\/\/         std::cout << \"ptx \" << ptxPath << std::endl;\n+\/\/         ptx.open(ptxPath, std::ofstream::trunc);\n+\/\/         ptx.write(ptxSource, len);\n+\/\/         ptx.close();\n+\/\/         const char *path = \"\/usr\/bin\/nvcc\";\n+\/\/         \/\/const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n+\/\/         const char *argv[]{\"nvcc\", \"-ptx\", ptxPath, \"-o\", ptxPath, nullptr};\n+\/\/         \/\/ we can't free ptxPath or ptxpath in child because we need them in exec, no prob through\n+\/\/         \/\/ because we get a new proc so they are released to os\n+\/\/         execvp(path, (char *const *) argv);\n+\n+\/\/     } else if (pid < 0) {\n+\/\/         \/\/ fork failed.\n+\/\/         std::cerr << \"fork of nvcc failed\" << std::endl;\n+\/\/         std::exit(1);\n+\/\/     } else {\n+\/\/         int status;\n+\/\/      \/\/   std::cerr << \"fork suceeded waiting for child\" << std::endl;\n+\/\/         pid_t result = wait(&status);\n+\/\/         std::cerr << \"child finished\" << std::endl;\n+\/\/         std::ifstream ptxStream;\n+\/\/         ptxStream.open(ptxPath);\n+\/\/       \/\/  if (ptxStream.is_open()) {\n+\/\/             ptxStream.seekg(0, std::ios::end);\n+\/\/             size_t ptxLen = ptxStream.tellg();\n+\/\/             ptxStream.close();\n+\/\/             ptxStream.open(ptxPath);\n+\/\/             free((void *) ptxPath);\n+\/\/             ptxPath = nullptr;\n+\/\/             if (ptxLen > 0) {\n+\/\/                 std::cerr << \"ptx len \"<< ptxLen << std::endl;\n+\/\/                 ptx = new Ptx(ptxLen + 1);\n+\/\/                 std::cerr << \"about to read  \"<< ptx->len << std::endl;\n+\/\/                 ptxStream.read(ptx->text, ptx->len);\n+\/\/                 ptxStream.close();\n+\/\/                 std::cerr << \"about to read  \"<< ptx->len << std::endl;\n+\/\/                 ptx->text[ptx->len - 1] = '\\0';\n+\/\/                 std::cerr << \"read text \"<< ptx->text << std::endl;\n+\n+\/\/             } else {\n+\/\/                 std::cerr << \"no ptx! ptxLen == 0?\";\n+\/\/                 exit(1);\n+\/\/             }\n+\/\/       \/\/  }else{\n+\/\/         \/\/    std::cerr << \"no ptx!\";\n+\/\/        \/\/     exit(1);\n+\/\/       \/\/  }\n+\/\/     }\n+\/\/     std::cout << \"returning PTX\" << std::endl;\n+\/\/     return ptx;\n@@ -454,0 +458,1 @@\n+        printf(\"status: %d\\n\", status);\n","filename":"hat\/backends\/ptx\/cpp\/ptx_backend.cpp","additions":67,"deletions":62,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.buffer.Buffer;\n@@ -31,0 +32,14 @@\n+import hat.ifacemapper.BoundSchema;\n+import hat.optools.*;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class PTXBackend extends C99NativeBackend {\n+    int major;\n+    int minor;\n+    String target;\n+    int addressSize;\n@@ -32,1 +47,0 @@\n-public class PTXBackend extends NativeBackend {\n@@ -35,0 +49,4 @@\n+        major = 7;\n+        minor = 5;\n+        target = \"sm_52\";\n+        addressSize = 64;\n@@ -61,3 +79,93 @@\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().toText());\n-        System.out.println(\"Add your code to \"+PTXBackend.class.getName()+\".dispatchKernel() to actually run! :)\");\n-        System.exit(1);\n+        String code = createCode(kernelCallGraph, new PTXCodeBuilder(), args);\n+        \/\/ System.out.println(\"\\nCode Builder Output: \\n\\n\" + code);\n+        \/\/ System.out.println(\"Add your code to \"+PTXBackend.class.getName()+\".dispatchKernel() to actually run! :)\");\n+        long programHandle = compileProgram(code);\n+        if (programOK(programHandle)) {\n+            long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n+            CompiledKernel compiledKernel = new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+            compiledKernel.dispatch(ndRange,args);\n+        }\n+    }\n+\n+    public String createCode(KernelCallGraph kernelCallGraph, PTXCodeBuilder builder, Object[] args) {\n+        String out = \"\";\n+        Optional<CoreOp.FuncOp> o = Optional.ofNullable(kernelCallGraph.entrypoint.funcOpWrapper().op());\n+        FuncOpWrapper f = new FuncOpWrapper(o.orElseThrow());\n+        FuncOpWrapper lowered = f.lower();\n+        HashMap<String, Object> argsMap = new HashMap<>();\n+        for (int i = 0; i < args.length; i++) {\n+            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n+        }\n+\n+        \/\/ currently hard coded but ill fix it later\n+        boolean useSchema = true;\n+\n+        \/\/ printing out ptx header (device info)\n+        builder.ptxHeader(major, minor, target, addressSize);\n+        out += builder.getTextAndReset();\n+\n+        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n+            Optional<CoreOp.FuncOp> optional = Optional.ofNullable(k.funcOpWrapper().op());\n+            FuncOpWrapper calledFunc = new FuncOpWrapper(optional.orElseThrow());\n+            FuncOpWrapper loweredFunc = calledFunc.lower();\n+\/\/            System.out.println(\"------------func------------\");\n+\/\/            System.out.println(loweredFunc.ssa().toText());\n+            if (useSchema) loweredFunc = transformPtrs(loweredFunc, argsMap);\n+            out += createFunction(new PTXCodeBuilder(addressSize).nl().nl(), loweredFunc, loweredFunc.ssa(), out, false);\n+        }\n+\n+        if (useSchema) lowered = transformPtrs(lowered, argsMap);\n+        FuncOpWrapper ssa = lowered.ssa();\n+\/\/        System.out.println(lowered.toText());\n+\/\/        System.out.println(ssa.toText());\n+        out += createFunction(builder.nl().nl(), lowered, ssa, out, true);\n+\n+        return out;\n+    }\n+\n+    public FuncOpWrapper transformPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap) {\n+        return FuncOpWrapper.wrap(func.op().transform((block, op) -> {\n+            CopyContext cc = block.context();\n+            \/\/ use first operand of invoke to figure out schema\n+            if (op instanceof CoreOp.InvokeOp invokeOp\n+                    && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                    && invokeOpWrapper.isIfaceBufferMethod()\n+                    && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+                    && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n+                    && varLoadResult.op() instanceof CoreOp.VarOp varOp\n+                    && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = cc.getValues(inputOperands);\n+                Op.Result inputResult = invokeOp.result();\n+                BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n+                PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema.schema());\n+                Op.Result outputResult = block.op(ptxOp);\n+                cc.mapValue(inputResult, outputResult);\n+            } else {\n+                block.apply(op);\n+            }\n+            return block;\n+        }));\n+    }\n+\n+    public String createFunction(PTXCodeBuilder builder, FuncOpWrapper lowered, FuncOpWrapper ssa, String out, boolean entry) {\n+        String body = \"\";\n+\n+        \/\/ building fn info (name, params)\n+        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n+\n+        \/\/ printing out params\n+        builder.parameters(lowered.paramTable().list());\n+\n+        \/\/ building body of fn\n+        builder.functionPrologue();\n+\n+        out = builder.getTextAndReset();\n+        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(OpWrapper::wrap)));\n+\n+        builder.functionEpilogue();\n+        body = builder.getTextAndReset();\n+\n+        builder.ptxRegisterDecl();\n+        out += builder.getText() + body;\n+        return out;\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXBackend.java","additions":112,"deletions":4,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,665 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend;\n+\n+import hat.ifacemapper.Schema;\n+import hat.optools.*;\n+import hat.text.CodeBuilder;\n+import hat.util.StreamCounter;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+public class PTXCodeBuilder extends CodeBuilder<PTXCodeBuilder> {\n+\n+    Map<Value, PTXRegister> varToRegMap;\n+    List<String> params;\n+    Map<String, Block.Parameter> paramMap;\n+    Map<Field, PTXRegister> fieldToRegMap;\n+\n+    HashMap<PTXRegister.Type, Integer> ordinalMap;\n+\n+    PTXRegister returnReg;\n+    private int addressSize;\n+\n+    public enum Field {\n+        NTID_X (\"ntid.x\", false),\n+        CTAID_X (\"ctaid.x\", false),\n+        TID_X (\"tid.x\", false),\n+        KC_X (\"x\", false),\n+        KC_ADDR(\"kc\", true),\n+        KC_MAXX (\"maxX\", false);\n+\n+        private final String name;\n+        private final boolean destination;\n+\n+        Field(String name, boolean destination) {\n+            this.name = name;\n+            this.destination = destination;\n+        }\n+        public String toString() {\n+            return this.name;\n+        }\n+        public boolean isDestination() {return this.destination;}\n+    }\n+\n+    public PTXCodeBuilder(int addressSize) {\n+        varToRegMap = new HashMap<>();\n+        params = new ArrayList<>();\n+        fieldToRegMap = new HashMap<>();\n+        paramMap = new HashMap<>();\n+        ordinalMap = new HashMap<>();\n+        this.addressSize = addressSize;\n+    }\n+\n+    public PTXCodeBuilder() {\n+        this(32);\n+    }\n+\n+    public void ptxHeader(int major, int minor, String target, int addressSize) {\n+        append(\".version \").append(String.valueOf(major)).dot().append(String.valueOf(minor)).nl();\n+        append(\".target \").append(target).nl();\n+        append(\".address_size \").append(String.valueOf(addressSize));\n+        this.addressSize = addressSize;\n+    }\n+\n+    public void functionHeader(String funcName, boolean entry, TypeElement yieldType) {\n+        if (entry) {\n+            append(\".visible .entry \");\n+        } else {\n+            append(\".func \");\n+        }\n+        if (!yieldType.toString().equals(\"void\")) {\n+            returnReg = new PTXRegister(getOrdinal(resultType(yieldType)), resultType(yieldType));\n+            returnReg.name(\"%retReg\");\n+            oparen().param().space().printParamType(yieldType);\n+            space().append(returnReg.name()).cparen().space();\n+        }\n+        append(funcName);\n+    }\n+\n+    public PTXCodeBuilder parameters(List<FuncOpWrapper.ParamTable.Info> infoList) {\n+        paren(_ -> nl().commaNlSeparated(infoList, (info) -> {\n+            ptxIndent().param().space().printParamType(info.javaType);\n+            space().append(info.varOp.varName());\n+            params.add(info.varOp.varName());\n+        }).nl()).nl();\n+        return this;\n+    }\n+\n+    public void blockBody(Block block, Stream<OpWrapper<?>> ops) {\n+        if (block.index() == 0) {\n+            for (Block.Parameter p : block.parameters()) {\n+                ptxIndent().ld().param();\n+                printResultType(p.type(), false).ptxIndent().space();\n+                printAndAddVar(p, resultType(p.type())).commaSpace().osbrace().append(params.get(p.index())).csbrace().semicolon().nl();\n+                paramMap.putIfAbsent(params.get(p.index()), p);\n+            }\n+        }\n+        nl();\n+        printBlock(block);\n+        colon().nl();\n+        ops.forEach(op -> {\n+            if (op instanceof InvokeOpWrapper invoke && !invoke.isIfaceBufferMethod()) {\n+                ptxIndent().obrace().nl().ptxIndent().convert(op).ptxNl();\n+                cbrace().nl();\n+            } else {\n+                ptxIndent().convert(op).semicolon().nl();\n+            }\n+        });\n+    }\n+\n+    public void ptxRegisterDecl() {\n+        for (PTXRegister.Type t : ordinalMap.keySet()) {\n+            ptxIndent().append(\".reg\").space();\n+            if (t.equals(PTXRegister.Type.U32)) {\n+                b32();\n+            } else if (t.equals(PTXRegister.Type.U64)) {\n+                b64();\n+            } else {\n+                dot().append(t.toString());\n+            }\n+            ptxIndent().append(t.getRegPrefix()).lt().append(String.valueOf(ordinalMap.get(t))).gt().semicolon().nl();\n+        }\n+        nl();\n+    }\n+\n+    public void functionPrologue() {\n+        append(\"{\").nl();\n+    }\n+\n+    public void functionEpilogue() {\n+        append(\"}\");\n+    }\n+\n+    public PTXCodeBuilder convert(OpWrapper<?> wrappedOp) {\n+        switch (wrappedOp) {\n+            case VarLoadOpWrapper op -> varLoad(op);\n+            case VarStoreOpWrapper op -> varStore(op);\n+            case FieldLoadOpWrapper op -> fieldLoad(op);\n+            case FieldStoreOpWrapper op -> fieldStore(op);\n+            case BinaryArithmeticOrLogicOperation op -> binaryOperation(op);\n+            case BinaryTestOpWrapper op -> binaryTest(op);\n+            case ConvOpWrapper op -> conv(op);\n+            case ConstantOpWrapper op -> constant(op);\n+            case YieldOpWrapper op -> javaYield(op);\n+            case FuncCallOpWrapper op -> funcCall(op);\n+            case InvokeOpWrapper op -> methodCall(op);\n+            case VarDeclarationOpWrapper op -> varDeclaration(op);\n+            case VarFuncDeclarationOpWrapper op -> varFuncDeclaration(op);\n+            case ReturnOpWrapper op -> ret(op);\n+            case JavaBreakOpWrapper op -> javaBreak(op);\n+            default -> {\n+                switch (wrappedOp.op()){\n+                    case CoreOp.BranchOp op -> branch(op);\n+                    case CoreOp.ConditionalBranchOp op -> condBranch(op);\n+                    case PTXPtrOp op -> ptxPtr(op);\n+                    default -> throw new IllegalStateException(\"op translation doesn't exist\");\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public void ptxPtr(PTXPtrOp op) {\n+        PTXRegister source;\n+        int offset = 0;\n+\n+        \/\/ TODO: account for nested schema\n+        \/\/ calculate offset\n+        for (Schema.FieldNode fieldNode : op.schema.rootIfaceType.fields) {\n+            if (fieldNode.name.equals(op.fieldName)) {\n+                break;\n+            }\n+            switch (fieldNode) {\n+                case Schema.SchemaNode.Padding f -> {\n+                    StringBuilder padding = new StringBuilder();\n+                    Consumer<String> consumer = a -> padding.append(a.replaceAll(\"[^0-9]\", \"\"));\n+                    f.toText(\"\", consumer);\n+                    offset += Integer.parseInt(padding.toString());\n+                }\n+                case Schema.FieldNode.PrimitiveFixedArray f -> offset += f.len * 4;\n+                case Schema.FieldNode.IfaceFixedArray f -> offset += f.len * 4;\n+                default -> offset += 4;\n+            }\n+        }\n+\n+        if (op.fieldName.equals(\"array\")) {\n+            \/\/ append(\"mul.wide\").s32().space().printAndAddVar(op.result(), PTXRegister.Type.U64).commaSpace()\n+            \/\/         .printVar(op.operands().getFirst()).commaSpace().append(\"4\").ptxNl();\n+            source = new PTXRegister(incrOrdinal(addrType()), addrType());\n+            append(\"add\").s64().space().append(source.name()).commaSpace().printVar(op.operands().get(0)).commaSpace().printVar(op.operands().get(1)).ptxNl();\n+        } else {\n+            source = getVar(op.operands().getFirst());\n+        }\n+\n+        if (op.resultType.toString().equals(\"void\")) {\n+            st().global().u32().space().address(source.name(), offset).commaSpace().printVar(op.operands().get(2));\n+        } else {\n+            ld().global().u32().space().printAndAddVar(op.result(), PTXRegister.Type.U32).commaSpace().address(source.name(), offset);\n+        }\n+    }\n+\n+    public void varLoad(VarLoadOpWrapper op) {\n+        ld().printResultType(op.resultType(), false).space().printResult(op, addrType()).commaSpace().printVar(op.operandNAsValue(0));\n+    }\n+\n+    public void varStore(VarStoreOpWrapper op) {\n+        st().printResultType(op.resultType(), false).space().printResult(op, addrType()).commaSpace().printVar(op.operandNAsValue(0));\n+    }\n+\n+    public void fieldLoad(FieldLoadOpWrapper op) {\n+        if (op.fieldName().equals(Field.KC_X.toString())) {\n+            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n+                loadKcX(op.result());\n+            } else {\n+                mov().u32().space().printResult(op, PTXRegister.Type.U32).commaSpace().printField(Field.KC_X);\n+            }\n+        } else if (op.fieldName().equals(Field.KC_MAXX.toString())) {\n+            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n+                loadKcX(op.operandNAsValue(0));\n+            }\n+            ld().global().u32().space().printFieldAndVal(Field.KC_MAXX, op.result()).commaSpace()\n+                    .address(fieldToRegMap.get(Field.KC_ADDR).name(), 4);\n+        } else {\n+            ld().global().u32().space().printResult(op, PTXRegister.Type.U64).commaSpace().printVar(op.operandNAsValue(0));\n+\/\/            ld().global().u32().space().printResult(op, PTXRegister.Type.U64).commaSpace().printFieldAndVal(op.fieldName(), op.result());\n+        }\n+    }\n+\n+    public void loadKcX(Value value) {\n+        append(\"cvta.to\").global().addrSize().space().printField(Field.KC_ADDR).commaSpace()\n+                .printAndAddVar(paramMap.get(\"kc\"), addrType()).ptxNl();\n+        mov().u32().space().printField(Field.NTID_X).commaSpace().append(\"%ntid.x\").ptxNl();\n+        mov().u32().space().printField(Field.CTAID_X).commaSpace().append(\"%ctaid.x\").ptxNl();\n+        mov().u32().space().printField(Field.TID_X).commaSpace().append(\"%tid.x\").ptxNl();\n+        append(\"mad.lo\").s32().space().printFieldAndVal(Field.KC_X, value).commaSpace().printField(Field.CTAID_X)\n+                .commaSpace().printField(Field.NTID_X).commaSpace().printField(Field.TID_X).ptxNl();\n+        st().global().u32().space().address(fieldToRegMap.get(Field.KC_ADDR).name()).commaSpace().printField(Field.KC_X);\n+    }\n+\n+    public void fieldStore(FieldStoreOpWrapper op) {\n+        \/\/ TODO: fix\n+        st().global().u64().space().printResult(op, PTXRegister.Type.U64).commaSpace().printVar(op.operandNAsValue(0));\n+    }\n+\n+    PTXCodeBuilder symbol(Op op) {\n+        return switch (op) {\n+            case CoreOp.ModOp _ -> append(\"rem\");\n+            case CoreOp.MulOp _ -> append(\"mul\");\n+            case CoreOp.DivOp _ -> append(\"div\");\n+            case CoreOp.AddOp _ -> append(\"add\");\n+            case CoreOp.SubOp _ -> append(\"sub\");\n+            case CoreOp.LtOp _ -> append(\"lt\");\n+            case CoreOp.GtOp _ -> append(\"gt\");\n+            case CoreOp.LeOp _ -> append(\"le\");\n+            case CoreOp.GeOp _ -> append(\"ge\");\n+            case CoreOp.NeqOp _ -> append(\"ne\");\n+            case CoreOp.EqOp _ -> append(\"eq\");\n+            case CoreOp.XorOp _ -> append(\"xor\");\n+            case ExtendedOp.JavaConditionalAndOp _ -> append(\"&&\");\n+            case ExtendedOp.JavaConditionalOrOp _ -> append(\"||\");\n+            default -> throw new IllegalStateException(\"Unexpected value\");\n+        };\n+    }\n+\n+    public void binaryOperation(BinaryArithmeticOrLogicOperation op) {\n+        symbol(op.op());\n+        if (op.resultType().toString().equals(\"float\") && op.op() instanceof CoreOp.DivOp) dot().append(\"rn\");\n+        if (!op.resultType().toString().equals(\"float\") && op.op() instanceof CoreOp.MulOp) dot().append(\"lo\");\n+        printResultType(op.resultType(), true).space();\n+        printResult(op, resultType(op.resultType()));\n+        commaSpace();\n+        printVar(op.operandNAsValue(0));\n+        commaSpace();\n+        printVar(op.operandNAsValue(1));\n+    }\n+\n+    public void binaryTest(BinaryTestOpWrapper op) {\n+        append(\"setp\").dot();\n+        symbol(op.op()).printResultType(op.operandNAsValue(0).type(), true).space();\n+        printResult(op, PTXRegister.Type.PREDICATE);\n+        commaSpace();\n+        printVar(op.operandNAsValue(0));\n+        commaSpace();\n+        printVar(op.operandNAsValue(1));\n+    }\n+\n+    \/\/TODO: fix?? (i think this is multiplying the idx by 4)\n+    public void conv(ConvOpWrapper op) {\n+        if (op.resultJavaType().equals(JavaType.LONG)) {\n+            \/\/ PTXRegister temp = new PTXRegister(incrOrdinal(addrType()), addrType());\n+            \/\/ append(\"cvt.rn\").u64().dot().append(getVar(op.operandNAsValue(0)).type().toString()).space()\n+            \/\/         .printResult(op, PTXRegister.Type.U64).commaSpace().printVar(op.operandNAsValue(0)).ptxNl();\n+            \/\/ append(\"mul.wide\").s32().space().printResult(op, PTXRegister.Type.U64).commaSpace()\n+            \/\/         .printVar(op.operandNAsValue(0)).commaSpace().append(\"4\");\n+            append(\"mul.wide\").s32().space().printResult(op, PTXRegister.Type.U64).commaSpace()\n+                    .printVar(op.operandNAsValue(0)).commaSpace().append(\"4\");\n+        } else if (op.resultJavaType().equals(JavaType.FLOAT)) {\n+            append(\"cvt.rn\").f32().dot().append(getVar(op.operandNAsValue(0)).type().toString()).space()\n+                    .printResult(op, PTXRegister.Type.F32).commaSpace().printVar(op.operandNAsValue(0));\n+        } else if (op.resultJavaType().equals(JavaType.DOUBLE)) {\n+            append(\"cvt.rn\").f64().dot().append(getVar(op.operandNAsValue(0)).type().toString()).space()\n+                    .printResult(op, PTXRegister.Type.F64).commaSpace().printVar(op.operandNAsValue(0));\n+        } else if (op.resultJavaType().equals(JavaType.INT)) {\n+            append(\"cvt.rn\").s32().dot().append(getVar(op.operandNAsValue(0)).type().toString()).space()\n+                    .printResult(op, PTXRegister.Type.S32).commaSpace().printVar(op.operandNAsValue(0));\n+        } else {\n+            append(\"cvt.rn\").s32().dot().append(getVar(op.operandNAsValue(0)).type().toString()).space()\n+                    .printResult(op, PTXRegister.Type.S32).commaSpace().printVar(op.operandNAsValue(0));\n+        }\n+    }\n+\n+    public void constant(ConstantOpWrapper op) {\n+        mov().printResultType(op.resultType(), false).space().printResult(op, resultType(op.resultType())).commaSpace();\n+        if (op.resultType().toString().equals(\"float\")) {\n+            append(\"0f\");\n+            append(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n+            if (op.op().value().toString().equals(\"0.0\")) append(\"0000000\");\n+        } else {\n+            append(op.op().value().toString());\n+        }\n+    }\n+\n+    public void javaYield(YieldOpWrapper op) {\n+        append(\"exit\");\n+    }\n+\n+    public void funcCall(FuncCallOpWrapper op) {\n+        \/\/ TODO: fix????\n+        append(op.toString());\n+    }\n+\n+    public void methodCall(InvokeOpWrapper op) {\n+        if (op.methodRef().toString().equals(\"hat.buffer.S32Array::array(long)int\")) {\n+            PTXRegister temp = new PTXRegister(incrOrdinal(addrType()), addrType());\n+            append(\"add\").s64().space().append(temp.name()).commaSpace().printVar(op.operandNAsValue(0)).commaSpace().printVar(op.operandNAsValue(1)).ptxNl();\n+            ld().global().u32().space().printResult(op, PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n+        } else if (op.methodRef().toString().equals(\"hat.buffer.S32Array::array(long, int)void\")) {\n+            PTXRegister temp = new PTXRegister(incrOrdinal(addrType()), addrType());\n+            append(\"add\").s64().space().append(temp.name()).commaSpace().printVar(op.operandNAsValue(0)).commaSpace().printVar(op.operandNAsValue(1)).ptxNl();\n+            st().global().u32().space().address(temp.name(), 4).commaSpace().printVar(op.operandNAsValue(2));\n+        } else if (op.methodRef().toString().equals(\"hat.buffer.S32Array::length()int\")) {\n+            ld().global().u32().space().printResult(op, PTXRegister.Type.U32).commaSpace().address(getVar(op.operandNAsValue(0)).name());\n+        } else if (op.methodRef().toString().equals(\"hat.buffer.S32Array2D::array(long, int)void\")) {\n+            PTXRegister temp = new PTXRegister(incrOrdinal(addrType()), addrType());\n+            append(\"add\").s64().space().append(temp.name()).commaSpace().printVar(op.operandNAsValue(0)).commaSpace().printVar(op.operandNAsValue(1)).ptxNl();\n+            st().global().u32().space().address(temp.name(), 8).commaSpace().printVar(op.operandNAsValue(2));\n+        } else if (op.methodRef().toString().equals(\"hat.buffer.S32Array2D::width()int\")) {\n+            ld().global().u32().space().printResult(op, PTXRegister.Type.U32).commaSpace().address(getVar(op.operandNAsValue(0)).name());\n+        } else if (op.methodRef().toString().equals(\"hat.buffer.S32Array2D::height()int\")) {\n+            ld().global().u32().space().printResult(op, PTXRegister.Type.U32).commaSpace().address(getVar(op.operandNAsValue(0)).name(), 4);\n+        } else {\n+            for (int i = 0; i < op.operands().size(); i++) {\n+                param().space().printParamType(op.operandNAsValue(i).type()).space().append(\"param\").append(String.valueOf(i)).ptxNl();\n+                st().param().printParamType(op.operandNAsValue(i).type()).space().osbrace().append(\"param\").append(String.valueOf(i)).csbrace().commaSpace().printVar(op.operandNAsValue(i)).ptxNl();\n+            }\n+            param().space().printParamType(op.resultType()).space().append(\"retval\").ptxNl();\n+            append(\"call.uni\").space().oparen().append(\"retval\").cparen().commaSpace().append(op.method().getName()).commaSpace();\n+            final int[] counter = {0};\n+            paren(_ -> commaSeparated(op.operands(), _ -> append(\"param\").append(String.valueOf(counter[0]++)))).ptxNl();\n+            ld().param().printParamType(op.resultType()).space().printResult(op, resultType(op.resultType())).commaSpace().osbrace().append(\"retval\").csbrace();\n+        }\n+    }\n+\n+    public void varDeclaration(VarDeclarationOpWrapper op) {\n+        ld().param().printResultType(op.resultType(), false).space().printResult(op, addrType()).commaSpace().printVar(op.operandNAsValue(0));\n+    }\n+\n+    public void varFuncDeclaration(VarFuncDeclarationOpWrapper op) {\n+        ld().param().printResultType(op.resultType(), false).space().printResult(op, addrType()).commaSpace().printVar(op.operandNAsValue(0));\n+    }\n+\n+    public void ret(ReturnOpWrapper op) {\n+        if (op.hasOperands()) {\n+            st().param();\n+            if (returnReg.type().equals(PTXRegister.Type.U32)) {\n+                b32();\n+            } else if (returnReg.type().equals(PTXRegister.Type.U64)) {\n+                b64();\n+            } else {\n+                dot().append(returnReg.type().toString());\n+            }\n+            space().osbrace().append(returnReg.name()).csbrace().commaSpace().printVar(op.operandNAsValue(0)).ptxNl();\n+        }\n+        append(\"ret\");\n+    }\n+\n+    public void javaBreak(JavaBreakOpWrapper op) {\n+        append(\"brkpt\");\n+    }\n+\n+    public void branch(CoreOp.BranchOp op) {\n+        loadBlockParams(op.successors().getFirst());\n+        append(\"bra\").space().printBlock(op.successors().getFirst().targetBlock());\n+    }\n+\n+    public void condBranch(CoreOp.ConditionalBranchOp op) {\n+        loadBlockParams(op.successors().getFirst());\n+        loadBlockParams(op.successors().getLast());\n+        append(\"@\").printVar(op.operands().getFirst()).space()\n+                .append(\"bra\").space().printBlock(op.successors().getFirst().targetBlock()).ptxNl();\n+        append(\"bra\").space().printBlock(op.successors().getLast().targetBlock());\n+    }\n+\n+    \/*\n+     * Helper functions for printing blocks and variables\n+     *\/\n+\n+    public void loadBlockParams(Block.Reference block) {\n+        for (int i = 0; i < block.arguments().size(); i++) {\n+            Block.Parameter p = block.targetBlock().parameters().get(i);\n+            mov().printResultType(p.type(), false).space().printAndAddVar(p, resultType(p.type()))\n+                    .commaSpace().printVar(block.arguments().get(i)).ptxNl();\n+        }\n+    }\n+\n+    public PTXCodeBuilder printBlock(Block block) {\n+        return append(\"block_\").append(String.valueOf(block.index()));\n+    }\n+\n+    public PTXCodeBuilder printField(String ref) {\n+        return printField(getFieldObj(ref));\n+    }\n+\n+    public PTXCodeBuilder printField(Field ref) {\n+        if (fieldToRegMap.containsKey(ref)) {\n+            return append(fieldToRegMap.get(ref).name());\n+        }\n+        if (ref.isDestination()) {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(addrType()), addrType()));\n+        } else {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n+        }\n+        return append(fieldToRegMap.get(ref).name());\n+    }\n+\n+    public PTXCodeBuilder printFieldAndVal(Field ref, Value value) {\n+        if (fieldToRegMap.containsKey(ref)) {\n+            return append(fieldToRegMap.get(ref).name());\n+        }\n+        if (ref.isDestination()) {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(addrType()), addrType()));\n+            return printAndAddVar(value, addrType());\n+        } else {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n+            return printAndAddVar(value, PTXRegister.Type.U32);\n+        }\n+    }\n+\n+    public Field getFieldObj(String fieldName) {\n+        for (Field f : fieldToRegMap.keySet()) {\n+            if (f.toString().equals(fieldName)) return f;\n+        }\n+        throw new IllegalStateException(\"no existing field\");\n+    }\n+\n+    public PTXCodeBuilder printResult(OpWrapper<?> opWrapper, PTXRegister.Type type) {\n+        return append(addVar(opWrapper.result(), type));\n+    }\n+\n+    public PTXCodeBuilder printAndAddVar(Value val, PTXRegister.Type type) {\n+        if (varToRegMap.containsKey(val)) {\n+            return append(getVar(val).name());\n+        } else {\n+            return append(addVar(val, type));\n+        }\n+    }\n+\n+    public PTXCodeBuilder printVar(Value val) {\n+        return append(getVar(val).name());\n+    }\n+\n+    public PTXRegister getVar(Value val) {\n+        if (varToRegMap.get(val) == null && val instanceof Op.Result result && result.op() instanceof CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+            return fieldToRegMap.get(getFieldObj(fieldLoadOp.fieldDescriptor().name()));\n+        }\n+        if (varToRegMap.containsKey(val)) {\n+            return varToRegMap.get(val);\n+        } else {\n+            throw new IllegalStateException(\"var to reg mapping doesn't exist\");\n+        }\n+    }\n+\n+    public String addVar(Value val, PTXRegister.Type type) {\n+        if (varToRegMap.containsKey(val)) {\n+            return varToRegMap.get(val).name();\n+        }\n+        varToRegMap.put(val, new PTXRegister(incrOrdinal(type), type));\n+        return varToRegMap.get(val).name();\n+    }\n+\n+    public Integer getOrdinal(PTXRegister.Type type) {\n+        ordinalMap.putIfAbsent(type, 1);\n+        return ordinalMap.get(type);\n+    }\n+\n+    public Integer incrOrdinal(PTXRegister.Type type) {\n+        ordinalMap.putIfAbsent(type, 1);\n+        int out = ordinalMap.get(type);\n+        ordinalMap.put(type, out + 1);\n+        return out;\n+    }\n+\n+    public PTXCodeBuilder addrSize() {\n+        return (addressSize == 32) ? u32() : u64();\n+    }\n+\n+    public PTXRegister.Type addrType() {\n+        return (addressSize == 32) ? PTXRegister.Type.U32 : PTXRegister.Type.U64;\n+    }\n+\n+    public PTXCodeBuilder printResultType(TypeElement type, boolean signedResult) {\n+        PTXRegister.Type res = resultType(type);\n+        if (signedResult && (res == PTXRegister.Type.U32)) return s32();\n+        return dot().append(resultType(type).toString());\n+    }\n+\n+    public PTXCodeBuilder printParamType(TypeElement type) {\n+        PTXRegister.Type res = resultType(type);\n+        if (res == PTXRegister.Type.U32) return b32();\n+        if (res == PTXRegister.Type.U64) return b64();\n+        return dot().append(resultType(type).toString());\n+    }\n+\n+    public PTXRegister.Type resultType(TypeElement type) {\n+        switch (type.toString()) {\n+            case \"float\" -> {\n+                return PTXRegister.Type.F32;\n+            }\n+            case \"int\" -> {\n+                return PTXRegister.Type.U32;\n+            }\n+            case \"boolean\" -> {\n+                return PTXRegister.Type.PREDICATE;\n+            }\n+            default -> {\n+                return PTXRegister.Type.U64;\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Basic CodeBuilder functions\n+     *\/\n+\n+    \/\/ used for parameter list\n+    \/\/ prints out items separated by a comma then new line\n+    public <I> PTXCodeBuilder commaNlSeparated(Iterable<I> iterable, Consumer<I> c) {\n+        StreamCounter.of(iterable, (counter, t) -> {\n+            if (counter.isNotFirst()) {\n+                comma().nl();\n+            }\n+            c.accept(t);\n+        });\n+        return self();\n+    }\n+\n+    public PTXCodeBuilder address(String address) {\n+        return osbrace().append(address).csbrace();\n+    }\n+\n+    public PTXCodeBuilder address(String address, int offset) {\n+        osbrace().append(address);\n+        if (offset == 0) {\n+            return csbrace();\n+        } else if (offset > 0) {\n+            plus();\n+        }\n+        return append(String.valueOf(offset)).csbrace();\n+    }\n+\n+    public void ptxNl() {\n+        semicolon().nl().ptxIndent();\n+    }\n+\n+    public PTXCodeBuilder commaSpace() {\n+        return comma().space();\n+    }\n+\n+    public PTXCodeBuilder param() {\n+        return dot().append(\"param\");\n+    }\n+\n+    public PTXCodeBuilder global() {\n+        return dot().append(\"global\");\n+    }\n+\n+    public PTXCodeBuilder mov() {\n+        return append(\"mov\");\n+    }\n+\n+    public PTXCodeBuilder ld() {\n+        return append(\"ld\");\n+    }\n+\n+    public PTXCodeBuilder st() {\n+        return append(\"st\");\n+    }\n+\n+    public PTXCodeBuilder ptxIndent() {\n+        return append(\"    \");\n+    }\n+\n+    public PTXCodeBuilder u32() {\n+        return dot().append(PTXRegister.Type.U32.toString());\n+    }\n+\n+    public PTXCodeBuilder s32() {\n+        return dot().append(PTXRegister.Type.S32.toString());\n+    }\n+\n+    public PTXCodeBuilder f32() {\n+        return dot().append(PTXRegister.Type.F32.toString());\n+    }\n+\n+    public PTXCodeBuilder b32() {\n+        return dot().append(PTXRegister.Type.B32.toString());\n+    }\n+\n+    public PTXCodeBuilder u64() {\n+        return dot().append(PTXRegister.Type.U64.toString());\n+    }\n+\n+    public PTXCodeBuilder s64() {\n+        return dot().append(PTXRegister.Type.S64.toString());\n+    }\n+\n+    public PTXCodeBuilder f64() {\n+        return dot().append(PTXRegister.Type.F64.toString());\n+    }\n+\n+    public PTXCodeBuilder b64() {\n+        return dot().append(PTXRegister.Type.B64.toString());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXCodeBuilder.java","additions":665,"deletions":0,"binary":false,"changes":665,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend;\n+\n+import hat.ifacemapper.Schema;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.util.List;\n+\n+public class PTXPtrOp extends ExternalizableOp {\n+    public String fieldName;\n+    public static final String NAME = \"ptxPtr\";\n+    final TypeElement resultType;\n+    public Schema<?> schema;\n+\n+    PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, Schema<?> schema) {\n+        super(NAME, operands);\n+        this.resultType = resultType;\n+        this.fieldName = fieldName;\n+        this.schema = schema;\n+    }\n+\n+    PTXPtrOp(PTXPtrOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.resultType = that.resultType;\n+        this.fieldName = that.fieldName;\n+        this.schema = that.schema;\n+    }\n+\n+    @Override\n+    public PTXPtrOp transform(CopyContext cc, OpTransformer ot) {\n+        return new PTXPtrOp(this, cc);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+}\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXPtrOp.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend;\n+\n+public class PTXRegister {\n+    private String name;\n+    private final Type type;\n+\n+    public enum Type {\n+        S8 (8, BasicType.SIGNED, \"s8\", \"%s\"),\n+        S16 (16, BasicType.SIGNED, \"s16\", \"%s\"),\n+        S32 (32, BasicType.SIGNED, \"s32\", \"%s\"),\n+        S64 (64, BasicType.SIGNED, \"s64\", \"%sd\"),\n+        U8 (8, BasicType.UNSIGNED, \"u8\", \"%r\"),\n+        U16 (16, BasicType.UNSIGNED, \"u16\", \"%r\"),\n+        U32 (32, BasicType.UNSIGNED, \"u32\", \"%r\"),\n+        U64 (64, BasicType.UNSIGNED, \"u64\", \"%rd\"),\n+        F16 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n+        F16X2 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n+        F32 (32, BasicType.FLOATING, \"f32\", \"%f\"),\n+        F64 (64, BasicType.FLOATING, \"f64\", \"%fd\"),\n+        B8 (8, BasicType.BIT, \"b8\", \"%b\"),\n+        B16 (16, BasicType.BIT, \"b16\", \"%b\"),\n+        B32 (32, BasicType.BIT, \"b32\", \"%b\"),\n+        B64 (64, BasicType.BIT, \"b64\", \"%bd\"),\n+        B128 (128, BasicType.BIT, \"b128\", \"%b\"),\n+        PREDICATE (1, BasicType.PREDICATE, \"pred\", \"%p\");\n+\n+        public enum BasicType {\n+            SIGNED,\n+            UNSIGNED,\n+            FLOATING,\n+            BIT,\n+            PREDICATE\n+        }\n+\n+        private final int size;\n+        private final BasicType basicType;\n+        private final String name;\n+        private final String regPrefix;\n+\n+        Type(int size, BasicType type, String name, String regPrefix) {\n+            this.size = size;\n+            this.basicType = type;\n+            this.name = name;\n+            this.regPrefix = regPrefix;\n+        }\n+\n+        public int getSize() {\n+            return this.size;\n+        }\n+\n+        public BasicType getBasicType() {\n+            return this.basicType;\n+        }\n+\n+        public String toString() {\n+            return this.name;\n+        }\n+\n+        public String getRegPrefix() {\n+            return this.regPrefix;\n+        }\n+    }\n+\n+    public PTXRegister(int num, Type type) {\n+        this.type = type;\n+        this.name = type.regPrefix + num;\n+    }\n+\n+    public String name() {\n+        return this.name;\n+    }\n+\n+    public void name(String name) {\n+        this.name = name;\n+    }\n+\n+    public Type type() {\n+        return this.type;\n+    }\n+}\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXRegister.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F32Array;\n+import hat.buffer.S32Array;\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class BlackScholes {\n+\n+    @CodeReflection\n+    public static void blackScholesKernel(KernelContext kc, F32Array f32Array, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n+        if (kc.x<kc.maxX){\n+            float S = sArray.array(kc.x);\n+            float X = xArray.array(kc.x);\n+            float T = tArray.array(kc.x);\n+            float d1 = (float) ((Math.log(S \/ X) + (r + v * v * .5f) * T) \/ (v * Math.sqrt(T)));\n+            float d2 = (float) (d1 - v * Math.sqrt(T));\n+            float value = (float) (S * CND(d1) - X * Math.exp(-r * T) * CND(d2));\n+            f32Array.array(kc.x, value);\n+            \/\/put[i]  = call[i] + (float)Math.exp(-r * t[i]) - s0[i];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static float CND(float input) {\n+        float x = input;\n+        if (input < 0f) {\n+            x = -input;\n+        }\n+\n+        float term = 1f \/ (1f + (0.2316419f * x));\n+        float term_pow2 = term * term;\n+        float term_pow3 = term_pow2 * term;\n+        float term_pow4 = term_pow2 * term_pow2;\n+        float term_pow5 = term_pow2 * term_pow3;\n+\n+        float part1 = (1f \/ (float)Math.sqrt(2f * Math.PI)) * (float)Math.exp((-x * x) * 0.5f);\n+\n+        float part2 = (0.31938153f * term) +\n+                (-0.356563782f * term_pow2) +\n+                (1.781477937f * term_pow3) +\n+                (-1.821255978f * term_pow4) +\n+                (1.330274429f * term_pow5);\n+\n+        if (input >= 0f) {\n+            return 1f - part1 * part2;\n+        } else {\n+            return part1 * part2;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void blackScholes(ComputeContext cc, F32Array f32Array, F32Array S, F32Array X, F32Array T, float r, float v) {\n+        cc.dispatchKernel(f32Array.length(),\n+                kc -> blackScholesKernel(kc, f32Array, S, X, T, r, v)\n+        );\n+    }\n+\n+    public static void main(String[] args) {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = F32Array.create(accelerator, 32);\n+\/\/        s0 = fillRandom(5.0f, 30.0f);\n+\/\/        x  = fillRandom(1.0f, 100.0f);\n+\/\/        t  = fillRandom(0.25f, 10.0f);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+\n+        var S = F32Array.create(accelerator, 32);\n+        for (int i = 0; i < S.length(); i++) {\n+            S.array(i, i + 5);\n+        }\n+\n+        var X = F32Array.create(accelerator, 32);\n+        for (int i = 0; i < X.length(); i++) {\n+            X.array(i, i + 1);\n+        }\n+\n+        var T = F32Array.create(accelerator, 32);\n+        for (int i = 0; i < T.length(); i++) {\n+            T.array(i, (float) (i + 1) \/4);\n+        }\n+        float r = 0.02f;\n+        float v = 0.30f;\n+\n+        accelerator.compute(\n+                cc -> BlackScholes.blackScholes(cc, arr, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            System.out.println(\"S=\" + S.array(i) + \", X=\" + X.array(i) + \", T=\" + T.array(i) + \", call option price = \" + arr.array(i));\n+        }\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlackScholes.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}