{"files":[{"patch":"@@ -49,62 +49,2 @@\n-    Ptx *ptx = nullptr;\n-    uint64_t time = timeSinceEpochMillisec();\n-    std::stringstream timestampPtx;\n-    timestampPtx << \".\/tmp\" << time << \".ptx\";\n-    const char *ptxPath = strdup(timestampPtx.str().c_str());\n-   \/\/ std::cout << \"ptx \" << ptxPath << std::endl;\n-    \/\/ we are going to fork exec nvcc\n-    int pid;\n-    if ((pid = fork()) == 0) {\n-        std::ofstream ptx;\n-        std::stringstream timestampPtx;\n-        timestampPtx << \".\/tmp\" << time << \".cu\";\n-        const char *ptxPath = strdup(timestampPtx.str().c_str());\n-        std::cout << \"ptx \" << ptxPath << std::endl;\n-        ptx.open(ptxPath, std::ofstream::trunc);\n-        ptx.write(ptxSource, len);\n-        ptx.close();\n-        const char *path = \"\/usr\/bin\/nvcc\";\n-        \/\/const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n-        const char *argv[]{\"nvcc\", \"-ptx\", ptxPath, \"-o\", ptxPath, nullptr};\n-        \/\/ we can't free ptxPath or ptxpath in child because we need them in exec, no prob through\n-        \/\/ because we get a new proc so they are released to os\n-        execvp(path, (char *const *) argv);\n-\n-    } else if (pid < 0) {\n-        \/\/ fork failed.\n-        std::cerr << \"fork of nvcc failed\" << std::endl;\n-        std::exit(1);\n-    } else {\n-        int status;\n-     \/\/   std::cerr << \"fork suceeded waiting for child\" << std::endl;\n-        pid_t result = wait(&status);\n-        std::cerr << \"child finished\" << std::endl;\n-        std::ifstream ptxStream;\n-        ptxStream.open(ptxPath);\n-      \/\/  if (ptxStream.is_open()) {\n-            ptxStream.seekg(0, std::ios::end);\n-            size_t ptxLen = ptxStream.tellg();\n-            ptxStream.close();\n-            ptxStream.open(ptxPath);\n-            free((void *) ptxPath);\n-            ptxPath = nullptr;\n-            if (ptxLen > 0) {\n-                std::cerr << \"ptx len \"<< ptxLen << std::endl;\n-                ptx = new Ptx(ptxLen + 1);\n-                std::cerr << \"about to read  \"<< ptx->len << std::endl;\n-                ptxStream.read(ptx->text, ptx->len);\n-                ptxStream.close();\n-                std::cerr << \"about to read  \"<< ptx->len << std::endl;\n-                ptx->text[ptx->len - 1] = '\\0';\n-                std::cerr << \"read text \"<< ptx->text << std::endl;\n-\n-            } else {\n-                std::cerr << \"no ptx! ptxLen == 0?\";\n-                exit(1);\n-            }\n-      \/\/  }else{\n-        \/\/    std::cerr << \"no ptx!\";\n-       \/\/     exit(1);\n-      \/\/  }\n-    }\n-    std::cout << \"returning PTX\" << std::endl;\n+    Ptx * ptx = new Ptx(len);\n+    strcpy(ptx->text,ptxSource);\n@@ -112,0 +52,64 @@\n+\n+\/\/     Ptx *ptx = nullptr;\n+\/\/     uint64_t time = timeSinceEpochMillisec();\n+\/\/     std::stringstream timestampPtx;\n+\/\/     timestampPtx << \".\/tmp\" << time << \".ptx\";\n+\/\/     const char *ptxPath = strdup(timestampPtx.str().c_str());\n+\/\/    \/\/ std::cout << \"ptx \" << ptxPath << std::endl;\n+\/\/     \/\/ we are going to fork exec nvcc\n+\/\/     int pid;\n+\/\/     if ((pid = fork()) == 0) {\n+\/\/         std::ofstream ptx;\n+\/\/         std::stringstream timestampPtx;\n+\/\/         timestampPtx << \".\/tmp\" << time << \".cu\";\n+\/\/         const char *ptxPath = strdup(timestampPtx.str().c_str());\n+\/\/         std::cout << \"ptx \" << ptxPath << std::endl;\n+\/\/         ptx.open(ptxPath, std::ofstream::trunc);\n+\/\/         ptx.write(ptxSource, len);\n+\/\/         ptx.close();\n+\/\/         const char *path = \"\/usr\/bin\/nvcc\";\n+\/\/         \/\/const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n+\/\/         const char *argv[]{\"nvcc\", \"-ptx\", ptxPath, \"-o\", ptxPath, nullptr};\n+\/\/         \/\/ we can't free ptxPath or ptxpath in child because we need them in exec, no prob through\n+\/\/         \/\/ because we get a new proc so they are released to os\n+\/\/         execvp(path, (char *const *) argv);\n+\n+\/\/     } else if (pid < 0) {\n+\/\/         \/\/ fork failed.\n+\/\/         std::cerr << \"fork of nvcc failed\" << std::endl;\n+\/\/         std::exit(1);\n+\/\/     } else {\n+\/\/         int status;\n+\/\/      \/\/   std::cerr << \"fork suceeded waiting for child\" << std::endl;\n+\/\/         pid_t result = wait(&status);\n+\/\/         std::cerr << \"child finished\" << std::endl;\n+\/\/         std::ifstream ptxStream;\n+\/\/         ptxStream.open(ptxPath);\n+\/\/       \/\/  if (ptxStream.is_open()) {\n+\/\/             ptxStream.seekg(0, std::ios::end);\n+\/\/             size_t ptxLen = ptxStream.tellg();\n+\/\/             ptxStream.close();\n+\/\/             ptxStream.open(ptxPath);\n+\/\/             free((void *) ptxPath);\n+\/\/             ptxPath = nullptr;\n+\/\/             if (ptxLen > 0) {\n+\/\/                 std::cerr << \"ptx len \"<< ptxLen << std::endl;\n+\/\/                 ptx = new Ptx(ptxLen + 1);\n+\/\/                 std::cerr << \"about to read  \"<< ptx->len << std::endl;\n+\/\/                 ptxStream.read(ptx->text, ptx->len);\n+\/\/                 ptxStream.close();\n+\/\/                 std::cerr << \"about to read  \"<< ptx->len << std::endl;\n+\/\/                 ptx->text[ptx->len - 1] = '\\0';\n+\/\/                 std::cerr << \"read text \"<< ptx->text << std::endl;\n+\n+\/\/             } else {\n+\/\/                 std::cerr << \"no ptx! ptxLen == 0?\";\n+\/\/                 exit(1);\n+\/\/             }\n+\/\/       \/\/  }else{\n+\/\/         \/\/    std::cerr << \"no ptx!\";\n+\/\/        \/\/     exit(1);\n+\/\/       \/\/  }\n+\/\/     }\n+\/\/     std::cout << \"returning PTX\" << std::endl;\n+\/\/     return ptx;\n@@ -454,0 +458,1 @@\n+        printf(\"status: %d\\n\", status);\n","filename":"hat\/backends\/ptx\/cpp\/ptx_backend.cpp","additions":67,"deletions":62,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.buffer.Buffer;\n@@ -31,0 +32,14 @@\n+import hat.ifacemapper.BoundSchema;\n+import hat.optools.*;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class PTXBackend extends C99NativeBackend {\n+    int major;\n+    int minor;\n+    String target;\n+    int addressSize;\n@@ -32,1 +47,0 @@\n-public class PTXBackend extends NativeBackend {\n@@ -35,0 +49,4 @@\n+        major = 7;\n+        minor = 5;\n+        target = \"sm_52\";\n+        addressSize = 64;\n@@ -61,3 +79,86 @@\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().toText());\n-        System.out.println(\"Add your code to \"+PTXBackend.class.getName()+\".dispatchKernel() to actually run! :)\");\n-        System.exit(1);\n+        String code = createCode(kernelCallGraph, new PTXCodeBuilder(), args);\n+        long programHandle = compileProgram(code);\n+        if (programOK(programHandle)) {\n+            long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n+            CompiledKernel compiledKernel = new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+            compiledKernel.dispatch(ndRange,args);\n+        }\n+    }\n+\n+    public String createCode(KernelCallGraph kernelCallGraph, PTXCodeBuilder builder, Object[] args) {\n+        StringBuilder out = new StringBuilder();\n+        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.entrypoint.funcOpWrapper().op());\n+        FuncOpWrapper lowered = f.lower();\n+        HashMap<String, Object> argsMap = new HashMap<>();\n+        for (int i = 0; i < args.length; i++) {\n+            argsMap.put(f.paramTable().list().get(i).varOp.varName(), args[i]);\n+        }\n+\n+        \/\/ currently hard coded but ill fix it later\n+        boolean useSchema = true;\n+\n+        \/\/ printing out ptx header (device info)\n+        builder.ptxHeader(major, minor, target, addressSize);\n+        out.append(builder.getTextAndReset());\n+\n+        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n+            FuncOpWrapper calledFunc = new FuncOpWrapper(k.funcOpWrapper().op());\n+            FuncOpWrapper loweredFunc = calledFunc.lower();\n+            if (useSchema) loweredFunc = transformPtrs(loweredFunc, argsMap);\n+            out.append(createFunction(new PTXCodeBuilder(addressSize).nl().nl(), loweredFunc, false));\n+        }\n+\n+        if (useSchema) lowered = transformPtrs(lowered, argsMap);\n+\n+        out.append(createFunction(builder.nl().nl(), lowered, true));\n+\n+        return out.toString();\n+    }\n+\n+    public FuncOpWrapper transformPtrs(FuncOpWrapper func, HashMap<String, Object> argsMap) {\n+        return FuncOpWrapper.wrap(func.op().transform((block, op) -> {\n+            CopyContext cc = block.context();\n+            \/\/ use first operand of invoke to figure out schema\n+            if (op instanceof CoreOp.InvokeOp invokeOp\n+                    && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                    && invokeOpWrapper.isIfaceBufferMethod()\n+                    && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+                    && invokeResult.op().operands().getFirst() instanceof Op.Result varLoadResult\n+                    && varLoadResult.op() instanceof CoreOp.VarOp varOp\n+                    && argsMap.get(varOp.varName()) instanceof Buffer buffer) {\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = cc.getValues(inputOperands);\n+                Op.Result inputResult = invokeOp.result();\n+                BoundSchema<?> boundSchema = Buffer.getBoundSchema(buffer);\n+                PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema.schema());\n+                Op.Result outputResult = block.op(ptxOp);\n+                cc.mapValue(inputResult, outputResult);\n+            } else {\n+                block.apply(op);\n+            }\n+            return block;\n+        }));\n+    }\n+\n+    public String createFunction(PTXCodeBuilder builder, FuncOpWrapper lowered, boolean entry) {\n+        FuncOpWrapper ssa = lowered.ssa();\n+        String out, body;\n+\n+        \/\/ building fn info (name, params)\n+        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n+\n+        \/\/ printing out params\n+        builder.parameters(lowered.paramTable().list());\n+\n+        \/\/ building body of fn\n+        builder.functionPrologue();\n+\n+        out = builder.getTextAndReset();\n+        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(OpWrapper::wrap)));\n+\n+        builder.functionEpilogue();\n+        body = builder.getTextAndReset();\n+\n+        builder.ptxRegisterDecl();\n+        out += builder.getText() + body;\n+        return out;\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXBackend.java","additions":105,"deletions":4,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -0,0 +1,952 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend;\n+\n+import hat.ifacemapper.Schema;\n+import hat.optools.*;\n+import hat.text.CodeBuilder;\n+import hat.util.StreamCounter;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+public class PTXCodeBuilder extends CodeBuilder<PTXCodeBuilder> {\n+\n+    Map<Value, PTXRegister> varToRegMap;\n+    List<String> params;\n+    Map<String, Block.Parameter> paramMap;\n+    Map<Field, PTXRegister> fieldToRegMap;\n+\n+    HashMap<PTXRegister.Type, Integer> ordinalMap;\n+\n+    PTXRegister returnReg;\n+    private int addressSize;\n+\n+    public enum Field {\n+        NTID_X (\"ntid.x\", false),\n+        CTAID_X (\"ctaid.x\", false),\n+        TID_X (\"tid.x\", false),\n+        KC_X (\"x\", false),\n+        KC_ADDR(\"kc\", true),\n+        KC_MAXX (\"maxX\", false);\n+\n+        private final String name;\n+        private final boolean destination;\n+\n+        Field(String name, boolean destination) {\n+            this.name = name;\n+            this.destination = destination;\n+        }\n+        public String toString() {\n+            return this.name;\n+        }\n+        public boolean isDestination() {return this.destination;}\n+    }\n+\n+    public PTXCodeBuilder(int addressSize) {\n+        varToRegMap = new HashMap<>();\n+        params = new ArrayList<>();\n+        fieldToRegMap = new HashMap<>();\n+        paramMap = new HashMap<>();\n+        ordinalMap = new HashMap<>();\n+        this.addressSize = addressSize;\n+    }\n+\n+    public PTXCodeBuilder() {\n+        this(32);\n+    }\n+\n+    public void ptxHeader(int major, int minor, String target, int addressSize) {\n+        this.addressSize = addressSize;\n+        version().space().major(major).dot().minor(minor).nl();\n+        target().space().target(target).nl();\n+        addressSize().space().size(addressSize);\n+    }\n+\n+    public void functionHeader(String funcName, boolean entry, TypeElement yieldType) {\n+        if (entry) {\n+            visible().space().entry().space();\n+        } else {\n+            func().space();\n+        }\n+        if (!yieldType.toString().equals(\"void\")) {\n+            returnReg = new PTXRegister(getOrdinal(getResultType(yieldType)), getResultType(yieldType));\n+            returnReg.name(\"%retReg\");\n+            oparen().dot().param().space().paramType(yieldType);\n+            space().regName(returnReg).cparen().space();\n+        }\n+        funcName(funcName);\n+    }\n+\n+    public PTXCodeBuilder parameters(List<FuncOpWrapper.ParamTable.Info> infoList) {\n+        paren(_ -> nl().commaNlSeparated(infoList, (info) -> {\n+            ptxIndent().dot().param().space().paramType(info.javaType);\n+            space().regName(info.varOp.varName());\n+            params.add(info.varOp.varName());\n+        }).nl()).nl();\n+        return this;\n+    }\n+\n+    public void blockBody(Block block, Stream<OpWrapper<?>> ops) {\n+        if (block.index() == 0) {\n+            for (Block.Parameter p : block.parameters()) {\n+                ptxIndent().ld().dot().param();\n+                resultType(p.type(), false).ptxIndent().space();\n+                reg(p, getResultType(p.type())).commaSpace().osbrace().regName(params.get(p.index())).csbrace().semicolon().nl();\n+                paramMap.putIfAbsent(params.get(p.index()), p);\n+            }\n+        }\n+        nl();\n+        block(block);\n+        colon().nl();\n+        ops.forEach(op -> {\n+            if (op instanceof InvokeOpWrapper invoke && !invoke.isIfaceBufferMethod()) {\n+                ptxIndent().obrace().nl().ptxIndent().convert(op).ptxNl();\n+                cbrace().nl();\n+            } else {\n+                ptxIndent().convert(op).semicolon().nl();\n+            }\n+        });\n+    }\n+\n+    public void ptxRegisterDecl() {\n+        for (PTXRegister.Type t : ordinalMap.keySet()) {\n+            ptxIndent().reg().space();\n+            if (t.equals(PTXRegister.Type.U32)) {\n+                b32();\n+            } else if (t.equals(PTXRegister.Type.U64)) {\n+                b64();\n+            } else {\n+                dot().regType(t);\n+            }\n+            ptxIndent().regTypePrefix(t).oabrace().intVal(ordinalMap.get(t)).cabrace().semicolon().nl();\n+        }\n+        nl();\n+    }\n+\n+    public void functionPrologue() {\n+        obrace().nl();\n+    }\n+\n+    public void functionEpilogue() {\n+        cbrace();\n+    }\n+\n+    public PTXCodeBuilder convert(OpWrapper<?> wrappedOp) {\n+        switch (wrappedOp) {\n+            case FieldLoadOpWrapper op -> fieldLoad(op);\n+            case FieldStoreOpWrapper op -> fieldStore(op);\n+            case BinaryArithmeticOrLogicOperation op -> binaryOperation(op);\n+            case BinaryTestOpWrapper op -> binaryTest(op);\n+            case ConvOpWrapper op -> conv(op);\n+            case ConstantOpWrapper op -> constant(op);\n+            case YieldOpWrapper op -> javaYield(op);\n+            case InvokeOpWrapper op -> methodCall(op);\n+            case VarDeclarationOpWrapper op -> varDeclaration(op);\n+            case VarFuncDeclarationOpWrapper op -> varFuncDeclaration(op);\n+            case ReturnOpWrapper op -> ret(op);\n+            case JavaBreakOpWrapper op -> javaBreak(op);\n+            default -> {\n+                switch (wrappedOp.op()){\n+                    case CoreOp.BranchOp op -> branch(op);\n+                    case CoreOp.ConditionalBranchOp op -> condBranch(op);\n+                    case CoreOp.NegOp op -> neg(op);\n+                    case PTXPtrOp op -> ptxPtr(op);\n+                    default -> throw new IllegalStateException(\"op translation doesn't exist\");\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public void ptxPtr(PTXPtrOp op) {\n+        PTXRegister source;\n+        int offset = 0;\n+\n+        \/\/ TODO: account for nested schema\n+        \/\/ calculate offset\n+        for (Schema.FieldNode fieldNode : op.schema.rootIfaceType.fields) {\n+            if (fieldNode.name.equals(op.fieldName)) {\n+                break;\n+            }\n+            switch (fieldNode) {\n+                case Schema.SchemaNode.Padding f -> {\n+                    StringBuilder padding = new StringBuilder();\n+                    Consumer<String> consumer = a -> padding.append(a.replaceAll(\"[^0-9]\", \"\"));\n+                    f.toText(\"\", consumer);\n+                    offset += Integer.parseInt(padding.toString());\n+                }\n+                case Schema.FieldNode.PrimitiveFixedArray f -> offset += f.len * 4;\n+                case Schema.FieldNode.IfaceFixedArray f -> offset += f.len * 4;\n+                default -> offset += 4;\n+            }\n+        }\n+\n+        if (op.fieldName.equals(\"array\")) {\n+            source = new PTXRegister(incrOrdinal(addressType()), addressType());\n+            add().s64().space().regName(source).commaSpace().reg(op.operands().get(0)).commaSpace().reg(op.operands().get(1)).ptxNl();\n+        } else {\n+            source = getReg(op.operands().getFirst());\n+        }\n+\n+        if (op.resultType.toString().equals(\"void\")) {\n+            st().global().u32().space().address(source.name(), offset).commaSpace().reg(op.operands().get(2));\n+        } else {\n+            ld().global().u32().space().reg(op.result(), PTXRegister.Type.U32).commaSpace().address(source.name(), offset);\n+        }\n+    }\n+\n+    public void fieldLoad(FieldLoadOpWrapper op) {\n+        if (op.fieldName().equals(Field.KC_X.toString())) {\n+            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n+                loadKcX(op.result());\n+            } else {\n+                mov().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n+            }\n+        } else if (op.fieldName().equals(Field.KC_MAXX.toString())) {\n+            if (!fieldToRegMap.containsKey(Field.KC_X)) {\n+                loadKcX(op.operandNAsValue(0));\n+            }\n+            ld().global().u32().space().fieldReg(Field.KC_MAXX, op.result()).commaSpace()\n+                    .address(fieldToRegMap.get(Field.KC_ADDR).name(), 4);\n+        } else {\n+            ld().global().u32().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n+        }\n+    }\n+\n+    public void loadKcX(Value value) {\n+        cvta().to().global().size().space().fieldReg(Field.KC_ADDR).commaSpace()\n+                .reg(paramMap.get(\"kc\"), addressType()).ptxNl();\n+        mov().u32().space().fieldReg(Field.NTID_X).commaSpace().percent().regName(Field.NTID_X.toString()).ptxNl();\n+        mov().u32().space().fieldReg(Field.CTAID_X).commaSpace().percent().regName(Field.CTAID_X.toString()).ptxNl();\n+        mov().u32().space().fieldReg(Field.TID_X).commaSpace().percent().regName(Field.TID_X.toString()).ptxNl();\n+        mad().lo().s32().space().fieldReg(Field.KC_X, value).commaSpace().fieldReg(Field.CTAID_X)\n+                .commaSpace().fieldReg(Field.NTID_X).commaSpace().fieldReg(Field.TID_X).ptxNl();\n+        st().global().u32().space().address(fieldToRegMap.get(Field.KC_ADDR).name()).commaSpace().fieldReg(Field.KC_X);\n+    }\n+\n+    public void fieldStore(FieldStoreOpWrapper op) {\n+        \/\/ TODO: fix\n+        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n+    }\n+\n+    PTXCodeBuilder symbol(Op op) {\n+        return switch (op) {\n+            case CoreOp.ModOp _ -> rem();\n+            case CoreOp.MulOp _ -> mul();\n+            case CoreOp.DivOp _ -> div();\n+            case CoreOp.AddOp _ -> add();\n+            case CoreOp.SubOp _ -> sub();\n+            case CoreOp.LtOp _ -> lt();\n+            case CoreOp.GtOp _ -> gt();\n+            case CoreOp.LeOp _ -> le();\n+            case CoreOp.GeOp _ -> ge();\n+            case CoreOp.NeqOp _ -> ne();\n+            case CoreOp.EqOp _ -> eq();\n+            case CoreOp.OrOp _ -> or();\n+            case CoreOp.AndOp _ -> and();\n+            case CoreOp.XorOp _ -> xor();\n+            case CoreOp.LshlOp _ -> shl();\n+            case CoreOp.AshrOp _, CoreOp.LshrOp _ -> shr();\n+            default -> throw new IllegalStateException(\"Unexpected value\");\n+        };\n+    }\n+\n+    public void binaryOperation(BinaryArithmeticOrLogicOperation op) {\n+        symbol(op.op());\n+        if (op.resultType().toString().equals(\"float\") && op.op() instanceof CoreOp.DivOp) rn();\n+        if (!op.resultType().toString().equals(\"float\") && op.op() instanceof CoreOp.MulOp) lo();\n+        resultType(op.resultType(), true).space();\n+        resultReg(op, getResultType(op.resultType()));\n+        commaSpace();\n+        reg(op.operandNAsValue(0));\n+        commaSpace();\n+        reg(op.operandNAsValue(1));\n+    }\n+\n+    public void binaryTest(BinaryTestOpWrapper op) {\n+        setp().dot();\n+        symbol(op.op()).resultType(op.operandNAsValue(0).type(), true).space();\n+        resultReg(op, PTXRegister.Type.PREDICATE);\n+        commaSpace();\n+        reg(op.operandNAsValue(0));\n+        commaSpace();\n+        reg(op.operandNAsValue(1));\n+    }\n+\n+    public void conv(ConvOpWrapper op) {\n+        if (op.resultJavaType().equals(JavaType.LONG)) {\n+            if (isIndex(op)) {\n+                mul().wide().s32().space().resultReg(op, PTXRegister.Type.U64).commaSpace()\n+                        .reg(op.operandNAsValue(0)).commaSpace().intVal(4);\n+            } else {\n+                cvt().rn().u64().dot().regType(op.operandNAsValue(0)).space()\n+                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n+            }\n+        } else if (op.resultJavaType().equals(JavaType.FLOAT)) {\n+            cvt().rn().f32().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.operandNAsValue(0));\n+        } else if (op.resultJavaType().equals(JavaType.DOUBLE)) {\n+            cvt().rn().f64().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0));\n+        } else if (op.resultJavaType().equals(JavaType.INT)) {\n+            cvt().rn().s32().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n+        } else {\n+            cvt().rn().s32().dot().regType(op.operandNAsValue(0)).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n+        }\n+    }\n+\n+    private boolean isIndex(ConvOpWrapper op) {\n+        for (Op.Result r : op.result().uses()) {\n+            if (r.op() instanceof PTXPtrOp) return true;\n+        }\n+        return false;\n+    }\n+\n+    public void constant(ConstantOpWrapper op) {\n+        mov().resultType(op.resultType(), false).space().resultReg(op, getResultType(op.resultType())).commaSpace();\n+        if (op.resultType().toString().equals(\"float\")) {\n+            append(\"0f\");\n+            append(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n+            if (op.op().value().toString().equals(\"0.0\")) append(\"0000000\");\n+        } else {\n+            append(op.op().value().toString());\n+        }\n+    }\n+\n+    public void javaYield(YieldOpWrapper op) {\n+        exit();\n+    }\n+\n+    public void methodCall(InvokeOpWrapper op) {\n+        switch (op.methodRef().toString()) {\n+            \/\/ S32Array functions\n+            case \"hat.buffer.S32Array::array(long)int\" -> {\n+                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n+                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(temp.name(), 4);\n+            }\n+            case \"hat.buffer.S32Array::array(long, int)void\" -> {\n+                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n+                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operandNAsValue(2));\n+            }\n+            case \"hat.buffer.S32Array::length()int\" -> {\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n+            }\n+            \/\/ S32Array2D functions\n+            case \"hat.buffer.S32Array2D::array(long, int)void\" -> {\n+                PTXRegister temp = new PTXRegister(incrOrdinal(addressType()), addressType());\n+                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operandNAsValue(2));\n+            }\n+            case \"hat.buffer.S32Array2D::width()int\" -> {\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n+            }\n+            case \"hat.buffer.S32Array2D::height()int\" -> {\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name(), 4);\n+            }\n+            \/\/ Java Math functions\n+            case \"java.lang.Math::sqrt(double)double\" -> {\n+                sqrt().rn().f32().space().resultReg(op, PTXRegister.Type.F32).commaSpace().getReg(op.operandNAsValue(0)).name();\n+            }\n+            \/\/ TODO: add these\n+            case \"java.lang.Math::exp(double)double\" -> {\n+                \/*\n+                mov.f32         %f2, 0f3F000000;\n+                mov.f32         %f3, 0f3BBB989D;\n+                fma.rn.f32      %f4, %f1, %f3, %f2;\n+                mov.f32         %f5, 0f3FB8AA3B;\n+                mov.f32         %f6, 0f437C0000;\n+                cvt.sat.f32.f32         %f7, %f4;\n+                mov.f32         %f8, 0f4B400001;\n+                fma.rm.f32      %f9, %f7, %f6, %f8;\n+                add.f32         %f10, %f9, 0fCB40007F;\n+                neg.f32         %f11, %f10;\n+                fma.rn.f32      %f12, %f1, %f5, %f11;\n+                mov.f32         %f13, 0f32A57060;\n+                fma.rn.f32      %f14, %f1, %f13, %f12;\n+                mov.b32         %r6, %f9;\n+                shl.b32         %r7, %r6, 23;\n+                mov.b32         %f15, %r7;\n+                ex2.approx.ftz.f32      %f16, %f14;\n+                mul.f32         %f17, %f16, %f15;\n+                 *\/\n+            }\n+            case \"java.lang.Math::log(double)double\" -> {\n+                \/*\n+                mul.f32         %f6, %f5, 0f4B000000;\n+                setp.lt.f32     %p2, %f5, 0f00800000;\n+                selp.f32        %f1, %f6, %f5, %p2;\n+                selp.f32        %f7, 0fC1B80000, 0f00000000, %p2;\n+                mov.b32         %r6, %f1;\n+                add.s32         %r7, %r6, -1059760811;\n+                and.b32         %r8, %r7, -8388608;\n+                sub.s32         %r9, %r6, %r8;\n+                mov.b32         %f8, %r9;\n+                cvt.rn.f32.s32  %f9, %r8;\n+                mov.f32         %f10, 0f34000000;\n+                fma.rn.f32      %f11, %f9, %f10, %f7;\n+                add.f32         %f12, %f8, 0fBF800000;\n+                mov.f32         %f13, 0f3E1039F6;\n+                mov.f32         %f14, 0fBE055027;\n+                fma.rn.f32      %f15, %f14, %f12, %f13;\n+                mov.f32         %f16, 0fBDF8CDCC;\n+                fma.rn.f32      %f17, %f15, %f12, %f16;\n+                mov.f32         %f18, 0f3E0F2955;\n+                fma.rn.f32      %f19, %f17, %f12, %f18;\n+                mov.f32         %f20, 0fBE2AD8B9;\n+                fma.rn.f32      %f21, %f19, %f12, %f20;\n+                mov.f32         %f22, 0f3E4CED0B;\n+                fma.rn.f32      %f23, %f21, %f12, %f22;\n+                mov.f32         %f24, 0fBE7FFF22;\n+                fma.rn.f32      %f25, %f23, %f12, %f24;\n+                mov.f32         %f26, 0f3EAAAA78;\n+                fma.rn.f32      %f27, %f25, %f12, %f26;\n+                mov.f32         %f28, 0fBF000000;\n+                fma.rn.f32      %f29, %f27, %f12, %f28;\n+                mul.f32         %f30, %f12, %f29;\n+                fma.rn.f32      %f31, %f30, %f12, %f12;\n+                mov.f32         %f32, 0f3F317218;\n+                fma.rn.f32      %f35, %f11, %f32, %f31;\n+                setp.lt.u32     %p3, %r6, 2139095040;\n+                @%p3 bra        $L__BB0_3;\n+\n+                mov.f32         %f33, 0f7F800000;\n+                fma.rn.f32      %f35, %f1, %f33, %f33;\n+\n+        $L__BB0_3:\n+                cvta.to.global.u64      %rd4, %rd1;\n+                setp.eq.f32     %p4, %f1, 0f00000000;\n+                selp.f32        %f34, 0fFF800000, %f35, %p4;\n+                 *\/\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name(), 4);\n+            }\n+            default -> {\n+                for (int i = 0; i < op.operands().size(); i++) {\n+                    dot().param().space().paramType(op.operandNAsValue(i).type()).space().param().intVal(i).ptxNl();\n+                    st().dot().param().paramType(op.operandNAsValue(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operandNAsValue(i)).ptxNl();\n+                }\n+                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.method().getName()).commaSpace();\n+                final int[] counter = {0};\n+                paren(_ -> commaSeparated(op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n+                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n+            }\n+        }\n+    }\n+\n+    public void varDeclaration(VarDeclarationOpWrapper op) {\n+        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n+    }\n+\n+    public void varFuncDeclaration(VarFuncDeclarationOpWrapper op) {\n+        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n+    }\n+\n+    public void ret(ReturnOpWrapper op) {\n+        if (op.hasOperands()) {\n+            st().dot().param();\n+            if (returnReg.type().equals(PTXRegister.Type.U32)) {\n+                b32();\n+            } else if (returnReg.type().equals(PTXRegister.Type.U64)) {\n+                b64();\n+            } else {\n+                dot().regType(returnReg.type());\n+            }\n+            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n+        }\n+        ret();\n+    }\n+\n+    public void javaBreak(JavaBreakOpWrapper op) {\n+        brkpt();\n+    }\n+\n+    public void branch(CoreOp.BranchOp op) {\n+        loadBlockParams(op.successors().getFirst());\n+        bra().space().block(op.successors().getFirst().targetBlock());\n+    }\n+\n+    public void condBranch(CoreOp.ConditionalBranchOp op) {\n+        loadBlockParams(op.successors().getFirst());\n+        loadBlockParams(op.successors().getLast());\n+        at().reg(op.operands().getFirst()).space()\n+                .bra().space().block(op.successors().getFirst().targetBlock()).ptxNl();\n+        bra().space().block(op.successors().getLast().targetBlock());\n+    }\n+\n+    public void neg(CoreOp.NegOp op) {\n+        neg().resultType(op.resultType(), true).space().reg(op.result(), getResultType(op.resultType())).commaSpace().reg(op.operands().getFirst());\n+    }\n+\n+    \/*\n+     * Helper functions for printing blocks and variables\n+     *\/\n+\n+    public void loadBlockParams(Block.Reference block) {\n+        for (int i = 0; i < block.arguments().size(); i++) {\n+            Block.Parameter p = block.targetBlock().parameters().get(i);\n+            mov().resultType(p.type(), false).space().reg(p, getResultType(p.type()))\n+                    .commaSpace().reg(block.arguments().get(i)).ptxNl();\n+        }\n+    }\n+\n+    public PTXCodeBuilder block(Block block) {\n+        return append(\"block_\").intVal(block.index());\n+    }\n+\n+    public PTXCodeBuilder fieldReg(Field ref) {\n+        if (fieldToRegMap.containsKey(ref)) {\n+            return regName(fieldToRegMap.get(ref));\n+        }\n+        if (ref.isDestination()) {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(addressType()), addressType()));\n+        } else {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(incrOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n+        }\n+        return regName(fieldToRegMap.get(ref));\n+    }\n+\n+    public PTXCodeBuilder fieldReg(Field ref, Value value) {\n+        if (fieldToRegMap.containsKey(ref)) {\n+            return regName(fieldToRegMap.get(ref));\n+        }\n+        if (ref.isDestination()) {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(addressType()), addressType()));\n+            return reg(value, addressType());\n+        } else {\n+            fieldToRegMap.putIfAbsent(ref, new PTXRegister(getOrdinal(PTXRegister.Type.U32), PTXRegister.Type.U32));\n+            return reg(value, PTXRegister.Type.U32);\n+        }\n+    }\n+\n+    public Field getFieldObj(String fieldName) {\n+        for (Field f : fieldToRegMap.keySet()) {\n+            if (f.toString().equals(fieldName)) return f;\n+        }\n+        throw new IllegalStateException(\"no existing field\");\n+    }\n+\n+    public PTXCodeBuilder resultReg(OpWrapper<?> opWrapper, PTXRegister.Type type) {\n+        return append(addReg(opWrapper.result(), type));\n+    }\n+\n+    public PTXCodeBuilder reg(Value val, PTXRegister.Type type) {\n+        if (varToRegMap.containsKey(val)) {\n+            return regName(getReg(val));\n+        } else {\n+            return append(addReg(val, type));\n+        }\n+    }\n+\n+    public PTXCodeBuilder reg(Value val) {\n+        return regName(getReg(val));\n+    }\n+\n+    public PTXRegister getReg(Value val) {\n+        if (varToRegMap.get(val) == null && val instanceof Op.Result result && result.op() instanceof CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+            return fieldToRegMap.get(getFieldObj(fieldLoadOp.fieldDescriptor().name()));\n+        }\n+        if (varToRegMap.containsKey(val)) {\n+            return varToRegMap.get(val);\n+        } else {\n+            throw new IllegalStateException(\"var to reg mapping doesn't exist\");\n+        }\n+    }\n+\n+    public String addReg(Value val, PTXRegister.Type type) {\n+        if (varToRegMap.containsKey(val)) {\n+            return varToRegMap.get(val).name();\n+        }\n+        varToRegMap.put(val, new PTXRegister(incrOrdinal(type), type));\n+        return varToRegMap.get(val).name();\n+    }\n+\n+    public Integer getOrdinal(PTXRegister.Type type) {\n+        ordinalMap.putIfAbsent(type, 1);\n+        return ordinalMap.get(type);\n+    }\n+\n+    public Integer incrOrdinal(PTXRegister.Type type) {\n+        ordinalMap.putIfAbsent(type, 1);\n+        int out = ordinalMap.get(type);\n+        ordinalMap.put(type, out + 1);\n+        return out;\n+    }\n+\n+    public PTXCodeBuilder size() {\n+        return (addressSize == 32) ? u32() : u64();\n+    }\n+\n+    public PTXRegister.Type addressType() {\n+        return (addressSize == 32) ? PTXRegister.Type.U32 : PTXRegister.Type.U64;\n+    }\n+\n+    public PTXCodeBuilder resultType(TypeElement type, boolean signedResult) {\n+        PTXRegister.Type res = getResultType(type);\n+        if (signedResult && (res == PTXRegister.Type.U32)) return s32();\n+        return dot().append(getResultType(type).getName());\n+    }\n+\n+    public PTXCodeBuilder paramType(TypeElement type) {\n+        PTXRegister.Type res = getResultType(type);\n+        if (res == PTXRegister.Type.U32) return b32();\n+        if (res == PTXRegister.Type.U64) return b64();\n+        return dot().append(getResultType(type).getName());\n+    }\n+\n+    public PTXRegister.Type getResultType(TypeElement type) {\n+        switch (type.toString()) {\n+            case \"float\" -> {\n+                return PTXRegister.Type.F32;\n+            }\n+            case \"int\" -> {\n+                return PTXRegister.Type.U32;\n+            }\n+            case \"boolean\" -> {\n+                return PTXRegister.Type.PREDICATE;\n+            }\n+            default -> {\n+                return PTXRegister.Type.U64;\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Basic CodeBuilder functions\n+     *\/\n+\n+    \/\/ used for parameter list\n+    \/\/ prints out items separated by a comma then new line\n+    public <I> PTXCodeBuilder commaNlSeparated(Iterable<I> iterable, Consumer<I> c) {\n+        StreamCounter.of(iterable, (counter, t) -> {\n+            if (counter.isNotFirst()) {\n+                comma().nl();\n+            }\n+            c.accept(t);\n+        });\n+        return self();\n+    }\n+\n+    public PTXCodeBuilder address(String address) {\n+        return osbrace().append(address).csbrace();\n+    }\n+\n+    public PTXCodeBuilder address(String address, int offset) {\n+        osbrace().append(address);\n+        if (offset == 0) {\n+            return csbrace();\n+        } else if (offset > 0) {\n+            plus();\n+        }\n+        return intVal(offset).csbrace();\n+    }\n+\n+    public void ptxNl() {\n+        semicolon().nl().ptxIndent();\n+    }\n+\n+    public PTXCodeBuilder commaSpace() {\n+        return comma().space();\n+    }\n+\n+    public PTXCodeBuilder param() {\n+        return append(\"param\");\n+    }\n+\n+    public PTXCodeBuilder global() {\n+        return dot().append(\"global\");\n+    }\n+\n+    public PTXCodeBuilder rn() {\n+        return dot().append(\"rn\");\n+    }\n+\n+    public PTXCodeBuilder to() {\n+        return dot().append(\"to\");\n+    }\n+\n+    public PTXCodeBuilder lo() {\n+        return dot().append(\"lo\");\n+    }\n+\n+    public PTXCodeBuilder wide() {\n+        return dot().append(\"wide\");\n+    }\n+\n+    public PTXCodeBuilder uni() {\n+        return dot().append(\"uni\");\n+    }\n+\n+    public PTXCodeBuilder mov() {\n+        return append(\"mov\");\n+    }\n+\n+    public PTXCodeBuilder setp() {\n+        return append(\"setp\");\n+    }\n+\n+    public PTXCodeBuilder ld() {\n+        return append(\"ld\");\n+    }\n+\n+    public PTXCodeBuilder st() {\n+        return append(\"st\");\n+    }\n+\n+    public PTXCodeBuilder cvt() {\n+        return append(\"cvt\");\n+    }\n+\n+    public PTXCodeBuilder bra() {\n+        return append(\"bra\");\n+    }\n+\n+    public PTXCodeBuilder ret() {\n+        return append(\"ret\");\n+    }\n+\n+    public PTXCodeBuilder rem() {\n+        return append(\"rem\");\n+    }\n+\n+    public PTXCodeBuilder mul() {\n+        return append(\"mul\");\n+    }\n+\n+    public PTXCodeBuilder div() {\n+        return append(\"div\");\n+    }\n+\n+    public PTXCodeBuilder add() {\n+        return append(\"add\");\n+    }\n+\n+    public PTXCodeBuilder sub() {\n+        return append(\"sub\");\n+    }\n+\n+    public PTXCodeBuilder lt() {\n+        return append(\"lt\");\n+    }\n+\n+    public PTXCodeBuilder gt() {\n+        return append(\"gt\");\n+    }\n+\n+    public PTXCodeBuilder le() {\n+        return append(\"le\");\n+    }\n+\n+    public PTXCodeBuilder ge() {\n+        return append(\"ge\");\n+    }\n+\n+    public PTXCodeBuilder ne() {\n+        return append(\"ne\");\n+    }\n+\n+    public PTXCodeBuilder eq() {\n+        return append(\"eq\");\n+    }\n+\n+    public PTXCodeBuilder xor() {\n+        return append(\"xor\");\n+    }\n+\n+    public PTXCodeBuilder or() {\n+        return append(\"or\");\n+    }\n+\n+    public PTXCodeBuilder and() {\n+        return append(\"and\");\n+    }\n+\n+    public PTXCodeBuilder cvta() {\n+        return append(\"cvta\");\n+    }\n+\n+    public PTXCodeBuilder mad() {\n+        return append(\"mad\");\n+    }\n+\n+    public PTXCodeBuilder sqrt() {\n+        return append(\"sqrt\");\n+    }\n+\n+    public PTXCodeBuilder shl() {\n+        return append(\"shl\");\n+    }\n+\n+    public PTXCodeBuilder shr() {\n+        return append(\"shr\");\n+    }\n+\n+    public PTXCodeBuilder neg() {\n+        return append(\"neg\");\n+    }\n+\n+    public PTXCodeBuilder call() {\n+        return append(\"call\");\n+    }\n+\n+    public PTXCodeBuilder exit() {\n+        return append(\"exit\");\n+    }\n+\n+    public PTXCodeBuilder brkpt() {\n+        return append(\"brkpt\");\n+    }\n+\n+    public PTXCodeBuilder ptxIndent() {\n+        return append(\"    \");\n+    }\n+\n+    public PTXCodeBuilder u32() {\n+        return dot().append(PTXRegister.Type.U32.getName());\n+    }\n+\n+    public PTXCodeBuilder s32() {\n+        return dot().append(PTXRegister.Type.S32.getName());\n+    }\n+\n+    public PTXCodeBuilder f32() {\n+        return dot().append(PTXRegister.Type.F32.getName());\n+    }\n+\n+    public PTXCodeBuilder b32() {\n+        return dot().append(PTXRegister.Type.B32.getName());\n+    }\n+\n+    public PTXCodeBuilder u64() {\n+        return dot().append(PTXRegister.Type.U64.getName());\n+    }\n+\n+    public PTXCodeBuilder s64() {\n+        return dot().append(PTXRegister.Type.S64.getName());\n+    }\n+\n+    public PTXCodeBuilder f64() {\n+        return dot().append(PTXRegister.Type.F64.getName());\n+    }\n+\n+    public PTXCodeBuilder b64() {\n+        return dot().append(PTXRegister.Type.B64.getName());\n+    }\n+\n+    public PTXCodeBuilder version() {\n+        return dot().append(\"version\");\n+    }\n+\n+    public PTXCodeBuilder target() {\n+        return dot().append(\"target\");\n+    }\n+\n+    public PTXCodeBuilder addressSize() {\n+        return dot().append(\"address_size\");\n+    }\n+\n+    public PTXCodeBuilder major(int major) {\n+        return intVal(major);\n+    }\n+\n+    public PTXCodeBuilder minor(int minor) {\n+        return intVal(minor);\n+    }\n+\n+    public PTXCodeBuilder target(String target) {\n+        return append(target);\n+    }\n+\n+    public PTXCodeBuilder size(int addressSize) {\n+        return intVal(addressSize);\n+    }\n+\n+    public PTXCodeBuilder funcName(String funcName) {\n+        return append(funcName);\n+    }\n+\n+    public PTXCodeBuilder visible() {\n+        return dot().append(\"visible\");\n+    }\n+\n+    public PTXCodeBuilder entry() {\n+        return dot().append(\"entry\");\n+    }\n+\n+    public PTXCodeBuilder func() {\n+        return dot().append(\"func\");\n+    }\n+\n+    public PTXCodeBuilder oabrace() {\n+        return append(\"<\");\n+    }\n+\n+    public PTXCodeBuilder cabrace() {\n+        return append(\">\");\n+    }\n+\n+    public PTXCodeBuilder regName(PTXRegister reg) {\n+        return append(reg.name());\n+    }\n+\n+    public PTXCodeBuilder regName(String regName) {\n+        return append(regName);\n+    }\n+\n+    public PTXCodeBuilder regType(Value val) {\n+        return append(getReg(val).type().getName());\n+    }\n+\n+    public PTXCodeBuilder regType(PTXRegister.Type t) {\n+        return append(t.getName());\n+    }\n+\n+    public PTXCodeBuilder regTypePrefix(PTXRegister.Type t) {\n+        return append(t.getRegPrefix());\n+    }\n+\n+    public PTXCodeBuilder reg() {\n+        return dot().append(\"reg\");\n+    }\n+\n+    public PTXCodeBuilder retVal() {\n+        return append(\"retval\");\n+    }\n+\n+    public PTXCodeBuilder intVal(int i) {\n+        return append(String.valueOf(i));\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXCodeBuilder.java","additions":952,"deletions":0,"binary":false,"changes":952,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend;\n+\n+import hat.ifacemapper.Schema;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.util.List;\n+\n+public class PTXPtrOp extends ExternalizableOp {\n+    public String fieldName;\n+    public static final String NAME = \"ptxPtr\";\n+    final TypeElement resultType;\n+    public Schema<?> schema;\n+\n+    PTXPtrOp(TypeElement resultType, String fieldName, List<Value> operands, Schema<?> schema) {\n+        super(NAME, operands);\n+        this.resultType = resultType;\n+        this.fieldName = fieldName;\n+        this.schema = schema;\n+    }\n+\n+    PTXPtrOp(PTXPtrOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.resultType = that.resultType;\n+        this.fieldName = that.fieldName;\n+        this.schema = that.schema;\n+    }\n+\n+    @Override\n+    public PTXPtrOp transform(CopyContext cc, OpTransformer ot) {\n+        return new PTXPtrOp(this, cc);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+}\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXPtrOp.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend;\n+\n+public class PTXRegister {\n+    private String name;\n+    private final Type type;\n+\n+    public enum Type {\n+        S8 (8, BasicType.SIGNED, \"s8\", \"%s\"),\n+        S16 (16, BasicType.SIGNED, \"s16\", \"%s\"),\n+        S32 (32, BasicType.SIGNED, \"s32\", \"%s\"),\n+        S64 (64, BasicType.SIGNED, \"s64\", \"%sd\"),\n+        U8 (8, BasicType.UNSIGNED, \"u8\", \"%r\"),\n+        U16 (16, BasicType.UNSIGNED, \"u16\", \"%r\"),\n+        U32 (32, BasicType.UNSIGNED, \"u32\", \"%r\"),\n+        U64 (64, BasicType.UNSIGNED, \"u64\", \"%rd\"),\n+        F16 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n+        F16X2 (16, BasicType.FLOATING, \"f16\", \"%f\"),\n+        F32 (32, BasicType.FLOATING, \"f32\", \"%f\"),\n+        F64 (64, BasicType.FLOATING, \"f64\", \"%fd\"),\n+        B8 (8, BasicType.BIT, \"b8\", \"%b\"),\n+        B16 (16, BasicType.BIT, \"b16\", \"%b\"),\n+        B32 (32, BasicType.BIT, \"b32\", \"%b\"),\n+        B64 (64, BasicType.BIT, \"b64\", \"%bd\"),\n+        B128 (128, BasicType.BIT, \"b128\", \"%b\"),\n+        PREDICATE (1, BasicType.PREDICATE, \"pred\", \"%p\");\n+\n+        public enum BasicType {\n+            SIGNED,\n+            UNSIGNED,\n+            FLOATING,\n+            BIT,\n+            PREDICATE\n+        }\n+\n+        private final int size;\n+        private final BasicType basicType;\n+        private final String name;\n+        private final String regPrefix;\n+\n+        Type(int size, BasicType type, String name, String regPrefix) {\n+            this.size = size;\n+            this.basicType = type;\n+            this.name = name;\n+            this.regPrefix = regPrefix;\n+        }\n+\n+        public int getSize() {\n+            return this.size;\n+        }\n+\n+        public BasicType getBasicType() {\n+            return this.basicType;\n+        }\n+\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        public String getRegPrefix() {\n+            return this.regPrefix;\n+        }\n+    }\n+\n+    public PTXRegister(int num, Type type) {\n+        this.type = type;\n+        this.name = type.regPrefix + num;\n+    }\n+\n+    public String name() {\n+        return this.name;\n+    }\n+\n+    public void name(String name) {\n+        this.name = name;\n+    }\n+\n+    public Type type() {\n+        return this.type;\n+    }\n+}\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXRegister.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F32Array;\n+import hat.buffer.S32Array;\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class BlackScholes {\n+\n+    @CodeReflection\n+    public static void blackScholesKernel(KernelContext kc, F32Array f32Array, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n+        if (kc.x<kc.maxX){\n+            float S = sArray.array(kc.x);\n+            float X = xArray.array(kc.x);\n+            float T = tArray.array(kc.x);\n+            float d1 = (float) ((Math.log(S \/ X) + (r + v * v * .5f) * T) \/ (v * Math.sqrt(T)));\n+            float d2 = (float) (d1 - v * Math.sqrt(T));\n+            float value = (float) (S * CND(d1) - X * Math.exp(-r * T) * CND(d2));\n+            f32Array.array(kc.x, value);\n+            \/\/put[i]  = call[i] + (float)Math.exp(-r * t[i]) - s0[i];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static float CND(float input) {\n+        float x = input;\n+        if (input < 0f) {\n+            x = -input;\n+        }\n+\n+        float term = 1f \/ (1f + (0.2316419f * x));\n+        float term_pow2 = term * term;\n+        float term_pow3 = term_pow2 * term;\n+        float term_pow4 = term_pow2 * term_pow2;\n+        float term_pow5 = term_pow2 * term_pow3;\n+\n+        float part1 = (1f \/ (float)Math.sqrt(2f * 3.1415926535f)) * (float)Math.exp((-x * x) * 0.5f);\n+\n+        float part2 = (0.31938153f * term) +\n+                (-0.356563782f * term_pow2) +\n+                (1.781477937f * term_pow3) +\n+                (-1.821255978f * term_pow4) +\n+                (1.330274429f * term_pow5);\n+\n+        if (input >= 0f) {\n+            return 1f - part1 * part2;\n+        } else {\n+            return part1 * part2;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void blackScholes(ComputeContext cc, F32Array f32Array, F32Array S, F32Array X, F32Array T, float r, float v) {\n+        cc.dispatchKernel(f32Array.length(),\n+                kc -> blackScholesKernel(kc, f32Array, S, X, T, r, v)\n+        );\n+    }\n+\n+    public static void main(String[] args) {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = F32Array.create(accelerator, 32);\n+\/\/        s0 = fillRandom(5.0f, 30.0f);\n+\/\/        x  = fillRandom(1.0f, 100.0f);\n+\/\/        t  = fillRandom(0.25f, 10.0f);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+\n+        var S = F32Array.create(accelerator, 32);\n+        for (int i = 0; i < S.length(); i++) {\n+            S.array(i, i + 5);\n+        }\n+\n+        var X = F32Array.create(accelerator, 32);\n+        for (int i = 0; i < X.length(); i++) {\n+            X.array(i, i + 1);\n+        }\n+\n+        var T = F32Array.create(accelerator, 32);\n+        for (int i = 0; i < T.length(); i++) {\n+            T.array(i, (float) (i + 1) \/4);\n+        }\n+        float r = 0.02f;\n+        float v = 0.30f;\n+\n+        accelerator.compute(\n+                cc -> BlackScholes.blackScholes(cc, arr, S, X, T, r, v)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            System.out.println(\"S=\" + S.array(i) + \"\\t X=\" + X.array(i) + \"\\t T=\" + T.array(i) + \"\\t call option price = \" + arr.array(i));\n+        }\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/BlackScholes.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}