{"files":[{"patch":"@@ -231,0 +231,2 @@\n+        kernelCallGraph.analyseFinalValues();\n+\n@@ -233,1 +235,1 @@\n-                        kernelCallGraph.entrypoint.funcOp());\n+                        kernelCallGraph.entrypoint.funcOp(), kernelCallGraph.finalVarOps());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.CodeElement;\n@@ -31,0 +32,1 @@\n+import jdk.incubator.code.Value;\n@@ -44,0 +46,26 @@\n+    public Map<Op.Result, CoreOp.VarOp> finalVarOps;\n+\n+    public void analyseFinalValues() {\n+        CoreOp.FuncOp kernelEntry = entrypoint.funcOp();\n+        Stream<CodeElement<?, ?>> elements = kernelEntry.elements();\n+        Map<Op.Result, CoreOp.VarOp> finalVars = new HashMap<>();\n+        elements.forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.VarOp varOp) {\n+                \/\/ obtain the result of the varOp\n+                Op.Result varResult = varOp.result();\n+                finalVars.put(varResult, varOp);\n+            } else if (codeElement instanceof CoreOp.VarAccessOp.VarStoreOp storeOp) {\n+                List<Value> operands = storeOp.operands();\n+                operands.stream().filter(finalVars::containsKey).forEach(finalVars::remove);\n+            } else if (codeElement instanceof CoreOp.YieldOp yieldOp) {\n+                List<Value> operands = yieldOp.operands();\n+                operands.stream().filter(finalVars::containsKey).forEach(finalVars::remove);\n+            }\n+        });\n+        finalVarOps = new HashMap<>(finalVars);\n+    }\n+\n+    public Map<Op.Result, CoreOp.VarOp> finalVarOps() {\n+        return finalVarOps;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+\n@@ -42,0 +43,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilderContext.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n@@ -77,2 +79,0 @@\n-\n-\n@@ -92,0 +92,3 @@\n+        if (buildContext.isVarOpFinal(varOp)) {\n+            constKeyword().space();\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.jdi.event.ClassPrepareEvent;\n@@ -221,0 +222,1 @@\n+\n@@ -224,0 +226,10 @@\n+\n+    private Map<Op.Result, CoreOp.VarOp> finalVarOps = new HashMap<>();\n+    public ScopedCodeBuilderContext(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, Map<Op.Result, CoreOp.VarOp> varOpFinals) {\n+        super(lookup,funcOp);\n+        this.finalVarOps = varOpFinals;\n+    }\n+\n+    public boolean isVarOpFinal(CoreOp.VarOp varOp) {\n+        return finalVarOps.containsKey(varOp.result());\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-                \"oracle.code.hat.TestReductions\"\n+                \"oracle.code.hat.TestReductions\",\n+                \"oracle.code.hat.TestConstants\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.*;\n+\n+public class TestConstants {\n+\n+    public static final int CONSTANT = 100;\n+\n+    @CodeReflection\n+    public static void vectorWithConstants(@RO KernelContext kc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        final int BM = 100;\n+        if (kc.x < kc.gsx) {\n+            final int valueA = arrayA.array(kc.x);\n+            final int valueB = arrayB.array(kc.x);\n+            arrayC.array(kc.x, (BM + valueA + valueB));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorWithConstants(@RO ComputeContext cc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n+        cc.dispatchKernel(computeRange, kc -> vectorWithConstants(kc, arrayA, arrayB, arrayC));\n+    }\n+\n+    @HatTest\n+    public static void testConstants() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = S32Array.create(accelerator, size);\n+        var arrayB = S32Array.create(accelerator, size);\n+        var arrayC = S32Array.create(accelerator, size);\n+\n+        arrayA.fill(i -> i);\n+        arrayB.fill(i -> 100 + i);\n+\n+        accelerator.compute(cc ->\n+                TestConstants.vectorWithConstants(cc, arrayA, arrayB, arrayC));\n+\n+        S32Array test = S32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, CONSTANT + arrayA.array(i) + arrayB.array(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HatAsserts.assertEquals(test.array(i), arrayC.array(i));\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestConstants.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}