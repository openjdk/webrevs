{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import hat.phases.HatFinalDetectionPhase;\n@@ -46,0 +47,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -234,1 +236,1 @@\n-            System.out.println(\"NOT using ModuleOp for C99FFIBackend\");\n+            IO.println(\"NOT using ModuleOp for C99FFIBackend\");\n@@ -236,5 +238,7 @@\n-                    .forEach(kernelReachableResolvedMethod ->\n-                            builder\n-                                    .nl()\n-                                    .kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp())\n-                                    .nl());\n+                    .forEach(kernelReachableResolvedMethod -> {\n+                                HatFinalDetectionPhase finals = new HatFinalDetectionPhase();\n+                                finals.apply(kernelReachableResolvedMethod.funcOp());\n+                                \/\/ Update the build context for this method to use the right constants-map\n+                                buildContext.setFinals(finals.getFinalVars());\n+                                builder.nl().kernelMethod(buildContext, kernelReachableResolvedMethod.funcOp()).nl();\n+                    });\n@@ -242,1 +246,1 @@\n-          System.out.println(\"Using ModuleOp for C99FFIBackend\");\n+            IO.println(\"Using ModuleOp for C99FFIBackend\");\n@@ -244,4 +248,9 @@\n-                    .forEach((_, funcOp) -> builder\n-                            .nl()\n-                            .kernelMethod(buildContext,funcOp)\n-                            .nl());\n+                    .forEach((_, funcOp) -> {\n+\n+                        HatFinalDetectionPhase finals = new HatFinalDetectionPhase();\n+                        finals.apply(funcOp);\n+\n+                        \/\/ Update the build context for this method to use the right constants-map\n+                        buildContext.setFinals(finals.getFinalVars());\n+                        builder.nl().kernelMethod(buildContext, funcOp).nl();\n+                    });\n@@ -250,0 +259,4 @@\n+        \/\/ Update the constants-map for the main kernel\n+        HatFinalDetectionPhase hatFinalDetectionPhase = new HatFinalDetectionPhase();\n+        hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n+        buildContext.setFinals(hatFinalDetectionPhase.getFinalVars());\n@@ -253,4 +266,4 @@\n-            System.out.println(\"Original\");\n-            System.out.println(kernelCallGraph.entrypoint.funcOp().toText());\n-            System.out.println(\"Lowered\");\n-            System.out.println(OpTk.lower(kernelCallGraph.entrypoint.funcOp()).toText());\n+            IO.println(\"Original\");\n+            IO.println(kernelCallGraph.entrypoint.funcOp().toText());\n+            IO.println(\"Lowered\");\n+            IO.println(OpTk.lower(kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -52,6 +52,1 @@\n-import java.util.ArrayList;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.*;\n@@ -192,292 +187,0 @@\n-    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n-    }\n-\n-    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n-    }\n-\n-    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n-    }\n-\n-    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n-    }\n-\n-    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n-    }\n-\n-    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = context.getValues(inputOperands);\n-        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n-        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n-        Op.Result inputResult = invokeOp.result();\n-        context.mapValue(inputResult, outputResult);\n-    }\n-\n-    public CoreOp.FuncOp dialectifyToHatBarriers(CoreOp.FuncOp funcOp) {\n-        Stream<CodeElement<?, ?>> elements = funcOp\n-                .elements()\n-                .mapMulti((element, consumer) -> {\n-                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n-                            consumer.accept(invokeOp);\n-                        }\n-                    }\n-                });\n-        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n-        if (collect.isEmpty()) {\n-            \/\/ Return the function with no modifications\n-            return funcOp;\n-        }\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!collect.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createBarrierNodeOp(context, invokeOp, blockBuilder);\n-            }\n-            return blockBuilder;\n-        });\n-        \/\/ System.out.println(\"[INFO] Code model: \" + funcOp.toText());\n-        \/\/entrypoint.funcOp(funcOp);\n-        return funcOp;\n-    }\n-\n-    public CoreOp.FuncOp dialectifyToHatMemorySpace(CoreOp.FuncOp funcOp, Space memorySpace) {\n-\n-        String nameNode = switch (memorySpace) {\n-            case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n-            case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n-        };\n-\n-        \/\/IO.println(\"ORIGINAL: \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (OpTk.isIfaceBufferMethod(computeContext.accelerator.lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n-                                        \/\/ It is the node we are looking for\n-                                        consumer.accept(invokeOp);\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            \/\/ No memory nodes involved\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node\n-                Op.Result result = invokeOp.result();\n-                List<Op.Result> collect = result.uses().stream().toList();\n-                for (Op.Result r : collect) {\n-                    if (r.op() instanceof CoreOp.VarOp varOp) {\n-                        \/\/ That's the node we want\n-                        List<Value> inputOperandsVarOp = invokeOp.operands();\n-                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                        HatMemoryOp memoryOp = switch (memorySpace) {\n-                            case SHARED ->\n-                                    new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                            default ->\n-                                    new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                        };\n-                        Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n-                        context.mapValue(invokeOp.result(), hatLocalResult);\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarOp varOp) {\n-                \/\/ pass value\n-                context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-        \/\/ IO.println(\"[INFO] Code model: \" + funcOp.toText());\n-        \/\/entrypoint.funcOp(funcOp);\n-        return funcOp;\n-    }\n-\n-    private enum Space {\n-        PRIVATE,\n-        SHARED,\n-    }\n-\n-    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        String fieldName = fieldLoadOp.fieldDescriptor().name();\n-        switch (threadAccess) {\n-            case GLOBAL_ID -> {\n-                if (fieldName.equals(\"y\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"z\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case GLOBAL_SIZE -> {\n-                if (fieldName.equals(\"gsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"gsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case LOCAL_ID -> {\n-                if (fieldName.equals(\"liy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lyz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case LOCAL_SIZE -> {\n-                if (fieldName.equals(\"lsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case BLOCK_ID ->  {\n-                if (fieldName.equals(\"biy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"biz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public CoreOp.FuncOp dialectifyToHatThreadIds(CoreOp.FuncOp funcOp, ThreadAccess threadAccess) {\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                        List<Value> operands = fieldLoadOp.operands();\n-                        for (Value inputOperand : operands) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                    boolean isThreadIntrinsic = switch (threadAccess) {\n-                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n-                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n-                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n-                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n-                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n-                                    };\n-                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n-                                        consumer.accept(fieldLoadOp);\n-                                        consumer.accept(varLoadOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            \/\/ No memory nodes involved\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                List<Value> operands = fieldLoadOp.operands();\n-                for (Value operand : operands) {\n-                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> varLoadOperands = varLoadOp.operands();\n-                        List<Value> outputOperands = context.getValues(varLoadOperands);\n-                        int dim = getDimension(threadAccess, fieldLoadOp);\n-                        if (dim < 0) {\n-                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n-                        }\n-                        HatThreadOP threadOP = switch (threadAccess) {\n-                            case GLOBAL_ID -> new HatGlobalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case GLOBAL_SIZE -> new HatGlobalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case LOCAL_ID -> new HatLocalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case LOCAL_SIZE -> new HatLocalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case BLOCK_ID -> new HatBlockThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                        };\n-                        Op.Result threadResult = blockBuilder.op(threadOP);\n-                        context.mapValue(fieldLoadOp.result(), threadResult);\n-                    }\n-                }\n-            }\n-            return blockBuilder;\n-        });\n-        \/\/IO.println(\"[INFO] Code model: \" + funcOp.toText());\n-        \/\/entrypoint.funcOp(funcOp);\n-        return funcOp;\n-    }\n-\n-    private enum ThreadAccess {\n-        GLOBAL_ID,\n-        GLOBAL_SIZE,\n-        LOCAL_ID,\n-        LOCAL_SIZE,\n-        BLOCK_ID,\n-    }\n-\n-    private CoreOp.FuncOp dialectifyToHat(CoreOp.FuncOp funcOp) {\n-        CoreOp.FuncOp f = dialectifyToHatBarriers(funcOp);\n-        for (Space space : Space.values()) {\n-            f = dialectifyToHatMemorySpace(f, space);\n-        }\n-        for (ThreadAccess threadAccess : ThreadAccess.values()) {\n-            f = dialectifyToHatThreadIds(f, threadAccess);\n-        }\n-        return f;\n-    }\n-\n@@ -487,1 +190,0 @@\n-\n@@ -496,1 +198,1 @@\n-\/\/        \/\/ Reachable functions\n+        \/\/ Reachable functions\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":300,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+\n@@ -42,0 +43,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilderContext.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n@@ -81,0 +83,3 @@\n+        if (buildContext.isVarOpFinal(varOp)) {\n+            constKeyword().space();\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\n@@ -226,0 +227,1 @@\n+\n@@ -229,0 +231,10 @@\n+\n+    private Map<Op.Result, CoreOp.VarOp> finalVarOps = new HashMap<>();\n+\n+    public void setFinals(Map<Op.Result, CoreOp.VarOp> finalVars) {\n+        this.finalVarOps = finalVars;\n+    }\n+\n+    public boolean isVarOpFinal(CoreOp.VarOp varOp) {\n+        return finalVarOps.containsKey(varOp.result());\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.ifacemapper.MappableIface;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+public class HatFinalDetectionPhase implements HatPhase {\n+\n+    private final Map<Op.Result, CoreOp.VarOp> finalVars = new HashMap<>();\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements();\n+        elements.forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.VarOp varOp) {\n+                Op.Result varResult = varOp.result();\n+                Set<Op.Result> uses = varResult.uses();\n+\n+                \/\/ Obtain if the varOp comes from a declaration of\n+                \/\/ a var with MappableIface type. If so, we can't\n+                \/\/ generate the constant, because at this point of the analysis\n+                \/\/ after the dialectify, the only accesses left are accesses\n+                \/\/ to global memory.\n+                TypeElement typeElement = varOp.resultType().valueType();\n+                boolean isMappableType = false;\n+                if (typeElement instanceof JavaType javaType) {\n+                    isMappableType = OpTk.isAssignable(MethodHandles.lookup(), javaType, MappableIface.class);\n+                }\n+\n+                if (!isMappableType) {\n+                    boolean isFinalVarOp = true;\n+                    for (Op.Result use : uses) {\n+                        Op op = use.op();\n+                        switch (op) {\n+                            case CoreOp.VarAccessOp.VarStoreOp storeOp -> {\n+                                if (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                                    isFinalVarOp = false;\n+                                }\n+                            }\n+                            case CoreOp.YieldOp yieldOp -> {\n+                                if (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                                    isFinalVarOp = false;\n+                                }\n+                            }\n+                            case null, default -> {\n+                            }\n+                        }\n+                    }\n+                    if (isFinalVarOp) {\n+                        finalVars.put(varResult, varOp);\n+                    }\n+                }\n+            }\n+        });\n+        return funcOp;\n+    }\n+\n+    public Map<Op.Result, CoreOp.VarOp> getFinalVars() {\n+        return finalVars;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatFinalDetectionPhase.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -29,4 +29,2 @@\n-public interface HatDialectifyPhase {\n-\n-    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n-\n+public interface HatPhase {\n+    CoreOp.FuncOp apply(CoreOp.FuncOp funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatPhase.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyPhase.java","status":"copied"},{"patch":"@@ -215,1 +215,1 @@\n-                           Stream.of( \"Arrays\", \"MatMul\", \"Mandel\", \"Local\", \"Reductions\", \"Private\", \"Parenthesis\")\n+                           Stream.of( \"Arrays\", \"MatMul\", \"Mandel\", \"Local\", \"Reductions\", \"Private\", \"Parenthesis\", \"Costants\")\n","filename":"hat\/hat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,1 +173,2 @@\n-                \"oracle.code.hat.TestParenthesis\"\n+                \"oracle.code.hat.TestParenthesis\",\n+                \"oracle.code.hat.TestConstants\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.*;\n+\n+public class TestConstants {\n+\n+    public static final int CONSTANT = 100;\n+\n+    @CodeReflection\n+    public static void vectorWithConstants(@RO KernelContext kc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        final int BM = 100;\n+        if (kc.x < kc.gsx) {\n+            final int valueA = arrayA.array(kc.x);\n+            final int valueB = arrayB.array(kc.x);\n+            arrayC.array(kc.x, (BM + valueA + valueB));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorWithConstants(@RO ComputeContext cc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n+        cc.dispatchKernel(computeRange, kc -> vectorWithConstants(kc, arrayA, arrayB, arrayC));\n+    }\n+\n+    \/**\n+     * Test to check if final values are represented in the generated code.\n+     *\/\n+    @HatTest\n+    public static void testConstants01() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = S32Array.create(accelerator, size);\n+        var arrayB = S32Array.create(accelerator, size);\n+        var arrayC = S32Array.create(accelerator, size);\n+\n+        arrayA.fill(i -> i);\n+        arrayB.fill(i -> 100 + i);\n+\n+        accelerator.compute(cc ->\n+                TestConstants.vectorWithConstants(cc, arrayA, arrayB, arrayC));\n+\n+        S32Array test = S32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, CONSTANT + arrayA.array(i) + arrayB.array(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HatAsserts.assertEquals(test.array(i), arrayC.array(i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static int compute(final int valueA, final int valueB) {\n+        final int BM = 100;\n+        return BM + valueA + valueB;\n+    }\n+\n+    @CodeReflection\n+    public static void vectorWithConstants2(@RO KernelContext kc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        if (kc.x < kc.gsx) {\n+            final int valueA = arrayA.array(kc.x);\n+            final int valueB = arrayB.array(kc.x);\n+            final int result = compute(valueA, valueB);\n+            arrayC.array(kc.x, result);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorWithConstants2(@RO ComputeContext cc, @RO S32Array arrayA, @RO S32Array arrayB, @RW S32Array arrayC) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(arrayA.length()));\n+        cc.dispatchKernel(computeRange, kc -> vectorWithConstants2(kc, arrayA, arrayB, arrayC));\n+    }\n+\n+    \/**\n+     * Test to check multiple method calls that contains constants.\n+     * This triggers the code model analysis for each of the reachable method before the\n+     * final code gen.\n+     *\/\n+    @HatTest\n+    public static void testConstants02() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = S32Array.create(accelerator, size);\n+        var arrayB = S32Array.create(accelerator, size);\n+        var arrayC = S32Array.create(accelerator, size);\n+\n+        arrayA.fill(i -> i);\n+        arrayB.fill(i -> 100 + i);\n+\n+        accelerator.compute(cc ->\n+                TestConstants.vectorWithConstants2(cc, arrayA, arrayB, arrayC));\n+\n+        S32Array test = S32Array.create(accelerator, size);\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            test.array(i, CONSTANT + arrayA.array(i) + arrayB.array(i));\n+        }\n+\n+        for (int i = 0; i < test.length(); i++) {\n+            HatAsserts.assertEquals(test.array(i), arrayC.array(i));\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestConstants.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}