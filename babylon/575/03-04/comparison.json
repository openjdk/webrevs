{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import hat.phases.HatFinalDetectionPhase;\n@@ -228,1 +229,3 @@\n-        kernelCallGraph.analyseFinalValues();\n+        \/\/ Phase to detect finals\n+        HatFinalDetectionPhase hatFinalDetectionPhase = new HatFinalDetectionPhase();\n+        hatFinalDetectionPhase.apply(kernelCallGraph.entrypoint.funcOp());\n@@ -232,1 +235,1 @@\n-                        kernelCallGraph.entrypoint.funcOp(), kernelCallGraph.finalVarOps());\n+                        kernelCallGraph.entrypoint.funcOp(), hatFinalDetectionPhase.getFinalVars());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,40 +61,0 @@\n-    public Map<Op.Result, CoreOp.VarOp> finalVarOps;\n-\n-    public void analyseFinalValues() {\n-        CoreOp.FuncOp kernelEntry = entrypoint.funcOp();\n-        Stream<CodeElement<?, ?>> elements = kernelEntry.elements();\n-        Map<Op.Result, CoreOp.VarOp> finalVars = new HashMap<>();\n-        elements.forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.VarOp varOp) {\n-                Op.Result varResult = varOp.result();\n-                Set<Op.Result> uses = varResult.uses();\n-                boolean isFinalVarOp = true;\n-                for (Op.Result use : uses) {\n-                    Op op = use.op();\n-                    switch (op) {\n-                        case CoreOp.VarAccessOp.VarStoreOp storeOp -> {\n-                            if (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n-                                isFinalVarOp = false;\n-                            }\n-                        }\n-                        case CoreOp.YieldOp yieldOp -> {\n-                            if (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n-                                isFinalVarOp = false;\n-                            }\n-                        }\n-                        case null, default -> {\n-                        }\n-                    }\n-                }\n-                if (isFinalVarOp) {\n-                    finalVars.put(varResult, varOp);\n-                }\n-            }\n-        });\n-        finalVarOps = new HashMap<>(finalVars);\n-    }\n-\n-    public Map<Op.Result, CoreOp.VarOp> finalVarOps() {\n-        return finalVarOps;\n-    }\n-\n@@ -227,292 +187,0 @@\n-    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n-    }\n-\n-    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n-    }\n-\n-    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n-    }\n-\n-    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n-    }\n-\n-    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n-    }\n-\n-    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = context.getValues(inputOperands);\n-        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n-        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n-        Op.Result inputResult = invokeOp.result();\n-        context.mapValue(inputResult, outputResult);\n-    }\n-\n-    public CoreOp.FuncOp dialectifyToHatBarriers(CoreOp.FuncOp funcOp) {\n-        Stream<CodeElement<?, ?>> elements = funcOp\n-                .elements()\n-                .mapMulti((element, consumer) -> {\n-                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n-                            consumer.accept(invokeOp);\n-                        }\n-                    }\n-                });\n-        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n-        if (collect.isEmpty()) {\n-            \/\/ Return the function with no modifications\n-            return funcOp;\n-        }\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!collect.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createBarrierNodeOp(context, invokeOp, blockBuilder);\n-            }\n-            return blockBuilder;\n-        });\n-        \/\/ System.out.println(\"[INFO] Code model: \" + funcOp.toText());\n-        \/\/entrypoint.funcOp(funcOp);\n-        return funcOp;\n-    }\n-\n-    public CoreOp.FuncOp dialectifyToHatMemorySpace(CoreOp.FuncOp funcOp, Space memorySpace) {\n-\n-        String nameNode = switch (memorySpace) {\n-            case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n-            case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n-        };\n-\n-        \/\/IO.println(\"ORIGINAL: \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (OpTk.isIfaceBufferMethod(computeContext.accelerator.lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n-                                        \/\/ It is the node we are looking for\n-                                        consumer.accept(invokeOp);\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            \/\/ No memory nodes involved\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node\n-                Op.Result result = invokeOp.result();\n-                List<Op.Result> collect = result.uses().stream().toList();\n-                for (Op.Result r : collect) {\n-                    if (r.op() instanceof CoreOp.VarOp varOp) {\n-                        \/\/ That's the node we want\n-                        List<Value> inputOperandsVarOp = invokeOp.operands();\n-                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                        HatMemoryOp memoryOp = switch (memorySpace) {\n-                            case SHARED ->\n-                                    new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                            default ->\n-                                    new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                        };\n-                        Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n-                        context.mapValue(invokeOp.result(), hatLocalResult);\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarOp varOp) {\n-                \/\/ pass value\n-                context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-        \/\/ IO.println(\"[INFO] Code model: \" + funcOp.toText());\n-        \/\/entrypoint.funcOp(funcOp);\n-        return funcOp;\n-    }\n-\n-    private enum Space {\n-        PRIVATE,\n-        SHARED,\n-    }\n-\n-    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        String fieldName = fieldLoadOp.fieldDescriptor().name();\n-        switch (threadAccess) {\n-            case GLOBAL_ID -> {\n-                if (fieldName.equals(\"y\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"z\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case GLOBAL_SIZE -> {\n-                if (fieldName.equals(\"gsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"gsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case LOCAL_ID -> {\n-                if (fieldName.equals(\"liy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lyz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case LOCAL_SIZE -> {\n-                if (fieldName.equals(\"lsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case BLOCK_ID ->  {\n-                if (fieldName.equals(\"biy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"biz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public CoreOp.FuncOp dialectifyToHatThreadIds(CoreOp.FuncOp funcOp, ThreadAccess threadAccess) {\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                        List<Value> operands = fieldLoadOp.operands();\n-                        for (Value inputOperand : operands) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                    boolean isThreadIntrinsic = switch (threadAccess) {\n-                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n-                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n-                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n-                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n-                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n-                                    };\n-                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n-                                        consumer.accept(fieldLoadOp);\n-                                        consumer.accept(varLoadOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            \/\/ No memory nodes involved\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                List<Value> operands = fieldLoadOp.operands();\n-                for (Value operand : operands) {\n-                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> varLoadOperands = varLoadOp.operands();\n-                        List<Value> outputOperands = context.getValues(varLoadOperands);\n-                        int dim = getDimension(threadAccess, fieldLoadOp);\n-                        if (dim < 0) {\n-                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n-                        }\n-                        HatThreadOP threadOP = switch (threadAccess) {\n-                            case GLOBAL_ID -> new HatGlobalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case GLOBAL_SIZE -> new HatGlobalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case LOCAL_ID -> new HatLocalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case LOCAL_SIZE -> new HatLocalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                            case BLOCK_ID -> new HatBlockThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n-                        };\n-                        Op.Result threadResult = blockBuilder.op(threadOP);\n-                        context.mapValue(fieldLoadOp.result(), threadResult);\n-                    }\n-                }\n-            }\n-            return blockBuilder;\n-        });\n-        \/\/IO.println(\"[INFO] Code model: \" + funcOp.toText());\n-        \/\/entrypoint.funcOp(funcOp);\n-        return funcOp;\n-    }\n-\n-    private enum ThreadAccess {\n-        GLOBAL_ID,\n-        GLOBAL_SIZE,\n-        LOCAL_ID,\n-        LOCAL_SIZE,\n-        BLOCK_ID,\n-    }\n-\n-    private CoreOp.FuncOp dialectifyToHat(CoreOp.FuncOp funcOp) {\n-        CoreOp.FuncOp f = dialectifyToHatBarriers(funcOp);\n-        for (Space space : Space.values()) {\n-            f = dialectifyToHatMemorySpace(f, space);\n-        }\n-        for (ThreadAccess threadAccess : ThreadAccess.values()) {\n-            f = dialectifyToHatThreadIds(f, threadAccess);\n-        }\n-        return f;\n-    }\n-\n@@ -522,1 +190,0 @@\n-\n@@ -531,1 +198,1 @@\n-\/\/        \/\/ Reachable functions\n+        \/\/ Reachable functions\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":1,"deletions":334,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+public class HatFinalDetectionPhase implements HatPhase {\n+\n+    private final Map<Op.Result, CoreOp.VarOp> finalVars = new HashMap<>();\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements();\n+        elements.forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.VarOp varOp) {\n+                Op.Result varResult = varOp.result();\n+                Set<Op.Result> uses = varResult.uses();\n+                boolean isFinalVarOp = true;\n+                for (Op.Result use : uses) {\n+                    Op op = use.op();\n+                    switch (op) {\n+                        case CoreOp.VarAccessOp.VarStoreOp storeOp -> {\n+                            if (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                                isFinalVarOp = false;\n+                            }\n+                        }\n+                        case CoreOp.YieldOp yieldOp -> {\n+                            if (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) {\n+                                isFinalVarOp = false;\n+                            }\n+                        }\n+                        case null, default -> {\n+                        }\n+                    }\n+                }\n+                if (isFinalVarOp) {\n+                    finalVars.put(varResult, varOp);\n+                }\n+            }\n+        });\n+        return funcOp;\n+    }\n+\n+    public Map<Op.Result, CoreOp.VarOp> getFinalVars() {\n+        return finalVars;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatFinalDetectionPhase.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -29,4 +29,2 @@\n-public interface HatDialectifyPhase {\n-\n-    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n-\n+public interface HatPhase {\n+    CoreOp.FuncOp apply(CoreOp.FuncOp funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatPhase.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyPhase.java","status":"copied"},{"patch":"@@ -215,1 +215,1 @@\n-                           Stream.of( \"Arrays\", \"MatMul\", \"Mandel\", \"Local\", \"Reductions\", \"Private\", \"Parenthesis\")\n+                           Stream.of( \"Arrays\", \"MatMul\", \"Mandel\", \"Local\", \"Reductions\", \"Private\", \"Parenthesis\", \"Costants\")\n","filename":"hat\/hat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}