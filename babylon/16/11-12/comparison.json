{"files":[{"patch":"@@ -107,5 +107,6 @@\n-            final BitSet resolved = new BitSet();\n-            int initiallyResolved;\n-            while ((initiallyResolved = resolved.cardinality()) < elements.size()) {\n-                for (int i = resolved.nextClearBit(0); i < elements.size();) {\n-                    resolved.set(i);\n+            final BitSet visited = new BitSet();\n+            int initiallyResolved; \/\/ This is counter helping to determine if the remaining code is not accessible (\"dead\")\n+            while ((initiallyResolved = visited.cardinality()) < elements.size()) {\n+                for (int i = visited.nextClearBit(0); i < elements.size();) {\n+                    \/\/ We start from the first unvisited block and mark it as visited\n+                    visited.set(i);\n@@ -120,0 +121,1 @@\n+                                \/\/ Flow has not been interrupted and we can build next block based on the actual stack and locals\n@@ -130,0 +132,1 @@\n+                                \/\/ We know the next block so we can continue\n@@ -135,1 +138,1 @@\n-                                \/\/ Insert relevant tryStart and tryEnd blocks\n+                                \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n@@ -153,0 +156,1 @@\n+                                \/\/ Insert relevant tryEnd blocks in normal order\n@@ -165,1 +169,4 @@\n-                                resolved.clear(i);\n+                                \/\/ Here we do not know the next block parameters, stack and locals\n+                                \/\/ so we make it unvisited\n+                                visited.clear(i);\n+                                \/\/ interrupt the flow\n@@ -168,1 +175,1 @@\n-                                \/\/ Skip to next block\n+                                \/\/ and skip to a next block\n@@ -413,1 +420,2 @@\n-                    if (resolved.get(++i)) {\n+                    if (visited.get(++i)) {\n+                        \/\/ Interrupt the flow if the following instruction has been already visited\n@@ -416,1 +424,2 @@\n-                        i = resolved.nextClearBit(i);\n+                        \/\/ and continue with the next unvisited instruction\n+                        i = visited.nextClearBit(i);\n@@ -419,2 +428,3 @@\n-                if (resolved.cardinality() == initiallyResolved) {\n-                    \/\/ No progress, all remaining blocks are dead code\n+                if (visited.cardinality() == initiallyResolved) {\n+                    \/\/ If there is no progress, all remaining blocks are dead code\n+                    \/\/ we may alternatively just exit and ignore the dead code\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -92,2 +92,2 @@\n-    static int conditionalExpression(int a, int b, int n) {\n-        return (n < 10) ? a : b;\n+    static int conditionalExpression(int a, int b, int c, int n) {\n+        return (n < 10) ? (n < 5) ? a : b : c;\n@@ -100,2 +100,3 @@\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 1), conditionalExpression(1, 2, 1));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 11), conditionalExpression(1, 2, 11));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 1), conditionalExpression(1, 2, 3, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 6), conditionalExpression(1, 2, 3, 6));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 11), conditionalExpression(1, 2, 3, 11));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftControl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}