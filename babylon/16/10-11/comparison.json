{"files":[{"patch":"@@ -51,0 +51,1 @@\n+import java.util.BitSet;\n@@ -106,17 +107,8 @@\n-            for (int i = 0; i < elements.size(); i++) {\n-                switch (elements.get(i)) {\n-                    case ExceptionCatch ec -> {\n-                        \/\/ Exception blocks are inserted by label target (below)\n-                    }\n-                    case LabelTarget lt -> {\n-                        \/\/ Start of a new block\n-                        CodeBlock next = blockMap.get(lt.label());\n-                        if (currentBlock != null) {\n-                            if (next == null) {\n-                                \/\/ New block parameter types are calculated from the actual stack\n-                                next = new CodeBlock(entryBlock.block(stack.stream().map(Value::type).toList()), locals);\n-                                blockMap.put(lt.label(), next);\n-                            }\n-                            \/\/ Implicit goto next block, add explicitly\n-                            \/\/ Use stack content as next block arguments\n-                            currentBlock.op(CoreOps.branch(next.blockBuilder.successor(List.copyOf(stack))));\n+            final BitSet resolved = new BitSet();\n+            int initiallyResolved;\n+            while ((initiallyResolved = resolved.cardinality()) < elements.size()) {\n+                for (int i = resolved.nextClearBit(0); i < elements.size();) {\n+                    resolved.set(i);\n+                    switch (elements.get(i)) {\n+                        case ExceptionCatch ec -> {\n+                            \/\/ Exception blocks are inserted by label target (below)\n@@ -124,22 +116,8 @@\n-                        if (next != null) {\n-                            currentBlock = next.blockBuilder;\n-                            \/\/ Stack is reconstructed from block parameters\n-                            stack.clear();\n-                            currentBlock.parameters().forEach(stack::add);\n-                            locals = next.locals;\n-                            \/\/ Insert relevant tryStart and tryEnd blocks\n-                            for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n-                                if (lt.label() == ec.tryStart()) {\n-                                    \/\/ Get or create handler with the exception as parameter\n-                                    CodeBlock handler = blockMap.getOrCreate(ec.handler(),\n-                                            List.of(TypeDesc.ofNominalDescriptor(ec.catchType().map(ClassEntry::asSymbol).orElse(ConstantDescs.CD_Throwable))), locals);\n-                                    \/\/ Create start block\n-                                    Block.Builder startBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                    ExceptionRegionEnter ere = CoreOps.exceptionRegionEnter(startBlock.successor(List.copyOf(stack)), handler.blockBuilder.successor());\n-                                    currentBlock.op(ere);\n-                                    \/\/ Store ERE into map for exit\n-                                    exceptionRegionsMap.put(ec, ere.result());\n-                                    currentBlock = startBlock;\n-                                    \/\/ Stack is reconstructed from block parameters\n-                                    stack.clear();\n-                                    currentBlock.parameters().forEach(stack::add);\n+                        case LabelTarget lt -> {\n+                            \/\/ Start of a new block\n+                            CodeBlock next = blockMap.get(lt.label());\n+                            if (currentBlock != null) {\n+                                if (next == null) {\n+                                    \/\/ New block parameter types are calculated from the actual stack\n+                                    next = new CodeBlock(entryBlock.block(stack.stream().map(Value::type).toList()), locals);\n+                                    blockMap.put(lt.label(), next);\n@@ -147,0 +125,3 @@\n+                                \/\/ Implicit goto next block, add explicitly\n+                                \/\/ Use stack content as next block arguments\n+                                currentBlock.op(CoreOps.branch(next.blockBuilder.successor(List.copyOf(stack))));\n@@ -148,9 +129,23 @@\n-                            for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n-                                if (lt.label() == ec.tryEnd()) {\n-                                    \/\/ Create exit block with parameters constructed from the stack\n-                                    Block.Builder endBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                    currentBlock.op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), endBlock.successor()));\n-                                    currentBlock = endBlock;\n-                                    \/\/ Stack is reconstructed from block parameters\n-                                    stack.clear();\n-                                    currentBlock.parameters().forEach(stack::add);\n+                            if (next != null) {\n+                                currentBlock = next.blockBuilder;\n+                                \/\/ Stack is reconstructed from block parameters\n+                                stack.clear();\n+                                currentBlock.parameters().forEach(stack::add);\n+                                locals = next.locals;\n+                                \/\/ Insert relevant tryStart and tryEnd blocks\n+                                for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                                    if (lt.label() == ec.tryStart()) {\n+                                        \/\/ Get or create handler with the exception as parameter\n+                                        CodeBlock handler = blockMap.getOrCreate(ec.handler(),\n+                                                List.of(TypeDesc.ofNominalDescriptor(ec.catchType().map(ClassEntry::asSymbol).orElse(ConstantDescs.CD_Throwable))), locals);\n+                                        \/\/ Create start block\n+                                        Block.Builder startBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n+                                        ExceptionRegionEnter ere = CoreOps.exceptionRegionEnter(startBlock.successor(List.copyOf(stack)), handler.blockBuilder.successor());\n+                                        currentBlock.op(ere);\n+                                        \/\/ Store ERE into map for exit\n+                                        exceptionRegionsMap.put(ec, ere.result());\n+                                        currentBlock = startBlock;\n+                                        \/\/ Stack is reconstructed from block parameters\n+                                        stack.clear();\n+                                        currentBlock.parameters().forEach(stack::add);\n+                                    }\n@@ -158,0 +153,17 @@\n+                                for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                                    if (lt.label() == ec.tryEnd()) {\n+                                        \/\/ Create exit block with parameters constructed from the stack\n+                                        Block.Builder endBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n+                                        currentBlock.op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), endBlock.successor()));\n+                                        currentBlock = endBlock;\n+                                        \/\/ Stack is reconstructed from block parameters\n+                                        stack.clear();\n+                                        currentBlock.parameters().forEach(stack::add);\n+                                    }\n+                                }\n+                            } else {\n+                                resolved.clear(i);\n+                                currentBlock = null;\n+                                stack.clear();\n+                                \/\/ Skip to next block\n+                                while (i < elements.size() - 1 && !(elements.get(i + 1) instanceof LabelTarget)) i++;\n@@ -159,3 +171,0 @@\n-                        } else {\n-                            \/\/ @@@ Skip over unitialized block\n-                            throw new UnsupportedOperationException(\"Not implemented yet\");\n@@ -163,29 +172,7 @@\n-                    }\n-                    case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n-                        \/\/ Get or create target block with parameters constructed from the stack\n-                        currentBlock.op(CoreOps.branch(blockMap.getOrCreate(inst.target(), stack, locals)\n-                                .blockBuilder.successor(List.copyOf(stack))));\n-                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                        stack.clear();\n-                        currentBlock = null;\n-                    }\n-                    case BranchInstruction inst -> {\n-                        \/\/ Conditional branch\n-                        Value operand = stack.pop();\n-                        Op cop = switch (inst.opcode()) {\n-                            case IFNE -> CoreOps.eq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                            case IFEQ -> CoreOps.neq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                            case IFGE -> CoreOps.lt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                            case IFLE -> CoreOps.gt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                            case IFGT -> CoreOps.le(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                            case IFLT -> CoreOps.ge(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                            case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n-                            case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n-                            case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n-                            case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n-                            case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n-                            case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n-                            default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n-                        };\n-                        if (!stack.isEmpty()) {\n-                            throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                        case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                            \/\/ Get or create target block with parameters constructed from the stack\n+                            currentBlock.op(CoreOps.branch(blockMap.getOrCreate(inst.target(), stack, locals)\n+                                    .blockBuilder.successor(List.copyOf(stack))));\n+                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                            stack.clear();\n+                            currentBlock = null;\n@@ -193,52 +180,20 @@\n-                        Block.Builder nextBlock = currentBlock.block();\n-                        currentBlock.op(CoreOps.conditionalBranch(\n-                                currentBlock.op(cop),\n-                                nextBlock.successor(),\n-                                \/\/ Get or create target block\n-                                blockMap.getOrCreate(inst.target(), stack, locals).blockBuilder.successor()));\n-                        currentBlock = nextBlock;\n-                    }\n-    \/\/                case LookupSwitchInstruction si -> {\n-    \/\/                    \/\/ Default label is first successor\n-    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-    \/\/                    addSuccessors(si.cases(), blockMap, b);\n-    \/\/                }\n-    \/\/                case TableSwitchInstruction si -> {\n-    \/\/                    \/\/ Default label is first successor\n-    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-    \/\/                    addSuccessors(si.cases(), blockMap, b);\n-    \/\/                }\n-                    case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n-                        currentBlock.op(CoreOps._return());\n-                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                        stack.clear();\n-                        currentBlock = null;\n-                    }\n-                    case ReturnInstruction _ -> {\n-                        currentBlock.op(CoreOps._return(stack.pop()));\n-                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                        stack.clear();\n-                        currentBlock = null;\n-                    }\n-                    case ThrowInstruction _ -> {\n-                        currentBlock.op(CoreOps._throw(stack.pop()));\n-                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                        stack.clear();\n-                        currentBlock = null;\n-                    }\n-                    case LoadInstruction inst -> {\n-                        stack.push(currentBlock.op(CoreOps.varLoad(locals.get(inst.slot()))));\n-                    }\n-                    case StoreInstruction inst -> {\n-                        Value operand = stack.pop();\n-                        Op.Result local = locals.get(inst.slot());\n-                        if (local == null) {\n-                            locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(uniqueVariableName), operand)));\n-                        } else {\n-                            TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n-                            if (!operand.type().equals(varType)) {\n-                                \/\/ Fork locals to override the slot\n-                                locals = new HashMap<>(locals);\n-                                locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(uniqueVariableName++), operand)));\n-                            } else {\n-                                currentBlock.op(CoreOps.varStore(local, operand));\n+                        case BranchInstruction inst -> {\n+                            \/\/ Conditional branch\n+                            Value operand = stack.pop();\n+                            Op cop = switch (inst.opcode()) {\n+                                case IFNE -> CoreOps.eq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFEQ -> CoreOps.neq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFGE -> CoreOps.lt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFLE -> CoreOps.gt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFGT -> CoreOps.le(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFLT -> CoreOps.ge(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n+                                case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                                case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n+                                case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n+                                case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n+                                case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n+                                default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                            };\n+                            if (!stack.isEmpty()) {\n+                                throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n@@ -246,0 +201,7 @@\n+                            Block.Builder nextBlock = currentBlock.block();\n+                            currentBlock.op(CoreOps.conditionalBranch(\n+                                    currentBlock.op(cop),\n+                                    nextBlock.successor(),\n+                                    \/\/ Get or create target block\n+                                    blockMap.getOrCreate(inst.target(), stack, locals).blockBuilder.successor()));\n+                            currentBlock = nextBlock;\n@@ -247,54 +209,44 @@\n-                    }\n-                    case IncrementInstruction inst -> {\n-                        Op.Result local = locals.get(inst.slot());\n-                        currentBlock.op(CoreOps.varStore(local, currentBlock.op(CoreOps.add(\n-                                currentBlock.op(CoreOps.varLoad(local)),\n-                                currentBlock.op(CoreOps.constant(TypeDesc.INT, inst.constant()))))));\n-                    }\n-                    case ConstantInstruction inst -> {\n-                        stack.push(currentBlock.op(switch (inst.constantValue()) {\n-                            case ClassDesc v -> CoreOps.constant(TypeDesc.J_L_CLASS, TypeDesc.ofNominalDescriptor(v));\n-                            case Double v -> CoreOps.constant(TypeDesc.DOUBLE, v);\n-                            case Float v -> CoreOps.constant(TypeDesc.FLOAT, v);\n-                            case Integer v -> CoreOps.constant(TypeDesc.INT, v);\n-                            case Long v -> CoreOps.constant(TypeDesc.LONG, v);\n-                            case String v -> CoreOps.constant(TypeDesc.J_L_STRING, v);\n-                            default ->\n-                                \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n-                                throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n-                        }));\n-                    }\n-                    case OperatorInstruction inst -> {\n-                        Value operand = stack.pop();\n-                        stack.push(currentBlock.op(switch (inst.opcode()) {\n-                            case IADD, LADD, FADD, DADD ->\n-                                    CoreOps.add(stack.pop(), operand);\n-                            case ISUB, LSUB, FSUB, DSUB ->\n-                                    CoreOps.sub(stack.pop(), operand);\n-                            case IMUL, LMUL, FMUL, DMUL ->\n-                                    CoreOps.mul(stack.pop(), operand);\n-                            case IDIV, LDIV, FDIV, DDIV ->\n-                                    CoreOps.div(stack.pop(), operand);\n-                            case IREM, LREM, FREM, DREM ->\n-                                    CoreOps.mod(stack.pop(), operand);\n-                            case INEG, LNEG, FNEG, DNEG ->\n-                                    CoreOps.neg(operand);\n-                            case ARRAYLENGTH ->\n-                                    CoreOps.arrayLength(operand);\n-                            default ->\n-                                throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n-                        }));\n-                    }\n-                    case FieldInstruction inst -> {\n-                            FieldDesc fd = FieldDesc.field(\n-                                    TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()),\n-                                    inst.name().stringValue(),\n-                                    TypeDesc.ofNominalDescriptor(inst.typeSymbol()));\n-                            switch (inst.opcode()) {\n-                                case GETFIELD ->\n-                                    stack.push(currentBlock.op(CoreOps.fieldLoad(fd, stack.pop())));\n-                                case GETSTATIC ->\n-                                    stack.push(currentBlock.op(CoreOps.fieldLoad(fd)));\n-                                case PUTFIELD -> {\n-                                    Value value = stack.pop();\n-                                    stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop(), value)));\n+        \/\/                case LookupSwitchInstruction si -> {\n+        \/\/                    \/\/ Default label is first successor\n+        \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+        \/\/                    addSuccessors(si.cases(), blockMap, b);\n+        \/\/                }\n+        \/\/                case TableSwitchInstruction si -> {\n+        \/\/                    \/\/ Default label is first successor\n+        \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+        \/\/                    addSuccessors(si.cases(), blockMap, b);\n+        \/\/                }\n+                        case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                            currentBlock.op(CoreOps._return());\n+                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                            stack.clear();\n+                            currentBlock = null;\n+                        }\n+                        case ReturnInstruction _ -> {\n+                            currentBlock.op(CoreOps._return(stack.pop()));\n+                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                            stack.clear();\n+                            currentBlock = null;\n+                        }\n+                        case ThrowInstruction _ -> {\n+                            currentBlock.op(CoreOps._throw(stack.pop()));\n+                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                            stack.clear();\n+                            currentBlock = null;\n+                        }\n+                        case LoadInstruction inst -> {\n+                            stack.push(currentBlock.op(CoreOps.varLoad(locals.get(inst.slot()))));\n+                        }\n+                        case StoreInstruction inst -> {\n+                            Value operand = stack.pop();\n+                            Op.Result local = locals.get(inst.slot());\n+                            if (local == null) {\n+                                locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(uniqueVariableName), operand)));\n+                            } else {\n+                                TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n+                                if (!operand.type().equals(varType)) {\n+                                    \/\/ Fork locals to override the slot\n+                                    locals = new HashMap<>(locals);\n+                                    locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(uniqueVariableName++), operand)));\n+                                } else {\n+                                    currentBlock.op(CoreOps.varStore(local, operand));\n@@ -302,4 +254,0 @@\n-                                case PUTSTATIC ->\n-                                    stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop())));\n-                                default ->\n-                                    throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n@@ -307,15 +255,0 @@\n-                    }\n-                    case ArrayStoreInstruction _ -> {\n-                        Value value = stack.pop();\n-                        Value index = stack.pop();\n-                        currentBlock.op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n-                    }\n-                    case ArrayLoadInstruction _ -> {\n-                        Value index = stack.pop();\n-                        stack.push(currentBlock.op(CoreOps.arrayLoadOp(stack.pop(), index)));\n-                    }\n-                    case InvokeInstruction inst -> {\n-                        MethodTypeDesc mType = MethodTypeDesc.ofNominalDescriptor(inst.typeSymbol());\n-                        List<Value> operands = new ArrayList<>();\n-                        for (var _ : mType.parameters()) {\n-                            operands.add(stack.pop());\n@@ -323,3 +256,73 @@\n-                        MethodDesc mDesc = MethodDesc.method(TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()), inst.name().stringValue(), mType);\n-                        Op.Result result = switch (inst.opcode()) {\n-                            case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                        case IncrementInstruction inst -> {\n+                            Op.Result local = locals.get(inst.slot());\n+                            currentBlock.op(CoreOps.varStore(local, currentBlock.op(CoreOps.add(\n+                                    currentBlock.op(CoreOps.varLoad(local)),\n+                                    currentBlock.op(CoreOps.constant(TypeDesc.INT, inst.constant()))))));\n+                        }\n+                        case ConstantInstruction inst -> {\n+                            stack.push(currentBlock.op(switch (inst.constantValue()) {\n+                                case ClassDesc v -> CoreOps.constant(TypeDesc.J_L_CLASS, TypeDesc.ofNominalDescriptor(v));\n+                                case Double v -> CoreOps.constant(TypeDesc.DOUBLE, v);\n+                                case Float v -> CoreOps.constant(TypeDesc.FLOAT, v);\n+                                case Integer v -> CoreOps.constant(TypeDesc.INT, v);\n+                                case Long v -> CoreOps.constant(TypeDesc.LONG, v);\n+                                case String v -> CoreOps.constant(TypeDesc.J_L_STRING, v);\n+                                default ->\n+                                    \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                                    throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n+                            }));\n+                        }\n+                        case OperatorInstruction inst -> {\n+                            Value operand = stack.pop();\n+                            stack.push(currentBlock.op(switch (inst.opcode()) {\n+                                case IADD, LADD, FADD, DADD ->\n+                                        CoreOps.add(stack.pop(), operand);\n+                                case ISUB, LSUB, FSUB, DSUB ->\n+                                        CoreOps.sub(stack.pop(), operand);\n+                                case IMUL, LMUL, FMUL, DMUL ->\n+                                        CoreOps.mul(stack.pop(), operand);\n+                                case IDIV, LDIV, FDIV, DDIV ->\n+                                        CoreOps.div(stack.pop(), operand);\n+                                case IREM, LREM, FREM, DREM ->\n+                                        CoreOps.mod(stack.pop(), operand);\n+                                case INEG, LNEG, FNEG, DNEG ->\n+                                        CoreOps.neg(operand);\n+                                case ARRAYLENGTH ->\n+                                        CoreOps.arrayLength(operand);\n+                                default ->\n+                                    throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                            }));\n+                        }\n+                        case FieldInstruction inst -> {\n+                                FieldDesc fd = FieldDesc.field(\n+                                        TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                        inst.name().stringValue(),\n+                                        TypeDesc.ofNominalDescriptor(inst.typeSymbol()));\n+                                switch (inst.opcode()) {\n+                                    case GETFIELD ->\n+                                        stack.push(currentBlock.op(CoreOps.fieldLoad(fd, stack.pop())));\n+                                    case GETSTATIC ->\n+                                        stack.push(currentBlock.op(CoreOps.fieldLoad(fd)));\n+                                    case PUTFIELD -> {\n+                                        Value value = stack.pop();\n+                                        stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop(), value)));\n+                                    }\n+                                    case PUTSTATIC ->\n+                                        stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop())));\n+                                    default ->\n+                                        throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n+                                }\n+                        }\n+                        case ArrayStoreInstruction _ -> {\n+                            Value value = stack.pop();\n+                            Value index = stack.pop();\n+                            currentBlock.op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n+                        }\n+                        case ArrayLoadInstruction _ -> {\n+                            Value index = stack.pop();\n+                            stack.push(currentBlock.op(CoreOps.arrayLoadOp(stack.pop(), index)));\n+                        }\n+                        case InvokeInstruction inst -> {\n+                            MethodTypeDesc mType = MethodTypeDesc.ofNominalDescriptor(inst.typeSymbol());\n+                            List<Value> operands = new ArrayList<>();\n+                            for (var _ : mType.parameters()) {\n@@ -327,1 +330,0 @@\n-                                yield currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n@@ -329,10 +331,3 @@\n-                            case INVOKESTATIC ->\n-                                currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                            case INVOKESPECIAL -> {\n-                                if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n-                                    yield currentBlock.op(CoreOps._new(\n-                                            MethodTypeDesc.methodType(\n-                                                    mType.parameters().get(0),\n-                                                    mType.parameters().subList(1, mType.parameters().size())),\n-                                            operands.reversed()));\n-                                } else {\n+                            MethodDesc mDesc = MethodDesc.method(TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()), inst.name().stringValue(), mType);\n+                            Op.Result result = switch (inst.opcode()) {\n+                                case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n@@ -342,0 +337,19 @@\n+                                case INVOKESTATIC ->\n+                                    currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n+                                case INVOKESPECIAL -> {\n+                                    if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                        yield currentBlock.op(CoreOps._new(\n+                                                MethodTypeDesc.methodType(\n+                                                        mType.parameters().get(0),\n+                                                        mType.parameters().subList(1, mType.parameters().size())),\n+                                                operands.reversed()));\n+                                    } else {\n+                                        operands.add(stack.pop());\n+                                        yield currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n+                                    }\n+                                }\n+                                default ->\n+                                    throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                            };\n+                            if (!result.type().equals(TypeDesc.VOID)) {\n+                                stack.push(result);\n@@ -343,5 +357,0 @@\n-                            default ->\n-                                throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n-                        };\n-                        if (!result.type().equals(TypeDesc.VOID)) {\n-                            stack.push(result);\n@@ -349,11 +358,11 @@\n-                    }\n-                    case NewObjectInstruction _ -> {\n-                        \/\/ Skip over this and the dup to process the invoke special\n-                        if (i + 2 < elements.size() - 1\n-                                && elements.get(i + 1) instanceof StackInstruction dup\n-                                && dup.opcode() == Opcode.DUP\n-                                && elements.get(i + 2) instanceof InvokeInstruction init\n-                                && init.name().equalsString(ConstantDescs.INIT_NAME)) {\n-                            i++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"New must be followed by dup and invokespecial for <init>\");\n+                        case NewObjectInstruction _ -> {\n+                            \/\/ Skip over this and the dup to process the invoke special\n+                            if (i + 2 < elements.size() - 1\n+                                    && elements.get(i + 1) instanceof StackInstruction dup\n+                                    && dup.opcode() == Opcode.DUP\n+                                    && elements.get(i + 2) instanceof InvokeInstruction init\n+                                    && init.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                i++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"New must be followed by dup and invokespecial for <init>\");\n+                            }\n@@ -361,39 +370,27 @@\n-                    }\n-                    case NewPrimitiveArrayInstruction inst -> {\n-                        stack.push(currentBlock.op(CoreOps.newArray(\n-                                switch (inst.typeKind()) {\n-                                    case BooleanType -> TypeDesc.BOOLEAN_ARRAY;\n-                                    case ByteType -> TypeDesc.BYTE_ARRAY;\n-                                    case CharType -> TypeDesc.CHAR_ARRAY;\n-                                    case DoubleType -> TypeDesc.DOUBLE_ARRAY;\n-                                    case FloatType -> TypeDesc.FLOAT_ARRAY;\n-                                    case IntType -> TypeDesc.INT_ARRAY;\n-                                    case LongType -> TypeDesc.LONG_ARRAY;\n-                                    case ShortType -> TypeDesc.SHORT_ARRAY;\n-                                    default ->\n-                                            throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n-                                },\n-                                stack.pop())));\n-                    }\n-                    case NewReferenceArrayInstruction inst -> {\n-                        stack.push(currentBlock.op(CoreOps.newArray(\n-                                TypeDesc.type(TypeDesc.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n-                                stack.pop())));\n-                    }\n-                    case NewMultiArrayInstruction inst -> {\n-                        stack.push(currentBlock.op(CoreOps._new(\n-                                MethodTypeDesc.methodType(\n-                                        TypeDesc.ofNominalDescriptor(inst.arrayType().asSymbol()),\n-                                        Collections.nCopies(inst.dimensions(), TypeDesc.INT)),\n-                                IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n-                    }\n-                    case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n-                        stack.push(currentBlock.op(CoreOps.cast(TypeDesc.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n-                    }\n-                    case StackInstruction inst -> {\n-                        switch (inst.opcode()) {\n-                            case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n-                            case DUP, DUP2 -> stack.push(stack.peek());\n-                            \/\/@@@ implement all other stack ops\n-                            default ->\n-                                throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                        case NewPrimitiveArrayInstruction inst -> {\n+                            stack.push(currentBlock.op(CoreOps.newArray(\n+                                    switch (inst.typeKind()) {\n+                                        case BooleanType -> TypeDesc.BOOLEAN_ARRAY;\n+                                        case ByteType -> TypeDesc.BYTE_ARRAY;\n+                                        case CharType -> TypeDesc.CHAR_ARRAY;\n+                                        case DoubleType -> TypeDesc.DOUBLE_ARRAY;\n+                                        case FloatType -> TypeDesc.FLOAT_ARRAY;\n+                                        case IntType -> TypeDesc.INT_ARRAY;\n+                                        case LongType -> TypeDesc.LONG_ARRAY;\n+                                        case ShortType -> TypeDesc.SHORT_ARRAY;\n+                                        default ->\n+                                                throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                                    },\n+                                    stack.pop())));\n+                        }\n+                        case NewReferenceArrayInstruction inst -> {\n+                            stack.push(currentBlock.op(CoreOps.newArray(\n+                                    TypeDesc.type(TypeDesc.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n+                                    stack.pop())));\n+                        }\n+                        case NewMultiArrayInstruction inst -> {\n+                            stack.push(currentBlock.op(CoreOps._new(\n+                                    MethodTypeDesc.methodType(\n+                                            TypeDesc.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                            Collections.nCopies(inst.dimensions(), TypeDesc.INT)),\n+                                    IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n@@ -401,0 +398,14 @@\n+                        case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n+                            stack.push(currentBlock.op(CoreOps.cast(TypeDesc.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                        }\n+                        case StackInstruction inst -> {\n+                            switch (inst.opcode()) {\n+                                case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n+                                case DUP, DUP2 -> stack.push(stack.peek());\n+                                \/\/@@@ implement all other stack ops\n+                                default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                            }\n+                        }\n+                        default ->\n+                            throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n@@ -402,2 +413,9 @@\n-                    default ->\n-                        throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n+                    if (resolved.get(++i)) {\n+                        currentBlock = null;\n+                        stack.clear();\n+                        i = resolved.nextClearBit(i);\n+                    }\n+                }\n+                if (resolved.cardinality() == initiallyResolved) {\n+                    \/\/ No progress, all remaining blocks are dead code\n+                    throw new IllegalArgumentException(\"Dead code detected.\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":294,"deletions":276,"binary":false,"changes":570,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -36,0 +41,1 @@\n+ * @enablePreview\n@@ -98,0 +104,31 @@\n+    @Test\n+    public void testBackJumps() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"BackJumps\"), clb ->\n+                clb.withMethodBody(\"backJumps\", MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int), ClassFile.ACC_STATIC, cob -> {\n+                    Label l1 = cob.newLabel();\n+                    Label l2 = cob.newLabel();\n+                    Label l3 = cob.newLabel();\n+                    Label l4 = cob.newLabel();\n+                    \/\/ Code wrapped in back jumps requires multiple passes and block skipping\n+                    cob.goto_(l1)\n+                       .labelBinding(l2)\n+                       .goto_(l3)\n+                       .labelBinding(l4)\n+                       .iload(0)\n+                       .ireturn()\n+                       .labelBinding(l1)\n+                       .goto_(l2)\n+                       .labelBinding(l3)\n+                       .goto_(l4);\n+                })), \"backJumps\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, 42), 42);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testDeadCodeDetection() throws Throwable {\n+        Interpreter.invoke(getFuncOp(ClassFile.of().build(ClassDesc.of(\"DeadCode\"), clb ->\n+                clb.withMethodBody(\"deadCode\", ConstantDescs.MTD_void, ClassFile.ACC_STATIC, cob ->\n+                   cob.return_().nop())), \"deadCode\"));\n+    }\n+\n@@ -99,1 +136,4 @@\n-        byte[] classdata = getClassdata();\n+        return getFuncOp(getClassdata(), method);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(byte[] classdata, String method) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftControl.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"}]}