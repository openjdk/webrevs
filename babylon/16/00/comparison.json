{"files":[{"patch":"@@ -138,1 +138,1 @@\n-    static final class ConversionContext implements BytecodeInstructionOps.MethodVisitorContext {\n+    static final class ConversionContext {\n@@ -142,1 +142,0 @@\n-        final Deque<BytecodeInstructionOps.ExceptionTableStart> labelStack;\n@@ -152,1 +151,0 @@\n-            this.labelStack = new ArrayDeque<>();\n@@ -158,6 +156,0 @@\n-        @Override\n-        public Deque<BytecodeInstructionOps.ExceptionTableStart> exceptionRegionStack() {\n-            return labelStack;\n-        }\n-\n-        @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,2584 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.bytecode;\n-\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.Instruction;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.TypeKind;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.classfile.constantpool.DoubleEntry;\n-import java.lang.classfile.constantpool.FieldRefEntry;\n-import java.lang.classfile.constantpool.FloatEntry;\n-import java.lang.classfile.constantpool.IntegerEntry;\n-import java.lang.classfile.constantpool.LoadableConstantEntry;\n-import java.lang.classfile.constantpool.LongEntry;\n-import java.lang.classfile.constantpool.MemberRefEntry;\n-import java.lang.classfile.constantpool.StringEntry;\n-import java.lang.classfile.instruction.ArrayLoadInstruction;\n-import java.lang.classfile.instruction.ArrayStoreInstruction;\n-import java.lang.classfile.instruction.BranchInstruction;\n-import java.lang.classfile.instruction.ConstantInstruction;\n-import java.lang.classfile.instruction.FieldInstruction;\n-import java.lang.classfile.instruction.IncrementInstruction;\n-import java.lang.classfile.instruction.InvokeInstruction;\n-import java.lang.classfile.instruction.LoadInstruction;\n-import java.lang.classfile.instruction.LookupSwitchInstruction;\n-import java.lang.classfile.instruction.NewMultiArrayInstruction;\n-import java.lang.classfile.instruction.NewObjectInstruction;\n-import java.lang.classfile.instruction.NewPrimitiveArrayInstruction;\n-import java.lang.classfile.instruction.NewReferenceArrayInstruction;\n-import java.lang.classfile.instruction.OperatorInstruction;\n-import java.lang.classfile.instruction.ReturnInstruction;\n-import java.lang.classfile.instruction.StackInstruction;\n-import java.lang.classfile.instruction.StoreInstruction;\n-import java.lang.classfile.instruction.SwitchCase;\n-import java.lang.classfile.instruction.TableSwitchInstruction;\n-import java.lang.classfile.instruction.ThrowInstruction;\n-import java.lang.classfile.instruction.TypeCheckInstruction;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.descriptor.FieldDesc;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n-import java.lang.reflect.code.descriptor.MethodTypeDesc;\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.lang.reflect.code.op.OpDeclaration;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-class BytecodeInstructionOps {\n-\n-    interface MethodVisitorContext {\n-        Deque<ExceptionTableStart> exceptionRegionStack();\n-\n-        Label getLabel(Object o);\n-    }\n-\n-    public record InstructionDef<T extends Instruction>(T instruction, List<Block.Reference> successors) {\n-\n-        InstructionDef(T instruction) {\n-            this(instruction, List.of());\n-        }\n-\n-        Opcode opcode() {\n-            return instruction.opcode();\n-        }\n-    }\n-\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Opcodes {\n-        Opcode[] value();\n-    }\n-\n-    public static abstract class InstructionOp extends Op {\n-        InstructionOp(InstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        InstructionOp(String name) {\n-            super(name, List.of());\n-        }\n-\n-        @Override\n-        public final Map<String, Object> attributes() {\n-            Map<String, Object> m = _attributes();\n-            return m.isEmpty() ? m : Collections.unmodifiableMap(m);\n-        }\n-\n-        Map<String, Object> _attributes() {\n-            return Map.of();\n-        }\n-\n-        \/\/ Produce an ASM bytecode instruction\n-        public abstract void apply(CodeBuilder b, MethodVisitorContext c);\n-\n-        @Override\n-        public TypeDesc resultType() {\n-            \/\/ I chose VOID, because bytecode instructions manipulate the stack\n-            \/\/ plus the type of what an operation will push\/pop mayn not be known, e.g. pop instruction\n-            return TypeDesc.VOID;\n-        }\n-    }\n-\n-    public static abstract class TerminatingInstructionOp extends InstructionOp implements Op.Terminating {\n-        final List<Block.Reference> successors;\n-\n-        TerminatingInstructionOp(TerminatingInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            \/\/ Copy successors\n-            this.successors = that.successors().stream()\n-                    .map(cc::getSuccessorOrCreate)\n-                    .toList();\n-        }\n-\n-        TerminatingInstructionOp(String name) {\n-            super(name);\n-\n-            this.successors = List.of();\n-        }\n-\n-        TerminatingInstructionOp(String name, List<Block.Reference> s) {\n-            super(name);\n-\n-            this.successors = List.copyOf(s);\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return successors;\n-        }\n-    }\n-\n-    public static abstract class TypedInstructionOp extends InstructionOp {\n-        public static final String ATTRIBUTE_TYPE = \"type\";\n-\n-        final TypeKind type;\n-\n-        TypedInstructionOp(TypedInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.type = that.type;\n-        }\n-\n-        TypedInstructionOp(String name, TypeKind type) {\n-            super(name);\n-\n-            this.type = type;\n-        }\n-\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_TYPE, type);\n-            return m;\n-        }\n-\n-        public TypeKind type() {\n-            return type;\n-        }\n-\n-        public TypeDesc typeDesc() {\n-            return switch (type) {\n-\/\/                case BooleanType -> TypeDesc.BOOLEAN;\n-\/\/                case ByteType -> TypeDesc.BYTE;\n-\/\/                case ShortType -> TypeDesc.SHORT;\n-\/\/                case CharType -> TypeDesc.CHAR;\n-                case IntType -> TypeDesc.INT;\n-                case FloatType -> TypeDesc.FLOAT;\n-                case LongType -> TypeDesc.LONG;\n-                case DoubleType -> TypeDesc.DOUBLE;\n-                case ReferenceType -> TypeDesc.J_L_OBJECT;\n-                default -> throw new IllegalArgumentException(\"Bad type kind: \" + type);\n-            };\n-        }\n-\n-    }\n-\n-    public static abstract class TypedTerminatingInstructionOp extends TerminatingInstructionOp {\n-        public static final String ATTRIBUTE_TYPE = \"type\";\n-\n-        final TypeKind type;\n-\n-        TypedTerminatingInstructionOp(TypedTerminatingInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.type = that.type;\n-        }\n-\n-        TypedTerminatingInstructionOp(String name, TypeKind type, List<Block.Reference> s) {\n-            super(name, s);\n-\n-            this.type = type;\n-        }\n-\n-        TypedTerminatingInstructionOp(String name, TypeKind type) {\n-            super(name);\n-\n-            this.type = type;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_TYPE, type);\n-            return m;\n-        }\n-\n-        public TypeKind type() {\n-            return type;\n-        }\n-    }\n-\n-    public static abstract class VarInstructionOp extends TypedInstructionOp {\n-        public static final String ATTRIBUTE_INDEX = \"index\";\n-\n-        final int slot;\n-\n-        VarInstructionOp(VarInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.slot = that.slot;\n-        }\n-\n-        VarInstructionOp(String name, TypeKind type, int slot) {\n-            super(name, type);\n-\n-            this.slot = slot;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = super._attributes();\n-            m.put(ATTRIBUTE_INDEX, slot);\n-            return m;\n-        }\n-\n-        public int slot() {\n-            return slot;\n-        }\n-    }\n-\n-\n-    @Opcodes({\n-            Opcode.ALOAD,\n-            Opcode.ALOAD_0,\n-            Opcode.ALOAD_1,\n-            Opcode.ALOAD_2,\n-            Opcode.ALOAD_3,\n-            Opcode.ILOAD,\n-            Opcode.ILOAD_0,\n-            Opcode.ILOAD_1,\n-            Opcode.ILOAD_2,\n-            Opcode.ILOAD_3,\n-            Opcode.LLOAD,\n-            Opcode.LLOAD_0,\n-            Opcode.LLOAD_1,\n-            Opcode.LLOAD_2,\n-            Opcode.LLOAD_3,\n-            Opcode.FLOAD,\n-            Opcode.FLOAD_0,\n-            Opcode.FLOAD_1,\n-            Opcode.FLOAD_2,\n-            Opcode.FLOAD_3,\n-            Opcode.DLOAD,\n-            Opcode.DLOAD_0,\n-            Opcode.DLOAD_1,\n-            Opcode.DLOAD_2,\n-            Opcode.DLOAD_3\n-    })\n-    @OpDeclaration(LoadInstructionOp.NAME)\n-    public static final class LoadInstructionOp extends VarInstructionOp {\n-        public static final String NAME = \"Tload\";\n-\n-        LoadInstructionOp(InstructionDef<LoadInstruction> def) {\n-            this(def.instruction().typeKind(), def.instruction().slot());\n-        }\n-\n-        LoadInstructionOp(LoadInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public LoadInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LoadInstructionOp(this, cc);\n-        }\n-\n-        LoadInstructionOp(TypeKind type, int slot) {\n-            super(NAME, type, slot);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.loadInstruction(type(), slot());\n-        }\n-    }\n-\n-    public static LoadInstructionOp load(TypeKind type, int index) {\n-        return new LoadInstructionOp(type, index);\n-    }\n-\n-    @Opcodes({\n-            Opcode.ASTORE,\n-            Opcode.ASTORE_0,\n-            Opcode.ASTORE_1,\n-            Opcode.ASTORE_2,\n-            Opcode.ASTORE_3,\n-            Opcode.ISTORE,\n-            Opcode.ISTORE_0,\n-            Opcode.ISTORE_1,\n-            Opcode.ISTORE_2,\n-            Opcode.ISTORE_3,\n-            Opcode.LSTORE,\n-            Opcode.LSTORE_0,\n-            Opcode.LSTORE_1,\n-            Opcode.LSTORE_2,\n-            Opcode.LSTORE_3,\n-            Opcode.FSTORE,\n-            Opcode.FSTORE_0,\n-            Opcode.FSTORE_1,\n-            Opcode.FSTORE_2,\n-            Opcode.FSTORE_3,\n-            Opcode.DSTORE,\n-            Opcode.DSTORE_0,\n-            Opcode.DSTORE_1,\n-            Opcode.DSTORE_2,\n-            Opcode.DSTORE_3\n-    })\n-    @OpDeclaration(StoreInstructionOp.NAME)\n-    public static final class StoreInstructionOp extends VarInstructionOp {\n-        public static final String NAME = \"Tstore\";\n-\n-        StoreInstructionOp(InstructionDef<StoreInstruction> def) {\n-            this(def.instruction().typeKind(), def.instruction().slot());\n-        }\n-\n-        StoreInstructionOp(StoreInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public StoreInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new StoreInstructionOp(this, cc);\n-        }\n-\n-        StoreInstructionOp(TypeKind type, int index) {\n-            super(NAME, type, index);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.storeInstruction(type(), slot());\n-        }\n-    }\n-\n-    public static StoreInstructionOp store(TypeKind type, int index) {\n-        return new StoreInstructionOp(type, index);\n-    }\n-\n-\n-    @Opcodes({Opcode.LDC, Opcode.LDC_W, Opcode.LDC2_W})\n-    @OpDeclaration(LdcInstructionOp.NAME)\n-    public static final class LdcInstructionOp extends InstructionOp {\n-        public static final String NAME = \"ldc\";\n-\n-        public static final String ATTRIBUTE_TYPE = \"type\";\n-\n-        public static final String ATTRIBUTE_VALUE = \"value\";\n-\n-        final TypeDesc type;\n-        final Object value;\n-\n-        LdcInstructionOp(InstructionDef<ConstantInstruction.LoadConstantInstruction> def) {\n-            this(toTypeDesc(def.instruction().constantEntry()), toValue(def.instruction().constantEntry()));\n-        }\n-\n-        private static TypeDesc toTypeDesc(LoadableConstantEntry entry) {\n-            if (entry instanceof IntegerEntry) {\n-                return TypeDesc.INT;\n-            } else if (entry instanceof LongEntry) {\n-                return TypeDesc.LONG;\n-            } else if (entry instanceof FloatEntry) {\n-                return TypeDesc.FLOAT;\n-            } else if (entry instanceof DoubleEntry) {\n-                return TypeDesc.DOUBLE;\n-            } else if (entry instanceof StringEntry) {\n-                return TypeDesc.J_L_STRING;\n-            } else if (entry instanceof ClassEntry) {\n-                return TypeDesc.J_L_CLASS;\n-            } else {\n-                \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n-                throw new IllegalArgumentException(\"Unsupported constant entry: \" + entry);\n-            }\n-        }\n-\n-        private static Object toValue(LoadableConstantEntry entry) {\n-            if (entry instanceof IntegerEntry e) {\n-                return e.intValue();\n-            } else if (entry instanceof LongEntry e) {\n-                return e.longValue();\n-            } else if (entry instanceof FloatEntry e) {\n-                return e.floatValue();\n-            } else if (entry instanceof DoubleEntry e) {\n-                return e.doubleValue();\n-            } else if (entry instanceof StringEntry e) {\n-                return e.stringValue();\n-            } else if (entry instanceof ClassEntry e) {\n-                return TypeDesc.ofNominalDescriptor(e.asSymbol());\n-            } else {\n-                \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n-                throw new IllegalArgumentException(\"Unsupported constant entry: \" + entry);\n-            }\n-        }\n-\n-        LdcInstructionOp(LdcInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.type = that.type;\n-            this.value = that.value;\n-        }\n-\n-        @Override\n-        public LdcInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LdcInstructionOp(this, cc);\n-        }\n-\n-        LdcInstructionOp(TypeDesc type, Object value) {\n-            super(NAME);\n-\n-            \/\/ @@@ constant dynamic\n-            \/\/ @@@ check value\n-\n-            this.type = type;\n-            this.value = value;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_TYPE, type);\n-            m.put(ATTRIBUTE_VALUE, value);\n-            return m;\n-        }\n-\n-        public TypeDesc type() {\n-            return type;\n-        }\n-\n-        public Object value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.ldc(fromValue(mv.constantPool(), value()));\n-        }\n-\n-        static LoadableConstantEntry fromValue(ConstantPoolBuilder b, Object value) {\n-            if (value instanceof ConstantDesc cd) {\n-                return b.constantValueEntry(cd);\n-            } else if (value instanceof TypeDesc td) {\n-                return b.classEntry(td.toNominalDescriptor());\n-            } else {\n-                throw new IllegalArgumentException(\"Unsupported constant value: \" + value);\n-            }\n-        }\n-    }\n-\n-    public static LdcInstructionOp ldc(TypeDesc type, Object value) {\n-        return new LdcInstructionOp(type, value);\n-    }\n-\n-    @Opcodes({Opcode.ICONST_M1,\n-            Opcode.ICONST_0, Opcode.ICONST_1, Opcode.ICONST_2, Opcode.ICONST_3, Opcode.ICONST_4, Opcode.ICONST_5,\n-            Opcode.LCONST_0, Opcode.LCONST_1,\n-            Opcode.FCONST_0, Opcode.FCONST_1, Opcode.FCONST_2,\n-            Opcode.DCONST_0, Opcode.DCONST_1\n-    })\n-    @OpDeclaration(ConstInstructionOp.NAME)\n-    public static final class ConstInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tconst\";\n-\n-        public static final String ATTRIBUTE_VALUE = \"value\";\n-\n-        final int value;\n-\n-        ConstInstructionOp(InstructionDef<ConstantInstruction.IntrinsicConstantInstruction> def) {\n-            this(def.instruction().typeKind(), getValue(def.instruction().opcode().constantValue()));\n-        }\n-\n-        ConstInstructionOp(ConstInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.value = that.value;\n-        }\n-\n-        @Override\n-        public ConstInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ConstInstructionOp(this, cc);\n-        }\n-\n-        ConstInstructionOp(TypeKind type, int value) {\n-            super(NAME, type);\n-\n-            switch (type) {\n-                case IntType -> {\n-                    if (value < -2 || value > 5) {\n-                        throw new IllegalArgumentException(\"Constant integer value out of range [-1, 5]: \" + value);\n-                    }\n-                }\n-                case LongType -> {\n-                    if (value < 0 || value > 1) {\n-                        throw new IllegalArgumentException(\"Constant long value out of range [0, 1]: \" + value);\n-                    }\n-                }\n-                case FloatType -> {\n-                    if (value < 0 || value > 2) {\n-                        throw new IllegalArgumentException(\"Constant float value not 0.0, 1.0, or 2.0: \" + value);\n-                    }\n-                }\n-                case DoubleType -> {\n-                    if (value < 0 || value > 1) {\n-                        throw new IllegalArgumentException(\"Constant double value not 0.0, or 1.0: \" + value);\n-                    }\n-                }\n-                default -> {\n-                    throw new IllegalArgumentException(\"Bad type for const instruction: \" + type);\n-                }\n-            }\n-\n-            this.value = value;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = super._attributes();\n-            m.put(ATTRIBUTE_VALUE, value);\n-            return m;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.with(ConstantInstruction.ofIntrinsic(getOpcode(type, value)));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t, int v) {\n-            return switch (t) {\n-                case IntType -> switch (v) {\n-                    case -1 -> Opcode.ICONST_M1;\n-                    case 0 -> Opcode.ICONST_0;\n-                    case 1 -> Opcode.ICONST_1;\n-                    case 2 -> Opcode.ICONST_2;\n-                    case 3 -> Opcode.ICONST_3;\n-                    case 4 -> Opcode.ICONST_4;\n-                    case 5 -> Opcode.ICONST_5;\n-                    default -> throw new InternalError(\"Should not reach here\");\n-                };\n-                case LongType -> switch (v) {\n-                    case 0 -> Opcode.LCONST_0;\n-                    case 1 -> Opcode.LCONST_1;\n-                    default -> throw new InternalError(\"Should not reach here\");\n-                };\n-                case FloatType -> switch (v) {\n-                    case 0 -> Opcode.FCONST_0;\n-                    case 1 -> Opcode.FCONST_1;\n-                    case 2 -> Opcode.FCONST_2;\n-                    default -> throw new InternalError(\"Should not reach here\");\n-                };\n-                case DoubleType -> switch (v) {\n-                    case 0 -> Opcode.DCONST_0;\n-                    case 1 -> Opcode.DCONST_1;\n-                    default -> throw new InternalError(\"Should not reach here\");\n-                };\n-                default -> throw new InternalError(\"Should not reach here\");\n-            };\n-        }\n-\n-        private static int getValue(ConstantDesc c) {\n-            if (c instanceof Number n) {\n-                return n.intValue();\n-            } else {\n-                throw new IllegalArgumentException(\"Unsupported constant value: \" + c);\n-            }\n-        }\n-    }\n-\n-    public static ConstInstructionOp _const(TypeKind type, int value) {\n-        return new ConstInstructionOp(type, value);\n-    }\n-\n-    @Opcodes(Opcode.ARRAYLENGTH)\n-    @OpDeclaration(ArrayLengthInstructionOp.NAME)\n-    public static final class ArrayLengthInstructionOp extends InstructionOp {\n-        public static final String NAME = \"arraylength\";\n-\n-        ArrayLengthInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this();\n-        }\n-\n-        ArrayLengthInstructionOp(ArrayLengthInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ArrayLengthInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ArrayLengthInstructionOp(this, cc);\n-        }\n-\n-        ArrayLengthInstructionOp() {\n-            super(NAME);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.arraylength();\n-        }\n-    }\n-\n-    public static ArrayLengthInstructionOp arraylength() {\n-        return new ArrayLengthInstructionOp();\n-    }\n-\n-    @Opcodes({Opcode.AALOAD, Opcode.BALOAD, Opcode.CALOAD, Opcode.SALOAD,\n-            Opcode.IALOAD, Opcode.LALOAD, Opcode.FALOAD, Opcode.DALOAD})\n-    @OpDeclaration(ArrayLoadInstructionOp.NAME)\n-    public static final class ArrayLoadInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Taload\";\n-\n-        ArrayLoadInstructionOp(InstructionDef<ArrayLoadInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        ArrayLoadInstructionOp(ArrayLoadInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ArrayLoadInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ArrayLoadInstructionOp(this, cc);\n-        }\n-\n-        ArrayLoadInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.arrayLoadInstruction(type);\n-        }\n-    }\n-\n-    public static ArrayLoadInstructionOp aload(TypeKind t) {\n-        return new ArrayLoadInstructionOp(t);\n-    }\n-\n-    @Opcodes({Opcode.AASTORE, Opcode.BASTORE, Opcode.CASTORE, Opcode.SASTORE,\n-            Opcode.IASTORE, Opcode.LASTORE, Opcode.FASTORE, Opcode.DASTORE})\n-    @OpDeclaration(ArrayStoreInstructionOp.NAME)\n-    public static final class ArrayStoreInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tastore\";\n-\n-        ArrayStoreInstructionOp(InstructionDef<ArrayStoreInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        ArrayStoreInstructionOp(ArrayStoreInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ArrayStoreInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ArrayStoreInstructionOp(this, cc);\n-        }\n-\n-        ArrayStoreInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.arrayStoreInstruction(type);\n-        }\n-    }\n-\n-    public static ArrayStoreInstructionOp astore(TypeKind t) {\n-        return new ArrayStoreInstructionOp(t);\n-    }\n-\n-\n-    @Opcodes({Opcode.INEG, Opcode.LNEG, Opcode.FNEG, Opcode.DNEG})\n-    @OpDeclaration(NegInstructionOp.NAME)\n-    public static final class NegInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tneg\";\n-\n-        NegInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        NegInstructionOp(NegInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public NegInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NegInstructionOp(this, cc);\n-        }\n-\n-        NegInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case IntType -> Opcode.INEG;\n-                case LongType -> Opcode.LNEG;\n-                case FloatType -> Opcode.FNEG;\n-                case DoubleType -> Opcode.DNEG;\n-                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n-            };\n-        }\n-    }\n-\n-    public static NegInstructionOp neg(TypeKind type) {\n-        return new NegInstructionOp(type);\n-    }\n-\n-    @Opcodes({Opcode.IADD, Opcode.LADD, Opcode.FADD, Opcode.DADD})\n-    @OpDeclaration(AddInstructionOp.NAME)\n-    public static final class AddInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tadd\";\n-\n-        AddInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        AddInstructionOp(AddInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public AddInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new AddInstructionOp(this, cc);\n-        }\n-\n-        AddInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case IntType -> Opcode.IADD;\n-                case LongType -> Opcode.LADD;\n-                case FloatType -> Opcode.FADD;\n-                case DoubleType -> Opcode.DADD;\n-                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n-            };\n-        }\n-    }\n-\n-    public static AddInstructionOp add(TypeKind type) {\n-        return new AddInstructionOp(type);\n-    }\n-\n-    @Opcodes({Opcode.IMUL, Opcode.LMUL, Opcode.FMUL, Opcode.DMUL})\n-    @OpDeclaration(MulInstructionOp.NAME)\n-    public static final class MulInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tmul\";\n-\n-        MulInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        MulInstructionOp(MulInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public MulInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new MulInstructionOp(this, cc);\n-        }\n-\n-        MulInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case IntType -> Opcode.IMUL;\n-                case LongType -> Opcode.LMUL;\n-                case FloatType -> Opcode.FMUL;\n-                case DoubleType -> Opcode.DMUL;\n-                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n-            };\n-        }\n-    }\n-\n-    public static MulInstructionOp mul(TypeKind type) {\n-        return new MulInstructionOp(type);\n-    }\n-\n-\n-    @Opcodes({Opcode.IDIV, Opcode.LDIV, Opcode.FDIV, Opcode.DDIV})\n-    @OpDeclaration(DivInstructionOp.NAME)\n-    public static final class DivInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tdiv\";\n-\n-        DivInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        DivInstructionOp(DivInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public DivInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new DivInstructionOp(this, cc);\n-        }\n-\n-        DivInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type()));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case IntType -> Opcode.IDIV;\n-                case LongType -> Opcode.LDIV;\n-                case FloatType -> Opcode.FDIV;\n-                case DoubleType -> Opcode.DDIV;\n-                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n-            };\n-        }\n-    }\n-\n-    public static DivInstructionOp div(TypeKind type) {\n-        return new DivInstructionOp(type);\n-    }\n-\n-    @Opcodes({Opcode.ISUB, Opcode.LSUB, Opcode.FSUB, Opcode.DSUB})\n-    @OpDeclaration(SubInstructionOp.NAME)\n-    public static final class SubInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tsub\";\n-\n-        SubInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        SubInstructionOp(SubInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public SubInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new SubInstructionOp(this, cc);\n-        }\n-\n-        SubInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type()));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case IntType -> Opcode.ISUB;\n-                case LongType -> Opcode.LSUB;\n-                case FloatType -> Opcode.FSUB;\n-                case DoubleType -> Opcode.DSUB;\n-                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n-            };\n-        }\n-    }\n-\n-    public static SubInstructionOp sub(TypeKind type) {\n-        return new SubInstructionOp(type);\n-    }\n-\n-    @Opcodes({Opcode.IREM, Opcode.LREM, Opcode.FREM, Opcode.DREM})\n-    @OpDeclaration(RemInstructionOp.NAME)\n-    public static final class RemInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Trem\";\n-\n-        RemInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        RemInstructionOp(RemInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public RemInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new RemInstructionOp(this, cc);\n-        }\n-\n-        RemInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type()));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case IntType -> Opcode.IREM;\n-                case LongType -> Opcode.LREM;\n-                case FloatType -> Opcode.FREM;\n-                case DoubleType -> Opcode.DREM;\n-                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n-            };\n-        }\n-    }\n-\n-    public static RemInstructionOp rem(TypeKind type) {\n-        return new RemInstructionOp(type);\n-    }\n-\n-    @Opcodes(Opcode.IINC)\n-    @OpDeclaration(IIncInstructionOp.NAME)\n-    public static final class IIncInstructionOp extends InstructionOp {\n-        public static final String NAME = \"iinc\";\n-\n-        public static final String ATTRIBUTE_INDEX = \"index\";\n-\n-        public static final String ATTRIBUTE_INCR = \"incr\";\n-\n-        final int slot;\n-        final int incr;\n-\n-        IIncInstructionOp(InstructionDef<IncrementInstruction> def) {\n-            this(def.instruction.slot(), def.instruction.constant());\n-        }\n-\n-        IIncInstructionOp(IIncInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.slot = that.slot;\n-            this.incr = that.incr;\n-        }\n-\n-        @Override\n-        public IIncInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new IIncInstructionOp(this, cc);\n-        }\n-\n-        IIncInstructionOp(int slot, int incr) {\n-            super(NAME);\n-\n-            this.slot = slot;\n-            this.incr = incr;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_INDEX, slot);\n-            m.put(ATTRIBUTE_INCR, incr);\n-            return m;\n-        }\n-\n-        public int index() {\n-            return slot;\n-        }\n-\n-        public int incr() {\n-            return incr;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.incrementInstruction(slot, incr);\n-        }\n-    }\n-\n-    public static IIncInstructionOp iinc(int slot, int incr) {\n-        return new IIncInstructionOp(slot, incr);\n-    }\n-\n-\n-    @Opcodes({Opcode.LCMP, Opcode.FCMPG, Opcode.DCMPG})\n-    @OpDeclaration(CmpInstructionOp.NAME)\n-    public static final class CmpInstructionOp extends TypedInstructionOp {\n-        public static final String NAME = \"Tcmp\";\n-\n-        CmpInstructionOp(InstructionDef<OperatorInstruction> def) {\n-            this(def.instruction.typeKind());\n-        }\n-\n-        CmpInstructionOp(CmpInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public CmpInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new CmpInstructionOp(this, cc);\n-        }\n-\n-        CmpInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-\n-            getOpcode(type);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.operatorInstruction(getOpcode(type()));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t) {\n-            return switch (t) {\n-                case LongType -> Opcode.LCMP;\n-                case FloatType -> Opcode.FCMPG; \/\/ FCMPL?\n-                case DoubleType -> Opcode.DCMPG; \/\/ DCMPL?\n-                default -> throw new InternalError(\"Should not reach here\");\n-            };\n-        }\n-    }\n-\n-    public static CmpInstructionOp cmp(TypeKind type) {\n-        return new CmpInstructionOp(type);\n-    }\n-\n-\n-    \/\/ Stack instructions\n-\n-    @Opcodes(Opcode.DUP)\n-    @OpDeclaration(DupInstructionOp.NAME)\n-    public static final class DupInstructionOp extends InstructionOp {\n-        public static final String NAME = \"dup\";\n-\n-        DupInstructionOp(InstructionDef<StackInstruction> def) {\n-            this();\n-        }\n-\n-        DupInstructionOp(DupInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public DupInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new DupInstructionOp(this, cc);\n-        }\n-\n-        DupInstructionOp() {\n-            super(NAME);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.dup();\n-        }\n-    }\n-\n-    public static DupInstructionOp dup() {\n-        return new DupInstructionOp();\n-    }\n-\n-    @Opcodes(Opcode.POP)\n-    @OpDeclaration(PopInstructionOp.NAME)\n-    public static final class PopInstructionOp extends InstructionOp {\n-        public static final String NAME = \"pop\";\n-\n-        PopInstructionOp(InstructionDef<StackInstruction> def) {\n-            this();\n-        }\n-\n-        PopInstructionOp(PopInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PopInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new PopInstructionOp(this, cc);\n-        }\n-\n-        PopInstructionOp() {\n-            super(NAME);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.pop();\n-        }\n-    }\n-\n-    public static PopInstructionOp pop() {\n-        return new PopInstructionOp();\n-    }\n-\n-    @Opcodes(Opcode.BIPUSH)\n-    @OpDeclaration(BipushInstructionOp.NAME)\n-    public static final class BipushInstructionOp extends InstructionOp {\n-        public static final String NAME = \"bipush\";\n-\n-        public static final String ATTRIBUTE_VALUE = \"value\";\n-\n-        final int value;\n-\n-        BipushInstructionOp(InstructionDef<ConstantInstruction.ArgumentConstantInstruction> def) {\n-            this(def.instruction.constantValue());\n-        }\n-\n-        BipushInstructionOp(BipushInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.value = that.value;\n-        }\n-\n-        @Override\n-        public BipushInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new BipushInstructionOp(this, cc);\n-        }\n-\n-        BipushInstructionOp(int value) {\n-            super(NAME);\n-\n-            this.value = value;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_VALUE, value);\n-            return m;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.bipush(value);\n-        }\n-    }\n-\n-    public static BipushInstructionOp bipush(byte value) {\n-        return new BipushInstructionOp(value);\n-    }\n-\n-    @Opcodes(Opcode.SIPUSH)\n-    @OpDeclaration(SipushInstructionOp.NAME)\n-    public static final class SipushInstructionOp extends InstructionOp {\n-        public static final String NAME = \"sipush\";\n-\n-        public static final String ATTRIBUTE_VALUE = \"value\";\n-\n-        final int value;\n-\n-        SipushInstructionOp(InstructionDef<ConstantInstruction.ArgumentConstantInstruction> def) {\n-            this(def.instruction.constantValue());\n-        }\n-\n-        SipushInstructionOp(SipushInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.value = that.value;\n-        }\n-\n-        @Override\n-        public SipushInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new SipushInstructionOp(this, cc);\n-        }\n-\n-        SipushInstructionOp(int value) {\n-            super(NAME);\n-\n-            this.value = value;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_VALUE, value);\n-            return m;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.sipush(value);\n-        }\n-    }\n-\n-    public static SipushInstructionOp sipush(short value) {\n-        return new SipushInstructionOp(value);\n-    }\n-\n-    \/\/ Reflective instructions\n-\n-    public static abstract class ClassTypeInstructionOp extends InstructionOp {\n-        public static final String ATTRIBUTE_DESC = \"desc\";\n-\n-        final TypeDesc desc;\n-\n-        ClassTypeInstructionOp(ClassTypeInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.desc = that.desc;\n-        }\n-\n-        ClassTypeInstructionOp(String name, TypeDesc desc) {\n-            super(name);\n-\n-            this.desc = desc;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_DESC, desc);\n-            return m;\n-        }\n-\n-        public TypeDesc desc() {\n-            return desc;\n-        }\n-    }\n-\n-    @Opcodes(Opcode.NEW)\n-    @OpDeclaration(NewInstructionOp.NAME)\n-    public static final class NewInstructionOp extends ClassTypeInstructionOp {\n-        public static final String NAME = \"new\";\n-\n-        NewInstructionOp(InstructionDef<NewObjectInstruction> def) {\n-            this(TypeDesc.ofNominalDescriptor(def.instruction.className().asSymbol()));\n-        }\n-\n-        NewInstructionOp(NewInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public NewInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NewInstructionOp(this, cc);\n-        }\n-\n-        NewInstructionOp(TypeDesc desc) {\n-            super(NAME, desc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.new_(desc.toNominalDescriptor());\n-        }\n-    }\n-\n-    public static NewInstructionOp _new(TypeDesc desc) {\n-        return new NewInstructionOp(desc);\n-    }\n-\n-    @Opcodes({Opcode.ANEWARRAY, Opcode.NEWARRAY})\n-    @OpDeclaration(NewArrayInstructionOp.NAME)\n-    public static final class NewArrayInstructionOp extends ClassTypeInstructionOp {\n-        public static final String NAME = \"Tnewarray\";\n-\n-        NewArrayInstructionOp(InstructionDef<Instruction> def) {\n-            this(getType(def.instruction));\n-        }\n-\n-        static TypeDesc getType(Instruction instruction) {\n-            if (instruction instanceof NewPrimitiveArrayInstruction a) {\n-                return switch (a.typeKind()) {\n-                    case BooleanType -> TypeDesc.BOOLEAN;\n-                    case ByteType -> TypeDesc.BYTE;\n-                    case ShortType -> TypeDesc.SHORT;\n-                    case CharType -> TypeDesc.CHAR;\n-                    case IntType -> TypeDesc.INT;\n-                    case FloatType -> TypeDesc.FLOAT;\n-                    case LongType -> TypeDesc.LONG;\n-                    case DoubleType -> TypeDesc.DOUBLE;\n-                    default -> throw new IllegalArgumentException(\"Bad array component type: \" + a.typeKind());\n-                };\n-            } else if (instruction instanceof NewReferenceArrayInstruction ra) {\n-                return TypeDesc.ofNominalDescriptor(ra.componentType().asSymbol());\n-            } else {\n-                throw new InternalError();\n-            }\n-        }\n-\n-        NewArrayInstructionOp(NewArrayInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public NewArrayInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NewArrayInstructionOp(this, cc);\n-        }\n-\n-        NewArrayInstructionOp(TypeDesc desc) {\n-            super(NAME, desc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            ClassDesc cd = desc().toNominalDescriptor();\n-            if (cd.isPrimitive()) {\n-                mv.newPrimitiveArrayInstruction(TypeKind.fromDescriptor(cd.descriptorString()));\n-            } else {\n-                mv.newReferenceArrayInstruction(cd);\n-            }\n-        }\n-    }\n-\n-    public static NewArrayInstructionOp newarray(TypeDesc desc) {\n-        return new NewArrayInstructionOp(desc);\n-    }\n-\n-    @Opcodes(Opcode.MULTIANEWARRAY)\n-    @OpDeclaration(MultiNewArrayInstructionOp.NAME)\n-    public static final class MultiNewArrayInstructionOp extends ClassTypeInstructionOp {\n-        public static final String NAME = \"multinewarray\";\n-\n-        public static final String ATTRIBUTE_DIMS = \"dims\";\n-\n-        final int dims;\n-\n-        MultiNewArrayInstructionOp(InstructionDef<NewMultiArrayInstruction> def) {\n-            this(TypeDesc.ofNominalDescriptor(def.instruction().arrayType().asSymbol()), def.instruction().dimensions());\n-        }\n-\n-        MultiNewArrayInstructionOp(MultiNewArrayInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.dims = that.dims;\n-        }\n-\n-        @Override\n-        public MultiNewArrayInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new MultiNewArrayInstructionOp(this, cc);\n-        }\n-\n-        MultiNewArrayInstructionOp(TypeDesc desc, int dims) {\n-            super(NAME, desc);\n-\n-            this.dims = dims;\n-        }\n-\n-        public int dims() {\n-            return dims;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = super._attributes();\n-            m.put(ATTRIBUTE_DIMS, dims);\n-            return m;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.multianewarray(desc().toNominalDescriptor(), dims);\n-        }\n-    }\n-\n-    public static MultiNewArrayInstructionOp multinewarray(TypeDesc desc, int dims) {\n-        return new MultiNewArrayInstructionOp(desc, dims);\n-    }\n-\n-    @Opcodes(Opcode.INSTANCEOF)\n-    @OpDeclaration(InstanceOfInstructionOp.NAME)\n-    public static final class InstanceOfInstructionOp extends ClassTypeInstructionOp {\n-        public static final String NAME = \"instanceof\";\n-\n-        InstanceOfInstructionOp(InstructionDef<TypeCheckInstruction> def) {\n-            this(TypeDesc.ofNominalDescriptor(def.instruction().type().asSymbol()));\n-        }\n-\n-        InstanceOfInstructionOp(InstanceOfInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public InstanceOfInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new InstanceOfInstructionOp(this, cc);\n-        }\n-\n-        InstanceOfInstructionOp(TypeDesc desc) {\n-            super(NAME, desc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.instanceof_(desc().toNominalDescriptor());\n-        }\n-    }\n-\n-    public static InstanceOfInstructionOp instanceOf(TypeDesc desc) {\n-        return new InstanceOfInstructionOp(desc);\n-    }\n-\n-    @Opcodes(Opcode.CHECKCAST)\n-    @OpDeclaration(CheckCastInstructionOp.NAME)\n-    public static final class CheckCastInstructionOp extends ClassTypeInstructionOp {\n-        public static final String NAME = \"checkcast\";\n-\n-        CheckCastInstructionOp(InstructionDef<TypeCheckInstruction> def) {\n-            this(TypeDesc.ofNominalDescriptor(def.instruction().type().asSymbol()));\n-        }\n-\n-        CheckCastInstructionOp(CheckCastInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public CheckCastInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new CheckCastInstructionOp(this, cc);\n-        }\n-\n-        CheckCastInstructionOp(TypeDesc desc) {\n-            super(NAME, desc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.checkcast(desc().toNominalDescriptor());\n-        }\n-    }\n-\n-    public static CheckCastInstructionOp checkCast(TypeDesc desc) {\n-        return new CheckCastInstructionOp(desc);\n-    }\n-\n-    enum FieldKind {\n-        STATIC, INSTANCE,\n-    }\n-\n-    public static abstract class FieldInstructionOp extends InstructionOp {\n-        public static final String ATTRIBUTE_KIND = \"kind\";\n-        public static final String ATTRIBUTE_DESC = \"desc\";\n-\n-        final FieldKind kind;\n-        final FieldDesc desc;\n-\n-        FieldInstructionOp(FieldInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.kind = that.kind;\n-            this.desc = that.desc;\n-        }\n-\n-        FieldInstructionOp(String name, FieldKind kind, FieldDesc desc) {\n-            super(name);\n-\n-            this.kind = kind;\n-            this.desc = desc;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_KIND, kind);\n-            m.put(ATTRIBUTE_DESC, desc);\n-            return m;\n-        }\n-\n-        public FieldKind kind() {\n-            return kind;\n-        }\n-\n-        public FieldDesc desc() {\n-            return desc;\n-        }\n-\n-        static FieldDesc getFieldDesc(FieldRefEntry node) {\n-            return FieldDesc.field(\n-                    TypeDesc.ofNominalDescriptor(node.owner().asSymbol()),\n-                    node.name().stringValue(),\n-                    TypeDesc.ofNominalDescriptorString(node.type().stringValue()));\n-        }\n-    }\n-\n-    @Opcodes({Opcode.GETFIELD, Opcode.GETSTATIC})\n-    @OpDeclaration(GetFieldInstructionOp.NAME)\n-    public static final class GetFieldInstructionOp extends FieldInstructionOp {\n-        public static final String NAME = \"getfield\";\n-\n-        GetFieldInstructionOp(InstructionDef<FieldInstruction> def) {\n-            this(getFieldKind(def.opcode()), getFieldDesc(def.instruction().field()));\n-        }\n-\n-        GetFieldInstructionOp(GetFieldInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public GetFieldInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new GetFieldInstructionOp(this, cc);\n-        }\n-\n-        GetFieldInstructionOp(FieldKind kind, FieldDesc desc) {\n-            super(NAME, kind, desc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            FieldDesc desc = desc();\n-            mv.fieldInstruction(getOpcode(kind),\n-                    desc.refType().toNominalDescriptor(), desc.name(), desc.type().toNominalDescriptor());\n-        }\n-\n-        private static Opcode getOpcode(FieldKind kind) {\n-            return switch (kind) {\n-                case STATIC -> Opcode.GETSTATIC;\n-                case INSTANCE -> Opcode.GETFIELD;\n-            };\n-        }\n-\n-        private static FieldKind getFieldKind(Opcode opcode) {\n-            return switch (opcode) {\n-                case GETSTATIC -> FieldKind.STATIC;\n-                case GETFIELD -> FieldKind.INSTANCE;\n-                default -> throw new InternalError();\n-            };\n-        }\n-    }\n-\n-    public static GetFieldInstructionOp getField(FieldKind kind, FieldDesc desc) {\n-        return new GetFieldInstructionOp(kind, desc);\n-    }\n-\n-    @Opcodes({Opcode.PUTFIELD, Opcode.PUTSTATIC})\n-    @OpDeclaration(PutFieldInstructionOp.NAME)\n-    public static final class PutFieldInstructionOp extends FieldInstructionOp {\n-        public static final String NAME = \"putfield\";\n-\n-        PutFieldInstructionOp(InstructionDef<FieldInstruction> def) {\n-            this(getFieldKind(def.opcode()), getFieldDesc(def.instruction().field()));\n-        }\n-\n-        PutFieldInstructionOp(PutFieldInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PutFieldInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new PutFieldInstructionOp(this, cc);\n-        }\n-\n-        PutFieldInstructionOp(FieldKind kind, FieldDesc desc) {\n-            super(NAME, kind, desc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            FieldDesc desc = desc();\n-            mv.fieldInstruction(getOpcode(kind),\n-                    desc.refType().toNominalDescriptor(), desc.name(), desc.type().toNominalDescriptor());\n-        }\n-\n-        private static Opcode getOpcode(FieldKind kind) {\n-            return switch (kind) {\n-                case STATIC -> Opcode.PUTSTATIC;\n-                case INSTANCE -> Opcode.PUTFIELD;\n-            };\n-        }\n-\n-        private static FieldKind getFieldKind(Opcode opcode) {\n-            return switch (opcode) {\n-                case PUTSTATIC -> FieldKind.STATIC;\n-                case PUTFIELD -> FieldKind.INSTANCE;\n-                default -> throw new InternalError();\n-            };\n-        }\n-    }\n-\n-    public static PutFieldInstructionOp putField(FieldKind kind, FieldDesc desc) {\n-        return new PutFieldInstructionOp(kind, desc);\n-    }\n-\n-    enum InvokeKind {\n-        STATIC, VIRTUAL, INTERFACE, SPECIAL,\n-    }\n-\n-    \/\/ @@@ static\/virtual\/special invocation on interfaces\n-    @Opcodes({Opcode.INVOKESTATIC, Opcode.INVOKEVIRTUAL, Opcode.INVOKEINTERFACE, Opcode.INVOKESPECIAL})\n-    @OpDeclaration(InvokeInstructionOp.NAME)\n-    public static final class InvokeInstructionOp extends InstructionOp {\n-        public static final String NAME = \"invoke\";\n-\n-        public static final String ATTRIBUTE_KIND = \"kind\";\n-        public static final String ATTRIBUTE_DESC = \"desc\";\n-        public static final String ATTRIBUTE_IFACE = \"iface\";\n-\n-        final InvokeKind kind;\n-        final MethodDesc desc;\n-        final boolean iface;\n-\n-        InvokeInstructionOp(InstructionDef<InvokeInstruction> def) {\n-            this(getInvokeKind(def.opcode()), getMethodDesc(def.instruction().method()), def.instruction().isInterface());\n-        }\n-\n-        InvokeInstructionOp(InvokeInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.kind = that.kind;\n-            this.desc = that.desc;\n-            this.iface = that.iface;\n-        }\n-\n-        @Override\n-        public InvokeInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new InvokeInstructionOp(this, cc);\n-        }\n-\n-        InvokeInstructionOp(InvokeKind kind, MethodDesc desc, boolean iface) {\n-            super(NAME);\n-\n-            this.kind = kind;\n-            this.desc = desc;\n-            this.iface = iface;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_KIND, kind);\n-            m.put(ATTRIBUTE_DESC, desc);\n-            m.put(ATTRIBUTE_IFACE, iface);\n-            return m;\n-        }\n-\n-        public InvokeKind kind() {\n-            return kind;\n-        }\n-\n-        public MethodDesc desc() {\n-            return desc;\n-        }\n-\n-        public boolean iface() {\n-            return iface;\n-        }\n-\n-        public MethodTypeDesc callOpDescriptor() {\n-            return switch (kind) {\n-                case STATIC -> desc.type();\n-                case VIRTUAL, INTERFACE, SPECIAL -> {\n-                    List<TypeDesc> params = new ArrayList<>();\n-                    params.add(desc.refType());\n-                    params.addAll(desc.type().parameters());\n-                    yield MethodTypeDesc.methodType(desc.type().returnType(), params);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            MethodDesc desc = desc();\n-\n-            \/\/ @@@ interfaces\n-            mv.invokeInstruction(\n-                    getOpcode(kind()),\n-                    desc.refType().toNominalDescriptor(),\n-                    desc.name(),\n-                    desc.type().toNominalDescriptor(),\n-                    iface()\n-            );\n-        }\n-\n-        private static Opcode getOpcode(InvokeKind kind) {\n-            return switch (kind) {\n-                case STATIC -> Opcode.INVOKESTATIC;\n-                case VIRTUAL -> Opcode.INVOKEVIRTUAL;\n-                case INTERFACE -> Opcode.INVOKEINTERFACE;\n-                case SPECIAL -> Opcode.INVOKESPECIAL;\n-            };\n-        }\n-\n-        private static InvokeKind getInvokeKind(Opcode opcode) {\n-            return switch (opcode) {\n-                case INVOKESTATIC -> InvokeKind.STATIC;\n-                case INVOKEVIRTUAL -> InvokeKind.VIRTUAL;\n-                case INVOKEINTERFACE -> InvokeKind.INTERFACE;\n-                case INVOKESPECIAL -> InvokeKind.SPECIAL;\n-                default -> throw new InternalError();\n-            };\n-        }\n-\n-        private static MethodDesc getMethodDesc(MemberRefEntry node) {\n-            return MethodDesc.method(\n-                    TypeDesc.ofNominalDescriptor(node.owner().asSymbol()),\n-                    node.name().stringValue(),\n-                    MethodTypeDesc.ofNominalDescriptor(java.lang.constant.MethodTypeDesc.ofDescriptor(node.type().stringValue())));\n-        }\n-    }\n-\n-    public static InvokeInstructionOp invoke(InvokeKind kind, MethodDesc desc) {\n-        return new InvokeInstructionOp(kind, desc, false);\n-    }\n-\n-    public static InvokeInstructionOp invoke(InvokeKind kind, MethodDesc desc, boolean isInterface) {\n-        return new InvokeInstructionOp(kind, desc, isInterface);\n-    }\n-\n-    \/\/ Terminating instructions\n-\n-    @Opcodes(Opcode.GOTO)\n-    @OpDeclaration(GotoInstructionOp.NAME)\n-    public static final class GotoInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n-        public static final String NAME = \"goto\";\n-\n-        GotoInstructionOp(InstructionDef<BranchInstruction> def) {\n-            this(def.successors.get(0));\n-        }\n-\n-        GotoInstructionOp(GotoInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public GotoInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new GotoInstructionOp(this, cc);\n-        }\n-\n-        GotoInstructionOp(Block.Reference t) {\n-            super(NAME, List.of(t));\n-\n-            if (!t.arguments().isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        public Block targetBranch() {\n-            return successors().get(0).targetBlock();\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.goto_(c.getLabel(targetBranch()));\n-        }\n-    }\n-\n-    public static GotoInstructionOp _goto(Block.Reference t) {\n-        return new GotoInstructionOp(t);\n-    }\n-\n-    enum Comparison {\n-        EQ(\"NE\"),\n-        NE(\"EQ\"),\n-        LT(\"GE\"),\n-        GE(\"LT\"),\n-        GT(\"LE\"),\n-        LE(\"GT\");\n-\n-        private final String inverseName;\n-\n-        Comparison(String inverseName) {\n-            this.inverseName = inverseName;\n-        }\n-\n-        public Comparison inverse() {\n-            return Comparison.valueOf(inverseName);\n-        }\n-    }\n-\n-    @Opcodes({Opcode.IF_ACMPEQ, Opcode.IF_ACMPNE,\n-            Opcode.IF_ICMPEQ, Opcode.IF_ICMPNE, Opcode.IF_ICMPLT, Opcode.IF_ICMPGE, Opcode.IF_ICMPGT, Opcode.IF_ICMPLE\n-    })\n-    @OpDeclaration(IfcmpInstructionOp.NAME)\n-    public static final class IfcmpInstructionOp extends TypedTerminatingInstructionOp implements Op.BlockTerminating {\n-        public static final String NAME = \"if_TcmpC\";\n-\n-        public static final String ATTRIBUTE_COND = \"cond\";\n-\n-        final Comparison cond;\n-\n-        IfcmpInstructionOp(InstructionDef<BranchInstruction> def) {\n-            this(def.instruction().opcode().primaryTypeKind(), getComparison(def.opcode()),\n-                    def.successors.get(0), def.successors.get(1));\n-        }\n-\n-        IfcmpInstructionOp(IfcmpInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.cond = that.cond;\n-        }\n-\n-        @Override\n-        public IfcmpInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new IfcmpInstructionOp(this, cc);\n-        }\n-\n-        IfcmpInstructionOp(TypeKind type, Comparison c, Block.Reference t, Block.Reference f) {\n-            \/\/ Ensure successor order is false branch, then true branch, for correct topological ordering\n-            super(NAME, type, List.of(f, t));\n-\n-            if (type != TypeKind.IntType && type != TypeKind.ReferenceType) {\n-                throw new IllegalArgumentException(\"Unsupported type: \" + type);\n-            }\n-\n-            if (type == TypeKind.ReferenceType) {\n-                if (c != Comparison.EQ && c != Comparison.NE) {\n-                    throw new IllegalArgumentException(\"Unsupported condition for reference (A) type: \" + c);\n-                }\n-            }\n-\n-            if (!t.arguments().isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            if (!f.arguments().isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            this.cond = c;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = super._attributes();\n-            m.put(ATTRIBUTE_COND, cond);\n-            return m;\n-        }\n-\n-        public Comparison cond() {\n-            return cond;\n-        }\n-\n-        public Block trueBranch() {\n-            return successors().get(1).targetBlock();\n-        }\n-\n-        public Block falseBranch() {\n-            return successors().get(0).targetBlock();\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            \/\/ False branch must be immediately after (in sequence) to this block\n-            mv.branchInstruction(getOpcode(type(), cond()), c.getLabel(trueBranch()));\n-        }\n-\n-        private static Opcode getOpcode(TypeKind t, Comparison c) {\n-            return switch (t) {\n-                case ReferenceType -> switch (c) {\n-                    case EQ -> Opcode.IF_ACMPEQ;\n-                    case NE -> Opcode.IF_ACMPNE;\n-                    default -> throw new InternalError(\"Should not reach here\");\n-                };\n-                case IntType -> switch (c) {\n-                    case EQ -> Opcode.IF_ICMPEQ;\n-                    case NE -> Opcode.IF_ICMPNE;\n-                    case LT -> Opcode.IF_ICMPLT;\n-                    case GE -> Opcode.IF_ICMPGE;\n-                    case GT -> Opcode.IF_ICMPGT;\n-                    case LE -> Opcode.IF_ICMPLE;\n-                };\n-                default -> throw new InternalError(\"Should not reach here\");\n-            };\n-        }\n-\n-        private static Comparison getComparison(Opcode opcode) {\n-            return switch (opcode) {\n-                case IF_ACMPEQ -> Comparison.EQ;\n-                case IF_ACMPNE -> Comparison.NE;\n-                case IF_ICMPEQ -> Comparison.EQ;\n-                case IF_ICMPNE -> Comparison.NE;\n-                case IF_ICMPLT -> Comparison.LT;\n-                case IF_ICMPGE -> Comparison.GE;\n-                case IF_ICMPGT -> Comparison.GT;\n-                case IF_ICMPLE -> Comparison.LE;\n-                default -> throw new InternalError(\"Should not reach here\");\n-            };\n-        }\n-    }\n-\n-    public static IfcmpInstructionOp if_cmp(TypeKind type, Comparison c, Block.Reference t, Block.Reference f) {\n-        return new IfcmpInstructionOp(type, c, t, f);\n-    }\n-\n-    @Opcodes({Opcode.IFEQ, Opcode.IFNE,\n-            Opcode.IFLT, Opcode.IFGE, Opcode.IFGT, Opcode.IFLE\n-    })\n-    @OpDeclaration(IfInstructionOp.NAME)\n-    public static final class IfInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n-        public static final String NAME = \"ifC\";\n-\n-        public static final String ATTRIBUTE_COND = \"cond\";\n-\n-        final Comparison cond;\n-\n-        IfInstructionOp(InstructionDef<BranchInstruction> def) {\n-            this(getComparison(def.opcode()), def.successors.get(0), def.successors.get(1));\n-        }\n-\n-        IfInstructionOp(IfInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.cond = that.cond;\n-        }\n-\n-        IfInstructionOp(Comparison c, Block.Reference t, Block.Reference f) {\n-            \/\/ Ensure successor order is false branch, then true branch, for correct topological ordering\n-            super(NAME, List.of(f, t));\n-\n-            if (!t.arguments().isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            if (!f.arguments().isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            this.cond = c;\n-        }\n-\n-        @Override\n-        public IfInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new IfInstructionOp(this, cc);\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_COND, cond);\n-            return m;\n-        }\n-\n-        public Comparison cond() {\n-            return cond;\n-        }\n-\n-        public Block trueBranch() {\n-            return successors().get(1).targetBlock();\n-        }\n-\n-        public Block falseBranch() {\n-            return successors().get(0).targetBlock();\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            \/\/ False branch must be immediately after (in sequence) to this block\n-            mv.branchInstruction(getOpcode(cond()), c.getLabel(trueBranch()));\n-        }\n-\n-        private static Opcode getOpcode(Comparison c) {\n-            return switch (c) {\n-                case EQ -> Opcode.IFEQ;\n-                case NE -> Opcode.IFNE;\n-                case LT -> Opcode.IFLT;\n-                case GE -> Opcode.IFGE;\n-                case GT -> Opcode.IFGT;\n-                case LE -> Opcode.IFLE;\n-            };\n-        }\n-\n-        private static Comparison getComparison(Opcode opcode) {\n-            return switch (opcode) {\n-                case IFEQ -> Comparison.EQ;\n-                case IFNE -> Comparison.NE;\n-                case IFLT -> Comparison.LT;\n-                case IFGE -> Comparison.GE;\n-                case IFGT -> Comparison.GT;\n-                case IFLE -> Comparison.LE;\n-                default -> throw new InternalError();\n-            };\n-        }\n-    }\n-\n-    public static IfInstructionOp _if(Comparison c, Block.Reference t, Block.Reference f) {\n-        return new IfInstructionOp(c, t, f);\n-    }\n-\n-    @Opcodes({Opcode.ARETURN, Opcode.IRETURN, Opcode.LRETURN, Opcode.FRETURN, Opcode.DRETURN})\n-    @OpDeclaration(ReturnInstructionOp.NAME)\n-    public static final class ReturnInstructionOp extends TypedTerminatingInstructionOp implements Op.BodyTerminating {\n-        public static final String NAME = \"Treturn\";\n-\n-        ReturnInstructionOp(InstructionDef<ReturnInstruction> def) {\n-            this(def.instruction().typeKind());\n-        }\n-\n-        ReturnInstructionOp(ReturnInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        ReturnInstructionOp(TypeKind type) {\n-            super(NAME, type);\n-        }\n-\n-        @Override\n-        public ReturnInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ReturnInstructionOp(this, cc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.returnInstruction(type());\n-        }\n-    }\n-\n-    @Opcodes(Opcode.RETURN)\n-    @OpDeclaration(VoidReturnInstructionOp.NAME)\n-    public static final class VoidReturnInstructionOp extends TerminatingInstructionOp implements Op.BodyTerminating {\n-        public static final String NAME = \"return\";\n-\n-        VoidReturnInstructionOp(InstructionDef<ReturnInstruction> def) {\n-            this();\n-        }\n-\n-        VoidReturnInstructionOp(VoidReturnInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        VoidReturnInstructionOp() {\n-            super(NAME);\n-        }\n-\n-        @Override\n-        public VoidReturnInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new VoidReturnInstructionOp(this, cc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.return_();\n-        }\n-    }\n-\n-    public static ReturnInstructionOp _return(TypeKind type) {\n-        return new ReturnInstructionOp(type);\n-    }\n-\n-    public static VoidReturnInstructionOp _return() {\n-        return new VoidReturnInstructionOp();\n-    }\n-\n-    @Opcodes(Opcode.ATHROW)\n-    @OpDeclaration(AthrowInstructionOp.NAME)\n-    public static final class AthrowInstructionOp extends TerminatingInstructionOp implements Op.BodyTerminating {\n-        public static final String NAME = \"athrow\";\n-\n-        AthrowInstructionOp(InstructionDef<ThrowInstruction> def) {\n-            this();\n-        }\n-\n-        AthrowInstructionOp(AthrowInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        AthrowInstructionOp() {\n-            super(NAME);\n-        }\n-\n-        @Override\n-        public AthrowInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new AthrowInstructionOp(this, cc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.athrow();\n-        }\n-    }\n-\n-    static public AthrowInstructionOp athrow() {\n-        return new AthrowInstructionOp();\n-    }\n-\n-    @Opcodes(Opcode.TABLESWITCH)\n-    @OpDeclaration(TableswitchInstructionOp.NAME)\n-    public static final class TableswitchInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n-        public static final String NAME = \"tableswitch\";\n-\n-        public static final String ATTRIBUTE_LOW = \"low\";\n-        public static final String ATTRIBUTE_HIGH = \"high\";\n-\n-        final int low;\n-        final int high;\n-\n-        TableswitchInstructionOp(InstructionDef<TableSwitchInstruction> def) {\n-            this(def.instruction().lowValue(), def.instruction().highValue(), def.successors);\n-        }\n-\n-        TableswitchInstructionOp(TableswitchInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.low = that.low;\n-            this.high = that.high;\n-        }\n-\n-        TableswitchInstructionOp(int low, int high, List<Block.Reference> successors) {\n-            super(NAME, successors);\n-\n-            if (low > high) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            if (high - low + 1 != successors.size()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            this.low = low;\n-            this.high = high;\n-        }\n-\n-        @Override\n-        public TableswitchInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new TableswitchInstructionOp(this, cc);\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_LOW, low);\n-            m.put(ATTRIBUTE_HIGH, high);\n-            return m;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.tableswitch(low, high, c.getLabel(successors().get(0).targetBlock()), getSwitchCases(c));\n-        }\n-\n-        private List<SwitchCase> getSwitchCases(MethodVisitorContext c) {\n-            List<SwitchCase> cases = new ArrayList<>();\n-            int caseValue = low;\n-            for (int i = 1; i < successors.size(); i++) {\n-                cases.add(SwitchCase.of(caseValue++, c.getLabel(successors.get(i))));\n-            }\n-            return cases;\n-        }\n-    }\n-\n-    static public TableswitchInstructionOp tableswitch(int min, int max, List<Block.Reference> successors) {\n-        return new TableswitchInstructionOp(min, max, successors);\n-    }\n-\n-    @Opcodes(Opcode.LOOKUPSWITCH)\n-    @OpDeclaration(LookupswitchInstructionOp.NAME)\n-    public static final class LookupswitchInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n-        public static final String NAME = \"lookupswitch\";\n-\n-        public static final String ATTRIBUTE_KEYS = \"keys\";\n-\n-        final List<Integer> keys;\n-\n-        LookupswitchInstructionOp(InstructionDef<LookupSwitchInstruction> def) {\n-            this(getKeys(def.instruction().cases()), def.successors);\n-        }\n-\n-        LookupswitchInstructionOp(LookupswitchInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.keys = that.keys;\n-        }\n-\n-        LookupswitchInstructionOp(List<Integer> keys, List<Block.Reference> successors) {\n-            super(NAME, successors);\n-\n-            if (keys.size() != successors.size() - 1) {\n-                throw new IllegalArgumentException(\"Number of keys must be one less than number of successors\");\n-            }\n-\n-            this.keys = List.copyOf(keys);\n-        }\n-\n-        @Override\n-        public LookupswitchInstructionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LookupswitchInstructionOp(this, cc);\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            m.put(ATTRIBUTE_KEYS, keys.toString());\n-            return m;\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            mv.lookupswitch(c.getLabel(successors().get(0).targetBlock()), getSwitchCases(c));\n-        }\n-\n-        private static List<Integer> getKeys(List<SwitchCase> cases) {\n-            return cases.stream().map(SwitchCase::caseValue).toList();\n-        }\n-\n-        private List<SwitchCase> getSwitchCases(MethodVisitorContext c) {\n-            List<SwitchCase> cases = new ArrayList<>();\n-            for (int i = 1; i < successors.size(); i++) {\n-                cases.add(SwitchCase.of(keys.get(i - 1), c.getLabel(successors.get(i))));\n-            }\n-            return cases;\n-        }\n-    }\n-\n-    static public LookupswitchInstructionOp lookupswitch(List<Integer> keys, List<Block.Reference> successors) {\n-        return new LookupswitchInstructionOp(keys, successors);\n-    }\n-\n-    \/\/ Internal control operations\n-\n-    public static abstract class ControlInstructionOp extends Op {\n-        private final TypeDesc resultType;\n-\n-        ControlInstructionOp(ControlInstructionOp that, CopyContext cc) {\n-            super(that, cc);\n-            this.resultType = that.resultType;\n-        }\n-\n-        ControlInstructionOp(String name, TypeDesc resultType, List<Value> operands) {\n-            super(name, operands);\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public final Map<String, Object> attributes() {\n-            Map<String, Object> m = _attributes();\n-            return m.isEmpty() ? m : Collections.unmodifiableMap(m);\n-        }\n-\n-        Map<String, Object> _attributes() {\n-            return Map.of();\n-        }\n-\n-        public abstract void apply(CodeBuilder mv, MethodVisitorContext c);\n-\n-        @Override\n-        public TypeDesc resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    enum PrimitiveFrameType {\n-        TOP, INTEGER, FLOAT, DOUBLE, LONG, NULL, UNINITIALIZED_THIS\n-    }\n-\n-    public static class Frame extends ControlInstructionOp {\n-        public static final String NAME = \"frame\";\n-\n-        public static final String ATTRIBUTE_TYPE = \"type\";\n-        public static final String ATTRIBUTE_LOCAL = \"local\";\n-        public static final String ATTRIBUTE_STACK = \"stack\";\n-\n-        final StackMapFrameInfo node;\n-\n-        Frame(Frame that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.node = that.node;\n-        }\n-\n-        @Override\n-        public Frame transform(CopyContext cc, OpTransformer ot) {\n-            return new Frame(this, cc);\n-        }\n-\n-        Frame(StackMapFrameInfo node) {\n-            super(NAME, TypeDesc.VOID, List.of());\n-\n-            this.node = node;\n-        }\n-\n-        @Override\n-        Map<String, Object> _attributes() {\n-            Map<String, Object> m = new HashMap<>();\n-            \/\/ @@@ Convert local\/stack elements to types\n-            m.put(ATTRIBUTE_TYPE, node.frameType());\n-            m.put(ATTRIBUTE_LOCAL, node.locals().toString());\n-            m.put(ATTRIBUTE_STACK, node.stack().toString());\n-            return m;\n-        }\n-\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-        }\n-\n-        public boolean hasOperandStackElements() {\n-            return !node.stack().isEmpty();\n-        }\n-\n-        public List<TypeDesc> operandStackTypes() {\n-            List<TypeDesc> stackTypes = new ArrayList<>();\n-            for (StackMapFrameInfo.VerificationTypeInfo ost : node.stack()) {\n-                if (ost instanceof StackMapFrameInfo.SimpleVerificationTypeInfo i) {\n-                    switch (i) {\n-                        case ITEM_TOP -> {\n-                            \/\/ @@@\n-                            stackTypes.add(TypeDesc.J_L_OBJECT);\n-                        }\n-                        case ITEM_INTEGER -> {\n-                            stackTypes.add(TypeDesc.INT);\n-                        }\n-                        case ITEM_FLOAT -> {\n-                            stackTypes.add(TypeDesc.FLOAT);\n-                        }\n-                        case ITEM_DOUBLE -> {\n-                            stackTypes.add(TypeDesc.DOUBLE);\n-                        }\n-                        case ITEM_LONG -> {\n-                            stackTypes.add(TypeDesc.LONG);\n-                        }\n-                        case ITEM_NULL -> {\n-                            \/\/ @@@\n-                            stackTypes.add(TypeDesc.J_L_OBJECT);\n-                        }\n-                        case ITEM_UNINITIALIZED_THIS -> {\n-                            \/\/ @@@\n-                            stackTypes.add(TypeDesc.J_L_OBJECT);\n-                        }\n-                    }\n-                } else if (ost instanceof StackMapFrameInfo.ObjectVerificationTypeInfo i) {\n-                    stackTypes.add(TypeDesc.ofNominalDescriptor(i.classSymbol()));\n-                } else if (ost instanceof StackMapFrameInfo.UninitializedVerificationTypeInfo i) {\n-                    \/\/ @@@\n-                    \/\/ label designates the NEW instruction that created the uninitialized value\n-                }\n-            }\n-            return stackTypes;\n-        }\n-    }\n-\n-    public static Frame frame(StackMapFrameInfo node) {\n-        return new Frame(node);\n-    }\n-\n-\n-    public static final class ExceptionTableStart extends ControlInstructionOp implements Op.BlockTerminating {\n-        public static final String NAME = \"exceptionTableStart\";\n-\n-        \/\/ First successor is the non-exceptional successor whose target indicates\n-        \/\/ the first block in the exception region.\n-        \/\/ One or more subsequent successors target the exception catching blocks\n-        \/\/ each of which have one block argument whose type is an exception type,\n-        \/\/ or no block argument for the finally block (that occurs last)\n-        final List<Block.Reference> s;\n-\n-        ExceptionTableStart(ExceptionTableStart that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n-        }\n-\n-        @Override\n-        public ExceptionTableStart transform(CopyContext cc, OpTransformer ot) {\n-            return new ExceptionTableStart(this, cc);\n-        }\n-\n-        ExceptionTableStart(List<Block.Reference> s) {\n-            super(NAME, TypeDesc.VOID, List.of());\n-\n-            if (s.size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n-            }\n-\n-            this.s = List.copyOf(s);\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return s;\n-        }\n-\n-        public Block.Reference start() {\n-            return s.get(0);\n-        }\n-\n-        public List<Block.Reference> catchBlocks() {\n-            return s.subList(1, s.size());\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            Label start = c.getLabel(result());\n-            c.exceptionRegionStack().push(this);\n-            mv.labelBinding(start);\n-        }\n-    }\n-\n-    public static ExceptionTableStart exceptionTableStart(Block.Reference start, Block.Reference... catchers) {\n-        return exceptionTableStart(start, List.of(catchers));\n-    }\n-\n-    public static ExceptionTableStart exceptionTableStart(Block.Reference start, List<Block.Reference> catchers) {\n-        List<Block.Reference> s = new ArrayList<>();\n-        s.add(start);\n-        s.addAll(catchers);\n-        return new ExceptionTableStart(s);\n-    }\n-\n-    public static final class ExceptionTableEnd extends ControlInstructionOp {\n-        public static final String NAME = \"exceptionTableEnd\";\n-\n-        ExceptionTableEnd(ExceptionTableEnd that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        ExceptionTableEnd() {\n-            super(NAME, TypeDesc.VOID, List.of());\n-        }\n-\n-        @Override\n-        public ExceptionTableEnd transform(CopyContext cc, OpTransformer ot) {\n-            return new ExceptionTableEnd(this, cc);\n-        }\n-\n-        @Override\n-        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n-            ExceptionTableStart er = c.exceptionRegionStack().pop();\n-            Label start = c.getLabel(er.result());\n-            Label end = c.getLabel(er);\n-            mv.labelBinding(end);\n-            for (Block.Reference catchBlockSuccessor : er.catchBlocks()) {\n-                Block catchBlock = catchBlockSuccessor.targetBlock();\n-                Label handle = c.getLabel(catchBlock);\n-\n-                if (!catchBlock.parameters().isEmpty()) {\n-                    ClassDesc type = catchBlock.parameters().get(0).type().toNominalDescriptor();\n-                    mv.exceptionCatch(start, end, handle, type);\n-                } else {\n-                    mv.exceptionCatchAll(start, end, handle);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static ExceptionTableEnd exceptionTableEnd() {\n-        return new ExceptionTableEnd();\n-    }\n-\n-\n-    \/\/ Opcode factory creation\n-\n-    public static InstructionOp create(InstructionDef<? extends Instruction> def) {\n-        MethodHandle mh = INSTRUCTION_FACTORY[def.opcode().bytecode()];\n-        if (mh == null) {\n-            throw new UnsupportedOperationException(\"Instruction unsupported, opcode = '\" + def.opcode());\n-        }\n-        try {\n-            return (InstructionOp) mh.invoke(def);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);\n-        }\n-    }\n-\n-    static final MethodHandle[] INSTRUCTION_FACTORY = createInstructionMapping();\n-\n-    static MethodHandle[] createInstructionMapping() {\n-        MethodHandle[] instructionFactory = new MethodHandle[ClassFile.GOTO_W + 1];\n-\n-        for (Class<?> opClass : BytecodeInstructionOps.class.getNestMembers()) {\n-            if (opClass.isAnnotationPresent(Opcodes.class)) {\n-                if (!Modifier.isPublic(opClass.getModifiers())) {\n-                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n-                }\n-\n-                if (!InstructionOp.class.isAssignableFrom(opClass)) {\n-                    throw new InternalError(\"Operation class is not assignable to Instruction: \" + opClass);\n-                }\n-\n-                MethodHandle handle = getOpcodeConstructorMethodHandle(opClass);\n-                if (handle == null) {\n-                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n-                }\n-\n-                if (!InstructionOp.class.isAssignableFrom(handle.type().returnType())) {\n-                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n-                }\n-\n-                Opcode[] opcodes = opClass.getAnnotation(Opcodes.class).value();\n-                for (Opcode opcode : opcodes) {\n-                    if (instructionFactory[opcode.bytecode()] != null) {\n-                        throw new InternalError(\"Opcode already assigned to \" + instructionFactory[opcode.bytecode()]);\n-                    }\n-                    instructionFactory[opcode.bytecode()] = handle;\n-                }\n-            }\n-        }\n-\n-        return instructionFactory;\n-    }\n-\n-    static MethodHandle getOpcodeConstructorMethodHandle(Class<?> opClass) {\n-        Optional<Constructor<?>> oc = Stream.of(opClass.getDeclaredConstructors())\n-                .filter(c -> c.getParameterCount() == 1)\n-                .filter(c -> InstructionDef.class.isAssignableFrom(c.getParameterTypes()[0]))\n-                .findFirst();\n-        Constructor<?> constructor = oc.orElse(null);\n-        if (constructor == null) {\n-            return null;\n-        }\n-\n-        try {\n-            return MethodHandles.lookup().unreflectConstructor(constructor);\n-        } catch (IllegalAccessException e) {\n-            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n-                    constructor);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeInstructionOps.java","additions":0,"deletions":2584,"binary":false,"changes":2584,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.classfile.Instruction;\n@@ -34,0 +33,2 @@\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n@@ -37,0 +38,2 @@\n+import java.lang.classfile.instruction.ArrayLoadInstruction;\n+import java.lang.classfile.instruction.ArrayStoreInstruction;\n@@ -38,0 +41,1 @@\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -39,0 +43,3 @@\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.IncrementInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -41,0 +48,1 @@\n+import java.lang.classfile.instruction.LoadInstruction;\n@@ -44,0 +52,5 @@\n+import java.lang.classfile.instruction.NewMultiArrayInstruction;\n+import java.lang.classfile.instruction.NewObjectInstruction;\n+import java.lang.classfile.instruction.NewPrimitiveArrayInstruction;\n+import java.lang.classfile.instruction.NewReferenceArrayInstruction;\n+import java.lang.classfile.instruction.OperatorInstruction;\n@@ -45,0 +58,2 @@\n+import java.lang.classfile.instruction.StackInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n@@ -48,0 +63,3 @@\n+import java.lang.classfile.instruction.TypeCheckInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -50,1 +68,0 @@\n-import java.lang.reflect.code.Body;\n@@ -54,0 +71,2 @@\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n@@ -61,1 +80,0 @@\n-import java.util.HashSet;\n@@ -64,1 +82,0 @@\n-import java.util.Set;\n@@ -66,0 +83,1 @@\n+import java.util.stream.IntStream;\n@@ -75,303 +93,0 @@\n-    public static CoreOps.FuncOp liftToCoreDialect(CoreOps.FuncOp lf) {\n-        Body.Builder body = Body.Builder.of(null, lf.funcDescriptor());\n-        liftToCoreDialect(lf.body(), body);\n-        return CoreOps.func(lf.funcName(), body);\n-    }\n-\n-    \/\/ @@@ boolean, byte, short, and char are erased to int on the stack\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    public static void liftToCoreDialect(Body lbody, Body.Builder c) {\n-        Block.Builder eb = c.entryBlock();\n-\n-        \/\/ Create blocks\n-        Map<Block, Block.Builder> blockMap = new HashMap<>();\n-        for (Block lb : lbody.blocks()) {\n-            Block.Builder b = lb.isEntryBlock() ? eb : eb.block();\n-            if (!lb.isEntryBlock()) {\n-                for (Block.Parameter lbp : lb.parameters()) {\n-                    b.parameter(lbp.type());\n-                }\n-            }\n-            blockMap.put(lb, b);\n-        }\n-\n-\n-        \/\/ @@@ catch\/finally handlers are disconnected block\n-        \/\/ treat as effectively separate bodies\n-\n-        \/\/ @@@ Needs to be cloned when there are two or more successors\n-        Map<Integer, Op.Result> locals = new HashMap<>();\n-        Deque<Value> stack = new ArrayDeque<>();\n-\n-        \/\/ Map Block arguments to local variables\n-        int lvm = 0;\n-        for (Block.Parameter bp : eb.parameters()) {\n-            \/\/ @@@ Reference type\n-            Op.Result local = eb.op(CoreOps.var(Integer.toString(lvm), bp));\n-            locals.put(lvm++, local);\n-        }\n-\n-        Set<Block> visited = new HashSet<>();\n-        Deque<Block> wl = new ArrayDeque<>();\n-        wl.push(lbody.entryBlock());\n-        while (!wl.isEmpty()) {\n-            Block lb = wl.pop();\n-            if (!visited.add(lb)) {\n-                continue;\n-            }\n-\n-            Block.Builder b = blockMap.get(lb);\n-\n-            \/\/ If a non-entry block has parameters then they correspond to stack arguments\n-            \/\/ Push back block parameters on the stack, in reverse order to preserve order on the stack\n-            if (b.parameters().size() > 0 && !b.isEntryBlock()) {\n-                for (int i = b.parameters().size() - 1; i >= 0; i--) {\n-                    stack.push(b.parameters().get(i));\n-                }\n-            }\n-\n-            int nops = lb.ops().size();\n-            for (int i = 0; i < nops - 1; i++) {\n-                Op lop = lb.ops().get(i);\n-\n-                if (lop instanceof BytecodeInstructionOps.LoadInstructionOp inst) {\n-                    Op.Result result = b.op(CoreOps.varLoad(locals.get(inst.slot())));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.StoreInstructionOp inst) {\n-                    Value operand = stack.pop();\n-\n-                    Op.Result local = locals.get(inst.slot());\n-                    if (local == null) {\n-                        local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n-                        locals.put(lvm++, local);\n-                    } else {\n-                        TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n-                        if (!operand.type().equals(varType)) {\n-                            local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n-                            locals.put(lvm++, local);\n-                        } else {\n-                            b.op(CoreOps.varStore(local, operand));\n-                        }\n-                    }\n-                } else if (lop instanceof BytecodeInstructionOps.IIncInstructionOp inst) {\n-                    Op.Result local = locals.get(inst.index());\n-                    Op.Result v1 = b.op(CoreOps.varLoad(local));\n-                    Op.Result v2 = b.op(CoreOps.constant(TypeDesc.INT, inst.incr()));\n-                    Op.Result result = b.op(CoreOps.add(v1, v2));\n-                    b.op(CoreOps.varStore(local, result));\n-                } else if (lop instanceof BytecodeInstructionOps.LdcInstructionOp inst) {\n-                    Op.Result result = b.op(CoreOps.constant(inst.type(), inst.value()));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.ConstInstructionOp inst) {\n-                    Op.Result result = b.op(CoreOps.constant(inst.typeDesc(), inst.value()));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.BipushInstructionOp inst) {\n-                    Op.Result result = b.op(CoreOps.constant(TypeDesc.INT, inst.value()));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.AddInstructionOp inst) {\n-                    Value operand2 = stack.pop();\n-                    Value operand1 = stack.pop();\n-                    Op.Result result = b.op(CoreOps.add(operand1, operand2));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.GetFieldInstructionOp inst) {\n-                    if (inst.kind() == BytecodeInstructionOps.FieldKind.INSTANCE) {\n-                        Value operand = stack.pop();\n-                        Op.Result result = b.op(CoreOps.fieldLoad(inst.desc(), operand));\n-                        stack.push(result);\n-                    } else {\n-                        Op.Result result = b.op(CoreOps.fieldLoad(inst.desc()));\n-                        stack.push(result);\n-                    }\n-                } else if (lop instanceof BytecodeInstructionOps.PutFieldInstructionOp inst) {\n-                    Value value = stack.pop();\n-                    if (inst.kind() == BytecodeInstructionOps.FieldKind.INSTANCE) {\n-                        Value receiver = stack.pop();\n-                        Op.Result result = b.op(CoreOps.fieldStore(inst.desc(), receiver, value));\n-                        stack.push(result);\n-                    } else {\n-                        Op.Result result = b.op(CoreOps.fieldStore(inst.desc(), value));\n-                        stack.push(result);\n-                    }\n-                } else if (lop instanceof BytecodeInstructionOps.ArrayStoreInstructionOp inst) {\n-                    Value value = stack.pop();\n-                    Value index = stack.pop();\n-                    Value array = stack.pop();\n-                    b.op(CoreOps.arrayStoreOp(array, index, value));\n-                } else if (lop instanceof BytecodeInstructionOps.ArrayLoadInstructionOp inst) {\n-                    Value index = stack.pop();\n-                    Value array = stack.pop();\n-                    Op.Result result = b.op(CoreOps.arrayLoadOp(array, index));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.ArrayLengthInstructionOp inst) {\n-                    Value array = stack.pop();\n-                    Op.Result result = b.op(CoreOps.arrayLength(array));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.InvokeInstructionOp inst) {\n-                    MethodTypeDesc descriptor = inst.callOpDescriptor();\n-\n-                    List<Value> operands = new ArrayList<>();\n-                    for (int p = 0; p < inst.desc().type().parameters().size(); p++) {\n-                        operands.add(stack.pop());\n-                    }\n-\n-                    switch (inst.kind()) {\n-                        case VIRTUAL:\n-                        case INTERFACE:\n-                            operands.add(stack.pop());\n-                            \/\/ Fallthrough\n-                        case STATIC: {\n-                            Collections.reverse(operands);\n-                            Op.Result result = b.op(CoreOps.invoke(descriptor.returnType(), inst.desc(), operands.toArray(Value[]::new)));\n-                            if (!result.type().equals(TypeDesc.VOID)) {\n-                                stack.push(result);\n-                            }\n-                            break;\n-                        }\n-                        case SPECIAL: {\n-                            if (inst.desc().name().equals(\"<init>\")) {\n-                                Collections.reverse(operands);\n-\n-                                TypeDesc ref = descriptor.parameters().get(0);\n-                                List<TypeDesc> params = descriptor.parameters().subList(1, descriptor.parameters().size());\n-                                MethodTypeDesc constructorDescriptor = MethodTypeDesc.methodType(ref, params);\n-                                Op.Result result = b.op(CoreOps._new(constructorDescriptor, operands.toArray(Value[]::new)));\n-                                stack.push(result);\n-                            } else {\n-                                operands.add(stack.pop());\n-                                Collections.reverse(operands);\n-                                Op.Result result = b.op(CoreOps.invoke(descriptor.returnType(), inst.desc(), operands.toArray(Value[]::new)));\n-                                if (!result.type().equals(TypeDesc.VOID)) {\n-                                    stack.push(result);\n-                                }\n-                                break;\n-                            }\n-                        }\n-\n-                    }\n-                } else if (lop instanceof BytecodeInstructionOps.NewInstructionOp inst) {\n-                    \/\/ Skip over this and the dup to process the invoke special\n-                    if (i + 2 >= nops - 1) {\n-                        throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial\");\n-                    }\n-                    Op dup = lb.ops().get(i + 1);\n-                    if (!(dup instanceof BytecodeInstructionOps.DupInstructionOp)) {\n-                        throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial\");\n-                    }\n-                    Op special = lb.ops().get(i + 2);\n-                    if (special instanceof BytecodeInstructionOps.InvokeInstructionOp invoke) {\n-                        if (!invoke.desc().name().equals(\"<init>\")) {\n-                            throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial for <init>\");\n-                        }\n-                    } else {\n-                        throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial\");\n-                    }\n-\n-                    i++;\n-                } else if (lop instanceof BytecodeInstructionOps.NewArrayInstructionOp inst) {\n-                    Value length = stack.pop();\n-                    Op.Result result = b.op(CoreOps.newArray(TypeDesc.type(inst.desc(), 1), length));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.MultiNewArrayInstructionOp inst) {\n-                    int dims = inst.dims();\n-                    Value[] counts = new Value[dims];\n-                    for (int d = dims - 1; d >= 0; d--) {\n-                        counts[d] = stack.pop();\n-                    }\n-                    MethodTypeDesc m = MethodTypeDesc.methodType(inst.desc(), Collections.nCopies(dims, TypeDesc.INT));\n-                    Op.Result result = b.op(CoreOps._new(m, counts));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.CheckCastInstructionOp inst) {\n-                    Value instance = stack.pop();\n-                    Op.Result result = b.op(CoreOps.cast(inst.desc(), instance));\n-                    stack.push(result);\n-                } else if (lop instanceof BytecodeInstructionOps.PopInstructionOp inst) {\n-                    stack.pop();\n-                } else if (lop instanceof BytecodeInstructionOps.DupInstructionOp inst) {\n-                    stack.push(stack.peek());\n-                } else if (lop instanceof BytecodeInstructionOps.Frame inst) {\n-                    \/\/ Ignore\n-                } else {\n-                    throw new UnsupportedOperationException(\"Unsupported operation: \" + lop.opName());\n-                }\n-            }\n-\n-            Op ltop = lb.terminatingOp();\n-            if (ltop instanceof BytecodeInstructionOps.GotoInstructionOp inst) {\n-                Block slb = inst.successors().get(0).targetBlock();\n-                Block.Reference sb;\n-                \/\/ If the block has block parameters for stack operands then\n-                \/\/ pop arguments off the stack and use as successor arguments\n-                if (!slb.parameters().isEmpty()) {\n-                    List<Value> args = new ArrayList<>();\n-                    for (int x = 0; x < slb.parameters().size(); x++) {\n-                        args.add(stack.pop());\n-                    }\n-                    sb = blockMap.get(slb).successor(args);\n-                } else {\n-                    sb = blockMap.get(slb).successor();\n-                }\n-                b.op(CoreOps.branch(sb));\n-\n-                wl.push(slb);\n-            } else if (ltop instanceof BytecodeInstructionOps.IfInstructionOp inst) {\n-                Value operand = stack.pop();\n-                Value zero = b.op(CoreOps.constant(TypeDesc.INT, 0));\n-\n-                if (!stack.isEmpty()) {\n-                    throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n-                }\n-\n-                BytecodeInstructionOps.Comparison cond = inst.cond().inverse();\n-                Op cop = switch (cond) {\n-                    case EQ -> CoreOps.eq(operand, zero);\n-                    case NE -> CoreOps.neq(operand, zero);\n-                    case LT -> CoreOps.lt(operand, zero);\n-                    case GT -> CoreOps.gt(operand, zero);\n-                    default -> throw new UnsupportedOperationException(\"Unsupported condition \" + cond);\n-                };\n-\n-                Block fslb = inst.successors().get(0).targetBlock();\n-                Block tslb = inst.successors().get(1).targetBlock();\n-                b.op(CoreOps.conditionalBranch(b.op(cop), blockMap.get(fslb).successor(), blockMap.get(tslb).successor()));\n-\n-                wl.push(tslb);\n-                wl.push(fslb);\n-            } else if (ltop instanceof BytecodeInstructionOps.IfcmpInstructionOp inst) {\n-                Value operand2 = stack.pop();\n-                Value operand1 = stack.pop();\n-\n-                if (!stack.isEmpty()) {\n-                    throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n-                }\n-\n-                BytecodeInstructionOps.Comparison cond = inst.cond().inverse();\n-                Op cop = switch (cond) {\n-                    case EQ -> CoreOps.eq(operand1, operand2);\n-                    case NE -> CoreOps.neq(operand1, operand2);\n-                    case LT -> CoreOps.lt(operand1, operand2);\n-                    case GT -> CoreOps.gt(operand1, operand2);\n-                    default -> throw new UnsupportedOperationException(\"Unsupported condition \" + cond);\n-                };\n-\n-                Block tslb = inst.trueBranch();\n-                Block fslb = inst.falseBranch();\n-                b.op(CoreOps.conditionalBranch(b.op(cop), blockMap.get(fslb).successor(), blockMap.get(tslb).successor()));\n-\n-                wl.push(tslb);\n-                wl.push(fslb);\n-            } else if (ltop instanceof BytecodeInstructionOps.ReturnInstructionOp inst) {\n-                Value operand = stack.pop();\n-                b.op(CoreOps._return(operand));\n-            } else if (ltop instanceof BytecodeInstructionOps.VoidReturnInstructionOp inst) {\n-                b.op(CoreOps._return());\n-            } else {\n-                throw new UnsupportedOperationException(\"Unsupported terminating operation: \" + ltop.opName());\n-            }\n-        }\n-    }\n-\n-\n-    \/\/\n-    \/\/ Lift to bytecode dialect\n-\n@@ -382,2 +97,2 @@\n-    public static CoreOps.FuncOp liftToBytecodeDialect(byte[] classdata, String methodName) {\n-        BytecodeMethodBody bcr = createBodyForMethod(classdata, methodName);\n+    public static CoreOps.FuncOp lift(byte[] classdata, String methodName) {\n+        BytecodeMethodBody bytecodeBody = createBodyForMethod(classdata, methodName);\n@@ -385,1 +100,1 @@\n-        MethodTypeDesc methodTypeDescriptor = MethodTypeDesc.ofNominalDescriptor(bcr.methodModel.methodTypeSymbol());\n+        MethodTypeDesc methodTypeDescriptor = MethodTypeDesc.ofNominalDescriptor(bytecodeBody.methodModel.methodTypeSymbol());\n@@ -388,1 +103,1 @@\n-                bcr.methodModel.methodName().stringValue(),\n+                bytecodeBody.methodModel.methodName().stringValue(),\n@@ -394,1 +109,1 @@\n-            for (BytecodeBasicBlock bcb : bcr.blocks) {\n+            for (BytecodeBasicBlock basicBlock : bytecodeBody.blocks) {\n@@ -397,8 +112,0 @@\n-                count++;\n-                c.blockMap.put(bcb, b);\n-            }\n-\n-            \/\/ Process blocks\n-            for (BytecodeBasicBlock bcb : bcr.blocks) {\n-                Block.Builder b = c.blockMap.get(bcb);\n-\n@@ -406,4 +113,4 @@\n-                for (ExceptionCatch tryCatchBlock : bcr.codeModel.exceptionHandlers()) {\n-                    BytecodeBasicBlock handler = bcr.blockMap.get(tryCatchBlock.handler());\n-                    if (handler == bcb) {\n-                        if (b.parameters().size() == 0) {\n+                for (ExceptionCatch tryCatchBlock : bytecodeBody.codeModel.exceptionHandlers()) {\n+                    BytecodeBasicBlock handler = bytecodeBody.blockMap.get(tryCatchBlock.handler());\n+                    if (handler == basicBlock) {\n+                        if (b.parameters().isEmpty()) {\n@@ -421,1 +128,0 @@\n-\n@@ -423,5 +129,24 @@\n-                if (bcb.frame != null) {\n-                    BytecodeInstructionOps.Frame frame = BytecodeInstructionOps.frame(bcb.frame);\n-                    if (frame.hasOperandStackElements()) {\n-                        for (TypeDesc t : frame.operandStackTypes()) {\n-                            b.parameter(t);\n+                if (basicBlock.frame != null) {\n+                    for (StackMapFrameInfo.VerificationTypeInfo ost : basicBlock.frame.stack()) {\n+                        if (ost instanceof StackMapFrameInfo.SimpleVerificationTypeInfo i) {\n+                            switch (i) {\n+                                case ITEM_INTEGER ->\n+                                    b.parameter(TypeDesc.INT);\n+                                case ITEM_FLOAT ->\n+                                    b.parameter(TypeDesc.FLOAT);\n+                                case ITEM_DOUBLE ->\n+                                    b.parameter(TypeDesc.DOUBLE);\n+                                case ITEM_LONG ->\n+                                    b.parameter(TypeDesc.LONG);\n+                                case ITEM_NULL -> \/\/ @@@\n+                                    b.parameter(TypeDesc.J_L_OBJECT);\n+                                case ITEM_UNINITIALIZED_THIS ->\n+                                    b.parameter(TypeDesc.ofNominalDescriptor(bytecodeBody.methodModel.parent().get().thisClass().asSymbol()));\n+                                case ITEM_TOP ->\n+                                    throw new IllegalArgumentException(\"Unexpected item TOP at frame stack.\");\n+                            }\n+                        } else if (ost instanceof StackMapFrameInfo.ObjectVerificationTypeInfo i) {\n+                            b.parameter(TypeDesc.ofNominalDescriptor(i.classSymbol()));\n+                        } else if (ost instanceof StackMapFrameInfo.UninitializedVerificationTypeInfo i) {\n+                            \/\/ @@@\n+                            \/\/ label designates the NEW instruction that created the uninitialized value\n@@ -430,1 +155,0 @@\n-                    b.op(frame);\n@@ -432,0 +156,6 @@\n+                count++;\n+                c.blockMap.put(basicBlock, b);\n+            }\n+\n+            \/\/ @@@ Needs to be cloned when there are two or more successors\n+            Map<Integer, Op.Result> locals = new HashMap<>();\n@@ -433,1 +163,6 @@\n-                liftBytecodeBlock(bcr, bcb, b, c);\n+            \/\/ Map Block arguments to local variables\n+            int lvm = 0;\n+            for (Block.Parameter bp : entryBlock.parameters()) {\n+                \/\/ @@@ Reference type\n+                Op.Result local = entryBlock.op(CoreOps.var(Integer.toString(lvm), bp));\n+                locals.put(lvm++, local);\n@@ -435,1 +170,0 @@\n-        });\n@@ -437,2 +171,187 @@\n-        return f;\n-    }\n+            \/\/ Process blocks\n+            for (BytecodeBasicBlock bcb : bytecodeBody.blocks) {\n+                Block.Builder b = c.blockMap.get(bcb);\n+                \/\/ If a non-entry block has parameters then they correspond to stack arguments\n+                \/\/ Push back block parameters on the stack, in reverse order to preserve order on the stack\n+                Deque<Value> stack = new ArrayDeque<>();\n+                if (!b.parameters().isEmpty() && !b.isEntryBlock()) {\n+                    for (int i = b.parameters().size() - 1; i >= 0; i--) {\n+                        stack.push(b.parameters().get(i));\n+                    }\n+                }\n+                int ni = bcb.instructions.size();\n+                for (int i = 0; i < ni; i++) {\n+                    switch (bcb.instructions.get(i)) {\n+                        case LabelTarget labelTarget -> {\n+                            \/\/ Insert control instructions for exception start\/end bodies\n+        \/\/                    for (ExceptionCatch tryCatchBlock : bcr.codeModel.exceptionHandlers()) {\n+        \/\/                        if (labelTarget.label() == tryCatchBlock.tryStart()) {\n+        \/\/                            BytecodeBasicBlock handler = bcr.blockMap.get(tryCatchBlock.handler());\n+        \/\/                            b.op(BytecodeInstructionOps.\n+        \/\/                                    exceptionTableStart(c.blockMap.get(handler).successor()));\n+        \/\/                        } else if (labelTarget.label() == tryCatchBlock.tryEnd()) {\n+        \/\/                            b.op(BytecodeInstructionOps.exceptionTableEnd());\n+        \/\/                        }\n+        \/\/                    }\n+                        }\n+                        case LineNumber ln -> {\n+                            \/\/ @@@ Add special line number instructions\n+                        }\n+                        case LocalVariable lv -> {\n+                            \/\/ @@@\n+                        }\n+                        case LocalVariableType lvt -> {\n+                            \/\/ @@@\n+                        }\n+                        case LoadInstruction inst -> {\n+                            stack.push(b.op(CoreOps.varLoad(locals.get(inst.slot()))));\n+                        }\n+                        case StoreInstruction inst -> {\n+                            Value operand = stack.pop();\n+                            Op.Result local = locals.get(inst.slot());\n+                            if (local == null) {\n+                                local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n+                                locals.put(lvm++, local);\n+                            } else {\n+                                TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n+                                if (!operand.type().equals(varType)) {\n+                                    local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n+                                    locals.put(lvm++, local);\n+                                } else {\n+                                    b.op(CoreOps.varStore(local, operand));\n+                                }\n+                            }\n+                        }\n+                        case IncrementInstruction inst -> {\n+                            Op.Result local = locals.get(inst.slot());\n+                            b.op(CoreOps.varStore(local, b.op(CoreOps.add(\n+                                    b.op(CoreOps.varLoad(local)),\n+                                    b.op(CoreOps.constant(TypeDesc.INT, inst.constant()))))));\n+                        }\n+                        case ConstantInstruction.LoadConstantInstruction inst -> {\n+                            stack.push(b.op(switch (inst.constantValue()) {\n+                                case ClassDesc v -> CoreOps.constant(TypeDesc.J_L_CLASS, TypeDesc.ofNominalDescriptor(v));\n+                                case Double v -> CoreOps.constant(TypeDesc.DOUBLE, v);\n+                                case Float v -> CoreOps.constant(TypeDesc.FLOAT, v);\n+                                case Integer v -> CoreOps.constant(TypeDesc.INT, v);\n+                                case Long v -> CoreOps.constant(TypeDesc.LONG, v);\n+                                case String v -> CoreOps.constant(TypeDesc.J_L_STRING, v);\n+                                default ->\n+                                    \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                                    throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n+                            }));\n+                        }\n+                        case ConstantInstruction inst -> {\n+                            Op.Result result = b.op(CoreOps.constant(TypeDesc.INT, inst.constantValue()));\n+                            stack.push(result);\n+                        }\n+                        case OperatorInstruction inst -> {\n+                            Value operand = stack.pop();\n+                            stack.push(b.op(switch (inst.opcode()) {\n+                                case IADD, LADD, FADD, DADD ->\n+                                        CoreOps.add(stack.pop(), operand);\n+                                case ISUB, LSUB, FSUB, DSUB ->\n+                                        CoreOps.sub(stack.pop(), operand);\n+                                case IMUL, LMUL, FMUL, DMUL ->\n+                                        CoreOps.mul(stack.pop(), operand);\n+                                case IDIV, LDIV, FDIV, DDIV ->\n+                                        CoreOps.div(stack.pop(), operand);\n+                                case IREM, LREM, FREM, DREM ->\n+                                        CoreOps.mod(stack.pop(), operand);\n+                                case INEG, LNEG, FNEG, DNEG ->\n+                                        CoreOps.neg(operand);\n+                                case ARRAYLENGTH ->\n+                                        CoreOps.arrayLength(operand);\n+                                default ->\n+                                    throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                            }));\n+                        }\n+                        case FieldInstruction inst -> {\n+                                FieldDesc fd = FieldDesc.field(\n+                                        TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                        inst.name().stringValue(),\n+                                        TypeDesc.ofNominalDescriptor(inst.typeSymbol()));\n+                                switch (inst.opcode()) {\n+                                    case GETFIELD ->\n+                                        stack.push(b.op(CoreOps.fieldLoad(fd, stack.pop())));\n+                                    case GETSTATIC ->\n+                                        stack.push(b.op(CoreOps.fieldLoad(fd)));\n+                                    case PUTFIELD -> {\n+                                        Value value = stack.pop();\n+                                        stack.push(b.op(CoreOps.fieldStore(fd, stack.pop(), value)));\n+                                    }\n+                                    case PUTSTATIC ->\n+                                        stack.push(b.op(CoreOps.fieldStore(fd, stack.pop())));\n+                                    default ->\n+                                        throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n+                                }\n+                        }\n+                        case ArrayStoreInstruction _ -> {\n+                            Value value = stack.pop();\n+                            Value index = stack.pop();\n+                            b.op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n+                        }\n+                        case ArrayLoadInstruction _ -> {\n+                            Value index = stack.pop();\n+                            stack.push(b.op(CoreOps.arrayLoadOp(stack.pop(), index)));\n+                        }\n+                        case InvokeInstruction inst -> {\n+                            MethodTypeDesc mType = MethodTypeDesc.ofNominalDescriptor(inst.typeSymbol());\n+                            List<Value> operands = new ArrayList<>();\n+                            for (var _ : mType.parameters()) {\n+                                operands.add(stack.pop());\n+                            }\n+                            MethodDesc mDesc = MethodDesc.method(TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()), inst.name().stringValue(), mType);\n+                            Op.Result result = switch (inst.opcode()) {\n+                                case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                                    operands.add(stack.pop());\n+                                    yield b.op(CoreOps.invoke(mDesc, operands.reversed()));\n+                                }\n+                                case INVOKESTATIC ->\n+                                    b.op(CoreOps.invoke(mDesc, operands.reversed()));\n+                                case INVOKESPECIAL -> {\n+                                    if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                        yield b.op(CoreOps._new(\n+                                                MethodTypeDesc.methodType(\n+                                                        mType.parameters().get(0),\n+                                                        mType.parameters().subList(1, mType.parameters().size())),\n+                                                operands.reversed()));\n+                                    } else {\n+                                        operands.add(stack.pop());\n+                                        yield b.op(CoreOps.invoke(mDesc, operands.reversed()));\n+                                    }\n+                                }\n+                                default ->\n+                                    throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                            };\n+                            if (!result.type().equals(TypeDesc.VOID)) {\n+                                stack.push(result);\n+                            }\n+                        }\n+                        case NewObjectInstruction _ -> {\n+                            \/\/ Skip over this and the dup to process the invoke special\n+                            if (i + 2 < ni - 1\n+                                    && bcb.instructions.get(i + 1) instanceof StackInstruction dup\n+                                    && dup.opcode() == Opcode.DUP\n+                                    && bcb.instructions.get(i + 2) instanceof InvokeInstruction init\n+                                    && init.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                i++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"New must be followed by dup and invokespecial for <init>\");\n+                            }\n+                        }\n+                        case NewPrimitiveArrayInstruction inst -> {\n+                            stack.push(b.op(CoreOps.newArray(\n+                                    switch (inst.typeKind()) {\n+                                        case BooleanType -> TypeDesc.BOOLEAN_ARRAY;\n+                                        case ByteType -> TypeDesc.BYTE_ARRAY;\n+                                        case CharType -> TypeDesc.CHAR_ARRAY;\n+                                        case DoubleType -> TypeDesc.DOUBLE_ARRAY;\n+                                        case FloatType -> TypeDesc.FLOAT_ARRAY;\n+                                        case IntType -> TypeDesc.INT_ARRAY;\n+                                        case LongType -> TypeDesc.LONG_ARRAY;\n+                                        case ShortType -> TypeDesc.SHORT_ARRAY;\n+                                        default ->\n+                                                throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                                    },\n+                                    stack.pop())));\n@@ -440,13 +359,73 @@\n-    static void liftBytecodeBlock(BytecodeMethodBody bcr, BytecodeBasicBlock bcb, Block.Builder b, LiftContext c) {\n-        int ni = bcb.instructions.size();\n-        for (int i = 0; i < ni - 1; i++) {\n-            CodeElement codeElement = bcb.instructions.get(i);\n-            if (codeElement instanceof LabelTarget labelTarget) {\n-                \/\/ Insert control instructions for exception start\/end bodies\n-                for (ExceptionCatch tryCatchBlock : bcr.codeModel.exceptionHandlers()) {\n-                    if (labelTarget.label() == tryCatchBlock.tryStart()) {\n-                        BytecodeBasicBlock handler = bcr.blockMap.get(tryCatchBlock.handler());\n-                        b.op(BytecodeInstructionOps.\n-                                exceptionTableStart(c.blockMap.get(handler).successor()));\n-                    } else if (labelTarget.label() == tryCatchBlock.tryEnd()) {\n-                        b.op(BytecodeInstructionOps.exceptionTableEnd());\n+                        }\n+                        case NewReferenceArrayInstruction inst -> {\n+                            stack.push(b.op(CoreOps.newArray(\n+                                    TypeDesc.type(TypeDesc.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n+                                    stack.pop())));\n+                        }\n+                        case NewMultiArrayInstruction inst -> {\n+                            stack.push(b.op(CoreOps._new(\n+                                    MethodTypeDesc.methodType(\n+                                            TypeDesc.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                            Collections.nCopies(inst.dimensions(), TypeDesc.INT)),\n+                                    IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n+                        }\n+                        case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST-> {\n+                            stack.push(b.op(CoreOps.cast(TypeDesc.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                        }\n+                        case StackInstruction inst -> {\n+                            switch (inst.opcode()) {\n+                                case POP, POP2 -> stack.pop(); \/\/check the type width\n+                                case DUP, DUP2 -> stack.push(stack.peek());\n+                                \/\/implement all other stack ops\n+                                default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                            }\n+                        }\n+                        case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                            BytecodeBasicBlock succ = bcb.successors.get(0);\n+                            Block.Reference sb;\n+                            \/\/ If the block has block parameters for stack operands then\n+                            \/\/ pop arguments off the stack and use as successor arguments\n+                            if (!b.parameters().isEmpty()) {\n+                                List<Value> args = new ArrayList<>();\n+                                for (int x = 0; x < b.parameters().size(); x++) {\n+                                    args.add(stack.pop());\n+                                }\n+                                sb = c.blockMap.get(succ).successor(args);\n+                            } else {\n+                                sb = c.blockMap.get(succ).successor();\n+                            }\n+                            stack.push(b.op(CoreOps.branch(sb)));\n+                        }\n+                        case BranchInstruction inst -> {\n+                            Value operand = stack.pop();\n+                            Op cop = switch (inst.opcode()) {\n+                                case IFNE -> CoreOps.eq(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFEQ -> CoreOps.neq(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFGE -> CoreOps.lt(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFLE -> CoreOps.gt(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFGT -> CoreOps.le(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IFLT -> CoreOps.ge(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                                case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n+                                case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                                case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n+                                case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n+                                case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n+                                case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n+                                default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                            };\n+                            if (!stack.isEmpty()) {\n+                                throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                            }\n+                            BytecodeBasicBlock fslb = bcb.successors.get(0);\n+                            BytecodeBasicBlock tslb = bcb.successors.get(1);\n+                            stack.push(b.op(CoreOps.conditionalBranch(b.op(cop), c.blockMap.get(tslb).successor(), c.blockMap.get(fslb).successor())));\n+                        }\n+                        case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                            b.op(CoreOps._return());\n+                        }\n+                        case ReturnInstruction _ -> {\n+                            b.op(CoreOps._return(stack.pop()));\n+                        }\n+                        default ->\n+                            throw new UnsupportedOperationException(\"Unsupported code element: \" + bcb.instructions.get(i));\n@@ -455,11 +434,17 @@\n-            } else if (codeElement instanceof LineNumber) {\n-                \/\/ @@@ Add special line number instructions\n-            } else if (codeElement instanceof LocalVariable) {\n-                \/\/ @@@\n-            } else if (codeElement instanceof LocalVariableType) {\n-                \/\/ @@@\n-            } else if (codeElement instanceof Instruction instruction) {\n-                var def = new BytecodeInstructionOps.InstructionDef<>(instruction);\n-                b.op(BytecodeInstructionOps.create(def));\n-            } else {\n-                throw new UnsupportedOperationException(\"Unsupported code element: \" + codeElement);\n+                \/\/ @@@ cast, select last Instruction, and adjust prior loop\n+                if (bcb.isImplicitTermination) {\n+                    BytecodeBasicBlock succ = bcb.successors.get(0);\n+                    Block.Reference sb;\n+                    \/\/ If the block has block parameters for stack operands then\n+                    \/\/ pop arguments off the stack and use as successor arguments\n+                    if (!b.parameters().isEmpty()) {\n+                        List<Value> args = new ArrayList<>();\n+                        for (int x = 0; x < b.parameters().size(); x++) {\n+                            args.add(stack.pop());\n+                        }\n+                        sb = c.blockMap.get(succ).successor(args);\n+                    } else {\n+                        sb = c.blockMap.get(succ).successor();\n+                    }\n+                    stack.push(b.op(CoreOps.branch(sb)));\n+                }\n@@ -467,7 +452,1 @@\n-        }\n-\n-        \/\/ @@@ cast, select last Instruction, and adjust prior loop\n-        Instruction top = (Instruction) bcb.instructions.get(ni - 1);\n-        if (bcb.isImplicitTermination) {\n-            var def = new BytecodeInstructionOps.InstructionDef<>(top);\n-            b.op(BytecodeInstructionOps.create(def));\n+        });\n@@ -475,7 +454,1 @@\n-            BytecodeBasicBlock succ = bcb.successors.get(0);\n-            b.op(BytecodeInstructionOps._goto(c.blockMap.get(succ).successor()));\n-        } else {\n-            List<Block.Reference> successors = bcb.successors.stream().map(s -> c.blockMap.get(s).successor()).toList();\n-            var def = new BytecodeInstructionOps.InstructionDef<>(top, successors);\n-            b.op(BytecodeInstructionOps.create(def));\n-        }\n+        return f;\n@@ -484,4 +457,0 @@\n-\n-    \/\/\n-    \/\/ Lift to basic blocks of code elements\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":346,"deletions":377,"binary":false,"changes":723,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f\");\n@@ -57,2 +57,0 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n@@ -60,1 +58,1 @@\n-        Assert.assertEquals(Interpreter.invoke(fliftcore), f());\n+        Assert.assertEquals(Interpreter.invoke(flift), f());\n@@ -73,1 +71,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f2\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f2\");\n@@ -75,2 +73,0 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n@@ -78,1 +74,1 @@\n-        Assert.assertEquals(Interpreter.invoke(fliftcore), f2());\n+        Assert.assertEquals(Interpreter.invoke(flift), f2());\n@@ -91,1 +87,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f3\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f3\");\n@@ -93,2 +89,0 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n@@ -96,1 +90,1 @@\n-        Assert.assertEquals(Interpreter.invoke(fliftcore), f3());\n+        Assert.assertEquals(Interpreter.invoke(flift), f3());\n@@ -109,1 +103,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f4\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f4\");\n@@ -111,2 +105,0 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n@@ -114,1 +106,1 @@\n-        Assert.assertEquals(Interpreter.invoke(fliftcore), f4());\n+        Assert.assertEquals(Interpreter.invoke(flift), f4());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftArrayCreation.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, method);\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, method);\n@@ -90,3 +90,1 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n-        CoreOps.FuncOp fliftcoreSSA = SSA.transform(fliftcore);\n+        CoreOps.FuncOp fliftcoreSSA = SSA.transform(flift);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftControl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"proxy\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"proxy\");\n@@ -71,3 +71,1 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n-        CoreOps.FuncOp fliftcoreSSA = SSA.transform(fliftcore);\n+        CoreOps.FuncOp fliftcoreSSA = SSA.transform(flift);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f\");\n@@ -60,2 +60,0 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n@@ -63,1 +61,1 @@\n-        Assert.assertEquals(Interpreter.invoke(fliftcore, 1, 1), f(1, 1));\n+        Assert.assertEquals(Interpreter.invoke(flift, 1, 1), f(1, 1));\n@@ -78,1 +76,1 @@\n-        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f2\");\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f2\");\n@@ -80,2 +78,0 @@\n-        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n-        fliftcore.writeTo(System.out);\n@@ -83,1 +79,1 @@\n-        Assert.assertEquals(Interpreter.invoke(fliftcore), f2());\n+        Assert.assertEquals(Interpreter.invoke(flift), f2());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftSimple.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}