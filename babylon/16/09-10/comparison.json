{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.classfile.Attributes;\n@@ -36,2 +35,1 @@\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -45,1 +43,0 @@\n-import java.lang.reflect.code.Op.Result;\n@@ -59,1 +56,0 @@\n-import java.util.stream.Collectors;\n@@ -76,0 +72,2 @@\n+    private record CodeBlock(Block.Builder blockBuilder, Map<Integer, Op.Result> locals) {}\n+\n@@ -83,25 +81,11 @@\n-            \/\/ Fill block map\n-            final Map<Label, Block.Builder> blockMap = codeModel.findAttribute(Attributes.STACK_MAP_TABLE).map(smta ->\n-                smta.entries().stream().collect(Collectors.toMap(\n-                        StackMapFrameInfo::target,\n-                        frameInfo -> entryBlock.block(frameInfo.stack().stream().map(vti ->\n-                                switch (vti) {\n-                                    case SimpleVerificationTypeInfo.ITEM_INTEGER ->\n-                                        TypeDesc.INT;\n-                                    case SimpleVerificationTypeInfo.ITEM_FLOAT ->\n-                                        TypeDesc.FLOAT;\n-                                    case SimpleVerificationTypeInfo.ITEM_DOUBLE ->\n-                                        TypeDesc.DOUBLE;\n-                                    case SimpleVerificationTypeInfo.ITEM_LONG ->\n-                                        TypeDesc.LONG;\n-                                    case SimpleVerificationTypeInfo.ITEM_NULL -> \/\/ @@@\n-                                        TypeDesc.J_L_OBJECT;\n-                                    case SimpleVerificationTypeInfo.ITEM_UNINITIALIZED_THIS ->\n-                                        TypeDesc.ofNominalDescriptor(methodModel.parent().get().thisClass().asSymbol());\n-                                    case ObjectVerificationTypeInfo i ->\n-                                        TypeDesc.ofNominalDescriptor(i.classSymbol());\n-                                    case UninitializedVerificationTypeInfo i ->\n-                                        throw new IllegalArgumentException(\"Unexpected item at frame stack: \" + i);\n-                                    case SimpleVerificationTypeInfo.ITEM_TOP ->\n-                                        throw new IllegalArgumentException(\"Unexpected item at frame stack: TOP\");\n-                                }).toList())))).orElseGet(HashMap::new);\n+            final var blockMap = new HashMap<Label, CodeBlock>() {\n+                public CodeBlock getOrCreate(Label l, Deque<Value> stack, Map<Integer, Op.Result> locals) {\n+                    return getOrCreate(l, stack.stream().map(Value::type).toList(), locals);\n+                }\n+                public CodeBlock getOrCreate(Label l, List<TypeDesc> parameters, Map<Integer, Op.Result> locals) {\n+                    return computeIfAbsent(l, _ ->\n+                            new CodeBlock(entryBlock.block(parameters), locals));\n+                }\n+            };\n+\n+            final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n@@ -109,0 +93,1 @@\n+            Block.Builder currentBlock = entryBlock;\n@@ -110,2 +95,1 @@\n-            final Map<Integer, Op.Result> locals = new HashMap<>();\n-            final Map<ExceptionCatch, Result> exceptionRegionsMap = new HashMap<>();\n+            Map<Integer, Op.Result> locals = new HashMap<>();\n@@ -113,2 +97,2 @@\n-            \/\/ Map Block arguments to local variables\n-            int lvm = 0;\n+            int uniqueVariableName = 0;\n+            \/\/ Initialize local variables from entry block parameters\n@@ -117,2 +101,2 @@\n-                Op.Result local = entryBlock.op(CoreOps.var(Integer.toString(lvm), bp));\n-                locals.put(lvm++, local);\n+                Op.Result local = entryBlock.op(CoreOps.var(Integer.toString(uniqueVariableName), bp));\n+                locals.put(uniqueVariableName++, local);\n@@ -122,1 +106,0 @@\n-            Block.Builder currentBlock = entryBlock;\n@@ -130,3 +113,1 @@\n-                        Block.Builder nextBlock = blockMap.computeIfAbsent(lt.label(), _ ->\n-                                \/\/ New block parameter types are calculated from the actual stack\n-                                entryBlock.block(stack.stream().map(Value::type).toList()));\n+                        CodeBlock next = blockMap.get(lt.label());\n@@ -134,0 +115,5 @@\n+                            if (next == null) {\n+                                \/\/ New block parameter types are calculated from the actual stack\n+                                next = new CodeBlock(entryBlock.block(stack.stream().map(Value::type).toList()), locals);\n+                                blockMap.put(lt.label(), next);\n+                            }\n@@ -136,2 +122,1 @@\n-                            currentBlock.op(CoreOps.branch(nextBlock.successor(List.copyOf(stack))));\n-                            stack.clear();\n+                            currentBlock.op(CoreOps.branch(next.blockBuilder.successor(List.copyOf(stack))));\n@@ -139,14 +124,23 @@\n-                        \/\/ Stack is reconstructed from block parameters\n-                        nextBlock.parameters().forEach(stack::add);\n-                        currentBlock = nextBlock;\n-                        \/\/ Insert relevant tryStart and tryEnd blocks\n-                        for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n-                            if (lt.label() == ec.tryStart()) {\n-                                nextBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                ExceptionRegionEnter ere = CoreOps.exceptionRegionEnter(nextBlock.successor(List.copyOf(stack)), blockMap.get(ec.handler()).successor());\n-                                currentBlock.op(ere);\n-                                exceptionRegionsMap.put(ec, ere.result());\n-                                stack.clear();\n-                                \/\/ Stack is reconstructed from block parameters\n-                                nextBlock.parameters().forEach(stack::add);\n-                                currentBlock = nextBlock;\n+                        if (next != null) {\n+                            currentBlock = next.blockBuilder;\n+                            \/\/ Stack is reconstructed from block parameters\n+                            stack.clear();\n+                            currentBlock.parameters().forEach(stack::add);\n+                            locals = next.locals;\n+                            \/\/ Insert relevant tryStart and tryEnd blocks\n+                            for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                                if (lt.label() == ec.tryStart()) {\n+                                    \/\/ Get or create handler with the exception as parameter\n+                                    CodeBlock handler = blockMap.getOrCreate(ec.handler(),\n+                                            List.of(TypeDesc.ofNominalDescriptor(ec.catchType().map(ClassEntry::asSymbol).orElse(ConstantDescs.CD_Throwable))), locals);\n+                                    \/\/ Create start block\n+                                    Block.Builder startBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n+                                    ExceptionRegionEnter ere = CoreOps.exceptionRegionEnter(startBlock.successor(List.copyOf(stack)), handler.blockBuilder.successor());\n+                                    currentBlock.op(ere);\n+                                    \/\/ Store ERE into map for exit\n+                                    exceptionRegionsMap.put(ec, ere.result());\n+                                    currentBlock = startBlock;\n+                                    \/\/ Stack is reconstructed from block parameters\n+                                    stack.clear();\n+                                    currentBlock.parameters().forEach(stack::add);\n+                                }\n@@ -154,9 +148,10 @@\n-                        }\n-                        for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n-                            if (lt.label() == ec.tryEnd()) {\n-                                nextBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                currentBlock.op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), nextBlock.successor()));\n-                                stack.clear();\n-                                \/\/ Stack is reconstructed from block parameters\n-                                nextBlock.parameters().forEach(stack::add);\n-                                currentBlock = nextBlock;\n+                            for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                                if (lt.label() == ec.tryEnd()) {\n+                                    \/\/ Create exit block with parameters constructed from the stack\n+                                    Block.Builder endBlock = entryBlock.block(stack.stream().map(Value::type).toList());\n+                                    currentBlock.op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), endBlock.successor()));\n+                                    currentBlock = endBlock;\n+                                    \/\/ Stack is reconstructed from block parameters\n+                                    stack.clear();\n+                                    currentBlock.parameters().forEach(stack::add);\n+                                }\n@@ -164,0 +159,3 @@\n+                        } else {\n+                            \/\/ @@@ Skip over unitialized block\n+                            throw new UnsupportedOperationException(\"Not implemented yet\");\n@@ -167,2 +165,3 @@\n-                        \/\/ Use stack content as target block arguments\n-                        currentBlock.op(CoreOps.branch(blockMap.get(inst.target()).successor(List.copyOf(stack))));\n+                        \/\/ Get or create target block with parameters constructed from the stack\n+                        currentBlock.op(CoreOps.branch(blockMap.getOrCreate(inst.target(), stack, locals)\n+                                .blockBuilder.successor(List.copyOf(stack))));\n@@ -198,1 +197,2 @@\n-                                blockMap.get(inst.target()).successor()));\n+                                \/\/ Get or create target block\n+                                blockMap.getOrCreate(inst.target(), stack, locals).blockBuilder.successor()));\n@@ -236,2 +236,1 @@\n-                            local = currentBlock.op(CoreOps.var(Integer.toString(lvm), operand));\n-                            locals.put(lvm++, local);\n+                            locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(uniqueVariableName), operand)));\n@@ -241,5 +240,3 @@\n-                                local = currentBlock.op(CoreOps.var(Integer.toString(lvm), operand));\n-                                locals.put(lvm++, local);\n-                                \/\/ @@@  The slot is reused with a different type\n-                                \/\/ so we need to update the existing entry in the map.\n-                                \/\/ This likely always connects to how to manage the map with conditional branching.\n+                                \/\/ Fork locals to override the slot\n+                                locals = new HashMap<>(locals);\n+                                locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(uniqueVariableName++), operand)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":72,"deletions":75,"binary":false,"changes":147,"status":"modified"}]}