{"files":[{"patch":"@@ -130,17 +130,19 @@\n-                    for (StackMapFrameInfo.VerificationTypeInfo ost : basicBlock.frame.stack()) {\n-                        if (ost instanceof StackMapFrameInfo.SimpleVerificationTypeInfo i) {\n-                            switch (i) {\n-                                case ITEM_INTEGER ->\n-                                    b.parameter(TypeDesc.INT);\n-                                case ITEM_FLOAT ->\n-                                    b.parameter(TypeDesc.FLOAT);\n-                                case ITEM_DOUBLE ->\n-                                    b.parameter(TypeDesc.DOUBLE);\n-                                case ITEM_LONG ->\n-                                    b.parameter(TypeDesc.LONG);\n-                                case ITEM_NULL -> \/\/ @@@\n-                                    b.parameter(TypeDesc.J_L_OBJECT);\n-                                case ITEM_UNINITIALIZED_THIS ->\n-                                    b.parameter(TypeDesc.ofNominalDescriptor(bytecodeBody.methodModel.parent().get().thisClass().asSymbol()));\n-                                case ITEM_TOP ->\n-                                    throw new IllegalArgumentException(\"Unexpected item TOP at frame stack.\");\n+                    for (StackMapFrameInfo.VerificationTypeInfo vti : basicBlock.frame.stack()) {\n+                        switch (vti) {\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_INTEGER ->\n+                                b.parameter(TypeDesc.INT);\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_FLOAT ->\n+                                b.parameter(TypeDesc.FLOAT);\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE ->\n+                                b.parameter(TypeDesc.DOUBLE);\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG ->\n+                                b.parameter(TypeDesc.LONG);\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_NULL -> \/\/ @@@\n+                                b.parameter(TypeDesc.J_L_OBJECT);\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_UNINITIALIZED_THIS ->\n+                                b.parameter(TypeDesc.ofNominalDescriptor(bytecodeBody.methodModel.parent().get().thisClass().asSymbol()));\n+                            case StackMapFrameInfo.ObjectVerificationTypeInfo i ->\n+                                b.parameter(TypeDesc.ofNominalDescriptor(i.classSymbol()));\n+                            case StackMapFrameInfo.UninitializedVerificationTypeInfo i -> {\n+                                \/\/ @@@\n+                                \/\/ label designates the NEW instruction that created the uninitialized value\n@@ -148,5 +150,2 @@\n-                        } else if (ost instanceof StackMapFrameInfo.ObjectVerificationTypeInfo i) {\n-                            b.parameter(TypeDesc.ofNominalDescriptor(i.classSymbol()));\n-                        } else if (ost instanceof StackMapFrameInfo.UninitializedVerificationTypeInfo i) {\n-                            \/\/ @@@\n-                            \/\/ label designates the NEW instruction that created the uninitialized value\n+                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_TOP ->\n+                                throw new IllegalArgumentException(\"Unexpected item TOP at frame stack.\");\n@@ -527,7 +526,10 @@\n-            if (ce instanceof LabelTarget labelTarget) {\n-                StackMapFrameInfo frame = labelToFrameMap.get(labelTarget.label());\n-                if (frame != null) {\n-                    \/\/ Not first block, nor prior block with non-terminating instruction\n-                    if (!currentBlock.instructions.isEmpty()) {\n-                        blocks.add(currentBlock);\n-                        currentBlock = new BytecodeBasicBlock();\n+            switch (ce) {\n+                case LabelTarget labelTarget -> {\n+                    StackMapFrameInfo frame = labelToFrameMap.get(labelTarget.label());\n+                    if (frame != null) {\n+                        \/\/ Not first block, nor prior block with non-terminating instruction\n+                        if (!currentBlock.instructions.isEmpty()) {\n+                            blocks.add(currentBlock);\n+                            currentBlock = new BytecodeBasicBlock();\n+                        }\n+                        currentBlock.setFrame(frame);\n@@ -535,2 +537,2 @@\n-\n-                    currentBlock.setFrame(frame);\n+                    blockMap.put(labelTarget.label(), currentBlock);\n+                    currentBlock.addInstruction(ce);\n@@ -538,19 +540,9 @@\n-\n-                blockMap.put(labelTarget.label(), currentBlock);\n-                currentBlock.addInstruction(ce);\n-            } else if (ce instanceof BranchInstruction ||\n-                    ce instanceof TableSwitchInstruction ||\n-                    ce instanceof LookupSwitchInstruction) {\n-                \/\/ End of block, branch\n-                currentBlock.addInstruction(ce);\n-\n-                blocks.add(currentBlock);\n-                currentBlock = new BytecodeBasicBlock();\n-            } else if (ce instanceof ReturnInstruction || ce instanceof ThrowInstruction) {\n-                \/\/ End of block, method terminating instruction,\n-                currentBlock.addInstruction(ce);\n-\n-                blocks.add(currentBlock);\n-                currentBlock = new BytecodeBasicBlock();\n-            } else {\n-                currentBlock.addInstruction(ce);\n+                case BranchInstruction _, TableSwitchInstruction _, LookupSwitchInstruction _,\n+                     ReturnInstruction _, ThrowInstruction _ -> {\n+                    \/\/ End of block, branch\n+                    currentBlock.addInstruction(ce);\n+                    blocks.add(currentBlock);\n+                    currentBlock = new BytecodeBasicBlock();\n+                }\n+                default ->\n+                    currentBlock.addInstruction(ce);\n@@ -559,1 +551,0 @@\n-\n@@ -565,0 +556,4 @@\n+                case BranchInstruction bi when bi.opcode().isUnconditionalBranch() -> {\n+                    BytecodeBasicBlock branch = blockMap.get(bi.target());\n+                    b.addSuccessor(branch);\n+                }\n@@ -566,17 +561,7 @@\n-                    switch (bi.opcode()) {\n-                        case GOTO, GOTO_W -> {\n-                            BytecodeBasicBlock branch = blockMap.get(bi.target());\n-                            b.addSuccessor(branch);\n-                        }\n-                        \/\/ Conditional branch\n-                        default -> {\n-                            assert !bi.opcode().isUnconditionalBranch();\n-\n-                            BytecodeBasicBlock tBranch = blockMap.get(bi.target());\n-                            BytecodeBasicBlock fBranch = blocks.get(i + 1);\n-                            \/\/ True branch is first\n-                            b.addSuccessor(tBranch);\n-                            \/\/ False (or continuation) branch is second\n-                            b.addSuccessor(fBranch);\n-                        }\n-                    }\n+                    \/\/ Conditional branch\n+                    BytecodeBasicBlock tBranch = blockMap.get(bi.target());\n+                    BytecodeBasicBlock fBranch = blocks.get(i + 1);\n+                    \/\/ True branch is first\n+                    b.addSuccessor(tBranch);\n+                    \/\/ False (or continuation) branch is second\n+                    b.addSuccessor(fBranch);\n@@ -595,4 +580,1 @@\n-                case ReturnInstruction ri -> {\n-                    \/\/ Ignore, method terminating\n-                }\n-                case ThrowInstruction ti -> {\n+                case ReturnInstruction _, ThrowInstruction _ -> {\n@@ -609,1 +591,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":54,"deletions":73,"binary":false,"changes":127,"status":"modified"}]}