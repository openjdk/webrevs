{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Attributes;\n@@ -36,28 +37,2 @@\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.instruction.ArrayLoadInstruction;\n-import java.lang.classfile.instruction.ArrayStoreInstruction;\n-import java.lang.classfile.instruction.BranchInstruction;\n-import java.lang.classfile.instruction.ConstantInstruction;\n-import java.lang.classfile.instruction.ExceptionCatch;\n-import java.lang.classfile.instruction.FieldInstruction;\n-import java.lang.classfile.instruction.IncrementInstruction;\n-import java.lang.classfile.instruction.InvokeInstruction;\n-import java.lang.classfile.instruction.LabelTarget;\n-import java.lang.classfile.instruction.LineNumber;\n-import java.lang.classfile.instruction.LoadInstruction;\n-import java.lang.classfile.instruction.LocalVariable;\n-import java.lang.classfile.instruction.LocalVariableType;\n-import java.lang.classfile.instruction.LookupSwitchInstruction;\n-import java.lang.classfile.instruction.NewMultiArrayInstruction;\n-import java.lang.classfile.instruction.NewObjectInstruction;\n-import java.lang.classfile.instruction.NewPrimitiveArrayInstruction;\n-import java.lang.classfile.instruction.NewReferenceArrayInstruction;\n-import java.lang.classfile.instruction.OperatorInstruction;\n-import java.lang.classfile.instruction.ReturnInstruction;\n-import java.lang.classfile.instruction.StackInstruction;\n-import java.lang.classfile.instruction.StoreInstruction;\n-import java.lang.classfile.instruction.SwitchCase;\n-import java.lang.classfile.instruction.TableSwitchInstruction;\n-import java.lang.classfile.instruction.ThrowInstruction;\n-import java.lang.classfile.instruction.TypeCheckInstruction;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.instruction.*;\n@@ -85,1 +60,1 @@\n-public class BytecodeLift {\n+public final class BytecodeLift {\n@@ -87,1 +62,1 @@\n-    BytecodeLift() {\n+    private BytecodeLift() {\n@@ -90,5 +65,0 @@\n-    static final class LiftContext {\n-        final Map<BytecodeBasicBlock, Block.Builder> blockMap = new HashMap<>();\n-    }\n-\n-    \/\/\n@@ -97,1 +67,6 @@\n-        BytecodeMethodBody bytecodeBody = createBodyForMethod(classdata, methodName);\n+        return lift(ClassFile.of(\n+                ClassFile.DebugElementsOption.DROP_DEBUG,\n+                ClassFile.LineNumbersOption.DROP_LINE_NUMBERS).parse(classdata).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName))\n+                        .findFirst().orElseThrow(() -> new IllegalArgumentException(\"Unknown method: \" + methodName)));\n+    }\n@@ -99,1 +74,4 @@\n-        MethodTypeDesc methodTypeDescriptor = MethodTypeDesc.ofNominalDescriptor(bytecodeBody.methodModel.methodTypeSymbol());\n+    public static CoreOps.FuncOp lift(MethodModel methodModel) {\n+        return CoreOps.func(\n+                methodModel.methodName().stringValue(),\n+                MethodTypeDesc.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock -> {\n@@ -101,54 +79,1 @@\n-        CoreOps.FuncOp f = CoreOps.func(\n-                bytecodeBody.methodModel.methodName().stringValue(),\n-                methodTypeDescriptor).body(entryBlock -> {\n-            LiftContext c = new LiftContext();\n-            \/\/ Create blocks\n-            int count = 0;\n-            for (BytecodeBasicBlock basicBlock : bytecodeBody.blocks) {\n-                Block.Builder b = count > 0 ? entryBlock.block() : entryBlock;\n-                \/\/ Add exception parameter to catch handler blocks\n-                for (ExceptionCatch tryCatchBlock : bytecodeBody.codeModel.exceptionHandlers()) {\n-                    BytecodeBasicBlock handler = bytecodeBody.blockMap.get(tryCatchBlock.handler());\n-                    if (handler == basicBlock) {\n-                        if (b.parameters().isEmpty()) {\n-                            TypeDesc throwableType = tryCatchBlock.catchType()\n-                                    .map(ClassEntry::asSymbol)\n-                                    .map(TypeDesc::ofNominalDescriptor)\n-                                    .orElse(null);\n-                            if (throwableType != null) {\n-                                b.parameter(throwableType);\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-                \/\/ If the frame has operand stack elements then represent as block arguments\n-                if (basicBlock.frame != null) {\n-                    for (StackMapFrameInfo.VerificationTypeInfo vti : basicBlock.frame.stack()) {\n-                        switch (vti) {\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_INTEGER ->\n-                                b.parameter(TypeDesc.INT);\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_FLOAT ->\n-                                b.parameter(TypeDesc.FLOAT);\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE ->\n-                                b.parameter(TypeDesc.DOUBLE);\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG ->\n-                                b.parameter(TypeDesc.LONG);\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_NULL -> \/\/ @@@\n-                                b.parameter(TypeDesc.J_L_OBJECT);\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_UNINITIALIZED_THIS ->\n-                                b.parameter(TypeDesc.ofNominalDescriptor(bytecodeBody.methodModel.parent().get().thisClass().asSymbol()));\n-                            case StackMapFrameInfo.ObjectVerificationTypeInfo i ->\n-                                b.parameter(TypeDesc.ofNominalDescriptor(i.classSymbol()));\n-                            case StackMapFrameInfo.UninitializedVerificationTypeInfo i -> {\n-                                \/\/ @@@\n-                                \/\/ label designates the NEW instruction that created the uninitialized value\n-                            }\n-                            case StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_TOP ->\n-                                throw new IllegalArgumentException(\"Unexpected item TOP at frame stack.\");\n-                        }\n-                    }\n-                }\n-                count++;\n-                c.blockMap.put(basicBlock, b);\n-            }\n+            final CodeModel codeModel = methodModel.code().orElseThrow();\n@@ -156,2 +81,28 @@\n-            \/\/ @@@ Needs to be cloned when there are two or more successors\n-            Map<Integer, Op.Result> locals = new HashMap<>();\n+            \/\/ Fill block map\n+            final Map<Label, Block.Builder> blockMap = codeModel.findAttribute(Attributes.STACK_MAP_TABLE).map(smta ->\n+                smta.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        frameInfo -> entryBlock.block(frameInfo.stack().stream().map(vti ->\n+                        switch (vti) {\n+                            case SimpleVerificationTypeInfo.ITEM_INTEGER ->\n+                                TypeDesc.INT;\n+                            case SimpleVerificationTypeInfo.ITEM_FLOAT ->\n+                                TypeDesc.FLOAT;\n+                            case SimpleVerificationTypeInfo.ITEM_DOUBLE ->\n+                                TypeDesc.DOUBLE;\n+                            case SimpleVerificationTypeInfo.ITEM_LONG ->\n+                                TypeDesc.LONG;\n+                            case SimpleVerificationTypeInfo.ITEM_NULL -> \/\/ @@@\n+                                TypeDesc.J_L_OBJECT;\n+                            case SimpleVerificationTypeInfo.ITEM_UNINITIALIZED_THIS ->\n+                                TypeDesc.ofNominalDescriptor(methodModel.parent().get().thisClass().asSymbol());\n+                            case ObjectVerificationTypeInfo i ->\n+                                TypeDesc.ofNominalDescriptor(i.classSymbol());\n+                            case UninitializedVerificationTypeInfo i ->\n+                                throw new IllegalArgumentException(\"Unexpected item at frame stack: \" + i);\n+                            case SimpleVerificationTypeInfo.ITEM_TOP ->\n+                                throw new IllegalArgumentException(\"Unexpected item at frame stack: TOP\");\n+                        }).toList())))).orElse(Map.of());\n+\n+            final Deque<Value> stack = new ArrayDeque<>();\n+            final Map<Integer, Op.Result> locals = new HashMap<>();\n@@ -167,30 +118,9 @@\n-            \/\/ Process blocks\n-            for (BytecodeBasicBlock bcb : bytecodeBody.blocks) {\n-                Block.Builder b = c.blockMap.get(bcb);\n-                \/\/ If a non-entry block has parameters then they correspond to stack arguments\n-                \/\/ Push back block parameters on the stack, in reverse order to preserve order on the stack\n-                Deque<Value> stack = new ArrayDeque<>();\n-                if (!b.parameters().isEmpty() && !b.isEntryBlock()) {\n-                    for (int i = b.parameters().size() - 1; i >= 0; i--) {\n-                        stack.push(b.parameters().get(i));\n-                    }\n-                }\n-                int ni = bcb.instructions.size();\n-                for (int i = 0; i < ni; i++) {\n-                    switch (bcb.instructions.get(i)) {\n-                        case LabelTarget labelTarget -> {\n-        \/\/ @@@                    for (ExceptionCatch tryCatchBlock : bcr.codeModel.exceptionHandlers()) {\n-        \/\/                        if (labelTarget.label() == tryCatchBlock.tryStart()) {\n-        \/\/                            BytecodeBasicBlock handler = bcr.blockMap.get(tryCatchBlock.handler());\n-        \/\/                            b.op(BytecodeInstructionOps.\n-        \/\/                                    exceptionTableStart(c.blockMap.get(handler).successor()));\n-        \/\/                        } else if (labelTarget.label() == tryCatchBlock.tryEnd()) {\n-        \/\/                            b.op(BytecodeInstructionOps.exceptionTableEnd());\n-        \/\/                        }\n-        \/\/                    }\n-                        }\n-                        case LineNumber ln -> {\n-                            \/\/ @@@ Add special line number instructions\n-                        }\n-                        case LocalVariable lv -> {\n-                            \/\/ @@@\n+            final List<CodeElement> elements = codeModel.elementList();\n+            Block.Builder currentBlock = entryBlock;\n+            for (int i = 0; i < elements.size(); i++) {\n+                switch (elements.get(i)) {\n+                    case ExceptionCatch ec -> {\n+                        Block.Builder handler = blockMap.get(ec.handler());\n+                        if (handler.parameters().isEmpty() && ec.catchType().isPresent()) {\n+                            \/\/ Initialize handler block parameter with catch type\n+                            handler.parameter(TypeDesc.ofNominalDescriptor(ec.catchType().get().asSymbol()));\n@@ -198,2 +128,13 @@\n-                        case LocalVariableType lvt -> {\n-                            \/\/ @@@\n+                        \/\/ @@@ construct also try-catch blocks\n+                    }\n+                    case LabelTarget lt -> {\n+                        \/\/ Start of a new block\n+                        Block.Builder nextBlock = blockMap.get(lt.label());\n+                        if (currentBlock != null) {\n+                            \/\/ Implicit goto next block, add explicitly\n+                            \/\/ Use stack content as next block arguments\n+                            currentBlock.op(CoreOps.branch(nextBlock.successor(List.copyOf(stack))));\n+                            \/\/ Keep the stack\n+                        } else {\n+                            \/\/ Flow discontinued, stack must be reconstructed from block parameters\n+                            nextBlock.parameters().forEach(stack::add);\n@@ -201,2 +142,29 @@\n-                        case LoadInstruction inst -> {\n-                            stack.push(b.op(CoreOps.varLoad(locals.get(inst.slot()))));\n+                        currentBlock = nextBlock;\n+                    }\n+                    case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                        \/\/ Use stack content as target block arguments\n+                        currentBlock.op(CoreOps.branch(blockMap.get(inst.target()).successor(List.copyOf(stack))));\n+                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                        stack.clear();\n+                        currentBlock = null;\n+                    }\n+                    case BranchInstruction inst -> {\n+                        \/\/ Conditional branch\n+                        Value operand = stack.pop();\n+                        Op cop = switch (inst.opcode()) {\n+                            case IFNE -> CoreOps.eq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                            case IFEQ -> CoreOps.neq(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                            case IFGE -> CoreOps.lt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                            case IFLE -> CoreOps.gt(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                            case IFGT -> CoreOps.le(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                            case IFLT -> CoreOps.ge(operand, currentBlock.op(CoreOps.constant(TypeDesc.INT, 0)));\n+                            case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n+                            case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                            case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n+                            case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n+                            case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n+                            case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n+                            default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                        };\n+                        if (!stack.isEmpty()) {\n+                            throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n@@ -204,5 +172,42 @@\n-                        case StoreInstruction inst -> {\n-                            Value operand = stack.pop();\n-                            Op.Result local = locals.get(inst.slot());\n-                            if (local == null) {\n-                                local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n+                        Block.Builder nextBlock = currentBlock.block();\n+                        currentBlock.op(CoreOps.conditionalBranch(\n+                                currentBlock.op(cop),\n+                                nextBlock.successor(),\n+                                blockMap.get(inst.target()).successor()));\n+                        currentBlock = nextBlock;\n+                    }\n+    \/\/                case LookupSwitchInstruction si -> {\n+    \/\/                    \/\/ Default label is first successor\n+    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+    \/\/                    addSuccessors(si.cases(), blockMap, b);\n+    \/\/                }\n+    \/\/                case TableSwitchInstruction si -> {\n+    \/\/                    \/\/ Default label is first successor\n+    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+    \/\/                    addSuccessors(si.cases(), blockMap, b);\n+    \/\/                }\n+                    case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                        currentBlock.op(CoreOps._return());\n+                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                        stack.clear();\n+                        currentBlock = null;\n+                    }\n+                    case ReturnInstruction _ -> {\n+                        currentBlock.op(CoreOps._return(stack.pop()));\n+                        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+                        stack.clear();\n+                        currentBlock = null;\n+                    }\n+                    case LoadInstruction inst -> {\n+                        stack.push(currentBlock.op(CoreOps.varLoad(locals.get(inst.slot()))));\n+                    }\n+                    case StoreInstruction inst -> {\n+                        Value operand = stack.pop();\n+                        Op.Result local = locals.get(inst.slot());\n+                        if (local == null) {\n+                            local = currentBlock.op(CoreOps.var(Integer.toString(lvm), operand));\n+                            locals.put(lvm++, local);\n+                        } else {\n+                            TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n+                            if (!operand.type().equals(varType)) {\n+                                local = currentBlock.op(CoreOps.var(Integer.toString(lvm), operand));\n@@ -210,0 +215,3 @@\n+                                \/\/ @@@  The slot is reused with a different type\n+                                \/\/ so we need to update the existing entry in the map.\n+                                \/\/ This likely always connects to how to manage the map with conditional branching.\n@@ -211,10 +219,1 @@\n-                                TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n-                                if (!operand.type().equals(varType)) {\n-                                    local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n-                                    locals.put(lvm++, local);\n-                                    \/\/ @@@  The slot is reused with a different type\n-                                    \/\/ so we need to update the existing entry in the map.\n-                                    \/\/ This likely always connects to how to manage the map with conditional branching.\n-                                } else {\n-                                    b.op(CoreOps.varStore(local, operand));\n-                                }\n+                                currentBlock.op(CoreOps.varStore(local, operand));\n@@ -223,94 +222,54 @@\n-                        case IncrementInstruction inst -> {\n-                            Op.Result local = locals.get(inst.slot());\n-                            b.op(CoreOps.varStore(local, b.op(CoreOps.add(\n-                                    b.op(CoreOps.varLoad(local)),\n-                                    b.op(CoreOps.constant(TypeDesc.INT, inst.constant()))))));\n-                        }\n-                        case ConstantInstruction inst -> {\n-                            stack.push(b.op(switch (inst.constantValue()) {\n-                                case ClassDesc v -> CoreOps.constant(TypeDesc.J_L_CLASS, TypeDesc.ofNominalDescriptor(v));\n-                                case Double v -> CoreOps.constant(TypeDesc.DOUBLE, v);\n-                                case Float v -> CoreOps.constant(TypeDesc.FLOAT, v);\n-                                case Integer v -> CoreOps.constant(TypeDesc.INT, v);\n-                                case Long v -> CoreOps.constant(TypeDesc.LONG, v);\n-                                case String v -> CoreOps.constant(TypeDesc.J_L_STRING, v);\n-                                default ->\n-                                    \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n-                                    throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n-                            }));\n-                        }\n-                        case OperatorInstruction inst -> {\n-                            Value operand = stack.pop();\n-                            stack.push(b.op(switch (inst.opcode()) {\n-                                case IADD, LADD, FADD, DADD ->\n-                                        CoreOps.add(stack.pop(), operand);\n-                                case ISUB, LSUB, FSUB, DSUB ->\n-                                        CoreOps.sub(stack.pop(), operand);\n-                                case IMUL, LMUL, FMUL, DMUL ->\n-                                        CoreOps.mul(stack.pop(), operand);\n-                                case IDIV, LDIV, FDIV, DDIV ->\n-                                        CoreOps.div(stack.pop(), operand);\n-                                case IREM, LREM, FREM, DREM ->\n-                                        CoreOps.mod(stack.pop(), operand);\n-                                case INEG, LNEG, FNEG, DNEG ->\n-                                        CoreOps.neg(operand);\n-                                case ARRAYLENGTH ->\n-                                        CoreOps.arrayLength(operand);\n-                                default ->\n-                                    throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n-                            }));\n-                        }\n-                        case FieldInstruction inst -> {\n-                                FieldDesc fd = FieldDesc.field(\n-                                        TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()),\n-                                        inst.name().stringValue(),\n-                                        TypeDesc.ofNominalDescriptor(inst.typeSymbol()));\n-                                switch (inst.opcode()) {\n-                                    case GETFIELD ->\n-                                        stack.push(b.op(CoreOps.fieldLoad(fd, stack.pop())));\n-                                    case GETSTATIC ->\n-                                        stack.push(b.op(CoreOps.fieldLoad(fd)));\n-                                    case PUTFIELD -> {\n-                                        Value value = stack.pop();\n-                                        stack.push(b.op(CoreOps.fieldStore(fd, stack.pop(), value)));\n-                                    }\n-                                    case PUTSTATIC ->\n-                                        stack.push(b.op(CoreOps.fieldStore(fd, stack.pop())));\n-                                    default ->\n-                                        throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n-                                }\n-                        }\n-                        case ArrayStoreInstruction _ -> {\n-                            Value value = stack.pop();\n-                            Value index = stack.pop();\n-                            b.op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n-                        }\n-                        case ArrayLoadInstruction _ -> {\n-                            Value index = stack.pop();\n-                            stack.push(b.op(CoreOps.arrayLoadOp(stack.pop(), index)));\n-                        }\n-                        case InvokeInstruction inst -> {\n-                            MethodTypeDesc mType = MethodTypeDesc.ofNominalDescriptor(inst.typeSymbol());\n-                            List<Value> operands = new ArrayList<>();\n-                            for (var _ : mType.parameters()) {\n-                                operands.add(stack.pop());\n-                            }\n-                            MethodDesc mDesc = MethodDesc.method(TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()), inst.name().stringValue(), mType);\n-                            Op.Result result = switch (inst.opcode()) {\n-                                case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n-                                    operands.add(stack.pop());\n-                                    yield b.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                                }\n-                                case INVOKESTATIC ->\n-                                    b.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                                case INVOKESPECIAL -> {\n-                                    if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n-                                        yield b.op(CoreOps._new(\n-                                                MethodTypeDesc.methodType(\n-                                                        mType.parameters().get(0),\n-                                                        mType.parameters().subList(1, mType.parameters().size())),\n-                                                operands.reversed()));\n-                                    } else {\n-                                        operands.add(stack.pop());\n-                                        yield b.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                                    }\n+                    }\n+                    case IncrementInstruction inst -> {\n+                        Op.Result local = locals.get(inst.slot());\n+                        currentBlock.op(CoreOps.varStore(local, currentBlock.op(CoreOps.add(\n+                                currentBlock.op(CoreOps.varLoad(local)),\n+                                currentBlock.op(CoreOps.constant(TypeDesc.INT, inst.constant()))))));\n+                    }\n+                    case ConstantInstruction inst -> {\n+                        stack.push(currentBlock.op(switch (inst.constantValue()) {\n+                            case ClassDesc v -> CoreOps.constant(TypeDesc.J_L_CLASS, TypeDesc.ofNominalDescriptor(v));\n+                            case Double v -> CoreOps.constant(TypeDesc.DOUBLE, v);\n+                            case Float v -> CoreOps.constant(TypeDesc.FLOAT, v);\n+                            case Integer v -> CoreOps.constant(TypeDesc.INT, v);\n+                            case Long v -> CoreOps.constant(TypeDesc.LONG, v);\n+                            case String v -> CoreOps.constant(TypeDesc.J_L_STRING, v);\n+                            default ->\n+                                \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                                throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n+                        }));\n+                    }\n+                    case OperatorInstruction inst -> {\n+                        Value operand = stack.pop();\n+                        stack.push(currentBlock.op(switch (inst.opcode()) {\n+                            case IADD, LADD, FADD, DADD ->\n+                                    CoreOps.add(stack.pop(), operand);\n+                            case ISUB, LSUB, FSUB, DSUB ->\n+                                    CoreOps.sub(stack.pop(), operand);\n+                            case IMUL, LMUL, FMUL, DMUL ->\n+                                    CoreOps.mul(stack.pop(), operand);\n+                            case IDIV, LDIV, FDIV, DDIV ->\n+                                    CoreOps.div(stack.pop(), operand);\n+                            case IREM, LREM, FREM, DREM ->\n+                                    CoreOps.mod(stack.pop(), operand);\n+                            case INEG, LNEG, FNEG, DNEG ->\n+                                    CoreOps.neg(operand);\n+                            case ARRAYLENGTH ->\n+                                    CoreOps.arrayLength(operand);\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                        }));\n+                    }\n+                    case FieldInstruction inst -> {\n+                            FieldDesc fd = FieldDesc.field(\n+                                    TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                    inst.name().stringValue(),\n+                                    TypeDesc.ofNominalDescriptor(inst.typeSymbol()));\n+                            switch (inst.opcode()) {\n+                                case GETFIELD ->\n+                                    stack.push(currentBlock.op(CoreOps.fieldLoad(fd, stack.pop())));\n+                                case GETSTATIC ->\n+                                    stack.push(currentBlock.op(CoreOps.fieldLoad(fd)));\n+                                case PUTFIELD -> {\n+                                    Value value = stack.pop();\n+                                    stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop(), value)));\n@@ -318,0 +277,2 @@\n+                                case PUTSTATIC ->\n+                                    stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop())));\n@@ -319,4 +280,1 @@\n-                                    throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n-                            };\n-                            if (!result.type().equals(TypeDesc.VOID)) {\n-                                stack.push(result);\n+                                    throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n@@ -324,0 +282,15 @@\n+                    }\n+                    case ArrayStoreInstruction _ -> {\n+                        Value value = stack.pop();\n+                        Value index = stack.pop();\n+                        currentBlock.op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n+                    }\n+                    case ArrayLoadInstruction _ -> {\n+                        Value index = stack.pop();\n+                        stack.push(currentBlock.op(CoreOps.arrayLoadOp(stack.pop(), index)));\n+                    }\n+                    case InvokeInstruction inst -> {\n+                        MethodTypeDesc mType = MethodTypeDesc.ofNominalDescriptor(inst.typeSymbol());\n+                        List<Value> operands = new ArrayList<>();\n+                        for (var _ : mType.parameters()) {\n+                            operands.add(stack.pop());\n@@ -325,51 +298,5 @@\n-                        case NewObjectInstruction _ -> {\n-                            \/\/ Skip over this and the dup to process the invoke special\n-                            if (i + 2 < ni - 1\n-                                    && bcb.instructions.get(i + 1) instanceof StackInstruction dup\n-                                    && dup.opcode() == Opcode.DUP\n-                                    && bcb.instructions.get(i + 2) instanceof InvokeInstruction init\n-                                    && init.name().equalsString(ConstantDescs.INIT_NAME)) {\n-                                i++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"New must be followed by dup and invokespecial for <init>\");\n-                            }\n-                        }\n-                        case NewPrimitiveArrayInstruction inst -> {\n-                            stack.push(b.op(CoreOps.newArray(\n-                                    switch (inst.typeKind()) {\n-                                        case BooleanType -> TypeDesc.BOOLEAN_ARRAY;\n-                                        case ByteType -> TypeDesc.BYTE_ARRAY;\n-                                        case CharType -> TypeDesc.CHAR_ARRAY;\n-                                        case DoubleType -> TypeDesc.DOUBLE_ARRAY;\n-                                        case FloatType -> TypeDesc.FLOAT_ARRAY;\n-                                        case IntType -> TypeDesc.INT_ARRAY;\n-                                        case LongType -> TypeDesc.LONG_ARRAY;\n-                                        case ShortType -> TypeDesc.SHORT_ARRAY;\n-                                        default ->\n-                                                throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n-                                    },\n-                                    stack.pop())));\n-\n-                        }\n-                        case NewReferenceArrayInstruction inst -> {\n-                            stack.push(b.op(CoreOps.newArray(\n-                                    TypeDesc.type(TypeDesc.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n-                                    stack.pop())));\n-                        }\n-                        case NewMultiArrayInstruction inst -> {\n-                            stack.push(b.op(CoreOps._new(\n-                                    MethodTypeDesc.methodType(\n-                                            TypeDesc.ofNominalDescriptor(inst.arrayType().asSymbol()),\n-                                            Collections.nCopies(inst.dimensions(), TypeDesc.INT)),\n-                                    IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n-                        }\n-                        case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n-                            stack.push(b.op(CoreOps.cast(TypeDesc.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n-                        }\n-                        case StackInstruction inst -> {\n-                            switch (inst.opcode()) {\n-                                case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n-                                case DUP, DUP2 -> stack.push(stack.peek());\n-                                \/\/@@@ implement all other stack ops\n-                                default ->\n-                                    throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                        MethodDesc mDesc = MethodDesc.method(TypeDesc.ofNominalDescriptor(inst.owner().asSymbol()), inst.name().stringValue(), mType);\n+                        Op.Result result = switch (inst.opcode()) {\n+                            case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                                operands.add(stack.pop());\n+                                yield currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n@@ -377,10 +304,12 @@\n-                        }\n-                        case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n-                            BytecodeBasicBlock succ = bcb.successors.get(0);\n-                            Block.Reference sb;\n-                            \/\/ If the block has block parameters for stack operands then\n-                            \/\/ pop arguments off the stack and use as successor arguments\n-                            if (!b.parameters().isEmpty()) {\n-                                List<Value> args = new ArrayList<>();\n-                                for (int x = 0; x < b.parameters().size(); x++) {\n-                                    args.add(stack.pop());\n+                            case INVOKESTATIC ->\n+                                currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n+                            case INVOKESPECIAL -> {\n+                                if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                    yield currentBlock.op(CoreOps._new(\n+                                            MethodTypeDesc.methodType(\n+                                                    mType.parameters().get(0),\n+                                                    mType.parameters().subList(1, mType.parameters().size())),\n+                                            operands.reversed()));\n+                                } else {\n+                                    operands.add(stack.pop());\n+                                    yield currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n@@ -388,3 +317,0 @@\n-                                sb = c.blockMap.get(succ).successor(args);\n-                            } else {\n-                                sb = c.blockMap.get(succ).successor();\n@@ -392,35 +318,5 @@\n-                            b.op(CoreOps.branch(sb));\n-                        }\n-                        case BranchInstruction inst -> {\n-                            \/\/ Conditional branch\n-                            Value operand = stack.pop();\n-                            Op cop = switch (inst.opcode()) {\n-                                case IFNE -> CoreOps.eq(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFEQ -> CoreOps.neq(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFGE -> CoreOps.lt(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFLE -> CoreOps.gt(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFGT -> CoreOps.le(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IFLT -> CoreOps.ge(operand, b.op(CoreOps.constant(TypeDesc.INT, 0)));\n-                                case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n-                                case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n-                                case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n-                                case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n-                                case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n-                                case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n-                                default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n-                            };\n-                            if (!stack.isEmpty()) {\n-                                throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n-                            }\n-                            BytecodeBasicBlock fslb = bcb.successors.get(0);\n-                            BytecodeBasicBlock tslb = bcb.successors.get(1);\n-                            stack.push(b.op(CoreOps.conditionalBranch(\n-                                    b.op(cop),\n-                                    c.blockMap.get(tslb).successor(),\n-                                    c.blockMap.get(fslb).successor())));\n-                        }\n-                        case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n-                            b.op(CoreOps._return());\n-                        }\n-                        case ReturnInstruction _ -> {\n-                            b.op(CoreOps._return(stack.pop()));\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                        };\n+                        if (!result.type().equals(TypeDesc.VOID)) {\n+                            stack.push(result);\n@@ -428,2 +324,0 @@\n-                        default ->\n-                            throw new UnsupportedOperationException(\"Unsupported code element: \" + bcb.instructions.get(i));\n@@ -431,10 +325,10 @@\n-                }\n-                if (bcb.isImplicitTermination) {\n-                    BytecodeBasicBlock succ = bcb.successors.get(0);\n-                    Block.Reference sb;\n-                    \/\/ If the block has block parameters for stack operands then\n-                    \/\/ pop arguments off the stack and use as successor arguments\n-                    if (!b.parameters().isEmpty()) {\n-                        List<Value> args = new ArrayList<>();\n-                        for (int x = 0; x < b.parameters().size(); x++) {\n-                            args.add(stack.pop());\n+                    case NewObjectInstruction _ -> {\n+                        \/\/ Skip over this and the dup to process the invoke special\n+                        if (i + 2 < elements.size() - 1\n+                                && elements.get(i + 1) instanceof StackInstruction dup\n+                                && dup.opcode() == Opcode.DUP\n+                                && elements.get(i + 2) instanceof InvokeInstruction init\n+                                && init.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                            i++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"New must be followed by dup and invokespecial for <init>\");\n@@ -442,3 +336,0 @@\n-                        sb = c.blockMap.get(succ).successor(args);\n-                    } else {\n-                        sb = c.blockMap.get(succ).successor();\n@@ -446,63 +337,15 @@\n-                    stack.push(b.op(CoreOps.branch(sb)));\n-                }\n-            }\n-        });\n-\n-        return f;\n-    }\n-\n-    record BytecodeMethodBody(MethodModel methodModel,\n-                              CodeModel codeModel,\n-                              List<BytecodeBasicBlock> blocks,\n-                              Map<Label, BytecodeBasicBlock> blockMap) {\n-    }\n-\n-    static final class BytecodeBasicBlock {\n-        final List<CodeElement> instructions;\n-\n-        final List<BytecodeBasicBlock> successors;\n-\n-        StackMapFrameInfo frame;\n-\n-        boolean isImplicitTermination;\n-\n-        public BytecodeBasicBlock() {\n-            this.instructions = new ArrayList<>();\n-            this.successors = new ArrayList<>();\n-        }\n-\n-        void setFrame(StackMapFrameInfo frame) {\n-            this.frame = frame;\n-        }\n-\n-        void setImplicitTermination() {\n-            isImplicitTermination = true;\n-        }\n-\n-        void addInstruction(CodeElement i) {\n-            instructions.add(i);\n-        }\n-\n-        CodeElement firstInstruction() {\n-            return instructions.get(0);\n-        }\n-\n-        CodeElement lastInstruction() {\n-            return instructions.get(instructions.size() - 1);\n-        }\n-\n-        void addSuccessor(BytecodeBasicBlock s) {\n-            successors.add(s);\n-        }\n-    }\n-\n-    static BytecodeMethodBody createBodyForMethod(byte[] classdata, String methodName) {\n-        MethodModel methodModel = ClassFile.of().parse(classdata).methods().stream()\n-                .filter(mm -> mm.methodName().equalsString(methodName))\n-                .findFirst().orElseThrow(() -> new IllegalArgumentException(\"Unknown method: \" + methodName));\n-\n-        return createBlocks(methodModel);\n-    }\n-\n-    static BytecodeMethodBody createBlocks(MethodModel methodModel) {\n-        CodeModel codeModel = methodModel.code().orElseThrow();\n+                    case NewPrimitiveArrayInstruction inst -> {\n+                        stack.push(currentBlock.op(CoreOps.newArray(\n+                                switch (inst.typeKind()) {\n+                                    case BooleanType -> TypeDesc.BOOLEAN_ARRAY;\n+                                    case ByteType -> TypeDesc.BYTE_ARRAY;\n+                                    case CharType -> TypeDesc.CHAR_ARRAY;\n+                                    case DoubleType -> TypeDesc.DOUBLE_ARRAY;\n+                                    case FloatType -> TypeDesc.FLOAT_ARRAY;\n+                                    case IntType -> TypeDesc.INT_ARRAY;\n+                                    case LongType -> TypeDesc.LONG_ARRAY;\n+                                    case ShortType -> TypeDesc.SHORT_ARRAY;\n+                                    default ->\n+                                            throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                                },\n+                                stack.pop())));\n@@ -510,5 +353,0 @@\n-        \/\/ Obtain stack map frames\n-        Map<Label, StackMapFrameInfo> labelToFrameMap = codeModel.attributes().stream()\n-                .<StackMapFrameInfo>mapMulti((a, consumer) -> {\n-                    if (a instanceof StackMapTableAttribute sa) {\n-                        sa.entries().forEach(consumer::accept);\n@@ -516,18 +354,4 @@\n-                })\n-                .collect(Collectors.toMap(StackMapFrameInfo::target, sa -> sa));\n-\n-        \/\/ Construct list of basic blocks\n-        Map<Label, BytecodeBasicBlock> blockMap = new HashMap<>();\n-        List<BytecodeBasicBlock> blocks = new ArrayList<>();\n-        BytecodeBasicBlock currentBlock = new BytecodeBasicBlock();\n-        for (CodeElement ce : codeModel) {\n-            switch (ce) {\n-                case LabelTarget labelTarget -> {\n-                    StackMapFrameInfo frame = labelToFrameMap.get(labelTarget.label());\n-                    if (frame != null) {\n-                        \/\/ Not first block, nor prior block with non-terminating instruction\n-                        if (!currentBlock.instructions.isEmpty()) {\n-                            blocks.add(currentBlock);\n-                            currentBlock = new BytecodeBasicBlock();\n-                        }\n-                        currentBlock.setFrame(frame);\n+                    case NewReferenceArrayInstruction inst -> {\n+                        stack.push(currentBlock.op(CoreOps.newArray(\n+                                TypeDesc.type(TypeDesc.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n+                                stack.pop())));\n@@ -535,24 +359,6 @@\n-                    blockMap.put(labelTarget.label(), currentBlock);\n-                    currentBlock.addInstruction(ce);\n-                }\n-                case BranchInstruction _, TableSwitchInstruction _, LookupSwitchInstruction _,\n-                     ReturnInstruction _, ThrowInstruction _ -> {\n-                    \/\/ End of block\n-                    currentBlock.addInstruction(ce);\n-                    blocks.add(currentBlock);\n-                    currentBlock = new BytecodeBasicBlock();\n-                }\n-                default ->\n-                    currentBlock.addInstruction(ce);\n-            }\n-        }\n-        \/\/ Update successors\n-        for (int i = 0; i < blocks.size(); i++) {\n-            BytecodeBasicBlock b = blocks.get(i);\n-            CodeElement lastElement = b.lastInstruction();\n-            switch (lastElement) {\n-                case BranchInstruction bi -> {\n-                    b.addSuccessor(blockMap.get(bi.target()));\n-                    if (!bi.opcode().isUnconditionalBranch()) {\n-                        \/\/ Conditional false branch\n-                        b.addSuccessor(blocks.get(i + 1));\n+                    case NewMultiArrayInstruction inst -> {\n+                        stack.push(currentBlock.op(CoreOps._new(\n+                                MethodTypeDesc.methodType(\n+                                        TypeDesc.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                        Collections.nCopies(inst.dimensions(), TypeDesc.INT)),\n+                                IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n@@ -560,20 +366,14 @@\n-                }\n-                case LookupSwitchInstruction si -> {\n-                    \/\/ Default label is first successor\n-                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-                    addSuccessors(si.cases(), blockMap, b);\n-                }\n-                case TableSwitchInstruction si -> {\n-                    \/\/ Default label is first successor\n-                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-                    addSuccessors(si.cases(), blockMap, b);\n-                }\n-                \/\/ @@@ Merge cases and use _, after merge with master\n-                case ReturnInstruction _, ThrowInstruction _ -> {\n-                    \/\/ Ignore, method terminating\n-                }\n-                default -> {\n-                    \/\/ Implicit goto next block, add explicitly\n-                    b.setImplicitTermination();\n-                    BytecodeBasicBlock branch = blocks.get(i + 1);\n-                    b.addSuccessor(branch);\n+                    case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n+                        stack.push(currentBlock.op(CoreOps.cast(TypeDesc.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                    }\n+                    case StackInstruction inst -> {\n+                        switch (inst.opcode()) {\n+                            case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n+                            case DUP, DUP2 -> stack.push(stack.peek());\n+                            \/\/@@@ implement all other stack ops\n+                            default ->\n+                                throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                        }\n+                    }\n+                    default ->\n+                        throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n@@ -582,10 +382,1 @@\n-        }\n-        return new BytecodeMethodBody(methodModel, codeModel, blocks, blockMap);\n-    }\n-\n-    static void addSuccessors(List<SwitchCase> cases,\n-                              Map<Label, BytecodeBasicBlock> blockMap,\n-                              BytecodeBasicBlock b) {\n-        cases.stream().map(SwitchCase::target)\n-                .map(blockMap::get)\n-                .forEach(b::addSuccessor);\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":285,"deletions":494,"binary":false,"changes":779,"status":"modified"}]}