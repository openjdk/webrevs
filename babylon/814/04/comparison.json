{"files":[{"patch":"@@ -49,2 +49,0 @@\n-\n-    default BF16Impl[] arrayview() {return null;}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16Array.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -562,2 +562,2 @@\n-    public final T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n-        identifier(hatPtrName(hatPtrOp));\n+    private T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n+        identifier(hatPtrOp.name());\n@@ -582,1 +582,1 @@\n-                        asterisk().identifier(hatPtrName(hatPtrOp));\n+                        asterisk().identifier(hatPtrOp.name());\n@@ -594,10 +594,0 @@\n-    public final String hatPtrName(HATPtrOp hatPtrOp) {\n-        Op op = ((Op.Result) ((Op.Result) (hatPtrOp.operands().getFirst())).op().operands().getFirst()).op();\n-        return switch (op) {\n-            case CoreOp.VarOp varOp -> varOp.varName();\n-            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n-            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n-            case null, default -> \"\";\n-        };\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    private final String name;\n@@ -53,3 +54,1 @@\n-                    retValue = retValue.isEmpty()\n-                            ?retValue\n-                            :retValue.subList(0, retValue.size() - 1); \/\/ is this intended to drop the last one?\n+                    if (!retValue.isEmpty()) retValue = retValue.subList(0, retValue.size() - 1); \/\/ is this intended to drop the last one?\n@@ -63,1 +62,1 @@\n-    public HATPtrOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+    public HATPtrOp(String name, TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n@@ -68,0 +67,1 @@\n+        this.name = name;\n@@ -75,0 +75,1 @@\n+        this.name = op.name;\n@@ -86,0 +87,4 @@\n+    public String name() {\n+        return name;\n+    }\n+\n@@ -95,2 +100,2 @@\n-        public HATPtrStoreOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n-            super(resultType, bufferClass, operands);\n+        public HATPtrStoreOp(String name, TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+            super(name, resultType, bufferClass, operands);\n@@ -119,2 +124,2 @@\n-        public HATPtrLoadOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n-            super(resultType, bufferClass, operands);\n+        public HATPtrLoadOp(String name, TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+            super(name, resultType, bufferClass, operands);\n@@ -142,2 +147,2 @@\n-        public HATPtrLengthOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n-            super(resultType, bufferClass, operands);\n+        public HATPtrLengthOp(String name, TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+            super(name, resultType, bufferClass, operands);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrOp.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -74,2 +74,3 @@\n-                        } else if (isBufferArray(invoke.op()) && invoke.resultFromFirstOperandOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n-                            replaced.put(invoke.returnResult(), result);\n+                        } else if (isBufferArray(invoke.op())) { \/\/ ensures we can use iop as key for replaced vvv\n+                            Op.Result r = invoke.firstOperandAsResultOrNull().result();\n+                            replaced.put(invoke.returnResult(), r);\n@@ -77,1 +78,1 @@\n-                            bufferVarLoads.put((firstOperandAsResultOrNull(result.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) result.op());\n+                            bufferVarLoads.put((firstOperandAsResultOrNull(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n@@ -84,2 +85,3 @@\n-                        if (isBufferInitialize(varOp) && firstOperand(varOp) instanceof Op.Result result) { \/\/ makes sure we don't process a new int[] for example\n-                            Op bufferLoad = replaced.get(result).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n+                        if (isBufferInitialize(varOp)) { \/\/ makes sure we don't process a new int[] for example\n+                            Op.Result r = firstOperand(varOp).result();\n+                            Op bufferLoad = replaced.get(r).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n@@ -105,1 +107,2 @@\n-                        if ((isBufferInitialize(varLoadOp)) && firstOperand(varLoadOp) instanceof Op.Result r) {\n+                        if ((isBufferInitialize(varLoadOp))) {\n+                            Op.Result r = firstOperand(varLoadOp).result();\n@@ -125,2 +128,1 @@\n-                        if (isBufferArray(arrayLoadOp) && firstOperand(arrayLoadOp) instanceof Op.Result r) {\n-                            Op.Result buffer = replaced.getOrDefault(r, r);\n+                        if (isBufferArray(arrayLoadOp)) {\n@@ -128,0 +130,2 @@\n+                                Op.Result r = firstOperand(arrayLoadOp).result();\n+                                Op.Result buffer = replaced.getOrDefault(r, r);\n@@ -150,0 +154,1 @@\n+                                        arrayAccessInfo.bufferName(),\n@@ -162,2 +167,1 @@\n-                        if (isBufferArray(arrayStoreOp) && firstOperand(arrayStoreOp) instanceof Op.Result r) {\n-                            Op.Result buffer = replaced.getOrDefault(r, r);\n+                        if (isBufferArray(arrayStoreOp)) {\n@@ -165,1 +169,3 @@\n-                                Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n+                                Op.Result r = firstOperand(arrayStoreOp).result();\n+                                Op.Result buffer = replaced.getOrDefault(r, r);\n+                                Op varOp = findVarOpOrHATVarOP(arrayStoreOp.operands().getLast().result().op());\n@@ -188,0 +194,1 @@\n+                                        arrayAccessInfo.bufferName(),\n@@ -202,1 +209,1 @@\n-                        if (isBufferArray(arrayLengthOp) && firstOperand(arrayLengthOp) instanceof Op.Result) {\n+                        if (isBufferArray(arrayLengthOp)) {\n@@ -205,0 +212,1 @@\n+                                    arrayAccessInfo.bufferName(),\n@@ -226,1 +234,10 @@\n-    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {\n+    public static String hatPtrName(Op op) {\n+        return switch (op) {\n+            case CoreOp.VarOp varOp -> varOp.varName();\n+            case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+            case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+            case null, default -> \"\";\n+        };\n+    }\n+\n+    record ArrayAccessInfo(Op.Result buffer, String bufferName, List<Op.Result> indices) {\n@@ -246,1 +263,1 @@\n-                        indices.addFirst(res.op() instanceof JavaOp.ArrayAccessOp ? ((Op.Result) res.op().operands().get(1)) : ((Op.Result) res.op().operands().get(0)));\n+                        indices.addFirst(res.op() instanceof JavaOp.ArrayAccessOp ? res.op().operands().get(1).result() : res.op().operands().get(0).result());\n@@ -251,1 +268,1 @@\n-                    Node<T> next = node.edges().getFirst();\n+                    Node<T> next = node.edges().getFirst(); \/\/ we only traverse through the index-related ops\n@@ -257,2 +274,3 @@\n-            buffer = replaced.get((Op.Result) firstOperand(buffer.op()));\n-            return new ArrayAccessInfo(buffer, indices);\n+            buffer = replaced.get(firstOperand(buffer.op()).result());\n+            String bufferName = hatPtrName((firstOperand(buffer.op()).result()).op());\n+            return new ArrayAccessInfo(buffer, bufferName, indices);\n@@ -309,4 +327,9 @@\n-        \/\/ no! lets not compare strings what if we refactor the class names?  This is brittle\n-        return invoke.returnType().toString().startsWith(\"hat.buffer.Float\")\n-                   && invoke.name().toLowerCase() instanceof String name\n-                   &&(name.equals(\"add\")|| name.equals(\"sub\")||name.equals(\"mul\")||name.equals(\"div\"));\n+        try {\n+            return ((invoke.returnType() instanceof ClassType ct\n+                   && _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup())))\n+                   || (invoke.returnType() instanceof ArrayType at\n+                   && _V.class.isAssignableFrom((Class<?>) at.componentType().resolve(lookup()))))\n+                   && invoke.operandCount() == 2;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":44,"deletions":21,"binary":false,"changes":65,"status":"modified"}]}