{"files":[{"patch":"@@ -882,1 +882,1 @@\n-                MethodSymbol opMethodSym = (MethodSymbol)tree.codeModel;\n+                MethodSymbol opMethodSym = tree.codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.incubator.code.internal.Quotable2;\n@@ -484,15 +483,0 @@\n-        \/\/ Quotable is a marker interface with no method\n-        \/\/ the code here, expect class of object q to have the method: Quoted quoted()\n-        \/\/ for lambda objects are created through LambdaMetaFactory, we know that their classes has the method\n-        \/\/ for lambda objects created via interpreter, the proxy class implements Quotable2\n-        \/\/ so the proxy class has the method\n-        \/\/ but it's in a package that's not exported to this module\n-        \/\/ so trying to do: method.setAccessible(true), will result in the error:\n-        \/\/ module jdk.proxy2 does not \"exports com.sun.proxy.jdk.proxy2\" to module jdk.incubator.code\n-        \/\/ that's why we do it differently by checking if q is instance of Quotable2\n-\n-        \/\/ also note that lambda classes created via LambdaMetaFactory, can't access Quotable2 because it's not exported\n-\n-        if (q instanceof Quotable2 q2) {\n-            return Optional.of(q2.quoted());\n-        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,8 +0,0 @@\n-package jdk.incubator.code.internal;\n-\n-import jdk.incubator.code.Quotable;\n-import jdk.incubator.code.Quoted;\n-\n-public interface Quotable2 extends Quotable {\n-    Quoted quoted();\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/Quotable2.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -29,0 +32,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -32,1 +36,0 @@\n-import jdk.incubator.code.internal.Quotable2;\n@@ -493,1 +496,16 @@\n-                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi, Quotable2.class},\n+                \/\/ Op.ofQuotable(Quotable q) expect q's class to have the method: Quoted quoted()\n+                \/\/ that's why we define an interface that contains the method, so that proxy class has it\n+                \/\/ and the code of Op.ofQuotable works\n+                byte[] bytes = ClassFile.of().build(ClassDesc.of(\"I\" + System.nanoTime()), classBuilder -> {\n+                    classBuilder\n+                            .withFlags(AccessFlag.PUBLIC, AccessFlag.INTERFACE, AccessFlag.ABSTRACT)\n+                            .withMethod(\"quoted\", MethodTypeDesc.of(Quoted.class.describeConstable().get()),\n+                            ClassFile.ACC_PUBLIC | ClassFile.ACC_ABSTRACT, mb -> {});\n+                });\n+                Class<?> interfaceQuotedCLass;\n+                try {\n+                    interfaceQuotedCLass = l.defineClass(bytes);\n+                } catch (IllegalAccessException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi, interfaceQuotedCLass},\n@@ -495,1 +513,1 @@\n-                            if (method.getDeclaringClass() == Quotable2.class) {\n+                            if (method.getDeclaringClass() == interfaceQuotedCLass) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"}]}