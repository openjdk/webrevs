{"files":[{"patch":"@@ -53,0 +53,1 @@\n+import java.lang.reflect.Proxy;\n@@ -483,0 +484,5 @@\n+        Object oq = q;\n+        if (Proxy.isProxyClass(oq.getClass())) {\n+            oq = Proxy.getInvocationHandler(oq);\n+        }\n+\n@@ -485,1 +491,1 @@\n-            method = q.getClass().getMethod(\"quoted\");\n+            method = oq.getClass().getMethod(\"quoted\");\n@@ -490,0 +496,1 @@\n+\n@@ -492,1 +499,1 @@\n-            quoted = (Quoted) method.invoke(q);\n+            quoted = (Quoted) method.invoke(oq);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -496,24 +496,3 @@\n-                \/\/ Op.ofQuotable(Quotable q) expect q's class to have the method: Quoted quoted()\n-                \/\/ that's why we define an interface that contains the method, so that proxy class has it\n-                \/\/ and the code of Op.ofQuotable works\n-                byte[] bytes = ClassFile.of().build(ClassDesc.of(\"I\" + System.nanoTime()), classBuilder -> {\n-                    classBuilder\n-                            .withFlags(AccessFlag.PUBLIC, AccessFlag.INTERFACE, AccessFlag.ABSTRACT)\n-                            .withMethod(\"quoted\", MethodTypeDesc.of(Quoted.class.describeConstable().get()),\n-                            ClassFile.ACC_PUBLIC | ClassFile.ACC_ABSTRACT, mb -> {});\n-                });\n-                Class<?> interfaceQuotedCLass;\n-                try {\n-                    interfaceQuotedCLass = l.defineClass(bytes);\n-                } catch (IllegalAccessException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi, interfaceQuotedCLass},\n-                        (_, method, args) -> {\n-                            if (method.getDeclaringClass() == interfaceQuotedCLass) {\n-                                return new Quoted(lo, capturedValuesAndArguments);\n-                            } else {\n-                                \/\/ Delegate to FI instance\n-                                return method.invoke(fiInstance, args);\n-                            }\n-                        });\n+                Quoted quoted = new Quoted(lo, capturedValuesAndArguments);\n+                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi},\n+                        new QuotableLambdaOpInvocationHandler(fiInstance, quoted));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+package jdk.incubator.code.interpreter;\n+\n+import jdk.incubator.code.Quoted;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+public class QuotableLambdaOpInvocationHandler implements InvocationHandler {\n+    private final Object fiInstance;\n+    private final Quoted quoted;\n+\n+    public QuotableLambdaOpInvocationHandler(Object fiInstance, Quoted quoted) {\n+        this.fiInstance = fiInstance;\n+        this.quoted = quoted;\n+    }\n+    @Override\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+        if (Objects.equals(method.getName(), \"quoted\") && method.getParameterCount() == 0) {\n+            return quoted();\n+        } else {\n+            \/\/ Delegate to FI instance\n+            return method.invoke(fiInstance, args);\n+        }\n+    }\n+\n+    public final Quoted quoted() {\n+        return quoted;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/QuotableLambdaOpInvocationHandler.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"}]}