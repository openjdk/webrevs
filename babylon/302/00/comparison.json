{"files":[{"patch":"@@ -72,4 +72,3 @@\n-    final MethodHandle quotableOpField;       \/\/ A getter method handle that is used to retrieve the\n-                                              \/\/ string representation of the quotable lambda's associated\n-                                              \/\/ intermediate representation (can be null).\n-    final MethodHandleInfo quotableOpFieldInfo;  \/\/ Info about the quotable getter method handle (can be null).\n+    final MethodHandle quotableOpGetter;       \/\/ A getter method handle that is used to retrieve the\n+                                              \/\/ the quotable lambda's associated intermediate representation (can be null).\n+    final MethodHandleInfo quotableOpGetterInfo;  \/\/ Info about the quotable getter method handle (can be null).\n@@ -190,1 +189,1 @@\n-        this.quotableOpField = reflectiveField;\n+        this.quotableOpGetter = reflectiveField;\n@@ -220,1 +219,1 @@\n-                quotableOpFieldInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+                quotableOpGetterInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n@@ -224,3 +223,2 @@\n-            if (quotableOpFieldInfo.getReferenceKind() != REF_getField &&\n-                    quotableOpFieldInfo.getReferenceKind() != REF_getStatic) {\n-                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpFieldInfo));\n+            if (quotableOpGetterInfo.getReferenceKind() != REF_invokeStatic) {\n+                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpGetterInfo));\n@@ -229,1 +227,1 @@\n-            quotableOpFieldInfo = null;\n+            quotableOpGetterInfo = null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.classfile.FieldBuilder;\n@@ -44,1 +43,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -52,2 +50,0 @@\n-import java.util.Optional;\n-import java.util.ServiceLoader;\n@@ -61,1 +57,1 @@\n-import java.lang.classfile.constantpool.MethodRefEntry;\n+\n@@ -65,2 +61,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -339,1 +333,1 @@\n-                if (quotableOpField != null) {\n+                if (quotableOpGetter != null) {\n@@ -370,2 +364,2 @@\n-                if (quotableOpField != null) {\n-                    generateQuotableMethod(clb);\n+                if (quotableOpGetter != null) {\n+                    generateQuotedMethod(clb);\n@@ -381,2 +375,2 @@\n-            if (useImplMethodHandle || quotableOpField != null) {\n-                classdata = quotableOpField == null ?\n+            if (useImplMethodHandle || quotableOpGetter != null) {\n+                classdata = quotableOpGetter == null ?\n@@ -384,1 +378,1 @@\n-                        List.of(implementation, quotableOpField, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n+                        List.of(implementation, quotableOpGetter, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n@@ -437,1 +431,1 @@\n-                        if (quotableOpField != null) {\n+                        if (quotableOpGetter != null) {\n@@ -454,2 +448,2 @@\n-        MethodType mtype = quotableOpFieldInfo.getMethodType();\n-        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+        MethodType mtype = quotableOpGetterInfo.getMethodType();\n+        if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n@@ -495,0 +489,2 @@\n+                Class<?> funcOp = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.op.CoreOp$FuncOp\");\n@@ -496,1 +492,1 @@\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, String.class, Object[].class));\n+                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, funcOp, Object[].class));\n@@ -581,1 +577,1 @@\n-     * Generate a writeReplace method that supports serialization\n+    * Generate method #quoted()\n@@ -583,1 +579,1 @@\n-    private void generateQuotableMethod(ClassBuilder clb) {\n+    private void generateQuotedMethod(ClassBuilder clb) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -503,1 +503,2 @@\n-        MethodHandle quotableField = null;\n+        \/\/ Getter that returns the op of a Quotable instance\n+        MethodHandle quotableOpGetter = null;\n@@ -525,1 +526,1 @@\n-            quotableField = extractArg(args, argIndex++, MethodHandle.class);\n+            quotableOpGetter = extractArg(args, argIndex++, MethodHandle.class);\n@@ -554,1 +555,1 @@\n-                                                  quotableField);\n+                                                  quotableOpGetter);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -882,2 +882,2 @@\n-                VarSymbol reflectField = (VarSymbol)tree.codeModel;\n-                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+                MethodSymbol opMethodSym = (MethodSymbol)tree.codeModel;\n+                staticArgs = staticArgs.append(opMethodSym.asHandle());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -475,0 +476,16 @@\n+    public static Optional<Quoted> ofQuotable(Quotable q) {\n+        Method method;\n+        try {\n+            method = q.getClass().getMethod(\"quoted\");\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+        method.setAccessible(true);\n+        Quoted quoted;\n+        try {\n+            quoted = (Quoted) method.invoke(q);\n+        } catch (InvocationTargetException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return Optional.of(quoted);\n+    }\n@@ -497,1 +514,1 @@\n-        String opMethodName = \"method$op$\" + new String(sig);\n+        String opMethodName = \"op$\" + new String(sig);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * a {@link Quoted} object using {@link #quoted()}, which returns the intermediate\n+ * a {@link Quoted} object using {@link Op#ofQuotable(Quotable)}, which returns the intermediate\n@@ -34,3 +34,0 @@\n-    default Quoted quoted() {\n-        throw new UnsupportedOperationException();\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quotable.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.incubator.code.parser.OpParser;\n@@ -166,3 +167,9 @@\n-                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n-                            .withFlags(ClassFile.ACC_STATIC)\n-                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                    \/\/ return (FuncOp) OpParser.fromOpString(opText)\n+                    clb.withMethod(\"op$lambda$\" + i, MethodTypeDesc.of(FuncOp.class.describeConstable().get()),\n+                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n+                                .loadConstant(quote(lop).toText())\n+                                .invoke(Opcode.INVOKESTATIC, OpParser.class.describeConstable().get(),\n+                                        \"fromStringOfFuncOp\",\n+                                        MethodTypeDesc.of(Op.class.describeConstable().get(), CD_String), false)\n+                                .checkcast(FuncOp.class.describeConstable().get())\n+                                .areturn()));\n@@ -894,4 +901,4 @@\n-                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER,\n-                                                                 className,\n-                                                                 \"lambda$\" + lambdaIndex + \"$op\",\n-                                                                 CD_String)));\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                className,\n+                                                \"op$lambda$\" + lambdaIndex,\n+                                                MethodTypeDesc.of(FuncOp.class.describeConstable().get()))));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n+        return (Quoted)Interpreter.invoke(lookup, op, args);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -256,4 +256,3 @@\n-                \/\/ create a static final field holding the op' string text.\n-                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n-                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n-                classOps.add(opField);\n+                \/\/ create a static method that returns the FuncOp representing the lambda\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                classOps.add(opMethod);\n@@ -265,1 +264,1 @@\n-                        JCIdent opFieldId = make.Ident(opField.sym);\n+                        JCIdent opMethodId = make.Ident(opMethod.sym);\n@@ -272,2 +271,2 @@\n-                        JCMethodInvocation parsedOp = make.App(make.Ident(crSyms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n-                        interpreterArgs.append(parsedOp);\n+                        JCMethodInvocation op = make.App(opMethodId);\n+                        interpreterArgs.append(op);\n@@ -286,1 +285,1 @@\n-                        tree.codeModel = opField.sym;\n+                        tree.codeModel = opMethod.sym;\n@@ -318,5 +317,4 @@\n-                \/\/ create a static final field holding the op' string text.\n-                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n-                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n-                classOps.add(opField);\n-                tree.codeModel = opField.sym;\n+                \/\/ create a method that returns the FuncOp representing the lambda\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                classOps.add(opMethod);\n+                tree.codeModel = opMethod.sym;\n@@ -393,12 +391,0 @@\n-    private JCVariableDecl opFieldDecl(Name prefix, long flags, CoreOp.FuncOp op) {\n-        VarSymbol opFieldSym = new VarSymbol(flags | Flags.STATIC | Flags.FINAL | Flags.SYNTHETIC,\n-                prefix.append('$', names.fromString(\"op\")),\n-                syms.stringType,\n-                currentClassSym);\n-\n-        currentClassSym.members().enter(opFieldSym);\n-        JCLiteral opText = make.Literal(op.toText());\n-        JCVariableDecl opFieldTree = make.VarDef(opFieldSym, opText);\n-        return opFieldTree;\n-    }\n-\n@@ -408,1 +394,1 @@\n-        var mn = names.fromString(\"method$op$\").append(methodName);\n+        var mn = names.fromString(\"op$\").append(methodName);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -29,0 +32,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -490,1 +494,1 @@\n-            \/\/ If a quotable lambda proxy again to implement Quotable\n+            \/\/ If a quotable lambda proxy again to add method Quoted quoted()\n@@ -492,1 +496,16 @@\n-                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi},\n+                \/\/ Op.ofQuotable(Quotable q) expect q's class to have the method: Quoted quoted()\n+                \/\/ that's why we define an interface that contains the method, so that proxy class has it\n+                \/\/ and the code of Op.ofQuotable works\n+                byte[] bytes = ClassFile.of().build(ClassDesc.of(\"I\" + System.nanoTime()), classBuilder -> {\n+                    classBuilder\n+                            .withFlags(AccessFlag.PUBLIC, AccessFlag.INTERFACE, AccessFlag.ABSTRACT)\n+                            .withMethod(\"quoted\", MethodTypeDesc.of(Quoted.class.describeConstable().get()),\n+                            ClassFile.ACC_PUBLIC | ClassFile.ACC_ABSTRACT, mb -> {});\n+                });\n+                Class<?> interfaceQuotedCLass;\n+                try {\n+                    interfaceQuotedCLass = l.defineClass(bytes);\n+                } catch (IllegalAccessException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi, interfaceQuotedCLass},\n@@ -494,2 +513,1 @@\n-                            if (method.getDeclaringClass() == Quotable.class) {\n-                                \/\/ Implement Quotable::quoted\n+                            if (method.getDeclaringClass() == interfaceQuotedCLass) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        return SSA.transform((LambdaOp) iboq.quoted().op());\n+        return SSA.transform((LambdaOp) Op.ofQuotable(iboq).get().op());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-        Op qop = quotable.quoted().op();\n+        Op qop = Op.ofQuotable(quotable).get().op();\n@@ -183,1 +183,1 @@\n-            Quoted q = op.quoted();\n+            Quoted q = Op.ofQuotable(op).get();\n@@ -201,1 +201,1 @@\n-            Quoted q = op.quoted();\n+            Quoted q = Op.ofQuotable(op).get();\n@@ -238,1 +238,1 @@\n-        Quoted quoted = q.quoted();\n+        Quoted quoted = Op.ofQuotable(q).get();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -389,3 +389,3 @@\n-        Assert.assertNotNull(f.quoted());\n-        Assert.assertNotNull(f.quoted().op());\n-        Assert.assertTrue(f.quoted().op() instanceof CoreOp.LambdaOp);\n+        Assert.assertNotNull(Op.ofQuotable(f).get());\n+        Assert.assertNotNull(Op.ofQuotable(f).get().op());\n+        Assert.assertTrue(Op.ofQuotable(f).get().op() instanceof CoreOp.LambdaOp);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        CoreOp.Var<Integer> capture = (CoreOp.Var<Integer>) s.quoted().capturedValues().values().iterator().next();\n+        CoreOp.Var<Integer> capture = (CoreOp.Var<Integer>) Op.ofQuotable(s).get().capturedValues().values().iterator().next();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        LambdaOp l = (LambdaOp) f.quoted().op();\n+        LambdaOp l = (LambdaOp) Op.ofQuotable(f).get().op();\n@@ -55,1 +55,1 @@\n-        LambdaOp l = (LambdaOp) f.quoted().op();\n+        LambdaOp l = (LambdaOp) Op.ofQuotable(f).get().op();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-                if (!(quotedLambda.quoted().op() instanceof LambdaOp lambdaOp)) {\n+                if (!(Op.ofQuotable(quotedLambda).get().op() instanceof LambdaOp lambdaOp)) {\n@@ -77,1 +77,1 @@\n-                if (!(quotedLambda.quoted().capturedValues().isEmpty())) {\n+                if (!(Op.ofQuotable(quotedLambda).get().capturedValues().isEmpty())) {\n@@ -200,1 +200,1 @@\n-            if (!(quotableConsumer.quoted().op() instanceof LambdaOp consumer)) {\n+            if (!(Op.ofQuotable(quotableConsumer).get().op() instanceof LambdaOp consumer)) {\n@@ -203,1 +203,1 @@\n-            if (!(quotableConsumer.quoted().capturedValues().isEmpty())) {\n+            if (!(Op.ofQuotable(quotableConsumer).get().capturedValues().isEmpty())) {\n@@ -227,1 +227,1 @@\n-            if (!(quotableSupplier.quoted().op() instanceof LambdaOp supplier)) {\n+            if (!(Op.ofQuotable(quotableSupplier).get().op() instanceof LambdaOp supplier)) {\n@@ -230,1 +230,1 @@\n-            if (!(quotableSupplier.quoted().capturedValues().isEmpty())) {\n+            if (!(Op.ofQuotable(quotableSupplier).get().capturedValues().isEmpty())) {\n@@ -233,1 +233,1 @@\n-            if (!(quotableAccumulator.quoted().op() instanceof LambdaOp accumulator)) {\n+            if (!(Op.ofQuotable(quotableAccumulator).get().op() instanceof LambdaOp accumulator)) {\n@@ -236,1 +236,1 @@\n-            if (!(quotableAccumulator.quoted().capturedValues().isEmpty())) {\n+            if (!(Op.ofQuotable(quotableAccumulator).get().capturedValues().isEmpty())) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-            String found = canonicalizeModel(field, getModelOfQuotedOp(quotable.quoted()));\n+            String found = canonicalizeModel(field, getModelOfQuotedOp(Op.ofQuotable(quotable).get()));\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import jdk.incubator.code.Op;\n@@ -10,1 +11,1 @@\n- * @summary test that invoking Quotable#quoted returns the same instance\n+ * @summary test that invoking Op#ofQuotable returns the same instance\n@@ -22,1 +23,1 @@\n-        Assert.assertSame(q1.quoted(), q1.quoted());\n+        Assert.assertSame(Op.ofQuotable(q1).get(), Op.ofQuotable(q1).get());\n@@ -30,1 +31,1 @@\n-        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> q2.quoted()).toArray();\n+        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(q2).get()).toArray();\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        Quoted quoted = quotable.quoted();\n+        Quoted quoted = Op.ofQuotable(quotable).get();\n@@ -70,1 +70,1 @@\n-        Quoted quoted = quotable.quoted();\n+        Quoted quoted = Op.ofQuotable(quotable).get();\n@@ -97,1 +97,1 @@\n-        Quoted quoted = quotable.quoted();\n+        Quoted quoted = Op.ofQuotable(quotable).get();\n@@ -123,1 +123,1 @@\n-        Quoted quoted = quotable.quoted();\n+        Quoted quoted = Op.ofQuotable(quotable).get();\n@@ -145,1 +145,1 @@\n-        Quoted quoted = quotable.quoted();\n+        Quoted quoted = Op.ofQuotable(quotable).get();\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}