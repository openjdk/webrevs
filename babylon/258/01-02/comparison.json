{"files":[{"patch":"@@ -1,10 +0,0 @@\n-package java.lang.reflect.code;\n-\n-\/**\n- * A type, that defines a component type.\n- *\/\n-public interface TypeWithComponent {\n-\n-    TypeElement componentType();\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeWithComponent.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -398,11 +398,14 @@\n-                    if (array.type() instanceof UnresolvedType ut) {\n-                        ut.resolveTo(switch (ali.typeKind()) {\n-                            case BYTE -> JavaType.BYTE_ARRAY;\n-                            case CHAR -> JavaType.CHAR_ARRAY;\n-                            case DOUBLE -> JavaType.DOUBLE_ARRAY;\n-                            case FLOAT -> JavaType.FLOAT_ARRAY;\n-                            case INT -> JavaType.INT_ARRAY;\n-                            case LONG -> JavaType.LONG_ARRAY;\n-                            case SHORT -> JavaType.SHORT_ARRAY;\n-                            default -> null;\n-                        });\n+                    if (array.type() instanceof UnresolvedType) {\n+                        stack.push(op(CoreOp.arrayLoadOp(array, index, switch (ali.typeKind()) {\n+                            case BYTE -> UnresolvedType.unresolvedInt(); \/\/ @@@ Create UnresolvedType.unresolvedByteOrBoolean();\n+                            case CHAR -> JavaType.CHAR;\n+                            case DOUBLE -> JavaType.DOUBLE;\n+                            case FLOAT -> JavaType.FLOAT;\n+                            case INT -> JavaType.INT;\n+                            case LONG -> JavaType.LONG;\n+                            case SHORT -> JavaType.SHORT;\n+                            case REFERENCE ->  UnresolvedType.unresolvedRef();\n+                            case BOOLEAN, VOID -> throw new IllegalArgumentException(\"Unexpected array load instruction type\");\n+                        })));\n+                    } else {\n+                        stack.push(op(CoreOp.arrayLoadOp(array, index)));\n@@ -410,1 +413,0 @@\n-                    stack.push(op(CoreOp.arrayLoadOp(array, index)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -190,2 +190,0 @@\n-            case UnresolvedType.Comp _ ->\n-                null;\n@@ -197,1 +195,1 @@\n-    \/\/ Support for SlotToVarTransformer\n+    \/\/ @@@ move to SlotToVarTransformer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotOp.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.TypeWithComponent;\n@@ -44,0 +43,3 @@\n+    \/\/ @@@ unresolvedByteOrBoolean()\n+\n+    \/\/ @@@ move all resolution code to UnresolvedTypesTransformer\n@@ -49,1 +51,1 @@\n-    static final class Ref implements UnresolvedType, TypeWithComponent {\n+    static final class Ref implements UnresolvedType {\n@@ -56,1 +58,1 @@\n-            return resolved == null ? UNRESOLVED_REF : resolved.externalize();\n+            return UNRESOLVED_REF;\n@@ -92,40 +94,0 @@\n-\n-        @Override\n-        public TypeElement componentType() {\n-            return resolved == null ? new Comp(this) : ((TypeWithComponent)resolved).componentType();\n-        }\n-    }\n-\n-    static final class Comp implements  UnresolvedType, TypeWithComponent {\n-\n-        private final UnresolvedType array;\n-\n-        Comp(UnresolvedType array) {\n-            this.array = array;\n-        }\n-\n-        @Override\n-        public TypeElement.ExternalizedTypeElement externalize() {\n-            var res = resolved();\n-            return res == null ? new TypeElement.ExternalizedTypeElement(\"?COMP\", List.of(array.externalize())) : res.externalize();\n-        }\n-\n-        @Override\n-        public boolean resolveTo(TypeElement type) {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean resolveFrom(TypeElement type) {\n-            return false;\n-        }\n-\n-        @Override\n-        public JavaType resolved() {\n-            return array.resolved() instanceof ArrayType at ? at.componentType() : null;\n-        }\n-\n-        @Override\n-        public TypeElement componentType() {\n-            return new Comp(this);\n-        }\n@@ -141,1 +103,1 @@\n-            return resolved < 0 ? UNRESOLVED_INT : resolved().externalize();\n+            return UNRESOLVED_INT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedType.java","additions":6,"deletions":44,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.reflect.code.type.ArrayType;\n@@ -96,0 +97,14 @@\n+    private static TypeElement toComponent(TypeElement te) {\n+        if (te instanceof UnresolvedType ut) {\n+            te = ut.resolved();\n+        }\n+        return te instanceof ArrayType at ? at.componentType() : null;\n+    }\n+\n+    private static TypeElement toArray(TypeElement te) {\n+        if (te instanceof UnresolvedType ut) {\n+            te = ut.resolved();\n+        }\n+        return te instanceof JavaType jt ? JavaType.array(jt) : null;\n+    }\n+\n@@ -105,1 +120,1 @@\n-                    case CoreOp.LshlOp _, CoreOp.LshrOp _, CoreOp.AshrOp _ -> \/\/ Second operands are asymetric\n+                    case CoreOp.LshlOp _, CoreOp.LshrOp _, CoreOp.AshrOp _ ->\n@@ -127,0 +142,8 @@\n+                    case CoreOp.ArrayAccessOp.ArrayLoadOp alo ->\n+                        ut.resolveTo(toArray(alo.resultType()));\n+                    case CoreOp.ArrayAccessOp.ArrayStoreOp aso ->\n+                        switch (i) {\n+                            case 0 -> ut.resolveFrom(toArray(aso.operands().get(2).type()));\n+                            case 2 -> ut.resolveTo(toComponent(aso.operands().get(0).type()));\n+                            default -> false;\n+                        };\n@@ -162,0 +185,2 @@\n+                case CoreOp.ArrayAccessOp.ArrayLoadOp alo ->\n+                    ut.resolveFrom(toComponent(alo.operands().getFirst().type()));\n@@ -228,0 +253,6 @@\n+                case CoreOp.ArrayAccessOp.ArrayLoadOp alop when op.resultType() instanceof UnresolvedType -> {\n+                    List<Value> opers = alop.operands();\n+                    Value array = opers.getFirst();\n+                    Value index = opers.getLast();\n+                    cc.mapValue(op.result(), block.op(CoreOp.arrayLoadOp(cc.getValueOrDefault(array, array), cc.getValueOrDefault(index, index))));\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1919,14 +1919,0 @@\n-        static TypeElement resultType(Value array, Value v) {\n-            if (!(array.type() instanceof ArrayType arrayType)) {\n-                throw new IllegalArgumentException(\"Type is not an array type: \" + array.type());\n-            }\n-\n-            \/\/ @@@ restrict to indexes of int?\n-            TypeElement componentType = arrayType.componentType();\n-            if (v == null) {\n-                return componentType;\n-            } else {\n-                return JavaType.VOID;\n-            }\n-        }\n-\n@@ -1941,0 +1927,1 @@\n+            final TypeElement componentType;\n@@ -1944,0 +1931,1 @@\n+                this.componentType = def.resultType();\n@@ -1948,0 +1936,1 @@\n+                this.componentType = that.componentType;\n@@ -1956,0 +1945,4 @@\n+                this(array, index, ((ArrayType)array.type()).componentType());\n+            }\n+\n+            ArrayLoadOp(Value array, Value index, TypeElement componentType) {\n@@ -1957,0 +1950,1 @@\n+                this.componentType = componentType;\n@@ -1961,3 +1955,1 @@\n-                Value array = operands().get(0);\n-                TypeWithComponent t = (TypeWithComponent) array.type();\n-                return t.componentType();\n+                return componentType;\n@@ -3989,0 +3981,12 @@\n+    \/**\n+     * Creates an array load operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @param componentType type of the array component\n+     * @return the array load operation\n+     *\/\n+    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index, TypeElement componentType) {\n+        return new ArrayAccessOp.ArrayLoadOp(array, index, componentType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.code.TypeWithComponent;\n@@ -40,1 +39,1 @@\n-public final class ArrayType implements JavaType, TypeWithComponent {\n+public final class ArrayType implements JavaType {\n@@ -66,1 +65,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}