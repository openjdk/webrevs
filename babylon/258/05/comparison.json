{"files":[{"patch":"@@ -55,1 +55,0 @@\n-import java.lang.reflect.code.analysis.Liveness;\n@@ -65,1 +64,0 @@\n-import java.util.ArrayDeque;\n@@ -67,0 +65,1 @@\n+import java.util.Arrays;\n@@ -68,3 +67,1 @@\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.HashSet;\n+import java.util.IdentityHashMap;\n@@ -194,1 +191,1 @@\n-                    new BytecodeGenerator(lookup, className, capturedValues, TypeKind.from(mtd.returnType()), new Liveness(iop),\n+                    new BytecodeGenerator(lookup, className, capturedValues, TypeKind.from(mtd.returnType()),\n@@ -199,1 +196,0 @@\n-    private record ExceptionRegionWithBlocks(ExceptionRegionEnter ere, BitSet blocks) {}\n@@ -208,3 +204,3 @@\n-    private final List<ExceptionRegionWithBlocks> allExceptionRegions;\n-    private final BitSet[] blocksRegionStack;\n-    private final BitSet blocksToVisit, catchingBlocks;\n+    private final Block[][] blocksCatchMap;\n+    private final BitSet allCatchBlocks;\n+    private final Label[] tryStartLabels;\n@@ -217,0 +213,1 @@\n+    private Block[] recentCatchBlocks;\n@@ -222,1 +219,0 @@\n-                              Liveness liveness,\n@@ -234,6 +230,5 @@\n-        this.allExceptionRegions = new ArrayList<>();\n-        this.blocksRegionStack = new BitSet[blocks.size()];\n-        this.blocksToVisit = new BitSet(blocks.size());\n-        this.catchingBlocks = new BitSet();\n-        this.slots = new HashMap<>();\n-        this.singlePredecessorsValues = new HashMap<>();\n+        this.blocksCatchMap = new Block[blocks.size()][];\n+        this.allCatchBlocks = new BitSet();\n+        this.tryStartLabels = new Label[blocks.size()];\n+        this.slots = new IdentityHashMap<>();\n+        this.singlePredecessorsValues = new IdentityHashMap<>();\n@@ -242,1 +237,1 @@\n-        this.deferCache = new HashMap<>();\n+        this.deferCache = new IdentityHashMap<>();\n@@ -245,2 +240,2 @@\n-    private void setExceptionRegionStack(Block.Reference target, BitSet activeRegionStack) {\n-        setExceptionRegionStack(target.targetBlock().index(), activeRegionStack);\n+    private void setCatchStack(Block.Reference target, Block[] activeCatchBlocks) {\n+        setCatchStack(target.targetBlock().index(), activeCatchBlocks);\n@@ -249,5 +244,6 @@\n-    private void setExceptionRegionStack(int blockIndex, BitSet activeRegionStack) {\n-        if (blocksRegionStack[blockIndex] == null) {\n-            blocksToVisit.set(blockIndex);\n-            blocksRegionStack[blockIndex] = activeRegionStack;\n-            activeRegionStack.stream().forEach(r -> allExceptionRegions.get(r).blocks.set(blockIndex));\n+    private void setCatchStack(int blockIndex, Block[] activeCatchBlocks) {\n+        Block[] prevStack = blocksCatchMap[blockIndex];\n+        if (prevStack == null) {\n+            blocksCatchMap[blockIndex] = activeCatchBlocks;\n+        } else {\n+            assert Arrays.equals(prevStack, activeCatchBlocks);\n@@ -381,4 +377,3 @@\n-        return !moreThanOneUse(op.result())\n-            || op.operands().getFirst() instanceof Block.Parameter bp && bp.declaringBlock().isEntryBlock() && !moreThanOneUse(bp)\n-            || op.initOperand() instanceof Op.Result or && or.op() instanceof ConstantOp cop && canDefer(cop) && isDefinitelyAssigned(op);\n-\n+        return !op.isUninitialized() && (!moreThanOneUse(op.result())\n+            || op.initOperand() instanceof Block.Parameter bp && bp.declaringBlock().isEntryBlock() && !moreThanOneUse(bp)\n+            || op.initOperand() instanceof Op.Result or && or.op() instanceof ConstantOp cop && canDefer(cop) && isDefinitelyAssigned(op));\n@@ -394,1 +389,1 @@\n-            if (load.op() instanceof VarAccessOp.VarLoadOp && !isDominatedBy(load, stores)) {\n+            if (load.op() instanceof VarAccessOp.VarLoadOp && !BytecodeUtil.isDominatedBy(load, stores)) {\n@@ -401,29 +396,0 @@\n-    \/\/ @@@ Test for dominant set\n-    private static boolean isDominatedBy(Op.Result n, Set<Op.Result> doms) {\n-        for (Op.Result dom : doms) {\n-            if (n.isDominatedBy(dom)) {\n-                return true;\n-            }\n-        }\n-\n-        Set<Block> stopBlocks = new HashSet<>();\n-        for (Op.Result dom : doms) {\n-            stopBlocks.add(dom.declaringBlock());\n-        }\n-\n-        Deque<Block> toProcess = new ArrayDeque<>();\n-        toProcess.add(n.declaringBlock());\n-        stopBlocks.add(n.declaringBlock());\n-        while (!toProcess.isEmpty()) {\n-            for (Block b : toProcess.pop().predecessors()) {\n-                if (b.isEntryBlock()) {\n-                    return false;\n-                }\n-                if (stopBlocks.add(b)) {\n-                    toProcess.add(b);\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n@@ -519,34 +485,12 @@\n-        \/\/ Compute exception region membership\n-        setExceptionRegionStack(0, new BitSet());\n-        int blockIndex;\n-        while ((blockIndex = blocksToVisit.nextSetBit(0)) >= 0) {\n-            blocksToVisit.clear(blockIndex);\n-            BitSet activeRegionStack = blocksRegionStack[blockIndex];\n-            Block b = blocks.get(blockIndex);\n-            Op top = b.terminatingOp();\n-            switch (top) {\n-                case BranchOp bop ->\n-                    setExceptionRegionStack(bop.branch(), activeRegionStack);\n-                case ConditionalBranchOp cop -> {\n-                    setExceptionRegionStack(cop.falseBranch(), activeRegionStack);\n-                    setExceptionRegionStack(cop.trueBranch(), activeRegionStack);\n-                }\n-                case ExceptionRegionEnter er -> {\n-                    for (Block.Reference catchBlock : er.catchBlocks()) {\n-                        catchingBlocks.set(catchBlock.targetBlock().index());\n-                        setExceptionRegionStack(catchBlock, activeRegionStack);\n-                    }\n-                    activeRegionStack = (BitSet)activeRegionStack.clone();\n-                    activeRegionStack.set(allExceptionRegions.size());\n-                    ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n-                    allExceptionRegions.add(newNode);\n-                    setExceptionRegionStack(er.start(), activeRegionStack);\n-                }\n-                case ExceptionRegionExit er -> {\n-                    activeRegionStack = (BitSet)activeRegionStack.clone();\n-                    activeRegionStack.clear(activeRegionStack.length() - 1);\n-                    setExceptionRegionStack(er.end(), activeRegionStack);\n-                }\n-                default -> {\n-                }\n-            }\n+        recentCatchBlocks = new Block[0];\n+\n+        Block entryBlock = blocks.getFirst();\n+        assert entryBlock.isEntryBlock();\n+\n+        \/\/ Entry block parameters conservatively require slots\n+        \/\/ Some unused parameters might be declared before others that are used\n+        List<Block.Parameter> parameters = entryBlock.parameters();\n+        int paramSlot = 0;\n+        \/\/ Captured values prepend parameters in lambda impl methods\n+        for (Value cv : capturedValues) {\n+            slots.put(cv, new Slot(cob.parameterSlot(paramSlot++), toTypeKind(cv.type())));\n@@ -554,22 +498,2 @@\n-\n-        \/\/ Declare the exception regions\n-        for (ExceptionRegionWithBlocks erNode : allExceptionRegions.reversed()) {\n-            int start  = erNode.blocks.nextSetBit(0);\n-            while (start >= 0) {\n-                int end = erNode.blocks.nextClearBit(start);\n-                \/\/ Avoid declaration of empty exception regions\n-                if (!(blocks.get(start).firstOp() instanceof ExceptionRegionExit erEx) || erEx.end().targetBlock().index() != end) {\n-                    Label startLabel = getLabel(start);\n-                    Label endLabel = getLabel(end);\n-                    for (Block.Reference cbr : erNode.ere.catchBlocks().reversed()) {\n-                        List<Block.Parameter> params = cbr.targetBlock().parameters();\n-                        if (!params.isEmpty()) {\n-                            JavaType jt = (JavaType) params.get(0).type();\n-                            cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n-                        } else {\n-                            cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n-                        }\n-                    }\n-                }\n-                start = erNode.blocks.nextSetBit(end);\n-            }\n+        for (Block.Parameter bp : parameters) {\n+            slots.put(bp, new Slot(cob.parameterSlot(paramSlot++), toTypeKind(bp.type())));\n@@ -578,0 +502,2 @@\n+        blocksCatchMap[entryBlock.index()] = new Block[0];\n+\n@@ -584,2 +510,5 @@\n-            \/\/ Ignore any non-entry blocks that have no predecessors\n-            if (!b.isEntryBlock() && b.predecessors().isEmpty()) {\n+\n+            Block[] catchBlocks = blocksCatchMap[b.index()];\n+\n+            \/\/ Ignore inaccessible blocks\n+            if (catchBlocks == null) {\n@@ -592,14 +521,0 @@\n-            \/\/ If b is the entry block then all its parameters conservatively require slots\n-            \/\/ Some unused parameters might be declared before others that are used\n-            if (b.isEntryBlock()) {\n-                List<Block.Parameter> parameters = b.parameters();\n-                int i = 0;\n-                \/\/ Captured values prepend parameters in lambda impl methods\n-                for (Value cv : capturedValues) {\n-                    slots.put(cv, new Slot(cob.parameterSlot(i++), toTypeKind(cv.type())));\n-                }\n-                for (Block.Parameter bp : parameters) {\n-                    slots.put(bp, new Slot(cob.parameterSlot(i++), toTypeKind(bp.type())));\n-                }\n-            }\n-\n@@ -609,1 +524,1 @@\n-            if (catchingBlocks.get(b.index())) {\n+            if (allCatchBlocks.get(b.index())) {\n@@ -614,0 +529,2 @@\n+            exceptionRegionsChange(catchBlocks);\n+\n@@ -640,1 +557,1 @@\n-                        } else {\n+                        } else if (!op.isUninitialized()) {\n@@ -1027,0 +944,2 @@\n+                    setCatchStack(op.branch(), recentCatchBlocks);\n+\n@@ -1031,0 +950,3 @@\n+                    setCatchStack(op.trueBranch(), recentCatchBlocks);\n+                    setCatchStack(op.falseBranch(), recentCatchBlocks);\n+\n@@ -1040,0 +962,10 @@\n+                    List<Block.Reference> enteringCatchBlocks = op.catchBlocks();\n+                    Block[] activeCatchBlocks = Arrays.copyOf(recentCatchBlocks, recentCatchBlocks.length + enteringCatchBlocks.size());\n+                    int i = recentCatchBlocks.length;\n+                    for (Block.Reference catchRef : enteringCatchBlocks) {\n+                        allCatchBlocks.set(catchRef.targetBlock().index());\n+                        activeCatchBlocks[i++] = catchRef.targetBlock();\n+                        setCatchStack(catchRef, recentCatchBlocks);\n+                    }\n+                    setCatchStack(op.start(), activeCatchBlocks);\n+\n@@ -1041,0 +973,1 @@\n+                    cob.goto_(getLabel(op.start()));\n@@ -1043,0 +976,10 @@\n+                    List<Block.Reference> exitingCatchBlocks = op.catchBlocks();\n+                    Block[] activeCatchBlocks = Arrays.copyOf(recentCatchBlocks, recentCatchBlocks.length - exitingCatchBlocks.size());\n+                    setCatchStack(op.end(), activeCatchBlocks);\n+\n+                    \/\/ Assert block exits in reverse order\n+                    int i = recentCatchBlocks.length;\n+                    for (Block.Reference catchRef : exitingCatchBlocks) {\n+                        assert catchRef.targetBlock() == recentCatchBlocks[--i];\n+                    }\n+\n@@ -1050,0 +993,25 @@\n+        exceptionRegionsChange(new Block[0]);\n+    }\n+\n+    private void exceptionRegionsChange(Block[] newCatchBlocks) {\n+        if (!Arrays.equals(recentCatchBlocks, newCatchBlocks)) {\n+            int i = recentCatchBlocks.length - 1;\n+            Label currentLabel = cob.newBoundLabel();\n+            \/\/ Exit catch blocks missing in the newCatchBlocks\n+            while (i >=0 && (i >= newCatchBlocks.length || recentCatchBlocks[i] != newCatchBlocks[i])) {\n+                Block catchBlock = recentCatchBlocks[i--];\n+                List<Block.Parameter> params = catchBlock.parameters();\n+                if (!params.isEmpty()) {\n+                    JavaType jt = (JavaType) params.get(0).type();\n+                    cob.exceptionCatch(tryStartLabels[catchBlock.index()], currentLabel, getLabel(catchBlock.index()), jt.toNominalDescriptor());\n+                } else {\n+                    cob.exceptionCatchAll(tryStartLabels[catchBlock.index()], currentLabel, getLabel(catchBlock.index()));\n+                }\n+                tryStartLabels[catchBlock.index()] = null;\n+            }\n+            \/\/ Fill tryStartLabels for new entries\n+            while (++i < newCatchBlocks.length) {\n+                tryStartLabels[newCatchBlocks[i].index()] = currentLabel;\n+            }\n+            recentCatchBlocks = newCatchBlocks;\n+        }\n@@ -1266,1 +1234,1 @@\n-        if (catchingBlocks.get(target.index())) {\n+        if (allCatchBlocks.get(target.index())) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":102,"deletions":134,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.classfile.attribute.CodeAttribute;\n@@ -58,0 +57,1 @@\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n@@ -71,0 +71,1 @@\n+import java.util.IdentityHashMap;\n@@ -73,1 +74,0 @@\n-import java.util.function.BiFunction;\n@@ -79,1 +79,0 @@\n-import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n@@ -83,3 +82,0 @@\n-    private record ExceptionRegion(Label startLabel, Label endLabel, Label handlerLabel) {}\n-    private record ExceptionRegionEntry(CoreOp.ExceptionRegionEnter enter, Block.Builder startBlock, ExceptionRegion region) {}\n-\n@@ -108,0 +104,1 @@\n+    private final List<Value> initialValues;\n@@ -109,2 +106,4 @@\n-    private final CodeAttribute codeAttribtue;\n-    private final List<ExceptionRegion> exceptionRegions;\n+    private final List<Label> exceptionHandlers;\n+    private final Map<Integer, Block.Builder> exceptionHandlerBlocks;\n+    private final BitSet actualEreStack;\n+    private final Map<Label, BitSet> exceptionHandlersMap;\n@@ -112,1 +111,0 @@\n-    private final LocalsToVarMapper localsToVarMapper;\n@@ -114,1 +112,0 @@\n-    private final Map<LocalsToVarMapper.Variable, Value> varToValueMap;\n@@ -116,4 +113,2 @@\n-    private final Map<Object, Op.Result> constantCache;\n-    private final ArrayDeque<ExceptionRegionEntry> exceptionRegionStack;\n-    private final List<Value> initLocalValues;\n-    private final ArrayDeque<ClassDesc> newStack;\n+    private final Deque<ClassDesc> newStack;\n+    private final List<ExceptionCatch> ecs;\n@@ -124,0 +119,1 @@\n+        this.initialValues = Stream.concat(Stream.of(capturedValues), entryBlock.parameters().stream()).toList();\n@@ -126,3 +122,4 @@\n-        this.codeAttribtue = (CodeAttribute)codeModel;\n-        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n-        this.exceptionRegions = extractExceptionRegions(codeAttribtue);\n+        this.exceptionHandlers = new ArrayList<>();\n+        this.exceptionHandlerBlocks = new HashMap<>();\n+        this.actualEreStack = new BitSet();\n+        this.newStack = new ArrayDeque<>();\n@@ -130,1 +127,0 @@\n-        this.varToValueMap = new HashMap<>();\n@@ -132,13 +128,2 @@\n-        List<ClassDesc> initLocalTypes = new ArrayList<>();\n-        this.initLocalValues = new ArrayList<>();\n-        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n-            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n-            initLocalTypes.add(locType);\n-            initLocalValues.add(val);\n-            if (TypeKind.from(locType).slotSize() == 2) {\n-                initLocalTypes.add(null);\n-                initLocalValues.add(null);\n-            }\n-        });\n-        this.localsToVarMapper = new LocalsToVarMapper(classModel.thisClass().asSymbol(), initLocalTypes, codeModel.exceptionHandlers(), smta, elements);\n-        this.blockMap = smta.map(sma ->\n+        this.exceptionHandlersMap = new IdentityHashMap<>();\n+        this.blockMap = codeModel.findAttribute(Attributes.stackMapTable()).map(sma ->\n@@ -148,14 +133,4 @@\n-        this.constantCache = new HashMap<>();\n-        this.exceptionRegionStack = new ArrayDeque<>();\n-        this.newStack = new ArrayDeque<>();\n-    }\n-\n-    private static List<ExceptionRegion> extractExceptionRegions(CodeAttribute codeAttribute) {\n-        record JumpTarget(int targetBci, Label target, List<Integer> sourceBcis) {}\n-        BitSet targetBcis = new BitSet(codeAttribute.codeLength());\n-        var jumpMap = new HashMap<Integer, JumpTarget>() {\n-            void add(Label target, int sourceBci) {\n-                computeIfAbsent(codeAttribute.labelToBci(target), targetBci -> {\n-                    targetBcis.set(targetBci);\n-                    return new JumpTarget(targetBci, target, new ArrayList<>());\n-                }).sourceBcis.add(sourceBci);\n+        this.ecs = codeModel.exceptionHandlers();\n+        for (var ec : ecs.reversed()) {\n+            if (exceptionHandlers.indexOf(ec.handler()) < 0) {\n+                exceptionHandlers.add(ec.handler());\n@@ -163,37 +138,0 @@\n-        };\n-\n-        int bci = 0;\n-        \/\/ First collect jump map\n-        for (CodeElement ce : codeAttribute) {\n-            switch (ce) {\n-                case BranchInstruction bi -> {\n-                    jumpMap.add(bi.target(), bci);\n-                }\n-                case TableSwitchInstruction tsi -> {\n-                    jumpMap.add(tsi.defaultTarget(), bci);\n-                    for (var c : tsi.cases()) {\n-                        jumpMap.add(c.target(), bci);\n-                    }\n-                }\n-                case LookupSwitchInstruction lsi -> {\n-                    jumpMap.add(lsi.defaultTarget(), bci);\n-                    for (var c : lsi.cases()) {\n-                        jumpMap.add(c.target(), bci);\n-                    }\n-                }\n-                default -> {}\n-            }\n-            if (ce instanceof Instruction i) {\n-                bci += i.sizeInBytes();\n-            }\n-        }\n-\n-        \/\/ Filter and split exception regions\n-        List<ExceptionRegion> regions = codeAttribute.exceptionHandlers().stream()\n-                .filter(ec -> ec.tryStart() != ec.tryEnd() && ec.tryStart() != ec.handler())\n-                .map(ec -> new ExceptionRegion(ec.tryStart(), ec.tryEnd(), ec.handler())).distinct().toList();\n-\n-        \/\/ Exception handlers also represent jump targets\n-        \/\/ @@@ not listed all source bcis\n-        for (ExceptionRegion er : regions) {\n-            jumpMap.add(er.handlerLabel, codeAttribute.labelToBci(er.startLabel));\n@@ -201,30 +139,0 @@\n-\n-        boolean split;\n-        do {\n-            split = false;\n-            var newRegions = new ArrayList<ExceptionRegion>();\n-            for (var reg : regions) {\n-                final int startBci = codeAttribute.labelToBci(reg.startLabel());\n-                final int endBci = codeAttribute.labelToBci(reg.endLabel());\n-                final int handlerBci = codeAttribute.labelToBci(reg.handlerLabel());\n-                \/\/ Filter out exception handlers overlapping with try blocks\n-                if (handlerBci >= endBci || handlerBci < startBci) {\n-                    Label startLabel = reg.startLabel();\n-                    int breakIndex = startBci;\n-                    \/\/ Detect additional exception region entries\n-                    while ((breakIndex = targetBcis.nextSetBit(breakIndex + 1)) >= 0 &&  breakIndex < endBci) {\n-                        JumpTarget jt = jumpMap.get(breakIndex);\n-                        \/\/ Split the exception region by each external entry (jump from outside of the region)\n-                        if (jt.sourceBcis.stream().anyMatch(sourceBci -> sourceBci < startBci || sourceBci > endBci)) {\n-                            Label breakLabel = jt.target();\n-                            newRegions.add(new ExceptionRegion(startLabel, breakLabel, reg.handlerLabel()));\n-                            startLabel = breakLabel;\n-                            split = true;\n-                        }\n-                    }\n-                    newRegions.add(new ExceptionRegion(startLabel, reg.endLabel(), reg.handlerLabel()));\n-                }\n-            }\n-            regions = newRegions;\n-        } while (split); \/\/ Each new split may change branch status to an external entry and imply more splits\n-        return regions;\n@@ -238,1 +146,1 @@\n-                case INTEGER -> params.add(JavaType.INT);\n+                case INTEGER -> params.add(UnresolvedType.unresolvedInt());\n@@ -242,1 +150,1 @@\n-                case NULL -> params.add(JavaType.J_L_OBJECT);\n+                case NULL -> params.add(UnresolvedType.unresolvedRef());\n@@ -282,9 +190,7 @@\n-                CoreOp.func(methodModel.methodName().stringValue(),\n-                            MethodRef.ofNominalDescriptor(mDesc)).body(entryBlock ->\n-                                    new BytecodeLift(entryBlock,\n-                                                     classModel,\n-                                                     methodModel.code().orElseThrow()).liftBody()));\n-    }\n-\n-    private Block.Builder newBlock(List<Block.Parameter> otherBlockParams) {\n-        return entryBlock.block(otherBlockParams.stream().map(Block.Parameter::type).toList());\n+                UnresolvedTypesTransformer.transform(\n+                    SlotToVarTransformer.transform(\n+                        CoreOp.func(methodModel.methodName().stringValue(),\n+                                    MethodRef.ofNominalDescriptor(mDesc)).body(entryBlock ->\n+                                            new BytecodeLift(entryBlock,\n+                                                             classModel,\n+                                                             methodModel.code().orElseThrow()).liftBody()))));\n@@ -293,7 +199,6 @@\n-    private void moveTo(Block.Builder next) {\n-        currentBlock = next;\n-        constantCache.clear();\n-        \/\/ Stack is reconstructed from block parameters\n-        stack.clear();\n-        if (currentBlock != null) {\n-            currentBlock.parameters().forEach(stack::add);\n+    private void liftBody() {\n+        \/\/ store entry block\n+        int slot = 0;\n+        for (var ep : initialValues) {\n+            op(SlotOp.store(slot, ep));\n+            slot += ep.type().equals(JavaType.LONG) || ep.type().equals(JavaType.DOUBLE) ? 2 : 1;\n@@ -301,1 +206,0 @@\n-    }\n@@ -303,6 +207,8 @@\n-    private void endOfFlow() {\n-        currentBlock = null;\n-        constantCache.clear();\n-        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-        stack.clear();\n-    }\n+        \/\/ fill exceptionHandlersMap\n+        BitSet eStack = new BitSet();\n+        for (var e : elements) {\n+            if (e instanceof LabelTarget lt) {\n+                BitSet newEreStack = null;\n+                for (var er : ecs) {\n+                    if (lt.label() == er.tryStart() || lt.label() == er.tryEnd()) {\n+                        if (newEreStack == null) newEreStack = (BitSet)eStack.clone();\n@@ -310,30 +216,6 @@\n-    private Block.Builder findTargetBlock(Label targetLabel) {\n-        Block.Builder targetBlock = blockMap.get(targetLabel);\n-        int targetBci = codeAttribtue.labelToBci(targetLabel);\n-        for (ExceptionRegionEntry ee : exceptionRegionStack.reversed()) {\n-            if (ee.region.startLabel == targetLabel) {\n-                \/\/ Avoid region re-entry\n-                targetBlock = ee.startBlock;\n-            } else if (targetBci < codeAttribtue.labelToBci(ee.region.startLabel) || targetBci >= codeAttribtue.labelToBci(ee.region.endLabel)) {\n-                \/\/ Leaving the exception region, need to insert ExceptionRegionExit\n-                Block.Builder next = newBlock(targetBlock.parameters());\n-                next.op(CoreOp.exceptionRegionExit(targetBlock.successor(next.parameters()), ee.enter().catchBlocks().reversed()));\n-                targetBlock = next;\n-            }\n-        }\n-        return targetBlock;\n-    }\n-\n-    private void liftBody() {\n-        \/\/ Declare initial variables\n-        for (int i = 0; i < localsToVarMapper.slotsToInit(); i++) {\n-            LocalsToVarMapper.Variable v = localsToVarMapper.initSlotVar(i);\n-            if (v != null) {\n-                if (v.hasSingleAssignment()) {\n-                    varToValueMap.put(v, initLocalValues.get(i)); \/\/ Single value var initialized with entry block parameter\n-                } else {\n-                    varToValueMap.put(v, op(CoreOp.var(\"slot#\" + i, \/\/ New var with slot# name\n-                                                       JavaType.type(v.type()), \/\/ Type calculated by LocalsToVarMapper\n-                                                       i < initLocalValues.size()\n-                                                               ? initLocalValues.get(i) \/\/ Initialized with entry block parameter\n-                                                               : liftDefaultValue(v.type())))); \/\/ Initialized with default\n+                        newEreStack.set(exceptionHandlers.indexOf(er.handler()), lt.label() == er.tryStart());\n+                    }\n+                }\n+                if (newEreStack != null || blockMap.containsKey(lt.label()))  {\n+                    if (newEreStack != null) eStack = newEreStack;\n+                    exceptionHandlersMap.put(lt.label(), eStack);\n@@ -350,5 +232,13 @@\n-                    \/\/ Insert relevant tryEnd blocks\n-                    while (!exceptionRegionStack.isEmpty() && lt.label() == exceptionRegionStack.peek().region.endLabel) {\n-                        \/\/ Create exit block with parameters constructed from the stack\n-                        ExceptionRegionEntry er = exceptionRegionStack.pop();\n-                        if (currentBlock != null) {\n+                    BitSet newEreStack = exceptionHandlersMap.get(lt.label());\n+                    if (newEreStack != null) {\n+                        Block.Builder target = blockMap.get(lt.label());\n+                        if (target != null) {\n+                            if (currentBlock != null) {\n+                                \/\/ Transition to a branch target or a handler\n+                                ereTransit(actualEreStack, newEreStack, currentBlock, target, stackValues(target), exceptionHandlers.indexOf(lt.label()));\n+                            }\n+                            currentBlock = target;\n+                            stack.clear();\n+                            stack.addAll(target.parameters());\n+                        } else if (currentBlock != null && !actualEreStack.equals(newEreStack)) {\n+                            \/\/ Transition to a block with a different ERE stack\n@@ -356,25 +246,1 @@\n-                            op(CoreOp.exceptionRegionExit(next.successor(), er.enter().catchBlocks().reversed()));\n-                            currentBlock = next;\n-                        }\n-                    }\n-                    Block.Builder next = blockMap.get(lt.label());\n-\n-                    \/\/ Start of a new block if defined by stack maps\n-                    if (next != null) {\n-                        if (currentBlock != null) {\n-                            \/\/ Implicit goto next block, add explicitly\n-                            \/\/ Use stack content as next block arguments\n-                            op(CoreOp.branch(successor(next)));\n-                        }\n-                        moveTo(next);\n-                    }\n-\n-                    \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n-                    for (ExceptionRegion reg : exceptionRegions.reversed()) {\n-                        if (lt.label() == reg.startLabel()) {\n-                            \/\/ Create start block\n-                            next = entryBlock.block();\n-                            var ere = CoreOp.exceptionRegionEnter(next.successor(), findTargetBlock(reg.handlerLabel()).successor());\n-                            op(ere);\n-                            \/\/ Push ExceptionRegionEntry on stack\n-                            exceptionRegionStack.push(new ExceptionRegionEntry(ere, next, reg));\n+                            ereTransit(actualEreStack, newEreStack, currentBlock, next, List.of(), -1);\n@@ -383,0 +249,2 @@\n+                        actualEreStack.clear();\n+                        actualEreStack.or(newEreStack);\n@@ -386,1 +254,2 @@\n-                    op(CoreOp.branch(successor(findTargetBlock(inst.target()))));\n+                    Block.Builder target = blockMap.get(inst.target());\n+                    ereTransit(actualEreStack, exceptionHandlersMap.get(inst.target()), currentBlock, target, stackValues(target), exceptionHandlers.indexOf(inst.target()));\n@@ -393,6 +262,6 @@\n-                        case IFNE -> CoreOp.eq(operand, zero(operand));\n-                        case IFEQ -> CoreOp.neq(operand, zero(operand));\n-                        case IFGE -> CoreOp.lt(operand, zero(operand));\n-                        case IFLE -> CoreOp.gt(operand, zero(operand));\n-                        case IFGT -> CoreOp.le(operand, zero(operand));\n-                        case IFLT -> CoreOp.ge(operand, zero(operand));\n+                        case IFNE -> CoreOp.eq(operand, liftConstant(0));\n+                        case IFEQ -> CoreOp.neq(operand, liftConstant(0));\n+                        case IFGE -> CoreOp.lt(operand, liftConstant(0));\n+                        case IFLE -> CoreOp.gt(operand, liftConstant(0));\n+                        case IFGT -> CoreOp.le(operand, liftConstant(0));\n+                        case IFLT -> CoreOp.ge(operand, liftConstant(0));\n@@ -401,6 +270,6 @@\n-                        case IF_ICMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.INT);\n-                        case IF_ICMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.INT);\n-                        case IF_ICMPGE -> unifyOperands(CoreOp::lt, stack.pop(), operand, TypeKind.INT);\n-                        case IF_ICMPLE -> unifyOperands(CoreOp::gt, stack.pop(), operand, TypeKind.INT);\n-                        case IF_ICMPGT -> unifyOperands(CoreOp::le, stack.pop(), operand, TypeKind.INT);\n-                        case IF_ICMPLT -> unifyOperands(CoreOp::ge, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPNE -> CoreOp.eq(stack.pop(), operand);\n+                        case IF_ICMPEQ -> CoreOp.neq(stack.pop(), operand);\n+                        case IF_ICMPGE -> CoreOp.lt(stack.pop(), operand);\n+                        case IF_ICMPLE -> CoreOp.gt(stack.pop(), operand);\n+                        case IF_ICMPGT -> CoreOp.le(stack.pop(), operand);\n+                        case IF_ICMPLT -> CoreOp.ge(stack.pop(), operand);\n@@ -411,2 +280,2 @@\n-                    Block.Builder branch = findTargetBlock(inst.target());\n-                    Block.Builder next = newBlock(branch.parameters());\n+                    Block.Builder branch = targetBlockForBranch(inst.target());\n+                    Block.Builder next = entryBlock.block();\n@@ -414,3 +283,3 @@\n-                            successor(next),\n-                            successor(branch)));\n-                    moveTo(next);\n+                            next.successor(),\n+                            successorWithStack(branch)));\n+                    currentBlock = next;\n@@ -437,1 +306,1 @@\n-                    stack.push(load(i));\n+                    stack.push(op(SlotOp.load(inst.slot(), inst.typeKind())));\n@@ -440,1 +309,1 @@\n-                    store(i, inst.slot(), stack.pop());\n+                    op(SlotOp.store(inst.slot(), stack.pop()));\n@@ -443,1 +312,1 @@\n-                    store(i, inst.slot(), op(CoreOp.add(load(-i - 1), liftConstant(inst.constant()))));\n+                    op(SlotOp.store(inst.slot(), op(CoreOp.add(op(SlotOp.load(inst.slot(), TypeKind.INT)), liftConstant(inst.constant())))));\n@@ -467,1 +336,1 @@\n-                                unifyOperands(CoreOp::add, stack.pop(), operand, tk);\n+                                CoreOp.add(stack.pop(), operand);\n@@ -469,1 +338,1 @@\n-                                unifyOperands(CoreOp::sub, stack.pop(), operand, tk);\n+                                CoreOp.sub(stack.pop(), operand);\n@@ -471,1 +340,1 @@\n-                                unifyOperands(CoreOp::mul, stack.pop(), operand, tk);\n+                                CoreOp.mul(stack.pop(), operand);\n@@ -473,1 +342,1 @@\n-                                unifyOperands(CoreOp::div, stack.pop(), operand, tk);\n+                                CoreOp.div(stack.pop(), operand);\n@@ -475,1 +344,1 @@\n-                                unifyOperands(CoreOp::mod, stack.pop(), operand, tk);\n+                                CoreOp.mod(stack.pop(), operand);\n@@ -481,1 +350,1 @@\n-                                unifyOperands(CoreOp::and, stack.pop(), operand, tk);\n+                                CoreOp.and(stack.pop(), operand);\n@@ -483,1 +352,1 @@\n-                                unifyOperands(CoreOp::or, stack.pop(), operand, tk);\n+                                CoreOp.or(stack.pop(), operand);\n@@ -485,1 +354,1 @@\n-                                unifyOperands(CoreOp::xor, stack.pop(), operand, tk);\n+                                CoreOp.xor(stack.pop(), operand);\n@@ -487,1 +356,1 @@\n-                                CoreOp.lshl(stack.pop(), toInt(operand));\n+                                CoreOp.lshl(stack.pop(), operand);\n@@ -489,1 +358,1 @@\n-                                CoreOp.ashr(stack.pop(), toInt(operand));\n+                                CoreOp.ashr(stack.pop(), operand);\n@@ -491,1 +360,1 @@\n-                                CoreOp.lshr(stack.pop(), toInt(operand));\n+                                CoreOp.lshr(stack.pop(), operand);\n@@ -527,1 +396,1 @@\n-                case ArrayLoadInstruction _ -> {\n+                case ArrayLoadInstruction ali -> {\n@@ -529,1 +398,16 @@\n-                    stack.push(op(CoreOp.arrayLoadOp(stack.pop(), index)));\n+                    Value array = stack.pop();\n+                    if (array.type() instanceof UnresolvedType) {\n+                        stack.push(op(CoreOp.arrayLoadOp(array, index, switch (ali.typeKind()) {\n+                            case BYTE -> UnresolvedType.unresolvedInt(); \/\/ @@@ Create UnresolvedType.unresolvedByteOrBoolean();\n+                            case CHAR -> JavaType.CHAR;\n+                            case DOUBLE -> JavaType.DOUBLE;\n+                            case FLOAT -> JavaType.FLOAT;\n+                            case INT -> JavaType.INT;\n+                            case LONG -> JavaType.LONG;\n+                            case SHORT -> JavaType.SHORT;\n+                            case REFERENCE ->  UnresolvedType.unresolvedRef();\n+                            case BOOLEAN, VOID -> throw new IllegalArgumentException(\"Unexpected array load instruction type\");\n+                        })));\n+                    } else {\n+                        stack.push(op(CoreOp.arrayLoadOp(array, index)));\n+                    }\n@@ -597,2 +481,1 @@\n-                            stack.push(op(lambda.body(\n-                                    eb -> new BytecodeLift(eb,\n+                            stack.push(op(lambda.body(eb -> new BytecodeLift(eb,\n@@ -833,37 +716,0 @@\n-    private Value load(int i) {\n-        LocalsToVarMapper.Variable var = localsToVarMapper.instructionVar(i);\n-        if (var.hasSingleAssignment()) {\n-            Value value = varToValueMap.get(var);\n-            assert value != null: \"Uninitialized single-value variable\";\n-            return value;\n-        } else {\n-            Value value = varToValueMap.get(var);\n-            assert value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp: \"Invalid variable reference\";\n-            return op(CoreOp.varLoad(value));\n-        }\n-    }\n-\n-    private void store(int i, int slot, Value value) {\n-        LocalsToVarMapper.Variable var = localsToVarMapper.instructionVar(i);\n-        if (var.hasSingleAssignment()) {\n-            Value expectedNull = varToValueMap.put(var, value);\n-            assert expectedNull == null: \"Multiple assignements to a single-value variable\";\n-        } else {\n-            varToValueMap.compute(var, (_, varOpResult) -> {\n-                if (varOpResult == null) {\n-                    return op(CoreOp.var(\"slot#\" + slot,  \/\/ Initial variable declaration with slot# name\n-                                         JavaType.type(var.type()), \/\/ Type calculated by LocalsToVarMapper\n-                                         value));\n-                } else {\n-                    assert varOpResult instanceof Op.Result r && r.op() instanceof CoreOp.VarOp: \"Invalid variable reference\";\n-                    op(CoreOp.varStore(varOpResult, value)); \/\/ Store into an existig variable\n-                    return varOpResult;\n-                }\n-            });\n-        }\n-    }\n-\n-    private Op.Result lookup() {\n-        return constantCache.computeIfAbsent(LOOKUP, _ -> op(CoreOp.invoke(LOOKUP)));\n-    }\n-\n@@ -894,39 +740,31 @@\n-        Op.Result res = constantCache.get(c);\n-        if (res == null) {\n-            res = switch (c) {\n-                case null -> op(CoreOp.constant(JavaType.J_L_OBJECT, null));\n-                case ClassDesc cd -> op(CoreOp.constant(JavaType.J_L_CLASS, JavaType.type(cd)));\n-                case Double d -> op(CoreOp.constant(JavaType.DOUBLE, d));\n-                case Float f -> op(CoreOp.constant(JavaType.FLOAT, f));\n-                case Integer ii -> op(CoreOp.constant(JavaType.INT, ii));\n-                case Long l -> op(CoreOp.constant(JavaType.LONG, l));\n-                case String s -> op(CoreOp.constant(JavaType.J_L_STRING, s));\n-                case DirectMethodHandleDesc dmh -> {\n-                    Op.Result lookup = lookup();\n-                    Op.Result owner = liftConstant(dmh.owner());\n-                    Op.Result name = liftConstant(dmh.methodName());\n-                    MethodTypeDesc invDesc = dmh.invocationType();\n-                    yield op(switch (dmh.kind()) {\n-                        case STATIC, INTERFACE_STATIC  ->\n-                            CoreOp.invoke(FIND_STATIC, lookup, owner, name, liftConstant(invDesc));\n-                        case VIRTUAL, INTERFACE_VIRTUAL ->\n-                            CoreOp.invoke(FIND_VIRTUAL, lookup, owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)));\n-                        case SPECIAL, INTERFACE_SPECIAL ->\n-                            \/\/CoreOp.invoke(MethodRef.method(e), \"findSpecial\", owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)), lookup.lookupClass());\n-                            throw new UnsupportedOperationException(dmh.toString());\n-                        case CONSTRUCTOR       ->\n-                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n-                        case GETTER            ->\n-                            CoreOp.invoke(FIND_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n-                        case STATIC_GETTER     ->\n-                            CoreOp.invoke(FIND_STATIC_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n-                        case SETTER            ->\n-                            CoreOp.invoke(FIND_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(1)));\n-                        case STATIC_SETTER     ->\n-                            CoreOp.invoke(FIND_STATIC_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(0)));\n-                    });\n-                }\n-                case MethodTypeDesc mt -> op(switch (mt.parameterCount()) {\n-                    case 0 -> CoreOp.invoke(METHOD_TYPE_0, liftConstant(mt.returnType()));\n-                    case 1 -> CoreOp.invoke(METHOD_TYPE_1, liftConstant(mt.returnType()), liftConstant(mt.parameterType(0)));\n-                    default -> CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), liftConstantsIntoArray(CLASS_ARRAY, (Object[])mt.parameterArray()));\n+        return switch (c) {\n+            case null -> op(CoreOp.constant(UnresolvedType.unresolvedRef(), null));\n+            case ClassDesc cd -> op(CoreOp.constant(JavaType.J_L_CLASS, JavaType.type(cd)));\n+            case Double d -> op(CoreOp.constant(JavaType.DOUBLE, d));\n+            case Float f -> op(CoreOp.constant(JavaType.FLOAT, f));\n+            case Integer ii -> op(CoreOp.constant(UnresolvedType.unresolvedInt(), ii));\n+            case Long l -> op(CoreOp.constant(JavaType.LONG, l));\n+            case String s -> op(CoreOp.constant(JavaType.J_L_STRING, s));\n+            case DirectMethodHandleDesc dmh -> {\n+                Op.Result lookup = op(CoreOp.invoke(LOOKUP));\n+                Op.Result owner = liftConstant(dmh.owner());\n+                Op.Result name = liftConstant(dmh.methodName());\n+                MethodTypeDesc invDesc = dmh.invocationType();\n+                yield op(switch (dmh.kind()) {\n+                    case STATIC, INTERFACE_STATIC  ->\n+                        CoreOp.invoke(FIND_STATIC, lookup, owner, name, liftConstant(invDesc));\n+                    case VIRTUAL, INTERFACE_VIRTUAL ->\n+                        CoreOp.invoke(FIND_VIRTUAL, lookup, owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)));\n+                    case SPECIAL, INTERFACE_SPECIAL ->\n+                        \/\/CoreOp.invoke(MethodRef.method(e), \"findSpecial\", owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)), lookup.lookupClass());\n+                        throw new UnsupportedOperationException(dmh.toString());\n+                    case CONSTRUCTOR       ->\n+                        CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n+                    case GETTER            ->\n+                        CoreOp.invoke(FIND_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                    case STATIC_GETTER     ->\n+                        CoreOp.invoke(FIND_STATIC_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                    case SETTER            ->\n+                        CoreOp.invoke(FIND_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(1)));\n+                    case STATIC_SETTER     ->\n+                        CoreOp.invoke(FIND_STATIC_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(0)));\n@@ -934,22 +772,28 @@\n-                case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n-                                             && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n-                        -> liftConstant(null);\n-                case DynamicConstantDesc<?> dcd -> {\n-                    DirectMethodHandleDesc bsm = dcd.bootstrapMethod();\n-                    MethodTypeDesc bsmDesc = bsm.invocationType();\n-                    Value[] bootstrapArgs = liftBootstrapArgs(bsmDesc, dcd.constantName(), dcd.constantType(), dcd.bootstrapArgsList());\n-                    MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n-                                                        bsm.methodName(),\n-                                                        JavaType.type(bsmDesc.returnType()),\n-                                                        bsmDesc.parameterList().stream().map(JavaType::type).toArray(TypeElement[]::new));\n-                    yield op(CoreOp.invoke(bsmRef, bootstrapArgs));\n-                }\n-                case Boolean b -> op(CoreOp.constant(JavaType.BOOLEAN, b));\n-                case Byte b -> op(CoreOp.constant(JavaType.BYTE, b));\n-                case Short s -> op(CoreOp.constant(JavaType.SHORT, s));\n-                case Character ch -> op(CoreOp.constant(JavaType.CHAR, ch));\n-                default -> throw new UnsupportedOperationException(c.getClass().toString());\n-            };\n-            constantCache.put(c, res);\n-        }\n-        return res;\n+            }\n+            case MethodTypeDesc mt -> op(switch (mt.parameterCount()) {\n+                case 0 -> CoreOp.invoke(METHOD_TYPE_0, liftConstant(mt.returnType()));\n+                case 1 -> CoreOp.invoke(METHOD_TYPE_1, liftConstant(mt.returnType()), liftConstant(mt.parameterType(0)));\n+                default -> CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), liftConstantsIntoArray(CLASS_ARRAY, (Object[])mt.parameterArray()));\n+            });\n+            case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n+                                         && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n+                    -> {\n+                c = null;\n+                yield liftConstant(null);\n+            }\n+            case DynamicConstantDesc<?> dcd -> {\n+                DirectMethodHandleDesc bsm = dcd.bootstrapMethod();\n+                MethodTypeDesc bsmDesc = bsm.invocationType();\n+                Value[] bootstrapArgs = liftBootstrapArgs(bsmDesc, dcd.constantName(), dcd.constantType(), dcd.bootstrapArgsList());\n+                MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                                                    bsm.methodName(),\n+                                                    JavaType.type(bsmDesc.returnType()),\n+                                                    bsmDesc.parameterList().stream().map(JavaType::type).toArray(TypeElement[]::new));\n+                yield op(CoreOp.invoke(bsmRef, bootstrapArgs));\n+            }\n+            case Boolean b -> op(CoreOp.constant(JavaType.BOOLEAN, b));\n+            case Byte b -> op(CoreOp.constant(JavaType.BYTE, b));\n+            case Short s -> op(CoreOp.constant(JavaType.SHORT, s));\n+            case Character ch -> op(CoreOp.constant(JavaType.CHAR, ch));\n+            default -> throw new UnsupportedOperationException(c.getClass().toString());\n+        };\n@@ -960,1 +804,1 @@\n-        bootstrapArgs[0] = lookup();\n+        bootstrapArgs[0] = op(CoreOp.invoke(LOOKUP));\n@@ -981,1 +825,4 @@\n-        Value v = toInt(stack.pop());\n+        Value v = stack.pop();\n+        if (!valueType(v).equals(PrimitiveType.INT)) {\n+            v = op(CoreOp.conv(PrimitiveType.INT, v));\n+        }\n@@ -983,1 +830,1 @@\n-        Block.Builder def = findTargetBlock(defaultTarget);\n+        Block.Builder def = targetBlockForBranch(defaultTarget);\n@@ -985,6 +832,13 @@\n-            Block.Builder next = sc == last ? def : newBlock(def.parameters());\n-            op(CoreOp.conditionalBranch(\n-                    op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n-                    successor(findTargetBlock(sc.target())),\n-                    successor(next)));\n-            moveTo(next);\n+            if (sc == last) {\n+                op(CoreOp.conditionalBranch(\n+                        op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                        successorWithStack(targetBlockForBranch(sc.target())),\n+                        successorWithStack(def)));\n+            } else {\n+                Block.Builder next = entryBlock.block();\n+                op(CoreOp.conditionalBranch(\n+                        op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                        successorWithStack(targetBlockForBranch(sc.target())),\n+                        next.successor()));\n+                currentBlock = next;\n+            }\n@@ -995,2 +849,2 @@\n-    Block.Reference successor(Block.Builder next) {\n-        return next.successor(stack.stream().limit(next.parameters().size()).toList());\n+    private Block.Builder newBlock(List<Block.Parameter> otherBlockParams) {\n+        return entryBlock.block(otherBlockParams.stream().map(Block.Parameter::type).toList());\n@@ -999,4 +853,14 @@\n-    private static TypeElement valueType(Value v) {\n-        var t = v.type();\n-        while (t instanceof VarType vt) t = vt.valueType();\n-        return t;\n+    private void endOfFlow() {\n+        currentBlock = null;\n+        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+        stack.clear();\n+    }\n+\n+    private Block.Builder targetBlockForExceptionHandler(BitSet initialEreStack, int exceptionHandlerIndex) {\n+        Block.Builder target = exceptionHandlerBlocks.get(exceptionHandlerIndex);\n+        if (target == null) { \/\/ Avoid ConcurrentModificationException\n+            Label ehLabel = exceptionHandlers.get(exceptionHandlerIndex);\n+            target = transitionBlockForTarget(initialEreStack, exceptionHandlersMap.get(ehLabel), blockMap.get(ehLabel), exceptionHandlerIndex);\n+            exceptionHandlerBlocks.put(exceptionHandlerIndex, target);\n+        }\n+        return target;\n@@ -1005,3 +869,2 @@\n-    private Op unifyOperands(BiFunction<Value, Value, Op> operator, Value v1, Value v2, TypeKind tk) {\n-        if (tk != TypeKind.INT || valueType(v1).equals(valueType(v2))) return operator.apply(v1, v2);\n-        return operator.apply(toInt(v1), toInt(v2));\n+    private Block.Builder targetBlockForBranch(Label targetLabel) {\n+        return transitionBlockForTarget(actualEreStack, exceptionHandlersMap.get(targetLabel), blockMap.get(targetLabel), -1);\n@@ -1010,2 +873,5 @@\n-    private Value toInt(Value v) {\n-        return valueType(v).equals(PrimitiveType.INT) ? v : op(CoreOp.conv(PrimitiveType.INT, v));\n+    private Block.Builder transitionBlockForTarget(BitSet initialEreStack, BitSet targetEreStack, Block.Builder targetBlock, int targetExceptionHandlerIndex) {\n+        if (targetBlock == null) return null;\n+        Block.Builder transitionBlock = newBlock(targetBlock.parameters());\n+        ereTransit(initialEreStack, targetEreStack, transitionBlock, targetBlock, transitionBlock.parameters(), targetExceptionHandlerIndex);\n+        return transitionBlock;\n@@ -1014,2 +880,56 @@\n-    private Value zero(Value otherOperand) {\n-        return liftDefaultValue(BytecodeGenerator.toClassDesc(otherOperand.type()));\n+    record EreT(boolean enter, int ehi) {}\n+\n+    private void ereTransit(BitSet initialEreStack, BitSet targetEreStack, Block.Builder initialBlock, Block.Builder targetBlock, List<? extends Value> values, int targetExceptionHandlerIndex) {\n+        List<EreT> transits = new ArrayList<>();\n+        BitSet ereStack = (BitSet)initialEreStack.clone();\n+        ereStack.andNot(targetEreStack);\n+        \/\/ Split region exits by handler stack\n+        for (int ehi = ereStack.previousSetBit(Integer.MAX_VALUE); ehi >= 0; ehi = ereStack.previousSetBit(ehi - 1)) {\n+            transits.add(new EreT(false, ehi));\n+        }\n+        ereStack = (BitSet)targetEreStack.clone();\n+        ereStack.andNot(initialEreStack);\n+        \/\/ Split region enters by handler stack\n+        for (int ehi = ereStack.nextSetBit(0); ehi >= 0; ehi = ereStack.nextSetBit(ehi + 1)) {\n+            transits.add(new EreT(true, ehi));\n+        }\n+\n+        if (transits.isEmpty()) {\n+            \/\/ Join with branch\n+            initialBlock.op(CoreOp.branch(targetBlock.successor(values)));\n+        } else {\n+            \/\/ Insert ERE transitions\n+            Block.Builder currentBlock = initialBlock;\n+            ereStack = (BitSet)initialEreStack.clone();\n+            for (int i = 0; i < transits.size() - 1; i++) {\n+                EreT t = transits.get(i);\n+                Block.Builder next = entryBlock.block();\n+                ereTransit(initialBlock, currentBlock, t.enter(), next, List.of(), t.ehi(), targetExceptionHandlerIndex, ereStack);\n+                currentBlock = next;\n+                ereStack.set(t.ehi(), t.enter());\n+            }\n+            EreT t = transits.getLast();\n+            ereTransit(initialBlock, currentBlock, t.enter(), targetBlock, values, t.ehi(), targetExceptionHandlerIndex, ereStack);\n+        }\n+    }\n+\n+    private void ereTransit(Block.Builder initialBlock, Block.Builder currentBlock, boolean enter, Block.Builder targetBlock, List<? extends Value> values, int ehi, int targetExceptionHandlerIndex, BitSet handlerEreStack) {\n+        Block.Reference ref = targetBlock.successor(values);\n+        Block.Reference catcher = (ehi == targetExceptionHandlerIndex\n+                ? initialBlock\n+                : targetBlockForExceptionHandler(handlerEreStack, ehi)).successor();\n+        currentBlock.op(enter ? CoreOp.exceptionRegionEnter(ref, catcher) : CoreOp.exceptionRegionExit(ref, catcher));\n+    }\n+\n+    Block.Reference successorWithStack(Block.Builder next) {\n+        return next.successor(stackValues(next));\n+    }\n+\n+    private List<Value> stackValues(Block.Builder limit) {\n+        return stack.stream().limit(limit.parameters().size()).toList();\n+    }\n+\n+    private static TypeElement valueType(Value v) {\n+        var t = v.type();\n+        while (t instanceof VarType vt) t = vt.valueType();\n+        return t;\n@@ -1019,1 +939,2 @@\n-        return BytecodeGenerator.toTypeKind(v.type()).slotSize() == 1;\n+        TypeElement t = v.type();\n+        return !t.equals(JavaType.LONG) && !t.equals(JavaType.DOUBLE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":275,"deletions":354,"binary":false,"changes":629,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Value;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+final class BytecodeUtil {\n+\n+    \/**\n+     * Returns {@code true} if this value is dominated by the given set of values {@code doms}.\n+     * <p>\n+     * The set dominates if every path from the entry node go through any member of the set.\n+     * <p>\n+     * First part checks individual dominance of every member of the set.\n+     * <p>\n+     * If no member of the set is individually dominant, the second part tries to find path\n+     * to the entry block bypassing all blocks from the tested set.\n+     * <p>\n+     * Implementation searches for the paths by traversing the value declaring block predecessors,\n+     * stopping at blocks where values from the tested set are declared or at blocks already processed.\n+     * Negative test result is returned when the entry block is reached.\n+     * Positive test result is returned when no path to the entry block is found.\n+     *\n+     * @param value the value\n+     * @param doms the dominating set of values\n+     * @return {@code true} if this value is dominated by the given set of values {@code dom}.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public static boolean isDominatedBy(Value value, Set<? extends Value> doms) {\n+        if (doms.isEmpty()) {\n+            return false;\n+        }\n+\n+        for (Value dom : doms) {\n+            if (value.isDominatedBy(dom)) {\n+                return true;\n+            }\n+        }\n+\n+        Set<Block> stopBlocks = new HashSet<>();\n+        for (Value dom : doms) {\n+            stopBlocks.add(dom.declaringBlock());\n+        }\n+\n+        Deque<Block> toProcess = new ArrayDeque<>();\n+        toProcess.add(value.declaringBlock());\n+        stopBlocks.add(value.declaringBlock());\n+        while (!toProcess.isEmpty()) {\n+            for (Block b : toProcess.pop().predecessors()) {\n+                if (b.isEntryBlock()) {\n+                    return false;\n+                }\n+                if (stopBlocks.add(b)) {\n+                    toProcess.add(b);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private BytecodeUtil() {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeUtil.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -1,882 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.reflect.code.bytecode;\n-\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.Instruction;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapFrameInfo.*;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.instruction.*;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n-import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.NULL;\n-import static java.lang.constant.ConstantDescs.*;\n-\n-\/**\n- * LocalsToVarMapper scans bytecode for slot operations, forms oriented flow graphs of the slot operation segments,\n- * analyzes the graphs and maps the segments to distinct variables, calculates each variable type and identifies\n- * single-assigned variables and variables requiring initialization in the entry block.\n- *\/\n-final class LocalsToVarMapper {\n-\n-    \/**\n-     * Variable identity object result of the LocalsToVarMapper analysis.\n-     *\/\n-    public static final class Variable {\n-        private ClassDesc type;\n-        private boolean single;\n-\n-        \/**\n-         * {@return Variable type}\n-         *\/\n-        ClassDesc type() {\n-            return type;\n-        }\n-\n-        \/**\n-         * {@return whether the variable has only single assignement}\n-         *\/\n-        boolean hasSingleAssignment() {\n-            return single;\n-        }\n-    }\n-\n-    \/**\n-     * Segment of bytecode related to one local slot, it represents a node in the segment graph.\n-     *\/\n-    private static final class Segment {\n-\n-        \/**\n-         * Categorization of the segment graph nodes.\n-         *\/\n-        enum Kind {\n-\n-            \/**\n-             * Segment storing a value into the local slot.\n-             *\/\n-            STORE,\n-\n-            \/**\n-             * Segment requesting to load value from the local slot.\n-             *\/\n-            LOAD,\n-\n-            \/**\n-             * Segment forming a frame of connection to other segments.\n-             * This kind of segment is later either resolved as LOAD or it identifies false connection.\n-             *\/\n-            FRAME;\n-        }\n-\n-        \/**\n-         * Link between segments.\n-         *\/\n-        record Link(Segment segment, Link other) {}\n-\n-        \/**\n-         * Kind of segment.\n-         * The value is not final, {@link Kind.FRAME} segments may be later resolved to {@link Kind.LOAD}.\n-         *\/\n-        Kind kind;\n-\n-        \/**\n-         * Segment type.\n-         * The value is not final, int type may be later changed to {@code boolean}, {@code byte}, {@code short} or {@code char}.\n-         *\/\n-        ClassDesc type;\n-\n-        \/**\n-         * Variable this segment belongs to.\n-         * The value is calculated later in the process.\n-         *\/\n-        Variable var;\n-\n-\n-        \/**\n-         * Incoming segments in the flow graph.\n-         *\/\n-        Link from;\n-\n-        \/**\n-         * Outgoing segments in the flow graph.\n-         *\/\n-        Link to;\n-\n-        \/**\n-         * Links this segment to an outgoing segment.\n-         * @param toSegment outgoing segment\n-         *\/\n-        void link(Segment toSegment) {\n-            if (this != toSegment) {\n-                toSegment.from = new Link(this, toSegment.from);\n-                this.to = new Link(toSegment, this.to);\n-            }\n-        }\n-\n-        \/**\n-         * {@return Iterable over incomming segments.}\n-         *\/\n-        Iterable<Segment> fromSegments() {\n-            return () -> new LinkIterator(from);\n-        }\n-\n-        \/**\n-         * {@return Iterable over outgoing segments.}\n-         *\/\n-        Iterable<Segment> toSegments() {\n-            return () -> new LinkIterator(to);\n-        }\n-\n-        private static final class LinkIterator implements Iterator<Segment> {\n-            Link l;\n-            public LinkIterator(Link l) {\n-                this.l = l;\n-            }\n-\n-            @Override\n-            public boolean hasNext() {\n-                return l != null;\n-            }\n-\n-            @Override\n-            public Segment next() {\n-                if (l == null) throw new NoSuchElementException();\n-                Segment s = l.segment();\n-                l = l.other();\n-                return s;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Stack map frame\n-     *\/\n-    private record Frame(List<ClassDesc> stack, List<Segment> locals) {}\n-\n-    \/**\n-     * Specific instance of CD_Object identifying null initialized objects.\n-     *\/\n-    private static final ClassDesc NULL_TYPE = ClassDesc.ofDescriptor(CD_Object.descriptorString());\n-\n-    \/**\n-     * Map from instruction index to a segment.\n-     *\/\n-    private final Map<Integer, Segment> insMap;\n-\n-    \/**\n-     * Set of all involved segments.\n-     *\/\n-    private final LinkedHashSet<Segment> allSegments;\n-\n-    \/**\n-     * This class descriptor.\n-     *\/\n-    private final ClassDesc thisClass;\n-\n-    \/**\n-     * All exception handlers.\n-     *\/\n-    private final List<ExceptionCatch> exceptionHandlers;\n-\n-    \/**\n-     * Actual exception handlers stack.\n-     *\/\n-    private final Set<ExceptionCatch> handlersStack;\n-\n-    \/**\n-     * Actual stack.\n-     *\/\n-    private final List<ClassDesc> stack;\n-\n-    \/**\n-     * Actual locals.\n-     *\/\n-    private final List<Segment> locals;\n-\n-    \/**\n-     * Stack map.\n-     *\/\n-    private final Map<Label, Frame> stackMap;\n-\n-    \/**\n-     * Map of new object types (to resolve uninitialized verification types in the stack map).\n-     *\/\n-    private final Map<Label, ClassDesc> newMap;\n-\n-    \/**\n-     * Dirty flag indicates modified stack map frame (sub-int adjustments), so the scanning process must restart\n-     *\/\n-    private boolean frameDirty;\n-\n-    \/**\n-     * Initial set of slots. Static part comes from method arguments.\n-     * Later phase of the analysis adds synthetic slots (declarations of multiple-assigned variables)\n-     * with mandatory initialization in the entry block.\n-     *\/\n-    private final List<Segment> initSlots;\n-\n-    \/**\n-     * Constructor and executor of the LocalsToVarMapper.\n-     * @param thisClass This class descriptor.\n-     * @param initFrameLocals Entry frame locals, expanded form of the method receiver and arguments. Second positions of double slots are null.\n-     * @param exceptionHandlers Exception handlers.\n-     * @param stackMapTableAttribute Stack map table attribute.\n-     * @param codeElements Code elements list. Indexes of this list are keys to the {@link #instructionVar(int) } method.\n-     *\/\n-    public LocalsToVarMapper(ClassDesc thisClass,\n-                     List<ClassDesc> initFrameLocals,\n-                     List<ExceptionCatch> exceptionHandlers,\n-                     Optional<StackMapTableAttribute> stackMapTableAttribute,\n-                     List<CodeElement> codeElements) {\n-        this.insMap = new HashMap<>();\n-        this.thisClass = thisClass;\n-        this.exceptionHandlers = exceptionHandlers;\n-        this.handlersStack = new LinkedHashSet<>();\n-        this.stack = new ArrayList<>();\n-        this.locals = new ArrayList<>();\n-        this.allSegments = new LinkedHashSet<>();\n-        this.newMap = computeNewMap(codeElements);\n-        this.initSlots = new ArrayList<>();\n-        this.stackMap = stackMapTableAttribute.map(a -> a.entries().stream().collect(Collectors.toMap(\n-                StackMapFrameInfo::target,\n-                this::toFrame))).orElse(Map.of());\n-        for (ClassDesc cd : initFrameLocals) {\n-            initSlots.add(cd == null ? null : newSegment(cd, Segment.Kind.STORE));\n-        }\n-        int initSize = allSegments.size();\n-\n-        \/\/ Main loop of the scan phase\n-        do {\n-            \/\/ Reset of the exception handler stack\n-            handlersStack.clear();\n-            \/\/ Slot states reset if running additional rounds (changed stack map frames)\n-            if (allSegments.size() > initSize) {\n-                while (allSegments.size() > initSize) allSegments.removeLast();\n-                allSegments.forEach(sl -> {\n-                    sl.from = null;\n-                    sl.to = null;\n-                    sl.var = null;\n-                });\n-            }\n-            \/\/ Initial frame store\n-            for (int i = 0; i < initFrameLocals.size(); i++) {\n-                storeLocal(i, initSlots.get(i), locals);\n-            }\n-            this.frameDirty = false;\n-            \/\/ Iteration over all code elements\n-            for (int i = 0; i < codeElements.size(); i++) {\n-                var ce = codeElements.get(i);\n-                scan(i, ce);\n-            }\n-            endOfFlow();\n-        } while (this.frameDirty);\n-\n-        \/\/ Segment graph analysis phase\n-        \/\/ First resolve FRAME segments to LOAD segments if directly followed by a LOAD segment\n-        \/\/ Remaining FRAME segments do not form connection with segments of the same variable and will be ignored.\n-        boolean changed = true;\n-        while (changed) {\n-            changed = false;\n-            for (Segment segment : allSegments) {\n-                if (segment.kind == Segment.Kind.FRAME) {\n-                    for (Segment to : segment.toSegments()) {\n-                        if (to.kind == Segment.Kind.LOAD) {\n-                            changed = true;\n-                            segment.kind = Segment.Kind.LOAD;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Assign variable to segments, calculate var type\n-        Set<Segment> stores = new LinkedHashSet<>(); \/\/ Helper set to collect all STORE segments of a variable\n-        ArrayDeque<Segment> q = new ArrayDeque<>(); \/\/ Working queue\n-        Set<Segment> visited = new LinkedHashSet<>(); \/\/ Helper set to traverse segment graph to filter initial stores\n-        for (Segment segment : allSegments) {\n-            \/\/ Only STORE and LOAD segments without assigned var are computed\n-            if (segment.var == null && segment.kind != Segment.Kind.FRAME) {\n-                Variable var = new Variable(); \/\/ New variable\n-                q.add(segment);\n-                var.type = segment.type; \/\/ Initial variable type\n-                while (!q.isEmpty()) {\n-                    Segment se = q.pop();\n-                    if (se.var == null) {\n-                        se.var = var; \/\/ Assign variable to the segment\n-                        for (Segment to : se.toSegments()) {\n-                            \/\/ All following LOAD segments belong to the same variable\n-                            if (to.kind == Segment.Kind.LOAD) {\n-                                if (var.type == NULL_TYPE) {\n-                                    var.type = to.type; \/\/ Initially null type re-assignemnt\n-                                }\n-                                if (to.var == null) {\n-                                    q.add(to);\n-                                }\n-                            }\n-                        }\n-                        if (se.kind == Segment.Kind.LOAD) {\n-                            \/\/ Segments preceeding LOAD segment also belong to the same variable\n-                            for (Segment from : se.fromSegments()) {\n-                                if (from.kind != Segment.Kind.FRAME) { \/\/ FRAME segments are ignored\n-                                    if (var.type == NULL_TYPE) {\n-                                        var.type = from.type; \/\/ Initially null type re-assignemnt\n-                                    }\n-                                    if (from.var == null) {\n-                                        q.add(from);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if (se.var == var && se.kind == Segment.Kind.STORE) {\n-                        stores.add(se); \/\/ Collection of all STORE segments of the variable\n-                    }\n-                }\n-\n-                \/\/ Single-assigned variable has only one STORE segment\n-                var.single = stores.size() < 2;\n-\n-                \/\/ Identification of initial STORE segments\n-                for (var it = stores.iterator(); it.hasNext();) {\n-                    visited.clear();\n-                    Segment s = it.next();\n-                    if (s.from != null && varDominatesOverSegmentPredecessors(s, var, visited)) {\n-                        \/\/ A store preceeding dominantly with segments of the same variable is not initial\n-                        it.remove();\n-                    }\n-                }\n-\n-                \/\/ Remaining stores are all initial.\n-                if (stores.size() > 1) {\n-                    \/\/ A synthetic default-initialized dominant segment must be inserted to the variable, if there is more than one initial store segment.\n-                    \/\/ It is not necessary to link it with other variable segments, the analysys ends here.\n-                    Segment initialSegment = new Segment();\n-                    initialSegment.var = var;\n-                    initSlots.add(initialSegment);\n-                    if (var.type == CD_long || var.type == CD_double) {\n-                        initSlots.add(null); \/\/ Do not forget to alocate second slot for double slots.\n-                    }\n-                }\n-                stores.clear();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * {@return Number of slots to initialize at entry block (method receiver + arguments + synthetic variable initialization segments).}\n-     *\/\n-    public int slotsToInit() {\n-        return initSlots.size();\n-    }\n-\n-    \/**\n-     * {@return Variable related to the given initial slot or null}\n-     * @param initSlot initial slot index\n-     *\/\n-    public Variable initSlotVar(int initSlot) {\n-        Segment s = initSlots.get(initSlot);\n-        return s == null ? null : s.var;\n-    }\n-\n-    \/**\n-     * Method returns relevant {@link Variable} for instructions operating with local slots,\n-     * such as {@link LoadInstruction}, {@link StoreInstruction} and {@link IncrementInstruction}.\n-     * For all other elements it returns {@code null}.\n-     *\n-     * Instructions are identified by index into the {@code codeElements} list used in the {@link LocalsToVarMapper} initializer.\n-     *\n-     * {@link IncrementInstruction} relates to two potentially distinct variables, one variable to load the value from\n-     * and one variable to store the incremented value into (see: {@link BytecodeLift#liftBody() }).\n-     *\n-     * @param codeElementIndex code element index\n-     * @return Variable related to the given code element index or null\n-     *\/\n-    public Variable instructionVar(int codeElementIndex) {\n-        return insMap.get(codeElementIndex).var;\n-    }\n-\n-    \/**\n-     * Tests if variable dominates over the segment predecessors.\n-     * All incoming paths to the segment must lead from segments of the given variable and not of any other variable.\n-     * The paths may pass through {@code FRAME} segments, which do not belong to any variable and their dominance must be computed.\n-     * Implementation relies on loops-avoiding breadth-first negative search.\n-     *\/\n-    private static boolean varDominatesOverSegmentPredecessors(Segment segment, Variable var, Set<Segment> visited) {\n-        if (visited.add(segment)) {\n-            for (Segment pred : segment.fromSegments()) {\n-                \/\/ Breadth-first\n-                if (pred.kind != Segment.Kind.FRAME && pred.var != var) {\n-                    return false;\n-                }\n-            }\n-            for (Segment pred : segment.fromSegments()) {\n-                \/\/ Preceeding FRAME segment implies there is no directly preceeding variable and the dominance test must go deeper\n-                if (pred.kind == Segment.Kind.FRAME && !varDominatesOverSegmentPredecessors(pred, var, visited)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Cconverts {@link StackMapFrameInfo} to {@code Frame}, where locals are expanded form ({@code null}-filled second slots for double-slots)\n-     * of {@code FRAME} segments.\n-     * @param smfi StackMapFrameInfo\n-     * @return Frame\n-     *\/\n-    private Frame toFrame(StackMapFrameInfo smfi) {\n-        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n-        List<Segment> flocals = new ArrayList<>(smfi.locals().size() * 2);\n-        for (var vti : smfi.stack()) {\n-            fstack.add(vtiToStackType(vti));\n-        }\n-        int i = 0;\n-        for (var vti : smfi.locals()) {\n-            storeLocal(i, vtiToStackType(vti), flocals, Segment.Kind.FRAME);\n-            i += vti == DOUBLE || vti == LONG ? 2 : 1;\n-        }\n-        return new Frame(fstack, flocals);\n-    }\n-\n-    \/**\n-     * {@return map of labels immediately preceding {@link NewObjectInstruction} to the object types}\n-     * The map is important to resolve uninitialized verification types in the stack map.\n-     * @param codeElements List of code elements to scan\n-     *\/\n-    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n-        Map<Label, ClassDesc> newMap = new HashMap<>();\n-        Label lastLabel = null;\n-        for (int i = 0; i < codeElements.size(); i++) {\n-            switch (codeElements.get(i)) {\n-                case LabelTarget lt -> lastLabel = lt.label();\n-                case NewObjectInstruction newI -> {\n-                    if (lastLabel != null) {\n-                        newMap.put(lastLabel, newI.className().asSymbol());\n-                    }\n-                }\n-                case Instruction _ -> lastLabel = null; \/\/invalidate label\n-                default -> {} \/\/skip\n-            }\n-        }\n-        return newMap;\n-    }\n-\n-    \/**\n-     * {@return new segment and registers it in {@code allSegments} list}\n-     * @param type class descriptor of segment type\n-     * @param kind one of the segment kinds: {@code STORE}, {@code LOAD} or {@code FRAME}\n-     *\/\n-    private Segment newSegment(ClassDesc type, Segment.Kind kind) {\n-        Segment s = new Segment();\n-        s.kind = kind;\n-        s.type = type;\n-        allSegments.add(s);\n-        return s;\n-    }\n-\n-    \/**\n-     * {@return resolved class descriptor of the stack map frame verification type, custom {@code NULL_TYPE} for {@code ITEM_NULL}\n-     * or {@code null} for {@code ITEM_TOP}}\n-     * @param vti stack map frame verification type\n-     *\/\n-    private ClassDesc vtiToStackType(StackMapFrameInfo.VerificationTypeInfo vti) {\n-        return switch (vti) {\n-            case INTEGER -> CD_int;\n-            case FLOAT -> CD_float;\n-            case DOUBLE -> CD_double;\n-            case LONG -> CD_long;\n-            case UNINITIALIZED_THIS -> thisClass;\n-            case NULL -> NULL_TYPE;\n-            case ObjectVerificationTypeInfo ovti -> ovti.classSymbol();\n-            case UninitializedVerificationTypeInfo uvti ->\n-                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n-                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n-                });\n-            case TOP -> null;\n-        };\n-    }\n-\n-    \/**\n-     * Pushes the class descriptor on {@link #stack}, except for {@code void}.\n-     * @param type class descriptor\n-     *\/\n-    private void push(ClassDesc type) {\n-        if (!ConstantDescs.CD_void.equals(type)) stack.add(type);\n-    }\n-\n-    \/**\n-     * Pushes the class descriptors on the {@link #stack} at the relative position, except for {@code void}.\n-     * @param pos position relative to the stack tip\n-     * @param types class descriptors\n-     *\/\n-    private void pushAt(int pos, ClassDesc... types) {\n-        for (var t : types)\n-            if (!ConstantDescs.CD_void.equals(t))\n-                stack.add(stack.size() + pos, t);\n-    }\n-\n-    \/**\n-     * {@return if class descriptor on the {@link #stack} at the relative position is {@code long} or {@code double}}\n-     * @param pos position relative to the stack tip\n-     *\/\n-    private boolean doubleAt(int pos) {\n-        var t  = stack.get(stack.size() + pos);\n-        return t.equals(CD_long) || t.equals(CD_double);\n-    }\n-\n-    \/**\n-     * {@return class descriptor poped from the {@link #stack}}\n-     *\/\n-    private ClassDesc pop() {\n-        return stack.removeLast();\n-    }\n-\n-    \/**\n-     * {@return class descriptor from the relative position of the {@link #stack}}\n-     * @param pos position relative to the stack tip\n-     *\/\n-    private ClassDesc get(int pos) {\n-        return stack.get(stack.size() + pos);\n-    }\n-\n-    \/**\n-     * {@return class descriptor from the tip of the {@link #stack}}\n-     *\/\n-    private ClassDesc top() {\n-        return stack.getLast();\n-    }\n-\n-    \/**\n-     * {@return two class descriptors from the tip of the {@link #stack}}\n-     *\/\n-    private ClassDesc[] top2() {\n-        return new ClassDesc[] {stack.get(stack.size() - 2), stack.getLast()};\n-    }\n-\n-    \/**\n-     * Pops given number of class descriptors from the {@link #stack}.\n-     * @param i number of class descriptors to pop\n-     * @return this LocalsToVarMapper\n-     *\/\n-    private LocalsToVarMapper pop(int i) {\n-        while (i-- > 0) pop();\n-        return this;\n-    }\n-\n-    \/**\n-     * Stores class descriptor as a new {@code STORE} {@link Segment} to the {@link #locals}.\n-     * The new segment is linked with the previous segment on the same slot position (if any).\n-     * @param slot locals slot number\n-     * @param type new segment class descriptor\n-     *\/\n-    private void storeLocal(int slot, ClassDesc type) {\n-        storeLocal(slot, type, locals, Segment.Kind.STORE);\n-    }\n-\n-    \/**\n-     * Stores class descriptor as a new {@link Segment} of given kind to the given list .\n-     * The new segment is linked with the previous segment on the same slot position (if any).\n-     * @param slot locals slot number\n-     * @param type new segment class descriptor\n-     * @param where target list of segments\n-     * @param kind new segment kind\n-     *\/\n-    private void storeLocal(int slot, ClassDesc type, List<Segment> where, Segment.Kind kind) {\n-        storeLocal(slot, type == null ? null : newSegment(type, kind), where);\n-    }\n-\n-    \/**\n-     * Stores the {@link Segment} to the given list.\n-     * The new segment is linked with the previous segment on the same slot position (if any).\n-     * @param slot locals slot number\n-     * @param segment the segment to store\n-     * @param where target list of segments\n-     *\/\n-    private void storeLocal(int slot, Segment segment, List<Segment> where) {\n-        if (segment != null) {\n-            for (int i = where.size(); i <= slot; i++) where.add(null);\n-            Segment prev = where.set(slot, segment);\n-            if (prev != null) {\n-                prev.link(segment);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Links existing {@link Segment} of the {@link #locals} with a new {@code LOAD} {@link Segment} with inherited type.\n-     * @param slot slot number to load\n-     * @return type of the local\n-     *\/\n-    private ClassDesc loadLocal(int slot) {\n-        Segment segment = locals.get(slot);\n-        Segment newSegment = newSegment(segment.type, Segment.Kind.LOAD);\n-        segment.link(newSegment);\n-        return segment.type;\n-    }\n-\n-    \/**\n-     * Main code element scanning method of the scan loop.\n-     * @param elementIndex element index\n-     * @param el code element\n-     *\/\n-    private void scan(int elementIndex, CodeElement el) {\n-        switch (el) {\n-            case ArrayLoadInstruction _ ->\n-                pop(1).push(pop().componentType());\n-            case ArrayStoreInstruction _ ->\n-                pop(3);\n-            case BranchInstruction i -> {\n-                switch (i.opcode()) {\n-                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n-                        pop();\n-                        mergeToTargetFrame(i.target());\n-                    }\n-                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n-                        pop(2);\n-                        mergeToTargetFrame(i.target());\n-                    }\n-                    case GOTO, GOTO_W -> {\n-                        mergeToTargetFrame(i.target());\n-                        endOfFlow();\n-                    }\n-                }\n-            }\n-            case ConstantInstruction i ->\n-                push(switch (i.constantValue()) {\n-                    case null -> NULL_TYPE;\n-                    case ClassDesc _ -> CD_Class;\n-                    case Double _ -> CD_double;\n-                    case Float _ -> CD_float;\n-                    case Integer _ -> CD_int;\n-                    case Long _ -> CD_long;\n-                    case String _ -> CD_String;\n-                    case DynamicConstantDesc<?> cd when cd.equals(NULL) -> NULL_TYPE;\n-                    case DynamicConstantDesc<?> cd -> cd.constantType();\n-                    case DirectMethodHandleDesc _ -> CD_MethodHandle;\n-                    case MethodTypeDesc _ -> CD_MethodType;\n-                });\n-            case ConvertInstruction i ->\n-                pop(1).push(i.toType().upperBound());\n-            case FieldInstruction i -> {\n-                switch (i.opcode()) {\n-                    case GETSTATIC ->\n-                        push(i.typeSymbol());\n-                    case GETFIELD ->\n-                        pop(1).push(i.typeSymbol());\n-                    case PUTSTATIC ->\n-                        pop(1);\n-                    case PUTFIELD ->\n-                        pop(2);\n-                }\n-            }\n-            case IncrementInstruction i -> { \/\/ Increment instruction maps to two segments\n-                loadLocal(i.slot());\n-                insMap.put(-elementIndex - 1, locals.get(i.slot())); \/\/ source segment is mapped with -elementIndex - 1 key\n-                storeLocal(i.slot(), CD_int);\n-                insMap.put(elementIndex, locals.get(i.slot())); \/\/ target segment is mapped with elementIndex key\n-                for (var ec : handlersStack) {\n-                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n-                }\n-            }\n-            case InvokeDynamicInstruction i ->\n-                pop(i.typeSymbol().parameterCount()).push(i.typeSymbol().returnType());\n-            case InvokeInstruction i ->\n-                pop(i.typeSymbol().parameterCount() + (i.opcode() == Opcode.INVOKESTATIC ? 0 : 1))\n-                        .push(i.typeSymbol().returnType());\n-            case LoadInstruction i -> {\n-                push(loadLocal(i.slot())); \/\/ Load instruction segment is mapped with elementIndex key\n-                insMap.put(elementIndex, locals.get(i.slot()));\n-            }\n-            case StoreInstruction i -> {\n-                storeLocal(i.slot(), pop());\n-                insMap.put(elementIndex, locals.get(i.slot()));  \/\/ Store instruction segment is mapped with elementIndex key\n-                for (var ec : handlersStack) {\n-                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n-                }\n-            }\n-            case MonitorInstruction _ ->\n-                pop(1);\n-            case NewMultiArrayInstruction i ->\n-                pop(i.dimensions()).push(i.arrayType().asSymbol());\n-            case NewObjectInstruction i ->\n-                push(i.className().asSymbol());\n-            case NewPrimitiveArrayInstruction i ->\n-                pop(1).push(i.typeKind().upperBound().arrayType());\n-            case NewReferenceArrayInstruction i ->\n-                pop(1).push(i.componentType().asSymbol().arrayType());\n-            case OperatorInstruction i ->\n-                pop(switch (i.opcode()) {\n-                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> 1;\n-                    default -> 2;\n-                }).push(i.typeKind().upperBound());\n-            case StackInstruction i -> {\n-                switch (i.opcode()) {\n-                    case POP -> pop(1);\n-                    case POP2 -> pop(doubleAt(-1) ? 1 : 2);\n-                    case DUP -> push(top());\n-                    case DUP2 -> {\n-                        if (doubleAt(-1)) {\n-                            push(top());\n-                        } else {\n-                            pushAt(-2, top2());\n-                        }\n-                    }\n-                    case DUP_X1 -> pushAt(-2, top());\n-                    case DUP_X2 -> pushAt(doubleAt(-2) ? -2 : -3, top());\n-                    case DUP2_X1 -> {\n-                        if (doubleAt(-1)) {\n-                            pushAt(-2, top());\n-                        } else {\n-                            pushAt(-3, top2());\n-                        }\n-                    }\n-                    case DUP2_X2 -> {\n-                        if (doubleAt(-1)) {\n-                            pushAt(doubleAt(-2) ? -2 : -3, top());\n-                        } else {\n-                            pushAt(doubleAt(-3) ? -3 : -4, top2());\n-                        }\n-                    }\n-                    case SWAP -> pushAt(-1, pop());\n-                }\n-            }\n-            case TypeCheckInstruction i ->\n-                pop(1).push(i.opcode() == Opcode.CHECKCAST ? i.type().asSymbol() : ConstantDescs.CD_int);\n-            case LabelTarget lt -> {\n-                var frame = stackMap.get(lt.label());\n-                if (frame != null) { \/\/ Here we reached a stack map frame, so we merge actual stack and locals into the frame\n-                    if (!stack.isEmpty() || !locals.isEmpty()) {\n-                        mergeToTargetFrame(lt.label());\n-                        endOfFlow();\n-                    }\n-                    \/\/ Stack and locals are then taken from the frame\n-                    stack.addAll(frame.stack());\n-                    locals.addAll(frame.locals());\n-                }\n-                for (ExceptionCatch ec : exceptionHandlers) {\n-                    if (lt.label() == ec.tryStart()) { \/\/ Entering a try block\n-                        handlersStack.add(ec);\n-                        mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n-                    }\n-                    if (lt.label() == ec.tryEnd()) { \/\/ Leaving a try block\n-                        handlersStack.remove(ec);\n-                    }\n-                }\n-            }\n-            case ReturnInstruction _ , ThrowInstruction _ -> {\n-                endOfFlow();\n-            }\n-            case TableSwitchInstruction tsi -> {\n-                pop();\n-                mergeToTargetFrame(tsi.defaultTarget());\n-                for (var c : tsi.cases()) {\n-                    mergeToTargetFrame(c.target());\n-                }\n-                endOfFlow();\n-            }\n-            case LookupSwitchInstruction lsi -> {\n-                pop();\n-                mergeToTargetFrame(lsi.defaultTarget());\n-                for (var c : lsi.cases()) {\n-                    mergeToTargetFrame(c.target());\n-                }\n-                endOfFlow();\n-            }\n-            default -> {}\n-        }\n-    }\n-\n-    private void endOfFlow() {\n-        stack.clear();\n-        locals.clear();\n-    }\n-\n-    \/**\n-     * Merge of the actual {@link #stack} and {@link #locals} to the target stack map frame\n-     * @param target label of the target stack map frame\n-     *\/\n-    private void mergeToTargetFrame(Label target) {\n-        Frame targetFrame = stackMap.get(target);\n-        \/\/ Merge stack\n-        assert stack.size() == targetFrame.stack.size();\n-        for (int i = 0; i < targetFrame.stack.size(); i++) {\n-            ClassDesc se = stack.get(i);\n-            ClassDesc fe = targetFrame.stack.get(i);\n-            if (!se.equals(fe)) {\n-                if (se.isPrimitive() && CD_int.equals(fe)) {\n-                    targetFrame.stack.set(i, se); \/\/ Override int target frame type with more specific int sub-type\n-                    this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n-                } else {\n-                    stack.set(i, fe); \/\/ Override stack type with target frame type\n-                }\n-            }\n-        }\n-        mergeLocalsToTargetFrame(targetFrame);\n-    }\n-\n-\n-    \/**\n-     * Merge of the actual {@link #locals} to the target stack map frame\n-     * @param targetFrame target stack map frame\n-     *\/\n-    private void mergeLocalsToTargetFrame(Frame targetFrame) {\n-        \/\/ Merge locals\n-        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n-        for (int i = 0; i < lSize; i++) {\n-            Segment le = locals.get(i);\n-            Segment fe = targetFrame.locals.get(i);\n-            if (le != null && fe != null) {\n-                le.link(fe); \/\/ Link target frame var with its source\n-                if (!le.type.equals(fe.type)) {\n-                    if (le.type.isPrimitive() && CD_int.equals(fe.type) ) {\n-                        fe.type = le.type; \/\/ Override int target frame type with more specific int sub-type\n-                        this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":0,"deletions":882,"binary":false,"changes":882,"status":"deleted"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.TypeKind;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+sealed abstract class SlotOp extends ExternalizableOp {\n+    public static final String ATTRIBUTE_SLOT = \"slot\";\n+\n+    public static SlotLoadOp load(int slot, TypeKind tk) {\n+        return new SlotLoadOp(slot, switch (tk) {\n+            case INT -> UnresolvedType.unresolvedInt();\n+            case REFERENCE -> UnresolvedType.unresolvedRef();\n+            case LONG -> JavaType.LONG;\n+            case DOUBLE -> JavaType.DOUBLE;\n+            case FLOAT -> JavaType.FLOAT;\n+            default -> throw new IllegalStateException(\"Unexpected load instruction type: \" + tk);\n+        });\n+    }\n+\n+    public static SlotStoreOp store(int slot, Value v) {\n+        return new SlotStoreOp(slot, v);\n+    }\n+\n+    final int slot;\n+\n+    protected SlotOp(SlotOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.slot = that.slot;\n+    }\n+\n+    protected SlotOp(String name, List<? extends Value> operands, int slot) {\n+        super(name, operands);\n+        this.slot = slot;\n+    }\n+\n+    protected SlotOp(ExternalizedOp def) {\n+        super(def);\n+\n+        this.slot = def.extractAttributeValue(ATTRIBUTE_SLOT, true,\n+                v -> switch (v) {\n+                    case String s -> Integer.parseInt(s);\n+                    case Integer i -> i;\n+                    default -> throw new UnsupportedOperationException(\"Unsupported slot value:\" + v);\n+                });\n+    }\n+\n+    public int slot() {\n+        return slot;\n+    }\n+\n+    public abstract TypeKind typeKind();\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        HashMap<String, Object> m = new HashMap<>(super.attributes());\n+        m.put(\"\", slot);\n+        return Collections.unmodifiableMap(m);\n+    }\n+\n+    @OpFactory.OpDeclaration(SlotLoadOp.NAME)\n+    public static final class SlotLoadOp extends SlotOp {\n+        public static final String NAME = \"slot.load\";\n+\n+        final TypeElement resultType;\n+\n+        public SlotLoadOp(ExternalizedOp opdef) {\n+            super(opdef);\n+\n+            if (opdef.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\");\n+            }\n+\n+            this.resultType = opdef.resultType();\n+        }\n+\n+        SlotLoadOp(SlotLoadOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public SlotLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SlotLoadOp(this, cc);\n+        }\n+\n+        SlotLoadOp(int slot, TypeElement resultType) {\n+            super(NAME, List.of(), slot);\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return toTypeKind(resultType);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"block_\" + parentBlock().index() + \" \" + parentBlock().ops().indexOf(this) + \": #\" + slot + \" LOAD \" + typeKind();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(SlotStoreOp.NAME)\n+    public static final class SlotStoreOp extends SlotOp {\n+        public static final String NAME = \"slot.store\";\n+\n+        public SlotStoreOp(ExternalizedOp opdef) {\n+            super(opdef);\n+\n+            if (opdef.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Operation must have two operands\");\n+            }\n+        }\n+\n+        SlotStoreOp(SlotStoreOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SlotStoreOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SlotStoreOp(this, cc);\n+        }\n+\n+        SlotStoreOp(int slot, Value v) {\n+            super(NAME, List.of(v), slot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return toTypeKind(operands().getFirst().type());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"block_\" + parentBlock().index() + \" \" + parentBlock().ops().indexOf(this) + \": #\" + slot + \" STORE \" + typeKind();\n+        }\n+    }\n+\n+    private static TypeKind toTypeKind(TypeElement type) {\n+        return switch (type) {\n+            case UnresolvedType.Int _ ->\n+                TypeKind.INT;\n+            case PrimitiveType pt ->\n+                TypeKind.from(pt.toNominalDescriptor()).asLoadable();\n+            default ->\n+                TypeKind.REFERENCE;\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotOp.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.TypeKind;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ *\n+ *\/\n+final class SlotToVarTransformer {\n+\n+    static final class Var {\n+        boolean single;\n+        TypeKind typeKind;\n+        Value value;\n+        Body parentBody;\n+    }\n+\n+    record ExcStackMap(List<Block> catchBlocks, Map<Block, BitSet> map) implements Function<Block, ExcStackMap> {\n+        @Override\n+        public ExcStackMap apply(Block b) {\n+            BitSet excStack = map.computeIfAbsent(b, _ -> new BitSet());\n+            switch (b.terminatingOp()) {\n+                case CoreOp.ExceptionRegionEnter ere -> {\n+                    BitSet entries = new BitSet();\n+                    for (Block.Reference cbr : ere.catchBlocks()) {\n+                        Block cb = cbr.targetBlock();\n+                        int i = catchBlocks.indexOf(cb);\n+                        if (i < 0) {\n+                            i = catchBlocks.size();\n+                            catchBlocks.add(cb);\n+                            map.put(cb, excStack);\n+                        }\n+                        entries.set(i);\n+                    }\n+                    entries.or(excStack);\n+                    map.put(ere.start().targetBlock(), entries);\n+                }\n+                case CoreOp.ExceptionRegionExit ere -> {\n+                    excStack = (BitSet) excStack.clone();\n+                    for (Block.Reference cbr : ere.catchBlocks()) {\n+                        excStack.clear(catchBlocks.indexOf(cbr.targetBlock()));\n+                    }\n+                    map.put(ere.end().targetBlock(), excStack);\n+                }\n+                case Op op -> {\n+                    for (Block.Reference tbr : op.successors()) {\n+                        map.put(tbr.targetBlock(), excStack);\n+                    }\n+                }\n+            }\n+            return this;\n+        }\n+\n+        void forEachHandler(Block b, Consumer<Block> hbc) {\n+            map.get(b).stream().mapToObj(catchBlocks::get).forEach(hbc);\n+        }\n+\n+        void forEachTryBlock(Block hb, Consumer<Block> bc) {\n+            int i = catchBlocks.indexOf(hb);\n+            if (i >= 0) {\n+                for (var me : map.entrySet()) {\n+                    if (me.getValue().get(i)) bc.accept(me.getKey());\n+                }\n+            }\n+        }\n+    }\n+\n+    static CoreOp.FuncOp transform(CoreOp.FuncOp func) {\n+        try {\n+            return new SlotToVarTransformer().convert(func);\n+        } catch (Throwable t) {\n+            System.out.println(func.toText());\n+            throw t;\n+        }\n+    }\n+\n+    private final Map<SlotOp, Var> varMap;\n+\n+    private SlotToVarTransformer() {\n+        varMap = new IdentityHashMap<>();\n+    }\n+\n+    private CoreOp.FuncOp convert(CoreOp.FuncOp func) {\n+        \/\/ Composing exception stack map to be able to follow slot ops from try to the handler\n+        ExcStackMap excMap = func.traverse(new ExcStackMap(new ArrayList<>(), new IdentityHashMap<>()),\n+                CodeElement.blockVisitor((map, b) -> map.apply(b)));\n+\n+        List<Var> toInitialize = func.body().traverse(new ArrayList<>(), CodeElement.opVisitor((toInit, op) -> {\n+            if (op instanceof SlotOp slotOp && !varMap.containsKey(slotOp)) {\n+\n+                \/\/ Assign variable to segments, calculate var slotType\n+                Var var = new Var(); \/\/ New variable\n+                var.parentBody = slotOp.ancestorBody();\n+                var q = new ArrayDeque<SlotOp>();\n+                var stores = new ArrayList<SlotOp.SlotStoreOp>();\n+                q.add(slotOp);\n+                while (!q.isEmpty()) {\n+                    SlotOp se = q.pop();\n+                    if (!varMap.containsKey(se)) {\n+                        varMap.put(se, var); \/\/ Assign variable to the segment\n+                        if (var.typeKind == null) var.typeKind = se.typeKind(); \/\/ TypeKind is identical for all SlotOps of the same variable\n+                        for (SlotOp to : slotImmediateSuccessors(se, excMap)) {\n+                            \/\/ All following SlotLoadOp belong to the same variable\n+                            if (to instanceof SlotOp.SlotLoadOp) {\n+                                if (!varMap.containsKey(to)) {\n+                                    q.add(to);\n+                                }\n+                            }\n+                        }\n+                        if (se instanceof SlotOp.SlotLoadOp) {\n+                            \/\/ Segments preceeding SlotLoadOp also belong to the same variable\n+                            for (SlotOp from : slotImmediatePredecessors(se, excMap)) {\n+                                if (!varMap.containsKey(from)) {\n+                                    q.add(from);\n+                                }\n+                            }\n+                        } else if (se instanceof SlotOp.SlotStoreOp store) {\n+                            stores.add(store); \/\/ Collection of all SlotStoreOps of the variable\n+                        }\n+                    }\n+                }\n+\n+                \/\/ Single-assigned variable has only one SlotStoreOp\n+                var.single = stores.size() < 2;\n+\n+                \/\/ Identification of initial SlotStoreOp\n+                for (var it = stores.iterator(); it.hasNext();) {\n+                    SlotOp s = it.next();\n+                    if (isDominatedByTheSameVar(s, excMap)) {\n+                        \/\/ A store preceeding dominantly with segments of the same variable is not initial\n+                        it.remove();\n+                    }\n+                }\n+\n+                \/\/ Remaining stores are all initial.\n+                if (stores.size() > 1) {\n+                    \/\/ A synthetic default-initialized dominant segment must be inserted to the variable, if there is more than one initial store segment.\n+                    \/\/ It is not necessary to link it with other variable segments, the analysys ends here.\n+                    toInit.add(varMap.get(stores.getFirst()));\n+                }\n+\n+\n+            }\n+            return toInit;\n+        }));\n+\n+        return func.transform((block, op) -> {\n+            if (!toInitialize.isEmpty()) {\n+                for (var it = toInitialize.iterator(); it.hasNext();) {\n+                    Var var = it.next();\n+                    if (var.parentBody == op.ancestorBody()) {\n+                        var.value = block.op(CoreOp.var(toTypeElement(var.typeKind)));\n+                        it.remove();\n+                    }\n+                }\n+            }\n+            CopyContext cc = block.context();\n+            switch (op) {\n+                case SlotOp.SlotLoadOp slo -> {\n+                    Var var = varMap.get(slo);\n+                    if (var.value == null) {\n+                        System.out.println(slo);\n+                        throw new AssertionError();\n+                    }\n+                    cc.mapValue(op.result(), var.single ? var.value : block.op(CoreOp.varLoad(var.value)));\n+                }\n+                case SlotOp.SlotStoreOp sso -> {\n+                    Var var = varMap.get(sso);\n+                    Value val = sso.operands().getFirst();\n+                    val = cc.getValueOrDefault(val, val);\n+                    if (var.single) {\n+                        var.value = val;\n+                    } else if (var.value == null) {\n+                        TypeElement varType = switch (val.type()) {\n+                            case UnresolvedType.Ref _ -> UnresolvedType.unresolvedRef();\n+                            case UnresolvedType.Int _ -> UnresolvedType.unresolvedInt();\n+                            default -> val.type();\n+                        };\n+                        var.value = block.op(CoreOp.var(null, varType, val));\n+                    } else {\n+                        block.op(CoreOp.varStore(var.value, val));\n+                    }\n+                }\n+                default ->\n+                    block.op(op);\n+            }\n+            return block;\n+        });\n+    }\n+\n+    private static TypeElement toTypeElement(TypeKind tk) {\n+        return switch (tk) {\n+            case INT -> UnresolvedType.unresolvedInt();\n+            case REFERENCE -> UnresolvedType.unresolvedRef();\n+            case LONG -> JavaType.LONG;\n+            case DOUBLE -> JavaType.DOUBLE;\n+            case FLOAT -> JavaType.FLOAT;\n+            case BOOLEAN -> JavaType.BOOLEAN;\n+            case BYTE -> JavaType.BYTE;\n+            case SHORT -> JavaType.SHORT;\n+            case CHAR -> JavaType.CHAR;\n+            case VOID -> throw new IllegalStateException(\"Unexpected void type.\");\n+        };\n+    }\n+\n+    \/\/ Traverse immediate same-slot successors of a SlotOp\n+    private static Iterable<SlotOp> slotImmediateSuccessors(SlotOp slotOp, ExcStackMap excMap) {\n+        return () -> new SlotOpIterator(slotOp, excMap, true);\n+    }\n+\n+    \/\/ Traverse immediate same-slot predecessors of a SlotOp\n+    private static Iterable<SlotOp> slotImmediatePredecessors(SlotOp slotOp, ExcStackMap excMap) {\n+        return () -> new SlotOpIterator(slotOp, excMap, false);\n+    }\n+\n+    private boolean isDominatedByTheSameVar(SlotOp slotOp, ExcStackMap excMap) {\n+        Var var = varMap.get(slotOp);\n+        Set<Op.Result> predecessors = new HashSet<>();\n+        for (SlotOp pred : slotImmediatePredecessors(slotOp, excMap)) {\n+            if (varMap.get(pred) != var) {\n+                return false;\n+            }\n+            if (pred != slotOp) predecessors.add(pred.result());\n+        }\n+        return BytecodeUtil.isDominatedBy(slotOp.result(), predecessors);\n+    }\n+\n+    static final class SlotOpIterator implements Iterator<SlotOp> {\n+\n+        SlotOp op;\n+        final int slot;\n+        final ExcStackMap map;\n+        final TypeKind tk;\n+        final boolean fwd;\n+        Block b;\n+        List<Op> ops;\n+        int i;\n+        BitSet visited;\n+        ArrayDeque<Block> toVisit;\n+\n+\n+        public SlotOpIterator(SlotOp slotOp, ExcStackMap excMap, boolean forward) {\n+            slot = slotOp.slot;\n+            tk = slotOp.typeKind();\n+            map = excMap;\n+            fwd = forward;\n+            b = slotOp.parentBlock();\n+            ops = fwd ? b.ops() : b.ops().reversed();\n+            i = ops.indexOf(slotOp) + 1;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            while (hasNextSlot()) {\n+                \/\/ filter loads and stores of the same TypeKind (if known)\n+                if (op.typeKind() == tk || op.typeKind() == null || tk == null) {\n+                    return true;\n+                }\n+                op = null;\n+            }\n+            return false;\n+        }\n+\n+        private boolean hasNextSlot() {\n+            if (op != null) {\n+                return true;\n+            } else {\n+                while (b != null || toVisit != null && !toVisit.isEmpty()) {\n+                    if (b == null) {\n+                        b = toVisit.pop();\n+                        ops = fwd ? b.ops() : b.ops().reversed();\n+                        i = 0;\n+                    }\n+                    while (i < ops.size()) {\n+                        if (ops.get(i++) instanceof SlotOp sop && sop.slot == slot) {\n+                            op = sop;\n+                            b = null;\n+                            return true;\n+                        }\n+                    }\n+                    if (toVisit == null) {\n+                        toVisit = new ArrayDeque<>();\n+                        visited = new BitSet();\n+                    }\n+                    if (fwd) {\n+                        for (Block.Reference sr : b.successors()) {\n+                            Block sb = sr.targetBlock();\n+                            if (!visited.get(sb.index())) {\n+                                toVisit.add(sb);\n+                                visited.set(sb.index());\n+                            }\n+                        }\n+                        \/\/ Visit also relevant exception handlers\n+                        map.forEachHandler(b, sb -> {\n+                            if (!visited.get(sb.index())) {\n+                                toVisit.add(sb);\n+                                visited.set(sb.index());\n+                            }\n+                        });\n+                    } else {\n+                        for (Block pb : b.predecessors()) {\n+                            if (!visited.get(pb.index())) {\n+                                toVisit.add(pb);\n+                                visited.set(pb.index());\n+                            }\n+                        }\n+                        \/\/ Visit also relevant try blocks from handler\n+                        map.forEachTryBlock(b, sb -> {\n+                            if (!visited.get(sb.index())) {\n+                                toVisit.add(sb);\n+                                visited.set(sb.index());\n+                            }\n+                        });\n+                    }\n+                    b = null;\n+                }\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public SlotOp next() {\n+            if (!hasNext()) throw new NoSuchElementException();\n+            SlotOp ret = op;\n+            op = null;\n+            return ret;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/SlotToVarTransformer.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+\n+sealed interface UnresolvedType extends TypeElement {\n+\n+    static Ref unresolvedRef() {\n+        return new Ref();\n+    }\n+\n+    static Int unresolvedInt() {\n+        return new Int();\n+    }\n+\n+    static final class Ref implements UnresolvedType {\n+        private static final TypeElement.ExternalizedTypeElement UNRESOLVED_REF = new TypeElement.ExternalizedTypeElement(\"?REF\", List.of());\n+\n+        @Override\n+        public TypeElement.ExternalizedTypeElement externalize() {\n+            return UNRESOLVED_REF;\n+        }\n+    }\n+\n+    static final class Int implements  UnresolvedType {\n+        private static final TypeElement.ExternalizedTypeElement UNRESOLVED_INT = new TypeElement.ExternalizedTypeElement(\"?INT\", List.of());\n+\n+        @Override\n+        public TypeElement.ExternalizedTypeElement externalize() {\n+            return UNRESOLVED_INT;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedType.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Resolves unresolved types.\n+ *\/\n+final class UnresolvedTypesTransformer {\n+\n+    static CoreOp.FuncOp transform(CoreOp.FuncOp func) {\n+        try {\n+            return new UnresolvedTypesTransformer().resolve(func);\n+        } catch (Throwable t) {\n+            System.out.println(func.toText());\n+            throw t;\n+        }\n+    }\n+\n+    private final Map<UnresolvedType, JavaType> resolvedMap;\n+\n+    private UnresolvedTypesTransformer() {\n+        resolvedMap = new IdentityHashMap<>();\n+    }\n+\n+    private CoreOp.FuncOp resolve(CoreOp.FuncOp func) {\n+        ArrayList<Value> unresolved = func.traverse(new ArrayList<>(), (q, e) -> {\n+            switch (e) {\n+                case Block b -> b.parameters().forEach(v -> {\n+                   if (toResolve(v) != null) q.add(v);\n+                });\n+                case Op op when toResolve(op.result()) != null ->\n+                   q.add(op.result());\n+                default -> {}\n+           }\n+           return q;\n+        });\n+\n+        boolean changed = true;\n+        while (changed) {\n+            changed = false;\n+            for (Value v : unresolved) {\n+                changed |= resolve(v);\n+            }\n+        }\n+\n+        \/\/ Remaining types are resolved to defaults\n+        for (Value v : unresolved) {\n+            resolvedMap.computeIfAbsent(toResolve(v), ut ->\n+                switch (ut) {\n+                    case UnresolvedType.Int _ -> JavaType.INT;\n+                    case UnresolvedType.Ref _ -> JavaType.J_L_OBJECT;\n+                });\n+        }\n+\n+        return func.transform(blockParamTypesTransformer())\n+                   .transform(opTypesTransformer())\n+                   .transform(unifyOperandsTransformer());\n+    }\n+\n+    private static UnresolvedType toResolve(Value v) {\n+        return v == null ? null : switch (v.type()) {\n+            case UnresolvedType ut -> ut;\n+            case VarType vt when vt.valueType() instanceof UnresolvedType ut  -> ut;\n+            default -> null;\n+        };\n+    }\n+\n+    private TypeElement toComponent(TypeElement te) {\n+        if (te instanceof UnresolvedType ut) {\n+            te = resolvedMap.get(ut);\n+        }\n+        return te instanceof ArrayType at ? at.componentType() : null;\n+    }\n+\n+    private TypeElement toArray(TypeElement te) {\n+        if (te instanceof UnresolvedType ut) {\n+            te = resolvedMap.get(ut);\n+        }\n+        return te instanceof JavaType jt ? JavaType.array(jt) : null;\n+    }\n+\n+    private boolean resolve(Value v) {\n+        UnresolvedType ut = toResolve(v);\n+        if (ut == null) return false;\n+        boolean changed = false;\n+        for (Op.Result useRes : v.uses()) {\n+            Op op = useRes.op();\n+            int i = op.operands().indexOf(v);\n+            if (i >= 0) {\n+                changed |= switch (op) {\n+                    case CoreOp.LshlOp _, CoreOp.LshrOp _, CoreOp.AshrOp _ ->\n+                        i == 0 && resolveTo(ut, op.resultType());\n+                    case CoreOp.BinaryOp bo ->\n+                        resolveTo(ut, bo.resultType());\n+                    case CoreOp.InvokeOp io -> {\n+                        MethodRef id = io.invokeDescriptor();\n+                        if (io.hasReceiver()) {\n+                            if (i == 0) yield resolveTo(ut, id.refType());\n+                            i--;\n+                        }\n+                        yield resolveTo(ut, id.type().parameterTypes().get(i));\n+                    }\n+                    case CoreOp.FieldAccessOp fao ->\n+                        resolveTo(ut, fao.fieldDescriptor().refType());\n+                    case CoreOp.ReturnOp ro ->\n+                        resolveTo(ut, ro.ancestorBody().bodyType().returnType());\n+                    case CoreOp.VarOp vo ->\n+                        resolveTo(ut, vo.varValueType());\n+                    case CoreOp.VarAccessOp.VarStoreOp vso ->\n+                        resolveTo(ut, vso.varType().valueType());\n+                    case CoreOp.NewOp no ->\n+                        resolveTo(ut, no.constructorType().parameterTypes().get(i));\n+                    case CoreOp.ArrayAccessOp.ArrayLoadOp alo ->\n+                        resolveTo(ut, toArray(alo.resultType()));\n+                    case CoreOp.ArrayAccessOp.ArrayStoreOp aso ->\n+                        switch (i) {\n+                            case 0 -> resolveFrom(ut, toArray(aso.operands().get(2).type()));\n+                            case 2 -> resolveTo(ut, toComponent(aso.operands().get(0).type()));\n+                            default -> false;\n+                        };\n+                    default -> false;\n+                };\n+            }\n+            \/\/ Pull block parameter type when used as block argument\n+            for (Block.Reference sucRef : useRes.op().successors()) {\n+                i = sucRef.arguments().indexOf(v);\n+                if (i >= 0) {\n+                    changed |= resolveTo(ut, sucRef.targetBlock().parameters().get(i).type());\n+                }\n+            }\n+        }\n+        if (v instanceof Block.Parameter bp) {\n+            int bi = bp.index();\n+            Block b = bp.declaringBlock();\n+            for (Block pb : b.predecessors()) {\n+                for (Block.Reference r : pb.successors()) {\n+                    if (r.targetBlock() == b) {\n+                        var args = r.arguments();\n+                        if (args.size() > bi && resolveFrom(ut, args.get(bi).type())) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (v instanceof Op.Result or) {\n+            changed |= switch (or.op()) {\n+                case CoreOp.UnaryOp uo ->\n+                    resolveFrom(ut, uo.operands().getFirst().type());\n+                case CoreOp.BinaryOp bo ->\n+                    resolveFrom(ut, bo.operands().getFirst().type())\n+                    || resolveFrom(ut, bo.operands().get(1).type());\n+                case CoreOp.VarAccessOp.VarLoadOp vlo ->\n+                    resolveFrom(ut, vlo.varType().valueType());\n+                case CoreOp.VarOp vo ->\n+                    resolveVarOpType(ut, vo);\n+                case CoreOp.ArrayAccessOp.ArrayLoadOp alo ->\n+                    resolveFrom(ut, toComponent(alo.operands().getFirst().type()));\n+                default -> false;\n+            };\n+        }\n+        return changed;\n+    }\n+\n+    private boolean resolveFrom(UnresolvedType unresolved, TypeElement from) {\n+        TypeElement type = from instanceof UnresolvedType utt ? resolvedMap.get(utt) : from;\n+        JavaType resolved = resolvedMap.get(unresolved);\n+        return switch (unresolved) {\n+            \/\/ Only care about arrays\n+            case UnresolvedType.Ref _ when (resolved == null || resolved.equals(JavaType.J_L_OBJECT)) && type instanceof ArrayType at -> {\n+                resolvedMap.put(unresolved, at);\n+                yield true;\n+            }\n+            \/\/ Only care about booleans\n+            case UnresolvedType.Int _ when JavaType.BOOLEAN.equals(type) && !JavaType.BOOLEAN.equals(resolved) -> {\n+                resolvedMap.put(unresolved, JavaType.BOOLEAN);\n+                yield true;\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private static final List<PrimitiveType> INT_TYPES = List.of(JavaType.INT, JavaType.CHAR, JavaType.SHORT, JavaType.BYTE, JavaType.BOOLEAN);\n+\n+    private boolean resolveTo(UnresolvedType unresolved, TypeElement to) {\n+        TypeElement type = to instanceof UnresolvedType utt ? resolvedMap.get(utt) : to;\n+        JavaType resolved = resolvedMap.get(unresolved);\n+        return switch (unresolved) {\n+            case UnresolvedType.Ref _ when (resolved == null || resolved.equals(JavaType.J_L_OBJECT)) && type instanceof JavaType jt && !jt.equals(resolved) -> {\n+                resolvedMap.put(unresolved, jt);\n+                yield true;\n+            }\n+            case UnresolvedType.Int _ when type instanceof PrimitiveType pt && (INT_TYPES.indexOf(pt) > (resolved == null ? -1 : INT_TYPES.indexOf(resolved))) -> {\n+                resolvedMap.put(unresolved, pt);\n+                yield true;\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean resolveVarOpType(UnresolvedType ut, CoreOp.VarOp vo) {\n+        boolean changed = vo.isUninitialized() ? false : resolveFrom(ut, vo.initOperand().type());\n+        for (Op.Result varUses : vo.result().uses()) {\n+            changed |= switch (varUses.op()) {\n+                case CoreOp.VarAccessOp.VarLoadOp vlo ->\n+                    resolveTo(ut, vlo.resultType());\n+                case CoreOp.VarAccessOp.VarStoreOp vso ->\n+                    resolveFrom(ut, vso.storeOperand().type());\n+                default -> false;\n+            };\n+        }\n+        return changed;\n+    }\n+\n+    private Object convertValue(UnresolvedType ut, Object value) {\n+        return switch (INT_TYPES.indexOf(resolvedMap.get(ut))) {\n+            case 0 -> toNumber(value).intValue();\n+            case 1 -> (char)toNumber(value).intValue();\n+            case 2 -> toNumber(value).shortValue();\n+            case 3 -> toNumber(value).byteValue();\n+            case 4 -> value instanceof Number n ? n.intValue() != 0 : (Boolean)value;\n+            default -> value;\n+        };\n+    }\n+\n+    private static Number toNumber(Object value) {\n+        return switch (value) {\n+            case Boolean b -> b ? 1 : 0;\n+            case Character c -> (int)c;\n+            case Number n -> n;\n+            default -> throw new IllegalStateException(\"Unexpected \" + value);\n+        };\n+    }\n+\n+    private OpTransformer blockParamTypesTransformer() {\n+        return new OpTransformer() {\n+            @Override\n+            public void apply(Block.Builder block, Block b) {\n+                if (block.isEntryBlock()) {\n+                    CopyContext cc = block.context();\n+                    List<Block> sourceBlocks = b.parentBody().blocks();\n+\n+                    \/\/ Override blocks with changed parameter types\n+                    for (int i = 1; i < sourceBlocks.size(); i++) {\n+                        Block sourceBlock = sourceBlocks.get(i);\n+                        List<TypeElement> paramTypes = sourceBlock.parameterTypes();\n+                        if (paramTypes.stream().anyMatch(UnresolvedType.class::isInstance)) {\n+                            Block.Builder newBlock = block.block(paramTypes.stream()\n+                                    .map(pt -> pt instanceof UnresolvedType ut  ? resolvedMap.get(ut) : pt)\n+                                    .toList());\n+                            cc.mapBlock(sourceBlock, newBlock);\n+                            cc.mapValues(sourceBlock.parameters(), newBlock.parameters());\n+                        }\n+                    }\n+\n+                }\n+                OpTransformer.super.apply(block, b);\n+            }\n+\n+            @Override\n+            public Block.Builder apply(Block.Builder block, Op op) {\n+                block.op(op);\n+                return block;\n+            }\n+        };\n+    }\n+\n+    private OpTransformer opTypesTransformer() {\n+        return (block, op) -> {\n+            CopyContext cc = block.context();\n+            switch (op) {\n+                case CoreOp.ConstantOp cop when op.resultType() instanceof UnresolvedType ut ->\n+                    cc.mapValue(op.result(), block.op(CoreOp.constant(resolvedMap.get(ut), convertValue(ut, cop.value()))));\n+                case CoreOp.VarOp vop when vop.varValueType() instanceof UnresolvedType ut ->\n+                    cc.mapValue(op.result(), block.op(vop.isUninitialized()\n+                            ? CoreOp.var(vop.varName(), resolvedMap.get(ut))\n+                            : CoreOp.var(vop.varName(), resolvedMap.get(ut), cc.getValueOrDefault(vop.initOperand(), vop.initOperand()))));\n+                case CoreOp.ArrayAccessOp.ArrayLoadOp alop when op.resultType() instanceof UnresolvedType -> {\n+                    List<Value> opers = alop.operands();\n+                    Value array = opers.getFirst();\n+                    Value index = opers.getLast();\n+                    cc.mapValue(op.result(), block.op(CoreOp.arrayLoadOp(cc.getValueOrDefault(array, array), cc.getValueOrDefault(index, index))));\n+                }\n+                default ->\n+                    block.op(op);\n+            }\n+            return block;\n+        };\n+    }\n+\n+    private static OpTransformer unifyOperandsTransformer() {\n+        return (block, op) -> {\n+            switch (op) {\n+                case CoreOp.BinaryTestOp _ ->\n+                    unify(block, op, JavaType.INT, JavaType.INT);\n+                case CoreOp.LshlOp _, CoreOp.LshrOp _, CoreOp.AshrOp _ ->\n+                    unify(block, op, op.resultType(), JavaType.INT);\n+                case CoreOp.BinaryOp _ ->\n+                    unify(block, op, op.resultType(), op.resultType());\n+                default ->\n+                    block.op(op);\n+            }\n+            return block;\n+        };\n+    }\n+\n+    private static void unify(Block.Builder block, Op op, TypeElement firstType, TypeElement secondType) {\n+        List<Value> operands = op.operands();\n+        CopyContext cc = CopyContext.create(block.context());\n+        Value first = operands.getFirst();\n+        boolean changed = false;\n+        if (first.type() instanceof PrimitiveType && !first.type().equals(firstType)) {\n+            cc.mapValue(first, block.op(CoreOp.conv(firstType, cc.getValueOrDefault(first, first))));\n+            changed = true;\n+        }\n+        Value second = operands.get(1);\n+        if (second.type() instanceof PrimitiveType && !second.type().equals(secondType)) {\n+            cc.mapValue(second, block.op(CoreOp.conv(secondType, cc.getValueOrDefault(second, second))));\n+            changed = true;\n+        }\n+        if (changed) {\n+            block.context().mapValue(op.result(), block.op(op.copy(cc)));\n+        } else {\n+            block.op(op);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -551,1 +551,1 @@\n-            MethodHandle mh = opHandle(o.opName(), o.opType());\n+            MethodHandle mh = opHandle(l, o.opName(), o.opType());\n@@ -555,1 +555,1 @@\n-            MethodHandle mh = opHandle(o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+            MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -618,2 +618,2 @@\n-    static MethodHandle opHandle(String opName, FunctionType ft) {\n-        MethodType mt = resolveToMethodType(MethodHandles.lookup(), ft).erase();\n+    static MethodHandle opHandle(MethodHandles.Lookup l, String opName, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(l, ft).erase();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -200,0 +200,24 @@\n+    public static boolean eq(byte l, byte r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(byte l, byte r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(byte l, byte r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(byte l, byte r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(byte l, byte r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(byte l, byte r) {\n+        return l <= r;\n+    }\n+\n@@ -262,2 +286,22 @@\n-    public static boolean eq(short a, short b) {\n-        return a == b;\n+    public static boolean eq(short l, short r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(short l, short r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(short l, short r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(short l, short r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(short l, short r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(short l, short r) {\n+        return l <= r;\n@@ -332,0 +376,19 @@\n+    public static boolean neq(char l, char r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(char l, char r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(char l, char r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(char l, char r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(char l, char r) {\n+        return l <= r;\n+    }\n@@ -502,0 +565,23 @@\n+    public static boolean eq(double l, double r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(double l, double r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(double l, double r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(double l, double r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(double l, double r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(double l, double r) {\n+        return l <= r;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":88,"deletions":2,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.interpreter;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class Verifier {\n+\n+    public final class VerifyError {\n+\n+        private final String message;\n+\n+        public VerifyError(String message) {\n+            this.message = message;\n+        }\n+\n+        public String getMessage() {\n+            return message;\n+        }\n+\n+        public String getPrintedContext() {\n+            return toText(rootOp);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getMessage() + \" in \" + getPrintedContext();\n+        }\n+    }\n+\n+    public static List<Verifier.VerifyError> verify(Op op) {\n+        return verify(MethodHandles.publicLookup(), op);\n+    }\n+\n+    public static List<Verifier.VerifyError> verify(MethodHandles.Lookup l, Op op) {\n+        var verifier = new Verifier(l, op);\n+        verifier.verifyOps();\n+        verifier.verifyExceptionRegions();\n+        return verifier.errors == null ? List.of() : Collections.unmodifiableList(verifier.errors);\n+    }\n+\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final Op rootOp;\n+    private OpWriter.CodeItemNamerOption namerOption;\n+    private List<Verifier.VerifyError> errors;\n+\n+    private Verifier(MethodHandles.Lookup lookup, Op rootOp) {\n+        this.lookup = lookup;\n+        this.rootOp = rootOp;\n+    }\n+\n+    private OpWriter.CodeItemNamerOption getNamer() {\n+        if (namerOption == null) {\n+            namerOption = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(rootOp));\n+        }\n+        return namerOption;\n+    }\n+\n+    private String toText(Op op) {\n+        return OpWriter.toText(op, getNamer());\n+    }\n+\n+    private String getName(CodeItem codeItem) {\n+        return getNamer().namer().apply(codeItem);\n+    }\n+\n+    private void error(String message, Object... args) {\n+        if (errors == null) {\n+            errors = new ArrayList<>();\n+        }\n+        for (int i = 0; i < args.length; i++) {\n+            args[i] = toText(args[i]);\n+        }\n+        errors.add(new VerifyError(message.formatted(args)));\n+    }\n+\n+    private String toText(Object arg) {\n+        return switch (arg) {\n+            case Op op -> toText(op);\n+            case Block b -> getName(b);\n+            case Value v -> getName(v);\n+            case List<?> l -> l.stream().map(this::toText).toList().toString();\n+            default -> arg.toString();\n+        };\n+    }\n+\n+    private void verifyOps() {\n+        rootOp.traverse(null, CodeElement.opVisitor((_, op) -> {\n+            \/\/ Verify operands declaration dominannce\n+            for (var v : op.operands()) {\n+                if (!op.result().isDominatedBy(v)) {\n+                    error(\"%s %s operand %s is not dominated by its declaration in %s\", op.parentBlock(), op, v, v.declaringBlock());\n+                }\n+            }\n+\n+            \/\/ Verify individual Ops\n+            switch (op) {\n+                case CoreOp.BranchOp br ->\n+                    verifyBlockReferences(op, br.successors());\n+                case CoreOp.ConditionalBranchOp cbr ->\n+                    verifyBlockReferences(op, cbr.successors());\n+                case CoreOp.ArithmeticOperation _, CoreOp.TestOperation _ ->\n+                    verifyOpHandleExists(op, op.opName());\n+                case CoreOp.ConvOp _ -> {\n+                    verifyOpHandleExists(op, op.opName() + \"_\" + op.opType().returnType());\n+                }\n+                default -> {}\n+\n+            }\n+            return null;\n+        }));\n+    }\n+\n+    private void verifyBlockReferences(Op op, List<Block.Reference> references) {\n+        for (Block.Reference r : references) {\n+            Block b = r.targetBlock();\n+            List<Value> args = r.arguments();\n+            List<Block.Parameter> params = r.targetBlock().parameters();\n+            if (args.size() != params.size()) {\n+                error(\"%s %s block reference arguments size to target block parameters size mismatch\", b, op);\n+            } else {\n+                Block tb = r.targetBlock();\n+                for (int i = 0; i < args.size(); i++) {\n+                    if (!isAssignable(params.get(i).type(), args.get(i), tb, b)) {\n+                        error(\"%s %s %s is not assignable from %s\", op.parentBlock(), op, params.get(i).type(), args.get(i).type());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean isAssignable(TypeElement toType, Value fromValue,  Object toContext, Object fromContext) {\n+        if (toType.equals(fromValue.type())) return true;\n+        var to = resolveToClass(toType, toContext);\n+        var from = resolveToClass(fromValue.type(), fromContext);\n+        if (from.isPrimitive()) {\n+            \/\/ Primitive types assignability\n+            return to == int.class && (from == byte.class || from == short.class || from == char.class);\n+        } else {\n+            \/\/ Objects assignability\n+            return to.isAssignableFrom(from);\n+        }\n+    }\n+\n+    public Class<?> resolveToClass(TypeElement d, Object context) {\n+        try {\n+            if (d instanceof JavaType jt) {\n+                return (Class<?>)jt.erasure().resolve(lookup);\n+            } else {\n+                error(\"%s %s is not a Java type\", context, d);\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            error(\"%s %s\", context, e.getMessage());\n+        }\n+        return Object.class;\n+    }\n+\n+    private void verifyOpHandleExists(Op op, String opName) {\n+        try {\n+            var mt = Interpreter.resolveToMethodType(lookup, op.opType()).erase();\n+            MethodHandles.lookup().findStatic(InvokableLeafOps.class, opName, mt);\n+        } catch (NoSuchMethodException nsme) {\n+            error(\"%s %s of type %s is not supported\", op.parentBlock(), op, op.opType());\n+        } catch (IllegalAccessException iae) {\n+            error(\"%s %s %s\",  op.parentBlock(), op, iae.getMessage());\n+        }\n+    }\n+\n+    private void verifyExceptionRegions() {\n+        rootOp.traverse(new HashMap<Block, List<Block>>(), CodeElement.blockVisitor((map, b) -> {\n+            List<Block> catchBlocks = map.computeIfAbsent(b, _ -> List.of());\n+            switch (b.terminatingOp()) {\n+                case CoreOp.BranchOp br ->\n+                    verifyCatchStack(b, br, br.branch(), catchBlocks, map);\n+                case CoreOp.ConditionalBranchOp cbr -> {\n+                    verifyCatchStack(b, cbr, cbr.trueBranch(), catchBlocks, map);\n+                    verifyCatchStack(b, cbr, cbr.falseBranch(), catchBlocks, map);\n+                }\n+                case CoreOp.ExceptionRegionEnter ere -> {\n+                    List<Block> newCatchBlocks = new ArrayList<>();\n+                    newCatchBlocks.addAll(catchBlocks);\n+                    for (Block.Reference cb : ere.catchBlocks()) {\n+                        newCatchBlocks.add(cb.targetBlock());\n+                        verifyCatchStack(b, ere, cb, catchBlocks, map);\n+                    }\n+                    verifyCatchStack(b, ere, ere.start(), newCatchBlocks, map);\n+                }\n+                case CoreOp.ExceptionRegionExit ere -> {\n+                    List<Block> exitedCatchBlocks = ere.catchBlocks().stream().map(Block.Reference::targetBlock).toList();\n+                    if (exitedCatchBlocks.size() > catchBlocks.size() || !catchBlocks.reversed().subList(0, exitedCatchBlocks.size()).equals(exitedCatchBlocks)) {\n+                        error(\"%s %s exited catch blocks %s does not match actual stack %s\", b, ere, exitedCatchBlocks, catchBlocks);\n+                    } else {\n+                        verifyCatchStack(b, ere, ere.end(), catchBlocks.subList(0, catchBlocks.size() - exitedCatchBlocks.size()), map);\n+                    }\n+                }\n+                default -> {}\n+            }\n+            return map;\n+        }));\n+    }\n+\n+    private void verifyCatchStack(Block b, Op op, Block.Reference target, List<Block> catchBlocks, Map<Block, List<Block>> blockMap) {\n+        blockMap.compute(target.targetBlock(), (tb, stored) -> {\n+            if (stored != null && !stored.equals(catchBlocks)) {\n+                error(\"%s %s catch stack mismatch at target %s %s vs %s\", b, op, tb, stored, catchBlocks);\n+            }\n+            return catchBlocks;\n+        });\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Verifier.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -1919,14 +1919,0 @@\n-        static TypeElement resultType(Value array, Value v) {\n-            if (!(array.type() instanceof ArrayType arrayType)) {\n-                throw new IllegalArgumentException(\"Type is not an array type: \" + array.type());\n-            }\n-\n-            \/\/ @@@ restrict to indexes of int?\n-            TypeElement componentType = arrayType.componentType();\n-            if (v == null) {\n-                return componentType;\n-            } else {\n-                return JavaType.VOID;\n-            }\n-        }\n-\n@@ -1941,0 +1927,1 @@\n+            final TypeElement componentType;\n@@ -1944,0 +1931,1 @@\n+                this.componentType = def.resultType();\n@@ -1948,0 +1936,1 @@\n+                this.componentType = that.componentType;\n@@ -1956,0 +1945,4 @@\n+                this(array, index, ((ArrayType)array.type()).componentType());\n+            }\n+\n+            ArrayLoadOp(Value array, Value index, TypeElement componentType) {\n@@ -1957,0 +1950,1 @@\n+                this.componentType = componentType;\n@@ -1961,3 +1955,1 @@\n-                Value array = operands().get(0);\n-                ArrayType t = (ArrayType) array.type();\n-                return t.componentType();\n+                return componentType;\n@@ -3989,0 +3981,12 @@\n+    \/**\n+     * Creates an array load operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @param componentType type of the array component\n+     * @return the array load operation\n+     *\/\n+    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index, TypeElement componentType) {\n+        return new ArrayAccessOp.ArrayLoadOp(array, index, componentType);\n+    }\n+\n@@ -4043,1 +4047,1 @@\n-        return var(null, type, null);\n+        return var(null, type);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n@@ -44,0 +43,1 @@\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.Value;\n@@ -38,0 +36,1 @@\n+import java.lang.reflect.code.interpreter.Verifier;\n@@ -39,1 +38,0 @@\n-import java.lang.reflect.code.writer.OpWriter;\n@@ -103,2 +101,2 @@\n-        \/\/ Roundtrip is >99% stable, no exceptions, no verification errors\n-        Assert.assertTrue(stable > 54140 && unstable < 100, String.format(\"stable: %d unstable: %d\", stable, unstable));\n+        \/\/ Roundtrip is 100% stable after 3 rounds, no exceptions, no verification errors\n+        Assert.assertTrue(stable > 54500 && unstable == 0, String.format(\"stable: %d unstable: %d\", stable, unstable));\n@@ -136,0 +134,1 @@\n+                        if (prevReflection != null) printInColumns(prevReflection, reflection);\n@@ -137,1 +136,0 @@\n-                        printInColumns(prevReflection, reflection);\n@@ -156,14 +154,8 @@\n-        reflection.traverse(null, CodeElement.opVisitor((n, op) -> {\n-            for (Value v : op.operands()) {\n-                \/\/ Verify operands dominance\n-                if (!op.result().isDominatedBy(v)) {\n-                    printBytecode();\n-                    var naming = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(reflection));\n-                    System.out.println(OpWriter.toText(reflection, naming));\n-                    System.out.println(\"Reflection verification failed\");\n-                    throw new AssertionError(\"block_%d %s is not dominated by its operand declaration in block_%d\".formatted(\n-                            op.parentBlock().index(), OpWriter.toText(op, naming), v.declaringBlock().index()));\n-                }\n-            }\n-            return null;\n-        }));\n+        var errors = Verifier.verify(TRUSTED_LOOKUP, reflection);\n+        if (!errors.isEmpty()) {\n+            printBytecode();\n+            System.out.println(\"Code reflection model verification failed:\");\n+            errors.forEach(e -> System.out.println(e.getMessage()));\n+            System.out.println(errors.getFirst().getPrintedContext());\n+            throw new AssertionError(\"Code reflection model verification failed\");\n+        }\n@@ -173,7 +165,8 @@\n-        for (var e : ClassFile.of().verify(bytecode.parent().get())) {\n-            if (!e.getMessage().contains(\"Illegal call to internal method\")) {\n-                printReflection();\n-                printBytecode();\n-                System.out.println(\"Bytecode verification failed\");\n-                throw new AssertionError(e.getMessage());\n-            }\n+        var errors = ClassFile.of().verify(bytecode.parent().get()).stream()\n+                .filter(e -> !e.getMessage().contains(\"Illegal call to internal method\")).toList();\n+        if (!errors.isEmpty()) {\n+            printReflection();\n+            System.out.println(\"Bytecode verification failed:\");\n+            errors.forEach(e -> System.out.println(e.getMessage()));\n+            printBytecode();\n+            throw new AssertionError(\"Bytecode verification failed\");\n@@ -216,0 +209,2 @@\n+        } catch (UnsupportedOperationException uoe) {\n+            throw uoe;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"}]}