{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.reflect.code.type.ArrayType;\n-import java.lang.reflect.code.type.JavaType;\n@@ -43,8 +41,0 @@\n-    \/\/ @@@ unresolvedByteOrBoolean()\n-\n-    \/\/ @@@ move all resolution code to UnresolvedTypesTransformer\n-    JavaType resolved();\n-\n-    boolean resolveTo(TypeElement type);\n-    boolean resolveFrom(TypeElement type);\n-\n@@ -54,2 +44,0 @@\n-        private JavaType resolved;\n-\n@@ -60,34 +48,0 @@\n-\n-        @Override\n-        public boolean resolveTo(TypeElement type) {\n-            if (resolved == null || resolved.equals(JavaType.J_L_OBJECT)) {\n-                if (type instanceof UnresolvedType utt) {\n-                    type = utt.resolved();\n-                }\n-                if (type != null && !type.equals(resolved)) {\n-                    resolved = (JavaType)type;\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean resolveFrom(TypeElement type) {\n-            if (resolved == null || resolved.equals(JavaType.J_L_OBJECT)) {\n-                if (type instanceof UnresolvedType utt) {\n-                    type = utt.resolved();\n-                }\n-                \/\/ Only care about arrays\n-                if (type instanceof ArrayType at) {\n-                    resolved = at;\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public JavaType resolved() {\n-            return resolved;\n-        }\n@@ -99,2 +53,0 @@\n-        private int resolved = -1;\n-\n@@ -105,59 +57,0 @@\n-\n-        @Override\n-        public boolean resolveFrom(TypeElement type) {\n-            \/\/ Only care about booleans\n-            if (resolved < 4) {\n-                if (type instanceof UnresolvedType utt) {\n-                    type = utt.resolved();\n-                }\n-                if (JavaType.BOOLEAN.equals(type)) {\n-                    resolved = 4;\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean resolveTo(TypeElement type) {\n-            if (resolved < 4) {\n-                if (type instanceof UnresolvedType utt) {\n-                    type = utt.resolved();\n-                }\n-                if (type != null) {\n-                    int p = TYPES.indexOf(type);\n-                    if (p > resolved) {\n-                        resolved = p;\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public JavaType resolved() {\n-            return resolved >=0 ? TYPES.get(resolved) : null;\n-        }\n-    }\n-\n-    static Object convertValue(UnresolvedType ut, Object value) {\n-        return switch (TYPES.indexOf(ut.resolved())) {\n-            case 0 -> toNumber(value).intValue();\n-            case 1 -> (char)toNumber(value).intValue();\n-            case 2 -> toNumber(value).shortValue();\n-            case 3 -> toNumber(value).byteValue();\n-            case 4 -> value instanceof Number n ? n.intValue() != 0 : (Boolean)value;\n-            default -> value;\n-        };\n-    }\n-\n-    static final List<JavaType> TYPES = List.of(JavaType.INT, JavaType.CHAR, JavaType.SHORT, JavaType.BYTE, JavaType.BOOLEAN);\n-\n-    private static Number toNumber(Object value) {\n-        return switch (value) {\n-            case Boolean b -> b ? 1 : 0;\n-            case Character c -> (int)c;\n-            case Number n -> n;\n-            default -> throw new IllegalStateException(\"Unexpected \" + value);\n-        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedType.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.HashMap;\n@@ -41,0 +42,1 @@\n+import java.util.Map;\n@@ -48,1 +50,15 @@\n-try {\n+        try {\n+            return new UnresolvedTypesTransformer().resolve(func);\n+        } catch (Throwable t) {\n+            System.out.println(func.toText());\n+            throw t;\n+        }\n+    }\n+\n+    private final Map<UnresolvedType, JavaType> resolvedMap;\n+\n+    private UnresolvedTypesTransformer() {\n+        resolvedMap = new HashMap<>();\n+    }\n+\n+    private CoreOp.FuncOp resolve(CoreOp.FuncOp func) {\n@@ -71,7 +87,5 @@\n-            switch (v.type()) {\n-                case UnresolvedType.Int ui when ui.resolved() == null ->\n-                    ui.resolveTo(JavaType.INT);\n-                case UnresolvedType.Ref ur when ur.resolved() == null ->\n-                    ur.resolveTo(JavaType.J_L_OBJECT);\n-                default -> {}\n-            }\n+            resolvedMap.computeIfAbsent(toResolve(v), ut ->\n+                switch (ut) {\n+                    case UnresolvedType.Int _ -> JavaType.INT;\n+                    case UnresolvedType.Ref _ -> JavaType.J_L_OBJECT;\n+                });\n@@ -83,4 +97,0 @@\n-} catch (Throwable t) {\n-    System.out.println(func.toText());\n-    throw t;\n-}\n@@ -97,1 +107,1 @@\n-    private static TypeElement toComponent(TypeElement te) {\n+    private TypeElement toComponent(TypeElement te) {\n@@ -99,1 +109,1 @@\n-            te = ut.resolved();\n+            te = resolvedMap.get(ut);\n@@ -104,1 +114,1 @@\n-    private static TypeElement toArray(TypeElement te) {\n+    private TypeElement toArray(TypeElement te) {\n@@ -106,1 +116,1 @@\n-            te = ut.resolved();\n+            te = resolvedMap.get(ut);\n@@ -111,1 +121,1 @@\n-    private static boolean resolve(Value v) {\n+    private boolean resolve(Value v) {\n@@ -121,1 +131,1 @@\n-                        i == 0 && ut.resolveTo(op.resultType());\n+                        i == 0 && resolveTo(ut, op.resultType());\n@@ -123,1 +133,1 @@\n-                        ut.resolveTo(bo.resultType());\n+                        resolveTo(ut, bo.resultType());\n@@ -127,1 +137,1 @@\n-                            if (i == 0) yield ut.resolveTo(id.refType());\n+                            if (i == 0) yield resolveTo(ut, id.refType());\n@@ -130,1 +140,1 @@\n-                        yield ut.resolveTo(id.type().parameterTypes().get(i));\n+                        yield resolveTo(ut, id.type().parameterTypes().get(i));\n@@ -133,1 +143,1 @@\n-                        ut.resolveTo(fao.fieldDescriptor().refType());\n+                        resolveTo(ut, fao.fieldDescriptor().refType());\n@@ -135,1 +145,1 @@\n-                        ut.resolveTo(ro.ancestorBody().bodyType().returnType());\n+                        resolveTo(ut, ro.ancestorBody().bodyType().returnType());\n@@ -137,1 +147,1 @@\n-                        ut.resolveTo(vo.varValueType());\n+                        resolveTo(ut, vo.varValueType());\n@@ -139,1 +149,1 @@\n-                        ut.resolveTo(vso.varType().valueType());\n+                        resolveTo(ut, vso.varType().valueType());\n@@ -141,1 +151,1 @@\n-                        ut.resolveTo(no.constructorType().parameterTypes().get(i));\n+                        resolveTo(ut, no.constructorType().parameterTypes().get(i));\n@@ -143,1 +153,1 @@\n-                        ut.resolveTo(toArray(alo.resultType()));\n+                        resolveTo(ut, toArray(alo.resultType()));\n@@ -146,2 +156,2 @@\n-                            case 0 -> ut.resolveFrom(toArray(aso.operands().get(2).type()));\n-                            case 2 -> ut.resolveTo(toComponent(aso.operands().get(0).type()));\n+                            case 0 -> resolveFrom(ut, toArray(aso.operands().get(2).type()));\n+                            case 2 -> resolveTo(ut, toComponent(aso.operands().get(0).type()));\n@@ -157,1 +167,1 @@\n-                    changed |= ut.resolveTo(sucRef.targetBlock().parameters().get(i).type());\n+                    changed |= resolveTo(ut, sucRef.targetBlock().parameters().get(i).type());\n@@ -168,1 +178,1 @@\n-                        if (args.size() > bi && ut.resolveFrom(args.get(bi).type())) {\n+                        if (args.size() > bi && resolveFrom(ut, args.get(bi).type())) {\n@@ -177,1 +187,1 @@\n-                    ut.resolveFrom(uo.operands().getFirst().type());\n+                    resolveFrom(ut, uo.operands().getFirst().type());\n@@ -179,2 +189,2 @@\n-                    ut.resolveFrom(bo.operands().getFirst().type())\n-                    || ut.resolveFrom(bo.operands().get(1).type());\n+                    resolveFrom(ut, bo.operands().getFirst().type())\n+                    || resolveFrom(ut, bo.operands().get(1).type());\n@@ -182,1 +192,1 @@\n-                    ut.resolveFrom(vlo.varType().valueType());\n+                    resolveFrom(ut, vlo.varType().valueType());\n@@ -186,1 +196,1 @@\n-                    ut.resolveFrom(toComponent(alo.operands().getFirst().type()));\n+                    resolveFrom(ut, toComponent(alo.operands().getFirst().type()));\n@@ -193,2 +203,38 @@\n-    private static boolean resolveVarOpType(UnresolvedType ut, CoreOp.VarOp vo) {\n-        boolean changed = vo.isUninitialized() ? false : ut.resolveFrom(vo.initOperand().type());\n+    private boolean resolveFrom(UnresolvedType unresolved, TypeElement from) {\n+        TypeElement type = from instanceof UnresolvedType utt ? resolvedMap.get(utt) : from;\n+        JavaType resolved = resolvedMap.get(unresolved);\n+        return switch (unresolved) {\n+            \/\/ Only care about arrays\n+            case UnresolvedType.Ref _ when (resolved == null || resolved.equals(JavaType.J_L_OBJECT)) && type instanceof ArrayType at -> {\n+                resolvedMap.put(unresolved, at);\n+                yield true;\n+            }\n+            \/\/ Only care about booleans\n+            case UnresolvedType.Int _ when JavaType.BOOLEAN.equals(type) && !JavaType.BOOLEAN.equals(resolved) -> {\n+                resolvedMap.put(unresolved, JavaType.BOOLEAN);\n+                yield true;\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private static final List<PrimitiveType> INT_TYPES = List.of(JavaType.INT, JavaType.CHAR, JavaType.SHORT, JavaType.BYTE, JavaType.BOOLEAN);\n+\n+    private boolean resolveTo(UnresolvedType unresolved, TypeElement to) {\n+        TypeElement type = to instanceof UnresolvedType utt ? resolvedMap.get(utt) : to;\n+        JavaType resolved = resolvedMap.get(unresolved);\n+        return switch (unresolved) {\n+            case UnresolvedType.Ref _ when (resolved == null || resolved.equals(JavaType.J_L_OBJECT)) && type instanceof JavaType jt && !jt.equals(resolved) -> {\n+                resolvedMap.put(unresolved, jt);\n+                yield true;\n+            }\n+            case UnresolvedType.Int _ when type instanceof PrimitiveType pt && (INT_TYPES.indexOf(pt) > (resolved == null ? -1 : INT_TYPES.indexOf(resolved))) -> {\n+                resolvedMap.put(unresolved, pt);\n+                yield true;\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean resolveVarOpType(UnresolvedType ut, CoreOp.VarOp vo) {\n+        boolean changed = vo.isUninitialized() ? false : resolveFrom(ut, vo.initOperand().type());\n@@ -198,1 +244,1 @@\n-                    ut.resolveTo(vlo.resultType());\n+                    resolveTo(ut, vlo.resultType());\n@@ -200,1 +246,1 @@\n-                    ut.resolveFrom(vso.storeOperand().type());\n+                    resolveFrom(ut, vso.storeOperand().type());\n@@ -207,1 +253,18 @@\n-    private UnresolvedTypesTransformer() {\n+    private Object convertValue(UnresolvedType ut, Object value) {\n+        return switch (INT_TYPES.indexOf(resolvedMap.get(ut))) {\n+            case 0 -> toNumber(value).intValue();\n+            case 1 -> (char)toNumber(value).intValue();\n+            case 2 -> toNumber(value).shortValue();\n+            case 3 -> toNumber(value).byteValue();\n+            case 4 -> value instanceof Number n ? n.intValue() != 0 : (Boolean)value;\n+            default -> value;\n+        };\n+    }\n+\n+    private static Number toNumber(Object value) {\n+        return switch (value) {\n+            case Boolean b -> b ? 1 : 0;\n+            case Character c -> (int)c;\n+            case Number n -> n;\n+            default -> throw new IllegalStateException(\"Unexpected \" + value);\n+        };\n@@ -210,1 +273,1 @@\n-    private static OpTransformer blockParamTypesTransformer() {\n+    private OpTransformer blockParamTypesTransformer() {\n@@ -224,1 +287,1 @@\n-                                    .map(pt -> pt instanceof UnresolvedType ut && ut.resolved() != null ? ut.resolved() : pt)\n+                                    .map(pt -> pt instanceof UnresolvedType ut  ? resolvedMap.get(ut) : pt)\n@@ -243,1 +306,1 @@\n-    private static OpTransformer opTypesTransformer() {\n+    private OpTransformer opTypesTransformer() {\n@@ -247,3 +310,3 @@\n-                case CoreOp.ConstantOp cop when op.resultType() instanceof UnresolvedType ut && ut.resolved() != null ->\n-                    cc.mapValue(op.result(), block.op(CoreOp.constant(ut.resolved(), UnresolvedType.convertValue(ut, cop.value()))));\n-                case CoreOp.VarOp vop when vop.varValueType() instanceof UnresolvedType ut && ut.resolved() != null ->\n+                case CoreOp.ConstantOp cop when op.resultType() instanceof UnresolvedType ut ->\n+                    cc.mapValue(op.result(), block.op(CoreOp.constant(resolvedMap.get(ut), convertValue(ut, cop.value()))));\n+                case CoreOp.VarOp vop when vop.varValueType() instanceof UnresolvedType ut ->\n@@ -251,2 +314,2 @@\n-                            ? CoreOp.var(vop.varName(), ut.resolved())\n-                            : CoreOp.var(vop.varName(), ut.resolved(), cc.getValueOrDefault(vop.initOperand(), vop.initOperand()))));\n+                            ? CoreOp.var(vop.varName(), resolvedMap.get(ut))\n+                            : CoreOp.var(vop.varName(), resolvedMap.get(ut), cc.getValueOrDefault(vop.initOperand(), vop.initOperand()))));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":112,"deletions":49,"binary":false,"changes":161,"status":"modified"}]}