{"files":[{"patch":"@@ -158,1 +158,1 @@\n-    final Set<Block> predecessors;\n+    final SequencedSet<Block> predecessors;\n@@ -315,2 +315,2 @@\n-    public Set<Block> predecessors() {\n-        return Collections.unmodifiableSet(predecessors);\n+    public SequencedSet<Block> predecessors() {\n+        return Collections.unmodifiableSequencedSet(predecessors);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+        \/\/ @@@ property is used to test both impls\n+        if (!\"cytron\".equalsIgnoreCase(System.getProperty(\"babylon.ssa\"))) {\n+            return SSAConstruction.transform(nestedOp);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,312 @@\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SequencedSet;\n+import java.util.Set;\n+\n+\/**\n+ * This is an implementation of SSA construction based on\n+ * <a href=\"https:\/\/doi.org\/10.1007\/978-3-642-37051-9\">\n+ * Simple end Efficient Construction of Static Single Assignment Form (pp 102-122)\n+ * <\/a>.\n+ * <p>\n+ * This implementation contains some adaptions, notably:\n+ * <ul>\n+ *     <li>Adapt to block parameters rather than phi functions.<\/li>\n+ *     <li>Adapt to work with multiple bodies.<\/li>\n+ * <\/ul>\n+ *\/\n+public class SSAConstruction implements OpTransformer {\n+\n+    private final Map<CoreOp.VarOp, Map<Block, Val>> currentDef = new HashMap<>();\n+    private final Set<Block> sealedBlocks = new HashSet<>();\n+    private final Map<Block, Map<CoreOp.VarOp, Phi>> incompletePhis = new HashMap<>();\n+\n+    \/\/ according to the algorithm:\n+    \/\/ \"As only filled blocks may have successors, predecessors are always filled.\"\n+    \/\/ In consequence, this means that only filled predecessors should be considered\n+    \/\/ when recursively searching for a definition\n+    private final Map<Block, SequencedSet<Block>> predecessors = new HashMap<>();\n+    \/\/ as we can't modify the graph at the same time as we analyze it,\n+    \/\/ we need to store which load op needs to remapped to which value\n+    private final Map<CoreOp.VarAccessOp.VarLoadOp, Val> loads = new HashMap<>();\n+    private final Map<Block, List<Phi>> additionalParameters = new HashMap<>();\n+    \/\/ as we look up definitions during the actual transformation again,\n+    \/\/ we might encounter deleted phis.\n+    \/\/ we use this set to be able to correct that during transformation\n+    private final Set<Phi> deletedPhis = new HashSet<>();\n+\n+    public static <O extends Op> O transform(O nestedOp) {\n+        SSAConstruction construction = new SSAConstruction();\n+        construction.prepare(nestedOp);\n+        @SuppressWarnings(\"unchecked\")\n+        O temp = (O) nestedOp.transform(CopyContext.create(), construction);\n+        return temp;\n+    }\n+\n+    private SSAConstruction() {\n+    }\n+\n+    private void prepare(Op nestedOp) {\n+        nestedOp.traverse(null, CodeElement.opVisitor((_, op) -> {\n+            switch (op) {\n+                case CoreOp.VarAccessOp.VarLoadOp load -> {\n+                    Val val = readVariable(load.varOp(), load.parentBlock());\n+                    registerLoad(load, val);\n+                }\n+                case CoreOp.VarAccessOp.VarStoreOp store ->\n+                        writeVariable(store.varOp(), store.parentBlock(), new Holder(store.storeOperand()));\n+                case CoreOp.VarOp initialStore ->\n+                        writeVariable(initialStore, initialStore.parentBlock(), new Holder(initialStore.initOperand()));\n+                case Op.Terminating _ -> {\n+                    Block block = op.parentBlock();\n+                    \/\/ handle the sealing, i.e. only now make this block a predecessor of its successors\n+                    for (Block.Reference successor : block.successors()) {\n+                        Block successorBlock = successor.targetBlock();\n+                        Set<Block> blocks = this.predecessors.computeIfAbsent(successorBlock, _ -> new LinkedHashSet<>());\n+                        blocks.add(block);\n+                        \/\/ if this was the last predecessor added to successorBlock, seal it\n+                        if (blocks.size() == successorBlock.predecessors().size()) {\n+                            sealBlock(successorBlock);\n+                        }\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return null;\n+        }));\n+    }\n+\n+    private void registerLoad(CoreOp.VarAccessOp.VarLoadOp load, Val val) {\n+        this.loads.put(load, val);\n+        if (val instanceof Phi phi) {\n+            phi.users.add(load);\n+        }\n+    }\n+\n+    private void writeVariable(CoreOp.VarOp variable, Block block, Val value) {\n+        this.currentDef.computeIfAbsent(variable, _ -> new HashMap<>()).put(block, value);\n+    }\n+\n+    private Val readVariable(CoreOp.VarOp variable, Block block) {\n+        Val value = this.currentDef.getOrDefault(variable, Map.of()).get(block);\n+        if (value == null\n+            \/\/ deleted Phi, this is an old reference\n+            \/\/ due to our 2-step variant of the original algorithm, we might encounter outdated definitions\n+            \/\/ when we read to prepare block arguments\n+            || value instanceof Phi phi && this.deletedPhis.contains(phi)) {\n+            return readVariableRecursive(variable, block);\n+        }\n+        return value;\n+    }\n+\n+    private Val readVariableRecursive(CoreOp.VarOp variable, Block block) {\n+        Val value;\n+        if (!block.isEntryBlock() && !this.sealedBlocks.contains(block)) {\n+            Phi phi = new Phi(variable, block);\n+            value = phi;\n+            this.incompletePhis.computeIfAbsent(block, _ -> new HashMap<>()).put(variable, phi);\n+            this.additionalParameters.computeIfAbsent(block, _ -> new ArrayList<>()).add(phi);\n+        } else if (block.isEntryBlock() && variable.ancestorBody() != block.parentBody()) {\n+            \/\/ we are in an entry block but didn't find a definition yet\n+            Block enclosingBlock = block.parent().parent().parent();\n+            assert enclosingBlock != null : \"def not found in entry block, with no enclosing block\";\n+            value = readVariable(variable, enclosingBlock);\n+        } else if (this.predecessors.get(block).size() == 1) {\n+            value = readVariable(variable, this.predecessors.get(block).getFirst());\n+        } else {\n+            Phi param = new Phi(variable, block);\n+            writeVariable(variable, block, param);\n+            value = addPhiOperands(variable, param);\n+            \/\/ To go from Phis to block parameters, we remember that we produced a Phi here.\n+            \/\/ This means that edges to this block need to pass a value via parameter\n+            if (value == param) {\n+                this.additionalParameters.computeIfAbsent(block, _ -> new ArrayList<>()).add(param);\n+            }\n+        }\n+        writeVariable(variable, block, value); \/\/ cache value for this variable + block\n+        return value;\n+    }\n+\n+    private Val addPhiOperands(CoreOp.VarOp variable, Phi value) {\n+        for (Block pred : this.predecessors.getOrDefault(value.block(), Collections.emptySortedSet())) {\n+            value.appendOperand(readVariable(variable, pred));\n+        }\n+        return tryRemoveTrivialPhi(value);\n+    }\n+\n+    private Val tryRemoveTrivialPhi(Phi phi) {\n+        Val same = null;\n+        for (Val op : phi.operands()) {\n+            if (op == same || op == phi) {\n+                continue;\n+            }\n+            if (same != null) {\n+                return phi;\n+            }\n+            same = op;\n+        }\n+        \/\/ we shouldn't have phis without operands (other than itself)\n+        assert same != null : \"phi without different operands\";\n+        List<Phi> phiUsers = phi.replaceBy(same, this);\n+        List<Phi> phis = this.additionalParameters.get(phi.block());\n+        if (phis != null) {\n+            phis.remove(phi);\n+        }\n+        for (Phi user : phiUsers) {\n+            tryRemoveTrivialPhi(user);\n+        }\n+        return same;\n+    }\n+\n+    private void sealBlock(Block block) {\n+        this.incompletePhis.getOrDefault(block, Map.of()).forEach(this::addPhiOperands);\n+        this.sealedBlocks.add(block);\n+    }\n+\n+    \/\/ only used during transformation\n+\n+    private Value resolveValue(CopyContext context, Val val) {\n+        return switch (val) {\n+            case Holder holder -> context.getValueOrDefault(holder.value(), holder.value());\n+            case Phi phi -> {\n+                List<Phi> phis = this.additionalParameters.get(phi.block());\n+                int additionalParameterIndex = phis.indexOf(phi);\n+                assert additionalParameterIndex >= 0 : \"phi not in parameters \" + phi;\n+                int index = additionalParameterIndex + phi.block().parameters().size();\n+                Block.Builder b = context.getBlock(phi.block());\n+                yield b.parameters().get(index);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Block.Builder apply(Block.Builder block, Op op) {\n+        Block originalBlock = op.parentBlock();\n+        CopyContext context = block.context();\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp load -> {\n+                Val val = this.loads.get(load);\n+                context.mapValue(load.result(), resolveValue(context, val));\n+            }\n+            case CoreOp.VarOp _, CoreOp.VarAccessOp.VarStoreOp _ -> {\n+            }\n+            case Op.Terminating _ -> {\n+                \/\/ make sure outgoing branches are corrected\n+                for (Block.Reference successor : originalBlock.successors()) {\n+                    Block successorBlock = successor.targetBlock();\n+                    List<Phi> successorParams = this.additionalParameters.getOrDefault(successorBlock, List.of());\n+                    List<Value> additionalParams = successorParams.stream()\n+                            .map(phi -> readVariable(phi.variable, originalBlock))\n+                            .map(val -> resolveValue(context, val))\n+                            .toList();\n+                    List<Value> values = context.getValues(successor.arguments());\n+                    values.addAll(additionalParams);\n+                    Block.Builder successorBlockBuilder = context.getBlock(successorBlock);\n+                    context.mapSuccessor(successor, successorBlockBuilder.successor(values));\n+                }\n+                block.op(op);\n+            }\n+            default -> block.op(op);\n+        }\n+        return block;\n+    }\n+\n+    @Override\n+    public void apply(Block.Builder block, Block b) {\n+        \/\/ add the required additional parameters to this block\n+        boolean isEntry = b.isEntryBlock();\n+        for (Phi phi : this.additionalParameters.getOrDefault(b, List.of())) {\n+            if (isEntry) {\n+                \/\/ Phis in entry blocks denote captured values. Do not add as param but make sure\n+                \/\/ the original value is used\n+                assert phi.operands().size() == 1 : \"entry block phi with multiple operands\";\n+                CopyContext context = block.context();\n+                context.mapValue(resolveValue(context, phi), resolveValue(context, phi.operands().getFirst()));\n+            } else {\n+                block.parameter(phi.variable.varValueType());\n+            }\n+        }\n+\n+        \/\/ actually visit ops in this block\n+        OpTransformer.super.apply(block, b);\n+    }\n+\n+    sealed interface Val {\n+    }\n+\n+    record Holder(Value value) implements Val {\n+    }\n+\n+    record Phi(CoreOp.VarOp variable, Block block, List<Val> operands, Set<Object> users) implements Val {\n+        Phi(CoreOp.VarOp variable, Block block) {\n+            this(variable, block, new ArrayList<>(), new HashSet<>());\n+        }\n+\n+        void appendOperand(Val val) {\n+            this.operands.add(val);\n+            if (val instanceof Phi phi) { \/\/ load op uses are added separately\n+                phi.users.add(this);\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return this == obj;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(this.variable, this.block);\n+        }\n+\n+        public List<Phi> replaceBy(Val same, SSAConstruction construction) {\n+            List<Phi> usingPhis = new ArrayList<>();\n+            for (Object user : this.users) {\n+                if (user == this) {\n+                    continue;\n+                }\n+                if (same instanceof Phi samePhi) {\n+                    samePhi.users.add(user);\n+                }\n+                switch (user) {\n+                    case Phi phi -> {\n+                        int i = phi.operands.indexOf(this);\n+                        assert i >= 0 : \"use does not have this as operand\";\n+                        phi.operands.set(i, same);\n+                        usingPhis.add(phi);\n+                    }\n+                    case CoreOp.VarAccessOp.VarLoadOp load -> construction.loads.put(load, same);\n+                    default -> throw new UnsupportedOperationException(user + \":\" + user.getClass());\n+                }\n+            }\n+            if (same instanceof Phi samePhi) {\n+                samePhi.users.remove(this);\n+            }\n+            construction.currentDef.get(this.variable).put(this.block, same);\n+            construction.deletedPhis.add(this); \/\/ we might not replace all current defs, so mark this phi as deleted\n+            this.users.clear();\n+            return usingPhis;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Phi[\" + variable.varName() + \"(\" + block.index() + \"),\" + \"operands: \" + operands.size() + \"}\";\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSAConstruction.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+ * @run junit\/othervm -Dbabylon.ssa=cytron CoreBinaryOpsTest\n@@ -47,2 +48,0 @@\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+ * @run testng\/othervm -Dbabylon.ssa=cytron TestBuild\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @run testng\/othervm -Dbabylon.ssa=cytron TestSSA\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @run testng\/othervm -Dbabylon.ssa=cytron TestStringConcatTransform\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @run testng\/othervm -Dbabylon.ssa=cytron TestTransitiveInvokeModule\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+ * @run testng\/othervm -Dbabylon.ssa=cytron TestForwardAutoDiff\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                branch ^block_0(%1, %2);\n+                branch ^block_1(%2, %1);\n@@ -88,1 +88,1 @@\n-              ^block_0(%3 : int, %4 : int):\n+              ^block_1(%3 : int, %4 : int):\n@@ -90,2 +90,2 @@\n-                %6 : boolean = lt %4 %5;\n-                cbranch %6 ^block_1 ^block_2;\n+                %6 : boolean = lt %3 %5;\n+                cbranch %6 ^block_2 ^block_4;\n@@ -93,3 +93,3 @@\n-              ^block_1:\n-                %7 : int = array.load %0 %4;\n-                %8 : int = add %3 %7;\n+              ^block_2:\n+                %7 : int = array.load %0 %3;\n+                %8 : int = add %4 %7;\n@@ -100,2 +100,2 @@\n-                %10 : int = add %4 %9;\n-                branch ^block_0(%8, %10);\n+                %10 : int = add %3 %9;\n+                branch ^block_1(%10, %8);\n@@ -103,2 +103,2 @@\n-              ^block_2:\n-                return %3;\n+              ^block_4:\n+                return %4;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/TestLoop.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}