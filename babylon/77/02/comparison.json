{"files":[{"patch":"@@ -134,0 +134,174 @@\n+    \/\/ byte\n+\n+    public static byte neg(byte l) {\n+        return (byte) -l;\n+    }\n+\n+    public static byte add(byte l, byte r) {\n+        return (byte) (l + r);\n+    }\n+\n+    public static byte sub(byte l, byte r) {\n+        return (byte) (l - r);\n+    }\n+\n+    public static byte mul(byte l, byte r) {\n+        return (byte) (l * r);\n+    }\n+\n+    public static byte div(byte l, byte r) {\n+        return (byte) (l \/ r);\n+    }\n+\n+    public static byte mod(byte l, byte r) {\n+        return (byte) (l % r);\n+    }\n+\n+    public static byte or(byte l, byte r) {\n+        return (byte) (l | r);\n+    }\n+\n+    public static byte and(byte l, byte r) {\n+        return (byte) (l & r);\n+    }\n+\n+    public static byte xor(byte l, byte r) {\n+        return (byte) (l ^ r);\n+    }\n+\n+    public static byte ashr(byte l, long r) {\n+        return (byte) (l >> r);\n+    }\n+\n+    public static byte lshr(byte l, long r) {\n+        return (byte) (l >>> r);\n+    }\n+\n+    public static byte lshl(byte l, int r) {\n+        return (byte) (l << r);\n+    }\n+\n+    public static byte ashr(byte l, int r) {\n+        return (byte) (l >> r);\n+    }\n+\n+    public static byte lshr(byte l, int r) {\n+        return (byte) (l >>> r);\n+    }\n+\n+    \/\/ short\n+\n+    public static short neg(short l) {\n+        return (short) -l;\n+    }\n+\n+    public static short add(short l, short r) {\n+        return (short) (l + r);\n+    }\n+\n+    public static short sub(short l, short r) {\n+        return (short) (l - r);\n+    }\n+\n+    public static short mul(short l, short r) {\n+        return (short) (l * r);\n+    }\n+\n+    public static short div(short l, short r) {\n+        return (short) (l \/ r);\n+    }\n+\n+    public static short mod(short l, short r) {\n+        return (short) (l % r);\n+    }\n+\n+    public static short or(short l, short r) {\n+        return (short) (l | r);\n+    }\n+\n+    public static short and(short l, short r) {\n+        return (short) (l & r);\n+    }\n+\n+    public static short xor(short l, short r) {\n+        return (short) (l ^ r);\n+    }\n+\n+    public static short ashr(short l, long r) {\n+        return (short) (l >> r);\n+    }\n+\n+    public static short lshr(short l, long r) {\n+        return (short) (l >>> r);\n+    }\n+\n+    public static short lshl(short l, int r) {\n+        return (short) (l << r);\n+    }\n+\n+    public static short ashr(short l, int r) {\n+        return (short) (l >> r);\n+    }\n+\n+    public static short lshr(short l, int r) {\n+        return (short) (l >>> r);\n+    }\n+\n+    \/\/ char\n+\n+    public static char neg(char l) {\n+        return (char) -l;\n+    }\n+\n+    public static char add(char l, char r) {\n+        return (char) (l + r);\n+    }\n+\n+    public static char sub(char l, char r) {\n+        return (char) (l - r);\n+    }\n+\n+    public static char mul(char l, char r) {\n+        return (char) (l * r);\n+    }\n+\n+    public static char div(char l, char r) {\n+        return (char) (l \/ r);\n+    }\n+\n+    public static char mod(char l, char r) {\n+        return (char) (l % r);\n+    }\n+\n+    public static char or(char l, char r) {\n+        return (char) (l | r);\n+    }\n+\n+    public static char and(char l, char r) {\n+        return (char) (l & r);\n+    }\n+\n+    public static char xor(char l, char r) {\n+        return (char) (l ^ r);\n+    }\n+\n+    public static char ashr(char l, long r) {\n+        return (char) (l >> r);\n+    }\n+\n+    public static char lshr(char l, long r) {\n+        return (char) (l >>> r);\n+    }\n+\n+    public static char lshl(char l, int r) {\n+        return (char) (l << r);\n+    }\n+\n+    public static char ashr(char l, int r) {\n+        return (char) (l >> r);\n+    }\n+\n+    public static char lshr(char l, int r) {\n+        return (char) (l >>> r);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -441,0 +441,1 @@\n+                        Tag.BITOR_ASG, Tag.BITAND_ASG, Tag.BITXOR_ASG,\n@@ -442,0 +443,1 @@\n+                        Tag.SL_ASG, Tag.SR_ASG, Tag.USR_ASG,\n@@ -805,1 +807,0 @@\n-                JavaType resultType = typeToTypeElement(unboxedType);\n@@ -818,0 +819,11 @@\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR_ASG -> append(CoreOp.or(lhs, rhs));\n+                    case BITAND_ASG -> append(CoreOp.and(lhs, rhs));\n+                    case BITXOR_ASG -> append(CoreOp.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL_ASG -> append(CoreOp.lshl(lhs, rhs));\n+                    case SR_ASG -> append(CoreOp.ashr(lhs, rhs));\n+                    case USR_ASG -> append(CoreOp.lshr(lhs, rhs));\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    @SupportedTypes(TypeList.INTEGRAL_BOOLEAN)\n@@ -72,1 +72,1 @@\n-    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    @SupportedTypes(TypeList.INTEGRAL_FLOATING_POINT)\n@@ -78,1 +78,1 @@\n-    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    @SupportedTypes(TypeList.INTEGRAL_FLOATING_POINT)\n@@ -84,1 +84,1 @@\n-    @SupportedTypes(types = {int.class, long.class})\n+    @SupportedTypes(TypeList.INT_LONG)\n@@ -102,1 +102,1 @@\n-    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    @SupportedTypes(TypeList.INTEGRAL_FLOATING_POINT)\n@@ -108,1 +108,1 @@\n-    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    @SupportedTypes(TypeList.INTEGRAL_FLOATING_POINT)\n@@ -114,1 +114,1 @@\n-    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    @SupportedTypes(TypeList.INTEGRAL_BOOLEAN)\n@@ -120,1 +120,1 @@\n-    @SupportedTypes(types = {int.class, long.class})\n+    @SupportedTypes(TypeList.INT_LONG)\n@@ -138,1 +138,1 @@\n-    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    @SupportedTypes(TypeList.INTEGRAL_FLOATING_POINT)\n@@ -144,1 +144,1 @@\n-    @SupportedTypes(types = {int.class, long.class})\n+    @SupportedTypes(TypeList.INT_LONG)\n@@ -162,1 +162,1 @@\n-    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    @SupportedTypes(TypeList.INTEGRAL_BOOLEAN)\n@@ -178,1 +178,17 @@\n-        Class<?>[] types();\n+        TypeList value();\n+    }\n+\n+    enum TypeList {\n+        INT_LONG(int.class, long.class),\n+        INTEGRAL_BOOLEAN(int.class, long.class, byte.class, short.class, char.class, boolean.class),\n+        INTEGRAL_FLOATING_POINT(int.class, long.class, byte.class, short.class, char.class, float.class, double.class);\n+\n+        private final Class<?>[] types;\n+\n+        TypeList(Class<?>... types) {\n+            this.types = types;\n+        }\n+\n+        public Class<?>[] types() {\n+            return types;\n+        }\n@@ -194,6 +210,10 @@\n-        private static final Map<JavaType, List<Object>> INTERESTING_INPUTS = Map.of(\n-                JavaType.INT, List.of(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, 0, -1),\n-                JavaType.LONG, List.of(Long.MIN_VALUE, Long.MAX_VALUE, 1, 0, -1),\n-                JavaType.DOUBLE, List.of(Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MIN_NORMAL, 1, 0, -1),\n-                JavaType.FLOAT, List.of(Float.MIN_VALUE, Float.MAX_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.MIN_NORMAL, 1, 0, -1),\n-                JavaType.BOOLEAN, List.of(true, false)\n+        private static final Map<JavaType, List<?>> INTERESTING_INPUTS = Map.of(\n+                \/\/ explicit type parameters to ensure boxing results in the expected type\n+                JavaType.INT, List.<Integer>of(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, 0, -1),\n+                JavaType.LONG, List.<Long>of(Long.MIN_VALUE, Long.MAX_VALUE, 1L, 0L, -1L),\n+                JavaType.BYTE, List.<Byte>of(Byte.MIN_VALUE, Byte.MAX_VALUE, (byte) 1, (byte) 0, (byte) -1),\n+                JavaType.SHORT, List.<Short>of(Short.MIN_VALUE, Short.MAX_VALUE, (short) 1, (short) 0, (short) -1),\n+                JavaType.CHAR, List.<Character>of(Character.MIN_VALUE, Character.MAX_VALUE, (char) 1, (char) 0, (char) -1),\n+                JavaType.DOUBLE, List.<Double>of(Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MIN_NORMAL, 1d, 0d, -1d),\n+                JavaType.FLOAT, List.<Float>of(Float.MIN_VALUE, Float.MAX_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.MIN_NORMAL, 1f, 0f, -1f),\n+                JavaType.BOOLEAN, List.<Boolean>of(true, false)\n@@ -217,1 +237,1 @@\n-                        if (supportedTypes == null || supportedTypes.types().length == 0) {\n+                        if (supportedTypes == null || supportedTypes.value().types().length == 0) {\n@@ -220,1 +240,1 @@\n-                        return Arrays.stream(supportedTypes.types())\n+                        return Arrays.stream(supportedTypes.value().types())\n@@ -226,1 +246,1 @@\n-        private static <T> Stream<List<T>> cartesianProduct(List<List<T>> source) {\n+        private static <T> Stream<List<T>> cartesianProduct(List<List<? extends T>> source) {\n@@ -286,1 +306,1 @@\n-            List<List<Object>> allInputs = new ArrayList<>();\n+            List<List<?>> allInputs = new ArrayList<>();\n@@ -338,2 +358,2 @@\n-            assertNotNull(first.throwable, \"only second threw an exception\");\n-            assertNotNull(second.throwable, \"only first threw an exception\");\n+            assertNotNull(first.throwable, () -> \"only second threw an exception: \" + second.throwable);\n+            assertNotNull(second.throwable, () -> \"only first threw an exception: \" + first.throwable);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -272,0 +272,51 @@\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : BinopTest, %1 : byte, %2 : byte, %3 : short)void -> {\n+                %4 : Var<byte> = var %1 @\"a\";\n+                %5 : Var<byte> = var %2 @\"b\";\n+                %6 : Var<short> = var %3 @\"s\";\n+                %7 : byte = var.load %4;\n+                %8 : byte = var.load %5;\n+                %9 : byte = add %7 %8;\n+                var.store %4 %9;\n+                %10 : byte = var.load %4;\n+                %11 : short = var.load %6;\n+                %12 : byte = conv %11;\n+                %13 : byte = div %10 %12;\n+                var.store %4 %13;\n+                %14 : byte = var.load %4;\n+                %15 : double = constant @\"3.5\";\n+                %16 : byte = conv %15;\n+                %17 : byte = mul %14 %16;\n+                var.store %4 %17;\n+                %18 : byte = var.load %4;\n+                %19 : byte = var.load %5;\n+                %20 : byte = lshl %18 %19;\n+                var.store %4 %20;\n+                %21 : byte = var.load %4;\n+                %22 : int = constant @\"1\";\n+                %23 : byte = conv %22;\n+                %24 : byte = ashr %21 %23;\n+                var.store %4 %24;\n+                %25 : byte = var.load %4;\n+                %26 : long = constant @\"1\";\n+                %27 : byte = conv %26;\n+                %28 : byte = ashr %25 %27;\n+                var.store %4 %28;\n+                return;\n+            };\n+            \"\"\")\n+    void test9(byte a, byte b, short s) {\n+        a += b;\n+\n+        a \/= s;\n+\n+        a *= 3.5d;\n+\n+        a <<= b;\n+\n+        a >>= 1;\n+\n+        a >>= 1L;\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/BinopTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"}]}