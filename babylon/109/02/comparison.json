{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -64,0 +65,2 @@\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n@@ -65,0 +68,5 @@\n+import java.lang.reflect.code.Block.Parameter;\n+import java.lang.reflect.code.op.CoreOp.LambdaOp;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.function.BiFunction;\n@@ -69,0 +77,5 @@\n+    private static final ClassDesc CD_LambdaMetafactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/LambdaMetafactory;\");\n+    private static final MethodRef LCMP = MethodRef.method(JavaType.J_L_LONG, \"compare\", JavaType.INT, JavaType.LONG, JavaType.LONG);\n+    private static final MethodRef FCMP = MethodRef.method(JavaType.J_L_FLOAT, \"compare\", JavaType.INT, JavaType.FLOAT, JavaType.FLOAT);\n+    private static final MethodRef DCMP = MethodRef.method(JavaType.J_L_DOUBLE, \"compare\", JavaType.INT, JavaType.DOUBLE, JavaType.DOUBLE);\n+\n@@ -98,1 +111,1 @@\n-    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel) {\n+    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel, Value... capturedValues) {\n@@ -113,1 +126,0 @@\n-        List<Block.Parameter> bps = entryBlock.parameters();\n@@ -115,3 +127,8 @@\n-        for (int i = 0, slot = 0; i < bps.size(); i++) {\n-            op(SlotOp.store(slot, bps.get(i)));\n-            slot += TypeKind.from(mtd.parameterType(i)).slotSize();\n+        int slot = 0, i = 0;\n+        for (Value cap : capturedValues) {\n+            op(SlotOp.store(slot, cap));\n+            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n+        }\n+        for (Parameter bp : entryBlock.parameters()) {\n+            op(SlotOp.store(slot, bp));\n+            slot += TypeKind.from(mtd.parameterType(i++)).slotSize();\n@@ -203,1 +220,1 @@\n-                            Op ere = CoreOp.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor());\n+                            Op ere = CoreOp.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor(List.copyOf(stack)));\n@@ -215,1 +232,1 @@\n-                            op(CoreOp.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor()));\n+                            op(CoreOp.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor(List.copyOf(stack))));\n@@ -228,6 +245,6 @@\n-                        case IFNE -> CoreOp.eq(operand, op(CoreOp.constant(JavaType.INT, 0)));\n-                        case IFEQ -> CoreOp.neq(operand, op(CoreOp.constant(JavaType.INT, 0)));\n-                        case IFGE -> CoreOp.lt(operand, op(CoreOp.constant(JavaType.INT, 0)));\n-                        case IFLE -> CoreOp.gt(operand, op(CoreOp.constant(JavaType.INT, 0)));\n-                        case IFGT -> CoreOp.le(operand, op(CoreOp.constant(JavaType.INT, 0)));\n-                        case IFLT -> CoreOp.ge(operand, op(CoreOp.constant(JavaType.INT, 0)));\n+                        case IFNE -> CoreOp.eq(operand, zero(operand));\n+                        case IFEQ -> CoreOp.neq(operand, zero(operand));\n+                        case IFGE -> CoreOp.lt(operand, zero(operand));\n+                        case IFLE -> CoreOp.gt(operand, zero(operand));\n+                        case IFGT -> CoreOp.le(operand, zero(operand));\n+                        case IFLT -> CoreOp.ge(operand, zero(operand));\n@@ -236,8 +253,8 @@\n-                        case IF_ICMPNE -> CoreOp.eq(stack.pop(), operand);\n-                        case IF_ICMPEQ -> CoreOp.neq(stack.pop(), operand);\n-                        case IF_ICMPGE -> CoreOp.lt(stack.pop(), operand);\n-                        case IF_ICMPLE -> CoreOp.gt(stack.pop(), operand);\n-                        case IF_ICMPGT -> CoreOp.le(stack.pop(), operand);\n-                        case IF_ICMPLT -> CoreOp.ge(stack.pop(), operand);\n-                        case IF_ACMPEQ -> CoreOp.neq(stack.pop(), operand);\n-                        case IF_ACMPNE -> CoreOp.eq(stack.pop(), operand);\n+                        case IF_ICMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPGE -> unifyOperands(CoreOp::lt, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPLE -> unifyOperands(CoreOp::gt, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPGT -> unifyOperands(CoreOp::le, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPLT -> unifyOperands(CoreOp::ge, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ACMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ACMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n@@ -252,10 +269,6 @@\n-    \/\/                case LookupSwitchInstruction si -> {\n-    \/\/                    \/\/ Default label is first successor\n-    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-    \/\/                    addSuccessors(si.cases(), blockMap, b);\n-    \/\/                }\n-    \/\/                case TableSwitchInstruction si -> {\n-    \/\/                    \/\/ Default label is first successor\n-    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-    \/\/                    addSuccessors(si.cases(), blockMap, b);\n-    \/\/                }\n+                case LookupSwitchInstruction si -> {\n+                    liftSwitch(si.defaultTarget(), si.cases());\n+                }\n+                case TableSwitchInstruction si -> {\n+                    liftSwitch(si.defaultTarget(), si.cases());\n+                }\n@@ -293,0 +306,3 @@\n+                        case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n+                                                     && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n+                                -> CoreOp.constant(JavaType.J_L_OBJECT, null);\n@@ -313,0 +329,1 @@\n+                    TypeKind tk = inst.typeKind();\n@@ -316,1 +333,1 @@\n-                                CoreOp.add(stack.pop(), operand);\n+                                unifyOperands(CoreOp::add, stack.pop(), operand, tk);\n@@ -318,1 +335,1 @@\n-                                CoreOp.sub(stack.pop(), operand);\n+                                unifyOperands(CoreOp::sub, stack.pop(), operand, tk);\n@@ -320,1 +337,1 @@\n-                                CoreOp.mul(stack.pop(), operand);\n+                                unifyOperands(CoreOp::mul, stack.pop(), operand, tk);\n@@ -322,1 +339,1 @@\n-                                CoreOp.div(stack.pop(), operand);\n+                                unifyOperands(CoreOp::div, stack.pop(), operand, tk);\n@@ -324,1 +341,1 @@\n-                                CoreOp.mod(stack.pop(), operand);\n+                                unifyOperands(CoreOp::mod, stack.pop(), operand, tk);\n@@ -330,1 +347,1 @@\n-                                CoreOp.and(stack.pop(), operand);\n+                                unifyOperands(CoreOp::and, stack.pop(), operand, tk);\n@@ -332,1 +349,1 @@\n-                                CoreOp.or(stack.pop(), operand);\n+                                unifyOperands(CoreOp::or, stack.pop(), operand, tk);\n@@ -334,1 +351,1 @@\n-                                CoreOp.xor(stack.pop(), operand);\n+                                unifyOperands(CoreOp::xor, stack.pop(), operand, tk);\n@@ -336,1 +353,1 @@\n-                                CoreOp.lshl(stack.pop(), operand);\n+                                CoreOp.lshl(stack.pop(), toInt(operand));\n@@ -338,1 +355,1 @@\n-                                CoreOp.ashr(stack.pop(), operand);\n+                                CoreOp.ashr(stack.pop(), toInt(operand));\n@@ -340,1 +357,7 @@\n-                                CoreOp.lshr(stack.pop(), operand);\n+                                CoreOp.lshr(stack.pop(), toInt(operand));\n+                        case LCMP ->\n+                                CoreOp.invoke(LCMP, stack.pop(), operand);\n+                        case FCMPL, FCMPG ->\n+                                CoreOp.invoke(FCMP, stack.pop(), operand);\n+                        case DCMPL, DCMPG ->\n+                                CoreOp.invoke(DCMP, stack.pop(), operand);\n@@ -410,0 +433,34 @@\n+                case InvokeDynamicInstruction inst when inst.bootstrapMethod().kind() == DirectMethodHandleDesc.Kind.STATIC\n+                                                     && inst.bootstrapMethod().owner().equals(CD_LambdaMetafactory)\n+                                                     && inst.bootstrapArgs().get(0) instanceof MethodTypeDesc mtd\n+                                                     && inst.bootstrapArgs().get(1) instanceof DirectMethodHandleDesc dmhd -> {\n+                    LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                            FunctionType.functionType(JavaType.type(mtd.returnType()), mtd.parameterList().stream().map(JavaType::type).toList()),\n+                            JavaType.type(inst.typeSymbol().returnType()));\n+                    ClassModel clm = codeModel.parent().orElseThrow().parent().orElseThrow();\n+                    if (dmhd.owner().equals(clm.thisClass().asSymbol())) {\n+                        \/\/ inline lambda impl method\n+                        MethodModel implMethod = clm.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())\n+                                                                            && m.methodTypeSymbol().equals(dmhd.invocationType())).findFirst().orElseThrow();\n+                        var captureTypes = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n+                        for (int ci = captureTypes.length - 1; ci >= 0; ci--) {\n+                            captureTypes[ci] = stack.pop();\n+                        }\n+                        for (int ci = captureTypes.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n+                            stack.pop();\n+                        }\n+                        stack.push(op(lambda.body(eb -> new BytecodeLift(eb, implMethod, captureTypes).lift())));\n+                    } else {\n+                        \/\/ lambda call to a MH\n+                        stack.push(op(lambda.body(eb -> {\n+                            MethodTypeDesc mt = dmhd.invocationType();\n+                            eb.op(CoreOp._return(eb.op(CoreOp.invoke(\n+                                    MethodRef.method(\n+                                            JavaType.type(dmhd.owner()),\n+                                            dmhd.methodName(),\n+                                            JavaType.type(mt.returnType()),\n+                                            mt.parameterList().stream().map(JavaType::type).toList()),\n+                                    eb.parameters().stream().toArray(Value[]::new)))));\n+                        })));\n+                    }\n+                }\n@@ -557,0 +614,34 @@\n+    private void liftSwitch(Label defaultTarget, List<SwitchCase> cases) {\n+        Value v = toInt(stack.pop());\n+        SwitchCase last = cases.getLast();\n+        for (SwitchCase sc : cases) {\n+            Block.Builder next = sc == last ? blockMap.get(defaultTarget) : newBlock();\n+            op(CoreOp.conditionalBranch(\n+                    op(CoreOp.eq(v, op(CoreOp.constant(JavaType.INT, sc.caseValue())))),\n+                    blockMap.get(sc.target()).successor(List.copyOf(stack)),\n+                    next.successor(List.copyOf(stack))));\n+            moveTo(next);\n+        }\n+        endOfFlow();\n+    }\n+\n+    private static TypeElement valueType(Value v) {\n+        var t = v.type();\n+        while (t instanceof VarType vt) t = vt.valueType();\n+        return t;\n+    }\n+\n+    private Op unifyOperands(BiFunction<Value, Value, Op> operator, Value v1, Value v2, TypeKind tk) {\n+        if (tk != TypeKind.IntType || valueType(v1).equals(valueType(v2))) return operator.apply(v1, v2);\n+        return operator.apply(toInt(v1), toInt(v2));\n+    }\n+\n+    private Value toInt(Value v) {\n+        return valueType(v).equals(PrimitiveType.INT) ? v : op(CoreOp.conv(PrimitiveType.INT, v));\n+    }\n+\n+    private Value zero(Value otherOperand) {\n+       var vt = valueType(otherOperand);\n+        return op(CoreOp.constant(vt, vt.equals(PrimitiveType.BOOLEAN) ? false : 0));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":133,"deletions":42,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n@@ -73,1 +71,0 @@\n-    @SkipLift\n@@ -82,1 +79,0 @@\n-    @SkipLift\n@@ -91,1 +87,0 @@\n-    @SkipLift\n@@ -129,1 +124,0 @@\n-    @SkipLift\n@@ -135,1 +129,0 @@\n-    @SkipLift\n@@ -141,1 +134,0 @@\n-    @SkipLift\n@@ -157,1 +149,0 @@\n-    @SkipLift\n@@ -163,1 +154,0 @@\n-    @SkipLift\n@@ -169,1 +159,0 @@\n-    @SkipLift\n@@ -175,1 +164,0 @@\n-    @SkipLift\n@@ -181,1 +169,0 @@\n-    @SkipLift\n@@ -187,1 +174,0 @@\n-    @SkipLift\n@@ -341,1 +327,0 @@\n-    @SkipLift\n@@ -395,1 +380,0 @@\n-    @SkipLift\n@@ -401,1 +385,0 @@\n-    @SkipLift\n@@ -407,1 +390,0 @@\n-    @SkipLift\n@@ -413,1 +395,0 @@\n-    @SkipLift\n@@ -419,1 +400,0 @@\n-    @SkipLift\n@@ -421,1 +401,1 @@\n-        return consume(i, a -> consume(a, b -> a + b + j) + s.length());\n+        return consume(i, a -> consume(a, b -> a + b + j - s.length()) + s.length());\n@@ -425,1 +405,0 @@\n-    @SkipLift\n@@ -427,1 +406,1 @@\n-        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j) + s.length());\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j - s.length()) + s.length());\n@@ -431,1 +410,0 @@\n-    @SkipLift\n@@ -436,2 +414,34 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface SkipLift {}\n+    @CodeReflection\n+    static boolean compareLong(long i, long j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareFloat(float i, float j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareDouble(double i, double j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static int lookupSwitch(int i) {\n+        return switch (1000 * i) {\n+            case 1000 -> 1;\n+            case 2000 -> 2;\n+            case 3000 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    static int tableSwitch(int i) {\n+        return switch (i) {\n+            case 1 -> 1;\n+            case 2 -> 2;\n+            case 3 -> 3;\n+            default -> 0;\n+        };\n+    }\n@@ -481,4 +491,4 @@\n-        initTestArgs(values(1, 2, 3, 4), int.class, Integer.class);\n-        initTestArgs(values((byte)1, (byte)2, (byte)3, (byte)4), byte.class, Byte.class);\n-        initTestArgs(values((short)1, (short)2, (short)3, (short)4), short.class, Short.class);\n-        initTestArgs(values((char)1, (char)2, (char)3, (char)4), char.class, Character.class);\n+        initTestArgs(values(1, 2, 4), int.class, Integer.class);\n+        initTestArgs(values((byte)1, (byte)3, (byte)4), byte.class, Byte.class);\n+        initTestArgs(values((short)1, (short)2, (short)3), short.class, Short.class);\n+        initTestArgs(values((char)2, (char)3, (char)4), char.class, Character.class);\n@@ -487,3 +497,3 @@\n-        initTestArgs(values(1l, 2l, 3l, 4l), long.class, Long.class);\n-        initTestArgs(values(1f, 2f, 3f, 4f), float.class, Float.class);\n-        initTestArgs(values(1d, 2d, 3d, 4d), double.class, Double.class);\n+        initTestArgs(values(1l, 2l, 4l), long.class, Long.class);\n+        initTestArgs(values(1f, 3f, 4f), float.class, Float.class);\n+        initTestArgs(values(1d, 2d, 3d), double.class, Double.class);\n@@ -519,3 +529,0 @@\n-        if (d.testMethod.getAnnotation(SkipLift.class) != null) {\n-            throw new SkipException(\"skipped\");\n-        }\n@@ -526,1 +533,4 @@\n-            System.out.println(\"Lift failed, expected:\");\n+            ClassPrinter.toYaml(ClassFile.of().parse(TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes())\n+                    .methods().stream().filter(m -> m.methodName().equalsString(d.testMethod().getName())).findAny().get(),\n+                    ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+            System.out.println(\"Lift failed, compiled model:\");\n@@ -534,0 +544,3 @@\n+            System.out.println(\"Compiled model:\");\n+            d.testMethod.getCodeModel().ifPresent(f -> f.writeTo(System.out));\n+            System.out.println(\"Lifted model:\");\n@@ -540,1 +553,1 @@\n-        Object ret = Interpreter.invoke(func, args);\n+        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, args);\n@@ -560,1 +573,6 @@\n-        CoreOp.FuncOp lfunc = func.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n+        CoreOp.FuncOp lfunc;\n+        try {\n+            lfunc = func.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n+        } catch (UnsupportedOperationException uoe) {\n+            throw new SkipException(\"lowering caused:\", uoe);\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":57,"deletions":39,"binary":false,"changes":96,"status":"modified"}]}