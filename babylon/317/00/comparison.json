{"files":[{"patch":"@@ -157,10 +157,0 @@\n-    unsigned long ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n-    unsigned long ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n-\n-    if (ifacefacade1 != 0x1face00000facadeL && ifacefacade1 != ifacefacade2) {\n-        std::cerr<<\"End of buf marker before HtoD\"<< std::hex << ifacefacade1 << ifacefacade2<< \" buffer corrupt !\" <<std::endl\n-                <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n-\n-\n@@ -190,8 +180,0 @@\n-    unsigned long ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n-    unsigned long ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n-\n-    if (ifacefacade1 != 0x1face00000facadeL || ifacefacade1 != ifacefacade2) {\n-        std::cerr<<\"end of buf marker before  DtoH\"<< std::hex << ifacefacade1 << ifacefacade2<< std::dec<< \" buffer corrupt !\"<<std::endl\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n@@ -212,2 +194,0 @@\n-    ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n-    ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n@@ -215,5 +195,0 @@\n-    if (ifacefacade1 != 0x1face00000facadeL || ifacefacade1 != ifacefacade2) {\n-        std::cerr<<\"end of buf marker after  DtoH\"<< std::hex << ifacefacade1 << ifacefacade2<< std::dec<< \" buffer corrupt !\"<<std::endl\n-                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n-        exit(-1);\n-    }\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+\n@@ -71,0 +72,3 @@\n+\n+\n+\n@@ -124,1 +128,1 @@\n-        std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n+        std::cerr << \"opencl issue, we might have leaked events!\" << std::endl;\n@@ -138,3 +142,13 @@\n-                     if (INFO){\n-                        if (arg->value.buffer.state == 1) { \/\/Java described this as dirty\n-                            std::cout << \"JAVA_DIRTY !\"<<std::endl;\n+                   IfaceBufferBits_s *ifacebufferbitz = IfaceBufferBits_s::of(\n+                      arg->value.buffer.memorySegment,\n+                      arg->value.buffer.sizeInBytes\n+                   );\n+                   if (ifacebufferbitz->ok()){\n+                      if (INFO){\n+                         if (ifacebufferbitz->isJavaDirty()){\n+                             printf(\" java dirty (javaDirty:%08x)\\n\", ifacebufferbitz->payload.javaDirty);\n+                         }else{\n+                            printf(\" NOT java dirty (javaDirty:%08x)\\n\", ifacebufferbitz->payload.javaDirty);\n+                         }\n+                         if (ifacebufferbitz->isGpuDirty()){\n+                            printf(\" gpu dirty (gpuDirty:%08x)\\n\", ifacebufferbitz->payload.gpuDirty);\n@@ -142,3 +156,12 @@\n-                            std::cout << \"NOT JAVA_DIRTY\"<<std::endl;\n-                          }\n-                     }\n+                            printf(\" NOT gpu dirty (gpuDirty:%08x)\\n\", ifacebufferbitz->payload.gpuDirty);\n+                         }\n+                      }\n+                   }else{\n+                      printf(\"bad magic \\n\");\n+                      printf(\"(magic1:%016lx,\", ifacebufferbitz->magic1);\n+                      printf(\"javaDirty:%08x,\", ifacebufferbitz->payload.javaDirty);\n+                      printf(\"gpuDirty:%08x,\", ifacebufferbitz->payload.gpuDirty);\n+                      printf(\"unused[0]:%08x,\", ifacebufferbitz->payload.unused[0]);\n+                      printf(\"unused[1]:%08x,\", ifacebufferbitz->payload.unused[1]);\n+                      printf(\"magic2:%016lx)\\n\", ifacebufferbitz->magic2);\n+                   }\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -78,0 +78,29 @@\n+ struct IfaceBufferPayload_s{\n+     int javaDirty;\n+     int gpuDirty;\n+     int unused[2];\n+ };\n+\n+ \/\/ hat iface buffer bits\n+ \/\/ hat iface bffa   bits\n+ \/\/ 4a7 1face bffa   b175\n+ #define MAGIC 0x4a71facebffab175\n+\n+ struct IfaceBufferBits_s{\n+   long magic1;\n+   IfaceBufferPayload_s payload;\n+   long magic2;\n+   bool ok(){\n+      return magic1 == MAGIC && magic2 == MAGIC;\n+   }\n+   bool isJavaDirty(){\n+      return payload.javaDirty != 0;\n+   }\n+   bool isGpuDirty(){\n+      return payload.gpuDirty != 0;\n+   }\n+   static IfaceBufferBits_s* of(void *ptr, size_t sizeInBytes){\n+      return (IfaceBufferBits_s*) (((char*)ptr)+sizeInBytes-sizeof(IfaceBufferBits_s));\n+   }\n+};\n+\n@@ -83,1 +112,1 @@\n-    u8_t state;           \/\/ 0=UNKNOWN\/1=GPUDIRTY\/2=JAVADIRTY\n+  \/\/  u8_t state;           \/\/ 0=UNKNOWN\/1=GPUDIRTY\/2=JAVADIRTY\n@@ -113,3 +142,0 @@\n-    \/\/ void * vendorPtr;\n-    \/\/ int schemaLen\n-    \/\/ char schema[schemaLen]\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.ifacemapper.MappableIface.*;\n@@ -103,1 +104,1 @@\n-        public static void life(KernelContext kc, Control control, CellGrid cellGrid) {\n+        public static void life(@RO KernelContext kc, @RO Control control, @RW CellGrid cellGrid) {\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.buffer.Buffer;\n@@ -36,0 +37,1 @@\n+\n@@ -37,0 +39,1 @@\n+import static hat.ifacemapper.MappableIface.*;\n@@ -40,1 +43,1 @@\n-    public static void mandel(KernelContext kc, S32Array2D s32Array2D, S32Array pallette, float offsetx, float offsety, float scale) {\n+    public static void mandel(@RO KernelContext kc, @RW S32Array2D s32Array2D, @RO S32Array pallette, float offsetx, float offsety, float scale) {\n@@ -84,0 +87,4 @@\n+       \/\/ var tail = Buffer.Tail.of(s32Array2D);\n+\n+       \/\/ System.out.println(\"java dirty \"+tail.javaDirty());\n+       \/\/ System.out.println(\"gpu dirty \"+tail.gpuDirty());\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import hat.buffer.After;\n-import hat.buffer.BoundBy;\n-import hat.buffer.BufferAllocator;\n-import hat.buffer.Length;\n-import hat.buffer.SelectedBy;\n+\n@@ -36,2 +32,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n@@ -78,1 +72,1 @@\n-            @SelectedBy(\"hasValue\")\n+\n@@ -96,1 +90,1 @@\n-        @Length(3)\n+\n@@ -133,1 +127,1 @@\n-    @After(\"width\")\n+\n@@ -138,1 +132,1 @@\n-    @After(\"height\")\n+\n@@ -143,1 +137,1 @@\n-    @BoundBy(\"featureCount\")\n+\n@@ -150,1 +144,1 @@\n-    @BoundBy(\"stageCount\")\n+\n@@ -155,1 +149,0 @@\n-\/\/void treeCount(int treeCount);\n@@ -157,1 +150,0 @@\n-    @BoundBy(\"treeCount\")\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import hat.buffer.After;\n-import hat.buffer.Atomic;\n-import hat.buffer.BoundBy;\n@@ -49,1 +46,1 @@\n-    @Atomic\n+\n@@ -53,1 +50,1 @@\n-    @After(\"atomicResultTableCount\")\n+\n@@ -56,1 +53,1 @@\n-    @BoundBy(\"length\")\n+\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -158,3 +158,3 @@\n-    public void clearRuntimeInfo() {\n-        runtimeInfo = new RuntimeInfo();\n-    }\n+   \/\/ public void clearRuntimeInfo() {\n+     \/\/   runtimeInfo = new RuntimeInfo();\n+   \/\/ }\n@@ -162,4 +162,4 @@\n-    public static class RuntimeInfo {\n-        public Set<Buffer> javaDirty = new HashSet<>();\n-        Set<Buffer> gpuDirty = new HashSet<>();\n-    }\n+  \/\/  public static class RuntimeInfo {\n+      \/\/  public Set<Buffer> javaDirty = new HashSet<>();\n+       \/\/ Set<Buffer> gpuDirty = new HashSet<>();\n+  \/\/  }\n@@ -167,1 +167,1 @@\n-    public RuntimeInfo runtimeInfo = null;\n+  \/\/  public RuntimeInfo runtimeInfo = null;\n@@ -171,3 +171,3 @@\n-        if (runtimeInfo.gpuDirty.contains(b)) {\n-            throw new IllegalStateException(\"We want to mutate a buffer on the java side but it is marked as gpu dirty.\");\n-        }\n+       \/\/ if (runtimeInfo.gpuDirty.contains(b)) {\n+          \/\/  throw new IllegalStateException(\"We want to mutate a buffer on the java side but it is marked as gpu dirty.\");\n+       \/\/ }\n@@ -178,1 +178,1 @@\n-        runtimeInfo.javaDirty.add(b);\n+       \/\/ runtimeInfo.javaDirty.add(b);\n@@ -183,3 +183,3 @@\n-        if (runtimeInfo.gpuDirty.contains(b)) {\n-            throw new IllegalStateException(\"We want to access a buffer on the java side but it is marked as gpu dirty.\");\n-        }\n+      \/\/  if (runtimeInfo.gpuDirty.contains(b)) {\n+        \/\/    throw new IllegalStateException(\"We want to access a buffer on the java side but it is marked as gpu dirty.\");\n+       \/\/ }\n@@ -194,3 +194,3 @@\n-        if (runtimeInfo.gpuDirty.contains(b)) {\n-            throw new IllegalStateException(\"We called a method which escapes a buffer on the java side but it is marked as gpu dirty.\");\n-        }\n+       \/\/ if (runtimeInfo.gpuDirty.contains(b)) {\n+           \/\/ throw new IllegalStateException(\"We called a method which escapes a buffer on the java side but it is marked as gpu dirty.\");\n+      \/\/  }\n@@ -201,1 +201,1 @@\n-        runtimeInfo.javaDirty.add(b);\n+      \/\/  runtimeInfo.javaDirty.add(b);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph.computeContext.runtimeInfo, ndRangeAndArgs);\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,  ndRangeAndArgs);\n@@ -69,1 +69,1 @@\n-            ArgArray.update(argArray, kernelCallGraph.computeContext.runtimeInfo, args);\n+            ArgArray.update(argArray, args);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        computeContext.clearRuntimeInfo();\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph.computeContext.runtimeInfo, ndRangeAndArgs);\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,  ndRangeAndArgs);\n@@ -70,1 +70,1 @@\n-            ArgArray.update(argArray, kernelCallGraph.computeContext.runtimeInfo, args);\n+            ArgArray.update(argArray,  args);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        computeContext.clearRuntimeInfo();\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface After {\n-    String value();\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/After.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -43,2 +43,1 @@\n-\n-                @After(\"address\") long bytes();\n+                long bytes();\n@@ -46,2 +45,0 @@\n-\n-                @After(\"bytes\")\n@@ -50,2 +47,0 @@\n-\n-                @After(\"vendorPtr\")\n@@ -55,3 +50,0 @@\n-                @After(\"access\")\n-                byte state();\n-                void state(byte state);\n@@ -106,1 +98,1 @@\n-        @After(\"idx\") byte variant();\n+         byte variant();\n@@ -109,1 +101,1 @@\n-        @SelectedBy(\"variant\") @Pad(11) Value value();\n+       Value value();\n@@ -219,1 +211,1 @@\n-    @BoundBy(\"argc\") @Pad(12)\n+\n@@ -222,1 +214,1 @@\n-    @After(\"arg\")\n+\n@@ -226,1 +218,0 @@\n-    @After(\"vendorPtr\")\n@@ -229,1 +220,0 @@\n-    @BoundBy(\"schemaLen\")\n@@ -240,2 +230,2 @@\n-                                                            .fields(\"address\",\"bytes\",\"vendorPtr\",\"access\",\"state\")\n-                                                            .pad((int)(16 - JAVA_BYTE.byteSize() - JAVA_BYTE.byteSize()))\n+                                                            .fields(\"address\",\"bytes\",\"vendorPtr\",\"access\")\n+                                                            .pad((int)(16 - JAVA_BYTE.byteSize()\/* - JAVA_BYTE.byteSize()*\/))\n@@ -265,1 +255,1 @@\n-    static ArgArray create(Accelerator accelerator,ComputeContext.RuntimeInfo runtimeInfo, Object... args) {\n+    static ArgArray create(Accelerator accelerator, Object... args) {\n@@ -295,1 +285,1 @@\n-        update(argArray, runtimeInfo,args);\n+        update(argArray,args);\n@@ -299,1 +289,1 @@\n-    static void update(ArgArray argArray, ComputeContext.RuntimeInfo runtimeInfo, Object... args) {\n+    static void update(ArgArray argArray,  Object... args) {\n@@ -322,1 +312,0 @@\n-                    buf.state(runtimeInfo.javaDirty.contains(buffer)?javaDirty:javaClean);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface Atomic {\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Atomic.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface BoundBy {\n-    String[] value();\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BoundBy.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n@@ -39,0 +41,1 @@\n+import static hat.ifacemapper.SegmentMapper.MAGIC;\n@@ -79,0 +82,80 @@\n+\n+    \/*\n+     * A hack for accessing the tailbits from a memory segment.  Hopefully I can get this from\n+     * ifacemapper\n+     * See SegmentMapper allocate and backend_ffi_shared\/include\/shared.h\n+\n+        struct ifacebufferpayload_t{\n+          int javaDirty;\n+          int gpuDirty;\n+          int unused[2];\n+        };\n+\n+        struct ifacebufferbitz_t{\n+           long magic1; \/\/ MAGIC\n+           ifacebufferpayload_t payload;\n+           long magic2; \/\/ MAGIC\n+        }\n+     *\/\n+\n+    record Tail(Buffer buffer, MemorySegment segment, long offset ) implements MappableIface {\n+\n+        public static final long tailLength = 4 * ValueLayout.JAVA_LONG.byteSize();\n+        public static final long magic1Offset =0;\n+        public static final long magic2Offset =3 * ValueLayout.JAVA_LONG.byteSize();\n+        public static final long javaDirtyOffset =ValueLayout.JAVA_LONG.byteSize();\n+        public static final long gpuDirtyOffset =ValueLayout.JAVA_LONG.byteSize()+ValueLayout.JAVA_INT.byteSize();\n+\n+        public static Tail of(Buffer buffer) {\n+            MemorySegment segment = getMemorySegment(buffer);\n+            return new Tail(buffer, segment, segment.byteSize() - tailLength);\n+        }\n+        public long magic1(){\n+            return segment.get(ValueLayout.JAVA_LONG, offset +magic1Offset);\n+        }\n+        public int javaDirty(){\n+            return segment.get(ValueLayout.JAVA_INT, offset +javaDirtyOffset);\n+        }\n+        public boolean isJavaDirty(){\n+            return javaDirty()!=0;\n+        }\n+        public int gpuDirty(){\n+            return segment.get(ValueLayout.JAVA_INT, offset +gpuDirtyOffset);\n+        }\n+        public boolean isGpuDirty(){\n+            return gpuDirty()!=0;\n+        }\n+\n+        public long magic2(){\n+            return segment.get(ValueLayout.JAVA_LONG, offset+ magic2Offset);\n+        }\n+        public boolean isOK() {\n+            if (magic1() != MAGIC) {\n+                System.out.println(\"magic1=\" + magic1()+ \" != \" + MAGIC);\n+                return false;\n+            }\n+            if (magic2() != MAGIC) {\n+                System.out.println(\"magic2=\" + magic2() + \" != \" + MAGIC);\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+\n+    default boolean isJavaDirty(){\n+        var seg = getMemorySegment(this);\n+        if (seg != null){\n+            long sizeInBytes = seg.byteSize();\n+            long magic1 = seg.get(ValueLayout.JAVA_LONG, sizeInBytes-4*ValueLayout.JAVA_LONG.byteSize());\n+\n+            if (magic1 != MAGIC){\n+                System.out.println(\"magic1=\" + magic1+\" != \"+MAGIC);\n+            }else{\n+                System.out.println(\"magic1=\" + magic1+\" != \"+MAGIC);\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-    @BoundBy(\"length\")\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    @After(\"width\")\n+\n@@ -42,1 +42,1 @@\n-    @BoundBy({\"width\",\"height\"})\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface Length {\n-    long value();\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Length.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface Pad {\n-    long value();\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Pad.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface SelectedBy {\n-    String[] value();\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/SelectedBy.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -30,2 +30,0 @@\n-\n-import java.lang.reflect.Method;\n@@ -34,0 +32,2 @@\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n@@ -35,0 +35,5 @@\n+import jdk.incubator.code.type.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n@@ -92,1 +97,7 @@\n-\n+        kernelReachableResolvedMethodCall.funcOpWrapper().selectAssignments(varOpWrapper -> {\n+            if (varOpWrapper.isIfaceAssignment()){\n+                \/\/ We might be aliasing a buffer which is 'frowned upon'\n+                System.out.println(\"Kernel appears to be aliasing a buffer  \" + varOpWrapper.javaType() + \" name \" + varOpWrapper.varName());\n+                System.out.println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Yep\");\n+            }\n+        });\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n@@ -28,0 +33,9 @@\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.PARAMETER)\n+    @interface RW {}\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.PARAMETER)\n+    @interface RO {}\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.PARAMETER)\n+    @interface WO {}\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MappableIface.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-\n+    static final long MAGIC =0x4a71facebffab175L;\n@@ -347,6 +347,24 @@\n-if (boundSchema == null) {\n-    throw new IllegalStateException(\"we must have a bound schema\");\n-}\n-        \/\/ To help debug we add a tail marker\n-        \/\/ We add 16 bytes and then pad to the next 16 bytes\n-        \/\/ and request alignment on 16 byte boundary\n+        if (boundSchema == null) {\n+            throw new IllegalStateException(\"we must have a bound schema\");\n+         }\n+        \/\/ hat iface buffer bits\n+        \/\/ hat iface bffa   bits\n+        \/\/ 4a7 1face bffa   b175\n+\n+        \/*\n+         We adjust size to next 16 byte boundary and then add sizeof ifacebufferbitz bytes\n+\n+         See backend_ffi_shared\/include\/shared.h\n+\n+        struct ifacebufferpayload_t{\n+          int javaDirty;\n+          int gpuDirty;\n+          int unused[2];\n+        };\n+\n+        struct ifacebufferbitz_t{\n+           long magic1; \/\/ MAGIC\n+           ifacebufferpayload_t payload;\n+           long magic2; \/\/ MAGIC\n+        }\n+         *\/\n@@ -361,3 +379,8 @@\n-        var segment = arena.allocate(extendedByteSizePaddedTo16Bytes, 16);\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-16,0x1face00000facadeL);\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-8, 0x1face00000facadeL);\n+        var segment = arena.allocate(extendedByteSizePaddedTo16Bytes\n+                +ValueLayout.JAVA_LONG.byteSize()*2, 16);\n+\n+\n+        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-2*ValueLayout.JAVA_LONG.byteSize(),  MAGIC);\/\/hatifacebffabits\n+        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-1*ValueLayout.JAVA_LONG.byteSize(),  0x0000000000000000L);\n+        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes+0*ValueLayout.JAVA_LONG.byteSize(),  0x0000000000000000L);\/\/hatifacebffabits\n+        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes+1*ValueLayout.JAVA_LONG.byteSize(),  MAGIC);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.reflect.Field;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.code.type.ClassType;\n@@ -31,2 +31,1 @@\n-public class FieldLoadOpWrapper extends FieldAccessOpWrapper<CoreOp.FieldAccessOp.FieldLoadOp> implements LoadOpWrapper {\n-\n+import java.lang.reflect.Field;\n@@ -34,0 +33,1 @@\n+public class FieldLoadOpWrapper extends FieldAccessOpWrapper<CoreOp.FieldAccessOp.FieldLoadOp> implements LoadOpWrapper {\n@@ -39,14 +39,11 @@\n-        TypeElement te = fieldType();\n-        String fieldName = fieldName();\n-        try {\n-            Class<?> clazz = Class.forName(te.toString());\n-            Field field = clazz.getField(fieldName);\n-            field.setAccessible(true);\n-           return  field.get(null);\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        } catch (NoSuchFieldException e) {\n-            throw new RuntimeException(e);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n+        if (fieldType() instanceof ClassType classType) {\n+            Class<?> clazz = (Class<?>) classTypeToType(classType);\n+            try {\n+                Field field = clazz.getField(fieldName());\n+                field.setAccessible(true);\n+                return field.get(null);\n+            } catch (NoSuchFieldException e) {\n+                throw new RuntimeException(e);\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n@@ -54,0 +51,1 @@\n+        throw new RuntimeException(\"Could not find field value\" + fieldName() + \" in \" + fieldType());\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.code.type.ClassType;\n@@ -154,6 +155,3 @@\n-        try {\n-            JavaType refType = javaRefType();\n-            String className = refType.toString();\n-            Class<?> javaRefClass = Class.forName(className);\n-            return Optional.of(javaRefClass);\n-        } catch (ClassNotFoundException e) {\n+        if (javaRefType() instanceof ClassType classType) {\n+            return Optional.of((Class<?>)classTypeToType(classType));\n+        }else{\n@@ -165,5 +163,3 @@\n-        try {\n-            String className = javaReturnType().toString();\n-            Class<?> javaRefClass = Class.forName(className);\n-            return Optional.of(javaRefClass);\n-        } catch (ClassNotFoundException e) {\n+        if (javaReturnType() instanceof ClassType classType) {\n+            return Optional.of((Class<?>)classTypeToType(classType));\n+        }else{\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -38,0 +39,3 @@\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Type;\n@@ -137,0 +141,8 @@\n+    public void selectAssignments(Consumer<VarOpWrapper> consumer) {\n+        this.op.traverse(null, (map, op) -> {\n+            if (op instanceof CoreOp.VarOp varOp) {\n+                consumer.accept(wrap(varOp));\n+            }\n+            return map;\n+        });\n+    }\n@@ -241,1 +253,11 @@\n-        return  (isAssignable(javaType, Buffer.class, Buffer.Struct.class, Buffer.Union.class));\n+        return  (isAssignable(javaType, MappableIface.class));\n+    }\n+    public static Type classTypeToType(ClassType classType){\n+        Type javaTypeClass = null;\n+        try {\n+            javaTypeClass = classType.resolve(MethodHandles.lookup());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return javaTypeClass;\n+\n@@ -245,4 +267,3 @@\n-            try {\n-                Class<?> javaTypeClass = Class.forName(classType.toString());\n-                for (Class<?> clazz : classes) {\n-                    if (clazz.isAssignableFrom(javaTypeClass)) {\n+            Type type = classTypeToType(classType);\n+            for (Class<?> clazz : classes) {\n+                if (clazz.isAssignableFrom((Class<?>) type)) {\n@@ -250,1 +271,0 @@\n-                    }\n@@ -252,2 +272,0 @@\n-            } catch (ClassNotFoundException _) {\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+\n+    public boolean isIfaceAssignment() {\n+        return OpWrapper.isIface(javaType());\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}