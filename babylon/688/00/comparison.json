{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess.ReflectableLambdaInfo;\n@@ -72,1 +73,1 @@\n-    final MethodHandle quotableOpGetter;       \/\/ A getter method handle that is used to retrieve the\n+    final ReflectableLambdaInfo reflectableLambdaInfo;       \/\/ A holder for information pertinent to a reflectable lambda\n@@ -110,3 +111,1 @@\n-     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n-     *                   method handle that is used to retrieve the string representation of the\n-     *                   quotable lambda's associated intermediate representation.\n+     * @param reflectableLambdaInfo a holder for information pertinent to a reflectable lambda\n@@ -125,1 +124,1 @@\n-                                        MethodHandle reflectiveField)\n+                                        ReflectableLambdaInfo reflectableLambdaInfo)\n@@ -186,1 +185,1 @@\n-        this.quotableOpGetter = reflectiveField;\n+        this.reflectableLambdaInfo = reflectableLambdaInfo;\n@@ -214,1 +213,1 @@\n-        if (reflectiveField != null) {\n+        if (reflectableLambdaInfo != null) {\n@@ -216,1 +215,1 @@\n-                quotableOpGetterInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+                quotableOpGetterInfo = caller.revealDirect(reflectableLambdaInfo.opHandle()); \/\/ may throw SecurityException\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess.ReflectableLambdaInfo;\n@@ -44,3 +45,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.module.Configuration;\n-import java.lang.module.ModuleFinder;\n@@ -163,1 +161,1 @@\n-                                       MethodHandle reflectiveField)\n+                                       ReflectableLambdaInfo reflectableLambdaInfo)\n@@ -167,1 +165,1 @@\n-              isSerializable, altInterfaces, altMethods, reflectiveField);\n+              isSerializable, altInterfaces, altMethods, reflectableLambdaInfo);\n@@ -339,2 +337,2 @@\n-                if (quotableOpGetter != null) {\n-                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n+                if (reflectableLambdaInfo != null) {\n+                    clb.withField(quotedInstanceFieldName, reflectableLambdaInfo.quotedClass(), ACC_PRIVATE + ACC_FINAL);\n@@ -369,1 +367,1 @@\n-                if (quotableOpGetter != null) {\n+                if (reflectableLambdaInfo != null) {\n@@ -380,2 +378,2 @@\n-            if (useImplMethodHandle || quotableOpGetter != null) {\n-                classdata = quotableOpGetter == null ?\n+            if (useImplMethodHandle || reflectableLambdaInfo != null) {\n+                classdata = reflectableLambdaInfo == null ?\n@@ -383,1 +381,1 @@\n-                        List.of(implementation, quotableOpGetter, CodeReflectionSupport.QUOTED_EXTRACT_OP_MH);\n+                        List.of(implementation, reflectableLambdaInfo.opHandle(), reflectableLambdaInfo.extractOpHandle());\n@@ -396,1 +394,1 @@\n-        if (!(factoryType.parameterCount() == 0 && disableEagerInitialization) && quotableOpGetter == null) {\n+        if (!(factoryType.parameterCount() == 0 && disableEagerInitialization) && reflectableLambdaInfo == null) {\n@@ -412,1 +410,1 @@\n-                if (quotableOpGetter != null) {\n+                if (reflectableLambdaInfo != null) {\n@@ -419,1 +417,1 @@\n-                    ClassDesc funcOpClassDesc = CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get();\n+                    ClassDesc funcOpClassDesc = reflectableLambdaInfo.funcOpClass();\n@@ -458,1 +456,1 @@\n-                        if (quotableOpGetter != null) {\n+                        if (reflectableLambdaInfo != null) {\n@@ -475,1 +473,1 @@\n-                        CodeReflectionSupport.FUNC_OP_CLASS.describeConstable().get());\n+                        reflectableLambdaInfo.funcOpClass());\n@@ -495,41 +493,2 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.QUOTED_EXTRACT_OP_MH.type()))\n-           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted);\n-    }\n-\n-    static class CodeReflectionSupport {\n-        static final Class<?> QUOTED_CLASS;\n-        static final MethodHandle QUOTED_EXTRACT_OP_MH;\n-        static final Class<?> FUNC_OP_CLASS;\n-\n-        static {\n-            try {\n-                ModuleLayer layer = codeLayer();\n-                ClassLoader cl = layer.findLoader(\"jdk.incubator.code\");\n-                QUOTED_CLASS = cl.loadClass(\"jdk.incubator.code.Quoted\");\n-                FUNC_OP_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n-                QUOTED_EXTRACT_OP_MH = Lookup.IMPL_LOOKUP.findStatic(QUOTED_CLASS, \"extractOp\",\n-                        MethodType.methodType(QUOTED_CLASS, FUNC_OP_CLASS, Object[].class));\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError(ex);\n-            }\n-        }\n-\n-        static ModuleLayer codeLayer() {\n-            final ModuleLayer codeLayer;\n-            if (ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n-                \/\/ we are in an exploded build, so just use the boot layer\n-                return ModuleLayer.boot();\n-            } else if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent()) {\n-                \/\/ the code module is installed, but not in the boot layer, create a new layer which contains it\n-                ModuleLayer parent = ModuleLayer.boot();\n-                Configuration cf = parent.configuration()\n-                        .resolve(ModuleFinder.of(), ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n-                ClassLoader scl = ClassLoader.getSystemClassLoader();\n-                return parent.defineModulesWithOneLoader(cf, scl);\n-            } else {\n-                throw new IllegalStateException(\"jdk.incubator.code module not found\");\n-            }\n-        }\n-\n-        static final ClassDesc CD_Quoted = QUOTED_CLASS.describeConstable().get();\n-        static final MethodTypeDesc MTD_Quoted = MethodTypeDescImpl.ofValidated(CD_Quoted);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(reflectableLambdaInfo.extractOpHandle().type()))\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, reflectableLambdaInfo.quotedClass());\n@@ -598,1 +557,1 @@\n-        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PRIVATE + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethod(NAME_METHOD_QUOTED, MethodTypeDesc.of(reflectableLambdaInfo.quotedClass()), ACC_PRIVATE + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n@@ -602,1 +561,1 @@\n-                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, reflectableLambdaInfo.quotedClass())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":18,"deletions":59,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess.ReflectableLambdaInfo;\n@@ -273,4 +274,0 @@\n-    \/** Flag for {@link #altMetafactory} indicating the lambda object\n-     * must be inspectable using code reflection. *\/\n-    public static final int FLAG_QUOTABLE = 1 << 3;\n-\n@@ -350,11 +347,22 @@\n-        AbstractValidatingLambdaMetafactory mf;\n-        mf = new InnerClassLambdaMetafactory(Objects.requireNonNull(caller),\n-                                             Objects.requireNonNull(factoryType),\n-                                             Objects.requireNonNull(interfaceMethodName),\n-                                             Objects.requireNonNull(interfaceMethodType),\n-                                             Objects.requireNonNull(implementation),\n-                                             Objects.requireNonNull(dynamicMethodType),\n-                                             false,\n-                                             EMPTY_CLASS_ARRAY,\n-                                             EMPTY_MT_ARRAY,\n-                                 null);\n+        return metafactoryInternal(caller, interfaceMethodName, factoryType, interfaceMethodType,\n+                implementation, dynamicMethodType, null);\n+    }\n+\n+    static CallSite metafactoryInternal(MethodHandles.Lookup caller,\n+                                               String interfaceMethodName,\n+                                               MethodType factoryType,\n+                                               MethodType interfaceMethodType,\n+                                               MethodHandle implementation,\n+                                               MethodType dynamicMethodType,\n+                                               ReflectableLambdaInfo reflectableLambdaInfo)\n+            throws LambdaConversionException {\n+        AbstractValidatingLambdaMetafactory mf = new InnerClassLambdaMetafactory(Objects.requireNonNull(caller),\n+                Objects.requireNonNull(factoryType),\n+                Objects.requireNonNull(interfaceMethodName),\n+                Objects.requireNonNull(interfaceMethodType),\n+                Objects.requireNonNull(implementation),\n+                Objects.requireNonNull(dynamicMethodType),\n+                false,\n+                EMPTY_CLASS_ARRAY,\n+                EMPTY_MT_ARRAY,\n+                reflectableLambdaInfo);\n@@ -406,1 +414,0 @@\n-     *                          MethodHandle quotableField    \/\/ IF flags has QUOTABLE set\n@@ -430,4 +437,0 @@\n-     *     <li>{@code quotableField} is a\n-     *     {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter} method handle\n-     *     that is used to retrieve the string representation of the quotable lambda's associated\n-     *     intermediate representation.<\/li>\n@@ -502,0 +505,9 @@\n+        return altMetafactoryInternal(caller, interfaceMethodName, factoryType, null, args);\n+    }\n+\n+    static CallSite altMetafactoryInternal(MethodHandles.Lookup caller,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n+                                          ReflectableLambdaInfo reflectableLambdaInfo,\n+                                          Object... args)\n+            throws LambdaConversionException {\n@@ -513,2 +525,0 @@\n-        \/\/ Getter that returns the op of a Quotable instance\n-        MethodHandle quotableOpGetter = null;\n@@ -525,0 +535,1 @@\n+\n@@ -535,3 +546,0 @@\n-        if ((flags & FLAG_QUOTABLE) != 0) {\n-            quotableOpGetter = extractArg(args, argIndex++, MethodHandle.class);\n-        }\n@@ -555,9 +563,9 @@\n-                                                  factoryType,\n-                                                  interfaceMethodName,\n-                                                  interfaceMethodType,\n-                                                  implementation,\n-                                                  dynamicMethodType,\n-                                                  isSerializable,\n-                                                  altInterfaces,\n-                                                  altMethods,\n-                                                  quotableOpGetter);\n+                factoryType,\n+                interfaceMethodName,\n+                interfaceMethodType,\n+                implementation,\n+                dynamicMethodType,\n+                isSerializable,\n+                altInterfaces,\n+                altMethods,\n+                reflectableLambdaInfo);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":42,"deletions":34,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1648,0 +1648,13 @@\n+            @Override\n+            public CallSite metafactoryInternal(Lookup caller, String interfaceMethodName, MethodType factoryType,\n+                                                MethodType interfaceMethodType, MethodHandle implementation,\n+                                                MethodType dynamicMethodType, ReflectableLambdaInfo reflectableLambdaInfo) throws LambdaConversionException {\n+                return LambdaMetafactory.metafactoryInternal(caller, interfaceMethodName, factoryType,\n+                        interfaceMethodType, implementation, dynamicMethodType, reflectableLambdaInfo);\n+            }\n+\n+            @Override\n+            public CallSite altMetafactoryInternal(Lookup caller, String interfaceMethodName, MethodType factoryType,\n+                                                   ReflectableLambdaInfo reflectableLambdaInfo, Object... args) throws LambdaConversionException {\n+                return LambdaMetafactory.altMetafactoryInternal(caller, interfaceMethodName, factoryType, reflectableLambdaInfo, args);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -31,0 +34,2 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.LambdaConversionException;\n@@ -32,0 +37,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -173,0 +179,17 @@\n+\n+    record ReflectableLambdaInfo(ClassDesc quotedClass, ClassDesc funcOpClass,\n+                                 MethodHandle extractOpHandle, MethodHandle opHandle) { }\n+\n+    CallSite metafactoryInternal(MethodHandles.Lookup caller,\n+                                               String interfaceMethodName,\n+                                               MethodType factoryType,\n+                                               MethodType interfaceMethodType,\n+                                               MethodHandle implementation,\n+                                               MethodType dynamicMethodType,\n+                                               ReflectableLambdaInfo reflectableLambdaInfo) throws LambdaConversionException;\n+\n+    CallSite altMetafactoryInternal(MethodHandles.Lookup caller,\n+                                    String interfaceMethodName,\n+                                    MethodType factoryType,\n+                                    ReflectableLambdaInfo reflectableLambdaInfo,\n+                                    Object... args) throws LambdaConversionException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -838,1 +838,0 @@\n-        boolean isQuotable = isQuotable(tree);\n@@ -840,1 +839,1 @@\n-                isSerializable || isQuotable || bridges.length() > 1;\n+                isSerializable || bridges.length() > 1;\n@@ -861,1 +860,0 @@\n-            flags |= isQuotable ? FLAG_QUOTABLE : 0;\n@@ -884,4 +882,0 @@\n-            if (isQuotable) {\n-                MethodSymbol opMethodSym = tree.codeModel;\n-                staticArgs = staticArgs.append(opMethodSym.asHandle());\n-            }\n@@ -900,1 +894,9 @@\n-        return makeIndyCall(tree, syms.lambdaMetafactory, metafactoryName, staticArgs, indyType, indy_args, samSym.name);\n+        Name lambdaName = samSym.name;\n+        if (tree.codeReflectionInfo != null) {\n+            lambdaName = lambdaName\n+                    .append(names.fromString(\"=\"))\n+                    .append(tree.codeReflectionInfo.codeModel().name);\n+        }\n+        Type lambdaMetafactory = tree.codeReflectionInfo != null ?\n+                tree.codeReflectionInfo.reflectableLambdaMetafactory() : syms.lambdaMetafactory;\n+        return makeIndyCall(tree, lambdaMetafactory, metafactoryName, staticArgs, indyType, indy_args, lambdaName);\n@@ -954,4 +956,0 @@\n-    boolean isQuotable(JCFunctionalExpression tree) {\n-        return tree.codeModel != null;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -52,2 +51,0 @@\n-import javax.lang.model.type.TypeKind;\n-\n@@ -643,0 +640,1 @@\n+                tree.codeReflectionInfo != null ||\n@@ -685,1 +683,1 @@\n-                slam.codeModel = tree.codeModel;\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -816,1 +816,1 @@\n-        public MethodSymbol codeModel;\n+        public CodeReflectionInfo codeReflectionInfo;\n@@ -821,0 +821,2 @@\n+\n+        public record CodeReflectionInfo(MethodSymbol codeModel, Type reflectableLambdaMetafactory) { }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+import jdk.incubator.code.runtime.ReflectableLambdaMetafactory;\n+\n@@ -86,4 +88,4 @@\n-    private static final DirectMethodHandleDesc DMHD_LAMBDA_ALT_METAFACTORY = ofCallsiteBootstrap(\n-            LambdaMetafactory.class.describeConstable().orElseThrow(),\n-            \"altMetafactory\",\n-            CD_CallSite, CD_Object.arrayType());\n+    private static final DirectMethodHandleDesc DMHD_REFLECTABLE_LAMBDA_METAFACTORY = ofCallsiteBootstrap(\n+            ReflectableLambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"metafactory\",\n+            CD_CallSite, CD_MethodType, CD_MethodHandle, CD_MethodType);\n@@ -935,0 +937,2 @@\n+                            DirectMethodHandleDesc lambdaMetafactory = DMHD_LAMBDA_METAFACTORY;\n+                            String intfMethodName = intfMethod.getName();\n@@ -936,16 +940,2 @@\n-                                cob.invokedynamic(DynamicCallSiteDesc.of(\n-                                        DMHD_LAMBDA_ALT_METAFACTORY,\n-                                        intfMethod.getName(),\n-                                        MethodTypeDesc.of(intfType.toNominalDescriptor(),\n-                                                          captureTypes),\n-                                        toMTD(intfMethod),\n-                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n-                                                                  className,\n-                                                                  \"lambda$\" + lambdaIndex,\n-                                                                  mtd.insertParameterTypes(0, captureTypes)),\n-                                        mtd,\n-                                        LambdaMetafactory.FLAG_QUOTABLE,\n-                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n-                                                className,\n-                                                \"op$lambda$\" + lambdaIndex,\n-                                                OP_METHOD_DESC)));\n+                                lambdaMetafactory = DMHD_REFLECTABLE_LAMBDA_METAFACTORY;\n+                                intfMethodName = intfMethodName + \"=\" + \"op$lambda$\" + lambdaIndex;\n@@ -953,11 +943,0 @@\n-                            } else {\n-                                cob.invokedynamic(DynamicCallSiteDesc.of(\n-                                        DMHD_LAMBDA_METAFACTORY,\n-                                        intfMethod.getName(),\n-                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n-                                        toMTD(intfMethod),\n-                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n-                                                                  className,\n-                                                                  \"lambda$\" + lambdaIndex,\n-                                                                  mtd.insertParameterTypes(0, captureTypes)),\n-                                        mtd));\n@@ -965,0 +944,10 @@\n+                            cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                    lambdaMetafactory,\n+                                    intfMethodName,\n+                                    MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n+                                    toMTD(intfMethod),\n+                                    MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                              className,\n+                                                              \"lambda$\" + lambdaIndex,\n+                                                              mtd.insertParameterTypes(0, captureTypes)),\n+                                    mtd));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":20,"deletions":31,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    public final Type reflectableLambdaMetafactory;\n@@ -61,0 +62,1 @@\n+        reflectableLambdaMetafactory = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.runtime.ReflectableLambdaMetafactory\");\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression.CodeReflectionInfo;\n@@ -265,1 +266,1 @@\n-            tree.codeModel = opMethod.sym;\n+            tree.codeReflectionInfo = new CodeReflectionInfo(opMethod.sym, crSyms.reflectableLambdaMetafactory);\n@@ -294,1 +295,1 @@\n-            tree.codeModel = opMethod.sym;\n+            tree.codeReflectionInfo = new CodeReflectionInfo(opMethod.sym, crSyms.reflectableLambdaMetafactory);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+package jdk.incubator.code.runtime;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.JavaLangInvokeAccess.ReflectableLambdaInfo;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.LambdaConversionException;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.SerializedLambda;\n+\n+public class ReflectableLambdaMetafactory {\n+\n+    private ReflectableLambdaMetafactory() {\n+        \/\/ nope\n+    }\n+\n+    \/**\n+     * Facilitates the creation of simple \"function objects\" that implement one\n+     * or more interfaces by delegation to a provided {@link MethodHandle},\n+     * after appropriate type adaptation and partial evaluation of arguments.\n+     * Typically used as a <em>bootstrap method<\/em> for {@code invokedynamic}\n+     * call sites, to support the <em>lambda expression<\/em> and <em>method\n+     * reference expression<\/em> features of the Java Programming Language.\n+     *\n+     * <p>This is the standard, streamlined metafactory; additional flexibility\n+     * is provided by {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}.\n+     * A general description of the behavior of this method is provided\n+     * {@link LambdaMetafactory above}.\n+     *\n+     * <p>When the target of the {@code CallSite} returned from this method is\n+     * invoked, the resulting function objects are instances of a class which\n+     * implements the interface named by the return type of {@code factoryType},\n+     * declares a method with the name given by {@code interfaceMethodName} and the\n+     * signature given by {@code interfaceMethodType}.  It may also override additional\n+     * methods from {@code Object}.\n+     *\n+     * @param caller Represents a lookup context with the accessibility\n+     *               privileges of the caller.  Specifically, the lookup context\n+     *               must have {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()\n+     *               full privilege access}.\n+     *               When used with {@code invokedynamic}, this is stacked\n+     *               automatically by the VM.\n+     * @param interfaceMethodName The name of the method to implement.  When used with\n+     *                            {@code invokedynamic}, this is provided by the\n+     *                            {@code NameAndType} of the {@code InvokeDynamic}\n+     *                            structure and is stacked automatically by the VM.\n+     * @param factoryType The expected signature of the {@code CallSite}.  The\n+     *                    parameter types represent the types of capture variables;\n+     *                    the return type is the interface to implement.   When\n+     *                    used with {@code invokedynamic}, this is provided by\n+     *                    the {@code NameAndType} of the {@code InvokeDynamic}\n+     *                    structure and is stacked automatically by the VM.\n+     * @param interfaceMethodType Signature and return type of method to be\n+     *                            implemented by the function object.\n+     * @param implementation A direct method handle describing the implementation\n+     *                       method which should be called (with suitable adaptation\n+     *                       of argument types and return types, and with captured\n+     *                       arguments prepended to the invocation arguments) at\n+     *                       invocation time.\n+     * @param dynamicMethodType The signature and return type that should\n+     *                          be enforced dynamically at invocation time.\n+     *                          In simple use cases this is the same as\n+     *                          {@code interfaceMethodType}.\n+     * @return a CallSite whose target can be used to perform capture, generating\n+     *         instances of the interface named by {@code factoryType}\n+     * @throws LambdaConversionException If {@code caller} does not have full privilege\n+     *         access, or if {@code interfaceMethodName} is not a valid JVM\n+     *         method name, or if the return type of {@code factoryType} is not\n+     *         an interface, or if {@code implementation} is not a direct method\n+     *         handle referencing a method or constructor, or if the linkage\n+     *         invariants are violated, as defined {@link LambdaMetafactory above}.\n+     * @throws NullPointerException If any argument is {@code null}.\n+     *\/\n+    public static CallSite metafactory(MethodHandles.Lookup caller,\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType)\n+            throws LambdaConversionException {\n+        DecodedName decodedName = findQuotableOpGetter(caller, interfaceMethodName);\n+        return JLI_ACCESS.metafactoryInternal(caller, decodedName.name, factoryType, interfaceMethodType,\n+                implementation, dynamicMethodType, decodedName.reflectableLambdaInfo);\n+    }\n+\n+    \/**\n+     * Facilitates the creation of simple \"function objects\" that implement one\n+     * or more interfaces by delegation to a provided {@link MethodHandle},\n+     * after appropriate type adaptation and partial evaluation of arguments.\n+     * Typically used as a <em>bootstrap method<\/em> for {@code invokedynamic}\n+     * call sites, to support the <em>lambda expression<\/em> and <em>method\n+     * reference expression<\/em> features of the Java Programming Language.\n+     *\n+     * <p>This is the general, more flexible metafactory; a streamlined version\n+     * is provided by {@link #metafactory(java.lang.invoke.MethodHandles.Lookup,\n+     * String, MethodType, MethodType, MethodHandle, MethodType)}.\n+     * A general description of the behavior of this method is provided\n+     * {@link LambdaMetafactory above}.\n+     *\n+     * <p>The argument list for this method includes three fixed parameters,\n+     * corresponding to the parameters automatically stacked by the VM for the\n+     * bootstrap method in an {@code invokedynamic} invocation, and an {@code Object[]}\n+     * parameter that contains additional parameters.  The declared argument\n+     * list for this method is:\n+     *\n+     * <pre>{@code\n+     *  CallSite altMetafactory(MethodHandles.Lookup caller,\n+     *                          String interfaceMethodName,\n+     *                          MethodType factoryType,\n+     *                          Object... args)\n+     * }<\/pre>\n+     *\n+     * <p>but it behaves as if the argument list is as follows:\n+     *\n+     * <pre>{@code\n+     *  CallSite altMetafactory(MethodHandles.Lookup caller,\n+     *                          String interfaceMethodName,\n+     *                          MethodType factoryType,\n+     *                          MethodType interfaceMethodType,\n+     *                          MethodHandle implementation,\n+     *                          MethodType dynamicMethodType,\n+     *                          int flags,\n+     *                          int altInterfaceCount,        \/\/ IF flags has MARKERS set\n+     *                          Class... altInterfaces,       \/\/ IF flags has MARKERS set\n+     *                          int altMethodCount,           \/\/ IF flags has BRIDGES set\n+     *                          MethodType... altMethods      \/\/ IF flags has BRIDGES set\n+     *                          )\n+     * }<\/pre>\n+     *\n+     * <p>Arguments that appear in the argument list for\n+     * {@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)}\n+     * have the same specification as in that method.  The additional arguments\n+     * are interpreted as follows:\n+     * <ul>\n+     *     <li>{@code flags} indicates additional options; this is a bitwise\n+     *     OR of desired flags.  Defined flags are {@link LambdaMetafactory#FLAG_BRIDGES},\n+     *     {@link LambdaMetafactory#FLAG_MARKERS}, and {@link LambdaMetafactory#FLAG_SERIALIZABLE}.<\/li>\n+     *     <li>{@code altInterfaceCount} is the number of additional interfaces\n+     *     the function object should implement, and is present if and only if the\n+     *     {@code FLAG_MARKERS} flag is set.<\/li>\n+     *     <li>{@code altInterfaces} is a variable-length list of additional\n+     *     interfaces to implement, whose length equals {@code altInterfaceCount},\n+     *     and is present if and only if the {@code FLAG_MARKERS} flag is set.<\/li>\n+     *     <li>{@code altMethodCount} is the number of additional method signatures\n+     *     the function object should implement, and is present if and only if\n+     *     the {@code FLAG_BRIDGES} flag is set.<\/li>\n+     *     <li>{@code altMethods} is a variable-length list of additional\n+     *     methods signatures to implement, whose length equals {@code altMethodCount},\n+     *     and is present if and only if the {@code FLAG_BRIDGES} flag is set.<\/li>\n+     * <\/ul>\n+     *\n+     * <p>Each class named by {@code altInterfaces} is subject to the same\n+     * restrictions as {@code Rd}, the return type of {@code factoryType},\n+     * as described {@link LambdaMetafactory above}.  Each {@code MethodType}\n+     * named by {@code altMethods} is subject to the same restrictions as\n+     * {@code interfaceMethodType}, as described {@link LambdaMetafactory above}.\n+     *\n+     * <p>When FLAG_SERIALIZABLE is set in {@code flags}, the function objects\n+     * will implement {@code Serializable}, and will have a {@code writeReplace}\n+     * method that returns an appropriate {@link SerializedLambda}.  The\n+     * {@code caller} class must have an appropriate {@code $deserializeLambda$}\n+     * method, as described in {@link SerializedLambda}.\n+     *\n+     * <p>When the target of the {@code CallSite} returned from this method is\n+     * invoked, the resulting function objects are instances of a class with\n+     * the following properties:\n+     * <ul>\n+     *     <li>The class implements the interface named by the return type\n+     *     of {@code factoryType} and any interfaces named by {@code altInterfaces}<\/li>\n+     *     <li>The class declares methods with the name given by {@code interfaceMethodName},\n+     *     and the signature given by {@code interfaceMethodType} and additional signatures\n+     *     given by {@code altMethods}<\/li>\n+     *     <li>The class may override methods from {@code Object}, and may\n+     *     implement methods related to serialization.<\/li>\n+     * <\/ul>\n+     *\n+     * @param caller Represents a lookup context with the accessibility\n+     *               privileges of the caller.  Specifically, the lookup context\n+     *               must have {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()\n+     *               full privilege access}.\n+     *               When used with {@code invokedynamic}, this is stacked\n+     *               automatically by the VM.\n+     * @param interfaceMethodName The name of the method to implement.  When used with\n+     *                            {@code invokedynamic}, this is provided by the\n+     *                            {@code NameAndType} of the {@code InvokeDynamic}\n+     *                            structure and is stacked automatically by the VM.\n+     * @param factoryType The expected signature of the {@code CallSite}.  The\n+     *                    parameter types represent the types of capture variables;\n+     *                    the return type is the interface to implement.   When\n+     *                    used with {@code invokedynamic}, this is provided by\n+     *                    the {@code NameAndType} of the {@code InvokeDynamic}\n+     *                    structure and is stacked automatically by the VM.\n+     * @param  args An array of {@code Object} containing the required\n+     *              arguments {@code interfaceMethodType}, {@code implementation},\n+     *              {@code dynamicMethodType}, {@code flags}, and any\n+     *              optional arguments, as described above\n+     * @return a CallSite whose target can be used to perform capture, generating\n+     *         instances of the interface named by {@code factoryType}\n+     * @throws LambdaConversionException If {@code caller} does not have full privilege\n+     *         access, or if {@code interfaceMethodName} is not a valid JVM\n+     *         method name, or if the return type of {@code factoryType} is not\n+     *         an interface, or if any of {@code altInterfaces} is not an\n+     *         interface, or if {@code implementation} is not a direct method\n+     *         handle referencing a method or constructor, or if the linkage\n+     *         invariants are violated, as defined {@link LambdaMetafactory above}.\n+     * @throws NullPointerException If any argument, or any component of {@code args},\n+     *         is {@code null}.\n+     * @throws IllegalArgumentException If the number or types of the components\n+     *         of {@code args} do not follow the above rules, or if\n+     *         {@code altInterfaceCount} or {@code altMethodCount} are negative\n+     *         integers.\n+     *\/\n+    public static CallSite altMetafactory(MethodHandles.Lookup caller,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n+                                          Object... args)\n+            throws LambdaConversionException {\n+        DecodedName decodedName = findQuotableOpGetter(caller, interfaceMethodName);\n+        return JLI_ACCESS.altMetafactoryInternal(caller, decodedName.name, factoryType, decodedName.reflectableLambdaInfo, args);\n+    }\n+\n+    static final JavaLangInvokeAccess JLI_ACCESS = SharedSecrets.getJavaLangInvokeAccess();\n+\n+    record DecodedName(String name, ReflectableLambdaInfo reflectableLambdaInfo) { }\n+\n+    private static DecodedName findQuotableOpGetter(MethodHandles.Lookup lookup, String interfaceMethodName) throws LambdaConversionException {\n+        String[] implNameParts = interfaceMethodName.split(\"=\");\n+        if (implNameParts.length != 2) {\n+            throw new LambdaConversionException(\"Bad method name: \" + interfaceMethodName);\n+        }\n+        try {\n+            return new DecodedName(\n+                    implNameParts[0],\n+                    newReflectableLambdaInfo(lookup.findStatic(lookup.lookupClass(), implNameParts[1], MethodType.methodType(Op.class))));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new LambdaConversionException(ex);\n+        }\n+    }\n+\n+    private static ReflectableLambdaInfo newReflectableLambdaInfo(MethodHandle handle) {\n+        class Holder {\n+            static final ClassDesc QUOTED_CLASS_DESC = Quoted.class.describeConstable().get();\n+            static final ClassDesc FUNC_OP_CLASS_DESC = FuncOp.class.describeConstable().get();\n+            static final MethodHandle QUOTED_EXTRACT_OP_HANDLE;\n+\n+            static {\n+                try {\n+                    QUOTED_EXTRACT_OP_HANDLE = MethodHandles.lookup()\n+                            .findStatic(Quoted.class, \"extractOp\",\n+                                    MethodType.methodType(Quoted.class, FuncOp.class, Object[].class));\n+                } catch (Throwable ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+        }\n+        return new ReflectableLambdaInfo(Holder.QUOTED_CLASS_DESC, Holder.FUNC_OP_CLASS_DESC,\n+                Holder.QUOTED_EXTRACT_OP_HANDLE, handle);\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/runtime\/ReflectableLambdaMetafactory.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -48,0 +48,1 @@\n+    exports jdk.incubator.code.runtime;\n","filename":"src\/jdk.incubator.code\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,9 +475,3 @@\n-                        \/\/ if FLAG_QUOTABLE is set, the lambda is quotable\n-                        if (bsm.methodName().equals(\"altMetafactory\")) {\n-                            assert inst.bootstrapArgs().size() > 3;\n-                            assert inst.bootstrapArgs().get(3) instanceof Integer;\n-\n-                            if (inst.bootstrapArgs().get(3) instanceof Integer flags\n-                                    && (flags & LambdaMetafactory.FLAG_QUOTABLE) != 0) {\n-                                lambda = lambda.quotable();\n-                            }\n+                        \/\/ if ReflectableLambdaMetafactory is used, the lambda is quotable\n+                        if (bsm.owner().displayName().equals(\"jdk.incubator.code.runtime.ReflectableLambdaMetafactory\")) {\n+                            lambda = lambda.quotable();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/BytecodeLift.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"}]}