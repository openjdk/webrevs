{"files":[{"patch":"@@ -2,0 +2,1 @@\n+conf\/\n","filename":"hat\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.code.extern.OpFactory;\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -41,1 +41,0 @@\n-import jdk.incubator.code.dialect.core.CoreType;\n@@ -46,0 +45,2 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n+import jdk.incubator.code.extern.OpFactory;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,543 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.source.util.JavacTask;\n-\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.NestingKind;\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticCollector;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-\n-import static java.lang.IO.println;\n-\n-public static String separated(List<String> strings, String separator) {\n-    StringBuilder stringBuilder = new StringBuilder();\n-    strings.forEach(opt -> {\n-        if (opt != null) {\n-            stringBuilder.append(stringBuilder.isEmpty() ? \"\" : separator).append(opt);\n-        }\n-    });\n-    return stringBuilder.toString();\n-}\n-\n-static boolean process(Consumer<String> consumer, List<String> opts) {\n-    if (consumer == null) {\n-        consumer = (s) -> println(\"NULL consumer\" + s);\n-    }\n-    boolean success = false;\n-    try {\n-        var process = new ProcessBuilder().command(opts).redirectErrorStream(true).start();\n-        process.waitFor();\n-        new BufferedReader(new InputStreamReader(process.getInputStream())).lines().forEach(consumer);\n-        success = (process.exitValue() == 0);\n-        if (!success) {\n-            println(\"process returned error \" + process.exitValue());\n-        }\n-    } catch (Exception e) {\n-        e.printStackTrace();\n-        throw new IllegalStateException(e);\n-    }\n-    return success;\n-}\n-\n-static boolean process(List<String> opts) {\n-    return process(s -> println(s), opts);\n-}\n-\n-static boolean process(Consumer<String> consumer, String... opts) {\n-    return process(consumer, List.of(opts));\n-}\n-\n-static boolean process(String... opts) {\n-    return process(s -> println(s), List.of(opts));\n-}\n-\n-public interface ProjectProvider {\n-    Project project();\n-\n-    default void run(Consumer<String> consumer, ProjectProvider backend, List<String> args) throws IOException, InterruptedException {\n-        project().runit(project().mainClassName, backend.project(), consumer, args);\n-    }\n-    default void run(Consumer<String> consumer, ProjectProvider backend, String ... args) throws IOException, InterruptedException {\n-       run(consumer, backend.project(), List.of(args));\n-    }\n-\n-    default void run(Consumer<String> consumer, List<String> args) throws IOException, InterruptedException {\n-        project().runit(project().mainClassName, null, consumer, args);\n-    }\n-    default void run(Consumer<String> consumer, String args) throws IOException, InterruptedException {\n-       run (consumer, List.of(args));\n-    }\n-\n-    default ProjectProvider compile(Consumer<String> consumer) {\n-        if (project().needsCompiling()) {\n-            return project().compileIt(consumer);\n-        }\n-        return this;\n-    }\n-}\n-public static final class JavaSource extends SimpleJavaFileObject {\n-    Path path;\n-\n-    @Override\n-    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-        try {\n-            return Files.readString(Path.of(toUri()));\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    JavaSource(Path path) {\n-        super(path.toUri(), Kind.SOURCE);\n-        this.path = path;\n-    }\n-    static JavaSource of(Path path) {\n-        return new JavaSource(path);\n-    }\n-\n-    public Path path() {\n-        return path;\n-    }\n-}\n-public record Project(String name, String mainClassName, Path root, Path sourcePath, Path buildDir, Path classDir,\n-                      Set<ProjectProvider> dependencies, Path jarFile,\n-                      List<JavaSource> sourceFiles) implements ProjectProvider {\n-\n-    public record JavaSourceN(Path path, SimpleJavaFileObject impl) implements JavaFileObject {\n-        @Override\n-        public URI toUri() {\n-            return impl.toUri();\n-        }\n-\n-        @Override\n-        public String getName() {\n-            return impl.getName();\n-        }\n-\n-        @Override\n-        public InputStream openInputStream() throws IOException {\n-            return impl.openInputStream();\n-        }\n-\n-        @Override\n-        public OutputStream openOutputStream() throws IOException {\n-            return impl.openOutputStream();\n-        }\n-\n-        @Override\n-        public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n-            return impl.openReader(ignoreEncodingErrors);\n-        }\n-\n-        @Override\n-        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-            try {\n-                return Files.readString(Path.of(toUri()));\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        @Override\n-        public Writer openWriter() throws IOException {\n-            return impl.openWriter();\n-        }\n-\n-        @Override\n-        public long getLastModified() {\n-            return impl.getLastModified();\n-        }\n-\n-        @Override\n-        public boolean delete() {\n-            return impl.delete();\n-        }\n-\n-        static JavaSourceN of(Path path) {\n-            return new JavaSourceN(path,  new SimpleJavaFileObject(path.toUri(), Kind.SOURCE){});\n-        }\n-\n-        @Override\n-        public Kind getKind() {\n-            return impl.getKind();\n-        }\n-\n-        @Override\n-        public boolean isNameCompatible(String simpleName, Kind kind) {\n-            return impl.isNameCompatible(simpleName, kind);\n-        }\n-\n-        @Override\n-        public NestingKind getNestingKind() {\n-            return impl.getNestingKind();\n-        }\n-\n-        @Override\n-        public Modifier getAccessLevel() {\n-            return impl.getAccessLevel();\n-        }\n-    }\n-\n-\n-    public Path path() {\n-        return jarFile;\n-    }\n-\n-    @Override\n-    public Project project() {\n-        return this;\n-    }\n-\n-    public boolean needsCompiling() {\n-        return !Files.exists(jarFile);\n-    }\n-\n-    public record Result(Project project, boolean ok, List<JavaFileObject> classes,\n-                         Path jar,\n-                         List<PathAndRoot> jaredPathsWithRoots, List<Path> jarPaths,\n-                         List<Diagnostic<? extends JavaFileObject>> javacDiagnostics,\n-                         List<Diagnostic<?>> jarDiagnostics) implements ProjectProvider { }\n-\n-    public static Project of(String name, String mainClassName, Path root, String version, Path buildDir, ProjectProvider... classPathEntries) {\n-        try {\n-            var sourcePath = root.resolve(\"src\/main\/java\");\n-            var src = Files.walk(sourcePath).filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\".java\")).map(JavaSource::of).toList();\n-            var classDir = buildDir.resolve(name + \"-\" + version + \".classes\");\n-            var jarFile = buildDir.resolve(name + \"-\" + version + \".jar\");\n-            return new Project(name, mainClassName, root, sourcePath, buildDir, classDir, new LinkedHashSet<>(Arrays.asList(classPathEntries)), jarFile, src);\n-        } catch (IOException e) {\n-            \/\/ throw new RuntimeException(e);\n-            return null;\n-        }\n-    }\n-\n-\n-    public static Project example(Path root, Path buildDir, ProjectProvider... classPathEntries) {\n-        return of(\"hat-example-\" + root.getFileName().toString(), root.getFileName().toString() + \".Main\", root, \"1.0\", buildDir, classPathEntries);\n-    }\n-\n-    public static Project backend(Path root, Path buildDir, ProjectProvider... classPathEntries) {\n-\n-        return of(\"hat-backend-\" + root.getParent().getFileName().toString() + \"-\" + root.getFileName().toString(), null, root, \"1.0\", buildDir, classPathEntries);\n-    }\n-\n-    Result compileIt(Consumer<String> consumer) {\n-        if (!needsCompiling()) {\n-            throw new IllegalStateException(\"does not need compiling not called\");\n-        }\n-\n-        List<String> opts = new ArrayList<>(\n-                List.of(\n-                        \"--source\", \"26\",\n-                        \"--enable-preview\",\n-                        \"--add-modules\", \"jdk.incubator.code\",\n-                        \"-d\", classDir.toString(),\n-                        \"--class-path\", separated(dependencies.stream().map(cpe -> cpe.project().jarFile.toString()).toList(), \":\"),\n-                        \"--source-path\", sourcePath.toString()\n-                )\n-        );\n-        \/\/   if (verbose) {\n-        println(separated(opts, \" \"));\n-        \/\/ }\n-        JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n-        DiagnosticCollector<JavaFileObject> javacDiagnostics = new DiagnosticCollector<>();\n-\n-\n-        JavaCompiler.CompilationTask compilationTask =\n-                (javac.getTask(\n-                        new PrintWriter(System.err),\n-                        javac.getStandardFileManager(javacDiagnostics, null, null),\n-                        javacDiagnostics,\n-                        opts,\n-                        null,\n-                        sourceFiles\n-                ));\n-        JavacTask javacTask = (JavacTask) compilationTask;\n-        List<JavaFileObject> generatedClasses = new ArrayList<>();\n-        try {\n-            rmdir(classDir);\n-            Files.createDirectories(classDir);\n-\n-            javacTask.generate().forEach(generatedClasses::add);\n-            Path resourceDir = root.resolve(\"src\/main\/resources\");\n-\n-            List<Path> dirsToJar = new ArrayList<>(List.of(classDir));\n-            if (Files.exists(resourceDir)) {\n-                dirsToJar.add(resourceDir);\n-            }\n-            List<Diagnostic<?>> jarDiagnostics = new ArrayList<>();\n-            var jarStream = new JarOutputStream(Files.newOutputStream(jarFile));\n-            Manifest manifest = null;\/\/new Manifest(null, null, null,null,null);\n-            if (manifest != null) {\n-                var entry = new JarEntry(\"META-INF\/MANIFEST.MF\");\n-                jarStream.putNextEntry(entry);\n-                manifest.writeTo(jarStream);\n-                jarStream.closeEntry();\n-            }\n-\n-\n-            List<PathAndRoot> pathsToJar = new ArrayList<>();\n-            dirsToJar.forEach(root -> {\n-                try {\n-                    Files.walk(root).map(path -> new PathAndRoot(root, path)).forEach(pathsToJar::add);\n-                } catch (Exception e) {\n-\n-                }\n-            });\n-            List<Path> filePaths = new ArrayList<>();\n-            pathsToJar.stream()\n-                    .sorted(Comparator.comparing(PathAndRoot::path))\n-                    .forEach(\n-                            rootAndPath -> {\n-                                try {\n-                                    if (!Files.isDirectory(rootAndPath.path)) {\n-                                        filePaths.add(rootAndPath.path);\n-                                        var relative = rootAndPath.root.relativize(rootAndPath.path);\n-                                        var entry = new JarEntry(relative.toString());\n-                                        entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n-                                        jarStream.putNextEntry(entry);\n-                                        Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n-                                        jarStream.closeEntry();\n-                                        \/\/   if (verbose) {\n-                                        \/\/println(\"INFO: adding \" + rootAndPath.relativize().toString());\n-                                        \/\/  }\n-                                    }\n-                                } catch (IOException e) {\n-                                    throw new RuntimeException(e);\n-                                }\n-                            });\n-            jarStream.finish();\n-            jarStream.close();\n-            \/\/ if (verbose) {\n-            \/\/ println(\"INFO: created \" + jarFile.toString());\n-            \/\/}\n-            return new Result(this, true, generatedClasses, jarFile, pathsToJar, filePaths, javacDiagnostics.getDiagnostics(), jarDiagnostics);\n-        } catch (IOException e) {\n-            println(e.getMessage());\n-            return null;\n-        }\n-    }\n-\n-    public record PathAndRoot(Path root, Path path) {\n-        Path relativize() {\n-            return root.relativize(path());\n-        }\n-    }\n-\n-    public record Manifest(String mainClass, String[] classPath, String version, String createdBy, String buildBy) {\n-\n-        public void writeTo(JarOutputStream jarStream) {\n-            PrintWriter printWriter = new PrintWriter(jarStream);\n-            if (version != null) {\n-                printWriter.println(\"Manifest-Version: \" + version);\n-            }\n-            if (mainClass != null) {\n-                printWriter.println(\"Main-Class: \" + mainClass);\n-            }\n-            if (classPath != null) {\n-                printWriter.print(\"Class-Path:\");\n-                for (String s : classPath) {\n-                    printWriter.print(\" \");\n-                    printWriter.print(s);\n-                }\n-                printWriter.println();\n-            }\n-            printWriter.flush();\n-        }\n-    }\n-\n-\n-    void runit(String classToRun, ProjectProvider backend, Consumer<String> consumer, List<String> args) throws IOException, InterruptedException {\n-        \/\/ before we start lets ensure all the dependencies are compiled\n-        Set<ProjectProvider> allDependencies = new LinkedHashSet<>();\n-        dependencies.forEach(classPathEntry -> classPathEntry.project().collect(allDependencies));\n-        if (backend != null) {\n-            backend.project().collect(allDependencies);\n-        }\n-        allDependencies.add(this);\n-        allDependencies.forEach(p ->\n-                p.compile(consumer)\n-        );\n-        List<String> opts = new ArrayList<>();\n-\n-        var colonSeperated = separated(allDependencies.stream().filter(Objects::nonNull).map(cpe -> cpe.project().jarFile.toString()).toList(), \":\");\n-\n-        opts.addAll(List.of(\n-                \"\/Users\/grfrost\/github\/babylon-grfrost-fork\/build\/macosx-aarch64-server-release\/jdk\/bin\/java\",\n-                \"--enable-preview\",\n-                \"--enable-native-access=ALL-UNNAMED\",\n-                \"--class-path\", colonSeperated,\n-                \"-Djava.library.path=\" + buildDir.toString(),\n-                classToRun != null ? classToRun : mainClassName\n-        ));\n-        opts.addAll(args);\n-        process(consumer, opts);\n-    }\n-\n-    private void collect(Set<ProjectProvider> all) {\n-\n-        dependencies.forEach(classPathEntry -> classPathEntry.project().collect(all));\n-        all.add(this);\n-    }\n-\n-}\n-\n-static Path rmdir(Path path) {\n-    try {\n-        if (Files.exists(path)) {\n-            Files.walk(path)\n-                    .sorted(Comparator.reverseOrder())\n-                    .map(Path::toFile)\n-                    .forEach(File::delete);\n-        }\n-    } catch (IOException ioe) {\n-        System.out.println(ioe);\n-        throw new RuntimeException(ioe);\n-    }\n-    return path;\n-}\n-\n-record CMaker(boolean verbose, Path dir, Path hatBuildDir, Path cmakeBuildDir) {\n-\n-    static CMaker of(boolean verbose, Path dir, Path hatBuildDir) {\n-        var cmakeBuildDir = dir.resolve(\"build\");\n-        try {\n-            rmdir(cmakeBuildDir);\n-            Files.createDirectories(cmakeBuildDir);\n-            return new CMaker(verbose, dir, hatBuildDir, cmakeBuildDir);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public boolean init(Consumer<String> consumer) {\n-        return process(consumer, \"cmake\",  \"--fresh\", \"-DHAT_TARGET=\" + hatBuildDir, \"-B\", cmakeBuildDir.toString(), \"-S\", dir.toString());\n-    }\n-\n-    public boolean build(Consumer<String> consumer) {\n-        return process(consumer, \"cmake\", \"--build\", cmakeBuildDir.toString());\n-    }\n-    public boolean build(Consumer<String> consumer, String target ) {\n-        return process(consumer, \"cmake\", \"--build\", cmakeBuildDir.toString(), \"--target\", target);\n-    }\n-}\n-\n-\n-public static final Path userDir = Path.of(System.getProperty(\"user.dir\"));\n-public static final Path rootDir = userDir.getFileName().toString().equals(\"intellij\") ? userDir.getParent() : userDir;\n-public static final Path buildDir = rootDir.resolve(\"build\");\n-public static final Project hatCore = Project.of(\"core\", null, rootDir.resolve(\"core\"), \"1.0\", buildDir);\n-public static final Path backendsDir = rootDir.resolve(\"backends\");\n-public static final Path ffiBackendsDir = backendsDir.resolve(\"ffi\");\n-public static final Project ffiSharedBackend = Project.backend(ffiBackendsDir.resolve(\"shared\"), buildDir, hatCore);\n-public static final Project cudaFFiBackend = Project.backend(ffiBackendsDir.resolve(\"cuda\"), buildDir, hatCore, ffiSharedBackend);\n-public static final Project openclFFiBackend = Project.backend(ffiBackendsDir.resolve(\"opencl\"), buildDir, hatCore, ffiSharedBackend);\n-public static final Project mockFFiBackend = Project.backend(ffiBackendsDir.resolve(\"mock\"), buildDir, hatCore, ffiSharedBackend);\n-public static final Path javaBackendsDir = backendsDir.resolve(\"java\");\n-public static final Project javaMtBackend = Project.backend(javaBackendsDir.resolve(\"mt\"), buildDir, hatCore);\n-public static final Project javaSeqBackend = Project.backend(javaBackendsDir.resolve(\"seq\"), buildDir, hatCore);\n-public static final Path examplesDir = rootDir.resolve(\"examples\");\n-public static final Project mandel = Project.example(examplesDir.resolve(\"mandel\"), buildDir, hatCore);\n-public static final Project life = Project.example(examplesDir.resolve(\"life\"), buildDir, hatCore);\n-public static final Project squares = Project.example(examplesDir.resolve(\"squares\"), buildDir, hatCore);\n-public static final Project heal = Project.example(examplesDir.resolve(\"heal\"), buildDir, hatCore);\n-public static final Project violaJones = Project.example(examplesDir.resolve(\"violajones\"), buildDir, hatCore);\n-public static final List<Project> examples = List.of(squares,mandel,life,heal,violaJones);\n-public static final List<Project> backends = List.of(openclFFiBackend,javaMtBackend,javaSeqBackend,cudaFFiBackend,mockFFiBackend);\n-public static Project example(String n){\n-    return examples.stream()\n-            \/\/.peek(p->println(p.name()))\n-            .filter(p->p.name().equals(\"hat-example-\"+n))\n-            .findFirst().orElse(null);\n-}\n-public static Project backend(String n){\n-    return backends.stream()\n-            .peek(p->println(p.name()))\n-            .filter(p->p.name().equals(\"hat-backend-\"+n))\n-            .findFirst().orElse(null);\n-}\n-\n-\n-\n-\n-public static void main(String[] argArr) throws IOException, InterruptedException {\n-\n-    var args = new ArrayList<>(List.of(argArr));\n-    var out = (Consumer<String>) IO::println;\n-    var command = args.isEmpty()?null:args.removeFirst();\n-\n-    if (\"clean\".equals(command)) {\n-        rmdir(buildDir);\n-\n-        command = args.isEmpty()?null:args.removeFirst();\n-        if (command == null) {\n-            System.exit(0);\n-        }\n-    }\n-    if (\"bld\".equals(command)) {\n-        backends.forEach(p->((ProjectProvider)p).compile(out));\n-        examples.forEach(p ->((ProjectProvider)p).compile(out) );\n-        if (CMaker.of(false, ffiBackendsDir, buildDir) instanceof CMaker cmaker) {\n-            if (cmaker.init(out)) {\n-                if (cmaker.build(out)) {\n-                    System.out.println(\"cmake finished\");\n-                }\n-            }\n-        }\n-    }else if (\"run\".equals(command) && args.size()>1){\n-        var backendName =args.removeFirst();\n-        var exampleName = args.removeFirst();\n-        System.out.println(\"Try to run example \"+exampleName+\" with backend \"+backendName);\n-        if (backend(backendName) instanceof ProjectProvider backend){\n-            if (backendName.startsWith(\"ffi\") && !Files.exists(backend.project().jarFile)) {\n-                if (CMaker.of(false, ffiBackendsDir, buildDir) instanceof CMaker cmaker) {\n-                    if (cmaker.init(out)) {\n-                        if (cmaker.build(out, backendName.substring(4)+\"_backend\")) {\n-                            System.out.println(\"cmake created \"+backendName+\" backend\");\n-                        }\n-                    }\n-                }\n-            }\n-            if (example(exampleName) instanceof ProjectProvider example){\n-                example.run(out, backend, args);\n-            }else{\n-                System. out.println(\"Failed to find \"+exampleName);\n-            }\n-        }else{\n-            System. out.println(\"Failed to find backend \"+backendName);\n-        }\n-\n-     }else{\n-         System. out.println(\"What? \");\n-     }\n-\n-}\n-\n-\n","filename":"hat\/hat\/HAT.java","additions":0,"deletions":543,"binary":false,"changes":543,"status":"deleted"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Set;\n+\n+public class Hat {\n+    public static void main(String[] argArr) throws IOException, InterruptedException {\n+\n+        Path userDir = Path.of(System.getProperty(\"user.dir\"));\n+        var project = new Job.Project(userDir.getFileName().toString().equals(\"intellij\") ? userDir.getParent() : userDir);\n+\n+        var mac = new Job.Mac(project.id(\"mac-1.0\"), Set.of());\n+        var opencl = new Job.OpenCL(project.id(\"opencl-1.0\"),  Set.of());\n+        var opengl = new Job.OpenGL(project.id(\"opengl-1.0\"),  Set.of());\n+        var cuda = new Job.Cuda(project.id(\"cuda-1.0\"),  Set.of());\n+\n+        var core = Job.Jar.of(project.id(\"core-1.0\"));\n+        var backend_ffi_native = Job.CMake.of(project.id(\"backend-ffi-1.0\"), core);\n+        var ffiSharedBackend = Job.Jar.of(project.id(\"backend-ffi-shared-1.0\"), core, backend_ffi_native);\n+        var backend_ffi_cuda = Job.Jar.of(project.id(\"backend-ffi-cuda-1.0\"), core, cuda, ffiSharedBackend);\n+        var backend_ffi_opencl = Job.Jar.of(project.id(\"backend-ffi-opencl-1.0\"), opencl, core, ffiSharedBackend);\n+        var backend_ffi_mock = Job.Jar.of(project.id(\"backend-ffi-mock-1.0\"), core, ffiSharedBackend);\n+        var backend_mt_java = Job.Jar.of(project.id(\"backend-java-mt-1.0\"), core);\n+        var backend_seq_java = Job.Jar.of(project.id(\"backend-java-mt-1.0\"), core);\n+        var example_mandel = Job.RunnableJar.of(project.id(\"example-mandel-1.0\"), core);\n+        var example_life = Job.RunnableJar.of(project.id(\"example-life-1.0\"), core);\n+        var example_squares = Job.RunnableJar.of(project.id(\"example-squares-1.0\"), core);\n+        var example_heal = Job.RunnableJar.of(project.id(\"example-heal-1.0\"), core);\n+        var example_violajones = Job.RunnableJar.of(project.id(\"example-violajones-1.0\"), core);\n+        var extractions_opengl = Job.JExtract.of(project.id(\"extraction-opengl-1.0\"), Job.JExtract.Mac.of(opengl,\"GLUT\", \"OpenGL\"), mac, opengl, core);\n+        var extractions_opencl = Job.JExtract.of(project.id(\"extraction-opencl-1.0\"), Job.JExtract.Mac.of(opencl,\"OpenCL\"), mac, opencl, core);\n+        var wraps_wrap = Job.Jar.of(project.id(\"wrap-wrap-1.0\"));\n+        var wraps_clwrap = Job.Jar.of(project.id(\"wrap-clwrap-1.0\"), extractions_opencl, wraps_wrap);\n+\n+        var wraps_glwrap = Job.Jar.of(project.id(\"wrap-glwrap-1.0\"),\n+                Set.of(project.rootPath().resolve(\"wraps\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLCallbackEventHandler.java\")), \/\/exclude\n+                extractions_opengl,\n+                wraps_wrap);\n+        var example_nbody = Job.RunnableJar.of(project.id(\"example-nbody-1.0\"), Set.of(wraps_glwrap, wraps_clwrap, wraps_wrap, core, mac));\n+        if (argArr.length == 0) {\n+            project.start(\"run\", \"ffi-opencl\", \"nbody\");\n+        } else {\n+            project.start(argArr);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/hat\/Hat.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,1267 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import com.sun.source.util.JavacTask;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+public class Job {\n+    @FunctionalInterface\n+    public interface Progress extends BiConsumer<Dependency, String> {\n+        void accept(Dependency a, String s);\n+    }\n+\n+    public interface Dependency {\n+        Project.Id id();\n+\n+        Set<Dependency> dependencies();\n+\n+        interface WithPath extends Dependency {\n+        }\n+\n+        interface Buildable extends Dependency {\n+            boolean build();\n+\n+            boolean clean();\n+\n+            List<Path> generatedPaths();\n+        }\n+\n+        interface Executable extends Dependency {\n+        }\n+\n+        interface ExecutableJar extends Executable {\n+            boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> args);\n+        }\n+\n+        interface Runnable extends Executable {\n+            boolean run();\n+        }\n+\n+        interface Optional extends Dependency {\n+            boolean isAvailable();\n+        }\n+    }\n+\n+\n+    public static abstract class AbstractArtifact<T extends AbstractArtifact<T>> implements Dependency {\n+        protected final Project.Id id;\n+\n+        @Override\n+        public Project.Id id() {\n+            return id;\n+        }\n+\n+        final private Set<Dependency> dependencies = new LinkedHashSet<>();\n+\n+        @Override\n+        public Set<Dependency> dependencies() {\n+            return dependencies;\n+        }\n+\n+        AbstractArtifact(Project.Id id, Set<Dependency> dependencies) {\n+            this.id = id;\n+            this.dependencies.addAll(dependencies);\n+        }\n+    }\n+\n+    public static abstract class AbstractArtifactWithPath<T extends AbstractArtifact<T>> extends AbstractArtifact<T>\n+            implements Dependency.WithPath {\n+\n+        AbstractArtifactWithPath(Project.Id id, Set<Dependency> dependencies) {\n+            super(id, dependencies);\n+            if (!Files.exists(id.path())) {\n+                System.err.println(\"The path does not exist: \" + id.path());\n+\n+            }\n+        }\n+    }\n+\n+    public static class Project {\n+\n+        public record Id(Project project, String projectName, String hyphenatedName, String version, Path path,\n+                         String name) {\n+        }\n+\n+        private static Id id(Project project, String hyphenatedName) {\n+            int lastIndex = hyphenatedName.lastIndexOf('-');\n+            var version = hyphenatedName.substring(lastIndex + 1);\n+            String[] splitString = hyphenatedName.substring(0, lastIndex).split(\"-\");\n+            var runName = \"\";\n+            var dirName = \"\";\n+            if (splitString.length == 3) {\n+                runName = splitString[1] + \"-\" + splitString[2];\n+                dirName = splitString[0] + \"s\/\" + splitString[1] + \"\/\" + splitString[2];\n+            } else if (splitString.length == 2) {\n+                runName = splitString[1];\n+                dirName = splitString[0] + \"s\/\" + splitString[1];\n+            } else if (splitString.length == 1) {\n+                runName = splitString[0];\n+                dirName = splitString[0];\n+            }\n+            var id = new Id(project, project.name(), hyphenatedName, version, project.rootPath().resolve(dirName), runName);\n+            return id;\n+        }\n+\n+        Id id(String id) {\n+            return id(this, id);\n+        }\n+\n+\n+        public static class Dag {\n+            static void recurse(Map<Dependency, Set<Dependency>> map, Dependency from) {\n+                var set = map.computeIfAbsent(from, _ -> new LinkedHashSet<>());\n+                var deps = from.dependencies();\n+                deps.forEach(dep -> {\n+                    set.add(dep);\n+                    recurse(map, dep);\n+                });\n+            }\n+\n+            static Set<Dependency> processOrder(Set<Dependency> jars) {\n+                Map<Dependency, Set<Dependency>> map = new LinkedHashMap<>();\n+                Set<Dependency> ordered = new LinkedHashSet<>();\n+                jars.forEach(jar -> recurse(map, jar));\n+                while (!map.isEmpty()) {\n+                    var leaves = map.entrySet().stream()\n+                            .filter(e -> e.getValue().isEmpty())    \/\/ if this entry has zero dependencies\n+                            .map(Map.Entry::getKey)                 \/\/ get the key\n+                            .collect(Collectors.toSet());\n+                    map.forEach((k, v) ->\n+                            leaves.forEach(v::remove)\n+                    );\n+                    leaves.forEach(leaf -> {\n+                        map.remove(leaf);\n+                        ordered.add(leaf);\n+                    });\n+                }\n+                return ordered;\n+            }\n+\n+            static Set<Dependency> build(Set<Dependency> jars) {\n+                var ordered = processOrder(jars);\n+                ordered.stream().filter(d -> d instanceof Dependency.Buildable).map(d -> (Dependency.Buildable) d).forEach(Dependency.Buildable::build);\n+                return ordered;\n+            }\n+\n+            static Set<Dependency> clean(Set<Dependency> jars) {\n+                var ordered = processOrder(jars);\n+                ordered.stream().filter(d -> d instanceof Dependency.Buildable).map(d -> (Dependency.Buildable) d).forEach(Dependency.Buildable::build);\n+                return ordered;\n+            }\n+\n+        }\n+\n+        private final Path rootPath;\n+        private final Path buildPath;\n+        private final Path confPath;\n+        private final Progress progress;\n+        private final Map<String, Dependency> artifacts = new LinkedHashMap<>();\n+\n+        public String name() {\n+            return rootPath().getFileName().toString();\n+        }\n+\n+        public Path rootPath() {\n+            return rootPath;\n+        }\n+\n+        public Path buildPath() {\n+            return buildPath;\n+        }\n+\n+        public Path confPath() {\n+            return confPath;\n+        }\n+\n+        public Project(Path root, Progress progress) {\n+            this.rootPath = root;\n+            if (!Files.exists(root)) {\n+                throw new IllegalArgumentException(\"Root path for project does not exist: \" + root);\n+            }\n+            this.buildPath = root.resolve(\"build\");\n+            this.confPath = root.resolve(\"conf\");\n+            this.progress = progress;\n+        }\n+\n+        public Project(Path root) {\n+            this(root, (a, s) -> System.out.println(a.id().project().name() + \":\" + a.id().name() + \":\" + s));\n+        }\n+\n+        public Dependency add(Dependency dependency) {\n+            artifacts.put(dependency.id().hyphenatedName, dependency);\n+            return dependency;\n+        }\n+\n+        public Dependency getArtifact(String dependency) {\n+            return artifacts.get(dependency);\n+        }\n+\n+        public void rmdir(Path... paths) {\n+            for (Path path : paths) {\n+                \/\/  System.out.println(\"rm -rf \"+path.getFileName().toString());\n+                if (Files.exists(path)) {\n+                    try (var files = Files.walk(path)) {\n+                        files.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+                    } catch (Throwable t) {\n+                        throw new RuntimeException(t);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void clean(Path... paths) {\n+            for (Path path : paths) {\n+                if (Files.exists(path)) {\n+                    \/\/ System.out.println(\"rm -rf \"+path.getFileName().toString());\n+                    \/\/ System.out.println(\"mkdir -p \"+path.getFileName().toString());\n+                    try (var files = Files.walk(path)) {\n+                        files.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+                        mkdir(path);\n+                    } catch (Throwable t) {\n+                        throw new RuntimeException(t);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void mkdir(Path... paths) {\n+            for (Path path : paths) {\n+                if (!Files.exists(path)) {\n+                    try {\n+                        Files.createDirectories(path);\n+                    } catch (Throwable t) {\n+                        throw new RuntimeException(t);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public Set<Dependency> clean(Set<Dependency> dependencies) {\n+            return Dag.clean(dependencies);\n+        }\n+\n+        public void clean(List<String> names) {\n+            if (names.isEmpty()) {\n+                rmdir(buildPath());\n+            } else {\n+                clean(names.stream().map(this::getArtifact).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        public Set<Dependency> build(Set<Dependency> dependencies) {\n+            return Dag.build(dependencies);\n+        }\n+\n+        public Set<Dependency> build(Dependency... dependencies) {\n+            return build(Set.of(dependencies));\n+        }\n+\n+        public Set<Dependency> build(List<String> names) {\n+            if (names.isEmpty()) {\n+                return build(new HashSet<>(artifacts.values()));\n+            } else {\n+                return build(names.stream().map(this::getArtifact).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        void start(String... argArr) throws IOException, InterruptedException {\n+            var args = new ArrayList<>(List.of(argArr));\n+\n+            Map<String, String> opts = Map.of(\n+                    \"bld\", \"Will Bld\",\n+                    \"help\", \"\"\"\n+                             help: This list\n+                              bld: ...buildables | all if none\n+                                   bld\n+                                   bld ffi-opencl\n+                              run: [ffi|my|seq]-[opencl|java|cuda|mock|hip] runnable (i.e has name.Main class)\n+                                   run ffi-opencl mandel\n+                                   run ffi-openc nbody\n+                            clean: ...buildables | all if none\n+                                   clean\n+                                   clean ffi-opencl\n+                            \"\"\",\n+                    \"clean\", \"Will clean\",\n+                    \"run\", \"Will run\"\n+            );\n+            record Action(String name, String help, List<String> args) {\n+                int size() {\n+                    return args.size();\n+                }\n+\n+                boolean isEmpty() {\n+                    return args.isEmpty();\n+                }\n+\n+                String get() {\n+                    var got = (size() > 0) ? args.removeFirst() : null;\n+                    return got;\n+                }\n+\n+                String str() {\n+                    return name + \" '\" + String.join(\" \", args) + \"'\";\n+                }\n+\n+            }\n+\n+            List<Action> actions = new ArrayList<>();\n+            while (!args.isEmpty()) {\n+                String arg = args.removeFirst();\n+                if (opts.containsKey(arg)) {\n+                    List<String> subList = new ArrayList<>();\n+                    while (!args.isEmpty() &&\n+                            args.getFirst() instanceof String next\n+                            && !opts.containsKey(next)) {\n+                        subList.add(args.removeFirst());\n+                    }\n+                    actions.add(new Action(arg, opts.get(arg), subList));\n+                } else {\n+                    System.err.println(\"What \" + arg + \" \" + String.join(\" \", args));\n+                }\n+            }\n+            if (actions.stream().anyMatch(a -> a.name.equals(\"help\"))) {\n+                actions.forEach(action ->\n+                        System.out.println(action.help)\n+                );\n+            } else {\n+                for (var action : actions) {\n+                    switch (action.name()) {\n+                        case \"clean\" -> clean(action.args);\n+                        case \"bld\" -> build(action.args);\n+                        case \"run\" -> {\n+                            if (action.get() instanceof String backendName && !action.isEmpty() && getArtifact(\"backend-\" + backendName + \"-1.0\") instanceof Jar backend) {\n+                                if (action.get() instanceof String runnableName && getArtifact(\"example-\" + runnableName + \"-1.0\") instanceof Dependency.ExecutableJar runnable) {\n+                                    runnable.run(runnable.id().name() + \".Main\", build(runnable, backend), args);\n+                                } else {\n+                                    System.out.println(\"Failed to find runnable \");\n+                                }\n+                            } else {\n+                                System.out.println(\"Failed to find backend !\");\n+                            }\n+                        }\n+                        default -> {\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+\n+    public static class Jar extends AbstractArtifactWithPath<Jar> implements Dependency.Buildable {\n+        public interface JavacProgress extends Progress {\n+\n+            default void javacCommandLine(Dependency a, List<String> opts, List<JavaSource> sources) {\n+                accept(a, \"javac \" + String.join(\" \", opts) + \" \" + String.join(\" \", sources.stream().map(JavaSource::getName).collect(Collectors.toList())));\n+            }\n+\n+            default void javacInfo(Dependency a, String s) {\n+                accept(a, \"JAVAC : I\" + s);\n+            }\n+\n+            default void javacProgress(Dependency a, String s) {\n+                accept(a, \"JAVAC : \" + s);\n+            }\n+\n+            default void javacError(Dependency a, String s) {\n+                accept(a, \"JAVAC : !!!\" + s);\n+                throw new RuntimeException(s);\n+            }\n+\n+            default void javacWarning(Dependency a, String s) {\n+                accept(a, \"JAVAC : W \" + s);\n+            }\n+\n+            default void javacClean(Dependency a, Path... paths) {\n+                accept(a, \"clean \" + String.join(\" \", Arrays.stream(paths).map(Path::toString).toList()));\n+            }\n+\n+            default void javacNote(Dependency a, String s) {\n+                accept(a, \"JAVAC :\" + s);\n+            }\n+\n+            default void javacVerbose(Dependency a, String s) {\n+                accept(a, \"JAVAC :\" + s);\n+            }\n+\n+            default void javacCreatedClass(Dependency a, String s) {\n+                accept(a, \"JAVAC_CREATED_CLASS :\" + s);\n+            }\n+\n+            static JavacProgress adapt(Project.Id id) {\n+                return (id.project().progress instanceof JavacProgress progress) ? progress : new JavacProgress() {\n+                    @Override\n+                    public void accept(Dependency a, String s) {\n+                        id.project().progress.accept(a, s);\n+                    }\n+                };\n+            }\n+\n+        }\n+\n+        public interface JarProgress extends Progress {\n+            default void jarProgress(Dependency a, String s) {\n+                accept(a, \"JAR :\" + s);\n+            }\n+\n+            default void jarInfo(Dependency a, String s) {\n+                accept(a, \"JAR : I\" + s);\n+            }\n+\n+            default void jarCommandLine(Dependency a, Path path, List<Path> paths) {\n+                accept(a, \"jar cvf \" + path + \" \" + String.join(paths.stream().map(Path::toString).collect(Collectors.joining(\" \"))));\n+            }\n+\n+            default void jarClean(Dependency a, Path... paths) {\n+                accept(a, \"clean \" + String.join(\" \", Arrays.stream(paths).map(Path::toString).toList()));\n+            }\n+\n+            default void jarError(Dependency a, String s) {\n+                accept(a, \"JAR : !!!\" + s);\n+                throw new RuntimeException(s);\n+            }\n+\n+            default void jarWarning(Dependency a, String s) {\n+                accept(a, \"JAR : W \" + s);\n+            }\n+\n+            default void jarNote(Dependency a, String s) {\n+                accept(a, \"JAR :\" + s);\n+            }\n+\n+            static JarProgress adapt(Project.Id id) {\n+                return (id.project.progress instanceof JarProgress progress) ? progress : new JarProgress() {\n+                    @Override\n+                    public void accept(Dependency a, String s) {\n+                        id.project.progress.accept(a, s);\n+                    }\n+                };\n+            }\n+        }\n+\n+        final Set<Path> exclude;\n+\n+        private Jar(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+            super(id, dependencies);\n+            this.exclude = exclude;\n+\n+            if (!Files.exists(javaSourcePath())) {\n+                var jsp = javaSourcePath();\n+                System.out.println(\"Failed to find java source \" + jsp + \" path for \" + id.name());\n+            }\n+            id.project.add(this);\n+        }\n+\n+        public static Jar of(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+            return new Jar(id, exclude, dependencies);\n+        }\n+\n+        public static Jar of(Project.Id id, Set<Dependency> dependencies) {\n+            return new Jar(id, Set.of(), dependencies);\n+        }\n+\n+        public static Jar of(Project.Id id, Set<Path> exclude, Dependency... dependencies) {\n+            return of(id, exclude, Set.of(dependencies));\n+        }\n+\n+        public static Jar of(Project.Id id, Dependency... dependencies) {\n+            return of(id, Set.of(), Set.of(dependencies));\n+        }\n+\n+        public static class JavaSource extends SimpleJavaFileObject {\n+            Path path;\n+\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                try {\n+                    return Files.readString(Path.of(toUri()));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            JavaSource(Path path) {\n+                super(path.toUri(), Kind.SOURCE);\n+                this.path = path;\n+            }\n+        }\n+\n+        public Path jarFile() {\n+            return id().project().buildPath().resolve(id().hyphenatedName() + \".jar\");\n+        }\n+\n+        @Override\n+        public List<Path> generatedPaths() {\n+            throw new IllegalStateException(\"who called me\");\n+        }\n+\n+\n+        @Override\n+        public boolean clean() {\n+            RunnableJar.JavacProgress.adapt(id()).javacClean(this, classesDir(), jarFile());\n+            RunnableJar.JarProgress.adapt(id()).jarClean(this, classesDir(), jarFile());\n+            id().project().clean(classesDir(), jarFile());\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean build() {\n+            List<String> opts = new ArrayList<>(\n+                    List.of(\n+                            \"--source=26\",\n+                            \"--enable-preview\",\n+                            \"--add-modules=jdk.incubator.code\",\n+                            \"--add-exports=jdk.incubator.code\/jdk.incubator.code.dialect.java.impl=ALL-UNNAMED\",\n+                            \"-g\",\n+                            \"-d\", classesDirName()\n+                    ));\n+            var deps = classPath(Project.Dag.processOrder(dependencies()));\n+            if (!deps.isEmpty()) {\n+                opts.addAll(List.of(\n+                        \"--class-path=\" + deps\n+                ));\n+            }\n+            opts.addAll(List.of(\n+                            \"--source-path=\" + javaSourcePathName()\n+                    )\n+            );\n+\n+            JavacProgress javacProgress = JavacProgress.adapt(id());\n+\n+            JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n+            javacProgress.javacClean(this, classesDir());\n+            id().project().clean(classesDir());\n+\n+            if (Files.exists(javaSourcePath())) {\n+                try (var files = Files.walk(javaSourcePath())) {\n+                    var listOfSources = files.filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".java\") && !exclude.contains(p)).map(JavaSource::new).toList();\n+\n+                    javacProgress.javacCommandLine(this, opts, listOfSources);\n+                    var diagnosticListener = new DiagnosticListener<JavaFileObject>() {\n+                        @Override\n+                        public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n+                            if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {\n+                                javacProgress.javacError(Jar.this, diagnostic.toString());\n+                            } else if (diagnostic.getKind() == Diagnostic.Kind.WARNING) {\n+                                javacProgress.javacWarning(Jar.this, diagnostic.toString());\n+                            } else if (diagnostic.getKind() == Diagnostic.Kind.MANDATORY_WARNING) {\n+                                javacProgress.javacWarning(Jar.this, \"!!\" + diagnostic.toString());\n+                            } else if (diagnostic.getKind() == Diagnostic.Kind.NOTE) {\n+                                javacProgress.javacNote(Jar.this, diagnostic.toString());\n+                            }\n+                            javacProgress.javacProgress(Jar.this, diagnostic.getKind() + \":\" + diagnostic.toString());\n+                        }\n+                    };\n+                    ((JavacTask) javac.getTask(\n+                            new PrintWriter(System.err),\n+                            javac.getStandardFileManager(diagnosticListener, null, null),\n+                            diagnosticListener,\n+                            opts,\n+                            null,\n+                            listOfSources\n+                    )).generate().forEach(gc ->\n+                            javacProgress.javacCreatedClass(this, gc.getName())\n+                    );\n+\n+                    List<Path> dirsToJar = new ArrayList<>(List.of(classesDir()));\n+                    if (Files.exists(javaResourcePath())) {\n+                        dirsToJar.add(javaResourcePath());\n+                    }\n+                    var jarStream = new JarOutputStream(Files.newOutputStream(jarFile()));\n+                    JarProgress jarProgress = JarProgress.adapt(id());\n+\n+                    record RootAndPath(Path root, Path path) {\n+                    }\n+                    dirsToJar.forEach(r -> {\n+                        try {\n+                            jarProgress.jarCommandLine(this, jarFile(), dirsToJar);\n+\n+                            Files.walk(r)\n+                                    .filter(p -> !Files.isDirectory(p))\n+                                    .map(p -> new RootAndPath(r, p))\n+                                    .sorted(Comparator.comparing(RootAndPath::path))\n+                                    .forEach(\n+                                            rootAndPath -> {\n+                                                try {\n+                                                    var entry = new JarEntry(rootAndPath.root.relativize(rootAndPath.path).toString());\n+                                                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                                                    jarStream.putNextEntry(entry);\n+                                                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                                                    jarStream.closeEntry();\n+                                                } catch (IOException e) {\n+                                                    throw new RuntimeException(e);\n+                                                }\n+                                            });\n+\n+\n+                        } catch (Exception e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    });\n+\n+                    jarStream.finish();\n+                    jarStream.close();\n+                    return true;\n+                } catch (Exception e) {\n+                    \/\/   println(e.getMessage());\n+                    throw new RuntimeException(e);\n+                }\n+            } else {\n+                return true;\n+            }\n+        }\n+\n+        protected String classPath(Set<Dependency> dependencies) {\n+            return String.join(\":\", dependencies.stream().filter(p ->\n+                    p instanceof Jar).map(a -> (Jar) a).map(Jar::jarFileName).toList());\n+        }\n+\n+        protected String classPathWithThisLast(Set<Dependency> dependencies) {\n+            Set<Dependency> all = new LinkedHashSet<>(dependencies);\n+            all.remove(this);\n+            all.add(this);\n+            return String.join(\":\", all.stream().filter(p ->\n+                    p instanceof Jar).map(a -> (Jar) a).map(Jar::jarFileName).toList());\n+        }\n+\n+        private Path classesDir() {\n+            return id().project().buildPath().resolve(id().hyphenatedName() + \".classes\");\n+        }\n+\n+        private String classesDirName() {\n+            return classesDir().toString();\n+        }\n+\n+        private String jarFileName() {\n+            return jarFile().toString();\n+        }\n+\n+        private Path javaResourcePath() {\n+            return id().path().resolve(\"src\/main\/resources\");\n+\n+        }\n+\n+        private String javaResourcePathName() {\n+            return javaResourcePath().toString();\n+        }\n+\n+        private String javaSourcePathName() {\n+            return javaSourcePath().toString();\n+        }\n+\n+        protected Path javaSourcePath() {\n+            return id().path().resolve(\"src\/main\/java\");\n+        }\n+    }\n+\n+    public static class RunnableJar extends Jar implements Dependency.ExecutableJar {\n+        public interface JavaProgress extends Progress {\n+            default void javaProgress(Dependency a, String s) {\n+                accept(a, \"JAVA :\" + s);\n+            }\n+\n+            default void javaInfo(Dependency a, String s) {\n+                accept(a, \"JAVA : I\" + s);\n+            }\n+\n+            default void javaCommandLine(Dependency a, String s) {\n+                accept(a, \"JAVA : \" + s);\n+            }\n+\n+            default void javaError(Dependency a, String s) {\n+                accept(a, \"JAVA : !!!\" + s);\n+                throw new RuntimeException(s);\n+            }\n+\n+            default void javaWarning(Dependency a, String s) {\n+                accept(a, \"JAVA : W \" + s);\n+            }\n+\n+            default void javaNote(Dependency a, String s) {\n+                accept(a, \"JAVA :\" + s);\n+            }\n+\n+            static JavaProgress adapt(Project.Id id) {\n+                return (id.project().progress instanceof JavaProgress progress) ? progress : new JavaProgress() {\n+                    @Override\n+                    public void accept(Dependency a, String s) {\n+                        id.project().progress.accept(a, s);\n+                    }\n+                };\n+            }\n+        }\n+\n+        private RunnableJar(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+            super(id, exclude, dependencies);\n+            id.project.add(this);\n+        }\n+\n+        static public RunnableJar of(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+            return new RunnableJar(id, exclude, dependencies);\n+        }\n+\n+        static public RunnableJar of(Project.Id id, Set<Path> exclude, Dependency... dependencies) {\n+            return of(id, exclude, Set.of(dependencies));\n+        }\n+\n+        static public RunnableJar of(Project.Id id, Set<Dependency> dependencies) {\n+            return new RunnableJar(id, Set.of(), dependencies);\n+        }\n+\n+        static public RunnableJar of(Project.Id id, Dependency... dependencies) {\n+            return of(id, Set.of(), Set.of(dependencies));\n+        }\n+\n+        @Override\n+        public List<Path> generatedPaths() {\n+            throw new IllegalStateException(\"who called me\");\n+        }\n+\n+        @Override\n+        public boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> args) {\n+            JavaProgress javaProgress = JavaProgress.adapt(id());\n+            List<String> opts = new ArrayList<>();\n+            opts.addAll(List.of(\n+                    \"\/Users\/grfrost\/github\/babylon-grfrost-fork\/build\/macosx-aarch64-server-release\/jdk\/bin\/java\",\n+                    \"--enable-preview\",\n+                    \"--enable-native-access=ALL-UNNAMED\"));\n+            if (id().name().equals(\"nbody\")) {\n+                opts.addAll(List.of(\n+                        \"-XstartOnFirstThread\"\n+                ));\n+            }\n+            opts.addAll(List.of(\n+                    \"--add-exports=jdk.incubator.code\/jdk.incubator.code.dialect.java.impl=ALL-UNNAMED\", \/\/ for OpRenderer\n+                    \"--class-path\", classPathWithThisLast(depsInOrder),\n+                    \"-Djava.library.path=\" + id().project().buildPath,\n+                    mainClassName\n+            ));\n+            opts.addAll(args);\n+            javaProgress.javaCommandLine(this, String.join(\" \", opts));\n+            try {\n+                var process = new ProcessBuilder().command(opts).redirectOutput(ProcessBuilder.Redirect.INHERIT).start();\n+                process.waitFor();\n+                return process.exitValue() == 0;\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+\n+    public static class CMake extends AbstractArtifactWithPath<CMake> implements Dependency.Buildable {\n+\n+\n+        public interface CMakeProgress extends Progress {\n+\n+            default void cmakeProgress(Dependency a, String s) {\n+                accept(a, \"CMAKE :\" + s);\n+            }\n+\n+            default void cmakeInfo(Dependency a, String s) {\n+                accept(a, \"CMAKE :\" + s);\n+            }\n+\n+            default void cmakeError(Dependency a, String s) {\n+                accept(a, \"CMAKE :!!\" + s);\n+            }\n+\n+            default void cmakeCommandLine(Dependency a, String s) {\n+                accept(a, \"CMAKE :\" + s);\n+            }\n+\n+            default void cmakeVerbose(Dependency a, String s) {\n+                accept(a, \"CMAKE :     \" + s);\n+            }\n+\n+            static CMakeProgress adapt(Project.Id id) {\n+                return (id.project().progress instanceof CMakeProgress progress) ? progress : new CMakeProgress() {\n+                    @Override\n+                    public void accept(Dependency a, String s) {\n+                        id.project().progress.accept(a, s);\n+                    }\n+                };\n+            }\n+\n+        }\n+\n+        public boolean cmake(Consumer<String> lineConsumer, List<String> tailopts) {\n+            List<String> opts = new ArrayList<>();\n+            opts.add(\"cmake\");\n+            opts.addAll(tailopts);\n+            boolean success;\n+            CMakeProgress cmakeProgres = CMakeProgress.adapt(id());\n+            cmakeProgres.cmakeCommandLine(this, String.join(\" \", opts));\n+            try {\n+                var process = new ProcessBuilder()\n+                        .command(opts)\n+                        .redirectErrorStream(true)\n+                        \/\/ .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .start();\n+                process.waitFor();\n+                new BufferedReader(new InputStreamReader(process.getInputStream())).lines()\n+                        .forEach(line -> {\n+                            lineConsumer.accept(line);\n+                            cmakeProgres.cmakeProgress(this, line);\n+                        });\n+                success = (process.exitValue() == 0);\n+\n+                if (!success) {\n+                    cmakeProgres.cmakeError(this, \"ERR \" + String.join(\" \", opts));\n+                    throw new RuntimeException(\"CMake failed\");\n+                }\n+                cmakeProgres.cmakeInfo(this, \"Done \" + String.join(\" \", opts));\n+            } catch (Exception e) {\n+                throw new IllegalStateException(e);\n+            }\n+            return success;\n+        }\n+\n+        @Override\n+        public List<Path> generatedPaths() {\n+            throw new IllegalStateException(\"who called me\");\n+        }\n+\n+        boolean cmake(Consumer<String> lineConsumer, String... opts) {\n+            return cmake(lineConsumer, List.of(opts));\n+        }\n+\n+        public boolean cmakeInit(Consumer<String> lineConsumer) {\n+            return cmake(lineConsumer, \"--fresh\", \"-DHAT_TARGET=\" + id().project().buildPath(), \"-B\", cmakeBuildDir().toString(), \"-S\", cmakeSourceDir().toString());\n+        }\n+\n+        public boolean cmakeBuildTarget(Consumer<String> lineConsumer, String target) {\n+            return cmake(lineConsumer, \"--build\", cmakeBuildDir().toString(), \"--target\", target);\n+        }\n+\n+        public boolean cmakeBuild(Consumer<String> lineConsumer) {\n+            return cmake(lineConsumer, \"--build\", cmakeBuildDir().toString());\n+        }\n+\n+        public boolean cmakeClean(Consumer<String> lineConsumer) {\n+            return cmakeBuildTarget(lineConsumer, \"clean\");\n+        }\n+\n+\n+        @Override\n+        public boolean build() {\n+            cmakeInit(_ -> {\n+            });\n+            cmakeBuild(_ -> {\n+            });\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean clean() {\n+            cmakeInit(_ -> {\n+            });\n+            cmakeClean(_ -> {\n+            });\n+            return false;\n+        }\n+\n+        final Path cmakeSourceDir;\n+        final Path cmakeBuildDir;\n+\n+        Path cmakeSourceDir() {\n+            return cmakeSourceDir;\n+        }\n+\n+        Path cmakeBuildDir() {\n+            return cmakeBuildDir;\n+        }\n+\n+        final Path CMakeLists_txt;\n+\n+        protected CMake(Project.Id gsn, Path cmakeSourceDir, Set<Dependency> dependencies) {\n+            super(gsn, dependencies);\n+            this.cmakeSourceDir = cmakeSourceDir;\n+            this.cmakeBuildDir = cmakeSourceDir.resolve(\"build\");\n+            this.CMakeLists_txt = cmakeSourceDir.resolve(\"CMakeLists.txt\");\n+        }\n+\n+        protected CMake(Project.Id id, Set<Dependency> dependencies) {\n+            this(id, id.path(), dependencies);\n+        }\n+\n+        public static CMake of(Project.Id id, Set<Dependency> dependencies) {\n+            return new CMake(id, dependencies);\n+        }\n+\n+        public static CMake of(Project.Id id, Dependency... dependencies) {\n+            return of(id, Set.of(dependencies));\n+        }\n+\n+    }\n+\n+\n+    public static class JExtract extends Jar {\n+        @Override\n+        public Path javaSourcePath() {\n+            return id.project.confPath.resolve(id().hyphenatedName).resolve(\"src\/main\/java\");\n+        }\n+\n+        public interface JExtractProgress extends Progress {\n+\n+            default void jextractProgress(Dependency a, String s) {\n+                accept(a, \"JEXTRACT :\" + s);\n+            }\n+\n+            default void jextractInfo(Dependency a, String s) {\n+                accept(a, \"JEXTRACT :\" + s);\n+            }\n+\n+            default void jextractCommandLine(Dependency a, String s) {\n+                accept(a, \"JEXTRACT :\" + s);\n+            }\n+\n+            default void jextractVerbose(Dependency a, String s) {\n+                accept(a, \"JEXTRACT :     \" + s);\n+            }\n+\n+            default void jextractError(Dependency a, String s) {\n+                accept(a, \"JEXTRACT :!!     \" + s);\n+            }\n+\n+            static JExtractProgress adapt(Project.Id id) {\n+                return (id.project().progress instanceof JExtractProgress progress) ? progress : new JExtractProgress() {\n+                    @Override\n+                    public void accept(Dependency a, String s) {\n+                        id.project().progress.accept(a, s);\n+                    }\n+                };\n+            }\n+        }\n+\n+\n+        public interface ExtractSpec {\n+            Path header();\n+\n+            List<Path> frameworks();\n+        }\n+\n+        record Mac(Path macSdkSysLibFrameWorks, Path macSysLibFrameWorks, Path header,\n+                   List<Path> frameworks) implements ExtractSpec {\n+            static Mac of(CMakeInfo cMakeInfo, String... frameworks) {\n+                var value = (String) cMakeInfo.properties.get(\"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\");\n+                Path macSdkSysLibFrameWorks = Path.of(value);\n+                Path macSysLibFrameWorks = Path.of(\"\/System\/Library\/Frameworks\");\n+                var firstName = frameworks[0];\n+                return new Mac(\n+                        macSdkSysLibFrameWorks,\n+                        macSysLibFrameWorks,\n+                        macSdkSysLibFrameWorks.resolve(firstName.toUpperCase() + \".framework\/Headers\/\" + firstName + \".h\"),\n+                        Stream.of(frameworks).map(s -> macSysLibFrameWorks.resolve(s + \".framework\/\" + s)).collect(Collectors.toList())\n+                );\n+            }\n+\n+            void writeCompileFlags(Path outputDir) {\n+                try {\n+                    Path compileFLags = outputDir.resolve(\"compile_flags.txt\");\n+                    Files.writeString(compileFLags, \"-F\" + macSdkSysLibFrameWorks + \"\\n\", StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n+                } catch (IOException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public boolean build() {\n+            try {\n+                id.project.mkdir(javaSourcePath());\n+\n+                List<String> opts = new ArrayList<>(List.of());\n+                opts.addAll(List.of(\n+                        \"\/Users\/grfrost\/jextract-22\/bin\/jextract\",\n+                        \"--target-package\", id().name(),\n+                        \"--output\", javaSourcePath().toString()\n+                ));\n+                spec.frameworks().forEach(library -> opts.addAll(List.of(\n+                        \"--library\", \":\" + library\n+                )));\n+                opts.addAll(List.of(\n+                        \"--header-class-name\", id().name() + \"_h\",\n+                        spec.header().toString()\n+                ));\n+                if (spec instanceof Mac mac) {\n+                    mac.writeCompileFlags(id().project().rootPath);\n+                }\n+                boolean success;\n+                JExtractProgress jExtractProgress = JExtractProgress.adapt(id());\n+                jExtractProgress.jextractCommandLine(this, String.join(\" \", opts));\n+                try {\n+                    var process = new ProcessBuilder()\n+                            .command(opts)\n+                            .redirectErrorStream(true)\n+                            .start();\n+                    process.waitFor();\n+                    new BufferedReader(new InputStreamReader(process.getInputStream())).lines()\n+                            .forEach(s -> jExtractProgress.jextractProgress(this, s));\n+                    success = (process.exitValue() == 0);\n+                    if (!success) {\n+                        jExtractProgress.jextractError(this, \"error \" + process.exitValue());\n+                    }\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(e);\n+                }\n+                super.build();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(e);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean clean() {\n+            \/\/ No opp\n+            return false;\n+        }\n+\n+        final ExtractSpec spec;\n+\n+        private JExtract(Project.Id id, ExtractSpec spec, Set<Path> exclude, Set<Dependency> dependencies) {\n+            super(id, exclude, dependencies);\n+            this.spec = spec;\n+            id.project.add(this);\n+        }\n+\n+        static JExtract of(Project.Id id, ExtractSpec spec, Set<Path> exclude, Set<Dependency> dependencies) {\n+            return new JExtract(id, spec, exclude, dependencies);\n+        }\n+\n+        static JExtract of(Project.Id id, ExtractSpec spec, Set<Path> exclude, Dependency... dependencies) {\n+            return of(id, spec, exclude, Set.of(dependencies));\n+        }\n+\n+        static JExtract of(Project.Id id, ExtractSpec spec, Set<Dependency> dependencies) {\n+            return new JExtract(id, spec, Set.of(), dependencies);\n+        }\n+\n+        static JExtract of(Project.Id id, ExtractSpec spec, Dependency... dependencies) {\n+            return of(id, spec, Set.of(), Set.of(dependencies));\n+        }\n+    }\n+\n+\n+    public static abstract class CMakeInfo extends Job.CMake implements Job.Dependency.Optional {\n+       \/* interface Mapper{\n+\n+        }\n+        interface PathMapper extends Mapper{\n+            Path map(String value);\n+            PathMapper impl =  (s)->Path.of(s);\n+        }\n+        interface BooleanMapper extends Mapper{\n+            boolean map(String value);\n+            BooleanMapper impl =  (s)->Boolean.getBoolean(s);\n+        }\n+        interface StringMapper extends Mapper{\n+            String map(String value);\n+            StringMapper impl =  (s)->s;\n+        }*\/\n+\n+        Path asPath(String key) {\n+            return properties.containsKey(key) ? Path.of((String) properties.get(key)) : null;\n+        }\n+\n+        boolean asBoolean(String key) {\n+            return properties.containsKey(key) && Boolean.parseBoolean((String) properties.get(key));\n+        }\n+\n+        String asString(String key) {\n+            return (properties.containsKey(key) && properties.get(key) instanceof String s) ? s : null;\n+        }\n+\n+\n+        final String find;\n+        final String response;\n+        final static String template = \"\"\"\n+                cmake_minimum_required(VERSION 3.22.1)\n+                project(extractions)\n+                find_package(__find__)\n+                get_cmake_property(_variableNames VARIABLES)\n+                foreach (_variableName ${_variableNames})\n+                   message(STATUS \"${_variableName}=${${_variableName}}\")\n+                endforeach()\n+                \"\"\";\n+\n+        final String text;\n+\n+        final Set<String> vars;\n+        Properties properties = new Properties();\n+        final Path propertiesPath;\n+\n+        final Map<String, String> otherVarMap = new LinkedHashMap<>();\n+        final boolean available;\n+\n+        CMakeInfo(Job.Project.Id id, String find, String response, Set<String> vars, Set<Job.Dependency> buildDependencies) {\n+            super(id, id.project().confPath().resolve(\"cmake-info\").resolve(find), buildDependencies);\n+            this.find = find;\n+            this.response = response;\n+            this.vars = vars;\n+            this.text = template.replaceAll(\"__find__\", find).replaceAll(\"__response__\", response);\n+            this.propertiesPath = cmakeSourceDir().resolve(\"properties\");\n+            if (Files.exists(propertiesPath)) {\n+                properties = new Properties();\n+                try {\n+                    properties.load(Files.newInputStream(propertiesPath));\n+\n+                } catch (IOException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            } else {\n+                id.project().mkdir(cmakeBuildDir());\n+                try {\n+                    Files.writeString(CMakeLists_txt, this.text, StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n+                    Pattern p = Pattern.compile(\"-- *([A-Za-z_0-9]+)=(.*)\");\n+                    cmakeInit((line) -> {\n+                        if (p.matcher(line) instanceof Matcher matcher && matcher.matches()) {\n+                            \/\/   System.out.println(\"GOT \"+matcher.group(1)+\"->\"+matcher.group(2));\n+                            if (vars.contains(matcher.group(1))) {\n+                                properties.put(matcher.group(1), matcher.group(2));\n+                            } else {\n+                                otherVarMap.put(matcher.group(1), matcher.group(2));\n+                            }\n+                        } else {\n+                            \/\/ System.out.println(\"skipped \" + line);\n+                        }\n+                    });\n+                    properties.store(Files.newOutputStream(propertiesPath), \"A comment\");\n+                } catch (IOException ioException) {\n+                    throw new IllegalStateException(ioException);\n+                }\n+            }\n+            available = asBoolean(response);\n+        }\n+\n+        @Override\n+        public boolean isAvailable() {\n+            return available;\n+        }\n+    }\n+\n+    public static class Mac extends Job.AbstractArtifact<Mac> implements Job.Dependency.Optional{\n+        Mac(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n+            super(id,  buildDependencies);\n+        }\n+\n+        @Override\n+        public boolean isAvailable() {\n+            return System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n+        }\n+    }\n+    public static class Linux extends Job.AbstractArtifact<Linux> implements Job.Dependency.Optional{\n+        Linux(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n+            super(id,  buildDependencies);\n+        }\n+\n+        @Override\n+        public boolean isAvailable() {\n+            return System.getProperty(\"os.name\").toLowerCase().contains(\"linux\");\n+        }\n+    }\n+    public static class OpenGL extends Job.CMakeInfo {\n+\n+        final Path glLibrary;\n+        OpenGL(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n+            super(id,  \"OpenGL\", \"OPENGL_FOUND\",Set.of(\n+                    \"OPENGL_FOUND\",\n+                    \"OPENGL_GLU_FOUND\",\n+                    \"OPENGL_gl_LIBRARY\",\n+                    \"OPENGL_glu_LIBRARY\",\n+                    \"CMAKE_HOST_SYSTEM_NAME\",\n+                    \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n+                    \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\"\n+            ), buildDependencies);\n+            System.out.println(\"HERE\");\n+            glLibrary = asPath(\"OpenGL_glu_Library\");\n+        }\n+\n+    }\n+\n+   public static class OpenCL extends Job.CMakeInfo{\n+\n+\n+        OpenCL(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n+            super(id,  \"OpenCL\", \"OPENCL_FOUND\", Set.of(\n+                    \"OPENCL_FOUND\",\n+                    \"CMAKE_HOST_SYSTEM_NAME\",\n+                    \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n+                    \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\"\n+            ), buildDependencies);\n+\n+        }\n+    }\n+  public static   class Cuda extends Job.CMakeInfo{\n+        Cuda(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n+            super(id,  \"CUDAToolkit\", \"CUDATOOLKIT_FOUND\",Set.of(\n+                    \"CUDATOOLKIT_FOUND\",\n+                    \"CMAKE_HOST_SYSTEM_NAME\",\n+                    \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n+                    \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\"\n+\n+            ), buildDependencies);\n+        }\n+    }\n+}\n+\n+\n","filename":"hat\/hat\/Job.java","additions":1267,"deletions":0,"binary":false,"changes":1267,"status":"added"}]}