{"files":[{"patch":"@@ -35,5 +35,5 @@\n-if (\"${SPIRV_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n-    set (SPIRV_BACKEND \"${CMAKE_SOURCE_DIR}\/spirv\")\n-    message(\"SPIRV_BACKEND=${SPIRV_BACKEND}\")\n-endif()\n-add_subdirectory(spirv)\n+#if (\"${SPIRV_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n+#    set (SPIRV_BACKEND \"${CMAKE_SOURCE_DIR}\/spirv\")\n+#    message(\"SPIRV_BACKEND=${SPIRV_BACKEND}\")\n+#endif()\n+#add_subdirectory(spirv)\n","filename":"hat\/backends\/ffi\/CMakeLists.txt","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+import static java.lang.IO.println;\n+\n+public static String separated(List<String> strings, String separator) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    strings.forEach(opt -> {\n+        if (opt != null) {\n+            stringBuilder.append(stringBuilder.isEmpty() ? \"\" : separator).append(opt);\n+        }\n+    });\n+    return stringBuilder.toString();\n+}\n+\n+static boolean process(Consumer<String> consumer, List<String> opts) {\n+    if (consumer == null) {\n+        consumer = (s) -> println(\"NULL consumer\" + s);\n+    }\n+    boolean success = false;\n+    try {\n+        var process = new ProcessBuilder().command(opts).redirectErrorStream(true).start();\n+        process.waitFor();\n+        new BufferedReader(new InputStreamReader(process.getInputStream())).lines().forEach(consumer);\n+        success = (process.exitValue() == 0);\n+        if (!success) {\n+            println(\"process returned error \" + process.exitValue());\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+        throw new IllegalStateException(e);\n+    }\n+    return success;\n+}\n+\n+static boolean process(List<String> opts) {\n+    return process(s -> println(s), opts);\n+}\n+\n+static boolean process(Consumer<String> consumer, String... opts) {\n+    return process(consumer, List.of(opts));\n+}\n+\n+static boolean process(String... opts) {\n+    return process(s -> println(s), List.of(opts));\n+}\n+\n+public interface ProjectProvider {\n+    Project project();\n+\n+    default void run(Consumer<String> consumer, ProjectProvider backend, List<String> args) throws IOException, InterruptedException {\n+        project().runit(project().mainClassName, backend.project(), consumer, args);\n+    }\n+    default void run(Consumer<String> consumer, ProjectProvider backend, String ... args) throws IOException, InterruptedException {\n+       run(consumer, backend.project(), List.of(args));\n+    }\n+\n+    default void run(Consumer<String> consumer, List<String> args) throws IOException, InterruptedException {\n+        project().runit(project().mainClassName, null, consumer, args);\n+    }\n+    default void run(Consumer<String> consumer, String args) throws IOException, InterruptedException {\n+       run (consumer, List.of(args));\n+    }\n+\n+    default ProjectProvider compile(Consumer<String> consumer) {\n+        if (project().needsCompiling()) {\n+            return project().compileIt(consumer);\n+        }\n+        return this;\n+    }\n+}\n+public static final class JavaSource extends SimpleJavaFileObject {\n+    Path path;\n+\n+    @Override\n+    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+        try {\n+            return Files.readString(Path.of(toUri()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    JavaSource(Path path) {\n+        super(path.toUri(), Kind.SOURCE);\n+        this.path = path;\n+    }\n+    static JavaSource of(Path path) {\n+        return new JavaSource(path);\n+    }\n+\n+    public Path path() {\n+        return path;\n+    }\n+}\n+public record Project(String name, String mainClassName, Path root, Path sourcePath, Path buildDir, Path classDir,\n+                      Set<ProjectProvider> dependencies, Path jarFile,\n+                      List<JavaSource> sourceFiles) implements ProjectProvider {\n+\n+    public record JavaSourceN(Path path, SimpleJavaFileObject impl) implements JavaFileObject {\n+        @Override\n+        public URI toUri() {\n+            return impl.toUri();\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return impl.getName();\n+        }\n+\n+        @Override\n+        public InputStream openInputStream() throws IOException {\n+            return impl.openInputStream();\n+        }\n+\n+        @Override\n+        public OutputStream openOutputStream() throws IOException {\n+            return impl.openOutputStream();\n+        }\n+\n+        @Override\n+        public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n+            return impl.openReader(ignoreEncodingErrors);\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            try {\n+                return Files.readString(Path.of(toUri()));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public Writer openWriter() throws IOException {\n+            return impl.openWriter();\n+        }\n+\n+        @Override\n+        public long getLastModified() {\n+            return impl.getLastModified();\n+        }\n+\n+        @Override\n+        public boolean delete() {\n+            return impl.delete();\n+        }\n+\n+        static JavaSourceN of(Path path) {\n+            return new JavaSourceN(path,  new SimpleJavaFileObject(path.toUri(), Kind.SOURCE){});\n+        }\n+\n+        @Override\n+        public Kind getKind() {\n+            return impl.getKind();\n+        }\n+\n+        @Override\n+        public boolean isNameCompatible(String simpleName, Kind kind) {\n+            return impl.isNameCompatible(simpleName, kind);\n+        }\n+\n+        @Override\n+        public NestingKind getNestingKind() {\n+            return impl.getNestingKind();\n+        }\n+\n+        @Override\n+        public Modifier getAccessLevel() {\n+            return impl.getAccessLevel();\n+        }\n+    }\n+\n+\n+    public Path path() {\n+        return jarFile;\n+    }\n+\n+    @Override\n+    public Project project() {\n+        return this;\n+    }\n+\n+    public boolean needsCompiling() {\n+        return !Files.exists(jarFile);\n+    }\n+\n+    public record Result(Project project, boolean ok, List<JavaFileObject> classes,\n+                         Path jar,\n+                         List<PathAndRoot> jaredPathsWithRoots, List<Path> jarPaths,\n+                         List<Diagnostic<? extends JavaFileObject>> javacDiagnostics,\n+                         List<Diagnostic<?>> jarDiagnostics) implements ProjectProvider { }\n+\n+    public static Project of(String name, String mainClassName, Path root, String version, Path buildDir, ProjectProvider... classPathEntries) {\n+        try {\n+            var sourcePath = root.resolve(\"src\/main\/java\");\n+            var src = Files.walk(sourcePath).filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\".java\")).map(JavaSource::of).toList();\n+            var classDir = buildDir.resolve(name + \"-\" + version + \".classes\");\n+            var jarFile = buildDir.resolve(name + \"-\" + version + \".jar\");\n+            return new Project(name, mainClassName, root, sourcePath, buildDir, classDir, new LinkedHashSet<>(Arrays.asList(classPathEntries)), jarFile, src);\n+        } catch (IOException e) {\n+            \/\/ throw new RuntimeException(e);\n+            return null;\n+        }\n+    }\n+\n+\n+    public static Project example(Path root, Path buildDir, ProjectProvider... classPathEntries) {\n+        return of(\"hat-example-\" + root.getFileName().toString(), root.getFileName().toString() + \".Main\", root, \"1.0\", buildDir, classPathEntries);\n+    }\n+\n+    public static Project backend(Path root, Path buildDir, ProjectProvider... classPathEntries) {\n+\n+        return of(\"hat-backend-\" + root.getParent().getFileName().toString() + \"-\" + root.getFileName().toString(), null, root, \"1.0\", buildDir, classPathEntries);\n+    }\n+\n+    Result compileIt(Consumer<String> consumer) {\n+        if (!needsCompiling()) {\n+            throw new IllegalStateException(\"does not need compiling not called\");\n+        }\n+\n+        List<String> opts = new ArrayList<>(\n+                List.of(\n+                        \"--source\", \"26\",\n+                        \"--enable-preview\",\n+                        \"--add-modules\", \"jdk.incubator.code\",\n+                        \"-d\", classDir.toString(),\n+                        \"--class-path\", separated(dependencies.stream().map(cpe -> cpe.project().jarFile.toString()).toList(), \":\"),\n+                        \"--source-path\", sourcePath.toString()\n+                )\n+        );\n+        \/\/   if (verbose) {\n+        println(separated(opts, \" \"));\n+        \/\/ }\n+        JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n+        DiagnosticCollector<JavaFileObject> javacDiagnostics = new DiagnosticCollector<>();\n+\n+\n+        JavaCompiler.CompilationTask compilationTask =\n+                (javac.getTask(\n+                        new PrintWriter(System.err),\n+                        javac.getStandardFileManager(javacDiagnostics, null, null),\n+                        javacDiagnostics,\n+                        opts,\n+                        null,\n+                        sourceFiles\n+                ));\n+        JavacTask javacTask = (JavacTask) compilationTask;\n+        List<JavaFileObject> generatedClasses = new ArrayList<>();\n+        try {\n+            rmdir(classDir);\n+            Files.createDirectories(classDir);\n+\n+            javacTask.generate().forEach(generatedClasses::add);\n+            Path resourceDir = root.resolve(\"src\/main\/resources\");\n+\n+            List<Path> dirsToJar = new ArrayList<>(List.of(classDir));\n+            if (Files.exists(resourceDir)) {\n+                dirsToJar.add(resourceDir);\n+            }\n+            List<Diagnostic<?>> jarDiagnostics = new ArrayList<>();\n+            var jarStream = new JarOutputStream(Files.newOutputStream(jarFile));\n+            Manifest manifest = null;\/\/new Manifest(null, null, null,null,null);\n+            if (manifest != null) {\n+                var entry = new JarEntry(\"META-INF\/MANIFEST.MF\");\n+                jarStream.putNextEntry(entry);\n+                manifest.writeTo(jarStream);\n+                jarStream.closeEntry();\n+            }\n+\n+\n+            List<PathAndRoot> pathsToJar = new ArrayList<>();\n+            dirsToJar.forEach(root -> {\n+                try {\n+                    Files.walk(root).map(path -> new PathAndRoot(root, path)).forEach(pathsToJar::add);\n+                } catch (Exception e) {\n+\n+                }\n+            });\n+            List<Path> filePaths = new ArrayList<>();\n+            pathsToJar.stream()\n+                    .sorted(Comparator.comparing(PathAndRoot::path))\n+                    .forEach(\n+                            rootAndPath -> {\n+                                try {\n+                                    if (!Files.isDirectory(rootAndPath.path)) {\n+                                        filePaths.add(rootAndPath.path);\n+                                        var relative = rootAndPath.root.relativize(rootAndPath.path);\n+                                        var entry = new JarEntry(relative.toString());\n+                                        entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                                        jarStream.putNextEntry(entry);\n+                                        Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                                        jarStream.closeEntry();\n+                                        \/\/   if (verbose) {\n+                                        \/\/println(\"INFO: adding \" + rootAndPath.relativize().toString());\n+                                        \/\/  }\n+                                    }\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            });\n+            jarStream.finish();\n+            jarStream.close();\n+            \/\/ if (verbose) {\n+            \/\/ println(\"INFO: created \" + jarFile.toString());\n+            \/\/}\n+            return new Result(this, true, generatedClasses, jarFile, pathsToJar, filePaths, javacDiagnostics.getDiagnostics(), jarDiagnostics);\n+        } catch (IOException e) {\n+            println(e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    public record PathAndRoot(Path root, Path path) {\n+        Path relativize() {\n+            return root.relativize(path());\n+        }\n+    }\n+\n+    public record Manifest(String mainClass, String[] classPath, String version, String createdBy, String buildBy) {\n+\n+        public void writeTo(JarOutputStream jarStream) {\n+            PrintWriter printWriter = new PrintWriter(jarStream);\n+            if (version != null) {\n+                printWriter.println(\"Manifest-Version: \" + version);\n+            }\n+            if (mainClass != null) {\n+                printWriter.println(\"Main-Class: \" + mainClass);\n+            }\n+            if (classPath != null) {\n+                printWriter.print(\"Class-Path:\");\n+                for (String s : classPath) {\n+                    printWriter.print(\" \");\n+                    printWriter.print(s);\n+                }\n+                printWriter.println();\n+            }\n+            printWriter.flush();\n+        }\n+    }\n+\n+\n+    void runit(String classToRun, ProjectProvider backend, Consumer<String> consumer, List<String> args) throws IOException, InterruptedException {\n+        \/\/ before we start lets ensure all the dependencies are compiled\n+        Set<ProjectProvider> allDependencies = new LinkedHashSet<>();\n+        dependencies.forEach(classPathEntry -> classPathEntry.project().collect(allDependencies));\n+        if (backend != null) {\n+            backend.project().collect(allDependencies);\n+        }\n+        allDependencies.add(this);\n+        allDependencies.forEach(p ->\n+                p.compile(consumer)\n+        );\n+        List<String> opts = new ArrayList<>();\n+\n+        var colonSeperated = separated(allDependencies.stream().filter(Objects::nonNull).map(cpe -> cpe.project().jarFile.toString()).toList(), \":\");\n+\n+        opts.addAll(List.of(\n+                \"\/Users\/grfrost\/github\/babylon-grfrost-fork\/build\/macosx-aarch64-server-release\/jdk\/bin\/java\",\n+                \"--enable-preview\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"--class-path\", colonSeperated,\n+                \"-Djava.library.path=\" + buildDir.toString(),\n+                classToRun != null ? classToRun : mainClassName\n+        ));\n+        opts.addAll(args);\n+        process(consumer, opts);\n+    }\n+\n+    private void collect(Set<ProjectProvider> all) {\n+\n+        dependencies.forEach(classPathEntry -> classPathEntry.project().collect(all));\n+        all.add(this);\n+    }\n+\n+}\n+\n+static Path rmdir(Path path) {\n+    try {\n+        if (Files.exists(path)) {\n+            Files.walk(path)\n+                    .sorted(Comparator.reverseOrder())\n+                    .map(Path::toFile)\n+                    .forEach(File::delete);\n+        }\n+    } catch (IOException ioe) {\n+        System.out.println(ioe);\n+        throw new RuntimeException(ioe);\n+    }\n+    return path;\n+}\n+\n+record CMaker(boolean verbose, Path dir, Path hatBuildDir, Path cmakeBuildDir) {\n+\n+    static CMaker of(boolean verbose, Path dir, Path hatBuildDir) {\n+        var cmakeBuildDir = dir.resolve(\"build\");\n+        try {\n+            rmdir(cmakeBuildDir);\n+            Files.createDirectories(cmakeBuildDir);\n+            return new CMaker(verbose, dir, hatBuildDir, cmakeBuildDir);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public boolean init(Consumer<String> consumer) {\n+        return process(consumer, \"cmake\",  \"--fresh\", \"-DHAT_TARGET=\" + hatBuildDir, \"-B\", cmakeBuildDir.toString(), \"-S\", dir.toString());\n+    }\n+\n+    public boolean build(Consumer<String> consumer) {\n+        return process(consumer, \"cmake\", \"--build\", cmakeBuildDir.toString());\n+    }\n+    public boolean build(Consumer<String> consumer, String target ) {\n+        return process(consumer, \"cmake\", \"--build\", cmakeBuildDir.toString(), \"--target\", target);\n+    }\n+}\n+\n+\n+public static final Path userDir = Path.of(System.getProperty(\"user.dir\"));\n+public static final Path rootDir = userDir.getFileName().toString().equals(\"intellij\") ? userDir.getParent() : userDir;\n+public static final Path buildDir = rootDir.resolve(\"build\");\n+public static final Project hatCore = Project.of(\"hat-core\", null, rootDir.resolve(\"hat-core\"), \"1.0\", buildDir);\n+public static final Path backendsDir = rootDir.resolve(\"backends\");\n+public static final Path ffiBackendsDir = backendsDir.resolve(\"ffi\");\n+public static final Project ffiSharedBackend = Project.backend(ffiBackendsDir.resolve(\"shared\"), buildDir, hatCore);\n+public static final Project cudaFFiBackend = Project.backend(ffiBackendsDir.resolve(\"cuda\"), buildDir, hatCore, ffiSharedBackend);\n+public static final Project openclFFiBackend = Project.backend(ffiBackendsDir.resolve(\"opencl\"), buildDir, hatCore, ffiSharedBackend);\n+public static final Project mockFFiBackend = Project.backend(ffiBackendsDir.resolve(\"mock\"), buildDir, hatCore, ffiSharedBackend);\n+public static final Path javaBackendsDir = backendsDir.resolve(\"java\");\n+public static final Project javaMtBackend = Project.backend(javaBackendsDir.resolve(\"mt\"), buildDir, hatCore);\n+public static final Project javaSeqBackend = Project.backend(javaBackendsDir.resolve(\"seq\"), buildDir, hatCore);\n+public static final Path examplesDir = rootDir.resolve(\"examples\");\n+public static final Project mandel = Project.example(examplesDir.resolve(\"mandel\"), buildDir, hatCore);\n+public static final Project life = Project.example(examplesDir.resolve(\"life\"), buildDir, hatCore);\n+public static final Project squares = Project.example(examplesDir.resolve(\"squares\"), buildDir, hatCore);\n+public static final Project heal = Project.example(examplesDir.resolve(\"heal\"), buildDir, hatCore);\n+public static final Project violaJones = Project.example(examplesDir.resolve(\"violajones\"), buildDir, hatCore);\n+public static final List<Project> examples = List.of(squares,mandel,life,heal,violaJones);\n+public static final List<Project> backends = List.of(openclFFiBackend,javaMtBackend,javaSeqBackend,cudaFFiBackend,mockFFiBackend);\n+public static Project example(String n){\n+    return examples.stream()\n+            \/\/.peek(p->println(p.name()))\n+            .filter(p->p.name().equals(\"hat-example-\"+n))\n+            .findFirst().orElse(null);\n+}\n+public static Project backend(String n){\n+    return backends.stream()\n+            .peek(p->println(p.name()))\n+            .filter(p->p.name().equals(\"hat-backend-\"+n))\n+            .findFirst().orElse(null);\n+}\n+\n+\n+\n+\n+public static void main(String[] argArr) throws IOException, InterruptedException {\n+\n+    var args = new ArrayList<>(List.of(argArr));\n+    var out = (Consumer<String>) IO::println;\n+    var command = args.isEmpty()?null:args.removeFirst();\n+\n+    if (\"clean\".equals(command)) {\n+        rmdir(buildDir);\n+\n+        command = args.isEmpty()?null:args.removeFirst();\n+        if (command == null) {\n+            System.exit(0);\n+        }\n+    }\n+    if (\"bld\".equals(command)) {\n+        backends.forEach(p->((ProjectProvider)p).compile(out));\n+        examples.forEach(p ->((ProjectProvider)p).compile(out) );\n+        if (CMaker.of(false, ffiBackendsDir, buildDir) instanceof CMaker cmaker) {\n+            if (cmaker.init(out)) {\n+                if (cmaker.build(out)) {\n+                    System.out.println(\"cmake finished\");\n+                }\n+            }\n+        }\n+    }else if (\"run\".equals(command) && args.size()>1){\n+        var backendName =args.removeFirst();\n+        var exampleName = args.removeFirst();\n+        System.out.println(\"Try to run example \"+exampleName+\" with backend \"+backendName);\n+        if (backend(backendName) instanceof ProjectProvider backend){\n+            if (backendName.startsWith(\"ffi\") && !Files.exists(backend.project().jarFile)) {\n+                if (CMaker.of(false, ffiBackendsDir, buildDir) instanceof CMaker cmaker) {\n+                    if (cmaker.init(out)) {\n+                        if (cmaker.build(out, backendName.substring(4)+\"_backend\")) {\n+                            System.out.println(\"cmake created \"+backendName+\" backend\");\n+                        }\n+                    }\n+                }\n+            }\n+            if (example(exampleName) instanceof ProjectProvider example){\n+                example.run(out, backend, args);\n+            }else{\n+                System. out.println(\"Failed to find \"+exampleName);\n+            }\n+        }else{\n+            System. out.println(\"Failed to find backend \"+backendName);\n+        }\n+\n+     }else{\n+         System. out.println(\"What? \");\n+     }\n+\n+}\n+\n+\n","filename":"hat\/hat\/HAT.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"},{"patch":"@@ -5,0 +5,1 @@\n+    <mapping directory=\"$PROJECT_DIR$\/..\/..\/..\/beehive-spirv-toolkit\" vcs=\"Git\" \/>\n","filename":"hat\/intellij\/.idea\/vcs.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}