{"files":[{"patch":"@@ -32,1 +32,1 @@\n-public abstract class HATF16Op extends HATOp {\n+public abstract class HATF16Op extends HATOp implements HATVarOp{\n@@ -45,1 +45,1 @@\n-\n+    @Override\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16Op.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public abstract class HATMemoryOp extends HATOp {\n+public abstract class HATMemoryOp extends HATOp implements HATVarOp {\n@@ -47,0 +47,1 @@\n+    @Override\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.device;\n+package hat.dialect;\n@@ -27,1 +27,2 @@\n-public interface DeviceType {\n+public interface HATVarOp {\n+    String varName();\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVarOp.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceType.java","status":"copied"},{"patch":"@@ -33,1 +33,1 @@\n-public abstract class HATVectorOp extends HATOp {\n+public abstract class HATVectorOp extends HATOp implements HATVarOp  {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import java.util.regex.Pattern;\n@@ -100,6 +101,12 @@\n- static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n-     if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp && isKernelContext(lookup,fieldAccessOp.fieldDescriptor().refType())){\n-         return predicate.test(fieldAccessOp)?fieldAccessOp:null;\n-     }\n-     return null;\n- }\n+    static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n+        if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp && isKernelContext(lookup,fieldAccessOp.fieldDescriptor().refType())){\n+            return predicate.test(fieldAccessOp)?fieldAccessOp:null;\n+        }\n+        return null;\n+    }\n+    static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, String name) {\n+        return asKernelContextFieldAccessOrNull(lookup,ce,fieldAccessOp->name.equals(fieldAccessOp.fieldDescriptor().name()));\n+    }\n+    static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Pattern pattern) {\n+        return asKernelContextFieldAccessOrNull(lookup,ce,fieldAccessOp->pattern.matcher(fieldAccessOp.fieldDescriptor().name()).matches());\n+    }\n@@ -293,8 +300,7 @@\n-                (   (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-                        || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-                        || (op instanceof HATMemoryOp)\n-                        || (op instanceof HATVectorVarOp)\n-                        || (op instanceof HATF16VarOp)\n-                )\n-                        && !(op instanceof CoreOp.VarOp varOp && paramVar(varOp) != null)\n-                        && !(op instanceof CoreOp.YieldOp));\n+        (\n+                (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+             || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+             || (op instanceof HATVarOp)\n+        )\n+        && !(op instanceof CoreOp.VarOp varOp && paramVar(varOp) != null)\n+        && !(op instanceof CoreOp.YieldOp));\n@@ -632,1 +638,24 @@\n-      record CallSite(Class<?> clazz,String methodName, boolean tracing){\n+    static Op.Result asResultOrNull(Value operand) {\n+        return operand instanceof Op.Result result?result:null;\n+    }\n+    static boolean isResult(Value operand) {\n+        return Objects.nonNull(asResultOrNull(operand));\n+    }\n+\n+    static Op opOfResultOrNull(Op.Result result) {\n+        return result.op() instanceof Op op?op:null;\n+    }\n+\n+    static TypeElement resultTypeOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return varLoadOp.resultType() instanceof TypeElement typeElement?typeElement:null;\n+    }\n+\n+    static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n+        return  op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n+    }\n+\n+    static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n+        return OpTk.isAssignable(lookup, varLoadOp.resultType(), classes);\n+    }\n+\n+    record CallSite(Class<?> clazz,String methodName, boolean tracing){\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":44,"deletions":15,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.KernelContext;\n@@ -42,0 +43,3 @@\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n@@ -62,0 +66,1 @@\n+\n@@ -65,14 +70,11 @@\n-\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                .filter(codeElement ->codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp)\n-                .map(codeElement -> (JavaOp.FieldAccessOp.FieldLoadOp)codeElement)\n-                .filter(fieldLoadOp -> pattern().matcher(fieldLoadOp.fieldDescriptor().name()).matches())\n-                .mapMulti((fieldLoadOp, consumer) ->\n-                            fieldLoadOp.operands().stream()\n-                                    .filter(o -> o instanceof Op.Result result && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                                    .map(o -> (CoreOp.VarAccessOp.VarLoadOp) ((Op.Result) o).op())\n-                                    .filter(this::isMethodFromHatKernelContext)\n-                                    .forEach(varLoadOp -> {\n-                                        consumer.accept(fieldLoadOp);\n-                                        consumer.accept(varLoadOp);\n-                                    })\n+        Set<Op> ops = new LinkedHashSet<>();\n+        funcOp.elements()\n+                .map(ce -> OpTk.asNamedKernelContextFieldAccessOrNull(accelerator.lookup,ce,pattern()))\n+                .filter(Objects::nonNull)\n+                .forEach(fieldLoadOp -> fieldLoadOp.operands().stream()\n+                    .map(OpTk::asResultOrNull)\n+                    .map(OpTk::opOfResultOrNull)\n+                    .map(OpTk::asVarLoadOrNull)\n+                    .filter(Objects::nonNull) \/\/ ((Result)operand).op()) instanceof VarLoad varload && varload is KernelContext.class\n+                    .findFirst()\n+                    .ifPresent(varLoadOp -> ops.addAll(Set.of(fieldLoadOp,varLoadOp)))\n@@ -81,17 +83,8 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-\n-\n-        funcOp = OpTk.transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n-            CodeContext context = blockBuilder.context();\n-            if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                fieldLoadOp.operands().stream()\/\/does a field Load not have 1 operand?\n-                        .filter(operand->operand instanceof Op.Result result && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                        .map(operand->(CoreOp.VarAccessOp.VarLoadOp)((Op.Result)operand).op())\n-                        .forEach(_-> { \/\/ why are we looping over all operands ?\n-                            HATThreadOp threadOp = factory(fieldLoadOp);\n-                            Op.Result threadResult = blockBuilder.op(threadOp);\n-                            threadOp.setLocation(fieldLoadOp.location()); \/\/ update location\n-                            context.mapValue(fieldLoadOp.result(), threadResult);\n-                        });\n+        funcOp = OpTk.transform(here, funcOp, ops::contains, (bb, op) -> {\n+            CodeContext ctx = bb.context();\n+            switch (op){\n+                case CoreOp.VarAccessOp.VarLoadOp  $->\n+                        ctx.mapValue($.result(), ctx.getValue($.operands().getFirst()));\n+                case JavaOp.FieldAccessOp.FieldLoadOp $->\n+                        ctx.mapValue($.result(), bb.op(OpTk.copyLocation($,factory($))).op().result());\n+                default -> throw new RuntimeException(\"We should never get here\");\n@@ -99,1 +92,1 @@\n-            return blockBuilder;\n+            return bb;\n@@ -104,1 +97,1 @@\n-    public CoreOp.FuncOp applyTxfmr(CoreOp.FuncOp funcOp) {\n+    public CoreOp.FuncOp applyTxform(CoreOp.FuncOp funcOp) {\n@@ -119,4 +112,4 @@\n-    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n-    }\n+    \/\/private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+     \/\/   String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+      \/\/  return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+   \/\/ }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":30,"deletions":37,"binary":false,"changes":67,"status":"modified"}]}