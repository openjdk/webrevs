{"files":[{"patch":"@@ -104,1 +104,1 @@\n-            hcl = l.defineHiddenClass(classBytes, true);\n+            hcl = l.defineHiddenClass(classBytes, true, MethodHandles.Lookup.ClassOption.NESTMATE);\n@@ -800,0 +800,1 @@\n+                        \/\/ @@@ var args\n@@ -801,6 +802,4 @@\n-                        \/\/ @@@ Enhance method descriptor to include how the method is to be invoked\n-                        \/\/ Example result of DirectMethodHandleDesc.toString()\n-                        \/\/   INTERFACE_VIRTUAL\/IntBinaryOperator::applyAsInt(IntBinaryOperator,int,int)int\n-                        \/\/ This will avoid the need to reflectively operate on the descriptor\n-                        \/\/ which may be insufficient in certain cases.\n-                        DirectMethodHandleDesc.Kind descKind;\n+                        \/\/ Resolve referenced class to determine if interface\n+                        MethodRef md = op.invokeDescriptor();\n+                        JavaType refType = (JavaType)md.refType();\n+                        Class<?> refClass;\n@@ -808,1 +807,1 @@\n-                            descKind = resolveToMethodHandleDesc(lookup, op.invokeDescriptor()).kind();\n+                             refClass = (Class<?>)refType.erasure().resolve(lookup);\n@@ -810,3 +809,19 @@\n-                            \/\/ @@@ Approximate fallback\n-                            if (op.hasReceiver()) {\n-                                descKind = DirectMethodHandleDesc.Kind.VIRTUAL;\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                        \/\/ Determine invoke opcode\n+                        final boolean isInterface = refClass.isInterface();\n+                        final boolean isInstance = op.hasReceiver();\n+                        final boolean isSuper = op instanceof InvokeOp.InvokeSuperOp;\n+                        Opcode invokeOpcode;\n+                        if (isInstance) {\n+                            if (isSuper) {\n+                                \/\/ @@@ We cannot generate an invokespecial as it will result in a verify error,\n+                                \/\/     since the owner is not assignable to generated hidden class\n+                                \/\/ @@@ Construct method handle via lookup.findSpecial\n+                                \/\/     using the lookup's class as the specialCaller and\n+                                \/\/     add that method handle to the to be defined hidden class's constant data\n+                                \/\/     Use and ldc+constant dynamic to access the class data,\n+                                \/\/     extract the method handle and then invoke it\n+                                throw new UnsupportedOperationException(\"invoke super unsupported: \" + op.invokeDescriptor());\n+                            } else if (isInterface) {\n+                                invokeOpcode = Opcode.INVOKEINTERFACE;\n@@ -814,1 +829,1 @@\n-                                descKind = DirectMethodHandleDesc.Kind.STATIC;\n+                                invokeOpcode = Opcode.INVOKEVIRTUAL;\n@@ -816,0 +831,2 @@\n+                        } else {\n+                            invokeOpcode = Opcode.INVOKESTATIC;\n@@ -817,1 +834,0 @@\n-                        MethodRef md = op.invokeDescriptor();\n@@ -820,10 +836,2 @@\n-                                switch (descKind) {\n-                                    case STATIC, INTERFACE_STATIC   -> Opcode.INVOKESTATIC;\n-                                    case VIRTUAL                    -> Opcode.INVOKEVIRTUAL;\n-                                    case INTERFACE_VIRTUAL          -> Opcode.INVOKEINTERFACE;\n-                                    case SPECIAL, INTERFACE_SPECIAL -> Opcode.INVOKESPECIAL;\n-                                    default ->\n-                                        throw new IllegalStateException(\"Bad method descriptor resolution: \"\n-                                                                        + op.opType() + \" > \" + op.invokeDescriptor());\n-                                },\n-                                ((JavaType) md.refType()).toNominalDescriptor(),\n+                                invokeOpcode,\n+                                refType.toNominalDescriptor(),\n@@ -832,4 +840,1 @@\n-                                switch (descKind) {\n-                                    case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> true;\n-                                    default -> false;\n-                                });\n+                                isInterface);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":32,"deletions":27,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -416,0 +416,1 @@\n+            MethodType target = resolveToMethodType(l, o.opType());\n@@ -417,2 +418,14 @@\n-            if (co.hasReceiver()) {\n-                mh = methodHandle(l, co.invokeDescriptor());\n+            \/\/ @@@ This does not work for vararg methods\n+\/\/            if (co.hasReceiver()) {\n+\/\/                if (co instanceof CoreOp.InvokeOp.InvokeSuperOp) {\n+\/\/                    MethodHandles.Lookup in = l.in(target.parameterType(0));\n+\/\/                    mh = resolveToMethodHandle(in, co.invokeDescriptor(), MethodRef.ResolveKind.invokeSuper);\n+\/\/                } else {\n+\/\/                    mh = resolveToMethodHandle(l, co.invokeDescriptor(), MethodRef.ResolveKind.invokeInstance);\n+\/\/                }\n+\/\/            } else {\n+\/\/                mh = resolveToMethodHandle(l, co.invokeDescriptor(), MethodRef.ResolveKind.invokeClass);\n+\/\/            }\n+            if (co instanceof CoreOp.InvokeOp.InvokeSuperOp) {\n+                MethodHandles.Lookup in = l.in(target.parameterType(0));\n+                mh = resolveToMethodHandle(in, co.invokeDescriptor(), MethodRef.ResolveKind.invokeSuper);\n@@ -420,1 +433,2 @@\n-                mh = methodStaticHandle(l, co.invokeDescriptor());\n+                \/\/ @@@ resolves to class or instance method handle\n+                mh = resolveToMethodHandle(l, co.invokeDescriptor());\n@@ -422,1 +436,1 @@\n-            MethodType target = resolveToMethodType(l, o.opType());\n+\n@@ -616,8 +630,0 @@\n-    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodRef d) {\n-        return resolveToMethodHandle(l, d);\n-    }\n-\n-    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodRef d) {\n-        return resolveToMethodHandle(l, d);\n-    }\n-\n@@ -667,0 +673,8 @@\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, MethodRef.ResolveKind kind) {\n+        try {\n+            return d.resolveToHandle(l, kind);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1399,2 +1399,1 @@\n-    @OpFactory.OpDeclaration(InvokeOp.NAME)\n-    public static final class InvokeOp extends CoreOp\n+    public sealed static abstract class InvokeOp extends CoreOp\n@@ -1408,11 +1407,0 @@\n-        public static InvokeOp create(ExternalizedOp def) {\n-            MethodRef invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n-                    true, v -> switch (v) {\n-                        case String s -> MethodRef.ofString(s);\n-                        case MethodRef md -> md;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n-                    });\n-\n-            return new InvokeOp(def, invokeDescriptor);\n-        }\n-\n@@ -1433,11 +1421,2 @@\n-        @Override\n-        public InvokeOp transform(CopyContext cc, OpTransformer ot) {\n-            return new InvokeOp(this, cc);\n-        }\n-\n-        InvokeOp(MethodRef invokeDescriptor, List<Value> args) {\n-            this(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n-        }\n-\n-        InvokeOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-            super(NAME, args);\n+        InvokeOp(String name, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+            super(name, args);\n@@ -1468,0 +1447,71 @@\n+\n+        static MethodRef createInvokeDescriptor(ExternalizedOp def) {\n+            return def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n+                    true, v -> switch (v) {\n+                        case String s -> MethodRef.ofString(s);\n+                        case MethodRef md -> md;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n+                    });\n+        }\n+\n+\n+        \/**\n+         * The invoke instance or class (static) operation, that can model Java language instance or class method\n+         * invocation expressions.\n+         *\/\n+        @OpFactory.OpDeclaration(InvokeInstanceClassOp.NAME)\n+        public static final class InvokeInstanceClassOp extends InvokeOp {\n+            public static final String NAME = InvokeOp.NAME;\n+\n+            public static InvokeInstanceClassOp create(ExternalizedOp def) {\n+                return new InvokeInstanceClassOp(def, createInvokeDescriptor(def));\n+            }\n+\n+            InvokeInstanceClassOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n+                super(def, invokeDescriptor);\n+            }\n+\n+            InvokeInstanceClassOp(InvokeOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public InvokeInstanceClassOp transform(CopyContext cc, OpTransformer ot) {\n+                return new InvokeInstanceClassOp(this, cc);\n+            }\n+\n+            InvokeInstanceClassOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+                super(NAME, resultType, invokeDescriptor, args);\n+            }\n+        }\n+\n+        \/**\n+         * The invoke super operation, that can model Java language super method\n+         * invocation expressions.\n+         *\/\n+        @OpFactory.OpDeclaration(InvokeSuperOp.NAME)\n+        public static final class InvokeSuperOp extends InvokeOp {\n+            public static final String NAME = InvokeOp.NAME + \".super\";\n+\n+            public static InvokeSuperOp create(ExternalizedOp def) {\n+                return new InvokeSuperOp(def, createInvokeDescriptor(def));\n+            }\n+\n+            InvokeSuperOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n+                super(def, invokeDescriptor);\n+            }\n+\n+            InvokeSuperOp(InvokeOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public InvokeSuperOp transform(CopyContext cc, OpTransformer ot) {\n+                return new InvokeSuperOp(this, cc);\n+            }\n+\n+            InvokeSuperOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+                super(NAME, resultType, invokeDescriptor, args);\n+            }\n+        }\n+\n@@ -3618,1 +3668,1 @@\n-     * Creates an invoke operation.\n+     * Creates an invoke instance or class (static) operation.\n@@ -3625,1 +3675,1 @@\n-        return new InvokeOp(invokeDescriptor, List.of(args));\n+        return invoke(invokeDescriptor, List.of(args));\n@@ -3629,1 +3679,1 @@\n-     * Creates an invoke operation.\n+     * Creates an invoke instance or class (static) operation.\n@@ -3636,1 +3686,1 @@\n-        return new InvokeOp(invokeDescriptor, args);\n+        return invoke(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n@@ -3640,1 +3690,1 @@\n-     * Creates an invoke operation.\n+     * Creates an invoke instance or class (static) operation.\n@@ -3648,1 +3698,1 @@\n-        return new InvokeOp(returnType, invokeDescriptor, List.of(args));\n+        return invoke(returnType, invokeDescriptor, List.of(args));\n@@ -3652,1 +3702,1 @@\n-     * Creates an invoke operation.\n+     * Creates an invoke instance or class (static) operation.\n@@ -3657,1 +3707,1 @@\n-     * @return the invoke operation\n+     * @return the invoke super operation\n@@ -3660,1 +3710,13 @@\n-        return new InvokeOp(returnType, invokeDescriptor, args);\n+        return new InvokeOp.InvokeInstanceClassOp(returnType, invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an invoke super operation.\n+     *\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp.InvokeSuperOp invokeSuper(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp.InvokeSuperOp(returnType, invokeDescriptor, args);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":95,"deletions":33,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -71,2 +71,0 @@\n-        EXTENDS(\"extends\", Token.Tag.NAMED),\n-        SUPER(\"super\", Token.Tag.NAMED),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Tokens.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,8 +46,0 @@\n-\/\/ @@@ require invoke kind:\n-\/\/    special, static, virtual\n-\/\/    interface_special, interface_static, interface_virtual\n-\/\/  Otherwise it is not possible to generate correct bytecode invoke instruction with\n-\/\/  a symbolic reference to a method or an interface method, specifically a\n-\/\/  constant pool entry of CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info.\n-\/\/\n-\/\/  We can infer the kind, if we can resolve the types and lookup the declared method\n@@ -62,1 +54,1 @@\n-    \/\/ Resolutions and model access\n+    \/\/ Resolutions to methods and method handles\n@@ -64,1 +56,2 @@\n-    Executable resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    \/\/ Resolve using ResolveKind.invokeClass, on failure resolve using ResolveKind.invokeInstance\n+    Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -66,0 +59,1 @@\n+    \/\/ Resolve using ResolveKind.invokeClass, on failure resolve using ResolveKind.invokeInstance\n@@ -68,1 +62,10 @@\n-    Optional<CoreOp.FuncOp> codeModel(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    enum ResolveKind {\n+        invokeClass,\n+        invokeInstance,\n+        invokeSuper\n+    }\n+\n+    Method resolveToMethod(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException;\n+\n+    \/\/ For ResolveKind.invokeSuper the specialCaller == l.lookupClass() for Lookup::findSpecial\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/MethodRef.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.reflect.Executable;\n+import java.lang.reflect.Method;\n@@ -54,1 +54,2 @@\n-                Executable method = ((MethodRef)owner).resolveToMember(lookup);\n+                \/\/ @@@ resolves to class or instance method\n+                Method method = ((MethodRef)owner).resolveToMethod(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.code.op.CoreOp;\n@@ -38,1 +37,0 @@\n-import java.util.Optional;\n@@ -69,2 +67,1 @@\n-    public Method resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        \/\/ @@@ Constructor\n+    public Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n@@ -77,8 +74,0 @@\n-        \/\/ @@@ kind\n-        Class<?> refC = resolve(l, refType);\n-\n-        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n-\n-        MethodHandle mh = null;\n-        ReflectiveOperationException c = null;\n-\n@@ -86,1 +75,1 @@\n-            mh = l.findStatic(refC, name, mt);\n+            return resolveToHandle(l, ResolveKind.invokeClass);\n@@ -88,10 +77,1 @@\n-            c = e;\n-        }\n-\n-        if (c != null) {\n-            c = null;\n-            try {\n-                mh = l.findVirtual(refC, name, mt);\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                c = e;\n-            }\n+            return resolveToHandle(l, ResolveKind.invokeInstance);\n@@ -99,0 +79,1 @@\n+    }\n@@ -100,3 +81,5 @@\n-        if (c != null) {\n-            throw c;\n-        }\n+    @Override\n+    public Method resolveToMethod(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException {\n+        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l, kind));\n+        return methodHandleInfo.reflectAs(Method.class, l);\n+    }\n@@ -104,2 +87,9 @@\n-        assert mh != null;\n-        return mh;\n+    @Override\n+    public MethodHandle resolveToHandle(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException {\n+        Class<?> refC = resolve(l, refType);\n+        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n+        return switch (kind) {\n+            case invokeSuper -> l.findSpecial(refC, name, mt, l.lookupClass());\n+            case invokeClass -> l.findStatic(refC, name, mt);\n+            case invokeInstance -> l.findVirtual(refC, name, mt);\n+        };\n@@ -117,6 +107,0 @@\n-    \/\/ Copied code in jdk.compiler module throws UOE\n-    @Override\n-    public Optional<CoreOp.FuncOp> codeModel(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-\/*__throw new UnsupportedOperationException();__*\/        return resolveToMember(l).getCodeModel();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","additions":18,"deletions":34,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -963,1 +963,1 @@\n-                    if (sym.name.equals(names._this)) {\n+                    if (sym.name.equals(names._this) || sym.name.equals(names._super)) {\n@@ -1023,5 +1023,2 @@\n-                        FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n-                                tree.selected.type : qualifierTarget);\n-                        TypeElement resultType = typeToTypeElement(types.memberType(tree.selected.type, sym));\n-                        if (sym.isStatic()) {\n-                            result = append(CoreOp.fieldLoad(resultType, fr));\n+                        if (sym.name.equals(names._this) || sym.name.equals(names._super)) {\n+                            result = thisValue();\n@@ -1029,1 +1026,8 @@\n-                            result = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                            FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n+                                    tree.selected.type : qualifierTarget);\n+                            TypeElement resultType = typeToTypeElement(types.memberType(tree.selected.type, sym));\n+                            if (sym.isStatic()) {\n+                                result = append(CoreOp.fieldLoad(resultType, fr));\n+                            } else {\n+                                result = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                            }\n@@ -1060,4 +1064,0 @@\n-            \/\/ @@@ super.xyz(...) calls\n-            \/\/ Modeling with a call operation would result in the receiver type differing from that\n-            \/\/ in the method reference, perhaps that is sufficient?\n-\n@@ -1092,0 +1092,1 @@\n+                    boolean isSuper;\n@@ -1094,0 +1095,7 @@\n+                        isSuper = switch (access.selected) {\n+                            case JCIdent i when i.sym.name.equals(names._super) -> true;\n+                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> true;\n+                            default -> false;\n+                        };\n+                    } else {\n+                        isSuper = false;\n@@ -1100,1 +1108,5 @@\n-                    Value res = append(CoreOp.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    JavaType returnType = typeToTypeElement(meth.type.getReturnType());\n+                    CoreOp.InvokeOp iop = isSuper\n+                            ? CoreOp.invokeSuper(returnType, mr, args)\n+                            : CoreOp.invoke(returnType, mr, args);\n+                    Value res = append(iop);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestInvokeSuper\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestInvokeSuper {\n+\n+    interface I {\n+        default String f() { return \"I\"; }\n+    }\n+    static class A {\n+        String f() { return \"A\"; }\n+    }\n+\n+    static class B extends A implements I {\n+        final boolean invokeClass;\n+\n+        public B(boolean invokeClass) {\n+            this.invokeClass = invokeClass;\n+        }\n+\n+        @CodeReflection\n+        public String f() {\n+            return invokeClass ? super.f() : I.super.f();\n+        }\n+    }\n+\n+    @Test\n+    public void testInvokeSuper() {\n+        CoreOp.FuncOp f = getFuncOp(B.class, \"f\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        f.writeTo(System.out);\n+\n+        for (boolean invokeClass : new boolean[] {true, false}) {\n+            B b = new B(invokeClass);\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, b), b.f());\n+        }\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -111,1 +111,1 @@\n-                    Executable em = null;\n+                    Method em = null;\n@@ -113,1 +113,1 @@\n-                        em = r.resolveToMember(l);\n+                        em = r.resolveToMethod(l);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestInvokeSuper\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Ignore;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestInvokeSuper {\n+\n+    interface I {\n+        default String f() { return \"I\"; }\n+    }\n+    static class A {\n+        String f() { return \"A\"; }\n+    }\n+\n+    static class B extends A implements I {\n+        final boolean invokeClass;\n+\n+        public B(boolean invokeClass) {\n+            this.invokeClass = invokeClass;\n+        }\n+\n+        @CodeReflection\n+        public String f() {\n+            return invokeClass ? super.f() : I.super.f();\n+        }\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testInvokeSuper() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(B.class, \"f\");\n+        MethodHandle mh = generate(f);\n+\n+        for (boolean invokeClass : new boolean[] {true, false}) {\n+            B b = new B(invokeClass);\n+            Assert.assertEquals(mh.invoke(b), b.f());\n+        }\n+    }\n+\n+    static MethodHandle generate(CoreOp.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup().in(B.class), lf);\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -100,11 +100,0 @@\n-\n-\n-    @CodeReflection\n-    static void x() {}\n-\n-    @Test\n-    public void testAccessCodeModel() throws ReflectiveOperationException {\n-        MethodRef xr = MethodRef.method(TestReferences.class, \"x\", void.class);\n-        Optional<CoreOp.FuncOp> m = xr.codeModel(MethodHandles.lookup());\n-        Assert.assertTrue(m.isPresent());\n-    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -114,0 +114,23 @@\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_3\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %0 %1 @\"FieldAccessTest::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2_3() {\n+        FieldAccessTest.this.f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_4\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test2_4() {\n+        return FieldAccessTest.this.f;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -67,0 +67,11 @@\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_1\" (%0 : MethodCallTest)void -> {\n+                invoke %0 @\"MethodCallTest::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2_1() {\n+        MethodCallTest.this.m();\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodCallTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with super qualified expressions.\n+ * @build SuperTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SuperTest\n+ *\/\n+\n+public class SuperTest extends SuperClass implements SuperInterface {\n+    static int sf;\n+    int f;\n+\n+    @Override\n+    public void get() {}\n+    static void sget() {}\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"superClassFieldAccess\" (%0 : SuperTest)void -> {\n+                %1 : int = field.load %0 @\"SuperClass::f()int\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = constant @\"1\";\n+                field.store %0 %3 @\"SuperClass::f()int\";\n+                %4 : int = field.load %0 @\"SuperClass::f()int\";\n+                var.store %2 %4;\n+                %5 : int = constant @\"1\";\n+                field.store %0 %5 @\"SuperClass::f()int\";\n+                %6 : int = field.load @\"SuperClass::sf()int\";\n+                var.store %2 %6;\n+                %7 : int = constant @\"1\";\n+                field.store %7 @\"SuperClass::sf()int\";\n+                %8 : int = field.load @\"SuperClass::sf()int\";\n+                var.store %2 %8;\n+                %9 : int = constant @\"1\";\n+                field.store %9 @\"SuperClass::sf()int\";\n+                return;\n+            };\n+            \"\"\")\n+    public void superClassFieldAccess() {\n+        int i = super.f;\n+        super.f = 1;\n+        i = SuperTest.super.f;\n+        SuperTest.super.f = 1;\n+\n+        i = super.sf;\n+        super.sf = 1;\n+        i = SuperTest.super.sf;\n+        SuperTest.super.sf = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"superClassMethodInvocation\" (%0 : SuperTest)void -> {\n+                invoke.super %0 @\"SuperClass::get()void\";\n+                invoke.super %0 @\"SuperClass::get()void\";\n+                invoke @\"SuperClass::sget()void\";\n+                invoke @\"SuperClass::sget()void\";\n+                return;\n+            };\n+            \"\"\")\n+    public void superClassMethodInvocation() {\n+        super.get();\n+        SuperTest.super.get();\n+\n+        super.sget();\n+        SuperTest.super.sget();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"superInterfaceMethodInvocation\" (%0 : SuperTest)void -> {\n+                invoke.super %0 @\"SuperInterface::get()void\";\n+                return;\n+            };\n+            \"\"\")\n+    public void superInterfaceMethodInvocation() {\n+        SuperInterface.super.get();\n+    }\n+}\n+\n+class SuperClass {\n+    static int sf;\n+    int f;\n+\n+    void get() {}\n+    static void sget() {}\n+}\n+\n+interface SuperInterface {\n+    default void get() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SuperTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -64,0 +64,2 @@\n+            \"SuperTest.java\",                   \/\/ @@@ Might be issue referencing auxiliary interface\n+                                                \/\/ in method superInterfaceMethodInvocation\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}