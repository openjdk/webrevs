{"files":[{"patch":"@@ -330,12 +330,0 @@\n-    \/** Enter a class into symbol table.\n-     *  @param s The name of the class.\n-     *\/\n-    public Type enterClass(ModuleSymbol moduleSymbol, String s) {\n-        try {\n-            return enterClass(moduleSymbol, names.fromString(s)).type;\n-        } catch (Throwable ex) {\n-            ex.printStackTrace();\n-            return Type.noType;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -166,3 +166,0 @@\n-    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n-    public static final int FLAG_QUOTABLE = 1 << 3;\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,13 +170,0 @@\n-    public static boolean isSuperQualifier(JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isThisQualifier(skipParens(tree));\n-            case IDENT: {\n-                JCIdent id = (JCIdent)tree;\n-                return id.name == id.name.table.names._super;\n-            }\n-            default:\n-                return false;\n-        }\n-    }\n-\n@@ -667,0 +654,5 @@\n+        if (endPosTable == null) {\n+            \/\/ fall back on limited info in the tree\n+            return endPos(tree);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.Name;\n@@ -58,5 +59,5 @@\n-        codeReflectionType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Reflect\");\n-        quotedType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Quoted\");\n-        opType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Op\");\n-        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n-        reflectableLambdaMetafactory = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.runtime.ReflectableLambdaMetafactory\");\n+        codeReflectionType = syms.enterClass(jdk_incubator_code, names.fromString(\"jdk.incubator.code.Reflect\")).type;\n+        quotedType = syms.enterClass(jdk_incubator_code, names.fromString(\"jdk.incubator.code.Quoted\")).type;\n+        opType = syms.enterClass(jdk_incubator_code, names.fromString(\"jdk.incubator.code.Op\")).type;\n+        funcOpType = syms.enterClass(jdk_incubator_code, names.fromString(\"jdk.incubator.code.dialect.core.CoreOp$FuncOp\")).type;\n+        reflectableLambdaMetafactory = syms.enterClass(jdk_incubator_code, names.fromString(\"jdk.incubator.code.runtime.ReflectableLambdaMetafactory\")).type;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2502,1 +2502,1 @@\n-            if (tree.kind == ReferenceKind.BOUND && !isThisOrSuper(tree.getQualifierExpression())) {\n+            if (tree.kind == ReferenceKind.BOUND && !TreeInfo.isThisQualifier(tree.getQualifierExpression())) {\n@@ -2641,4 +2641,0 @@\n-\n-        boolean isThisOrSuper(JCExpression expression) {\n-            return TreeInfo.isThisQualifier(expression) || TreeInfo.isSuperQualifier(tree);\n-        }\n@@ -2774,1 +2770,1 @@\n-            case ClassType ct -> types.erasure(syms.enterClass(attrEnv().toplevel.modle, ct.toClassName()));\n+            case ClassType ct -> types.erasure(syms.enterClass(attrEnv().toplevel.modle, names.fromString(ct.toClassName())).type);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}