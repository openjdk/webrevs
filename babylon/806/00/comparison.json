{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import optkl.Invoke;\n@@ -43,0 +44,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -46,0 +48,1 @@\n+import static optkl.Trxfmr.copyLocation;\n@@ -49,4 +52,9 @@\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp entry) {\n-\n-        if (!isArrayView(entry)) return entry;\n+    public boolean hasArrayView(CoreOp.FuncOp entry) {\n+        var here = CallSite.of(HATArrayViewPhase.class, \"isArrayView\");\n+        return elements(here, entry).anyMatch((element) -> (\n+                element instanceof JavaOp.InvokeOp iop &&\n+                        iop.resultType() instanceof ArrayType &&\n+                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n+                        (isAssignable(lookup(), javaType, MappableIface.class)\n+                                || isAssignable(lookup(), javaType, DeviceType.class))));\n+    }\n@@ -54,2 +62,5 @@\n-        Map<Op.Result, Op.Result> replaced = new HashMap<>(); \/\/ maps a result to the result it should be replaced by\n-        Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        if (hasArrayView(funcOp)) {\n+            Map<Op.Result, Op.Result> replaced = new HashMap<>(); \/\/ maps a result to the result it should be replaced by\n+            Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n@@ -57,22 +68,24 @@\n-        return entry.transform(entry.funcName(), (bb, op) -> {\n-            switch (op) {\n-                case JavaOp.InvokeOp invokeOp -> {\n-                    if (isVectorBinaryOperation(invokeOp)) {\n-                        \/\/ catching HATVectorBinaryOps not stored in VarOps\n-                        HATVectorOp.HATVectorBinaryOp vBinaryOp = buildVectorBinaryOp(\n-                                invokeOp.invokeDescriptor().name(),\n-                                obtainVarNameFromInvoke(invokeOp),\n-                                invokeOp.resultType(),\n-                                bb.context().getValues(invokeOp.operands())\n-                        );\n-                        vBinaryOp.setLocation(invokeOp.location());\n-                        Op.Result res = bb.op(vBinaryOp);\n-                        bb.context().mapValue(invokeOp.result(), res);\n-                        replaced.put(invokeOp.result(), res);\n-                        return bb;\n-                    } else if (isBufferArray(invokeOp) &&\n-                            firstOperand(invokeOp) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n-                        replaced.put(invokeOp.result(), r);\n-                        \/\/ map buffer VarOp to its corresponding VarLoadOp\n-                        bufferVarLoads.put((firstOperandAsRes(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n-                        return bb;\n+            return funcOp.transform(funcOp.funcName(), (blockBuilder, op) -> {\n+                var context = blockBuilder.context();\n+                switch (op) {\n+                    case JavaOp.InvokeOp i when invokeOpHelper(lookup(), i) instanceof Invoke invoke -> {\n+                        if (isHatVectorBinaryOperation(invoke)) {\n+                            \/\/ catching HATVectorBinaryOps not stored in VarOps\n+                            var hatVectorBinaryOp = copyLocation(invoke.op(), buildVectorBinaryOp(\n+                                    invoke.name(),\n+                                    varNameFromInvokeFirstUse(invoke),\n+                                    invoke.returnType(),\n+                                    blockBuilder.context().getValues(invoke.op().operands())\n+                            ));\n+                            Op.Result binaryResult = blockBuilder.op(hatVectorBinaryOp);\n+                           context.mapValue(invoke.returnResult(), binaryResult);\n+                            replaced.put(invoke.returnResult(), binaryResult);\n+                            return blockBuilder;\n+                        } else if (isBufferArray(invoke.op()) && invoke.firstOperandAsResultOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n+                            replaced.put(invoke.returnResult(), result);\n+                            \/\/ map buffer VarOp to its corresponding VarLoadOp\n+                            bufferVarLoads.put((firstOperandAsResultOrNull(result.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) result.op());\n+                            return blockBuilder;\n+                        } else{\n+                            \/\/ or else\n+                        }\n@@ -80,21 +93,20 @@\n-                }\n-                case CoreOp.VarOp varOp -> {\n-                    if (isBufferInitialize(varOp) &&\n-                            firstOperand(varOp) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n-                        Op bufferLoad = replaced.get(r).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n-                        replaced.put(varOp.result(), firstOperandAsRes(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n-                        return bb;\n-                    } else if (isVectorOp(varOp)) {\n-                        List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n-                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(varOp.resultType().valueType());\n-                        HATVectorOp.HATVectorVarOp vVarOp = new HATVectorOp.HATVectorVarOp(\n-                                varOp.varName(),\n-                                varOp.resultType(),\n-                                md.vectorTypeElement(),\n-                                md.lanes(),\n-                                bb.context().getValues(operands)\n-                        );\n-                        vVarOp.setLocation(varOp.location());\n-                        Op.Result res = bb.op(vVarOp);\n-                        bb.context().mapValue(varOp.result(), res);\n-                        return bb;\n+                    case CoreOp.VarOp varOp -> {\n+                        if (isBufferInitialize(varOp) && firstOperand(varOp) instanceof Op.Result result) { \/\/ makes sure we don't process a new int[] for example\n+                            Op bufferLoad = replaced.get(result).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n+                            replaced.put(varOp.result(), firstOperandAsResultOrNull(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n+                            return blockBuilder;\n+                        } else if (isVectorOp(varOp)) {\n+                            List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n+                            var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(varOp.resultType().valueType());\n+                            var hatVectorVarOp = copyLocation(varOp,new HATVectorOp.HATVectorVarOp(\n+                                    varOp.varName(),\n+                                    varOp.resultType(),\n+                                    vectorMetaData.vectorTypeElement(),\n+                                    vectorMetaData.lanes(),\n+                                   context.getValues(operands)\n+                            ));\n+                            context.mapValue(varOp.result(), blockBuilder.op(hatVectorVarOp));\n+                            return blockBuilder;\n+                        }else{\n+                            \/\/ or else\n+                        }\n@@ -102,16 +114,18 @@\n-                }\n-                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n-                    if ((isBufferInitialize(varLoadOp)) &&\n-                            firstOperand(varLoadOp) instanceof Op.Result r) {\n-                        if (r.op() instanceof CoreOp.VarOp) { \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n-                            Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n-                                    firstOperandAsRes((firstOperandAsRes(r.op())).op()) :\n-                                    bufferVarLoads.get(replaced.get(r).op()).result();\n-                            replaced.put(varLoadOp.result(), replacement);\n-                        } else { \/\/ if this is a VarLoadOp loading the buffer\n-                            Value loaded = getValue(bb, replaced.get(r));\n-                            CoreOp.VarAccessOp.VarLoadOp newVarLoad = CoreOp.VarAccessOp.varLoad(loaded);\n-                            newVarLoad.setLocation(varLoadOp.location());\n-                            Op.Result res = bb.op(newVarLoad);\n-                            bb.context().mapValue(varLoadOp.result(), res);\n-                            replaced.put(varLoadOp.result(), res);\n+                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n+                        if ((isBufferInitialize(varLoadOp)) && firstOperand(varLoadOp) instanceof Op.Result r) {\n+                            if (r.op() instanceof CoreOp.VarOp) { \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n+                                Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n+                                        firstOperandAsResultOrNull((firstOperandAsResultOrNull(r.op())).op()) :\n+                                        bufferVarLoads.get(replaced.get(r).op()).result();\n+                                replaced.put(varLoadOp.result(), replacement);\n+                            } else { \/\/ if this is a VarLoadOp loading the buffer\n+                                \/\/ is this not just bb.op(varLoadOp)?\n+                                CoreOp.VarAccessOp.VarLoadOp newVarLoad = copyLocation(varLoadOp,\n+                                        CoreOp.VarAccessOp.varLoad(getValue(blockBuilder, replaced.get(r))));\n+                                Op.Result res = blockBuilder.op(newVarLoad);\n+                                context.mapValue(varLoadOp.result(), res);\n+                                replaced.put(varLoadOp.result(), res);\n+                            }\n+                            return blockBuilder;\n+                        }else{\n+                            \/\/ or else\n@@ -119,1 +133,0 @@\n-                        return bb;\n@@ -121,38 +134,34 @@\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n-                    if (isBufferArray(arrayLoadOp) &&\n-                            firstOperand(arrayLoadOp) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.getOrDefault(r, r);\n-                        if (isVectorOp(arrayLoadOp)) {\n-                            Op vop = (firstOperandAsRes(buffer.op())).op();\n-                            String name = switch (vop) {\n-                                case CoreOp.VarOp varOp -> varOp.varName();\n-                                case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n-                                case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n-                                default -> throw new IllegalStateException(\"Unexpected value: \" + vop);\n-                            };\n-                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(arrayLoadOp.resultType());\n-                            HATVectorOp.HATVectorLoadOp vLoadOp = new HATVectorOp.HATVectorLoadOp(\n-                                    name,\n-                                    CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n-                                    md.vectorTypeElement(),\n-                                    md.lanes(),\n-                                    notGlobalVarOp(arrayLoadOp),\n-                                    bb.context().getValues(List.of(buffer, arrayLoadOp.operands().getLast()))\n-                            );\n-                            vLoadOp.setLocation(arrayLoadOp.location());\n-                            Op.Result res = bb.op(vLoadOp);\n-                            bb.context().mapValue(arrayLoadOp.result(), res);\n-                        } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                            ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                            List<Value> operands = new ArrayList<>();\n-                            operands.add(info.buffer);\n-                            operands.addAll(info.indices);\n-                            HATPtrOp.HATPtrLoadOp ptrLoadOp = new HATPtrOp.HATPtrLoadOp(\n-                                    arrayLoadOp.resultType(),\n-                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n-                                    bb.context().getValues(operands)\n-                            );\n-                            ptrLoadOp.setLocation(arrayLoadOp.location());\n-                            Op.Result res = bb.op(ptrLoadOp);\n-                            bb.context().mapValue(arrayLoadOp.result(), res);\n+                    case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+                        if (isBufferArray(arrayLoadOp) && firstOperand(arrayLoadOp) instanceof Op.Result r) {\n+                            Op.Result buffer = replaced.getOrDefault(r, r);\n+                            if (isVectorOp(arrayLoadOp)) {\n+                                Op vop = (firstOperandAsResultOrNull(buffer.op())).op();\n+                                String name = switch (vop) {\n+                                    case CoreOp.VarOp varOp -> varOp.varName();\n+                                    case HATMemoryVarOp.HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+                                    case HATMemoryVarOp.HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+                                    default -> throw new IllegalStateException(\"Unexpected value: \" + vop);\n+                                };\n+                                var  hatVectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(arrayLoadOp.resultType());\n+                                HATVectorOp.HATVectorLoadOp vLoadOp = copyLocation(arrayLoadOp,new HATVectorOp.HATVectorLoadOp(\n+                                        name,\n+                                        CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n+                                        hatVectorMetaData.vectorTypeElement(),\n+                                        hatVectorMetaData.lanes(),\n+                                        notGlobalVarOp(arrayLoadOp),\n+                                        context.getValues(List.of(buffer, arrayLoadOp.operands().getLast()))\n+                                ));\n+                                context.mapValue(arrayLoadOp.result(), blockBuilder.op(vLoadOp));\n+                            } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                                var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                                var operands = arrayAccessInfo.bufferAndIndicesAsValues();\n+\n+                                var hatPtrLoadOp = copyLocation(arrayLoadOp,new HATPtrOp.HATPtrLoadOp(\n+                                        arrayLoadOp.resultType(),\n+                                        (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                        context.getValues(operands)\n+                                ));\n+                                context.mapValue(arrayLoadOp.result(), blockBuilder.op(hatPtrLoadOp));\n+                            }\n+                        } else {\n+                            \/\/ or else?\n@@ -160,0 +169,1 @@\n+                        return blockBuilder;\n@@ -161,37 +171,37 @@\n-                    return bb;\n-                }\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n-                    if (isBufferArray(arrayStoreOp) &&\n-                            firstOperand(arrayStoreOp) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.getOrDefault(r, r);\n-                        if (isVectorOp(arrayStoreOp)) {\n-                            Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n-                            String name = (varOp instanceof HATVectorOp.HATVectorVarOp) ? ((HATVectorOp.HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n-                            TypeElement resultType = (varOp instanceof HATVectorOp.HATVectorVarOp) ? (varOp).resultType() : ((CoreOp.VarOp) varOp).resultType();\n-                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n-                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(classType);\n-                            HATVectorOp.HATVectorStoreView vStoreOp = new HATVectorOp.HATVectorStoreView(\n-                                    name,\n-                                    resultType,\n-                                    md.lanes(),\n-                                    md.vectorTypeElement(),\n-                                    notGlobalVarOp(arrayStoreOp),\n-                                    bb.context().getValues(List.of(buffer, arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n-                            );\n-                            vStoreOp.setLocation(arrayStoreOp.location());\n-                            Op.Result res = bb.op(vStoreOp);\n-                            bb.context().mapValue(arrayStoreOp.result(), res);\n-                        } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                            ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                            List<Value> operands = new ArrayList<>();\n-                            operands.add(info.buffer());\n-                            operands.addAll(info.indices);\n-                            operands.add(arrayStoreOp.operands().getLast());\n-                            HATPtrOp.HATPtrStoreOp ptrLoadOp = new HATPtrOp.HATPtrStoreOp(\n-                                    arrayStoreOp.resultType(),\n-                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n-                                    bb.context().getValues(operands)\n-                            );\n-                            ptrLoadOp.setLocation(arrayStoreOp.location());\n-                            Op.Result res = bb.op(ptrLoadOp);\n-                            bb.context().mapValue(arrayStoreOp.result(), res);\n+                    case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+                        if (isBufferArray(arrayStoreOp) && firstOperand(arrayStoreOp) instanceof Op.Result r) {\n+                            Op.Result buffer = replaced.getOrDefault(r, r);\n+                            if (isVectorOp(arrayStoreOp)) {\n+                                Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n+                                var name = (varOp instanceof HATVectorOp.HATVectorVarOp)\n+                                        ? ((HATVectorOp.HATVectorVarOp) varOp).varName()\n+                                        : ((CoreOp.VarOp) varOp).varName();\n+                                var resultType = (varOp instanceof HATVectorOp.HATVectorVarOp)\n+                                        ? (varOp).resultType()\n+                                        : ((CoreOp.VarOp) varOp).resultType();\n+                                var classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n+                                var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(classType);\n+                                HATVectorOp.HATVectorStoreView vStoreOp = copyLocation(arrayStoreOp,new HATVectorOp.HATVectorStoreView(\n+                                        name,\n+                                        resultType,\n+                                        vectorMetaData.lanes(),\n+                                        vectorMetaData.vectorTypeElement(),\n+                                        notGlobalVarOp(arrayStoreOp),\n+                                        context.getValues(List.of(buffer, arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n+                                ));\n+                                context.mapValue(arrayStoreOp.result(), blockBuilder.op(vStoreOp));\n+                            } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                                var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                                var operands = arrayAccessInfo.bufferAndIndicesAsValues();\n+                                operands.add(arrayStoreOp.operands().getLast());\n+                                HATPtrOp.HATPtrStoreOp ptrLoadOp = copyLocation(arrayStoreOp,new HATPtrOp.HATPtrStoreOp(\n+                                        arrayStoreOp.resultType(),\n+                                        (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                        context.getValues(operands)\n+                                ));\n+                                context.mapValue(arrayStoreOp.result(), blockBuilder.op(ptrLoadOp));\n+                            }else{\n+                                \/\/ or else\n+                            }\n+                        }else{\n+                            \/\/ or else?\n@@ -199,0 +209,1 @@\n+                        return blockBuilder;\n@@ -200,15 +211,15 @@\n-                    return bb;\n-                }\n-                case JavaOp.ArrayLengthOp arrayLengthOp -> {\n-                    if (isBufferArray(arrayLengthOp) &&\n-                            firstOperand(arrayLengthOp) instanceof Op.Result r) {\n-                        ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                        HATPtrOp.HATPtrLengthOp ptrLengthOp = new HATPtrOp.HATPtrLengthOp(\n-                                arrayLengthOp.resultType(),\n-                                (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) info.buffer().type()),\n-                                bb.context().getValues(List.of(info.buffer()))\n-                        );\n-                        ptrLengthOp.setLocation(arrayLengthOp.location());\n-                        Op.Result res = bb.op(ptrLengthOp);\n-                        bb.context().mapValue(arrayLengthOp.result(), res);\n-                        return bb;\n+                    case JavaOp.ArrayLengthOp arrayLengthOp -> {\n+                        if (isBufferArray(arrayLengthOp) && firstOperand(arrayLengthOp) instanceof Op.Result) {\n+                            var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                            var hatPtrLengthOp = copyLocation(arrayLengthOp,new HATPtrOp.HATPtrLengthOp(\n+                                    arrayLengthOp.resultType(),\n+                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                    context.getValues(List.of(arrayAccessInfo.buffer()))\n+                            ));\n+                            context.mapValue(arrayLengthOp.result(), blockBuilder.op(hatPtrLengthOp));\n+                            return blockBuilder;\n+                        }else{\n+                            \/\/ or else\n+                        }\n+                    }\n+                    default -> {\n@@ -217,6 +228,6 @@\n-                default -> {\n-                }\n-            }\n-            bb.op(op);\n-            return bb;\n-        });\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            });\n+        }else {\n+            return funcOp;\n+        }\n@@ -225,1 +236,7 @@\n-    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {};\n+    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {\n+        public List<Value> bufferAndIndicesAsValues() {\n+            List<Value> operands = new ArrayList<>(List.of(buffer));\n+            operands.addAll(indices);\n+            return operands;\n+        }\n+    };\n@@ -229,2 +246,2 @@\n-            List<Node<T>> wl = new ArrayList<>();\n-            Set<Node<T>> seen = new HashSet<>();\n+            List<Node<T>> nodeList = new ArrayList<>(List.of(this));\n+            Set<Node<T>> handled = new HashSet<>();\n@@ -233,6 +250,5 @@\n-            wl.add(this);\n-            while (!wl.isEmpty()) {\n-                Node<T> cur = wl.removeFirst();\n-                seen.add(cur);\n-                if (cur.value instanceof Op.Result res) {\n-                    if (res.op() instanceof JavaOp.ArrayAccessOp || res.op() instanceof JavaOp.ArrayLengthOp) {\n+            while (!nodeList.isEmpty()) {\n+                Node<T> node = nodeList.removeFirst();\n+                handled.add(node);\n+                if (node.value instanceof Op.Result res &&\n+                        (res.op() instanceof JavaOp.ArrayAccessOp || res.op() instanceof JavaOp.ArrayLengthOp)) {\n@@ -241,1 +257,1 @@\n-                    }\n+\n@@ -243,3 +259,6 @@\n-                if (!cur.edges().isEmpty()) {\n-                    Node<T> next = cur.edges().getFirst();\n-                    if (!seen.contains(next)) wl.add(next);\n+                \/\/ I think we need to comment this.  Not so obvious.\n+                if (!node.edges().isEmpty()) {\n+                    Node<T> next = node.edges().getFirst();\n+                    if (!handled.contains(next)) {\n+                        nodeList.add(next);\n+                    }\n@@ -269,0 +288,2 @@\n+\n+        \/\/ looks like\n@@ -270,1 +291,5 @@\n-            if (operand instanceof Op.Result res && res.op() instanceof JavaOp.InvokeOp iop && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")) continue;\n+            if (operand instanceof Op.Result res &&\n+                    res.op() instanceof JavaOp.InvokeOp iop\n+                    && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")){\n+                continue;\n+            }\n@@ -293,8 +318,5 @@\n-    private boolean isVectorBinaryOperation(JavaOp.InvokeOp invokeOp) {\n-        TypeElement typeElement = invokeOp.resultType();\n-        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && (invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"add\")\n-                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"sub\")\n-                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"mul\")\n-                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"div\"));\n+    private boolean isHatVectorBinaryOperation(Invoke invoke) {\n+        \/\/ no! lets not compare strings what if we refactor the class names?  This is brittle\n+        return invoke.returnType().toString().startsWith(\"hat.buffer.Float\")\n+                   && invoke.name().toLowerCase() instanceof String name\n+                   &&(name.equals(\"add\")|| name.equals(\"sub\")||name.equals(\"mul\")||name.equals(\"div\"));\n@@ -304,1 +326,1 @@\n-        return searchForOp(op, Set.of(CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class));\n+        return searchForOpOrNull(op, CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class);\n@@ -308,9 +330,12 @@\n-        if (op.operands().isEmpty()) return false;\n-        TypeElement type = firstOperand(op).type();\n-        if (type instanceof ArrayType at) type = at.componentType();\n-        if (type instanceof ClassType ct) {\n-            try {\n-                return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup()));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n+        if (!op.operands().isEmpty()) {\n+           TypeElement type = firstOperand(op).type();\n+           if (type instanceof ArrayType at) {\n+               type = at.componentType();\n+           }\n+           if (type instanceof ClassType ct) {\n+               try {\n+                   return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup()));\n+               } catch (ReflectiveOperationException e) {\n+                   throw new RuntimeException(e);\n+              }\n+           }\n@@ -321,2 +346,2 @@\n-    public static Op.Result firstOperandAsRes(Op op) {\n-        return (firstOperand(op) instanceof Op.Result res) ? res : null;\n+    public static Op.Result firstOperandAsResultOrNull(Op op) {\n+        return (firstOperand(op) instanceof Op.Result result) ? result : null;\n@@ -334,1 +359,1 @@\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOp(op, Set.of(JavaOp.InvokeOp.class));\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOpOrNull(op, JavaOp.InvokeOp.class);\n@@ -339,1 +364,1 @@\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOp(op, Set.of(JavaOp.InvokeOp.class));\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOpOrNull(op, JavaOp.InvokeOp.class);\n@@ -345,4 +370,5 @@\n-    public Op searchForOp(Op op, Set<Class<?>> opClasses) {\n-        while (!(opClasses.contains(op.getClass()))) {\n-            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n-                op = r.op();\n+    public Op searchForOpOrNull(Op op, Class<?> ...classes) {\n+        Set<Class<?>> set =Set.of(classes);\n+        while (!(set.contains(op.getClass()))) {\n+            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result result) {\n+                op = result.op();\n@@ -359,1 +385,3 @@\n-            if (!(vop.varValueType() instanceof ArrayType)) return false;\n+            if (!(vop.varValueType() instanceof ArrayType)){\n+                return false;\n+            }\n@@ -361,36 +389,2 @@\n-            if (!(op.resultType() instanceof ArrayType)) return false;\n-        }\n-\n-        return isBufferArray(op);\n-    }\n-\n-    public boolean isArrayView(CoreOp.FuncOp entry) {\n-        var here = CallSite.of(HATArrayViewPhase.class, \"isArrayView\");\n-        return elements(here, entry).anyMatch((element) -> (\n-                element instanceof JavaOp.InvokeOp iop &&\n-                        iop.resultType() instanceof ArrayType &&\n-                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n-                        (isAssignable(lookup(), javaType, MappableIface.class)\n-                                || isAssignable(lookup(), javaType, DeviceType.class))));\n-    }\n-\n-    public Class<?> typeElementToClass(TypeElement type) {\n-        class PrimitiveHolder {\n-            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-                    JavaType.BYTE, byte.class,\n-                    JavaType.SHORT, short.class,\n-                    JavaType.INT, int.class,\n-                    JavaType.LONG, long.class,\n-                    JavaType.FLOAT, float.class,\n-                    JavaType.DOUBLE, double.class,\n-                    JavaType.CHAR, char.class,\n-                    JavaType.BOOLEAN, boolean.class\n-            );\n-        }\n-        try {\n-            if (type instanceof PrimitiveType primitiveType) {\n-                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-            } else if (type instanceof ClassType classType) {\n-                return ((Class<?>) classType.resolve(lookup()));\n-            } else {\n-                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+            if (!(op.resultType() instanceof ArrayType)) {\n+                return false;\n@@ -398,2 +392,0 @@\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(\"given type cannot be converted to class\");\n@@ -401,0 +393,1 @@\n+        return isBufferArray(op);\n@@ -403,5 +396,5 @@\n-    private String obtainVarNameFromInvoke(JavaOp.InvokeOp invokeOp) {\n-        Op.Result invokeResult = invokeOp.result();\n-        if (!invokeResult.uses().isEmpty()) {\n-            Op.Result r = invokeResult.uses().stream().toList().getFirst();\n-            if (r.op() instanceof CoreOp.VarOp varOp) {\n+    private String varNameFromInvokeFirstUse(Invoke invoke) {\n+        var uses= invoke.op().result().uses();\n+        if (!uses.isEmpty()) {\n+            Op.Result result = uses.stream().toList().getFirst();\n+            if (result.op() instanceof CoreOp.VarOp varOp) {\n@@ -411,1 +404,1 @@\n-        return invokeOp.externalizeOpName();\n+        return invoke.op().externalizeOpName();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":240,"deletions":247,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.CodeElement;\n@@ -36,1 +37,0 @@\n-import optkl.util.CallSite;\n@@ -40,0 +40,1 @@\n+import java.util.HashSet;\n@@ -41,0 +42,1 @@\n+import java.util.Set;\n@@ -61,0 +63,2 @@\n+\n+\n@@ -63,1 +67,0 @@\n-        var txfmr = new Trxfmr(CallSite.of(this.getClass()),funcOp);\n@@ -71,33 +74,28 @@\n-        return txfmr.select(\n-                ce-> fieldAccessOpHelper(lookup(),ce) instanceof FieldAccess fieldAccess\n-                        && fieldAccess.refType(KernelContext.class)\n-                && fieldAccess.named(fieldNameRegex)\n-              \/\/  fieldAccessOpKernelContextPattern.asKernelContextFieldAccessOrNull(\n-        \/\/                lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null\n-        ,(s, o)->\n-                   operandsAsResults(o)\n-                     .map(OpTkl::opOfResultOrNull)\n-                     .map(OpTkl::asVarLoadOrNull)\n-                     .filter(Objects::nonNull) \/\/ ((Result)operand).op()) instanceof VarLoad varload && varload is KernelContext.class\n-                     .findFirst()\n-                     .ifPresent(varLoadOp -> s.select(o,varLoadOp))\n-                ).transform(txfmr.selected::contains, c->{\n-                   switch (c.op()){\n-                      case JavaOp.FieldAccessOp.FieldLoadOp $  -> {\n-                          String name = $.fieldDescriptor().name();\n-                          int dimIdx = name.length()==3 ?name.charAt(2)-'x' :-1;\n-                          if (dimIdx <0||dimIdx>3){\n-                              throw new IllegalStateException();\/\/'x'=1,'y'=2....\n-                          }\n-                          c.replace(switch (HATThreadsPhase.this){\n-                              case BlockPhase _-> HATThreadOp.HATBlockThreadIdOp.of(dimIdx, $.resultType());\n-                              case GlobalIdPhase _-> HATThreadOp.HATGlobalThreadIdOp.of(dimIdx, $.resultType());\n-                              case GlobalSizePhase _-> HATThreadOp.HATGlobalSizeOp.of(dimIdx, $.resultType());\n-                              case LocalIdPhase _-> HATThreadOp.HATLocalThreadIdOp.of(dimIdx, $.resultType());\n-                              case LocalSizePhase _-> HATThreadOp.HATLocalSizeOp.of(dimIdx,$.resultType());\n-                          });\n-                      }\n-                      case CoreOp.VarAccessOp.VarLoadOp _ -> c.remove();\n-                      default -> {}\n-                }\n-        }).funcOp();\n+        Set<CodeElement<?,?>> removeMe= new HashSet<>();\n+        return new Trxfmr(funcOp)\n+                .transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n+                    if (fieldAccessOpHelper(lookup(),c.op()) instanceof FieldAccess fieldAccess\n+                            && fieldAccess.refType(KernelContext.class)\n+                            && fieldAccess.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp\n+                            && fieldAccess.named(fieldNameRegex)) {\n+                        operandsAsResults(fieldAccess.op())\n+                                .map(OpTkl::opOfResultOrNull)\n+                                .map(OpTkl::asVarLoadOrNull)\n+                                .filter(Objects::nonNull)\n+                                .findFirst()\n+                                .ifPresent(varLoadOp -> {\n+                                    removeMe.add(varLoadOp); \/\/ We will need to remove this\n+                                    int dimIdx = fieldAccess.name().charAt(2) - 'x';\n+                                    c.replace(switch (HATThreadsPhase.this) {\n+                                        case BlockPhase _ -> HATThreadOp.HATBlockThreadIdOp.of(dimIdx, fieldAccess.resultType());\n+                                        case GlobalIdPhase _ -> HATThreadOp.HATGlobalThreadIdOp.of(dimIdx, fieldAccess.resultType());\n+                                        case GlobalSizePhase _ -> HATThreadOp.HATGlobalSizeOp.of(dimIdx, fieldAccess.resultType());\n+                                        case LocalIdPhase _ -> HATThreadOp.HATLocalThreadIdOp.of(dimIdx, fieldAccess.resultType());\n+                                        case LocalSizePhase _ -> HATThreadOp.HATLocalSizeOp.of(dimIdx, fieldAccess.resultType());\n+                                    });\n+                                });\n+                    }\n+                })\n+                .remap(removeMe)\n+                .remove(removeMe::contains)\n+                .funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import optkl.Invoke;\n@@ -66,2 +65,2 @@\n-\n-    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+    \/\/ recursive\n+    private static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -70,1 +69,1 @@\n-\n+    \/\/ recursive\n@@ -73,1 +72,1 @@\n-            return findVectorTypeElement(varLoadOp);\n+            return findVectorTypeElement(varLoadOp); \/\/ recurse\n@@ -83,2 +82,3 @@\n-    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().getFirst());\n+    \/\/recursive\n+    public static int getWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getWidth(varLoadOp.operands().getFirst());\n@@ -86,1 +86,1 @@\n-\n+    \/\/recursive\n@@ -98,2 +98,17 @@\n-    public static int getWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return getWidth(varLoadOp.operands().getFirst());\n+    \/\/recursive\n+    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    private boolean findIsSharedOrPrivate(Value v) {\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n+            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ recursive\n+    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().getFirst());\n@@ -101,0 +116,2 @@\n+\n+    \/\/ recursive\n@@ -142,4 +159,0 @@\n-    \/\/recursive\n-    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n-    }\n@@ -147,8 +160,0 @@\n-    \/\/recursive\n-    private boolean findIsSharedOrPrivate(Value v) {\n-        return v instanceof Op.Result result && switch (result.op()) {\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n-            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n-            default -> false;\n-        };\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.CodeElement;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.code.Op;\n@@ -36,1 +34,1 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.Invoke;\n@@ -38,1 +36,0 @@\n-import optkl.OpTkl;\n@@ -41,0 +38,2 @@\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -42,0 +41,1 @@\n+import java.util.Map;\n@@ -43,2 +43,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -46,1 +44,0 @@\n-import static hat.optools.RefactorMe.inspectAllInterfaces;\n@@ -50,0 +47,1 @@\n+import static optkl.Trxfmr.copyLocation;\n@@ -52,1 +50,0 @@\n-    private static final Regex xyzw = Regex.of(\"[xyzw]\");\n@@ -54,16 +51,3 @@\n-    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n-        return invokeOpHelper(lookup(),invokeOp).named(xyzw);\n-    }\n-    static boolean isVectorOperation(JavaOp.InvokeOp invokeOp, boolean laneOk) {\n-        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n-        Set<Class<?>> interfaces;\n-        try {\n-            Class<?> aClass = Class.forName(typeElement); \/\/ WHY?\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-            return false;\n-        }\n-        return interfaces.contains(_V.class) && laneOk;\n-    }\n-    int getLane(String fieldName) {\n-        return switch (fieldName) {\n+    int laneIdxOrThrow(String fieldName) {\n+        return \"xyzw\".indexOf(fieldName.charAt(0));\n+     \/*   return switch (fieldName) {\n@@ -74,2 +58,2 @@\n-            default -> -1;\n-        };\n+            default -> throw new RuntimeException(\"fieldName not x,y,z,w\");\n+        };*\/\n@@ -79,8 +63,6 @@\n-    private String findNameVector(Value v) {\n-        if (OpTkl.asOpFromResultOrNull(v) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp.operands().getFirst());\n-        } else if (OpTkl.asOpFromResultOrNull(v)  instanceof HATVectorOp vectorViewOp) {\n-            return vectorViewOp.varName();\n-        }\n-        throw new IllegalStateException(\"recurse fail findNameVector\");\n-\n+    private String vectorNameOrThrow(Value v) {\n+       return switch (asOpFromResultOrNull(v)){\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->vectorNameOrThrow(varLoadOp.operands().getFirst()); \/\/ recurse\n+            case HATVectorOp vectorOp ->vectorOp.varName();\n+            default -> throw new IllegalStateException(\"failed to find vector name\");\n+        };\n@@ -91,8 +73,6 @@\n-    private CoreOp.VarOp findVarOp(Value v) {\n-        if (asOpFromResultOrNull(v) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVarOp(varLoadOp.operands().getFirst());\n-        } else if (asOpFromResultOrNull(v) instanceof CoreOp.VarOp varOp) {\n-            return varOp;\n-        }\n-        return null;\n-\n+    private CoreOp.VarOp findVarOpOrNull(Value v) {\n+        return switch (asOpFromResultOrNull(v)){\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->findVarOpOrNull(varLoadOp.operands().getFirst()); \/\/recurse\n+            case CoreOp.VarOp varOp->varOp;\n+            default ->  null;\n+        };\n@@ -107,11 +87,8 @@\n-        Stream<CodeElement<?, ?>> vectorSelectOps = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp, isVectorLane(invokeOp)) && (invokeOp.resultType() != JavaType.VOID)) {\n-                            Value inputOperand = invokeOp.operands().getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n+        Set<CoreOp.VarAccessOp.VarLoadOp> varLoadOps =new HashSet<>();\n+        Map<JavaOp.InvokeOp, String> invokeToVectorName = new HashMap<>();\n+        Invoke.stream(lookup(),funcOp)\n+                .filter(invoke -> !invoke.returnsVoid() && invoke.named(\"x\",\"y\",\"z\",\"w\") && invoke.refIs(_V.class))\n+                .forEach(invoke -> {\n+                    var varLoadOp = invoke.varLoadOpFromFirstOperandAsResultOrThrow();\n+                    invokeToVectorName.put(invoke.op(), vectorNameOrThrow(varLoadOp.operands().getFirst()));\n+                    varLoadOps.add(varLoadOp);\n@@ -120,23 +97,13 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = vectorSelectOps.collect(Collectors.toSet());\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            CodeContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                for (Value v : inputInvokeOp) {\n-                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                        int lane = getLane(invokeOp.invokeDescriptor().name());\n-                        HATVectorOp vSelectOp;\n-                        String name = findNameVector(varLoadOp.operands().getFirst());\n-                        if (invokeOp.resultType() != JavaType.VOID) {\n-                            vSelectOp = new HATVectorOp.HATVectorSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n-                        } else {\n-                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n-                        }\n-                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n-                        vSelectOp.setLocation(invokeOp.location());\n-                        context.mapValue(invokeOp.result(), hatSelectResult);\n-                    }\n-                }\n+        funcOp = transform(here, funcOp\n+                ,ce-> (varLoadOps.contains(ce)||invokeToVectorName.containsKey(ce)),\n+                (blockBuilder, op) -> {\n+            if (invokeOpHelper(lookup(), op) instanceof Invoke invoke) {\n+                blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(\n+                        copyLocation(invoke.op(), new HATVectorOp.HATVectorSelectLoadOp(\n+                                        invokeToVectorName.get(invoke.op()),\n+                                        invoke.returnType(),\n+                                        laneIdxOrThrow(invoke.name()),\n+                                        blockBuilder.context().getValues(invoke.op().operands())\n+                                )\n+                        )\n+                ));\n@@ -144,2 +111,1 @@\n-                \/\/ Pass the value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+                blockBuilder.context().mapValue(varLoadOp.result(), blockBuilder.context().getValue(varLoadOp.operands().getFirst()));\n@@ -161,13 +127,8 @@\n-        \/\/TODO is this side table safe?\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTkl.elements(here, funcOp)\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp, isVectorLane(invokeOp))) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            Value inputOperand = inputOperandsInvoke.getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n+        Set<CoreOp.VarAccessOp.VarLoadOp> varLoads = new HashSet<>();\n+        Map<JavaOp.InvokeOp, CoreOp.VarAccessOp.VarLoadOp> invokeToVarLoadOp  = new HashMap<>();\n+        Invoke.stream(lookup(),funcOp)\n+                .filter($ -> $.named(\"x\",\"y\",\"z\",\"w\") && $.returnsVoid() &&  $.refIs(_V.class))\n+                .forEach($ ->{\n+                    var varLoadOp = $.varLoadOpFromFirstOperandAsResultOrThrow();\n+                    invokeToVarLoadOp.put($.op(),varLoadOp);\n+                    varLoads.add(varLoadOp);\n@@ -176,2 +137,3 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,\n+                ce->varLoads.contains(ce)||invokeToVarLoadOp.containsKey(ce), \/\/ only the nodes we mapped\/selected\n+                (blockBuilder, op) -> {\n@@ -179,24 +141,12 @@\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                Value v = inputInvokeOp.getFirst();\n-\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                    int lane = getLane(invokeOp.invokeDescriptor().name());\n-                    HATVectorOp vSelectOp;\n-                    String name = findNameVector(varLoadOp.operands().getFirst());\n-                    if (invokeOp.resultType() == JavaType.VOID) {\n-                        \/\/ The operand 1 in the store is the address (lane)\n-                        \/\/ The operand 1 in the store is the storeValue\n-                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n-                        vSelectOp = new HATVectorOp.HATVectorSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n-                    } else {\n-                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n-                    }\n-                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n-                    vSelectOp.setLocation(invokeOp.location());\n-                    context.mapValue(invokeOp.result(), resultVStore);\n-                }\n-\n+            if (invokeOpHelper(lookup(),op) instanceof Invoke invoke) {\n+                List<Value> outputOperandsInvokeOp = context.getValues( invoke.op().operands());\n+                context.mapValue(invoke.op().result(), blockBuilder.op(copyLocation(invoke.op(), new HATVectorOp.HATVectorSelectStoreOp(\n+                                vectorNameOrThrow(invokeToVarLoadOp.get(invoke.op()).operands().getFirst()),\n+                                invoke.returnType(),\n+                                laneIdxOrThrow(invoke.name()),\n+                                \/\/ The operand 1 in the store is the address (lane)\n+                                \/\/ The operand 1 in the store is the storeValue\n+                                findVarOpOrNull(outputOperandsInvokeOp.get(1)),\n+                                outputOperandsInvokeOp\n+                        )\n+                )));\n@@ -204,1 +154,0 @@\n-                \/\/ Pass the value\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":67,"deletions":118,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -36,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -50,0 +51,4 @@\n+    default TypeElement resultType(){\n+        return op().resultType();\n+    }\n+\n@@ -74,0 +79,4 @@\n+\n+    static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        return  funcOp.elements().filter(ce->ce instanceof JavaOp.FieldAccessOp).map(ce->fieldAccessOpHelper(lookup,ce));\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccess.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.Op;\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.Value;\n@@ -169,1 +171,3 @@\n-\n+    default Op.Result returnResult(){\n+        return op().result();\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -31,0 +32,3 @@\n+\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -42,2 +46,2 @@\n-    default boolean named(String name){\n-        return name().equals(name);\n+    default boolean named( String...names){\n+       return Set.of(names).contains(name());\n@@ -71,1 +75,1 @@\n-    default Op.Result firstOperandAsResultOrNull(int i){\n+    default Op.Result firstOperandAsResultOrNull(){\n@@ -101,0 +105,11 @@\n+    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandAsResultOrNull(){\n+           return opFromFirstOperandAsResultOrThrow()\n+                instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp?varLoadOp:null;\n+    }\n+    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandAsResultOrThrow() {\n+        if (varLoadOpFromFirstOperandAsResultOrNull() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return varLoadOp;\n+        } else {\n+            throw new IllegalStateException(\"Expecting first operand to be a result which yields an VarLoadOp \");\n+        }\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -77,42 +77,0 @@\n-  \/*  public interface  Walker extends TransformerCarrier {\n-        void op(Op op);\n-        Op op();\n-        void funcOp(CoreOp.FuncOp funcOp);\n-        CoreOp.FuncOp funcOp();\n-              class Impl implements TransformerCarrier,Walker {\n-                private final Trxfmr trxfmr;\n-                public Trxfmr trxfmr() {\n-                    return trxfmr;\n-                }\n-                private Op op;\n-                private CoreOp.FuncOp funcOp;\n-                @Override\n-                public void op(Op op) {\n-                    this.op = op;\n-                }\n-\n-                @Override\n-                public Op op() {\n-                    return this.op;\n-                }\n-\n-                @Override\n-                public void funcOp(CoreOp.FuncOp funcOp) {\n-                    this.funcOp = funcOp;\n-                }\n-\n-                @Override\n-                public CoreOp.FuncOp funcOp() {\n-                    return this.funcOp;\n-                }\n-\n-                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp) {\n-                    this.trxfmr = trxfmr;\n-                    this.funcOp = funcOp;\n-                }\n-            }\n-      \/\/  static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n-        \/\/    return new Impl(trxfmr,funcOp);\n-       \/\/ }\n-    } *\/\n-\n@@ -256,10 +214,0 @@\n-    public interface Selector<T extends Selector<T>> extends TransformerCarrier {\n-        default T  select(Op...ops){\n-            trxfmr().selected.addAll(List.of(ops));\n-            return (T)this;\n-        }\n-       static Selector<?> of(Trxfmr trxfmr){\n-            record SelectorImpl(Trxfmr trxfmr) implements Selector<SelectorImpl>{}\n-            return  new SelectorImpl(trxfmr);\n-        }\n-    }\n@@ -298,1 +246,1 @@\n-    public final Set<Op> selected = new LinkedHashSet<>();\n+\n@@ -322,7 +270,0 @@\n-    public Trxfmr select(Predicate<Op> codeElementPredicate, BiConsumer<Selector<?>,Op> selectorConsumer) {\n-        Selector<?> selector = Selector.of(this);\n-        funcOp().elements().filter(ce->ce instanceof Op).map(ce->(Op)ce).filter(codeElementPredicate).forEach(op->\n-                selectorConsumer.accept(selector,op)\n-        );\n-        return this;\n-    }\n@@ -344,8 +285,0 @@\n-    private boolean shouldTransform(Predicate<CodeElement<?,?>> predicate, Op op){\n-        boolean isEmpty = selected.isEmpty();\n-        boolean isInSelected = selected.contains(op);\n-        boolean isSelected = isEmpty|isInSelected;\n-        boolean passesPredicate = predicate.test(op);\n-        return isSelected && passesPredicate;\n-    }\n-\n@@ -357,1 +290,1 @@\n-            if (shouldTransform(predicate,op)){\n+            if (predicate.test(op)){\n@@ -381,1 +314,1 @@\n-            if (shouldTransform(predicate,op)){\n+            if (predicate.test(op)){\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"}]}