{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Stream;\n@@ -103,1 +104,21 @@\n-\n+        \/\/ validate runtime args types\n+        List<Value> symbolicValues = Stream.concat(parameters.stream(), capturedValues.stream()).toList();\n+        for (int i = 0; i < symbolicValues.size(); i++) {\n+            Value sv = symbolicValues.get(i);\n+            Object rv = args.get(i);\n+            try {\n+                JavaType typeToResolve = switch (sv.type()) {\n+                    case PrimitiveType pt -> pt.box().orElseThrow();\n+                    case JavaType jt -> jt;\n+                    default -> throw new IllegalStateException(\"Unexpected value: \" + sv.type());\n+                };\n+                Class<?> c = typeToResolve.toNominalDescriptor().resolveConstantDesc(l);\n+                if (!c.isInstance(rv)) {\n+                    Class<?> svc = ((JavaType) sv.type()).toNominalDescriptor().resolveConstantDesc(l);\n+                    throw interpreterException(new IllegalArgumentException((\"Runtime argument at position %d has type %s \" +\n+                            \"but the corresponding symbolic value has type %s\").formatted(i, rv.getClass(), svc)));\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestArgsTypesValidationWhenInterpreting\n+ *\/\n+public class TestArgsTypesValidationWhenInterpreting {\n+\n+    @CodeReflection\n+    private double f(int value) {\n+        return Math.pow(value, 2);\n+    }\n+\n+    @Test\n+    void test() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp funcOp = Op.ofMethod(m).get();\n+        System.out.println(funcOp.toText());\n+\n+        double res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2);\n+        Assert.assertEquals(res, 4d);\n+\n+        res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp,\n+                new TestArgsTypesValidationWhenInterpreting(), 2);\n+        Assert.assertEquals(res, 4d);\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, new Object(), 2));\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, null, 2));\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2d));\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestArgsTypesValidationWhenInterpreting.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}