{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Stream;\n@@ -75,0 +76,13 @@\n+    private static Class<?> getBoxedClass(Class<?> clazz) {\n+        if (clazz == int.class) return Integer.class;\n+        if (clazz == long.class) return Long.class;\n+        if (clazz == double.class) return Double.class;\n+        if (clazz == float.class) return Float.class;\n+        if (clazz == boolean.class) return Boolean.class;\n+        if (clazz == char.class) return Character.class;\n+        if (clazz == byte.class) return Byte.class;\n+        if (clazz == short.class) return Short.class;\n+        if (clazz == void.class) return Void.class;\n+        throw new IllegalArgumentException(\"Unknown primitive type: \" + clazz);\n+    }\n+\n@@ -103,1 +117,17 @@\n-\n+        \/\/ validate runtime args types\n+        List<Value> symbolicValues = Stream.concat(parameters.stream(), capturedValues.stream()).toList();\n+        for (int i = 0; i < symbolicValues.size(); i++) {\n+            try {\n+                Class<?> svc = ((JavaType) symbolicValues.get(i).type()).toNominalDescriptor().resolveConstantDesc(l);\n+                Class<?> c = svc;\n+                if (c.isPrimitive()) {\n+                    c = getBoxedClass(c);\n+                }\n+                if (!c.isInstance(args.get(i))) {\n+                    throw interpreterException(new IllegalArgumentException((\"Runtime argument at position %d has type %s \" +\n+                            \"but the corresponding symbolic value has type %s\").formatted(i, args.get(i).getClass(), svc)));\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestArgsTypesValidationWhenInterpreting\n+ *\/\n+public class TestArgsTypesValidationWhenInterpreting {\n+\n+    @CodeReflection\n+    private double f(int value) {\n+        return Math.pow(value, 2);\n+    }\n+\n+    @Test\n+    void test() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp funcOp = Op.ofMethod(m).get();\n+        System.out.println(funcOp.toText());\n+\n+        double res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2);\n+        Assert.assertEquals(res, 4d);\n+\n+        res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp,\n+                new TestArgsTypesValidationWhenInterpreting(), 2);\n+        Assert.assertEquals(res, 4d);\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, new Object(), 2));\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, null, 2));\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2d));\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArgsTypesValidationWhenInterpreting.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}