{"files":[{"patch":"@@ -76,13 +76,0 @@\n-    private static Class<?> getBoxedClass(Class<?> clazz) {\n-        if (clazz == int.class) return Integer.class;\n-        if (clazz == long.class) return Long.class;\n-        if (clazz == double.class) return Double.class;\n-        if (clazz == float.class) return Float.class;\n-        if (clazz == boolean.class) return Boolean.class;\n-        if (clazz == char.class) return Character.class;\n-        if (clazz == byte.class) return Byte.class;\n-        if (clazz == short.class) return Short.class;\n-        if (clazz == void.class) return Void.class;\n-        throw new IllegalArgumentException(\"Unknown primitive type: \" + clazz);\n-    }\n-\n@@ -120,0 +107,2 @@\n+            Value sv = symbolicValues.get(i);\n+            Object rv = args.get(i);\n@@ -121,1 +110,1 @@\n-                Class<?> svc = ((JavaType) symbolicValues.get(i).type()).toNominalDescriptor().resolveConstantDesc(l);\n+                Class<?> svc = ((JavaType) sv.type()).toNominalDescriptor().resolveConstantDesc(l);\n@@ -123,2 +112,3 @@\n-                if (c.isPrimitive()) {\n-                    c = getBoxedClass(c);\n+                if (sv.type() instanceof PrimitiveType pt) {\n+                    ClassType box = pt.box().orElseThrow();\n+                    c = box.toNominalDescriptor().resolveConstantDesc(l);\n@@ -126,1 +116,1 @@\n-                if (!c.isInstance(args.get(i))) {\n+                if (!c.isInstance(rv)) {\n@@ -128,1 +118,1 @@\n-                            \"but the corresponding symbolic value has type %s\").formatted(i, args.get(i).getClass(), svc)));\n+                            \"but the corresponding symbolic value has type %s\").formatted(i, rv.getClass(), svc)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-import jdk.incubator.code.CodeReflection;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run testng TestArgsTypesValidationWhenInterpreting\n- *\/\n-public class TestArgsTypesValidationWhenInterpreting {\n-\n-    @CodeReflection\n-    private double f(int value) {\n-        return Math.pow(value, 2);\n-    }\n-\n-    @Test\n-    void test() throws NoSuchMethodException {\n-        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n-        CoreOp.FuncOp funcOp = Op.ofMethod(m).get();\n-        System.out.println(funcOp.toText());\n-\n-        double res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2);\n-        Assert.assertEquals(res, 4d);\n-\n-        res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp,\n-                new TestArgsTypesValidationWhenInterpreting(), 2);\n-        Assert.assertEquals(res, 4d);\n-\n-        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, new Object(), 2));\n-\n-        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, null, 2));\n-\n-        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2d));\n-\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArgsTypesValidationWhenInterpreting.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestArgsTypesValidationWhenInterpreting\n+ *\/\n+public class TestArgsTypesValidationWhenInterpreting {\n+\n+    @CodeReflection\n+    private double f(int value) {\n+        return Math.pow(value, 2);\n+    }\n+\n+    @Test\n+    void test() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"f\", int.class);\n+        CoreOp.FuncOp funcOp = Op.ofMethod(m).get();\n+        System.out.println(funcOp.toText());\n+\n+        double res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2);\n+        Assert.assertEquals(res, 4d);\n+\n+        res = (double) Interpreter.invoke(MethodHandles.lookup(), funcOp,\n+                new TestArgsTypesValidationWhenInterpreting(), 2);\n+        Assert.assertEquals(res, 4d);\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, new Object(), 2));\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, null, 2));\n+\n+        Assert.assertThrows(() -> Interpreter.invoke(MethodHandles.lookup(), funcOp, this, 2d));\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestArgsTypesValidationWhenInterpreting.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}