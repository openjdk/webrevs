{"files":[{"patch":"@@ -136,0 +136,4 @@\n+    enum Uninitialized {\n+        UNINITIALIZED;\n+    }\n+\n@@ -188,1 +192,3 @@\n-                    Value current = op.operands().get(0);\n+                    Object current = varOp.isUninitialized()\n+                            ? Uninitialized.UNINITIALIZED\n+                            : op.operands().get(0);\n@@ -198,1 +204,1 @@\n-                    Object to = variableStack.get(loadOp.varOp()).peek();\n+                    Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n@@ -206,1 +212,1 @@\n-                            Object to = variableStack.get(loadOp.varOp()).peek();\n+                            Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n@@ -219,1 +225,1 @@\n-                            .map(vop -> variableStack.get(vop).peek()).toList();\n+                            .map(vop -> peekAtCurrentVariable(variableStack, vop)).toList();\n@@ -254,0 +260,12 @@\n+    static Object peekAtCurrentVariable(Map<CoreOp.VarOp, Deque<Object>> variableStack, CoreOp.VarOp vop) {\n+        Object to = variableStack.get(vop).peek();\n+        return throwIfUninitialized(vop, to);\n+    }\n+\n+    static Object throwIfUninitialized(CoreOp.VarOp vop, Object to) {\n+        if (to instanceof Uninitialized) {\n+            throw new IllegalStateException(\"Loading from uninitialized variable: \" + vop);\n+        }\n+        return to;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-     * Map of new object types (to resolve unitialized verification types in the stack map).\n+     * Map of new object types (to resolve uninitialized verification types in the stack map).\n@@ -486,1 +486,1 @@\n-     * The map is important to resolve unitialized verification types in the stack map.\n+     * The map is important to resolve uninitialized verification types in the stack map.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,0 +179,2 @@\n+\n+        static final Object UINITIALIZED = new Object();\n@@ -482,1 +484,4 @@\n-            return new VarBox(oc.getValue(o.operands().get(0)));\n+            Object v = vo.isUninitialized()\n+                    ? VarBox.UINITIALIZED\n+                    : oc.getValue(o.operands().get(0));\n+            return new VarBox(v);\n@@ -487,1 +492,5 @@\n-            return vb.value();\n+            Object value = vb.value();\n+            if (value == VarBox.UINITIALIZED) {\n+                throw interpreterException(new IllegalStateException(\"Loading from uninitialized variable\"));\n+            }\n+            return value;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2136,1 +2136,0 @@\n-\n@@ -2176,2 +2175,2 @@\n-            if (def.operands().size() != 1) {\n-                throw new IllegalStateException(\"Operation must have one operand\");\n+            if (def.operands().size() > 1) {\n+                throw new IllegalStateException(\"Operation must have zero or one operand\");\n@@ -2205,1 +2204,1 @@\n-            return resultType().valueType().equals(initOperand().type());\n+            return !isUninitialized() && resultType().valueType().equals(initOperand().type());\n@@ -2224,0 +2223,9 @@\n+        \/\/ @@@ This and the above constructor can be merged when\n+        \/\/ statements before super can be used in the jdk.compiler module\n+        VarOp(String varName, TypeElement type) {\n+            super(NAME, List.of());\n+\n+            this.varName =  varName == null ? \"\" : varName;\n+            this.resultType = VarType.varType(type);\n+        }\n+\n@@ -2236,0 +2244,3 @@\n+            if (operands().isEmpty()) {\n+                throw new IllegalStateException(\"Uninitialized variable\");\n+            }\n@@ -2255,0 +2266,4 @@\n+\n+        public boolean isUninitialized() {\n+            return operands().isEmpty();\n+        }\n@@ -4020,0 +4035,22 @@\n+    \/**\n+     * Creates a var operation modeling an unnamed and uninitialized variable,\n+     * either an unnamed local variable or an unnamed parameter.\n+     *\n+     * @param type the type of the var's value\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(TypeElement type) {\n+        return var(null, type, null);\n+    }\n+\n+    \/**\n+     * Creates a var operation modeling an uninitialized variable, either a local variable or a parameter.\n+     *\n+     * @param name the name of the var\n+     * @param type the type of the var's value\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type) {\n+        return new VarOp(name, type);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -838,1 +838,1 @@\n-            Value initOp;\n+            JavaType javaType = typeToTypeElement(tree.type);\n@@ -840,1 +840,2 @@\n-                initOp = toValue(tree.init, tree.type);\n+                Value initOp = toValue(tree.init, tree.type);\n+                result = append(CoreOp.var(tree.name.toString(), javaType, initOp));\n@@ -842,1 +843,2 @@\n-                initOp = append(defaultValue(tree.type));\n+                \/\/ Uninitialized\n+                result = append(CoreOp.var(tree.name.toString(), javaType));\n@@ -844,1 +846,0 @@\n-            result = append(CoreOp.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -1370,0 +1371,1 @@\n+                \/\/ @@@ use uninitialized variable\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestUninitializedVariable\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+public class TestUninitializedVariable {\n+\n+    @CodeReflection\n+    static int simple(int i) {\n+        int x;\n+        x = i; \/\/ drop store\n+        return x;\n+    }\n+\n+    @CodeReflection\n+    static int controlFlow(int i) {\n+        int x;\n+        if (i > 0) {\n+            x = i;  \/\/ drop store\n+        } else {\n+            x = -i;\n+        }\n+        return x;\n+    }\n+\n+    @DataProvider\n+    Object[][] methods() {\n+        return new Object[][] {\n+                { \"simple\" },\n+                { \"controlFlow\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testInterpret(String method) {\n+        CoreOp.FuncOp f = removeFirstStore(getFuncOp(method).transform(OpTransformer.LOWERING_TRANSFORMER));\n+        f.writeTo(System.out);\n+\n+        Assert.assertThrows(Interpreter.InterpreterException.class, () -> Interpreter.invoke(f, 1));\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testSSA(String method) {\n+        CoreOp.FuncOp f = removeFirstStore(getFuncOp(method).transform(OpTransformer.LOWERING_TRANSFORMER));\n+        f.writeTo(System.out);\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> SSA.transform(f));\n+    }\n+\n+    static CoreOp.FuncOp removeFirstStore(CoreOp.FuncOp f) {\n+        AtomicBoolean b = new AtomicBoolean();\n+        return f.transform((block, op) -> {\n+            if (op instanceof CoreOp.VarAccessOp.VarStoreOp vop && !b.getAndSet(true)) {\n+                \/\/ Drop first encountered var store\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestUninitializedVariable.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUninitializedVariable.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -328,2 +328,1 @@\n-                %2 : int = constant @\"0\";\n-                %3 : Var<int> = var %2 @\"i\";\n+                %3 : Var<int> = var @\"i\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-                %1 : long = constant @\"0\";\n-                %2 : Var<long> = var %1 @\"x\";\n+                %2 : Var<long> = var @\"x\";\n@@ -89,2 +88,1 @@\n-                %3 : long = constant @\"0\";\n-                %4 : Var<long> = var %3 @\"x\";\n+                %4 : Var<long> = var @\"x\";\n@@ -118,2 +116,1 @@\n-               %3 : long = constant @\"0\";\n-               %4 : Var<long> = var %3 @\"x\";\n+               %4 : Var<long> = var @\"x\";\n@@ -147,2 +144,1 @@\n-               %3 : long = constant @\"0\";\n-               %4 : Var<long> = var %3 @\"x\";\n+               %4 : Var<long> = var @\"x\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,4 +73,2 @@\n-                %1 : int = constant @\"0\";\n-                %2 : Var<int> = var %1 @\"x\";\n-                %3 : int = constant @\"0\";\n-                %4 : Var<int> = var %3 @\"y\";\n+                %2 : Var<int> = var @\"x\";\n+                %4 : Var<int> = var @\"y\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalVarTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-            func @\"tes4\" ()void -> {\n+            func @\"test4\" ()void -> {\n@@ -159,1 +159,1 @@\n-    static void tes4() {\n+    static void test4() {\n@@ -171,2 +171,1 @@\n-                %2 : java.lang.Boolean = constant @null;\n-                %3 : Var<java.lang.Boolean> = var %2 @\"b\";\n+                %3 : Var<java.lang.Boolean> = var @\"b\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/WhileLoopTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}