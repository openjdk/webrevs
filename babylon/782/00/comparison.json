{"files":[{"patch":"@@ -32,1 +32,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -414,1 +414,1 @@\n-        var here = OpTkl.CallSite.of(CudaBackend.class, \"createPTX\");\n+        var here = CallSite.of(CudaBackend.class, \"createPTX\");\n@@ -419,1 +419,1 @@\n-            loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.lookup(),loweredFunc, argsMap, usedMathFns);\n+            loweredFunc = transformPTXPtrs(kernelCallGraph.lookup(),loweredFunc, argsMap, usedMathFns);\n@@ -424,1 +424,1 @@\n-        CoreOp.FuncOp loweredPtx = transformPTXPtrs(kernelCallGraph.computeContext.lookup(),lowered, argsMap, usedMathFns);\n+        CoreOp.FuncOp loweredPtx = transformPTXPtrs(kernelCallGraph.lookup(),lowered, argsMap, usedMathFns);\n@@ -440,1 +440,1 @@\n-        var here = OpTkl.CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n+        var here = CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n@@ -472,1 +472,1 @@\n-        var here = OpTkl.CallSite.of(CudaBackend.class, \"createFucntion\" );\n+        var here = CallSite.of(CudaBackend.class, \"createFucntion\" );\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static hat.optools.OpTk.isIfaceBufferMethod;\n@@ -143,1 +144,1 @@\n-            if (op instanceof JavaOp.InvokeOp invoke && !OpTk.isIfaceBufferMethod(MethodHandles.lookup(),invoke)) {  \/\/ We should pass lookup down\n+            if (op instanceof JavaOp.InvokeOp invoke && !isIfaceBufferMethod(MethodHandles.lookup(),invoke)) {  \/\/ We should pass lookup down\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.CallSite;\n@@ -49,1 +50,0 @@\n-import hat.optools.OpTk;\n@@ -209,1 +209,1 @@\n-        var here = OpTkl.CallSite.of(C99FFIBackend.class, \"createCode\");\n+        var here = CallSite.of(C99FFIBackend.class, \"createCode\");\n@@ -268,1 +268,1 @@\n-                    Class<?> clazz = (Class<?>) ((ClassType) typeElement).resolve(kernelCallGraph.computeContext.lookup());\n+                    Class<?> clazz = (Class<?>) ((ClassType) typeElement).resolve(kernelCallGraph.lookup());\n@@ -287,1 +287,1 @@\n-                    new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.computeContext.lookup(),\n+                    new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.lookup(),\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.CallSite;\n@@ -69,1 +70,1 @@\n-        var here = OpTkl.CallSite.of(FFIBackend.class, \"dispatchCompute\");\n+        var here = CallSite.of(FFIBackend.class, \"dispatchCompute\");\n@@ -134,1 +135,1 @@\n-        var here = OpTkl.CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n+        var here = CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n@@ -140,1 +141,1 @@\n-            var lookup = computeMethod.callGraph.computeContext.lookup();\n+            var lookup = computeMethod.callGraph.lookup();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        if (kernelCallGraph.usesArrayView) {\n+        if (kernelCallGraph.traits.usesArrayView) {\n","filename":"hat\/backends\/java\/mt\/src\/main\/java\/hat\/backend\/java\/JavaMultiThreadedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        if (kernelCallGraph.usesArrayView) {\n+        if (kernelCallGraph.traits.usesArrayView) {\n","filename":"hat\/backends\/java\/seq\/src\/main\/java\/hat\/backend\/java\/JavaSequentialBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.CallSite;\n@@ -82,1 +83,1 @@\n-        var here = OpTkl.CallSite.of(C99JExtractedBackend.class, \"createCode\");\n+        var here = CallSite.of(C99JExtractedBackend.class, \"createCode\");\n@@ -97,1 +98,1 @@\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelCallGraph.computeContext.lookup()\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelCallGraph.lookup()\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.CallSite;\n@@ -64,1 +65,1 @@\n-        var here = OpTkl.CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n+        var here = CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n@@ -89,1 +90,1 @@\n-        var lookup = computeMethod.callGraph.computeContext.lookup();\n+        var lookup = computeMethod.callGraph.lookup();\n@@ -92,1 +93,1 @@\n-        var here = OpTkl.CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n+        var here = CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import optkl.CallSite;\n@@ -92,1 +93,1 @@\n-        var here = OpTkl.CallSite.of(BufferTagger.class, \"inlineLoop\");\n+        var here = CallSite.of(BufferTagger.class, \"inlineLoop\");\n@@ -97,1 +98,1 @@\n-            ssaFunc = OpTkl.transform(OpTkl.CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n+            ssaFunc = OpTkl.transform(CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n@@ -131,1 +132,1 @@\n-        var here = OpTkl.CallSite.of(BufferTagger.class, \"buildAccessMap\");\n+        var here = CallSite.of(BufferTagger.class, \"buildAccessMap\");\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    public Config config() {\n+        return accelerator().config();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -66,1 +66,1 @@\n-        var here = OpTkl.CallSite.of(DebugBackend.class,\"dispatchCompute\");\n+        var here = CallSite.of(DebugBackend.class,\"dispatchCompute\");\n@@ -105,1 +105,1 @@\n-        var here = OpTkl.CallSite.of(DebugBackend.class, \"dispatchKernel\");\n+        var here = CallSite.of(DebugBackend.class, \"dispatchKernel\");\n@@ -123,1 +123,1 @@\n-                Interpreter.invoke(kernelCallGraph.computeContext.lookup(), lowered, args);\n+                Interpreter.invoke(kernelCallGraph.lookup(), lowered, args);\n@@ -128,1 +128,1 @@\n-                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.lookup(), lowered);\n+                var mh = BytecodeGenerator.generate(kernelCallGraph.lookup(), lowered);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-        List<BufferTagger.AccessType> bufferAccessList = kernelCallGraph.bufferAccessList;\n+         List<BufferTagger.AccessType> bufferAccessList = kernelCallGraph.traits.bufferAccessList;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.Op;\n@@ -32,0 +33,1 @@\n+import optkl.CallSite;\n@@ -33,0 +35,1 @@\n+import optkl.OpTkl;\n@@ -34,0 +37,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,0 +39,3 @@\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n@@ -37,0 +44,2 @@\n+import java.util.LinkedHashSet;\n+import java.util.List;\n@@ -39,1 +48,3 @@\n-import java.util.stream.Stream;\n+\n+import static optkl.OpTkl.elements;\n+import static optkl.OpTkl.javaRefClassOrThrow;\n@@ -42,0 +53,7 @@\n+\n+    @Override\n+    public final MethodHandles.Lookup lookup() {\n+        return computeContext.lookup();\n+    }\n+\n+\n@@ -56,0 +74,62 @@\n+     CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+                                                        CoreOp.FuncOp entry) {\n+        LinkedHashSet<MethodRef> funcsVisited = new LinkedHashSet<>();\n+        List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+        record RefAndFunc(MethodRef r, CoreOp.FuncOp f) {}\n+\n+        Deque<RefAndFunc> work = new ArrayDeque<>();\n+        var here = CallSite.of(OpTkl.class, \"createTransitiveInvokeModule\");\n+        elements(here, entry).forEach(codeElement -> {\n+            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                Class<?> javaRefTypeClass = javaRefClassOrThrow(lookup(), invokeOp);\n+                try {\n+                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n+                    CoreOp.FuncOp f = Op.ofMethod(method).orElse(null);\n+                    \/\/ TODO filter calls has side effects we may need another call. We might just check the map.\n+\n+                    if (f != null && !filterCalls(f, invokeOp, method, invokeOp.invokeDescriptor(), javaRefTypeClass)) {\n+                        work.push(new RefAndFunc(invokeOp.invokeDescriptor(),  f));\n+                    }\n+                } catch (ReflectiveOperationException _) {\n+                    throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n+                }\n+            }\n+        });\n+\n+        while (!work.isEmpty()) {\n+            RefAndFunc rf = work.pop();\n+            if (funcsVisited.add(rf.r)) {\n+                \/\/ TODO:is this really transforming? it seems to be creating a new funcop.. Oh I guess for the new ModuleOp?\n+                CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n+                    if (op instanceof JavaOp.InvokeOp iop) {\n+                        try {\n+                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(lookup);\n+                            if (invokeOpCalledMethod instanceof Method m) {\n+                                CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n+                                if (f != null) {\n+                                    RefAndFunc call = new RefAndFunc(iop.invokeDescriptor(), f);\n+                                    work.push(call);\n+                                    Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                            call.r.name(),\n+                                            call.f.invokableType(),\n+                                            blockBuilder.context().getValues(iop.operands())));\n+                                    blockBuilder.context().mapValue(op.result(), result);\n+                                    return blockBuilder;\n+                                }\n+                            }\n+                        } catch (ReflectiveOperationException _) {\n+                            throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n+                        }\n+                    }\n+                    blockBuilder.op(op);\n+                    return blockBuilder;\n+                });\n+\n+                funcs.addFirst(tf);\n+            }\n+        }\n+\n+        return CoreOp.module(funcs);\n+    }\n+\n+\n@@ -58,0 +138,4 @@\n+    public Config config() {\n+        return computeContext.config();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":85,"deletions":1,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.Accelerator;\n@@ -29,0 +28,1 @@\n+import hat.Config;\n@@ -34,1 +34,0 @@\n-import optkl.StreamMutable;\n@@ -38,1 +37,0 @@\n-import jdk.incubator.code.Op;\n@@ -55,3 +53,2 @@\n-    @Override\n-    public MethodHandles.Lookup lookup() {\n-        return computeContext.lookup();\n+    public Config config() {\n+        return computeContext.config();\n@@ -99,1 +96,12 @@\n-    static boolean isKernelDispatch(MethodHandles.Lookup lookup,Method calledMethod, CoreOp.FuncOp fow) {\n+    static boolean isValidKernelDispatch(MethodHandles.Lookup lookup, Method calledMethod, CoreOp.FuncOp fow) {\n+        \/\/ We check that the proposed kernel returns void, the first arg is an KernelContext and we have more args\n+        \/\/ We also check that other args are primitive or ifacebuffers  (or atomics?)...\n+        class Traits{\n+            boolean firstArgKernelContext = false;\n+            boolean atLeastOneIfaceBufferParam=false;\n+            boolean hasOnlyPrimitiveAndIfaceBufferParams=true;\n+            boolean ok(){\n+                return firstArgKernelContext &&atLeastOneIfaceBufferParam&&hasOnlyPrimitiveAndIfaceBufferParams;\n+            }\n+        }\n+        var traits = new Traits();\n@@ -103,5 +111,0 @@\n-                \/\/ We check that the proposed kernel returns void, the first arg is an KernelContext and we have more args\n-                \/\/ We also check that other args are primitive or ifacebuffers  (or atomics?)...\n-                var firstArgIsKid = StreamMutable.of(false);\n-                var atLeastOneIfaceBufferParam = StreamMutable.of(false);\n-                var hasOnlyPrimitiveAndIfaceBufferParams = StreamMutable.of(true);\n@@ -111,1 +114,1 @@\n-                        firstArgIsKid.set(parameterTypes[0].isAssignableFrom(KernelContext.class));\n+                        traits.firstArgKernelContext = parameterTypes[0].isAssignableFrom(KernelContext.class);\n@@ -116,1 +119,1 @@\n-                            atLeastOneIfaceBufferParam.set(true);\n+                            traits.atLeastOneIfaceBufferParam= true;\n@@ -118,1 +121,1 @@\n-                            hasOnlyPrimitiveAndIfaceBufferParams.set(false);\n+                            traits.hasOnlyPrimitiveAndIfaceBufferParams=false;\n@@ -122,1 +125,0 @@\n-                return true;\n@@ -124,1 +126,1 @@\n-            return false;\n+            return traits.ok();\n@@ -133,2 +135,1 @@\n-        setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.lookup(), entrypoint.funcOp(), this));\n-        \/\/close(entrypoint);\n+        setModuleOp(createTransitiveInvokeModule(computeContext.lookup(), entrypoint.funcOp()));\n@@ -141,1 +142,1 @@\n-                && isKernelDispatch(computeContext.lookup(),method, f)) {\n+                && isValidKernelDispatch(computeContext.lookup(),method, f)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-     \/\/default Annotation[][] getParamaterAnnotations(){\n-        \/\/ return getMethod().getParameterAnnotations();\n-    \/\/ }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/Entrypoint.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,6 +43,6 @@\n-    public final List<BufferTagger.AccessType> bufferAccessList;\n-    public boolean usesArrayView;\n-\n-    @Override\n-    public MethodHandles.Lookup lookup() {\n-        return computeContext.lookup();\n+    public static class Traits{\n+        public final List<BufferTagger.AccessType> bufferAccessList;\n+        public boolean usesArrayView;\n+        Traits(List<BufferTagger.AccessType> bufferAccessList){\n+            this.bufferAccessList=bufferAccessList;\n+        }\n@@ -50,0 +50,2 @@\n+    final public Traits traits;\n+\n@@ -82,1 +84,1 @@\n-        entrypoint.callGraph = this;\n+        this.entrypoint.callGraph = this;\n@@ -84,4 +86,3 @@\n-        bufferAccessList = BufferTagger.getAccessList(computeContext.lookup(), entrypoint.funcOp());\n-        usesArrayView = false;\n-        CoreOp.ModuleOp initialModuleOp = OpTk.createTransitiveInvokeModule(computeContext.lookup(), entrypoint.funcOp(), this);\n-        HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator());\n+        this.traits = new Traits(BufferTagger.getAccessList(computeContext.lookup(), entrypoint.funcOp()));\n+\n+        HATDialectifyTier tier = new HATDialectifyTier(this);\n@@ -89,0 +90,1 @@\n+\n@@ -91,0 +93,3 @@\n+\n+        CoreOp.ModuleOp initialModuleOp = createTransitiveInvokeModule(computeContext.lookup(), entrypoint.funcOp());\n+\n@@ -94,0 +99,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-                                        nlSeparated(OpTk.statements(ifOp.bodies().get(idx).entryBlock()),\n+                                        nlSeparated(OpTkl.statements(ifOp.bodies().get(idx).entryBlock()),\n@@ -326,1 +326,1 @@\n-                        nlSeparated(OpTk.statements(whileOp),\n+                        nlSeparated(OpTkl.loopBodyStatements(whileOp),\n@@ -342,1 +342,1 @@\n-                            OpTk.statements(mutateBlock(forOp)),\n+                            OpTkl.statements(mutateBlock(forOp)),\n@@ -346,1 +346,1 @@\n-                            nlSeparated(OpTk.statements(forOp),\n+                            nlSeparated(OpTkl.loopBodyStatements(forOp),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import hat.optools.OpTk;\n-\n@@ -30,0 +28,1 @@\n+import optkl.OpTkl;\n@@ -51,1 +50,1 @@\n-                        OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                        OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import hat.optools.OpTk;\n@@ -369,1 +368,1 @@\n-                        OpTk.statements(funcOp.bodies().getFirst().entryBlock()),\n+                        OpTkl.statements(funcOp.bodies().getFirst().entryBlock()),\n@@ -386,1 +385,1 @@\n-                    OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.StatementLikeOp;\n@@ -37,1 +38,1 @@\n-public final class HATF16VarOp extends HATF16Op {\n+public final class HATF16VarOp extends HATF16Op implements StatementLikeOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATF16VarOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import optkl.StatementLikeOp;\n@@ -36,1 +37,1 @@\n-public abstract sealed class HATMemoryVarOp extends HATOp implements VarLikeOp permits HATLocalVarOp, HATPrivateVarOp, HATPrivateInitVarOp  {\n+public abstract sealed class HATMemoryVarOp extends HATOp implements VarLikeOp, StatementLikeOp permits HATLocalVarOp, HATPrivateVarOp, HATPrivateInitVarOp  {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryVarOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.StatementLikeOp;\n@@ -37,1 +38,1 @@\n-public final class HATVectorVarOp extends HATVectorOp {\n+public final class HATVectorVarOp extends HATVectorOp implements StatementLikeOp {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.callgraph.CallGraph;\n@@ -32,1 +31,0 @@\n-import hat.dialect.*;\n@@ -37,1 +35,0 @@\n-import jdk.incubator.code.Block;\n@@ -45,2 +42,0 @@\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import optkl.ParamVar;\n@@ -49,3 +44,0 @@\n-import java.lang.reflect.Method;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n@@ -53,1 +45,0 @@\n-import java.util.Deque;\n@@ -55,2 +46,0 @@\n-import java.util.LinkedHashSet;\n-import java.util.List;\n@@ -61,1 +50,0 @@\n-import java.util.stream.Stream;\n@@ -64,1 +52,0 @@\n-import static optkl.OpTkl.elements;\n@@ -68,1 +55,0 @@\n-import static optkl.OpTkl.javaRefClassOrThrow;\n@@ -78,0 +64,2 @@\n+    \/* KernelContext *\/\n+\n@@ -81,3 +69,0 @@\n-    default boolean isKernelContext(TypeElement typeElement){\n-        return isAssignable(lookup(),typeElement,KernelContext.class);\n-    }\n@@ -125,4 +110,1 @@\n-    static boolean isKernelContextFieldAccessOp(MethodHandles.Lookup lookup,CodeElement<?, ?> ce) {\n-        return isKernelContextFieldAccessOp(lookup,ce, AnyFieldAccess);\n-    }\n-\n+    \/* ComputeContext *\/\n@@ -134,0 +116,5 @@\n+    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+        return isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n+                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n+                && isMethod(invokeOp, namePredicate);\n+    }\n@@ -136,1 +123,1 @@\n-\n+    \/* ComputeContext *\/\n@@ -142,82 +129,1 @@\n-    static Stream<Op> statements(Op.Loop op) {\n-        var list = new ArrayList<>(statements( op.loopBody().entryBlock()).toList());\n-        if (list.getLast() instanceof JavaOp.ContinueOp) {\n-            list.removeLast();\n-        }\n-        return list.stream();\n-    }\n-\n-    static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n-                                                               CoreOp.FuncOp entry, CallGraph<?> callGraph) {\n-        LinkedHashSet<MethodRef> funcsVisited = new LinkedHashSet<>();\n-        List<CoreOp.FuncOp> funcs = new ArrayList<>();\n-        record RefAndFunc(MethodRef r, CoreOp.FuncOp f) {}\n-\n-        Deque<RefAndFunc> work = new ArrayDeque<>();\n-        var here = OpTkl.CallSite.of(OpTkl.class, \"createTransitiveInvokeModule\");\n-        elements(here, entry).forEach(codeElement -> {\n-            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                Class<?> javaRefTypeClass = javaRefClassOrThrow(callGraph.lookup(), invokeOp);\n-                try {\n-                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n-                    CoreOp.FuncOp f = Op.ofMethod(method).orElse(null);\n-                    \/\/ TODO filter calls has side effects we may need another call. We might just check the map.\n-\n-                    if (f != null && !callGraph.filterCalls(f, invokeOp, method, invokeOp.invokeDescriptor(), javaRefTypeClass)) {\n-                        work.push(new RefAndFunc(invokeOp.invokeDescriptor(),  f));\n-                    }\n-                } catch (ReflectiveOperationException _) {\n-                    throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n-                }\n-            }\n-        });\n-\n-        while (!work.isEmpty()) {\n-            RefAndFunc rf = work.pop();\n-            if (funcsVisited.add(rf.r)) {\n-                \/\/ TODO:is this really transforming? it seems to be creating a new funcop.. Oh I guess for the new ModuleOp?\n-                CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n-                    if (op instanceof JavaOp.InvokeOp iop) {\n-                        try {\n-                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(lookup);\n-                            if (invokeOpCalledMethod instanceof Method m) {\n-                                CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n-                                if (f != null) {\n-                                    RefAndFunc call = new RefAndFunc(iop.invokeDescriptor(), f);\n-                                    work.push(call);\n-                                    Op.Result result = blockBuilder.op(CoreOp.funcCall(\n-                                            call.r.name(),\n-                                            call.f.invokableType(),\n-                                            blockBuilder.context().getValues(iop.operands())));\n-                                    blockBuilder.context().mapValue(op.result(), result);\n-                                    return blockBuilder;\n-                                }\n-                            }\n-                        } catch (ReflectiveOperationException _) {\n-                            throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n-                        }\n-                    }\n-                    blockBuilder.op(op);\n-                    return blockBuilder;\n-                });\n-\n-                funcs.addFirst(tf);\n-            }\n-        }\n-\n-        return CoreOp.module(funcs);\n-    }\n-    static Stream<Op> statements(Block block) {\n-        return block.ops().stream().filter(op->\n-        (\n-                (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-             || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-             || (op instanceof HATMemoryVarOp)\n-             || (op instanceof HATVectorVarOp)\n-             || (op instanceof HATF16VarOp)\n-        )\n-        && !(op instanceof CoreOp.VarOp varOp && ParamVar.of(varOp) != null)\n-        && !(op instanceof CoreOp.YieldOp));\n-    }\n-\n-\n+    \/* these seem to be just replacements for isAssignable *\/\n@@ -233,2 +139,1 @@\n-        \/\/ is Assignble\n-        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n@@ -239,1 +144,1 @@\n-                interfaces = OpTk.inspectAllInterfacesWhy(aClass);\n+                interfaces = inspectAllInterfacesWhy(aClass);\n@@ -251,1 +156,1 @@\n-            interfaces = OpTk.inspectAllInterfacesWhy(aClass);\n+            interfaces = inspectAllInterfacesWhy(aClass);\n@@ -310,6 +215,0 @@\n-    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-        return isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n-                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n-                && isMethod(invokeOp, namePredicate);\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":13,"deletions":114,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -210,1 +210,1 @@\n-    public final OpTkl.CallSite callSite;\n+    public final CallSite callSite;\n@@ -220,1 +220,1 @@\n-    public Trxfmr(OpTkl.CallSite callSite, CoreOp.FuncOp funcOp) {\n+    public Trxfmr(CallSite callSite, CoreOp.FuncOp funcOp) {\n@@ -375,1 +375,1 @@\n-                 return new Trxfmr(OpTkl.CallSite.of(this.getClass()), funcOp)\n+                 return new Trxfmr(CallSite.of(this.getClass()), funcOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Accelerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n-\n-import java.util.function.Function;\n-\n-public interface HATDialect  extends Function<CoreOp.FuncOp,CoreOp.FuncOp> {\n-    LookupCarrier lookupCarrier();\n-\n-    default boolean tracing(){\n-        return ((Accelerator)lookupCarrier()).backend.config().showCompilationPhases();\n-    }\n-\n-    default void before(OpTkl.CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model before [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \"  + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-\n-    default void after(OpTkl.CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \" + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.callgraph.KernelCallGraph;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.CallSite;\n+import optkl.LookupCarrier;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.Function;\n+\n+public sealed interface HATDialectPhase extends Function<CoreOp.FuncOp,CoreOp.FuncOp>,LookupCarrier\n+        permits HATDialectifyArrayViewPhase, HATDialectifyBarrierPhase, HATDialectifyFP16Phase,\n+        HATDialectifyMemoryPhase, HATDialectifyThreadsPhase, HATDialectifyVectorOpPhase, HATDialectifyVectorSelectPhase, HATDialectifyVectorStorePhase {\n+\n+\n+    KernelCallGraph kernelCallGraph();\n+\n+    @Override default MethodHandles.Lookup lookup(){\n+        return kernelCallGraph().lookup();\n+    }\n+\n+    default boolean tracing(){\n+            return kernelCallGraph().config().showCompilationPhases();\n+    }\n+\n+    default void before(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (tracing()) {\n+            IO.println(\"[INFO] Code model before [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \"  + System.lineSeparator() + funcOp.toText());\n+        }\n+    }\n+\n+    default void after(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (tracing()) {\n+            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \" + System.lineSeparator() + funcOp.toText());\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectPhase.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -29,2 +30,1 @@\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -48,1 +48,1 @@\n-public record HATDialectifyArrayViewPhase(LookupCarrier lookupCarrier) implements HATDialect {\n+public record HATDialectifyArrayViewPhase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n@@ -52,1 +52,1 @@\n-        MethodHandles.Lookup l = lookupCarrier.lookup();\n+        MethodHandles.Lookup l = lookup();\n@@ -314,1 +314,1 @@\n-                return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookupCarrier.lookup()));\n+                return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup()));\n@@ -369,1 +369,1 @@\n-        var here = OpTkl.CallSite.of(HATDialectifyArrayViewPhase.class, \"isArrayView\");\n+        var here = CallSite.of(HATDialectifyArrayViewPhase.class, \"isArrayView\");\n@@ -374,2 +374,2 @@\n-                        (isAssignable(lookupCarrier.lookup(), javaType, MappableIface.class)\n-                                || isAssignable(lookupCarrier.lookup(), javaType, DeviceType.class))));\n+                        (isAssignable(lookup(), javaType, MappableIface.class)\n+                                || isAssignable(lookup(), javaType, DeviceType.class))));\n@@ -395,1 +395,1 @@\n-                return ((Class<?>) classType.resolve(lookupCarrier.lookup()));\n+                return ((Class<?>) classType.resolve(lookup()));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -30,1 +31,1 @@\n-import optkl.LookupCarrier;\n+import optkl.CallSite;\n@@ -35,1 +36,1 @@\n-public record HATDialectifyBarrierPhase(LookupCarrier lookupCarrier) implements HATDialect {\n+public record HATDialectifyBarrierPhase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n@@ -39,1 +40,1 @@\n-        var here = OpTkl.CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n+        var here = CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n@@ -46,1 +47,1 @@\n-                \/* filter op                    *\/ ce -> OpTk.isKernelContextInvokeOp(lookupCarrier.lookup(), ce,\n+                \/* filter op                    *\/ ce -> OpTk.isKernelContextInvokeOp(lookup(), ce,\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -39,1 +40,0 @@\n-import hat.optools.OpTk;\n@@ -49,2 +49,1 @@\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -62,1 +61,1 @@\n-public record HATDialectifyFP16Phase(LookupCarrier lookupCarrier) implements HATDialect {\n+public record HATDialectifyFP16Phase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n@@ -208,1 +207,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n@@ -249,1 +248,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyF16Stores\");\n@@ -297,1 +296,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16Init\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyF16Init\");\n@@ -336,1 +335,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyF16ToFloat\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyF16ToFloat\");\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import hat.callgraph.KernelCallGraph;\n@@ -43,2 +43,1 @@\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -59,1 +58,1 @@\n-public abstract class HATDialectifyMemoryPhase implements HATDialect {\n+public abstract sealed class HATDialectifyMemoryPhase implements HATDialectPhase {\n@@ -61,1 +60,6 @@\n-    protected final LookupCarrier lookupCarrier;\n+    protected final KernelCallGraph kernelCallGraph;\n+\n+    @Override\n+    public KernelCallGraph kernelCallGraph(){\n+        return this.kernelCallGraph;\n+    }\n@@ -73,5 +77,0 @@\n-    @Override\n-    public LookupCarrier lookupCarrier(){\n-        return this.lookupCarrier;\n-    }\n-\n@@ -82,2 +81,2 @@\n-    public HATDialectifyMemoryPhase(LookupCarrier lookupCarrier) {\n-        this.lookupCarrier = lookupCarrier;\n+    public HATDialectifyMemoryPhase(KernelCallGraph kernelCallGraph) {\n+        this.kernelCallGraph = kernelCallGraph;\n@@ -88,1 +87,1 @@\n-        var here = OpTkl.CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n+        var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n@@ -130,3 +129,3 @@\n-    public static class PrivateMemoryPhase extends HATDialectifyMemoryPhase {\n-        public PrivateMemoryPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier);\n+    public static final class PrivateMemoryPhase extends HATDialectifyMemoryPhase {\n+        public PrivateMemoryPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n@@ -137,1 +136,1 @@\n-            if (isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n+            if (isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n@@ -141,1 +140,1 @@\n-                        && isAssignable(lookupCarrier.lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n+                        && isAssignable(lookup(),invokeOp.invokeDescriptor().refType(),DeviceType.class);\n@@ -159,1 +158,1 @@\n-    public static class LocalMemoryPhase extends HATDialectifyMemoryPhase {\n+    public static final  class LocalMemoryPhase extends HATDialectifyMemoryPhase {\n@@ -161,2 +160,2 @@\n-        public LocalMemoryPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier);\n+        public LocalMemoryPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n@@ -167,1 +166,1 @@\n-            if (isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n+            if (isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n@@ -172,1 +171,1 @@\n-                        isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n+                        isAssignable(lookup(),javaType,DeviceType.class));\n@@ -190,1 +189,1 @@\n-    public static class DeviceTypePhase extends HATDialectifyMemoryPhase {\n+    public static final class DeviceTypePhase extends HATDialectifyMemoryPhase {\n@@ -192,2 +191,2 @@\n-        public DeviceTypePhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier);\n+        public DeviceTypePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n@@ -198,1 +197,1 @@\n-            return isIfaceBufferInvokeOpWithName(lookupCarrier.lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+            return isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n@@ -201,1 +200,1 @@\n-                    isAssignable(lookupCarrier.lookup(),javaType,DeviceType.class));\n+                    isAssignable(lookup(),javaType,DeviceType.class));\n@@ -209,1 +208,1 @@\n-            return OpTk.isInvokeDescriptorSubtypeOf(lookupCarrier.lookup(),invokeOp, DeviceType.class)\n+            return OpTk.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n@@ -217,1 +216,1 @@\n-            var here = OpTkl.CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n+            var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":29,"deletions":30,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -38,1 +39,1 @@\n-import optkl.LookupCarrier;\n+import optkl.CallSite;\n@@ -46,4 +47,4 @@\n-public abstract class HATDialectifyThreadsPhase<T extends HATDialectifyThreadsPhase<T,C>,C extends HATThreadOp> implements HATDialect  {\n-    protected final LookupCarrier lookupCarrier;\n-    @Override  public LookupCarrier lookupCarrier(){\n-        return this.lookupCarrier;\n+public sealed abstract class HATDialectifyThreadsPhase<T extends HATDialectifyThreadsPhase<T,C>,C extends HATThreadOp> implements HATDialectPhase {\n+    private final KernelCallGraph kernelCallGraph;\n+    @Override public KernelCallGraph kernelCallGraph(){\n+        return kernelCallGraph;\n@@ -53,2 +54,2 @@\n-    public HATDialectifyThreadsPhase(LookupCarrier lookupCarrier, Class<C> clazz) {\n-        this.lookupCarrier=lookupCarrier;\n+    public HATDialectifyThreadsPhase(KernelCallGraph kernelCallGraph, Class<C> clazz) {\n+        this.kernelCallGraph=kernelCallGraph;\n@@ -64,1 +65,1 @@\n-        var txfmr = new Trxfmr(OpTkl.CallSite.of(this.getClass()),funcOp);\n+        var txfmr = new Trxfmr(CallSite.of(this.getClass()),funcOp);\n@@ -66,1 +67,1 @@\n-                ce->OpTk.asNamedKernelContextFieldAccessOrNull(lookupCarrier.lookup(),ce,pattern())!=null,(s,o)->\n+                ce->OpTk.asNamedKernelContextFieldAccessOrNull(lookup(),ce,pattern())!=null,(s,o)->\n@@ -82,3 +83,3 @@\n-    public static class BlockPhase extends HATDialectifyThreadsPhase<BlockPhase,HATBlockThreadIdOp> {\n-        public BlockPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, HATBlockThreadIdOp.class);\n+    public static final class BlockPhase extends HATDialectifyThreadsPhase<BlockPhase,HATBlockThreadIdOp> {\n+        public BlockPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, HATBlockThreadIdOp.class);\n@@ -96,3 +97,3 @@\n-    public static class GlobalIdPhase extends HATDialectifyThreadsPhase<GlobalIdPhase,HATGlobalThreadIdOp>  {\n-        public GlobalIdPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, HATGlobalThreadIdOp.class);\n+    public static final class GlobalIdPhase extends HATDialectifyThreadsPhase<GlobalIdPhase,HATGlobalThreadIdOp>  {\n+        public GlobalIdPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, HATGlobalThreadIdOp.class);\n@@ -109,3 +110,3 @@\n-    public static class GlobalSizePhase extends HATDialectifyThreadsPhase<GlobalSizePhase,HATGlobalSizeOp>  {\n-        public GlobalSizePhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, HATGlobalSizeOp.class);\n+    public static final class GlobalSizePhase extends HATDialectifyThreadsPhase<GlobalSizePhase,HATGlobalSizeOp>  {\n+        public GlobalSizePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, HATGlobalSizeOp.class);\n@@ -122,3 +123,3 @@\n-    public static class LocalIdPhase extends HATDialectifyThreadsPhase<LocalIdPhase,HATLocalThreadIdOp>  {\n-        public LocalIdPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier,HATLocalThreadIdOp.class);\n+    public static final class LocalIdPhase extends HATDialectifyThreadsPhase<LocalIdPhase,HATLocalThreadIdOp>  {\n+        public LocalIdPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph,HATLocalThreadIdOp.class);\n@@ -135,3 +136,3 @@\n-    public static class LocalSizePhase extends HATDialectifyThreadsPhase<LocalSizePhase,HATLocalSizeOp>  {\n-        public LocalSizePhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier,HATLocalSizeOp.class);\n+    public static final class LocalSizePhase extends HATDialectifyThreadsPhase<LocalSizePhase,HATLocalSizeOp>  {\n+        public LocalSizePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph,HATLocalSizeOp.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import hat.callgraph.KernelCallGraph;\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -37,3 +38,7 @@\n-public class HATDialectifyTier implements Function<CoreOp.FuncOp, CoreOp.FuncOp> {\n-\n-    private List<HATDialect> hatPhases = new ArrayList<>();\n+public class HATDialectifyTier implements Function<CoreOp.FuncOp, CoreOp.FuncOp>, LookupCarrier {\n+    KernelCallGraph kernelCallGraph;\n+    @Override\n+    public MethodHandles.Lookup lookup(){\n+        return kernelCallGraph.lookup();\n+    }\n+    private List<HATDialectPhase> hatPhases = new ArrayList<>();\n@@ -41,1 +46,2 @@\n-    public HATDialectifyTier(LookupCarrier lc) {\n+    public HATDialectifyTier(KernelCallGraph kernelCallGraph) {\n+        this.kernelCallGraph = kernelCallGraph;\n@@ -43,1 +49,1 @@\n-        hatPhases.add(new HATDialectifyBarrierPhase(lc));\n+        hatPhases.add(new HATDialectifyBarrierPhase(kernelCallGraph));\n@@ -46,1 +52,1 @@\n-        hatPhases.add(new HATDialectifyArrayViewPhase(lc));\n+        hatPhases.add(new HATDialectifyArrayViewPhase(kernelCallGraph));\n@@ -49,3 +55,3 @@\n-        hatPhases.add(new HATDialectifyMemoryPhase.LocalMemoryPhase(lc));\n-        hatPhases.add(new HATDialectifyMemoryPhase.PrivateMemoryPhase(lc));\n-        hatPhases.add(new HATDialectifyMemoryPhase.DeviceTypePhase(lc));\n+        hatPhases.add(new HATDialectifyMemoryPhase.LocalMemoryPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyMemoryPhase.PrivateMemoryPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyMemoryPhase.DeviceTypePhase(kernelCallGraph));\n@@ -54,5 +60,5 @@\n-        hatPhases.add(new HATDialectifyThreadsPhase.GlobalIdPhase(lc));\n-        hatPhases.add(new HATDialectifyThreadsPhase.GlobalSizePhase(lc));\n-        hatPhases.add(new HATDialectifyThreadsPhase.LocalIdPhase(lc));\n-        hatPhases.add(new HATDialectifyThreadsPhase.LocalSizePhase(lc));\n-        hatPhases.add(new HATDialectifyThreadsPhase.BlockPhase(lc));\n+        hatPhases.add(new HATDialectifyThreadsPhase.GlobalIdPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyThreadsPhase.GlobalSizePhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyThreadsPhase.LocalIdPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyThreadsPhase.LocalSizePhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyThreadsPhase.BlockPhase(kernelCallGraph));\n@@ -61,10 +67,10 @@\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float4LoadPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float2LoadPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float4OfPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.AddPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.SubPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.MulPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.DivPhase(lc));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.MakeMutable(lc));\n-        hatPhases.add(new HATDialectifyVectorStorePhase.Float4StorePhase(lc));\n-        hatPhases.add(new HATDialectifyVectorStorePhase.Float2StorePhase(lc));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float4LoadPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float2LoadPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.Float4OfPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.AddPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.SubPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.MulPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.DivPhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorOpPhase.MakeMutable(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorStorePhase.Float4StorePhase(kernelCallGraph));\n+        hatPhases.add(new HATDialectifyVectorStorePhase.Float2StorePhase(kernelCallGraph));\n@@ -73,1 +79,1 @@\n-        hatPhases.add(new HATDialectifyVectorSelectPhase(lc));\n+        hatPhases.add(new HATDialectifyVectorSelectPhase(kernelCallGraph));\n@@ -76,1 +82,1 @@\n-        hatPhases.add(new HATDialectifyFP16Phase(lc));\n+        hatPhases.add(new HATDialectifyFP16Phase(kernelCallGraph));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import hat.callgraph.KernelCallGraph;\n@@ -42,1 +42,0 @@\n-import hat.optools.OpTk;\n@@ -53,2 +52,1 @@\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -73,3 +71,5 @@\n-public abstract class HATDialectifyVectorOpPhase implements HATDialect {\n-\n-    protected final LookupCarrier lookupCarrier;\n+public abstract sealed class HATDialectifyVectorOpPhase implements HATDialectPhase {\n+    private final KernelCallGraph kernelCallGraph;\n+@Override public KernelCallGraph kernelCallGraph(){\n+    return kernelCallGraph;\n+}\n@@ -77,4 +77,0 @@\n-    @Override\n-    public LookupCarrier lookupCarrier() {\n-        return this.lookupCarrier;\n-    }\n@@ -84,2 +80,2 @@\n-    public HATDialectifyVectorOpPhase(LookupCarrier lookupCarrier, OpView vectorOperation) {\n-        this.lookupCarrier = lookupCarrier;\n+    public HATDialectifyVectorOpPhase(KernelCallGraph kernelCallGraph, OpView vectorOperation) {\n+        this.kernelCallGraph = kernelCallGraph;\n@@ -89,2 +85,0 @@\n-\n-\n@@ -109,1 +103,1 @@\n-                   && isAssignable(lookupCarrier.lookup(), jt, _V.class)\n+                   && isAssignable(lookup(), jt, _V.class)\n@@ -213,1 +207,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n@@ -264,1 +258,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n@@ -302,1 +296,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n@@ -351,1 +345,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n@@ -389,1 +383,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n+        var here = CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n@@ -450,1 +444,1 @@\n-    public static class AddPhase extends HATDialectifyVectorOpPhase {\n+    public static final class AddPhase extends HATDialectifyVectorOpPhase {\n@@ -452,2 +446,2 @@\n-        public AddPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.ADD);\n+        public AddPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.ADD);\n@@ -457,1 +451,1 @@\n-    public static class DivPhase extends HATDialectifyVectorOpPhase {\n+    public static final class DivPhase extends HATDialectifyVectorOpPhase {\n@@ -459,2 +453,2 @@\n-        public DivPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.DIV);\n+        public DivPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.DIV);\n@@ -464,1 +458,1 @@\n-    public static class MakeMutable extends HATDialectifyVectorOpPhase {\n+    public static final class MakeMutable extends HATDialectifyVectorOpPhase {\n@@ -466,2 +460,2 @@\n-        public MakeMutable(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.MAKE_MUTABLE);\n+        public MakeMutable(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.MAKE_MUTABLE);\n@@ -471,1 +465,1 @@\n-    public static class Float4LoadPhase extends HATDialectifyVectorOpPhase {\n+    public static final class Float4LoadPhase extends HATDialectifyVectorOpPhase {\n@@ -473,2 +467,2 @@\n-        public Float4LoadPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.FLOAT4_LOAD);\n+        public Float4LoadPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.FLOAT4_LOAD);\n@@ -478,1 +472,1 @@\n-    public static class Float2LoadPhase extends HATDialectifyVectorOpPhase {\n+    public static final class Float2LoadPhase extends HATDialectifyVectorOpPhase {\n@@ -480,2 +474,2 @@\n-        public Float2LoadPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.FLOAT2_LOAD);\n+        public Float2LoadPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.FLOAT2_LOAD);\n@@ -485,1 +479,1 @@\n-    public static class Float4OfPhase extends HATDialectifyVectorOpPhase {\n+    public static final class Float4OfPhase extends HATDialectifyVectorOpPhase {\n@@ -487,2 +481,2 @@\n-        public Float4OfPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.OF);\n+        public Float4OfPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.OF);\n@@ -492,1 +486,1 @@\n-    public static class MulPhase extends HATDialectifyVectorOpPhase {\n+    public static final class MulPhase extends HATDialectifyVectorOpPhase {\n@@ -494,2 +488,2 @@\n-        public MulPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.MUL);\n+        public MulPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.MUL);\n@@ -499,1 +493,1 @@\n-    public static class SubPhase extends HATDialectifyVectorOpPhase {\n+    public static final class SubPhase extends HATDialectifyVectorOpPhase {\n@@ -501,2 +495,2 @@\n-        public SubPhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, OpView.SUB);\n+        public SubPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, OpView.SUB);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":39,"deletions":45,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -38,1 +39,1 @@\n-import optkl.LookupCarrier;\n+import optkl.CallSite;\n@@ -50,1 +51,1 @@\n-public record HATDialectifyVectorSelectPhase(LookupCarrier lookupCarrier) implements HATDialect {\n+public record HATDialectifyVectorSelectPhase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n@@ -94,1 +95,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"vloadSelectPhase\");\n+        var here = CallSite.of(this.getClass(), \"vloadSelectPhase\");\n@@ -148,1 +149,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n+        var here = CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.Accelerator;\n+import hat.callgraph.KernelCallGraph;\n@@ -34,1 +34,0 @@\n-import hat.types._V;\n@@ -42,2 +41,1 @@\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -52,1 +50,1 @@\n-public abstract  class HATDialectifyVectorStorePhase implements HATDialect {\n+public abstract sealed class HATDialectifyVectorStorePhase implements HATDialectPhase {\n@@ -54,3 +52,3 @@\n-    protected final LookupCarrier lookupCarrier;\n-    @Override  public LookupCarrier lookupCarrier(){\n-        return this.lookupCarrier;\n+    protected final KernelCallGraph kernelCallGraph;\n+    @Override  public KernelCallGraph kernelCallGraph(){\n+        return this.kernelCallGraph;\n@@ -60,2 +58,2 @@\n-    public HATDialectifyVectorStorePhase(LookupCarrier lookupCarrier, StoreView vectorOperation) {\n-        this.lookupCarrier= lookupCarrier;\n+    public HATDialectifyVectorStorePhase(KernelCallGraph kernelCallGraph, StoreView vectorOperation) {\n+        this.kernelCallGraph= kernelCallGraph;\n@@ -95,1 +93,1 @@\n-        var here = OpTkl.CallSite.of(this.getClass(), \"apply\");\n+        var here = CallSite.of(this.getClass(), \"apply\");\n@@ -134,3 +132,3 @@\n-    public static class Float4StorePhase extends HATDialectifyVectorStorePhase{\n-        public Float4StorePhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, StoreView.FLOAT4_STORE);\n+    public static final class Float4StorePhase extends HATDialectifyVectorStorePhase{\n+        public Float4StorePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, StoreView.FLOAT4_STORE);\n@@ -140,3 +138,3 @@\n-    public static class Float2StorePhase extends HATDialectifyVectorStorePhase{\n-        public Float2StorePhase(LookupCarrier lookupCarrier) {\n-            super(lookupCarrier, StoreView.FLOAT2_STORE);\n+    public static final class Float2StorePhase extends HATDialectifyVectorStorePhase{\n+        public Float2StorePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph, StoreView.FLOAT2_STORE);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -68,2 +68,1 @@\n-      java.lang.invoke.MethodHandles.lookup(),\n-      Backend.FIRST  \/\/ Predicate<Backend>\n+      MethodHandles.lookup(), Backend.FIRST  \/\/ Predicate<Backend>\n","filename":"hat\/docs\/hat-03-programming-model.md","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,4 +58,1 @@\n-  var accelerator = new Accelerator(\n-      java.lang.invoke.MethodHandles.lookup(),\n-      Backend.FIRST  \/\/ Predicate<Backend>\n-  );\n+  var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n","filename":"hat\/docs\/hat-04-01-interface-mapping.md","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import java.lang.invoke.MethodHandles;\n@@ -115,1 +117,1 @@\n-        var accelerator = new Accelerator(java.lang.invoke.MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.optools.OpTk;\n@@ -39,1 +38,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -83,1 +82,1 @@\n-        var here = OpTkl.CallSite.of(DNA.class, \"main\");\n+        var here = CallSite.of(DNA.class, \"main\");\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -116,1 +116,1 @@\n-        var here = OpTkl.CallSite.of(LayoutExample.class, \"main\");\n+        var here = CallSite.of(LayoutExample.class, \"main\");\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            return null;\/\/schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST)); \/\/\/ This is crazy? why\n+            return null;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import hat.optools.OpTk;\n@@ -39,1 +38,0 @@\n-import jdk.incubator.code.analysis.SSA;\n@@ -48,1 +46,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -129,1 +127,1 @@\n-        var here = OpTkl.CallSite.of(RawLayout.class, \"main\");\n+        var here = CallSite.of(RawLayout.class, \"main\");\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.optools.OpTk;\n@@ -41,1 +40,1 @@\n-import optkl.OpTkl;\n+import optkl.CallSite;\n@@ -140,1 +139,1 @@\n-            var here = OpTkl.CallSite.of(Transform.class, \"main\");\n+            var here = CallSite.of(Transform.class, \"main\");\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-        \/\/  Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend::isJava);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+public record CallSite(Class<?> clazz, String methodName, boolean tracing) {\n+    public static CallSite of(Class<?> clazz, String methodName) {\n+        return new CallSite(clazz, methodName, Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+    }\n+\n+    public static CallSite of(Class<?> clazz) {\n+        for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {\n+            if (ste.getClassName().equals(clazz.getName())) {\n+                new CallSite(ste.getClass(), ste.getMethodName(), Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+            }\n+        }\n+        return new CallSite(clazz, \"???\", Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return clazz.toString() + \":\" + methodName;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/CallSite.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.ArrayList;\n@@ -173,0 +174,3 @@\n+   static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+      return namePredicate.test(invokeOp.invokeDescriptor().name());\n+   }\n@@ -349,3 +353,6 @@\n-record CallSite(Class<?> clazz,String methodName, boolean tracing){\n-   public static CallSite of(Class<?> clazz, String methodName) {\n-      return new CallSite(clazz,methodName, Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+   static Stream<Op> loopBodyStatements(Op.Loop op) {\n+       var list = new ArrayList<>(statements( op.loopBody().entryBlock()).toList());\n+       if (list.getLast() instanceof JavaOp.ContinueOp) {\n+           list.removeLast();\n+       }\n+       return list.stream();\n@@ -353,7 +360,21 @@\n-   public static CallSite of(Class<?> clazz) {\n-      for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {\n-         if (ste.getClassName().equals(clazz.getName())) {\n-            new CallSite(ste.getClass(),ste.getMethodName(), Boolean.getBoolean(\"TRACE_CALLSITES\"));\n-         }\n-      }\n-      return new CallSite(clazz,\"???\", Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+\n+   static  Op asStatementOpOrNull(CodeElement<?,?> ce){\n+       if (ce instanceof Op op){\n+              return (\n+                      (\n+                              (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+                               || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                               || (op instanceof StatementLikeOp)\n+                      )\n+                      && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n+                      && !(op instanceof CoreOp.YieldOp)\n+              )\n+                      ?op\n+                      :null;\n+       }else{\n+          return null;\n+       }\n+\n+   }\n+   static  boolean isStatementOp(CodeElement<?,?> ce){\n+       return Objects.nonNull(asStatementOpOrNull(ce));\n@@ -362,2 +383,2 @@\n-   @Override public  String toString(){\n-      return clazz.toString()+\":\"+methodName;\n+   static Stream<Op> statements(Block block) {\n+       return block.ops().stream().filter(OpTkl::isStatementOp);\n@@ -365,3 +386,3 @@\n-}\n-static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n-   if (callSite.tracing){\n+\n+   static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n+   if (callSite.tracing()){\n@@ -373,1 +394,1 @@\n-   if (callSite.tracing){\n+   if (callSite.tracing()){\n@@ -382,1 +403,1 @@\n-   if (callSite.tracing){\n+   if (callSite.tracing()){\n@@ -393,1 +414,1 @@\n-   if (callSite.tracing){\n+   if (callSite.tracing()){\n@@ -399,1 +420,1 @@\n-   if (callSite.tracing){\n+   if (callSite.tracing()){\n@@ -406,1 +427,1 @@\n-   if (callSite.tracing){\n+   if (callSite.tracing()){\n@@ -423,1 +444,1 @@\n-   if (callSite.tracing){\n+   if (callSite.tracing()){\n@@ -488,3 +509,1 @@\n-static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-   return namePredicate.test(invokeOp.invokeDescriptor().name());\n-}\n+\n@@ -516,1 +535,5 @@\n-\n+   static boolean isParamVar(CoreOp.VarOp varOp) {\n+      return !varOp.isUninitialized()\n+              && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+              && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n+   }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":48,"deletions":25,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.Op;\n@@ -31,1 +32,1 @@\n-       public static ParamVar of(CoreOp.VarOp varOp) {\n+    public static ParamVar of(CoreOp.VarOp varOp) {\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ParamVar.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Precedence.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-public interface VarLikeOp {\n-    String varName();\n+public interface StatementLikeOp {\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/StatementLikeOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/optkl\/src\/main\/java\/optkl\/VarLikeOp.java","status":"copied"},{"patch":"@@ -74,1 +74,1 @@\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n@@ -107,1 +107,1 @@\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n@@ -312,1 +312,1 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup());\/\/,new OpenCLBackend(\"INFO,MINIMIZE_COPIES,SHOW_COMPUTE_MODEL\"));\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup());\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -293,1 +294,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -328,1 +329,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -364,1 +365,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -399,1 +400,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -434,1 +435,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -476,1 +477,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -769,1 +770,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -804,1 +805,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -1128,1 +1129,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n@@ -1168,1 +1169,1 @@\n-        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var lookup = MethodHandles.lookup();\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                    OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}