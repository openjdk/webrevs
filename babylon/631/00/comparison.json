{"files":[{"patch":"@@ -39,1 +39,1 @@\n-    int HEADER_BYTES = 4;\n+    int ARRAY_OFFSET = 4;\n@@ -49,1 +49,1 @@\n-        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, HEADER_BYTES, length());\n+        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, length());\n@@ -58,1 +58,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, HEADER_BYTES, floats, 0, length());\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, floats, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-    int PADDING_BYTES = 12;\n-    int HEADER_BYTES = 4 + PADDING_BYTES;\n+    int ARRAY_OFFSET = 16;\n@@ -42,2 +41,2 @@\n-    Schema<F32ArrayPadded> schema = Schema.of(F32ArrayPadded.class, s32Array ->\n-            s32Array.arrayLen(\"length\").pad(12).array(\"array\"));\n+    Schema<F32ArrayPadded> schema = Schema.of(F32ArrayPadded.class, $ -> $\n+            .arrayLen(\"length\").pad(ARRAY_OFFSET-4).array(\"array\"));\n@@ -50,1 +49,1 @@\n-        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, HEADER_BYTES, length());\n+        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, length());\n@@ -59,1 +58,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, HEADER_BYTES, floats, 0, length());\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, ARRAY_OFFSET, floats, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Config;\n@@ -570,1 +571,1 @@\n-    public  record CallSite(Class<?> clazz,String methodName){\n+    public  record CallSite(Class<?> clazz,String methodName, boolean tracing){\n@@ -572,5 +573,1 @@\n-            boolean TRACE = Boolean.getBoolean(\"TRACE_CALLSITES\");\n-\n-                \/\/System.out.println(\"TRACE_CALLSITES \"+TRACE);\n-\n-            return TRACE?new CallSite(clazz,methodName):null;\n+            return new CallSite(clazz,methodName, Boolean.getBoolean(\"TRACE_CALLSITES\"));\n@@ -584,1 +581,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n@@ -590,1 +587,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n@@ -596,1 +593,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n@@ -603,1 +600,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n@@ -609,1 +606,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n@@ -616,1 +613,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n@@ -633,1 +630,1 @@\n-        if (callSite!= null){\n+        if (callSite.tracing){\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.code.Value;\n@@ -39,0 +40,5 @@\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Optional;\n@@ -55,0 +61,10 @@\n+    Stream<JavaOp.InvokeOp> invokeOpOperands(Op op){\n+        return op.operands().stream()\n+                .filter(o -> o instanceof Op.Result result\n+                        && result.op() instanceof JavaOp.InvokeOp invokeOp\n+                        && isIfaceBufferInvokeWithName(invokeOp))\n+                .map(r -> (JavaOp.InvokeOp) (((Op.Result) r).op()));\n+    }\n+\n+\n+\n@@ -57,17 +73,4 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n-        }\n-      \/\/  record BufferIfaceInvokeOpAndVarOpPair(JavaOp.InvokeOp bufferIfaceOp, CoreOp.VarOp varOp){}\n-       \/\/ List<BufferIfaceInvokeOpAndVarOpPair> bufferIfaceInvokeOpAndVarOpPairList = new ArrayList<>();\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements().filter(e -> e instanceof CoreOp.VarOp ).map(e-> (CoreOp.VarOp) e)\n-                .mapMulti((varOp, consumer) -> {\n-                                var bufferIfaceInvokeOp = varOp.operands().stream()\n-                                        .filter(o -> o instanceof Op.Result result && result.op() instanceof JavaOp.InvokeOp invokeOp && isIfaceBufferInvokeWithName(invokeOp))\n-                                        .map(r -> (JavaOp.InvokeOp) (((Op.Result) r).op()))\n-                                        .findFirst();\n-                                if (bufferIfaceInvokeOp.isPresent()) {\n-                                    consumer.accept(bufferIfaceInvokeOp.get());\n-                                    consumer.accept(varOp);\n-                                }\n-                        }\n-                );\n+        var here = OpTk.CallSite.of(PrivatePhase.class, \"apply\");\n+        before(here,funcOp);\n+        Set<CoreOp.VarOp> removeMe = new LinkedHashSet<>();\n+        Set<JavaOp.InvokeOp> mapMe = new LinkedHashSet<>();\n@@ -75,1 +78,15 @@\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        funcOp.elements()\n+                .filter(e -> e instanceof CoreOp.VarOp )\n+                .map(e-> (CoreOp.VarOp) e)\n+                .forEach(varOp->varOp\n+                        .operands()\n+                        .stream()\n+                        .filter(o -> o instanceof Op.Result result\n+                                && result.op() instanceof JavaOp.InvokeOp invokeOp\n+                                && isIfaceBufferInvokeWithName(invokeOp))\n+                        .map(r -> (JavaOp.InvokeOp) (((Op.Result) r).op()))\n+                        .findFirst().ifPresent(remove-> {\n+                            removeMe.add(varOp);\n+                            mapMe.add(remove);\n+                    })\n+                );\n@@ -77,1 +94,0 @@\n-        var here = OpTk.CallSite.of(PrivatePhase.class, \"run\");\n@@ -79,6 +95,4 @@\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node we just want the results\n-                invokeOp.result().uses().stream()\n+            if (op instanceof JavaOp.InvokeOp invokeOp && mapMe.contains(invokeOp)) {\n+                invokeOp.result()\n+                        .uses()\n+                        .stream()\n@@ -88,1 +102,1 @@\n-                            context.mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder,varOp,invokeOp)))\n+                                blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n@@ -90,3 +104,4 @@\n-            } else if (op instanceof CoreOp.VarOp varOp) {\n-                \/\/ pass value\n-                context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+            } else if (op instanceof CoreOp.VarOp varOp && removeMe.contains(varOp)) {\n+                blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n+            }else{\n+                blockBuilder.op(op);\n@@ -96,3 +111,1 @@\n-        if (accelerator.backend.config().showCompilationPhases()) {\n-            IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n-        }\n+        after(here,funcOp );\n@@ -102,0 +115,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":46,"deletions":32,"binary":false,"changes":78,"status":"modified"}]}