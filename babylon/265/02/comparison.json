{"files":[{"patch":"@@ -3158,12 +3158,17 @@\n-                Result p;\n-                boolean patternWithPrimitive = false;\n-                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n-                    patternWithPrimitive = true;\n-                    if (SHORT.equals(st) || CHAR.equals(st)) {\n-                        st = INT;\n-                    }\n-                    String s = capitalize(st.toString());\n-                    String t = capitalize(tt.toString());\n-                    String mn = \"is%sTo%sExact\".formatted(s, t);\n-                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n-                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n+                Result p; \/\/ result of the type check\n+                Op c; \/\/ op that perform conversion\n+                TypeElement s = target.type();\n+                TypeElement t = targetType;\n+                if (isNarrowingPrimitiveConv(s, t)) {\n+                    MethodRef mref = convMethodRef(s, t);\n+                    p = currentBlock.op(invoke(mref, target));\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (isWideningPrimitiveConvAndNeedsCheck(s, t)) {\n+                    MethodRef mref = convMethodRef(s, t);\n+                    p = currentBlock.op(invoke(mref, target));\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (isIdentityPrimitiveConv(s, t)) {\n+                    p = currentBlock.op(constant(BOOLEAN, true));\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (BYTE.equals(s) && CHAR.equals(t)) {\n+                    MethodRef mref = convMethodRef(s, t);\n@@ -3171,0 +3176,11 @@\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (isNarrowingRefConvFollowedByUnboxing(s, t)) {\n+                    ClassType box = ((PrimitiveType) t).box().orElseThrow();\n+                    p = currentBlock.op(CoreOp.instanceOf(box, target));\n+                    c = invoke(MethodRef.method(box, t + \"Value\", t), target);\n+                } else if (isUnboxing(s, t)) {\n+                    p = currentBlock.op(CoreOp.constant(BOOLEAN, true));\n+                    c = invoke(MethodRef.method(s, t + \"Value\", t), target);\n+                } else if (isUnboxingFollowedByPrimitiveWidening(s, t)) {\n+                    p = currentBlock.op(CoreOp.constant(BOOLEAN, true));\n+                    c = invoke(MethodRef.method(s, t + \"Value\", t), target);\n@@ -3173,0 +3189,1 @@\n+                    c = CoreOp.cast(targetType, target);\n@@ -3179,5 +3196,2 @@\n-                if (patternWithPrimitive) {\n-                    target = currentBlock.op(CoreOp.conv(targetType, target));\n-                } else {\n-                    target = currentBlock.op(CoreOp.cast(targetType, target));\n-                }\n+                target = currentBlock.op(c);\n+\n@@ -3189,0 +3203,43 @@\n+            private static boolean isUnboxingFollowedByPrimitiveWidening(TypeElement s, TypeElement t) {\n+                return s instanceof ClassType ct && ct.unbox().isPresent() && t instanceof PrimitiveType pt &&\n+                        !pt.box().orElseThrow().equals(s);\n+            }\n+\n+            private static boolean isNarrowingRefConvFollowedByUnboxing(TypeElement s, TypeElement t) {\n+                return s instanceof ClassType ct && ct.unbox().isEmpty() && t instanceof PrimitiveType;\n+            }\n+\n+            private static boolean isUnboxing(TypeElement s, TypeElement t) {\n+                return s instanceof ClassType && t instanceof PrimitiveType pt && pt.box().orElseThrow().equals(s);\n+            }\n+\n+            private static boolean isIdentityPrimitiveConv(TypeElement s, TypeElement t) {\n+                return s instanceof PrimitiveType && t instanceof PrimitiveType && Objects.equals(s, t);\n+            }\n+\n+            private static boolean isWideningPrimitiveConvAndNeedsCheck(TypeElement s, TypeElement t) {\n+                return (INT.equals(s) && FLOAT.equals(t)) ||\n+                        (LONG.equals(s) && FLOAT.equals(t)) ||\n+                        (LONG.equals(s) && DOUBLE.equals(t));\n+            }\n+            private static MethodRef convMethodRef(TypeElement s, TypeElement t) {\n+                if (BYTE.equals(s) || SHORT.equals(s) || CHAR.equals(s)) {\n+                    s = INT;\n+                }\n+                String sn = capitalize(s.toString());\n+                String tn = capitalize(t.toString());\n+                String mn = \"is%sTo%sExact\".formatted(sn, tn);\n+                JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                return MethodRef.method(exactConversionSupport, mn, BOOLEAN, s);\n+            }\n+\n+            private static boolean isNarrowingPrimitiveConv(TypeElement s, TypeElement t) { \/\/ s -> t\n+                if (!(s instanceof PrimitiveType sp) || !(t instanceof PrimitiveType tp)) {\n+                    return false;\n+                }\n+                List<PrimitiveType> l = List.of(BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE);\n+                int si = l.indexOf(s);\n+                int ti = l.indexOf(t);\n+                return ti < si || (SHORT.equals(s) && CHAR.equals(t));\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":74,"deletions":17,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.reflect.Method;\n@@ -10,0 +11,1 @@\n+import java.lang.reflect.code.op.CoreOp;\n@@ -13,0 +15,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -15,0 +18,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -163,0 +168,182 @@\n+    @CodeReflection\n+    static boolean ip(short s) {\n+        return s instanceof short _;\n+    }\n+\n+    @Test\n+    void test_ip() {\n+        FuncOp f = getFuncOp(\"ip\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Short.MAX_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wnp(byte s) {\n+        return s instanceof char _;\n+    }\n+\n+    @Test\n+    void test_wnp() {\n+        FuncOp f = getFuncOp(\"wnp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MIN_VALUE), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean b(int s) {\n+        return s instanceof Integer _;\n+    }\n+\n+    @Test\n+    void test_b() {\n+        FuncOp f = getFuncOp(\"b\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean bw(int s) {\n+        return s instanceof Number _;\n+    }\n+\n+    @Test\n+    void test_bw() {\n+        FuncOp f = getFuncOp(\"bw\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean nr_unboxing(Number n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void test_nr_unboxing() {\n+        FuncOp f = getFuncOp(\"nr_unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, 1), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, (short) 1), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing(Integer n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void test_unboxing() {\n+        FuncOp f = getFuncOp(\"unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing_wp(Integer n) {\n+        return n instanceof long _;\n+    }\n+\n+    @Test\n+    void test_unboxing_wp() {\n+        FuncOp f = getFuncOp(\"unboxing_wp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wr(String s) {\n+        return s instanceof Object _;\n+    }\n+\n+    @Test\n+    void test_wr() {\n+        FuncOp f = getFuncOp(\"wr\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, \"str\"), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean ir(Float f) {\n+        return f instanceof Float _;\n+    }\n+\n+    @Test\n+    void test_ir() {\n+        FuncOp f = getFuncOp(\"ir\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.NEGATIVE_INFINITY), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean nr(Number n) {\n+        return n instanceof Double _;\n+    }\n+\n+    @Test\n+    void test_nr() {\n+        FuncOp f = getFuncOp(\"nr\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.NEGATIVE_INFINITY), true);\n+    }\n+\n+     private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n@@ -166,1 +353,1 @@\n-        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+        return func(sourceType + \"_\" + targetType, functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":188,"deletions":1,"binary":false,"changes":189,"status":"modified"}]}