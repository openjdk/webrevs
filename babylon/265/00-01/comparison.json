{"files":[{"patch":"@@ -3177,1 +3177,11 @@\n-                } else { \/\/ boxing,\n+                } else if (isNarrowingRefConvFollowedByUnboxing(s, t)) {\n+                    ClassType box = ((PrimitiveType) t).box().orElseThrow();\n+                    p = currentBlock.op(CoreOp.instanceOf(box, target));\n+                    c = invoke(MethodRef.method(box, t + \"Value\", t), target);\n+                } else if (isUnboxing(s, t)) {\n+                    p = currentBlock.op(CoreOp.constant(BOOLEAN, true));\n+                    c = invoke(MethodRef.method(s, t + \"Value\", t), target);\n+                } else if (isUnboxingFollowedByPrimitiveWidening(s, t)) {\n+                    p = currentBlock.op(CoreOp.constant(BOOLEAN, true));\n+                    c = invoke(MethodRef.method(s, t + \"Value\", t), target);\n+                } else {\n@@ -3193,0 +3203,13 @@\n+            private static boolean isUnboxingFollowedByPrimitiveWidening(TypeElement s, TypeElement t) {\n+                return s instanceof ClassType ct && ct.unbox().isPresent() && t instanceof PrimitiveType pt &&\n+                        !pt.box().orElseThrow().equals(s);\n+            }\n+\n+            private static boolean isNarrowingRefConvFollowedByUnboxing(TypeElement s, TypeElement t) {\n+                return s instanceof ClassType ct && ct.unbox().isEmpty() && t instanceof PrimitiveType;\n+            }\n+\n+            private static boolean isUnboxing(TypeElement s, TypeElement t) {\n+                return s instanceof ClassType && t instanceof PrimitiveType pt && pt.box().orElseThrow().equals(s);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -235,0 +235,106 @@\n+    @CodeReflection\n+    static boolean nr_unboxing(Number n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void test_nr_unboxing() {\n+        FuncOp f = getFuncOp(\"nr_unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, 1), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, (short) 1), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing(Integer n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void test_unboxing() {\n+        FuncOp f = getFuncOp(\"unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing_wp(Integer n) {\n+        return n instanceof long _;\n+    }\n+\n+    @Test\n+    void test_unboxing_wp() {\n+        FuncOp f = getFuncOp(\"unboxing_wp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wr(String s) {\n+        return s instanceof Object _;\n+    }\n+\n+    @Test\n+    void test_wr() {\n+        FuncOp f = getFuncOp(\"wr\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, \"str\"), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean ir(Float f) {\n+        return f instanceof Float _;\n+    }\n+\n+    @Test\n+    void test_ir() {\n+        FuncOp f = getFuncOp(\"ir\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.NEGATIVE_INFINITY), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean nr(Number n) {\n+        return n instanceof Double _;\n+    }\n+\n+    @Test\n+    void test_nr() {\n+        FuncOp f = getFuncOp(\"nr\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.NEGATIVE_INFINITY), true);\n+    }\n+\n@@ -247,1 +353,1 @@\n-        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+        return func(sourceType + \"_\" + targetType, functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":107,"deletions":1,"binary":false,"changes":108,"status":"modified"}]}