{"files":[{"patch":"@@ -3158,12 +3158,6 @@\n-                Result p;\n-                boolean patternWithPrimitive = false;\n-                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n-                    patternWithPrimitive = true;\n-                    if (SHORT.equals(st) || CHAR.equals(st)) {\n-                        st = INT;\n-                    }\n-                    String s = capitalize(st.toString());\n-                    String t = capitalize(tt.toString());\n-                    String mn = \"is%sTo%sExact\".formatted(s, t);\n-                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n-                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n+                Result p; \/\/ result of the type check\n+                Op c; \/\/ op that perform conversion\n+                TypeElement s = target.type();\n+                TypeElement t = targetType;\n+                if (isNarrowingPrimitiveConv(s, t)) {\n+                    MethodRef mref = convMethodRef(s, t);\n@@ -3171,1 +3165,13 @@\n-                } else {\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (isWideningPrimitiveConvAndNeedsCheck(s, t)) {\n+                    MethodRef mref = convMethodRef(s, t);\n+                    p = currentBlock.op(invoke(mref, target));\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (isIdentityPrimitiveConv(s, t)) {\n+                    p = currentBlock.op(constant(BOOLEAN, true));\n+                    c = CoreOp.conv(targetType, target);\n+                } else if (BYTE.equals(s) && CHAR.equals(t)) {\n+                    MethodRef mref = convMethodRef(s, t);\n+                    p = currentBlock.op(invoke(mref, target));\n+                    c = CoreOp.conv(targetType, target);\n+                } else { \/\/ boxing,\n@@ -3173,0 +3179,1 @@\n+                    c = CoreOp.cast(targetType, target);\n@@ -3179,5 +3186,2 @@\n-                if (patternWithPrimitive) {\n-                    target = currentBlock.op(CoreOp.conv(targetType, target));\n-                } else {\n-                    target = currentBlock.op(CoreOp.cast(targetType, target));\n-                }\n+                target = currentBlock.op(c);\n+\n@@ -3189,0 +3193,53 @@\n+            private static boolean isIdentityPrimitiveConv(TypeElement s, TypeElement t) {\n+                return s instanceof PrimitiveType && t instanceof PrimitiveType && Objects.equals(s, t);\n+            }\n+\n+            private static boolean isWideningPrimitiveConvAndNeedsCheck(TypeElement s, TypeElement t) {\n+                return (INT.equals(s) && FLOAT.equals(t)) ||\n+                        (LONG.equals(s) && FLOAT.equals(t)) ||\n+                        (LONG.equals(s) && DOUBLE.equals(t));\n+            }\n+            private static MethodRef convMethodRef(TypeElement s, TypeElement t) {\n+                if (BYTE.equals(s) || SHORT.equals(s) || CHAR.equals(s)) {\n+                    s = INT;\n+                }\n+                String sn = capitalize(s.toString());\n+                String tn = capitalize(t.toString());\n+                String mn = \"is%sTo%sExact\".formatted(sn, tn);\n+                JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                return MethodRef.method(exactConversionSupport, mn, BOOLEAN, s);\n+            }\n+\n+            private static boolean isWideningPrimitiveConv(TypeElement s, TypeElement t) {\n+                if (!(s instanceof PrimitiveType sp) || !(t instanceof PrimitiveType tp)) {\n+                    return false;\n+                }\n+                List<PrimitiveType> l = List.of(BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE);\n+                if (BYTE.equals(s) && CHAR.equals(t)) {\n+                    return false;\n+                } else if (SHORT.equals(s) && CHAR.equals(t)) {\n+                    return false;\n+                }\n+                int si = l.indexOf(s);\n+                int ti = l.indexOf(t);\n+                return si < ti;\n+            }\n+\n+            private static boolean isNarrowingPrimitiveConv(TypeElement s, TypeElement t) { \/\/ s -> t\n+                if (!(s instanceof PrimitiveType sp) || !(t instanceof PrimitiveType tp)) {\n+                    return false;\n+                }\n+                List<PrimitiveType> l = List.of(BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE);\n+                int si = l.indexOf(s);\n+                int ti = l.indexOf(t);\n+                return ti < si || (SHORT.equals(s) && CHAR.equals(t));\n+            }\n+\n+            private static boolean isNarrower(PrimitiveType s, PrimitiveType t) {\n+                \/\/ byte and char ?\n+                List<PrimitiveType> l = List.of(BOOLEAN, BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE);\n+                int si = l.indexOf(s);\n+                int ti = l.indexOf(t);\n+                return si != -1 && ti != -1 && si < ti;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":75,"deletions":18,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.reflect.Method;\n@@ -10,0 +11,1 @@\n+import java.lang.reflect.code.op.CoreOp;\n@@ -13,0 +15,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -15,0 +18,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -163,0 +168,76 @@\n+    @CodeReflection\n+    static boolean ip(short s) {\n+        return s instanceof short _;\n+    }\n+\n+    @Test\n+    void test_ip() {\n+        FuncOp f = getFuncOp(\"ip\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Short.MAX_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wnp(byte s) {\n+        return s instanceof char _;\n+    }\n+\n+    @Test\n+    void test_wnp() {\n+        FuncOp f = getFuncOp(\"wnp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MIN_VALUE), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean b(int s) {\n+        return s instanceof Integer _;\n+    }\n+\n+    @Test\n+    void test_b() {\n+        FuncOp f = getFuncOp(\"b\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean bw(int s) {\n+        return s instanceof Number _;\n+    }\n+\n+    @Test\n+    void test_bw() {\n+        FuncOp f = getFuncOp(\"bw\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+     private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"}]}