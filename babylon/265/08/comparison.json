{"files":[{"patch":"@@ -3155,2 +3155,0 @@\n-                Block.Builder nextBlock = currentBlock.block();\n-\n@@ -3158,6 +3156,29 @@\n-                Result p;\n-                boolean patternWithPrimitive = false;\n-                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n-                    patternWithPrimitive = true;\n-                    if (SHORT.equals(st) || CHAR.equals(st)) {\n-                        st = INT;\n+                Op p = null; \/\/ op that perform type check\n+                Op c; \/\/ op that perform conversion\n+                TypeElement s = target.type();\n+                TypeElement t = targetType;\n+                if (t instanceof PrimitiveType pt) {\n+                    if (s instanceof ClassType cs) {\n+                        \/\/ unboxing conversions\n+                        ClassType box;\n+                        if (cs.unbox().isEmpty()) { \/\/ s not a boxed type\n+                            \/\/ e.g. Number -> int\n+                            box = pt.box().orElseThrow();\n+                            p = CoreOp.instanceOf(box, target);\n+                        } else {\n+                            \/\/ e.g. Float -> float\n+                            box = cs;\n+                        }\n+                        c = invoke(MethodRef.method(box, t + \"Value\", t), target);\n+                    } else {\n+                        \/\/ primitive to primitive conversion\n+                        PrimitiveType ps = ((PrimitiveType) s);\n+                        if (isNarrowingPrimitiveConv(ps, pt) || isWideningPrimitiveConvThatNeedCheck(ps, pt)\n+                                || isWideningAndNarrowingPrimitiveConv(ps, pt)) {\n+                            \/\/ e.g. int -> byte, narrowing\n+                            \/\/ e,g. int -> float, widening that need check\n+                            \/\/ e.g. byte -> char, widening and narrowing\n+                            MethodRef mref = convMethodRef(s, t);\n+                            p = invoke(mref, target);\n+                        }\n+                        c = CoreOp.conv(targetType, target);\n@@ -3165,6 +3186,0 @@\n-                    String s = capitalize(st.toString());\n-                    String t = capitalize(tt.toString());\n-                    String mn = \"is%sTo%sExact\".formatted(s, t);\n-                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n-                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n-                    p = currentBlock.op(invoke(mref, target));\n@@ -3172,1 +3187,3 @@\n-                    p = currentBlock.op(CoreOp.instanceOf(targetType, target));\n+                    \/\/ e.g. byte -> Byte, Number -> Double, ...\n+                    p = CoreOp.instanceOf(targetType, target);\n+                    c = CoreOp.cast(targetType, target);\n@@ -3175,1 +3192,6 @@\n-                currentBlock.op(conditionalBranch(p, nextBlock.successor(), endNoMatchBlock.successor()));\n+                if (p != null) {\n+                    \/\/ p != null, we need to perform type check at runtime\n+                    Block.Builder nextBlock = currentBlock.block();\n+                    currentBlock.op(conditionalBranch(currentBlock.op(p), nextBlock.successor(), endNoMatchBlock.successor()));\n+                    currentBlock = nextBlock;\n+                }\n@@ -3177,1 +3199,1 @@\n-                currentBlock = nextBlock;\n+                target = currentBlock.op(c);\n@@ -3179,5 +3201,0 @@\n-                if (patternWithPrimitive) {\n-                    target = currentBlock.op(CoreOp.conv(targetType, target));\n-                } else {\n-                    target = currentBlock.op(CoreOp.cast(targetType, target));\n-                }\n@@ -3189,0 +3206,35 @@\n+            private static boolean isWideningAndNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n+                return BYTE.equals(s) && CHAR.equals(t);\n+            }\n+\n+            private static boolean isWideningPrimitiveConvThatNeedCheck(PrimitiveType s, PrimitiveType t) {\n+                return (INT.equals(s) && FLOAT.equals(t))\n+                        || (LONG.equals(s) && FLOAT.equals(t))\n+                        || (LONG.equals(s) && DOUBLE.equals(t));\n+            }\n+\n+            \/\/ s -> t is narrowing if order(t) <= order(s)\n+            private final static Map<PrimitiveType, Integer> narrowingOrder = Map.of(\n+                    BYTE, 1,\n+                    SHORT, 2,\n+                    CHAR, 2,\n+                    INT, 3,\n+                    LONG, 4,\n+                    FLOAT, 5,\n+                    DOUBLE, 6\n+            );\n+            private static boolean isNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n+                return narrowingOrder.get(t) <= narrowingOrder.get(s);\n+            }\n+\n+            private static MethodRef convMethodRef(TypeElement s, TypeElement t) {\n+                if (BYTE.equals(s) || SHORT.equals(s) || CHAR.equals(s)) {\n+                    s = INT;\n+                }\n+                String sn = capitalize(s.toString());\n+                String tn = capitalize(t.toString());\n+                String mn = \"is%sTo%sExact\".formatted(sn, tn);\n+                JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                return MethodRef.method(exactConversionSupport, mn, BOOLEAN, s);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":74,"deletions":22,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.reflect.Method;\n@@ -10,0 +11,1 @@\n+import java.lang.reflect.code.op.CoreOp;\n@@ -13,0 +15,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -15,0 +18,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -44,1 +49,1 @@\n-    public static Object[][] dp() {\n+    public static Object[][] narrowingPrimitiveAndWideningPrimitiveThatNeedCheck() {\n@@ -136,2 +141,2 @@\n-    @Test(dataProvider = \"dp\")\n-    void test(JavaType sourceType, JavaType targetType, Object[] values) throws Throwable {\n+    @Test(dataProvider = \"narrowingPrimitiveAndWideningPrimitiveThatNeedCheck\")\n+    void testNarrowingPrimitiveAndWideningPrimitiveThatNeedCheck(JavaType sourceType, JavaType targetType, Object[] values) throws Throwable {\n@@ -163,0 +168,199 @@\n+    @CodeReflection\n+    static boolean identityPrimitive(short s) {\n+        return s instanceof short _;\n+    }\n+\n+    @Test\n+    void testIdentityPrimitive() {\n+        FuncOp f = getFuncOp(\"identityPrimitive\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Short.MAX_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wideningNarrowingPrimitive(byte s) {\n+        return s instanceof char _;\n+    }\n+\n+    @Test\n+    void testWideningNarrowingPrimitive() {\n+        FuncOp f = getFuncOp(\"wideningNarrowingPrimitive\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MIN_VALUE), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean boxing(int s) {\n+        return s instanceof Integer _;\n+    }\n+\n+    @Test\n+    void testBoxing() {\n+        FuncOp f = getFuncOp(\"boxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean boxingWideningReference(int s) {\n+        return s instanceof Number _;\n+    }\n+\n+    @Test\n+    void testBoxingWideningReference() {\n+        FuncOp f = getFuncOp(\"boxingWideningReference\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean narrowingReferenceUnboxing(Number n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void testNarrowingReferenceUnboxing() {\n+        FuncOp f = getFuncOp(\"narrowingReferenceUnboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, 1), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, (short) 1), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing(Integer n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void testUnboxing() {\n+        FuncOp f = getFuncOp(\"unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxingWideningPrimitive(Integer n) {\n+        return n instanceof long _;\n+    }\n+\n+    @Test\n+    void testUnboxingWideningPrimitive() {\n+        FuncOp f = getFuncOp(\"unboxingWideningPrimitive\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wideningReference(String s) {\n+        return s instanceof Object _;\n+    }\n+\n+    @Test\n+    void testWideningReference() {\n+        FuncOp f = getFuncOp(\"wideningReference\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, \"str\"), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean identityReference(Float f) {\n+        return f instanceof Float _;\n+    }\n+\n+    @Test\n+    void testIdentityReference() {\n+        FuncOp f = getFuncOp(\"identityReference\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.NEGATIVE_INFINITY), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean narrowingReference(Number n) {\n+        return n instanceof Double _;\n+    }\n+\n+    @Test\n+    void testNarrowingReference() {\n+        FuncOp f = getFuncOp(\"narrowingReference\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.NEGATIVE_INFINITY), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wideningPrimitive(int i) {\n+        return i instanceof long _;\n+    }\n+\n+    @Test\n+    void testWideningPrimitive() {\n+        FuncOp f = getFuncOp(\"wideningPrimitive\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+     private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n@@ -166,1 +370,1 @@\n-        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+        return func(sourceType + \"_\" + targetType, functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":208,"deletions":4,"binary":false,"changes":212,"status":"modified"}]}