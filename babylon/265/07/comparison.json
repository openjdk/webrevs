{"files":[{"patch":"@@ -3155,2 +3155,0 @@\n-                Block.Builder nextBlock = currentBlock.block();\n-\n@@ -3158,6 +3156,29 @@\n-                Result p;\n-                boolean patternWithPrimitive = false;\n-                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n-                    patternWithPrimitive = true;\n-                    if (SHORT.equals(st) || CHAR.equals(st)) {\n-                        st = INT;\n+                Op p = null; \/\/ op that perform type check\n+                Op c; \/\/ op that perform conversion\n+                TypeElement s = target.type();\n+                TypeElement t = targetType;\n+                if (t instanceof PrimitiveType pt) {\n+                    if (s instanceof ClassType cs) {\n+                        \/\/ unboxing conversions\n+                        ClassType box;\n+                        if (cs.unbox().isEmpty()) { \/\/ s not a boxed type\n+                            \/\/ e.g. Number -> int\n+                            box = pt.box().orElseThrow();\n+                            p = CoreOp.instanceOf(box, target);\n+                        } else {\n+                            \/\/ e.g. Float -> float\n+                            box = cs;\n+                        }\n+                        c = invoke(MethodRef.method(box, t + \"Value\", t), target);\n+                    } else {\n+                        \/\/ primitive to primitive conversion\n+                        PrimitiveType ps = ((PrimitiveType) s);\n+                        if (isNarrowingPrimitiveConv(ps, pt) || isWideningPrimitiveConvThatNeedCheck(ps, pt)\n+                                || isWideningAndNarrowingPrimitiveConv(ps, pt)) {\n+                            \/\/ e.g. int -> byte, narrowing\n+                            \/\/ e,g. int -> float, widening that need check\n+                            \/\/ e.g. byte -> char, widening and narrowing\n+                            MethodRef mref = convMethodRef(s, t);\n+                            p = invoke(mref, target);\n+                        }\n+                        c = CoreOp.conv(targetType, target);\n@@ -3165,6 +3186,0 @@\n-                    String s = capitalize(st.toString());\n-                    String t = capitalize(tt.toString());\n-                    String mn = \"is%sTo%sExact\".formatted(s, t);\n-                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n-                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n-                    p = currentBlock.op(invoke(mref, target));\n@@ -3172,1 +3187,3 @@\n-                    p = currentBlock.op(CoreOp.instanceOf(targetType, target));\n+                    \/\/ e.g. byte -> Byte, Number -> Double, ...\n+                    p = CoreOp.instanceOf(targetType, target);\n+                    c = CoreOp.cast(targetType, target);\n@@ -3175,1 +3192,6 @@\n-                currentBlock.op(conditionalBranch(p, nextBlock.successor(), endNoMatchBlock.successor()));\n+                if (p != null) {\n+                    \/\/ p != null, we need to perform type check at runtime\n+                    Block.Builder nextBlock = currentBlock.block();\n+                    currentBlock.op(conditionalBranch(currentBlock.op(p), nextBlock.successor(), endNoMatchBlock.successor()));\n+                    currentBlock = nextBlock;\n+                }\n@@ -3177,1 +3199,1 @@\n-                currentBlock = nextBlock;\n+                target = currentBlock.op(c);\n@@ -3179,5 +3201,0 @@\n-                if (patternWithPrimitive) {\n-                    target = currentBlock.op(CoreOp.conv(targetType, target));\n-                } else {\n-                    target = currentBlock.op(CoreOp.cast(targetType, target));\n-                }\n@@ -3189,0 +3206,35 @@\n+            private static boolean isWideningAndNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n+                return BYTE.equals(s) && CHAR.equals(t);\n+            }\n+\n+            private static boolean isWideningPrimitiveConvThatNeedCheck(PrimitiveType s, PrimitiveType t) {\n+                return (INT.equals(s) && FLOAT.equals(t))\n+                        || (LONG.equals(s) && FLOAT.equals(t))\n+                        || (LONG.equals(s) && DOUBLE.equals(t));\n+            }\n+\n+            \/\/ s -> t is narrowing if order(t) <= order(s)\n+            private final static Map<PrimitiveType, Integer> narrowingOrder = Map.of(\n+                    BYTE, 1,\n+                    SHORT, 2,\n+                    CHAR, 2,\n+                    INT, 3,\n+                    LONG, 4,\n+                    FLOAT, 5,\n+                    DOUBLE, 6\n+            );\n+            private static boolean isNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n+                return narrowingOrder.get(t) <= narrowingOrder.get(s);\n+            }\n+\n+            private static MethodRef convMethodRef(TypeElement s, TypeElement t) {\n+                if (BYTE.equals(s) || SHORT.equals(s) || CHAR.equals(s)) {\n+                    s = INT;\n+                }\n+                String sn = capitalize(s.toString());\n+                String tn = capitalize(t.toString());\n+                String mn = \"is%sTo%sExact\".formatted(sn, tn);\n+                JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                return MethodRef.method(exactConversionSupport, mn, BOOLEAN, s);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":74,"deletions":22,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.reflect.Method;\n@@ -10,0 +11,1 @@\n+import java.lang.reflect.code.op.CoreOp;\n@@ -13,0 +15,1 @@\n+import java.lang.runtime.CodeReflection;\n@@ -15,0 +18,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -163,0 +168,199 @@\n+    @CodeReflection\n+    static boolean ip(short s) {\n+        return s instanceof short _;\n+    }\n+\n+    @Test\n+    void test_ip() {\n+        FuncOp f = getFuncOp(\"ip\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Short.MAX_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wnp(byte s) {\n+        return s instanceof char _;\n+    }\n+\n+    @Test\n+    void test_wnp() {\n+        FuncOp f = getFuncOp(\"wnp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Byte.MIN_VALUE), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean b(int s) {\n+        return s instanceof Integer _;\n+    }\n+\n+    @Test\n+    void test_b() {\n+        FuncOp f = getFuncOp(\"b\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean bw(int s) {\n+        return s instanceof Number _;\n+    }\n+\n+    @Test\n+    void test_bw() {\n+        FuncOp f = getFuncOp(\"bw\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean nr_unboxing(Number n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void test_nr_unboxing() {\n+        FuncOp f = getFuncOp(\"nr_unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, 1), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, (short) 1), false);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing(Integer n) {\n+        return n instanceof int _;\n+    }\n+\n+    @Test\n+    void test_unboxing() {\n+        FuncOp f = getFuncOp(\"unboxing\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean unboxing_wp(Integer n) {\n+        return n instanceof long _;\n+    }\n+\n+    @Test\n+    void test_unboxing_wp() {\n+        FuncOp f = getFuncOp(\"unboxing_wp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wr(String s) {\n+        return s instanceof Object _;\n+    }\n+\n+    @Test\n+    void test_wr() {\n+        FuncOp f = getFuncOp(\"wr\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, \"str\"), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean ir(Float f) {\n+        return f instanceof Float _;\n+    }\n+\n+    @Test\n+    void test_ir() {\n+        FuncOp f = getFuncOp(\"ir\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MIN_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.NEGATIVE_INFINITY), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean nr(Number n) {\n+        return n instanceof Double _;\n+    }\n+\n+    @Test\n+    void test_nr() {\n+        FuncOp f = getFuncOp(\"nr\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Float.MAX_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), false);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.POSITIVE_INFINITY), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Double.NEGATIVE_INFINITY), true);\n+    }\n+\n+    @CodeReflection\n+    static boolean wp(int i) {\n+        return i instanceof long _;\n+    }\n+\n+    @Test\n+    void test_wp() {\n+        FuncOp f = getFuncOp(\"wp\");\n+        f.writeTo(System.out);\n+\n+        FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MAX_VALUE), true);\n+        Assert.assertEquals(Interpreter.invoke(lf, Integer.MIN_VALUE), true);\n+    }\n+\n+     private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n@@ -166,1 +370,1 @@\n-        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+        return func(sourceType + \"_\" + targetType, functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":205,"deletions":1,"binary":false,"changes":206,"status":"modified"}]}