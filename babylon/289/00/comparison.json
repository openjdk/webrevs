{"files":[{"patch":"@@ -81,2 +81,6 @@\n-    var extractOpenCL= false;\n-    var extractOpenGL= false;\n+    \/\/ You will need to set these to true for nbody, but if course you must have opencl and opengl ;)\n+    var extractOpenCL= true;   \/\/ needed for nbody\n+    var extractOpenGL= true;   \/\/ needed for nbody\n+    var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n+    var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n+\n@@ -88,1 +92,0 @@\n-             var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n@@ -112,1 +115,0 @@\n-             var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n@@ -170,1 +172,2 @@\n-          .javac($$->$$.opts(hatOpts)\n+          .javac($$->$$\n+              .opts(hatOpts)\n@@ -174,0 +177,2 @@\n+              .when(extractedOpenCLJar.exists(), _->$$.class_path(extractedOpenCLJar))\n+              .when(extractedOpenGLJar.exists(), _->$$.class_path(extractedOpenGLJar))\n@@ -181,11 +186,0 @@\n-  var hatlessNBodyDir = hatDir.dir(\"hatless-examples\/nbody\");\n-\n-  buildDir.jarFile(\"hatless-example-nbody.jar\", $->$\n-     .javac($$->$$.opts(hatOpts)\n-         .source(24)\n-         .class_path(buildDir.jarFile(\"jextracted-opencl.jar\"),buildDir.jarFile(\"jextracted-opengl.jar\"))\n-         .source_path(hatlessNBodyDir.sourceDir(\"src\/main\/java\"))\n-     )\n-     .dir_list(hatlessNBodyDir.dir(\"src\/main\/resources\"))\n- );\n-\n","filename":"hat\/bld","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"","filename":"hat\/examples\/nbody\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/.gitignore","status":"copied"},{"patch":"","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","status":"copied"},{"patch":"","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/GLWrap.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/GLWrap.java","status":"copied"},{"patch":"@@ -0,0 +1,519 @@\n+package nbody;\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandles;\n+import java.util.stream.IntStream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opengl.glut_h.GL_COLOR_BUFFER_BIT;\n+import static opengl.glut_h.GL_DEPTH_BUFFER_BIT;\n+import static opengl.glut_h.GL_QUADS;\n+import static opengl.glut_h.GL_TEXTURE_2D;\n+import static opengl.glut_h.glBegin;\n+import static opengl.glut_h.glBindTexture;\n+import static opengl.glut_h.glClear;\n+import static opengl.glut_h.glColor3f;\n+import static opengl.glut_h.glEnd;\n+import static opengl.glut_h.glLoadIdentity;\n+import static opengl.glut_h.glPopMatrix;\n+import static opengl.glut_h.glPushMatrix;\n+import static opengl.glut_h.glRotatef;\n+import static opengl.glut_h.glScalef;\n+import static opengl.glut_h.glTexCoord2f;\n+import static opengl.glut_h.glVertex3f;\n+import static opengl.glut_h.glutSwapBuffers;\n+import static opengl.glut_h_3.C_FLOAT;\n+\n+\n+public class Main {\n+    public interface Universe extends Buffer {\n+        int length();\n+\n+        interface Body extends Struct {\n+            float x();\n+\n+            float y();\n+\n+            float z();\n+\n+            float vx();\n+\n+            float vy();\n+\n+            float vz();\n+\n+            void x(float x);\n+\n+            void y(float y);\n+\n+            void z(float z);\n+\n+            void vx(float vx);\n+\n+            void vy(float vy);\n+\n+            void vz(float vz);\n+        }\n+\n+        Body body(long idx);\n+\n+        Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n+\n+                .arrayLen(\"length\").array(\"body\", array -> array\n+                        .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n+                )\n+        );\n+\n+        static Universe create(Accelerator accelerator, int length) {\n+            return schema.allocate(accelerator, length);\n+        }\n+\n+    }\n+\n+    public static class NBody extends GLWrap.GLWindow {\n+\n+        protected final static float delT = .1f;\n+\n+        protected final static float espSqr = 0.1f;\n+\n+        protected final static float mass = .5f;\n+\n+        @CodeReflection\n+        static public void nbodyKernel(KernelContext kc, Universe universe, float mass, float delT, float espSqr) {\n+            float accx = 0.0f;\n+            float accy = 0.0f;\n+            float accz = 0.0f;\n+            Universe.Body me = universe.body(kc.x);\n+\n+            for (int i = 0; i < kc.maxX; i++) {\n+                Universe.Body body = universe.body(i);\n+                float dx = body.x() - me.x();\n+                float dy = body.y() - me.y();\n+                float dz = body.z() - me.z();\n+                float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n+                float s = mass * invDist * invDist * invDist;\n+                accx = accx + (s * dx);\n+                accy = accy + (s * dy);\n+                accz = accz + (s * dz);\n+            }\n+            accx = accx * delT;\n+            accy = accy * delT;\n+            accz = accz * delT;\n+            me.x(me.x() + (me.vx() * delT + accx * .5f * delT));\n+            me.y(me.y() + (me.vy() * delT + accy * .5f * delT));\n+            me.z(me.z() + (me.vz() * delT + accz * .5f * delT));\n+            me.vx(me.vx() + accx);\n+            me.vy(me.vy() + accy);\n+            me.vz(me.vz() + accz);\n+        }\n+\n+        @CodeReflection\n+        public static void nbodyCompute(ComputeContext cc, Universe universe, float mass, float delT, float espSqr) {\n+            float cmass = mass;\n+            float cdelT = delT;\n+            float cespSqr= espSqr;\n+\n+            cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n+        }\n+\n+\n+        private static int STRIDE = 4;\n+        private static int Xidx = 0;\n+        private static int Yidx = 1;\n+        private static int Zidx = 2;\n+\n+        final float[] xyzPos;\n+        final float[] xyzVel;\n+\n+        final GLWrap.GLTexture particle;\n+        final MemorySegment xyzPosSeg;\n+        final MemorySegment xyzVelSeg;\n+        final Universe universe;\n+        final Accelerator accelerator;\n+        final CLWrap.Platform.Device.Context.Program.Kernel kernel;\n+\n+        int count;\n+        int frames = 0;\n+        long startTime = 0l;\n+\n+        public enum Mode {\n+            HAT(),\n+            OpenCL(\"\"\"\n+                    __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n+                        int body = get_global_id(0);\n+                        int STRIDE=4;\n+                        int Xidx=0;\n+                        int Yidx=1;\n+                        int Zidx=2;\n+                        int bodyStride = body*STRIDE;\n+                        int bodyStrideX = bodyStride+Xidx;\n+                        int bodyStrideY = bodyStride+Yidx;\n+                        int bodyStrideZ = bodyStride+Zidx;\n+\n+                        float accx = 0.0;\n+                        float accy = 0.0;\n+                        float accz = 0.0;\n+                        float myPosx = xyzPos[bodyStrideX];\n+                        float myPosy = xyzPos[bodyStrideY];\n+                        float myPosz = xyzPos[bodyStrideZ];\n+                        for (int i = 0; i < get_global_size(0); i++) {\n+                            int iStride = i*STRIDE;\n+                            float dx = xyzPos[iStride+Xidx] - myPosx;\n+                            float dy = xyzPos[iStride+Yidx] - myPosy;\n+                            float dz = xyzPos[iStride+Zidx] - myPosz;\n+                            float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n+                            float s = mass * invDist * invDist * invDist;\n+                            accx = accx + (s * dx);\n+                            accy = accy + (s * dy);\n+                            accz = accz + (s * dz);\n+                        }\n+                        accx = accx * delT;\n+                        accy = accy * delT;\n+                        accz = accz * delT;\n+                        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n+                        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n+                        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n+\n+                        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n+                        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n+                        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+\n+                    }\n+                    \"\"\"),\n+            OpenCL4(\"\"\"\n+                    __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                        float4 acc = (0.0,0.0,0.0,0.0);\n+                        float4 myPos = xyzPos[get_global_id(0)];\n+                        float4 myVel = xyzVel[get_global_id(0)];\n+                        for (int i = 0; i < get_global_size(0); i++) {\n+                               float4 delta =  xyzPos[i] - myPos;\n+                               float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                               float s = mass * invDist * invDist * invDist;\n+                               acc= acc + (s * delta);\n+                        }\n+                        acc = acc*delT;\n+                        myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                        myVel = myVel + acc;\n+                        xyzPos[get_global_id(0)] = myPos;\n+                        xyzVel[get_global_id(0)] = myVel;\n+\n+                    }\n+                    \"\"\"),\n+            JavaSeq(false),\n+            JavaMT(true);\n+            final public boolean hat;\n+            final public String code;\n+            final public boolean isOpenCL;\n+            final public boolean isJava;\n+            final public boolean isMultiThreaded;\n+\n+            Mode() {\n+                this.hat = true;\n+                this.code = null;\n+                this.isOpenCL = false;\n+                this.isJava = false;\n+                this.isMultiThreaded = false;\n+            }\n+\n+            Mode(String code) {\n+                this.hat = true;\n+                this.code = code;\n+                this.isOpenCL = true;\n+                this.isJava = false;\n+                this.isMultiThreaded = false;\n+            }\n+\n+            Mode(boolean isMultiThreaded) {\n+                this.hat = true;\n+                this.code = null;\n+                this.isOpenCL = false;\n+                this.isJava = true;\n+                this.isMultiThreaded = isMultiThreaded;\n+            }\n+\n+            public static Mode of(String name, Mode defaultMode) {\n+                return switch (name) {\n+                    case \"HAT\" -> NBody.Mode.HAT;\n+                    case \"OpenCL\" -> NBody.Mode.OpenCL;\n+                    case \"JavaSeq\" -> NBody.Mode.JavaSeq;\n+                    case \"JavaMT\" -> NBody.Mode.JavaMT;\n+                    case \"OpenCL4\" -> NBody.Mode.OpenCL4;\n+                    default -> defaultMode;\n+                };\n+            }\n+        }\n+\n+        final Mode mode;\n+\n+        public NBody(Arena arena, int width, int height, GLWrap.GLTexture particle, int count, Mode mode) {\n+            super(arena, width, height, \"nbody\", particle);\n+            this.particle = particle;\n+            this.count = count;\n+            this.xyzPos = new float[count * STRIDE];\n+            this.xyzVel = new float[count * STRIDE];\n+            this.mode = mode;\n+            final float maxDist = 80f;\n+\n+            System.out.println(count + \" particles\");\n+\n+            switch (mode) {\n+                case OpenCL, OpenCL4, JavaMT, JavaSeq -> {\n+                    for (int body = 0; body < count; body++) {\n+                        final float theta = (float) (Math.random() * Math.PI * 2);\n+                        final float phi = (float) (Math.random() * Math.PI * 2);\n+                        final float radius = (float) (Math.random() * maxDist);\n+\n+                        \/\/ get random 3D coordinates in sphere\n+                        xyzPos[(body * STRIDE) + Xidx] = (float) (radius * Math.cos(theta) * Math.sin(phi));\n+                        xyzPos[(body * STRIDE) + Yidx] = (float) (radius * Math.sin(theta) * Math.sin(phi));\n+                        xyzPos[(body * STRIDE) + Zidx] = (float) (radius * Math.cos(phi));\n+                    }\n+                }\n+                default -> {\n+                }\n+\n+            }\n+            switch (mode){\n+                case OpenCL,OpenCL4->{\n+                    xyzPosSeg = arena.allocateFrom(JAVA_FLOAT, xyzPos);\n+                    xyzVelSeg = arena.allocateFrom(JAVA_FLOAT, xyzVel);\n+                    CLWrap openCL = new CLWrap(arena);\n+\n+                    CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n+                    openCL.platforms.forEach(platform -> {\n+                        System.out.println(\"Platform Name \" + platform.platformName());\n+                        platform.devices.forEach(device -> {\n+                            System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                            System.out.println(\"   Device Name       \" + device.deviceName());\n+                            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+                            selectedDevice[0] = device;\n+                        });\n+                    });\n+                    var context = selectedDevice[0].createContext();\n+                    var program = context.buildProgram(mode.code);\n+                    kernel = program.getKernel(\"nbody\");\n+                    accelerator = null;\n+                    universe = null;\n+                }\n+                case JavaMT,JavaSeq->{\n+                    kernel = null;\n+                    xyzPosSeg = null;\n+                    xyzVelSeg = null;\n+                    accelerator = null;\n+                    universe = null;\n+                }\n+                case HAT->{\n+                    kernel = null;\n+                    xyzPosSeg = null;\n+                    xyzVelSeg = null;\n+                    accelerator = new Accelerator(MethodHandles.lookup(),\n+                            Backend.FIRST\n+                    );\n+                    universe = Universe.create(accelerator, count);\n+                    for (int body = 0; body < count; body++) {\n+                        Universe.Body b = universe.body(body);\n+                        final float theta = (float) (Math.random() * Math.PI * 2);\n+                        final float phi = (float) (Math.random() * Math.PI * 2);\n+                        final float radius = (float) (Math.random() * maxDist);\n+\n+                        \/\/ get random 3D coordinates in sphere\n+                        b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n+                        b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n+                        b.z((float) (radius * Math.cos(phi)));\n+                    }\n+                }\n+                default -> {\n+                    kernel = null;\n+                    xyzPosSeg = null;\n+                    xyzVelSeg = null;\n+                    accelerator = null;\n+                    universe = null;\n+                }\n+            }\n+        }\n+\n+\n+        float rot = 0f;\n+\n+        public static void run(int body, int size, float[] xyzPos, float[] xyzVel, float mass, float delT, float espSqr) {\n+            float accx = 0.f;\n+            float accy = 0.f;\n+            float accz = 0.f;\n+            int bodyStride = body * STRIDE;\n+            int bodyStrideX = bodyStride + Xidx;\n+            int bodyStrideY = bodyStride + Yidx;\n+            int bodyStrideZ = bodyStride + Zidx;\n+\n+            final float myPosx = xyzPos[bodyStrideX];\n+            final float myPosy = xyzPos[bodyStrideY];\n+            final float myPosz = xyzPos[bodyStrideZ];\n+\n+            for (int i = 0; i < size; i++) {\n+                int iStride = i * STRIDE;\n+                int iStrideX = iStride + Xidx;\n+                int iStrideY = iStride + Yidx;\n+                int iStrideZ = iStride + Zidx;\n+                final float dx = xyzPos[iStrideX] - myPosx;\n+                final float dy = xyzPos[iStrideY] - myPosy;\n+                final float dz = xyzPos[iStrideZ] - myPosz;\n+                final float invDist = 1 \/ (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz) + espSqr);\n+                final float s = mass * invDist * invDist * invDist;\n+                accx = accx + (s * dx);\n+                accy = accy + (s * dy);\n+                accz = accz + (s * dz);\n+            }\n+            accx = accx * delT;\n+            accy = accy * delT;\n+            accz = accz * delT;\n+            xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * .5f * delT);\n+            xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * .5f * delT);\n+            xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * .5f * delT);\n+\n+            xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n+            xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n+            xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+        }\n+\n+        void display() {\n+            if (startTime == 0) {\n+                startTime = System.currentTimeMillis();\n+            }\n+            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+            glPushMatrix();\n+            glLoadIdentity();\n+            glRotatef(-rot \/ 2f, 0f, 0f, 1f);\n+            \/\/glRotatef(rot, 0f, 1f, 0f);\n+            \/\/   glTranslatef(0f, 0f, trans);\n+            glScalef(.01f, .01f, .01f);\n+            glColor3f(1f, 1f, 1f);\n+\n+            switch (mode){\n+                case JavaMT,JavaSeq ->{\n+                    if (mode.isMultiThreaded) {\n+                        IntStream.range(0, count).parallel().forEach(\n+                                i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n+                        );\n+                    } else {\n+                        IntStream.range(0, count).forEach(\n+                                i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n+                        );\n+                    }\n+                }\n+                case OpenCL,OpenCL4->{\n+                    kernel.run(count, xyzPosSeg, xyzVelSeg, mass, delT, espSqr);\n+                }\n+                case HAT->{\n+                    float cmass = mass;\n+                    float cdelT = delT;\n+                    float cespSqr = espSqr;\n+                    Universe cuniverse = universe;\n+                    accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n+                }\n+            }\n+\n+            glBegin(GL_QUADS());\n+            {\n+                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, particle.idx * JAVA_INT.byteSize()));\n+                float dx = -.5f;\n+                float dy = -.5f;\n+                float dz = -.5f;\n+\n+                for (int i = 0; i < count; i++) {\n+                    float x=0,y=0,z=0;\n+                    switch (mode){\n+                        case OpenCL4 ,OpenCL -> {\n+                            x = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Xidx * C_FLOAT.byteSize()));\n+                            y = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Yidx * C_FLOAT.byteSize()));\n+                            z = xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Zidx * C_FLOAT.byteSize()));\n+                        }\n+                        case JavaMT, JavaSeq -> {\n+                            x = xyzPos[(i * STRIDE) + Xidx];\n+                            y = xyzPos[(i * STRIDE) + Yidx];\n+                            z = xyzPos[(i * STRIDE) + Zidx];\n+                        }\n+                        case HAT ->{\n+                            Universe.Body body = universe.body(i);\n+                            x=body.x();\n+                            y=body.y();\n+                            z=body.z();\n+                        }\n+                    }\n+                    final int LEFT = 0;\n+                    final int RIGHT = 1;\n+                    final int TOP = 0;\n+                    final int BOTTOM = 1;\n+                    glTexCoord2f(LEFT, BOTTOM);\n+                    glVertex3f(x + dx + LEFT, y + dy + BOTTOM, z + dz);\n+                    glTexCoord2f(LEFT, TOP);\n+                    glVertex3f(x + dx + LEFT, y + dy + TOP, z + dz);\n+                    glTexCoord2f(RIGHT, TOP);\n+                    glVertex3f(x + dx + RIGHT, y + dy + TOP, z + dz);\n+                    glTexCoord2f(RIGHT, BOTTOM);\n+                    glVertex3f(x + dx + RIGHT, y + dy + BOTTOM, z + dz);\n+                }\n+            }\n+            glEnd();\n+            glColor3f(0.8f, 0.1f, 0.1f);\n+            glPopMatrix();\n+            glutSwapBuffers();\n+            frames++;\n+            long elapsed = System.currentTimeMillis() - startTime;\n+            if (elapsed > 200 || (frames % 100) == 0) {\n+                float secs = elapsed \/ 1000f;\n+              \/\/  System.out.println((frames \/ secs) + \"fps\");\n+            }\n+        }\n+\n+        void onIdle() {\n+            rot += 1f;\n+            super.onIdle();\n+        }\n+    }\n+\n+    public void main(String[] args) {\n+        int particleCount =  32768;\n+        NBody.Mode mode = NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n+        System.out.println(\"mode\" + mode);\n+        try (var arena = Arena.ofConfined()) {\n+            var particleTexture = new GLWrap.GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n+            new NBody(arena, 1000, 1000, particleTexture, particleCount, mode).mainLoop();\n+        }\n+    }\n+}\n+\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":519,"deletions":0,"binary":false,"changes":519,"status":"added"},{"patch":"","filename":"hat\/examples\/nbody\/src\/main\/resources\/particle.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hatless-examples\/nbody\/src\/main\/resources\/particle.png","status":"copied"},{"patch":"@@ -50,0 +50,4 @@\n+  var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n+  var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n+\n+\n@@ -71,0 +75,4 @@\n+    javaBuilder.when( exampleName.equals(\"nbody\"), $->$\n+       .start_on_first_thread()\n+       .class_path(buildDir.jarFile(\"hat-1.0.jar\"), extractedOpenGLJar, extractedOpenCLJar)\n+    );\n","filename":"hat\/hatrun","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/nbody.iml\" filepath=\"$PROJECT_DIR$\/nbody.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-     .modules(modules -> examples.subDirs().filter(dir -> !dir.matches(\"^.*(experiments|target|.idea)$\")).forEach(example -> {\n+     .modules(modules -> examples.subDirs().filter(dir -> !dir.matches(\"^.*(experiments|nbody|target|.idea)$\")).forEach(example -> {\n","filename":"hat\/mkpoms","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-               && !textFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n+               && !textFile.grep(Pattern.compile(\"^.*Copyright.*202[0-9].*(Intel|Oracle).*$\"))) {\n","filename":"hat\/sanity","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}