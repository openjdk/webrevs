{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator;\n@@ -59,2 +60,2 @@\n-        static MockConfig create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, boolean gpu) {\n-            MockConfig config =schema.allocate(lookup,bufferAllocator);\n+        static MockConfig create(Accelerator accelerator, boolean gpu) {\n+            MockConfig config =schema.allocate(accelerator);\n@@ -70,1 +71,1 @@\n-        getBackend(MockConfig.create(MethodHandles.lookup(),this,  true));\n+        getBackend(null);\/\/MockConfig.create(MethodHandles.lookup(),this,  true));\n","filename":"hat\/backends\/mock\/src\/main\/java\/hat\/backend\/MockBackend.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator;\n@@ -59,2 +60,2 @@\n-        static OpenCLConfig create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, boolean gpu, boolean verbose) {\n-            OpenCLConfig config =schema.allocate(lookup,bufferAllocator);\n+        static OpenCLConfig create(Accelerator accelerator, boolean gpu, boolean verbose) {\n+            OpenCLConfig config =schema.allocate(accelerator);\n@@ -71,1 +72,1 @@\n-        getBackend(OpenCLConfig.create( MethodHandles.lookup(),this, true, true));\n+        getBackend(null);\/\/OpenCLConfig.create( MethodHandles.lookup(),this, true, true));\n","filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLBackend.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import hat.Accelerator;\n@@ -17,0 +18,1 @@\n+import hat.backend.DebugBackend;\n@@ -42,8 +44,4 @@\n-        BufferAllocator bufferAllocator = new BufferAllocator() {\n-            @Override\n-            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n-                return segmentMapper.allocate(Arena.global(),boundSchema);\n-            }\n-        };\n-\n-        PointyHat.ColoredWeightedPoint p = PointyHat.ColoredWeightedPoint.schema.allocate(MethodHandles.lookup(),bufferAllocator);\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend());\n+\n+        PointyHat.ColoredWeightedPoint p = PointyHat.ColoredWeightedPoint.schema.allocate(accelerator);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-        static  MeshData create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator) {\n-            return schema.allocate(lookup,bufferAllocator,100,10);\n+        static  MeshData create(Accelerator accelerator) {\n+            return schema.allocate(accelerator,100,10);\n@@ -146,1 +146,1 @@\n-        var meshDataOld = MeshData.create(accelerator.lookup,accelerator);\n+        var meshDataOld = MeshData.create(accelerator);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-        static ColoredWeightedPoint create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator) {\n-            return schema.allocate(lookup,bufferAllocator);\n+        static ColoredWeightedPoint create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n@@ -119,1 +119,1 @@\n-        var coloredWeightedPoint = ColoredWeightedPoint.create(MethodHandles.lookup(),accelerator);\n+        var coloredWeightedPoint = ColoredWeightedPoint.create(accelerator);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        static PointArray create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int len) {\n+        static PointArray create(Accelerator accelerator, int len) {\n@@ -67,1 +67,1 @@\n-            PointArray pointArray= schema.allocate(lookup,bufferAllocator,100);\n+            PointArray pointArray= schema.allocate(accelerator,100);\n@@ -122,1 +122,1 @@\n-        var pointArray = PointArray.create(accelerator.lookup,accelerator,100);\n+        var pointArray = PointArray.create(accelerator,100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.Accelerator;\n+import hat.backend.DebugBackend;\n@@ -39,7 +41,4 @@\n-        BufferAllocator bufferAllocator = new BufferAllocator() {\n-            @Override\n-            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n-                return segmentMapper.allocate(Arena.global(),boundSchema);\n-            }\n-        };\n-        var rgbS08x3Image = S08x3RGBImage.create(MethodHandles.lookup(), bufferAllocator,100,100);\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend());\n+\n+        var rgbS08x3Image = S08x3RGBImage.create(accelerator,100,100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S08x3ImageTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.Accelerator;\n+import hat.backend.DebugBackend;\n@@ -39,7 +41,3 @@\n-        BufferAllocator bufferAllocator = new BufferAllocator() {\n-            @Override\n-            public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n-                return segmentMapper.allocate(Arena.global(),boundSchema);\n-            }\n-        };\n-        hat.buffer.S32Array s32Array  = hat.buffer.S32Array.create(MethodHandles.lookup(),bufferAllocator, 100);\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend());\n+\n+        hat.buffer.S32Array s32Array  = hat.buffer.S32Array.create(accelerator, 100);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator;\n@@ -53,2 +54,2 @@\n-    final MethodHandles.Lookup lookup;\n-    final BufferedImage image;\n+   final Accelerator accelerator;\n+     final BufferedImage image;\n@@ -69,1 +70,1 @@\n-        public IntegralWindow(Container container, MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, F32Array2D integralImageF32, F32Array2D integralSqImageF32) {\n+        public IntegralWindow(Container container, Accelerator accelerator, F32Array2D integralImageF32, F32Array2D integralSqImageF32) {\n@@ -78,2 +79,2 @@\n-                this.integralImageU16 = U16GreyImage.create(lookup,bufferAllocator,integral.getWidth(),integral.getHeight());\n-                this.integralSqImageU16 = U16GreyImage.create(lookup,bufferAllocator, integral.getWidth(),integral.getHeight());\n+                this.integralImageU16 = U16GreyImage.create(accelerator,integral.getWidth(),integral.getHeight());\n+                this.integralSqImageU16 = U16GreyImage.create(accelerator, integral.getWidth(),integral.getHeight());\n@@ -174,2 +175,1 @@\n-    public HaarViewer(MethodHandles.Lookup lookup,\n-                      BufferAllocator bufferAllocator,\n+    public HaarViewer(Accelerator accelerator,\n@@ -183,1 +183,1 @@\n-        this.lookup = lookup;\n+        this.accelerator = accelerator;\n@@ -252,1 +252,1 @@\n-        this.integralWindow = new IntegralWindow(this,lookup, bufferAllocator, integralImageF32, integralSqImageF32);\n+        this.integralWindow = new IntegralWindow(this,accelerator, integralImageF32, integralSqImageF32);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/HaarViewer.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            harViz = new HaarViewer(accelerator.lookup,accelerator, nasa1996, rgbImage, cascade, null, null);\n+            harViz = new HaarViewer(accelerator, nasa1996, rgbImage, cascade, null, null);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCompute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        HaarViewer harViz = new HaarViewer(accelerator.lookup, accelerator, nasa, rgbImage, cascade, integralImageF32, integralSqImageF32);\n+        HaarViewer harViz = new HaarViewer(accelerator, nasa, rgbImage, cascade, integralImageF32, integralSqImageF32);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-    static Cascade create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height,\n+    static Cascade create(Accelerator accelerator, int width, int height,\n@@ -178,2 +178,1 @@\n-        var instance  = schema.allocate(lookup,\n-                bufferAllocator,\n+        var instance  = schema.allocate(accelerator,\n@@ -192,4 +191,0 @@\n-    static Cascade create(Accelerator accelerator, int width, int height,\n-                          int features, int stages, int trees){\n-       return create(accelerator.lookup,accelerator,width,height,features,stages,trees);\n-    }\n@@ -198,1 +193,1 @@\n-        return create(accelerator.lookup,accelerator,cascade.width(),cascade.height(),cascade.featureCount(),cascade.stageCount(),cascade.treeCount()).copyFrom(cascade);\n+        return create(accelerator,cascade.width(),cascade.height(),cascade.featureCount(),cascade.stageCount(),cascade.treeCount()).copyFrom(cascade);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-    static ResultTable create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator,int length){\n-        var instance = schema.allocate(lookup,bufferAllocator,length);\n+    static ResultTable create(Accelerator accelerator,int length){\n+        var instance = schema.allocate(accelerator,length);\n@@ -82,3 +82,0 @@\n-    static ResultTable create(Accelerator accelerator, int length){\n-       return create(accelerator.lookup, accelerator,length);\n-    }\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -178,2 +178,2 @@\n-    static ScaleTable create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int length){\n-        var instance = schema.allocate(lookup,bufferAllocator,length);\n+    static ScaleTable create(Accelerator accelerator, int length){\n+        var instance = schema.allocate(accelerator,length);\n@@ -184,4 +184,0 @@\n-    static ScaleTable create(Accelerator accelerator, int length){\n-        return create(accelerator.lookup, accelerator,length);\n-    }\n-\n@@ -189,1 +185,1 @@\n-        return create(accelerator.lookup, accelerator,constraints.scales).applyConstraints(constraints);\n+        return create(accelerator,constraints.scales).applyConstraints(constraints);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator.lookup, c99NativeBackend, 0, 0);\n+            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n@@ -63,1 +63,1 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator.lookup, kernelCallGraph.computeContext.accelerator, ndRangeAndArgs);\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, ndRangeAndArgs);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -22,0 +22,5 @@\n+\n+    public DebugBackend(){\n+       this(HowToRunCompute.REFLECT, HowToRunKernel.REFLECT);\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Accelerator;\n@@ -267,1 +268,1 @@\n-    static ArgArray create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, Object... args) {\n+    static ArgArray create(Accelerator accelerator, Object... args) {\n@@ -291,1 +292,1 @@\n-        ArgArray argArray = schema.allocate(lookup,bufferAllocator,args.length,schemaStr.length() + 1);\n+        ArgArray argArray = schema.allocate(accelerator,args.length,schemaStr.length() + 1);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-    static F32Array create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int length){\n-        var instance = schema.allocate(lookup,bufferAllocator, length);\n+    static F32Array create(Accelerator accelerator, int length){\n+        var instance = schema.allocate(accelerator, length);\n@@ -55,3 +55,0 @@\n-    static F32Array create(Accelerator accelerator, int length){\n-        return create(accelerator.lookup, accelerator, length);\n-    }\n@@ -63,1 +60,1 @@\n-        return create(accelerator.lookup, accelerator, arr.length).copyFrom(arr);\n+        return create( accelerator, arr.length).copyFrom(arr);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    static F32Array2D create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n-        var instance = schema.allocate(lookup,bufferAllocator, width,height);\n+    static F32Array2D create(Accelerator accelerator, int width, int height){\n+        var instance = schema.allocate(accelerator, width,height);\n@@ -66,3 +66,0 @@\n-    static F32Array2D create(Accelerator accelerator,  int width, int height){\n-        return create(accelerator.lookup, accelerator, width,height);\n-    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import hat.Accelerator;\n@@ -18,2 +19,2 @@\n-    static KernelContext create(MethodHandles.Lookup lookup,BufferAllocator bufferAllocator, int x, int maxX) {\n-        KernelContext kernelContext =  schema.allocate(lookup,bufferAllocator);\n+    static KernelContext create(Accelerator accelerator, int x, int maxX) {\n+        KernelContext kernelContext =  schema.allocate(accelerator);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -19,2 +19,2 @@\n-    static S08x3RGBImage create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n-        var instance = schema.allocate(lookup, bufferAllocator,width,height);\n+    static S08x3RGBImage create(Accelerator accelerator, int width, int height){\n+        var instance = schema.allocate(accelerator,width,height);\n@@ -25,4 +25,0 @@\n-    static S08x3RGBImage create(Accelerator accelerator, int width, int height){\n-        return create(accelerator.lookup,accelerator,width,height);\n-    }\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    static S32Array create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int length){\n-        var instance = schema.allocate(lookup,bufferAllocator, length);\n+    static S32Array create(Accelerator accelerator, int length){\n+        var instance = schema.allocate(accelerator, length);\n@@ -51,3 +51,0 @@\n-    static S32Array create(Accelerator accelerator, int length){\n-        return create(accelerator.lookup, accelerator, length);\n-    }\n@@ -55,1 +52,1 @@\n-        return create(accelerator.lookup, accelerator, arr.length).copyfrom(arr);\n+        return create( accelerator, arr.length).copyfrom(arr);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-    static S32Array2D create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n-        var instance = schema.allocate(lookup,bufferAllocator, width,height);\n+    static S32Array2D create(Accelerator accelerator, int width, int height){\n+        var instance = schema.allocate(accelerator, width,height);\n@@ -63,3 +63,0 @@\n-    static S32Array2D create(Accelerator accelerator,  int width, int height){\n-        return create(accelerator.lookup, accelerator, width,height);\n-    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Accelerator;\n@@ -45,2 +46,2 @@\n-    static S32RGBAImage create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n-        var instance = schema.allocate(lookup, bufferAllocator,width,height);\n+    static S32RGBAImage create(Accelerator accelerator, int width, int height){\n+        var instance = schema.allocate(accelerator,width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Accelerator;\n@@ -43,2 +44,2 @@\n-    static U16GreyImage create(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int width, int height){\n-        var instance = schema.allocate(lookup, bufferAllocator,width,height);\n+    static U16GreyImage create(Accelerator accelerator, int width, int height){\n+        var instance = schema.allocate(accelerator,width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -12,0 +13,1 @@\n+\n@@ -19,0 +21,1 @@\n+\n@@ -51,1 +54,1 @@\n-        this.groupLayout = schema.rootIfaceType.getBoundGroupLayout(rootBoundSchemaNode);\n+        this.groupLayout = rootBoundSchemaNode.getBoundGroupLayout(schema.rootIfaceType);\n@@ -137,0 +140,55 @@\n+\n+        private GroupLayout getBoundGroupLayout(Schema.IfaceType ifaceType) {\n+            BoundSchema.BoundSchemaNode<?> child = createChild(ifaceType);\n+            ifaceType.fields.forEach(fieldNode ->\n+                child.bind(fieldNode,(switch (fieldNode) {\n+                            case Schema.SchemaNode.Padding field ->\n+                                    MemoryLayout.paddingLayout(field.len);\n+                            case Schema.FieldNode.AddressField field ->\n+                                    ValueLayout.ADDRESS;\n+                            case Schema.FieldNode.ArrayLen field ->\n+                                    MapperUtil.primitiveToLayout(field.type);\n+                            case Schema.FieldNode.AtomicField field ->\n+                                    MapperUtil.primitiveToLayout(field.type);\n+                            case Schema.FieldNode.IfaceField field ->\n+                                    child.getBoundGroupLayout(field.parent.getChild(field.ifaceType.iface));\n+                            case Schema.FieldNode.PrimitiveField field ->\n+                                    MapperUtil.primitiveToLayout(field.type);\n+                            case Schema.FieldNode.IfaceFixedArray field -> {\n+                                var elementLayout = child.getBoundGroupLayout(field.parent.getChild(field.ifaceType.iface))\n+                                        .withName(field.ifaceType.iface.getSimpleName());\n+                                yield MemoryLayout.sequenceLayout(field.len,elementLayout);\n+                            }\n+                            case Schema.FieldNode.PrimitiveFixedArray field -> {\n+                                var elementLayout = MapperUtil.primitiveToLayout(field.type)\n+                                        .withName(field.type.getSimpleName());\n+                                yield MemoryLayout.sequenceLayout(field.len, elementLayout);\n+                            }\n+                            case Schema.FieldNode.IfaceFieldControlledArray field -> {\n+                                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                                int size = field.stride; \/\/usually 1 but developer can define.\n+                                for (int i = 0; i < field.contributingDims; i++) {\n+                                    size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                                }\n+                                var elementLayout = child.getBoundGroupLayout(field.parent.getChild(field.ifaceType.iface))\n+\n+                                        .withName(field.ifaceType.iface.getSimpleName());\n+                                yield MemoryLayout.sequenceLayout(size,elementLayout);\n+                            }\n+                            case Schema.FieldNode.PrimitiveFieldControlledArray field -> {\n+                                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                                int size = field.stride; \/\/usually 1 but developer can define.\n+                                for (int i = 0; i < field.contributingDims; i++) {\n+                                    size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n+                                }\n+                                var elementLayout = MapperUtil.primitiveToLayout(field.type)\n+                                        .withName(field.type.getSimpleName());\n+                                yield MemoryLayout.sequenceLayout(size,elementLayout);\n+                            }\n+                        }).withName(fieldNode.name))\n+            );\n+            return (MapperUtil.isUnion(ifaceType.iface)\n+                    ? MemoryLayout.unionLayout(child.memoryLayoutListToArray())\n+                    : MemoryLayout.structLayout(child.memoryLayoutListToArray())).withName(ifaceType.iface.getSimpleName());\n+        }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+import hat.Accelerator;\n@@ -4,1 +5,0 @@\n-import hat.buffer.BufferAllocator;\n@@ -12,1 +12,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -26,1 +25,0 @@\n-\n@@ -44,2 +42,1 @@\n-\n-    public T allocate(MethodHandles.Lookup lookup, BufferAllocator bufferAllocator, int... boundLengths) {\n+    public T allocate(Accelerator accelerator,  int... boundLengths) {\n@@ -47,1 +44,1 @@\n-        return (T) boundSchema.allocate(lookup, bufferAllocator);\n+        return (T) boundSchema.allocate(accelerator.lookup, accelerator);\n@@ -99,73 +96,0 @@\n-        public GroupLayout getBoundGroupLayout(BoundSchema.BoundSchemaNode parentBoundSchemaNode) {\n-\n-            BoundSchema.BoundSchemaNode<?> child = parentBoundSchemaNode.createChild(this);\n-            this.fields.forEach(fieldNode -> {\n-                        if (fieldNode instanceof SchemaNode.Padding field) {\n-                            child.bind(field, MemoryLayout.paddingLayout(field.len));\n-                        } else if (fieldNode instanceof FieldNode.AddressField field) {\n-                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.ArrayLen field) {\n-                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.AtomicField field) {\n-                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.IfaceField field) {\n-                            child.bind(field, field.parent.getBoundLayout(field.ifaceType.iface, child).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.PrimitiveField field) {\n-                            child.bind(field, field.parent.getBoundLayout(field.type, child).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.IfaceFixedArray field) {\n-                            child.bind(field, MemoryLayout.sequenceLayout(field.len,\n-                                    field.parent.getBoundLayout(field.ifaceType.iface, child).withName(field.ifaceType.iface.getSimpleName())\n-                            ).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.PrimitiveFixedArray field) {\n-                            child.bind(field, MemoryLayout.sequenceLayout(field.len,\n-                                    field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n-                            ).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.IfaceFieldControlledArray field) {\n-                            \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n-                            int size = field.stride; \/\/usually 1 but developer can define.\n-                            for (int i = 0; i < field.contributingDims; i++) {\n-                                size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n-                            }\n-\n-                            child.bind(field, MemoryLayout.sequenceLayout(size,\n-                                    field.parent.getBoundLayout(field.ifaceType.iface, child).withName(field.ifaceType.iface.getSimpleName())\n-                            ).withName(field.name));\n-                        } else if (fieldNode instanceof FieldNode.PrimitiveFieldControlledArray field) {\n-                            \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n-                            int size = field.stride; \/\/usually 1 but developer can define.\n-                            for (int i = 0; i < field.contributingDims; i++) {\n-                                size *= child.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n-                            }\n-\n-                            child.bind(field, MemoryLayout.sequenceLayout(size,\n-                                    field.parent.getBoundLayout(field.type, child).withName(field.type.getSimpleName())\n-                            ).withName(field.name));\n-                        } else {\n-                            throw new IllegalStateException(\"what is this?\");\n-                        }\n-                    }\n-            );\n-            return (MapperUtil.isUnion(this.iface)\n-                    ? MemoryLayout.unionLayout(child.memoryLayoutListToArray())\n-                    : MemoryLayout.structLayout(child.memoryLayoutListToArray())).withName(this.iface.getSimpleName());\n-        }\n-\n-        \/**\n-         * Get a layout which describes the type.\n-         * <p>\n-         * If tyoe holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n-         * Otherwise we look through the parent's children.  Which should include a type node struct\/union matching the type.\n-         *\n-         * @param type\n-         * @param boundSchemaNode\n-         * @return\n-         *\/\n-        MemoryLayout getBoundLayout(Class<?> type, BoundSchema.BoundSchemaNode boundSchemaNode) {\n-            if (type.isPrimitive()) {\n-                return MapperUtil.primitiveToLayout(type);\n-            } else if (MapperUtil.isMemorySegment(type)) {\n-                return ValueLayout.ADDRESS;\n-            } else {\n-                return getChild(type).getBoundGroupLayout(boundSchemaNode);\n-            }\n-        }\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":3,"deletions":79,"binary":false,"changes":82,"status":"modified"}]}