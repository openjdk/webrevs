{"files":[{"patch":"@@ -501,0 +501,2 @@\n+     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n+     *                                       is not the same as the Java version used at runtime to load the code model.\n@@ -537,0 +539,2 @@\n+     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n+     *                                       is not the same as the Java version used at runtime to load the code model.\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5253,0 +5253,17 @@\n+     *\n+     * @param invokeKind       the invoke kind\n+     * @param isVarArgs        true if an invocation to a variable argument method\n+     * @param returnType       the return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n+     * @return the invoke operation\n+     * @throws IllegalArgumentException if there is a mismatch between the argument count\n+     *                                  and the invoke descriptors parameter count.\n+     *\/\n+    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n+                                  TypeElement returnType, MethodRef invokeDescriptor, Value... args) {\n+        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modelling an invocation to a method.\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    static final String JAVA_VERSION_CHECKER_F_NAME = \"$checkJavaVersion\";\n@@ -348,0 +349,22 @@\n+                }),\n+                func(JAVA_VERSION_CHECKER_F_NAME, FunctionType.FUNCTION_TYPE_VOID).body(b -> {\n+                    var compiletimeVersion = Runtime.version().feature();\n+                    \/\/ runtimeVersion = Runtime.version().feature()\n+                    var version = b.op(invoke(MethodRef.method(Runtime.class, \"version\", Runtime.Version.class)));\n+                    var runtimeVersion = b.op(invoke(MethodRef.method(Runtime.Version.class, \"feature\", int.class), version));\n+                    IfOp ifop = if_(b.parentBody()).if_(c -> {\n+                        var p = c.op(neq(runtimeVersion, b.op(constant(INT, compiletimeVersion))));\n+                        c.op(core_yield(p));\n+                    }).then(t -> {\n+                        var s = \"The Java version used at compile time to generate and store the code model, Java \" + compiletimeVersion +\n+                                \", is not the same as the Java version used at runtime to load the code model, Java \";\n+                        var errMessage = t.op(concat(\n+                                t.op(constant(J_L_STRING, s)),\n+                                runtimeVersion\n+                        ));\n+                        t.op(throw_(\n+                                t.op(new_(MethodRef.constructor(UnsupportedOperationException.class, String.class), errMessage))\n+                        ));\n+                    }).else_();\n+                    b.op(ifop);\n+                    b.op(return_());\n@@ -425,0 +448,2 @@\n+        \/\/ check if java version at compile time matches the java version at runtime\n+        builder.op(funcCall(JAVA_VERSION_CHECKER_F_NAME, FunctionType.FUNCTION_TYPE_VOID));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}