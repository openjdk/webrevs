{"files":[{"patch":"@@ -501,0 +501,2 @@\n+     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n+     *                                       is not the same as the Java version used at runtime to load the code model.\n@@ -537,0 +539,2 @@\n+     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n+     *                                       is not the same as the Java version used at runtime to load the code model.\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5253,0 +5253,17 @@\n+     *\n+     * @param invokeKind       the invoke kind\n+     * @param isVarArgs        true if an invocation to a variable argument method\n+     * @param returnType       the return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n+     * @return the invoke operation\n+     * @throws IllegalArgumentException if there is a mismatch between the argument count\n+     *                                  and the invoke descriptors parameter count.\n+     *\/\n+    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n+                                  TypeElement returnType, MethodRef invokeDescriptor, Value... args) {\n+        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modelling an invocation to a method.\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -179,0 +179,4 @@\n+    static final MethodRef STRING_FORMAT = MethodRef.method(String.class, \"format\", String.class, String.class,\n+            Object[].class);\n+\n+\n@@ -425,0 +429,20 @@\n+        \/\/ check if java version at compile time matches the java version at runtime\n+        var compiletimeVersion = Runtime.version().feature();\n+        \/\/ runtimeVersion = Runtime.version().feature()\n+        var version = builder.op(invoke(MethodRef.method(Runtime.class, \"version\", Runtime.Version.class)));\n+        var runtimeVersion = builder.op(invoke(MethodRef.method(Runtime.Version.class, \"feature\", int.class), version));\n+        IfOp ifop = if_(builder.parentBody()).if_(c -> {\n+            var p = c.op(neq(runtimeVersion, builder.op(constant(INT, compiletimeVersion))));\n+            c.op(core_yield(p));\n+        }).then(t -> {\n+            var s = \"The Java version used at compile time to generate and store the code model, Java \" + compiletimeVersion +\n+                    \", is not the same as the Java version used at runtime to load the code model, Java \";\n+            var errMessage = t.op(concat(\n+                    t.op(constant(J_L_STRING, s)),\n+                    runtimeVersion\n+            ));\n+            t.op(throw_(\n+                    t.op(new_(MethodRef.constructor(UnsupportedOperationException.class, String.class), errMessage))\n+            ));\n+        }).else_();\n+        builder.op(ifop);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}