{"files":[{"patch":"@@ -137,0 +137,1 @@\n+    static final String JAVA_VERSION_CHECKER_F_NAME = \"$checkJavaVersion\";\n@@ -179,4 +180,0 @@\n-    static final MethodRef STRING_FORMAT = MethodRef.method(String.class, \"format\", String.class, String.class,\n-            Object[].class);\n-\n-\n@@ -352,0 +349,22 @@\n+                }),\n+                func(JAVA_VERSION_CHECKER_F_NAME, FunctionType.FUNCTION_TYPE_VOID).body(b -> {\n+                    var compiletimeVersion = Runtime.version().feature();\n+                    \/\/ runtimeVersion = Runtime.version().feature()\n+                    var version = b.op(invoke(MethodRef.method(Runtime.class, \"version\", Runtime.Version.class)));\n+                    var runtimeVersion = b.op(invoke(MethodRef.method(Runtime.Version.class, \"feature\", int.class), version));\n+                    IfOp ifop = if_(b.parentBody()).if_(c -> {\n+                        var p = c.op(neq(runtimeVersion, b.op(constant(INT, compiletimeVersion))));\n+                        c.op(core_yield(p));\n+                    }).then(t -> {\n+                        var s = \"The Java version used at compile time to generate and store the code model, Java \" + compiletimeVersion +\n+                                \", is not the same as the Java version used at runtime to load the code model, Java \";\n+                        var errMessage = t.op(concat(\n+                                t.op(constant(J_L_STRING, s)),\n+                                runtimeVersion\n+                        ));\n+                        t.op(throw_(\n+                                t.op(new_(MethodRef.constructor(UnsupportedOperationException.class, String.class), errMessage))\n+                        ));\n+                    }).else_();\n+                    b.op(ifop);\n+                    b.op(return_());\n@@ -430,19 +449,1 @@\n-        var compiletimeVersion = Runtime.version().feature();\n-        \/\/ runtimeVersion = Runtime.version().feature()\n-        var version = builder.op(invoke(MethodRef.method(Runtime.class, \"version\", Runtime.Version.class)));\n-        var runtimeVersion = builder.op(invoke(MethodRef.method(Runtime.Version.class, \"feature\", int.class), version));\n-        IfOp ifop = if_(builder.parentBody()).if_(c -> {\n-            var p = c.op(neq(runtimeVersion, builder.op(constant(INT, compiletimeVersion))));\n-            c.op(core_yield(p));\n-        }).then(t -> {\n-            var s = \"The Java version used at compile time to generate and store the code model, Java \" + compiletimeVersion +\n-                    \", is not the same as the Java version used at runtime to load the code model, Java \";\n-            var errMessage = t.op(concat(\n-                    t.op(constant(J_L_STRING, s)),\n-                    runtimeVersion\n-            ));\n-            t.op(throw_(\n-                    t.op(new_(MethodRef.constructor(UnsupportedOperationException.class, String.class), errMessage))\n-            ));\n-        }).else_();\n-        builder.op(ifop);\n+        builder.op(funcCall(JAVA_VERSION_CHECKER_F_NAME, FunctionType.FUNCTION_TYPE_VOID));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"}]}