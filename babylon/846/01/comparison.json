{"files":[{"patch":"@@ -4340,0 +4340,5 @@\n+# 0: symbol, 1: string\n+compiler.warn.reflectable.lambda.unsupported=\\\n+    unsupported reflectable lambda in class {0}\\n\\\n+    {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+                CoreOp.FuncOp funcOp;\n@@ -213,10 +214,2 @@\n-                    CoreOp.FuncOp funcOp = bodyScanner.scanMethod();\n-                    if (dumpIR) {\n-                        \/\/ dump the method IR if requested\n-                        log.note(ReflectableMethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n-                    }\n-                    \/\/ create a static method that returns the op\n-                    Name methodName = methodName(symbolToMethodRef(tree.sym));\n-                    opMethodDecls.add(opMethodDecl(methodName));\n-                    ops.put(methodName.toString(), funcOp);\n-                } catch (RuntimeException e) {\n+                    funcOp = bodyScanner.scanMethod();\n+                } catch (Exception e) {\n@@ -231,0 +224,8 @@\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(ReflectableMethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static method that returns the op\n+                Name methodName = methodName(symbolToMethodRef(tree.sym));\n+                opMethodDecls.add(opMethodDecl(methodName));\n+                ops.put(methodName.toString(), funcOp);\n@@ -302,1 +303,1 @@\n-            if (currentClassSym.type.getEnclosingType().hasTag(CLASS)) {\n+            if (currentClassSym.type.getEnclosingType().hasTag(CLASS) || currentClassSym.isDirectlyOrIndirectlyLocal()) {\n@@ -311,1 +312,11 @@\n-            CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+            CoreOp.FuncOp funcOp;\n+            try {\n+                funcOp = bodyScanner.scanLambda();\n+            } catch (Exception e) {\n+                if (reflectAll) {\n+                    log.warning(tree, ReflectableLambdaUnsupported(currentClassSym.enclClass(), e.toString()));\n+                    super.visitLambda(tree);\n+                    return;\n+                }\n+                throw e;\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"}]}