{"files":[{"patch":"@@ -4340,0 +4340,5 @@\n+# 0: symbol, 1: string\n+compiler.warn.reflectable.lambda.unsupported=\\\n+    unsupported reflectable lambda in class {0}\\n\\\n+    {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-                } catch (RuntimeException e) {\n+                } catch (Exception e) {\n@@ -302,1 +302,1 @@\n-            if (currentClassSym.type.getEnclosingType().hasTag(CLASS)) {\n+            if (currentClassSym.type.getEnclosingType().hasTag(CLASS) || currentClassSym.isDirectlyOrIndirectlyLocal()) {\n@@ -311,10 +311,11 @@\n-            CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n-            if (dumpIR) {\n-                \/\/ dump the method IR if requested\n-                log.note(ReflectableLambdaIrDump(funcOp.toText()));\n-            }\n-            \/\/ create a static method that returns the FuncOp representing the lambda\n-            Name lambdaName = lambdaName();\n-            JCMethodDecl opMethod = opMethodDecl(lambdaName);\n-            opMethodDecls.add(opMethod);\n-            ops.put(lambdaName.toString(), funcOp);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(ReflectableLambdaIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static method that returns the FuncOp representing the lambda\n+                Name lambdaName = lambdaName();\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName);\n+                opMethodDecls.add(opMethod);\n+                ops.put(lambdaName.toString(), funcOp);\n@@ -322,2 +323,10 @@\n-            \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n-            tree.codeReflectionInfo = new CodeReflectionInfo(opMethod.sym, crSyms.reflectableLambdaMetafactory);\n+                \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                tree.codeReflectionInfo = new CodeReflectionInfo(opMethod.sym, crSyms.reflectableLambdaMetafactory);\n+            } catch (Exception e) {\n+                if (reflectAll) {\n+                    log.warning(tree, ReflectableLambdaUnsupported(currentClassSym.enclClass(), e.toString()));\n+                    super.visitLambda(tree);\n+                    return;\n+                }\n+                throw e;\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"}]}