{"files":[{"patch":"@@ -212,0 +212,1 @@\n+                CoreOp.FuncOp funcOp;\n@@ -213,9 +214,1 @@\n-                    CoreOp.FuncOp funcOp = bodyScanner.scanMethod();\n-                    if (dumpIR) {\n-                        \/\/ dump the method IR if requested\n-                        log.note(ReflectableMethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n-                    }\n-                    \/\/ create a static method that returns the op\n-                    Name methodName = methodName(symbolToMethodRef(tree.sym));\n-                    opMethodDecls.add(opMethodDecl(methodName));\n-                    ops.put(methodName.toString(), funcOp);\n+                    funcOp = bodyScanner.scanMethod();\n@@ -231,0 +224,8 @@\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(ReflectableMethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static method that returns the op\n+                Name methodName = methodName(symbolToMethodRef(tree.sym));\n+                opMethodDecls.add(opMethodDecl(methodName));\n+                ops.put(methodName.toString(), funcOp);\n@@ -311,0 +312,1 @@\n+            CoreOp.FuncOp funcOp;\n@@ -312,13 +314,1 @@\n-                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n-                if (dumpIR) {\n-                    \/\/ dump the method IR if requested\n-                    log.note(ReflectableLambdaIrDump(funcOp.toText()));\n-                }\n-                \/\/ create a static method that returns the FuncOp representing the lambda\n-                Name lambdaName = lambdaName();\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName);\n-                opMethodDecls.add(opMethod);\n-                ops.put(lambdaName.toString(), funcOp);\n-\n-                \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n-                tree.codeReflectionInfo = new CodeReflectionInfo(opMethod.sym, crSyms.reflectableLambdaMetafactory);\n+                funcOp = bodyScanner.scanLambda();\n@@ -333,0 +323,12 @@\n+            if (dumpIR) {\n+                \/\/ dump the method IR if requested\n+                log.note(ReflectableLambdaIrDump(funcOp.toText()));\n+            }\n+            \/\/ create a static method that returns the FuncOp representing the lambda\n+            Name lambdaName = lambdaName();\n+            JCMethodDecl opMethod = opMethodDecl(lambdaName);\n+            opMethodDecls.add(opMethod);\n+            ops.put(lambdaName.toString(), funcOp);\n+\n+            \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+            tree.codeReflectionInfo = new CodeReflectionInfo(opMethod.sym, crSyms.reflectableLambdaMetafactory);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"}]}