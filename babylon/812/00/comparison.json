{"files":[{"patch":"@@ -34,1 +34,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -55,1 +55,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -444,1 +444,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof Invoke invoke){\n+            if (invokeOpHelper(lookup,op) instanceof OpHelper.NamedOpHelper.Invoke invoke){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -45,2 +45,2 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -144,1 +144,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof Invoke invoke && !invoke.isMappableIface()) {\n+            if (invokeOpHelper(lookup,op) instanceof OpHelper.NamedOpHelper.Invoke invoke && !invoke.isMappableIface()) {\n@@ -450,1 +450,1 @@\n-    public void methodCall(Invoke invoke) {\n+    public void methodCall(OpHelper.NamedOpHelper.Invoke invoke) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import optkl.OpTkl;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -34,1 +34,0 @@\n-import optkl.util.CallSite;\n@@ -42,1 +41,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -55,3 +53,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -92,1 +88,1 @@\n-            return isAssignable(lookup, javaType,MappableIface.class);\n+            return OpHelper.isAssignable(lookup, javaType,MappableIface.class);\n@@ -174,1 +170,1 @@\n-                                    .filter(typeAndAccess -> isAssignable(lookup(), typeAndAccess.javaType, MappableIface.class))\n+                                    .filter(typeAndAccess -> OpHelper.isAssignable(lookup(), typeAndAccess.javaType, MappableIface.class))\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-import static optkl.Invoke.getTargetInvoke;\n-import static optkl.Lambda.lambdaOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Lambda.lambdaOpHelper;\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import optkl.Invoke;\n-import optkl.Trxfmr;\n+import optkl.OpHelper;\n@@ -38,1 +37,0 @@\n-import optkl.util.CallSite;\n@@ -45,2 +43,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -61,1 +58,1 @@\n-            } else if (isAssignable(lookup, p.type(), MappableIface.class)) {\n+            } else if (OpHelper.isAssignable(lookup, p.type(), MappableIface.class)) {\n@@ -77,1 +74,1 @@\n-                if (invokeOpHelper(lookup, op) instanceof Invoke invoke                         \/\/ always but pattern friendly\n+                if (invokeOpHelper(lookup, op) instanceof OpHelper.NamedOpHelper.Invoke invoke                         \/\/ always but pattern friendly\n@@ -136,1 +133,1 @@\n-                    if (isAssignable(lookup,  vop.resultType().valueType(), Buffer.class)) {\n+                    if (OpHelper.isAssignable(lookup,  vop.resultType().valueType(), Buffer.class)) {\n@@ -143,1 +140,1 @@\n-                    if (isAssignable(lookup,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                    if (OpHelper.isAssignable(lookup,  flop.fieldDescriptor().refType(), KernelContext.class)) {\n@@ -164,1 +161,1 @@\n-                if (isAssignable(lookup, value.type(), MappableIface.class)) {\n+                if (OpHelper.isAssignable(lookup, value.type(), MappableIface.class)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-import static optkl.Invoke.getTargetInvoke;\n-import static optkl.Lambda.lambdaOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.getTargetInvoke;\n+import static optkl.OpHelper.Lambda.lambdaOpHelper;\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-import optkl.Invoke;\n-import optkl.util.CallSite;\n+import optkl.OpHelper;\n@@ -36,1 +35,0 @@\n-import optkl.OpTkl;\n@@ -50,2 +48,0 @@\n-import static optkl.Invoke.invokeOpHelper;\n-\n@@ -82,1 +78,1 @@\n-        Invoke.stream(lookup,entry)\n+        OpHelper.NamedOpHelper.Invoke.stream(lookup,entry)\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.OpHelper;\n@@ -44,2 +45,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -118,1 +118,1 @@\n-                        } else if (isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n+                        } else if (OpHelper.isAssignable(lookup,paramInfo.javaType, MappableIface.class)){\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import optkl.FieldAccess;\n@@ -34,2 +33,1 @@\n-import optkl.Invoke;\n-import optkl.OpTkl;\n+import optkl.OpHelper;\n@@ -49,12 +47,3 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.condBlock;\n-import static optkl.OpTkl.elseBlock;\n-import static optkl.OpTkl.initBlock;\n-import static optkl.OpTkl.lhsOps;\n-import static optkl.OpTkl.lhsResult;\n-import static optkl.OpTkl.updateBlock;\n-import static optkl.OpTkl.result;\n-import static optkl.OpTkl.rhsOps;\n-import static optkl.OpTkl.rhsResult;\n-import static optkl.OpTkl.thenBlock;\n+import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.Ternary.ternaryOpHelper;\n@@ -132,1 +121,1 @@\n-        if (fieldAccessOpHelper(buildContext.lookup,fieldLoadOp1) instanceof FieldAccess fieldAccess\n+        if (fieldAccessOpHelper(buildContext.lookup,fieldLoadOp1) instanceof OpHelper.NamedOpHelper.FieldAccess fieldAccess\n@@ -157,1 +146,1 @@\n-        parenthesisIfNeeded(buildContext, binaryOp, lhsResult(binaryOp).op());\n+        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.lhsResult(binaryOp).op());\n@@ -159,1 +148,1 @@\n-        parenthesisIfNeeded(buildContext, binaryOp, rhsResult(binaryOp).op());\n+        parenthesisIfNeeded(buildContext, binaryOp, OpHelper.rhsResult(binaryOp).op());\n@@ -166,1 +155,1 @@\n-        lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n+        OpHelper.lhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o ->  recurse(buildContext, o));\n@@ -168,1 +157,1 @@\n-        rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n+        OpHelper.rhsOps(logicalOp).stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o-> recurse(buildContext, o));\n@@ -174,1 +163,1 @@\n-        parenthesisIfNeeded(buildContext, binaryTestOp, lhsResult(binaryTestOp).op());\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.lhsResult(binaryTestOp).op());\n@@ -176,1 +165,1 @@\n-        parenthesisIfNeeded(buildContext, binaryTestOp, rhsResult(binaryTestOp).op());\n+        parenthesisIfNeeded(buildContext, binaryTestOp, OpHelper.rhsResult(binaryTestOp).op());\n@@ -188,1 +177,1 @@\n-        parenthesisIfNeeded(buildContext, convOp, result(convOp).op());\n+        parenthesisIfNeeded(buildContext, convOp, ((Op.Result) convOp.operands().getFirst()).op());\n@@ -291,1 +280,1 @@\n-                                        nlSeparated(OpTkl.statements(ifOp.bodies().get(idx).entryBlock()),\n+                                        nlSeparated(OpHelper.Statement.statements(ifOp.bodies().get(idx).entryBlock()),\n@@ -316,1 +305,3 @@\n-                condBlock(whileOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n+                        OpHelper.entryBlockOfBodyN(whileOp, 0)\n+               \/\/ condBlock(whileOp)\n+                        .ops().stream().filter(o -> o instanceof CoreOp.YieldOp)\n@@ -320,1 +311,1 @@\n-                        nlSeparated(OpTkl.loopBodyStatements(whileOp),\n+                        nlSeparated(OpHelper.Statement.loopBodyStatements(whileOp),\n@@ -331,1 +322,1 @@\n-                    initBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    forOp.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -333,1 +324,1 @@\n-                    condBlock(forOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+                    forOp.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -336,1 +327,1 @@\n-                            OpTkl.statements(updateBlock(forOp)),\n+                            OpHelper.Statement.statements(forOp.update().entryBlock()),\n@@ -340,1 +331,1 @@\n-                            nlSeparated(OpTkl.loopBodyStatements(forOp),\n+                            nlSeparated(OpHelper.Statement.loopBodyStatements(forOp),\n@@ -379,1 +370,1 @@\n-                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof Invoke invoke0\n+                                && invokeOpHelper(buildContext.lookup,instance.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke0\n@@ -429,1 +420,2 @@\n-        condBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        OpHelper.Ternary ternary = ternaryOpHelper(buildContext.lookup,ternaryOp);\n+        ternary.condBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -431,1 +423,1 @@\n-        thenBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        ternary.thenBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -433,1 +425,1 @@\n-        elseBlock(ternaryOp).ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n+        ternary.elseBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(buildContext, o));\n@@ -452,1 +444,1 @@\n-                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, OpTkl.result(returnOp).op())\n+                        $-> $.space().parenthesisIfNeeded(buildContext, returnOp, ((Op.Result) returnOp.operands().getFirst()).op())\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":27,"deletions":35,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import optkl.OpTkl;\n+import optkl.OpHelper;\n@@ -49,1 +49,1 @@\n-                        OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                        OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import optkl.OpTkl;\n+import optkl.OpHelper;\n@@ -44,1 +44,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -51,5 +50,1 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpTkl.asResultOrThrow;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isPrimitiveResult;\n-import static optkl.OpTkl.statements;\n+import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n@@ -366,1 +361,1 @@\n-        if (javaType instanceof ClassType classType && isAssignable(buildContext.lookup, javaType, MappableIface.class)) {\n+        if (javaType instanceof ClassType classType && OpHelper.isAssignable(buildContext.lookup, javaType, MappableIface.class)) {\n@@ -368,1 +363,1 @@\n-        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,KernelContext.class)) {\n+        } else if (OpHelper.isAssignable(buildContext.lookup, javaType,KernelContext.class)) {\n@@ -370,1 +365,1 @@\n-        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,F16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n+        } else if (OpHelper.isAssignable(buildContext.lookup, javaType,F16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n@@ -372,1 +367,1 @@\n-        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,BF16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n+        } else if (OpHelper.isAssignable(buildContext.lookup, javaType,BF16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n@@ -393,1 +388,1 @@\n-                        statements(funcOp.bodies().getFirst().entryBlock()),\n+                        OpHelper.Statement.statements(funcOp.bodies().getFirst().entryBlock()),\n@@ -410,1 +405,1 @@\n-                    statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n@@ -441,1 +436,1 @@\n-                _->recurse(buildContext, asResultOrThrow(hatF16VarOp.operands().getFirst()).op()));\n+                _->recurse(buildContext, OpHelper.asResultOrThrow(hatF16VarOp.operands().getFirst()).op()));\n@@ -470,1 +465,1 @@\n-                recurse(buildContext, asResultOrThrow(hatf16BinaryOp.operands().getFirst()).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatf16BinaryOp.operands().getFirst()).op());\n@@ -475,1 +470,1 @@\n-                } else if (!isPrimitiveResult(hatf16BinaryOp.operands().getFirst())) {\n+                } else if (!OpHelper.isPrimitiveResult(hatf16BinaryOp.operands().getFirst())) {\n@@ -490,1 +485,1 @@\n-                recurse(buildContext, asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatf16BinaryOp.operands().get(1)).op());\n@@ -493,1 +488,1 @@\n-                } else if (!isPrimitiveResult(hatf16BinaryOp.operands().get(1))) {\n+                } else if (!OpHelper.isPrimitiveResult(hatf16BinaryOp.operands().get(1))) {\n@@ -516,1 +511,1 @@\n-                recurse(buildContext, asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatF16BinaryOp.operands().getFirst()).op());\n@@ -519,1 +514,1 @@\n-                } else if (!isPrimitiveResult(hatF16BinaryOp.operands().getFirst())) {\n+                } else if (!OpHelper.isPrimitiveResult(hatF16BinaryOp.operands().getFirst())) {\n@@ -525,1 +520,1 @@\n-                recurse(buildContext, asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n+                recurse(buildContext, OpHelper.asResultOrThrow(hatF16BinaryOp.operands().get(1)).op());\n@@ -528,1 +523,1 @@\n-                } else if (!isPrimitiveResult(hatF16BinaryOp.operands().get(1))) {\n+                } else if (!OpHelper.isPrimitiveResult(hatF16BinaryOp.operands().get(1))) {\n@@ -554,1 +549,1 @@\n-                        operand -> recurse(buildContext, asResultOrThrow(operand).op()))\n+                        operand -> recurse(buildContext, OpHelper.asResultOrThrow(operand).op()))\n@@ -563,1 +558,1 @@\n-                        _->recurse(builderContext,asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op()));\n+                        _->recurse(builderContext,OpHelper.asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op()));\n@@ -568,1 +563,1 @@\n-        return recurse(builderContext, asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n+        return recurse(builderContext, OpHelper.asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n@@ -571,1 +566,1 @@\n-                   sbrace(_-> recurse(builderContext, asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n+                   sbrace(_-> recurse(builderContext, OpHelper.asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.Block;\n@@ -30,2 +29,1 @@\n-import optkl.FieldAccess;\n-import optkl.OpTkl;\n+import optkl.OpHelper;\n@@ -42,1 +40,1 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n@@ -75,2 +73,0 @@\n-     \/\/   }else if (!invokeOp.operands().isEmpty() && invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n-       \/\/     recurse(buildContext, instanceResult.op());\n@@ -82,2 +78,1 @@\n-                \/\/ why did we have a sublist before? is this static vs instance?\n-            commaSpaceSeparated(  invokeOp.operands()\/*.subList(0,invokeOp.operands().size()-1)*\/, o-> {\n+            commaSpaceSeparated(  invokeOp.operands(), o-> {\n@@ -86,1 +81,1 @@\n-                } else if (o instanceof Block.Parameter parameter) {\n+                } else if (o instanceof jdk.incubator.code.Block.Parameter parameter) {\n@@ -106,1 +101,1 @@\n-                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    OpHelper.Statement.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import optkl.OpTkl;\n+import optkl.OpHelper;\n@@ -84,1 +84,1 @@\n-        Class<?> clazz = (Class<?>)OpTkl.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n+        Class<?> clazz = (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -32,1 +32,0 @@\n-import optkl.util.CallSite;\n@@ -45,2 +44,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -54,1 +52,1 @@\n-        if (Invoke.stream(lookup(), funcOp).anyMatch(invoke ->\n+        if (OpHelper.NamedOpHelper.Invoke.stream(lookup(), funcOp).anyMatch(invoke ->\n@@ -63,1 +61,1 @@\n-                    case JavaOp.InvokeOp i when invokeOpHelper(lookup(), i) instanceof Invoke invoke -> {\n+                    case JavaOp.InvokeOp i when invokeOpHelper(lookup(), i) instanceof OpHelper.NamedOpHelper.Invoke invoke -> {\n@@ -153,1 +151,1 @@\n-                                        (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                        (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n@@ -191,1 +189,1 @@\n-                                        (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                        (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n@@ -208,1 +206,1 @@\n-                                    (Class<?>) classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n+                                    (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup(), (ClassType) arrayAccessInfo.buffer().type()),\n@@ -310,1 +308,1 @@\n-    private boolean isHatVectorBinaryOperation(Invoke invoke) {\n+    private boolean isHatVectorBinaryOperation(OpHelper.NamedOpHelper.Invoke invoke) {\n@@ -388,1 +386,1 @@\n-    private String varNameFromInvokeFirstUse(Invoke invoke) {\n+    private String varNameFromInvokeFirstUse(OpHelper.NamedOpHelper.Invoke invoke) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -38,1 +38,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -45,1 +45,1 @@\n-                     ce-> invokeOpHelper(lookup(),ce) instanceof Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n+                     ce-> invokeOpHelper(lookup(),ce) instanceof OpHelper.NamedOpHelper.Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -52,1 +52,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -81,1 +81,1 @@\n-                            && invokeOpHelper(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n+                            && invokeOpHelper(lookup,varOpResult.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke && invoke.named(\"array\");\n@@ -117,1 +117,1 @@\n-    private boolean is16BitFloat(Invoke invoke, Regex methodName) {\n+    private boolean is16BitFloat(OpHelper.NamedOpHelper.Invoke invoke, Regex methodName) {\n@@ -139,1 +139,1 @@\n-    private void createF16ConvOP(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+    private void createF16ConvOP(OpHelper.NamedOpHelper.Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n@@ -161,1 +161,1 @@\n-    private void createFloatFromF16(Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+    private void createFloatFromF16(OpHelper.NamedOpHelper.Invoke invoke, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n@@ -213,1 +213,1 @@\n-        Invoke.stream(lookup(),funcOp)\n+        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n@@ -237,1 +237,1 @@\n-        Invoke.stream(lookup(),funcOp)\n+        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n@@ -261,1 +261,1 @@\n-        Invoke.stream(lookup(),funcOp)\n+        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n@@ -296,1 +296,1 @@\n-            if (op instanceof JavaOp.InvokeOp $ && invokeOpHelper(lookup(),$) instanceof Invoke invoke) {\n+            if (op instanceof JavaOp.InvokeOp $ && invokeOpHelper(lookup(),$) instanceof OpHelper.NamedOpHelper.Invoke invoke) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import optkl.OpHelper;\n@@ -40,2 +41,0 @@\n-import static optkl.OpTkl.isAssignable;\n-\n@@ -56,1 +55,1 @@\n-                if (!isAssignable(kernelCallGraph.lookup(), varOp.resultType().valueType(),\n+                if (!OpHelper.isAssignable(kernelCallGraph.lookup(), varOp.resultType().valueType(),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -39,2 +38,1 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -43,1 +41,0 @@\n-import optkl.util.CallSite;\n@@ -45,1 +42,0 @@\n-import java.util.Arrays;\n@@ -54,1 +50,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -78,1 +74,1 @@\n-    protected abstract boolean isIfaceBufferInvokeWithName(Invoke invoke);\n+    protected abstract boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke);\n@@ -128,1 +124,1 @@\n-        protected boolean isIfaceBufferInvokeWithName(Invoke invoke) {\n+        protected boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke) {\n@@ -154,1 +150,1 @@\n-        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n+        protected boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke){\n@@ -179,1 +175,1 @@\n-        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n+        protected boolean isIfaceBufferInvokeWithName(OpHelper.NamedOpHelper.Invoke invoke){\n@@ -189,1 +185,1 @@\n-                        if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                        if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import optkl.FieldAccess;\n+import optkl.OpHelper;\n@@ -37,1 +37,0 @@\n-import optkl.OpTkl;\n@@ -44,2 +43,1 @@\n-import static optkl.FieldAccess.fieldAccessOpHelper;\n-import static optkl.OpTkl.operandsAsResults;\n+import static optkl.OpHelper.NamedOpHelper.FieldAccess.fieldAccessOpHelper;\n@@ -76,1 +74,1 @@\n-                    if (fieldAccessOpHelper(lookup(),c.op()) instanceof FieldAccess fieldAccess\n+                    if (fieldAccessOpHelper(lookup(),c.op()) instanceof OpHelper.NamedOpHelper.FieldAccess fieldAccess\n@@ -80,3 +78,3 @@\n-                        operandsAsResults(fieldAccess.op())\n-                                .map(OpTkl::opOfResultOrNull)\n-                                .map(OpTkl::asVarLoadOrNull)\n+                        OpHelper.operandsAsResults(fieldAccess.op())\n+                                .map(OpHelper::opOfResultOrNull)\n+                                .map(OpHelper.NamedOpHelper.VarAccess::asVarLoadOrNull)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.code.Reflect;\n@@ -40,1 +39,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -44,1 +43,0 @@\n-import java.util.HashSet;\n@@ -54,1 +52,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -278,1 +276,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke\n@@ -319,1 +317,1 @@\n-                                if (invokeOpHelper(lookup(),result.op()) instanceof Invoke invoke ) {\n+                                if (invokeOpHelper(lookup(),result.op()) instanceof OpHelper.NamedOpHelper.Invoke invoke ) {\n@@ -358,1 +356,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke) {\n@@ -393,1 +391,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof OpHelper.NamedOpHelper.Invoke invoke) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -43,2 +43,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.asOpFromResultOrNull;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -54,1 +53,1 @@\n-                return switch (asOpFromResultOrNull(v)){\n+                return switch (OpHelper.asOpFromResultOrNull(v)){\n@@ -57,0 +56,1 @@\n+                    case null -> null;\n@@ -65,1 +65,1 @@\n-                return switch (asOpFromResultOrNull(v)){\n+                return switch (OpHelper.asOpFromResultOrNull(v)){\n@@ -68,0 +68,1 @@\n+                    case null -> null;\n@@ -84,1 +85,1 @@\n-        Invoke.stream(lookup(),funcOp)\n+        OpHelper.NamedOpHelper.Invoke.stream(lookup(),funcOp)\n@@ -99,1 +100,1 @@\n-            if (invokeOpHelper(lookup(),op) instanceof Invoke invoke\n+            if (invokeOpHelper(lookup(),op) instanceof OpHelper.NamedOpHelper.Invoke invoke\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -47,3 +47,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.asResultOrNull;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -87,1 +85,1 @@\n-                    if (invokeOpHelper(lookup(),codeElement)instanceof Invoke invoke\n+                    if (invokeOpHelper(lookup(),codeElement)instanceof OpHelper.NamedOpHelper.Invoke invoke\n@@ -94,1 +92,1 @@\n-                            && asResultOrNull(invoke.op().operands().get(1)) instanceof Op.Result result\n+                            && OpHelper.asResultOrNull(invoke.op().operands().get(1)) instanceof Op.Result result\n@@ -96,1 +94,1 @@\n-                            && isAssignable(lookup(),varLoadOp.resultType(), _V.class)){\n+                            && OpHelper.isAssignable(lookup(),varLoadOp.resultType(), _V.class)){\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.Invoke;\n+import optkl.OpHelper;\n@@ -32,1 +32,1 @@\n-import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n@@ -76,1 +76,1 @@\n-            if (invokeOpHelper(lookup,op) instanceof Invoke ih\n+            if (invokeOpHelper(lookup,op) instanceof OpHelper.NamedOpHelper.Invoke ih\n@@ -96,1 +96,1 @@\n-                .transform(ce-> Invoke.invokeOpHelper(lookup,ce) instanceof Invoke $\n+                .transform(ce-> OpHelper.NamedOpHelper.Invoke.invokeOpHelper(lookup,ce) instanceof OpHelper.NamedOpHelper.Invoke $\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-import java.util.stream.Stream;\n-\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-\n-public interface FieldAccess extends OpHelper<JavaOp.FieldAccessOp>{\n-\n-    @Override\n-    default  String name(){\n-        return op().fieldDescriptor().name();\n-    }\n-\n-    default boolean isPrimitive(){\n-        return op().result().type() instanceof PrimitiveType;\n-    }\n-\n-    default TypeElement resultType(){\n-        return op().resultType();\n-    }\n-\n-    default TypeElement refType(){\n-        return op().fieldDescriptor().refType();\n-    }\n-    default boolean refType(Class<?> ... classes){\n-        return OpTkl.isAssignable(lookup(),refType(),classes);\n-    }\n-    default  Object getStaticFinalPrimitiveValue() {\n-        if (refType() instanceof ClassType classType) {\n-            Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n-            try {\n-                Field field = clazz.getField(name());\n-                field.setAccessible(true);\n-                return field.get(null);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        throw new RuntimeException(\"Could not find field value\" + op());\n-    }\n-\n-    static FieldAccess fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {}\n-        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new Impl(lookup,fieldAccessOp): null;\n-    }\n-\n-    static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        return  funcOp.elements().filter(ce->ce instanceof JavaOp.FieldAccessOp).map(ce->fieldAccessOpHelper(lookup,ce));\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccess.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.VarType;\n-import jdk.incubator.code.dialect.java.ArrayType;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import optkl.ifacemapper.MappableIface;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-\n-\n-public interface Invoke extends OpHelper<JavaOp.InvokeOp>{\n-\n-    static Stream<Invoke> stream(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n-       return  funcOp.elements().filter(ce->ce instanceof JavaOp.InvokeOp).map(ce->invokeOpHelper(lookup,ce));\n-    }\n-\n-    default  boolean isStatic(){\n-        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n-    }\n-     default  boolean isInstance(){\n-        return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n-    }\n-    @Override default String name(){\n-        return op().invokeDescriptor().name();\n-    }\n-    default <T>boolean returns(Class<T> clazz){\n-        return isAssignable((JavaType)op().resultType(),clazz);\n-    }\n-    default boolean receives(Class<?>... classes){\n-        boolean  assignable = true;\n-        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n-            var operand = op().operands().get(i);\n-            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n-            assignable &= isAssignable((JavaType) resultType,classes[i-(isStatic()?1:0)]);\n-        }\n-        return assignable;\n-    }\n-\n-    default Method resolvedMethodOrNull(){\n-        try {\n-            return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n-        }catch (ReflectiveOperationException rope){\n-            return null;\n-        }\n-    }\n-\n-     static Invoke invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {}\n-\n-        return codeElement instanceof JavaOp.InvokeOp invokeOp? new Impl(lookup,invokeOp): null;\n-    }\n-\n-     default boolean refIs(Class<?> ...classes) {\n-        return OpTkl.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n-    }\n-\n-     default boolean returnsArray() {\n-        return op().resultType() instanceof ArrayType;\n-    }\n-\n-     default boolean returnsVoid() {\n-        return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n-    }\n-\n-     default   TypeElement returnType() {\n-        return op().invokeDescriptor().type().returnType();\n-    }\n-\n-    default boolean returnsInt(){\n-        return returnType().equals(JavaType.INT);\n-    }\n-\n-\n-\n-    default boolean returnsClassType(){\n-        return returnType() instanceof ClassType;\n-    }\n-\n-\n-    default TypeElement refType(){\n-        return op().invokeDescriptor().refType();\n-    }\n-\n-    default boolean returnsPrimitive(){\n-        return returnType() instanceof PrimitiveType ;\n-    }\n-    default boolean returnsFloat(){\n-        return returnType() == JavaType.FLOAT;\n-    }\n-    default boolean returnsChar(){\n-       return returnType() ==   JavaType.CHAR;\n-    }\n-    default boolean returnsShort(){\n-        return returnType() ==   JavaType.SHORT ;\n-    }\n-    default boolean returns16BitValue(){\n-        return returnsChar()||returnsShort();\n-    }\n-    default Method resolveMethodOrNull() {\n-        try {\n-            return op().invokeDescriptor().resolveToMethod(lookup());\n-        } catch (ReflectiveOperationException e) {\n-           return null;\n-        }\n-    }\n-    default Method resolveMethodOrThrow() {\n-        try {\n-            return op().invokeDescriptor().resolveToMethod(lookup());\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    default Class<?> classOrThrow() {\n-        if (refType() instanceof ClassType classType) {\n-            return (Class<?>) OpTkl.classTypeToTypeOrThrow(lookup(), classType);\n-        } else {\n-            throw new IllegalStateException(\" javaRef class is null\");\n-        }\n-    }\n-\n-    default boolean isMappableIface() {\n-        return refIs(MappableIface.class);\n-    }\n-    static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n-        return lambdaOp.body().entryBlock().ops().stream()\n-                .filter(ce -> ce instanceof JavaOp.InvokeOp)\n-                .map(ce -> invokeOpHelper(lookup,ce))\n-                .filter(Invoke::isStatic)\n-                .filter(invoke -> OpTkl.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n-                .findFirst()\n-                .orElseThrow();\n-    }\n-\n-\n-    default Op.Result returnResult(){\n-        return op().result();\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public interface Lambda extends OpHelper<JavaOp.LambdaOp>{\n-\n-    @Override\n-    default  String name(){\n-        return op().externalizeOpName();\n-    }\n-\n-    default boolean isPrimitive(){\n-        return op().result().type() instanceof PrimitiveType;\n-    }\n-\n-    default  <T>boolean of(Class<T> clazz){\n-        return isAssignable((JavaType) op().resultType(),clazz);\n-    }\n-\n-    static Lambda lambdaOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, JavaOp.LambdaOp op) implements Lambda {}\n-        return codeElement instanceof JavaOp.LambdaOp lambdaOp? new Impl(lookup,lambdaOp): null;\n-    }\n-\n-\n-    default Object[] getQuotedCapturedValues(Quoted quoted, Method method) {\n-        var block = op().body().entryBlock();\n-        var ops = block.ops();\n-        Object[] varLoadNames = ops.stream()\n-                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-                .map(CoreOp.VarOp::varName).toArray();\n-        Map<String, Object> nameValueMap = new HashMap<>();\n-\n-        quoted.capturedValues().forEach((k, v) -> {\n-            if (k instanceof Op.Result result) {\n-                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                    nameValueMap.put(varOp.varName(), v);\n-                }\n-            }\n-        });\n-        Object[] args = new Object[method.getParameterCount()];\n-        if (args.length != varLoadNames.length) {\n-            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-        }\n-        for (int i = 1; i < args.length; i++) {\n-            args[i] = nameValueMap.get(varLoadNames[i].toString());\n-            if (args[i] instanceof CoreOp.Var<?> var) {\n-                args[i] = var.value();\n-            }\n-        }\n-        return args;\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Lambda.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n@@ -28,0 +30,3 @@\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n@@ -29,0 +34,4 @@\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -30,0 +39,2 @@\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.ifacemapper.MappableIface;\n@@ -32,0 +43,1 @@\n+import optkl.util.ops.StatementLikeOp;\n@@ -33,0 +45,10 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n@@ -35,0 +57,1 @@\n+import java.util.stream.Stream;\n@@ -37,1 +60,1 @@\n-public interface OpHelper<T extends Op> extends LookupCarrier {\n+public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Lambda, OpHelper.NamedOpHelper, OpHelper.Ternary {\n@@ -40,7 +63,6 @@\n-    String name();\n-\n-    default boolean named(Regex regex){\n-        return regex.matches(name());\n-    }\n-    default boolean named( String...names){\n-       return Set.of(names).contains(name());\n+    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n+        try {\n+            return classType.resolve(lookup);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n@@ -48,2 +70,7 @@\n-    default boolean named(Predicate<String> predicate){\n-        return predicate.test(name());\n+\n+    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n+        if (typeElement instanceof ClassType classType) {\n+            Type type = classTypeToTypeOrThrow(lookup, classType);\n+            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n+        }\n+        return false;\n@@ -51,2 +78,3 @@\n-    default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n-            return  OpTkl.isAssignable(lookup(),javaType,clazz);\n+\n+     default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n+            return  OpHelper.isAssignable(lookup(),javaType,clazz);\n@@ -57,0 +85,1 @@\n+\n@@ -58,1 +87,1 @@\n-        return OpTkl.operandNAsResult(op(),i) instanceof Op.Result result?result:null;\n+        return operandNAsResult(op(),i) instanceof Op.Result result?result:null;\n@@ -63,0 +92,1 @@\n+\n@@ -70,0 +100,1 @@\n+\n@@ -94,0 +125,149 @@\n+    static Block entryBlockOfBodyN(Op op, int idx) {\n+        return op.bodies().get(idx).entryBlock();\n+    }\n+\n+\n+    static Value operandNOrNull(Op op, int idx) {\n+        return op.operands().size() > idx ? op.operands().get(idx) : null;\n+    }\n+\n+\n+    static boolean isPrimitiveResult(Value val) {\n+        return ((val instanceof Op.Result result && result.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null) != null;\n+    }\n+\n+    static Op.Result asResultOrThrow(Value value) {\n+        if (value instanceof Op.Result result) {\n+            return result;\n+        } else {\n+            throw new RuntimeException(\"Value not a result\");\n+        }\n+    }\n+\n+    static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n+        return codeElement instanceof Op ?\n+                ((Op) codeElement).operands().stream().filter(o -> o instanceof Op.Result).map(o -> (Op.Result) o)\n+                : Stream.of();\n+    }\n+\n+    static Op.Result operandNAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op.Result asResultOrNull(Value operand) {\n+        return operand instanceof Op.Result result ? result : null;\n+    }\n+\n+    static Op asOpFromResultOrNull(Value operand) {\n+        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n+    }\n+\n+    static Op opOfResultOrNull(Op.Result result) {\n+        return result.op() instanceof Op op ? op : null;\n+    }\n+    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp) {\n+        return (Op.Result) binaryOp.operands().get(1);\n+    }\n+\n+    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return javaConditionalOp.bodies().get(0).entryBlock().ops();\n+    }\n+    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n+        return javaConditionalOp.bodies().get(1).entryBlock().ops();\n+    }\n+\n+    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return (Op.Result) binaryTestOp.operands().get(0);\n+    }\n+\n+    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n+        return (Op.Result) binaryTestOp.operands().get(1);\n+    }\n+\n+    sealed interface NamedOpHelper<T extends Op> extends OpHelper<T>\n+            permits NamedOpHelper.FieldAccess, NamedOpHelper.Invoke, NamedOpHelper.VarAccess {\n+        String name();\n+        default boolean named(Regex regex){\n+            return regex.matches(name());\n+        }\n+        default boolean named( String...names){\n+           return Set.of(names).contains(name());\n+        }\n+        default boolean named(Predicate<String> predicate){\n+            return predicate.test(name());\n+        }\n+\n+        sealed interface VarAccess extends NamedOpHelper<CoreOp.VarAccessOp> {\n+\n+            @Override\n+            default  String name(){\n+                return op().varOp().varName();\n+            }\n+\n+            default boolean isPrimitive(){\n+                return op().result().type() instanceof PrimitiveType;\n+            }\n+\n+\n+            default  <T>boolean of(Class<T> clazz){\n+                return isAssignable((JavaType) op().resultType(),clazz);\n+            }\n+            record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n+            static VarAccess varAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+                return codeElement instanceof CoreOp.VarAccessOp varAccessOp? new VarAccess.Impl(lookup,varAccessOp): null;\n+            }\n+            static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n+                return op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n+            }\n+        }\n+\n+        sealed interface FieldAccess extends NamedOpHelper<JavaOp.FieldAccessOp> {\n+\n+            @Override\n+            default  String name(){\n+                return op().fieldDescriptor().name();\n+            }\n+\n+            default boolean isPrimitive(){\n+                return op().result().type() instanceof PrimitiveType;\n+            }\n+\n+            default TypeElement resultType(){\n+                return op().resultType();\n+            }\n+\n+            default TypeElement refType(){\n+                return op().fieldDescriptor().refType();\n+            }\n+            default boolean refType(Class<?> ... classes){\n+                return OpHelper.isAssignable(lookup(),refType(),classes);\n+            }\n+            default  Object getStaticFinalPrimitiveValue() {\n+                if (refType() instanceof ClassType classType) {\n+                    Class<?> clazz = (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+                    try {\n+                        Field field = clazz.getField(name());\n+                        field.setAccessible(true);\n+                        return field.get(null);\n+                    } catch (NoSuchFieldException | IllegalAccessException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                throw new RuntimeException(\"Could not find field value\" + op());\n+            }\n+            record Impl(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements FieldAccess {}\n+\n+\n+            static FieldAccess fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+\n+                return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new FieldAccess.Impl(lookup,fieldAccessOp): null;\n+            }\n+\n+            static Stream<FieldAccess> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+                return  funcOp.elements().filter(ce->ce instanceof JavaOp.FieldAccessOp).map(ce->fieldAccessOpHelper(lookup,ce));\n+            }\n+        }\n@@ -95,0 +275,247 @@\n+        sealed interface Invoke extends NamedOpHelper<JavaOp.InvokeOp> {\n+\n+            static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+               return  funcOp.elements().filter(ce->ce instanceof JavaOp.InvokeOp).map(ce->invokeOpHelper(lookup,ce));\n+            }\n+\n+            default  boolean isStatic(){\n+                return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+            }\n+             default  boolean isInstance(){\n+                return op().invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+            }\n+            @Override default String name(){\n+                return op().invokeDescriptor().name();\n+            }\n+            default <T>boolean returns(Class<T> clazz){\n+                return isAssignable((JavaType)op().resultType(),clazz);\n+            }\n+            default boolean receives(Class<?>... classes){\n+                boolean  assignable = true;\n+                for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n+                    var operand = op().operands().get(i);\n+                    TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n+                    assignable &= isAssignable((JavaType) resultType,classes[i-(isStatic()?1:0)]);\n+                }\n+                return assignable;\n+            }\n+\n+            default Method resolvedMethodOrNull(){\n+                try {\n+                    return op().invokeDescriptor().resolveToMethod(lookup()) instanceof Method method ? method : null;\n+                }catch (ReflectiveOperationException rope){\n+                    return null;\n+                }\n+            }\n+\n+\n+             default boolean refIs(Class<?> ...classes) {\n+                return OpHelper.isAssignable(lookup(), op().invokeDescriptor().refType(), classes);\n+            }\n+\n+             default boolean returnsArray() {\n+                return op().resultType() instanceof ArrayType;\n+            }\n+\n+             default boolean returnsVoid() {\n+                return op().invokeDescriptor().type().returnType().equals(JavaType.VOID);\n+            }\n+\n+             default   TypeElement returnType() {\n+                return op().invokeDescriptor().type().returnType();\n+            }\n+\n+            default boolean returnsInt(){\n+                return returnType().equals(JavaType.INT);\n+            }\n+\n+\n+\n+            default boolean returnsClassType(){\n+                return returnType() instanceof ClassType;\n+            }\n+\n+\n+            default TypeElement refType(){\n+                return op().invokeDescriptor().refType();\n+            }\n+\n+            default boolean returnsPrimitive(){\n+                return returnType() instanceof PrimitiveType ;\n+            }\n+            default boolean returnsFloat(){\n+                return returnType() == JavaType.FLOAT;\n+            }\n+            default boolean returnsChar(){\n+               return returnType() ==   JavaType.CHAR;\n+            }\n+            default boolean returnsShort(){\n+                return returnType() ==   JavaType.SHORT ;\n+            }\n+            default boolean returns16BitValue(){\n+                return returnsChar()||returnsShort();\n+            }\n+            default Method resolveMethodOrNull() {\n+                try {\n+                    return op().invokeDescriptor().resolveToMethod(lookup());\n+                } catch (ReflectiveOperationException e) {\n+                   return null;\n+                }\n+            }\n+            default Method resolveMethodOrThrow() {\n+                try {\n+                    return op().invokeDescriptor().resolveToMethod(lookup());\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            default Class<?> classOrThrow() {\n+                if (refType() instanceof ClassType classType) {\n+                    return (Class<?>) classTypeToTypeOrThrow(lookup(), classType);\n+                } else {\n+                    throw new IllegalStateException(\" javaRef class is null\");\n+                }\n+            }\n+\n+            default boolean isMappableIface() {\n+                return refIs(MappableIface.class);\n+            }\n+\n+            record Impl(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements Invoke {}\n+\n+            static Invoke invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+\n+                return codeElement instanceof JavaOp.InvokeOp invokeOp? new Invoke.Impl(lookup,invokeOp): null;\n+            }\n+            default Op.Result returnResult(){\n+                return op().result();\n+            }\n+\n+            static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+                return lambdaOp.body().entryBlock().ops().stream()\n+                        .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                        .map(ce -> invokeOpHelper(lookup,ce))\n+                        .filter(Invoke::isStatic)\n+                        .filter(invoke -> OpHelper.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                        .findFirst()\n+                        .orElseThrow();\n+            }\n+        }\n+    }\n+\n+    interface Statement {\n+\n+       private  static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n+            if (ce instanceof Op op) {\n+                return (\n+                        (\n+                                (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+                                        || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                                        || (op instanceof StatementLikeOp)\n+                        )\n+                                && !(op instanceof CoreOp.VarOp varOp && (!varOp.isUninitialized()\n+                                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                                && parameter.invokableOperation() instanceof CoreOp.FuncOp)\n+                        )\n+                                && !(op instanceof CoreOp.YieldOp)\n+                )\n+                        ? op\n+                        : null;\n+            } else {\n+                return null;\n+            }\n+\n+        }\n+\n+       private static boolean isStatementOp(CodeElement<?, ?> ce) {\n+            return Objects.nonNull(asStatementOpOrNull(ce));\n+        }\n+\n+        static Stream<Op> statements(Block block) {\n+            return block.ops().stream().filter(Statement::isStatementOp);\n+        }\n+        static Stream<Op> loopBodyStatements(Op.Loop op) {\n+            var list = new ArrayList<>(statements(op.loopBody().entryBlock()).toList());\n+            if (list.getLast() instanceof JavaOp.ContinueOp) {\n+                list.removeLast();\n+            }\n+            return list.stream();\n+        }\n+\n+    }\n+\n+    sealed interface Ternary extends OpHelper<JavaOp.ConditionalExpressionOp>{\n+\n+        default boolean isPrimitive(){\n+            return op().result().type() instanceof PrimitiveType;\n+        }\n+\n+        default  <T>boolean of(Class<T> clazz){\n+            return isAssignable((JavaType) op().resultType(),clazz);\n+        }\n+\n+        default Block condBlock() {\n+            return OpHelper.entryBlockOfBodyN(op(), 0);\n+        }\n+\n+        default Block thenBlock() {\n+            return OpHelper.entryBlockOfBodyN(op(), 1);\n+        }\n+\n+        default Block elseBlock() {\n+            return OpHelper.entryBlockOfBodyN(op(), 2);\n+        }\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) implements Ternary {}\n+        static Ternary ternaryOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+\n+            return codeElement instanceof JavaOp.ConditionalExpressionOp op? new Impl(lookup,op): null;\n+        }\n+    }\n+\n+    sealed interface Lambda extends OpHelper<JavaOp.LambdaOp>{\n+        default boolean isPrimitive(){\n+            return op().result().type() instanceof PrimitiveType;\n+        }\n+\n+        default  <T>boolean of(Class<T> clazz){\n+            return isAssignable((JavaType) op().resultType(),clazz);\n+        }\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.LambdaOp op) implements Lambda {}\n+        static Lambda lambdaOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+\n+            return codeElement instanceof JavaOp.LambdaOp lambdaOp? new Impl(lookup,lambdaOp): null;\n+        }\n+\n+\n+        default Object[] getQuotedCapturedValues(Quoted quoted, Method method) {\n+            var block = op().body().entryBlock();\n+            var ops = block.ops();\n+            Object[] varLoadNames = ops.stream()\n+                    .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                    .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+                    .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+                    .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+                    .map(CoreOp.VarOp::varName).toArray();\n+            Map<String, Object> nameValueMap = new HashMap<>();\n+\n+            quoted.capturedValues().forEach((k, v) -> {\n+                if (k instanceof Op.Result result) {\n+                    if (result.op() instanceof CoreOp.VarOp varOp) {\n+                        nameValueMap.put(varOp.varName(), v);\n+                    }\n+                }\n+            });\n+            Object[] args = new Object[method.getParameterCount()];\n+            if (args.length != varLoadNames.length) {\n+                throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+            }\n+            for (int i = 1; i < args.length; i++) {\n+                args[i] = nameValueMap.get(varLoadNames[i].toString());\n+                if (args[i] instanceof CoreOp.Var<?> var) {\n+                    args[i] = var.value();\n+                }\n+            }\n+            return args;\n+        }\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":440,"deletions":13,"binary":false,"changes":453,"status":"modified"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import optkl.util.ops.StatementLikeOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Stream;\n-\n-\n-public interface OpTkl {\n-\n-    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n-        try {\n-            return classType.resolve(lookup);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n-        if (typeElement instanceof ClassType classType) {\n-            Type type = classTypeToTypeOrThrow(lookup, classType);\n-            return Arrays.stream(classes).anyMatch(clazz -> clazz.isAssignableFrom((Class<?>) type));\n-        }\n-        return false;\n-    }\n-\n-\n-    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp) {\n-        return (Op.Result) binaryOp.operands().get(0);\n-    }\n-\n-    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp) {\n-        return (Op.Result) binaryOp.operands().get(1);\n-    }\n-\n-    static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx) {\n-        return javaConditionalOp.bodies().get(idx).entryBlock().ops();\n-    }\n-\n-    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n-        return ops(javaConditionalOp, 0);\n-    }\n-\n-    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp) {\n-        return ops(javaConditionalOp, 1);\n-    }\n-\n-    static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx) {\n-        return (Op.Result) binaryTestOp.operands().get(idx);\n-    }\n-\n-    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n-        return result(binaryTestOp, 0);\n-    }\n-\n-    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp) {\n-        return result(binaryTestOp, 1);\n-    }\n-\n-    static Op.Result result(JavaOp.ConvOp convOp) {\n-        return (Op.Result) convOp.operands().getFirst();\n-    }\n-\n-    static Op.Result result(CoreOp.ReturnOp returnOp) {\n-        return (Op.Result) returnOp.operands().getFirst();\n-    }\n-\n-    static Block entryBlockOfBodyN(Op op, int idx) {\n-        return op.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n-        return entryBlockOfBodyN(ternaryOp, 0);\n-    }\n-\n-    static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n-        return entryBlockOfBodyN(ternaryOp, 1);\n-    }\n-\n-    static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp) {\n-        return entryBlockOfBodyN(ternaryOp, 2);\n-    }\n-\n-\n-    static Value operandNOrNull(Op op, int idx) {\n-        return op.operands().size() > idx ? op.operands().get(idx) : null;\n-    }\n-\n-    static Block updateBlock(JavaOp.ForOp forOp) {return forOp.update().entryBlock();}\n-    static Block condBlock(JavaOp.ForOp forOp) {\n-        return forOp.cond().entryBlock();\n-    }\n-    static Block initBlock(JavaOp.ForOp forOp) {\n-        return forOp.init().entryBlock();\n-    }\n-    static Block condBlock(JavaOp.WhileOp whileOp) {\n-        return entryBlockOfBodyN(whileOp, 0);\n-    }\n-\n-    static PrimitiveType asPrimitiveResultOrNull(Value v) {\n-        return (v instanceof Op.Result r && r.op().resultType() instanceof PrimitiveType primitiveType)?primitiveType:null;\n-    }\n-\n-    static boolean isPrimitiveResult(Value v) {\n-        return (asPrimitiveResultOrNull(v) != null);\n-    }\n-\n-    static Op.Result asResultOrThrow(Value value) {\n-        if (value instanceof Op.Result result) {\n-            return result;\n-        } else {\n-            throw new RuntimeException(\"Value not a result\");\n-        }\n-    }\n-\n-    static Stream<Op.Result> operandsAsResults(jdk.incubator.code.CodeElement<?, ?> codeElement) {\n-        return codeElement instanceof Op ?\n-                ((Op) codeElement).operands().stream().filter(o -> o instanceof Op.Result).map(o -> (Op.Result) o)\n-                : Stream.of();\n-    }\n-\n-    static Op.Result operandNAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n-        return codeElement instanceof Op op && op.operands().size() > n && op.operands().get(n) instanceof Op.Result result ? result : null;\n-    }\n-\n-    static Op.Result asResultOrNull(Value operand) {\n-        return operand instanceof Op.Result result ? result : null;\n-    }\n-\n-    static Op asOpFromResultOrNull(Value operand) {\n-        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n-    }\n-\n-    static Op opOfResultOrNull(Op.Result result) {\n-        return result.op() instanceof Op op ? op : null;\n-    }\n-\n-    static CoreOp.VarAccessOp.VarLoadOp asVarLoadOrNull(Op op) {\n-        return op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp ? varLoadOp : null;\n-    }\n-\n-    static boolean resultType(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp, Class<?>... classes) {\n-        return isAssignable(lookup, varLoadOp.resultType(), classes);\n-    }\n-\n-    static Stream<Op> loopBodyStatements(Op.Loop op) {\n-        var list = new ArrayList<>(statements(op.loopBody().entryBlock()).toList());\n-        if (list.getLast() instanceof JavaOp.ContinueOp) {\n-            list.removeLast();\n-        }\n-        return list.stream();\n-    }\n-\n-    static Op asStatementOpOrNull(CodeElement<?, ?> ce) {\n-        if (ce instanceof Op op) {\n-            return (\n-                    (\n-                            (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-                                    || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-                                    || (op instanceof StatementLikeOp)\n-                    )\n-                            && !(op instanceof CoreOp.VarOp varOp && isParamVar(varOp))\/\/..ParamVar.of(varOp) != null)\n-                            && !(op instanceof CoreOp.YieldOp)\n-            )\n-                    ? op\n-                    : null;\n-        } else {\n-            return null;\n-        }\n-\n-    }\n-\n-    static boolean isStatementOp(CodeElement<?, ?> ce) {\n-        return Objects.nonNull(asStatementOpOrNull(ce));\n-    }\n-\n-    static Stream<Op> statements(Block block) {\n-        return block.ops().stream().filter(OpTkl::isStatementOp);\n-    }\n-\n-    static boolean isParamVar(CoreOp.VarOp varOp) {\n-        return !varOp.isUninitialized()\n-                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n-                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp;\n-    }\n-}\n-\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.Function;\n@@ -45,2 +44,0 @@\n-import static optkl.OpTkl.operandNOrNull;\n-\n@@ -214,1 +211,1 @@\n-            return getValue(operandNOrNull(op(),idx));\n+            return getValue(OpHelper.operandNAsResult(op(),idx));\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package optkl;\n-\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-\n-public interface VarAccess extends OpHelper<CoreOp.VarAccessOp>{\n-\n-    @Override\n-    default  String name(){\n-        return op().varOp().varName();\n-    }\n-\n-    default boolean isPrimitive(){\n-        return op().result().type() instanceof PrimitiveType;\n-    }\n-\n-\n-    default  <T>boolean of(Class<T> clazz){\n-        return isAssignable((JavaType) op().resultType(),clazz);\n-    }\n-\n-    static VarAccess varAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n-        record Impl(MethodHandles.Lookup lookup, CoreOp.VarAccessOp op) implements VarAccess {}\n-        return codeElement instanceof CoreOp.VarAccessOp varAccessOp? new Impl(lookup,varAccessOp): null;\n-    }\n-}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/VarAccess.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"}]}