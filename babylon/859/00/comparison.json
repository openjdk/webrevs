{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import optkl.OpHelper;\n@@ -241,1 +242,1 @@\n-            List<TypeElement> localIFaceList = new ArrayList<>();\n+            Set<String> typedefs = new HashSet<>();\n@@ -243,5 +244,3 @@\n-            kernelCallGraph.getModuleOp()\n-                    .elements()\n-                    .filter(c -> Objects.requireNonNull(c) instanceof HATMemoryVarOp)\n-                    .map(c -> ((HATMemoryVarOp) c).invokeType())\n-                    .forEach(localIFaceList::add);\n+            \/\/ Add HAT reserved types\n+            typedefs.add(F16.class.getName());\n+            typedefs.add(BF16.class.getName());\n@@ -249,1 +248,7 @@\n-            kernelCallGraph.entrypoint.funcOp()\n+            \/*\n+             I think the kernelCallGraph module op was built before we inserted HATMemoryVarOps\n+\n+             So we will likely never get any matches from the module op\n+\n+             List<ClassType> localIFaceList = new ArrayList<>();\n+             kernelCallGraph.getModuleOp()\n@@ -252,1 +257,1 @@\n-                    .map(c -> ((HATMemoryVarOp) c).invokeType())\n+                    .map(c -> (ClassType)((HATMemoryVarOp) c).invokeType())\n@@ -255,0 +260,7 @@\n+\n+\n+             However,the sentiment from above was correct as we may have kernel reachable methods that do indeed\n+             have these HATMemoryVarOps.  I think if we called a method from the entrypoint with Device type accesses\n+             we would miss them\n+             *\/\n+\n@@ -259,25 +271,23 @@\n-            Set<String> typedefs = new HashSet<>();\n-\n-            \/\/ Add HAT reserved types\n-            typedefs.add(F16.class.getName());\n-            typedefs.add(BF16.class.getName());\n-\n-            for (TypeElement typeElement : localIFaceList) {\n-                try {\n-                    Class<?> clazz = (Class<?>) ((ClassType) typeElement).resolve(kernelCallGraph.lookup());\n-                    Field schemaField = clazz.getDeclaredField(\"schema\");\n-                    schemaField.setAccessible(true);\n-                    var schema = (DeviceSchema<?>)schemaField.get(schemaField);\n-                    \/\/ <1> We are creating text form of DeviceType schema\n-                    String toText = schema.toText();\n-                    if (toText != null) {\n-                        \/\/ <2> just to then parse the text from above.\n-                        \/\/ Lets get the model in a cleaner form\n-                        generateDeviceTypeStructs(builder, toText, typedefs);\n-                    } else {\n-                        throw new RuntimeException(\"[ERROR] Could not find valid device schema \");\n-                    }\n-                } catch (ReflectiveOperationException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n+            kernelCallGraph.entrypoint.funcOp()\n+                    .elements()\n+                    .filter(c -> Objects.requireNonNull(c) instanceof HATMemoryVarOp)\n+                    .map(c -> (ClassType)((HATMemoryVarOp) c).invokeType())\n+                    .forEach( classType-> {\n+                         try {\n+                             Class<?> clazz = (Class<?>) classType.resolve(kernelCallGraph.lookup());\n+                             Field schemaField = clazz.getDeclaredField(\"schema\");\n+                             schemaField.setAccessible(true);\n+                             var schema = (DeviceSchema<?>)schemaField.get(schemaField);\n+                             \/\/ <1> We are creating text form of DeviceType schema\n+                             String toText = schema.toText();\n+                             if (toText != null) {\n+                                 \/\/ <2> just to then parse the text from above.\n+                                 \/\/ Lets get the model in a cleaner form\n+                                 generateDeviceTypeStructs(builder, toText, typedefs);\n+                             } else {\n+                                 throw new RuntimeException(\"[ERROR] Could not find valid device schema \");\n+                             }\n+                         } catch (ReflectiveOperationException e) {\n+                             throw new RuntimeException(e);\n+                         }\n+            });\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":43,"deletions":33,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -653,2 +653,0 @@\n-                 \/\/   .filter(invoke->invoke instanceof Invoke.Static)\n-                  \/\/  .map(invoke->(Invoke.Static)invoke)\n@@ -679,3 +677,0 @@\n-           \/\/ static Virtual invokeVirtual(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-             \/\/   return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n-           \/\/ }\n@@ -686,3 +681,0 @@\n-           \/\/ static Static invokeStatic(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n-             \/\/   return codeElement instanceof JavaOp.InvokeOp invokeOp ? new Impl(lookup, invokeOp) : null;\n-           \/\/ }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}