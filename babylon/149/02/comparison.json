{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.*;\n@@ -41,2 +43,4 @@\n-    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n-    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n+    private static final JavaType J_L_BYTESTRING = JavaType.type(StringBuilder.class);\n+    private static final JavaType J_L_CHARSEQUENCE = JavaType.type(CharSequence.class);\n+    private static final JavaType J_L_OBJECT = JavaType.type(Object.class);\n+    private static final MethodRef SB_TO_STRING = MethodRef.method(J_L_BYTESTRING, \"toString\", JavaType.J_L_STRING);\n@@ -44,1 +48,2 @@\n-    record StringAndBuilder(Value string, Value stringBuilder) { }\n+    final private Set<Value> StringBuilders = new HashSet<>();\n+    final private Map<Integer, Value> IntConstants = new HashMap<>();\n@@ -46,1 +51,9 @@\n-    public StringConcatTransformer() {}\n+    public StringConcatTransformer() {\n+    }\n+\n+    private static boolean reusableResult(Op.Result r) {\n+        if (r.uses().size() == 1) {\n+            return r.uses().stream().allMatch((use) -> use.op() instanceof CoreOp.ConcatOp);\n+        }\n+        return false;\n+    }\n@@ -48,2 +61,1 @@\n-    @Override\n-    public Block.Builder apply(Block.Builder builder, Op op) {\n+    @Override public Block.Builder apply(Block.Builder builder, Op op) {\n@@ -54,5 +66,9 @@\n-\n-            Value result = cz.result();\n-\n-            StringAndBuilder newRes = stringBuild(builder, left, right);\n-            builder.context().mapValue(result, newRes.string);\n+            Op.Result result = cz.result();\n+            if (reusableResult(result)) {\n+                Value sb = stringBuilder(builder, left, right);\n+                builder.context().mapValue(result, sb);\n+            } else {\n+                Value sb = stringBuilder(builder, left, right);\n+                Value str = buildString(builder, sb);\n+                builder.context().mapValue(result, str);\n+            }\n@@ -66,5 +82,21 @@\n-    private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n-        var newB = stringBuilder(builder, left, right);\n-        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, newB);\n-        Value newString = builder.apply(toStringInvoke);\n-        return new StringAndBuilder(newString, newB);\n+    private Value buildString(Block.Builder builder, Value sb){\n+        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, sb);\n+        return builder.apply(toStringInvoke);\n+    }\n+\n+    private Value stringBuilder(Block.Builder builder, Value left, Value right) {\n+        if (left.type().equals(J_L_BYTESTRING) && StringBuilders.contains(left)\n+                || right.type().equals(J_L_BYTESTRING) && StringBuilders.contains(right)) {\n+            var res = builder.op(append(builder, left, right));\n+            StringBuilders.add(res);\n+            return res;\n+        } else {\n+            CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(J_L_BYTESTRING));\n+            Value sb = builder.op(newBuilder);\n+            StringBuilders.add(sb);\n+            var res = builder.op(append(builder, sb, left));\n+            StringBuilders.add(res);\n+            var res2 = builder.op(append(builder, res, right));\n+            StringBuilders.add(res2);\n+            return res2;\n+        }\n@@ -73,6 +105,52 @@\n-    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n-        CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n-        Value sb = builder.apply(newBuilder);\n-        builder.op(append(sb, left));\n-        builder.op(append(sb, right));\n-        return sb;\n+    private Op append(Block.Builder builder, Value left, Value right) {\n+        \/\/Left argument is a blessed stringbuilder\n+        if (left.type().equals(J_L_BYTESTRING) && StringBuilders.contains(left)) {\n+            var rightType = right.type();\n+            if (rightType.equals(J_L_BYTESTRING)) {\n+                rightType = J_L_CHARSEQUENCE;\n+                MethodRef leftMethodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n+                return CoreOp.invoke(leftMethodDesc, left, right);\n+            }\n+\n+            if (rightType instanceof PrimitiveType) {\n+                if (List.of(JavaType.BYTE, JavaType.SHORT).contains(rightType)) {\n+                    Value widened = builder.op(CoreOp.conv(JavaType.INT, right));\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, JavaType.INT);\n+                    return CoreOp.invoke(methodDesc, left, widened);\n+                } else {\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n+                    return CoreOp.invoke(methodDesc, left, right);\n+                }\n+            } else if (rightType.equals(JavaType.J_L_STRING)) {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n+                return CoreOp.invoke(methodDesc, left, right);\n+            } else {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, J_L_OBJECT);\n+                return CoreOp.invoke(methodDesc, left, right);\n+            }\n+        } else if (right.type().equals(J_L_BYTESTRING) && StringBuilders.contains(right)) {\n+            var leftType = left.type();\n+            var zero = getConstant(builder, 0);\n+            if (leftType.equals(J_L_BYTESTRING)) {\n+                leftType = J_L_CHARSEQUENCE;\n+                MethodRef leftMethodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n+                return CoreOp.invoke(leftMethodDesc, right, zero, left);\n+            }\n+            if (leftType instanceof PrimitiveType) {\n+                if (List.of(JavaType.BYTE, JavaType.SHORT).contains(leftType)) {\n+                    Value widened = builder.op(CoreOp.conv(JavaType.INT, left));\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, JavaType.INT);\n+                    return CoreOp.invoke(methodDesc, right, zero, widened);\n+                } else {\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n+                    return CoreOp.invoke(methodDesc, right, zero, left);\n+                }\n+            } else if (leftType.equals(JavaType.J_L_STRING)) {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n+                return CoreOp.invoke(methodDesc, right, zero, left);\n+            } else {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, J_L_OBJECT);\n+                return CoreOp.invoke(methodDesc, right, zero, left);\n+            }\n+        }\n+        throw new RuntimeException(\"append requires a blessed StringBuilder as one Value argument\");\n@@ -81,3 +159,8 @@\n-    private static Op append(Value stringBuilder, Value arg) {\n-        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, arg.type());\n-        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n+    private Value getConstant(Block.Builder builder, int con) {\n+        var val = IntConstants.get(con);\n+        if (val == null) {\n+            var constOp = CoreOp.constant(JavaType.INT, con);\n+            val = builder.op(constOp);\n+            IntConstants.put(0, val);\n+        }\n+        return val;\n@@ -85,0 +168,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+        model.writeTo(System.out);\n@@ -117,0 +118,4 @@\n+        model.writeTo(System.out);\n+        ssa_model.writeTo(System.out);\n+        ssa_transformed_model.writeTo(System.out);\n+\n@@ -196,1 +201,1 @@\n-    public static String intConcatNestedSplit(int i, String s){\n+    public static String intConcatNestedSplit(int i, String s) {\n@@ -202,1 +207,35 @@\n-}\n\\ No newline at end of file\n+    @CodeReflection\n+    public static String degenerateTree(String a, String b, String c, String d) {\n+        String s = (a + b) + (c + d);\n+        return s;\n+    }\n+\n+    \/\/This String Builder is getting tweaked, check for side effects\n+    @CodeReflection\n+    public static String degenerateTree2(String a, String d) {\n+        StringBuilder sb = new StringBuilder(\"test\");\n+        String s = sb + a;\n+        String t = s + d;\n+        System.out.println(sb);\n+        return t;\n+    }\n+\n+    @CodeReflection\n+    public static String degenerateTree4(String a, String b, String c, String d) {\n+        String s = ((a + b) + c) + d;\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String degenerateTree5(String a, String b, String c, String d) {\n+        String s = (a + (b + (c + d)));\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String widenPrimitives(short a, byte b, int c, int d) {\n+        String s = (a + (b + (c + d + \"hi\")));\n+        return s;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"}]}