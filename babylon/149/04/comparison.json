{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.*;\n@@ -41,2 +43,2 @@\n-    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n-    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n+    private static final JavaType J_L_OBJECT = JavaType.type(Object.class);\n+    private static final JavaType J_L_STRING_BUILDER = JavaType.type(StringBuilder.class);\n@@ -44,1 +46,2 @@\n-    record StringAndBuilder(Value string, Value stringBuilder) { }\n+    private static final MethodRef SB_TO_STRING_REF = MethodRef.method(\n+            J_L_STRING_BUILDER, \"toString\", JavaType.J_L_STRING);\n@@ -49,2 +52,17 @@\n-    public Block.Builder apply(Block.Builder builder, Op op) {\n-        if (op instanceof CoreOp.ConcatOp cz) {\n+    public Block.Builder apply(Block.Builder block, Op op) {\n+        switch (op) {\n+            case CoreOp.ConcatOp cz when isRootConcat(cz) -> {\n+                \/\/ Create a string builder and build by traversing tree of operands\n+                Op.Result builder = block.apply(CoreOp._new(FunctionType.functionType(J_L_STRING_BUILDER)));\n+                buildFromTree(block, builder, cz);\n+                \/\/ Convert to string\n+                Value s = block.op(CoreOp.invoke(SB_TO_STRING_REF, builder));\n+                block.context().mapValue(cz.result(), s);\n+            }\n+            case CoreOp.ConcatOp cz -> {\n+                \/\/ Process later when building from root concat\n+            }\n+            default -> block.op(op);\n+        }\n+        return block;\n+    }\n@@ -52,2 +70,6 @@\n-            Value left = builder.context().getValue(cz.operands().get(0));\n-            Value right = builder.context().getValue(cz.operands().get(1));\n+    static boolean isRootConcat(CoreOp.ConcatOp cz) {\n+        \/\/ Root of concat tree, zero uses, two or more uses,\n+        \/\/ or one use that is not a subsequent concat op\n+        Set<Op.Result> uses = cz.result().uses();\n+        return uses.size() != 1 || !(uses.iterator().next().op() instanceof CoreOp.ConcatOp);\n+    }\n@@ -55,1 +77,5 @@\n-            Value result = cz.result();\n+    static void buildFromTree(Block.Builder block, Op.Result builder, CoreOp.ConcatOp cz) {\n+        \/\/ Process concat op's operands from left to right\n+        buildFromTree(block, builder, cz.operands().get(0));\n+        buildFromTree(block, builder, cz.operands().get(1));\n+    }\n@@ -57,2 +83,6 @@\n-            StringAndBuilder newRes = stringBuild(builder, left, right);\n-            builder.context().mapValue(result, newRes.string);\n+    static void buildFromTree(Block.Builder block, Op.Result builder, Value v) {\n+        if (v instanceof Op.Result r &&\n+                r.op() instanceof CoreOp.ConcatOp cz &&\n+                r.uses().size() == 1) {\n+            \/\/ Node of tree, recursively traverse the operands\n+            buildFromTree(block, builder, cz);\n@@ -60,1 +90,3 @@\n-            builder.op(op);\n+            \/\/ Leaf of tree, append value to builder\n+            \/\/ Note leaf can be the result of a ConcatOp with multiple uses\n+            block.op(append(block, builder, block.context().getValue(v)));\n@@ -62,1 +94,0 @@\n-        return builder;\n@@ -65,6 +96,2 @@\n-    \/\/Uses StringBuilder and Immediate String Value\n-    private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n-        var newB = stringBuilder(builder, left, right);\n-        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, newB);\n-        Value newString = builder.apply(toStringInvoke);\n-        return new StringAndBuilder(newString, newB);\n+    private static Op append(Block.Builder block, Value builder, Value arg) {\n+        return append(block, builder, arg, arg.type());\n@@ -73,6 +100,19 @@\n-    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n-        CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n-        Value sb = builder.apply(newBuilder);\n-        builder.op(append(sb, left));\n-        builder.op(append(sb, right));\n-        return sb;\n+    private static Op append(Block.Builder block, Value builder, Value arg, TypeElement type) {\n+        \/\/ Check if we need to widen unsupported integer types in the StringBuilder API\n+        \/\/ Strings are fed in as-is, everything else given as an Object.\n+        if (type instanceof PrimitiveType) {\n+            if (List.of(JavaType.BYTE, JavaType.SHORT).contains(type)) {\n+                Value widened = block.op(CoreOp.conv(JavaType.INT, arg));\n+                MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, JavaType.INT);\n+                return CoreOp.invoke(methodDesc, builder, widened);\n+            } else {\n+                MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, type);\n+                return CoreOp.invoke(methodDesc, builder, arg);\n+            }\n+        } else if (type.equals(JavaType.J_L_STRING)) {\n+            MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, type);\n+            return CoreOp.invoke(methodDesc, builder, arg);\n+        } else {\n+            MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, J_L_OBJECT);\n+            return CoreOp.invoke(methodDesc, builder, arg);\n+        }\n@@ -81,4 +121,0 @@\n-    private static Op append(Value stringBuilder, Value arg) {\n-        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, arg.type());\n-        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":64,"deletions":28,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        valMap.put(StringBuilder.class, new StringBuilder(\"test\"));\n@@ -100,0 +101,1 @@\n+        model.writeTo(System.out);\n@@ -117,0 +119,4 @@\n+        model.writeTo(System.out);\n+        ssa_model.writeTo(System.out);\n+        ssa_transformed_model.writeTo(System.out);\n+\n@@ -133,0 +139,31 @@\n+    \/\/Testing to make sure StringBuilders aren't caught up in the concat transformation\n+    @Test\n+    public void testStringBuilderUnchanged() {\n+        Method method;\n+\n+        try {\n+            method = TestStringConcatTransform.class.getMethod(\"stringBuilderArgCheck\", String.class, String.class, StringBuilder.class);\n+        } catch (NoSuchMethodException e) {\n+           throw new RuntimeException(e);\n+        }\n+\n+        CoreOp.FuncOp model = method.getCodeModel().orElseThrow();\n+        CoreOp.FuncOp transformed_model = model.transform(new StringConcatTransformer());\n+        CoreOp.FuncOp ssa_model = generateSSA(model);\n+        CoreOp.FuncOp ssa_transformed_model = ssa_model.transform(new StringConcatTransformer());\n+        Object[] args = {\"Foo\", \"Bar\", new StringBuilder(\"test\")};\n+\n+        Interpreter.invoke(model, args);\n+        Interpreter.invoke(transformed_model, args);\n+        Interpreter.invoke(ssa_model, args);\n+        Interpreter.invoke(ssa_transformed_model, args);\n+        Object jvm_interpreted;\n+        try {\n+            method.invoke(null, args);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        Assert.assertEquals(\"test\", args[2].toString());\n+    }\n+\n@@ -196,1 +233,1 @@\n-    public static String intConcatNestedSplit(int i, String s){\n+    public static String intConcatNestedSplit(int i, String s) {\n@@ -202,1 +239,41 @@\n-}\n\\ No newline at end of file\n+    @CodeReflection\n+    public static String nonLeftAssociativeTree(String a, String b, String c, String d) {\n+        String s = (a + b) + (c + d);\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String stringBuilderCheck(String a, String d) {\n+        StringBuilder sb = new StringBuilder(\"test\");\n+        String s = sb + a;\n+        String t = s + d;\n+        return t;\n+    }\n+\n+    @CodeReflection\n+    public static String stringBuilderArgCheck(String a, String d, StringBuilder c) {\n+        StringBuilder sb = c;\n+        String s = sb + a;\n+        String t = s + d;\n+        return t;\n+    }\n+\n+    @CodeReflection\n+    public static String leftAssociativeTree(String a, String b, String c, String d) {\n+        String s = ((a + b) + c) + d;\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String rightAssociativeTree(String a, String b, String c, String d) {\n+        String s = (a + (b + (c + d)));\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String widenPrimitives(short a, byte b, int c, int d) {\n+        String s = (a + (b + (c + d + \"hi\")));\n+        return s;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":79,"deletions":2,"binary":false,"changes":81,"status":"modified"}]}