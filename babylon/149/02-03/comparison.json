{"files":[{"patch":"@@ -43,2 +43,0 @@\n-    private static final JavaType J_L_BYTESTRING = JavaType.type(StringBuilder.class);\n-    private static final JavaType J_L_CHARSEQUENCE = JavaType.type(CharSequence.class);\n@@ -46,1 +44,1 @@\n-    private static final MethodRef SB_TO_STRING = MethodRef.method(J_L_BYTESTRING, \"toString\", JavaType.J_L_STRING);\n+    private static final JavaType J_L_STRING_BUILDER = JavaType.type(StringBuilder.class);\n@@ -48,2 +46,2 @@\n-    final private Set<Value> StringBuilders = new HashSet<>();\n-    final private Map<Integer, Value> IntConstants = new HashMap<>();\n+    private static final MethodRef SB_TO_STRING_REF = MethodRef.method(\n+            J_L_STRING_BUILDER, \"toString\", JavaType.J_L_STRING);\n@@ -51,2 +49,1 @@\n-    public StringConcatTransformer() {\n-    }\n+    public StringConcatTransformer() {}\n@@ -54,3 +51,15 @@\n-    private static boolean reusableResult(Op.Result r) {\n-        if (r.uses().size() == 1) {\n-            return r.uses().stream().allMatch((use) -> use.op() instanceof CoreOp.ConcatOp);\n+    @Override\n+    public Block.Builder apply(Block.Builder block, Op op) {\n+        switch (op) {\n+            case CoreOp.ConcatOp cz when isRootConcat(cz) -> {\n+                \/\/ Create a string builder and build by traversing tree of operands\n+                Op.Result builder = block.apply(CoreOp._new(FunctionType.functionType(J_L_STRING_BUILDER)));\n+                buildFromTree(block, builder, cz);\n+                \/\/ Convert to string\n+                Value s = block.op(CoreOp.invoke(SB_TO_STRING_REF, builder));\n+                block.context().mapValue(cz.result(), s);\n+            }\n+            case CoreOp.ConcatOp cz -> {\n+                \/\/ Process later when building from root concat\n+            }\n+            default -> block.op(op);\n@@ -58,1 +67,1 @@\n-        return false;\n+        return block;\n@@ -61,18 +70,5 @@\n-    @Override public Block.Builder apply(Block.Builder builder, Op op) {\n-        if (op instanceof CoreOp.ConcatOp cz) {\n-\n-            Value left = builder.context().getValue(cz.operands().get(0));\n-            Value right = builder.context().getValue(cz.operands().get(1));\n-            Op.Result result = cz.result();\n-            if (reusableResult(result)) {\n-                Value sb = stringBuilder(builder, left, right);\n-                builder.context().mapValue(result, sb);\n-            } else {\n-                Value sb = stringBuilder(builder, left, right);\n-                Value str = buildString(builder, sb);\n-                builder.context().mapValue(result, str);\n-            }\n-        } else {\n-            builder.op(op);\n-        }\n-        return builder;\n+    static boolean isRootConcat(CoreOp.ConcatOp cz) {\n+        \/\/ Root of concat tree, zero uses, two or more uses,\n+        \/\/ or one use that is not a subsequent concat op\n+        Set<Op.Result> uses = cz.result().uses();\n+        return uses.size() != 1 || !(uses.iterator().next().op() instanceof CoreOp.ConcatOp);\n@@ -81,4 +77,4 @@\n-    \/\/Uses StringBuilder and Immediate String Value\n-    private Value buildString(Block.Builder builder, Value sb){\n-        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, sb);\n-        return builder.apply(toStringInvoke);\n+    static void buildFromTree(Block.Builder block, Op.Result builder, CoreOp.ConcatOp cz) {\n+        \/\/ Process concat op's operands from left to right\n+        buildFromTree(block, builder, cz.operands().get(0));\n+        buildFromTree(block, builder, cz.operands().get(1));\n@@ -87,6 +83,6 @@\n-    private Value stringBuilder(Block.Builder builder, Value left, Value right) {\n-        if (left.type().equals(J_L_BYTESTRING) && StringBuilders.contains(left)\n-                || right.type().equals(J_L_BYTESTRING) && StringBuilders.contains(right)) {\n-            var res = builder.op(append(builder, left, right));\n-            StringBuilders.add(res);\n-            return res;\n+    static void buildFromTree(Block.Builder block, Op.Result builder, Value v) {\n+        if (v instanceof Op.Result r &&\n+                r.op() instanceof CoreOp.ConcatOp cz &&\n+                r.uses().size() == 1) {\n+            \/\/ Node of tree, recursively traverse the operands\n+            buildFromTree(block, builder, cz);\n@@ -94,8 +90,3 @@\n-            CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(J_L_BYTESTRING));\n-            Value sb = builder.op(newBuilder);\n-            StringBuilders.add(sb);\n-            var res = builder.op(append(builder, sb, left));\n-            StringBuilders.add(res);\n-            var res2 = builder.op(append(builder, res, right));\n-            StringBuilders.add(res2);\n-            return res2;\n+            \/\/ Leaf of tree, append value to builder\n+            \/\/ Note leaf can be the result of a ConcatOp with multiple uses\n+            block.op(append(block, builder, block.context().getValue(v)));\n@@ -105,9 +96,3 @@\n-    private Op append(Block.Builder builder, Value left, Value right) {\n-        \/\/Left argument is a blessed stringbuilder\n-        if (left.type().equals(J_L_BYTESTRING) && StringBuilders.contains(left)) {\n-            var rightType = right.type();\n-            if (rightType.equals(J_L_BYTESTRING)) {\n-                rightType = J_L_CHARSEQUENCE;\n-                MethodRef leftMethodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n-                return CoreOp.invoke(leftMethodDesc, left, right);\n-            }\n+    private static Op append(Block.Builder block, Value builder, Value arg) {\n+        return append(block, builder, arg, arg.type());\n+    }\n@@ -115,36 +100,8 @@\n-            if (rightType instanceof PrimitiveType) {\n-                if (List.of(JavaType.BYTE, JavaType.SHORT).contains(rightType)) {\n-                    Value widened = builder.op(CoreOp.conv(JavaType.INT, right));\n-                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, JavaType.INT);\n-                    return CoreOp.invoke(methodDesc, left, widened);\n-                } else {\n-                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n-                    return CoreOp.invoke(methodDesc, left, right);\n-                }\n-            } else if (rightType.equals(JavaType.J_L_STRING)) {\n-                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n-                return CoreOp.invoke(methodDesc, left, right);\n-            } else {\n-                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, J_L_OBJECT);\n-                return CoreOp.invoke(methodDesc, left, right);\n-            }\n-        } else if (right.type().equals(J_L_BYTESTRING) && StringBuilders.contains(right)) {\n-            var leftType = left.type();\n-            var zero = getConstant(builder, 0);\n-            if (leftType.equals(J_L_BYTESTRING)) {\n-                leftType = J_L_CHARSEQUENCE;\n-                MethodRef leftMethodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n-                return CoreOp.invoke(leftMethodDesc, right, zero, left);\n-            }\n-            if (leftType instanceof PrimitiveType) {\n-                if (List.of(JavaType.BYTE, JavaType.SHORT).contains(leftType)) {\n-                    Value widened = builder.op(CoreOp.conv(JavaType.INT, left));\n-                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, JavaType.INT);\n-                    return CoreOp.invoke(methodDesc, right, zero, widened);\n-                } else {\n-                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n-                    return CoreOp.invoke(methodDesc, right, zero, left);\n-                }\n-            } else if (leftType.equals(JavaType.J_L_STRING)) {\n-                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n-                return CoreOp.invoke(methodDesc, right, zero, left);\n+    private static Op append(Block.Builder block, Value builder, Value arg, TypeElement type) {\n+        \/\/ Check if we need to widen unsupported integer types in the StringBuilder API\n+        \/\/ Strings are fed in as-is, everything else given as an Object.\n+        if (type instanceof PrimitiveType) {\n+            if (List.of(JavaType.BYTE, JavaType.SHORT).contains(type)) {\n+                Value widened = block.op(CoreOp.conv(JavaType.INT, arg));\n+                MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, JavaType.INT);\n+                return CoreOp.invoke(methodDesc, builder, widened);\n@@ -152,2 +109,2 @@\n-                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, J_L_OBJECT);\n-                return CoreOp.invoke(methodDesc, right, zero, left);\n+                MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, type);\n+                return CoreOp.invoke(methodDesc, builder, arg);\n@@ -155,0 +112,6 @@\n+        } else if (type.equals(JavaType.J_L_STRING)) {\n+            MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, type);\n+            return CoreOp.invoke(methodDesc, builder, arg);\n+        } else {\n+            MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, J_L_OBJECT);\n+            return CoreOp.invoke(methodDesc, builder, arg);\n@@ -156,11 +119,0 @@\n-        throw new RuntimeException(\"append requires a blessed StringBuilder as one Value argument\");\n-    }\n-\n-    private Value getConstant(Block.Builder builder, int con) {\n-        var val = IntConstants.get(con);\n-        if (val == null) {\n-            var constOp = CoreOp.constant(JavaType.INT, con);\n-            val = builder.op(constOp);\n-            IntConstants.put(0, val);\n-        }\n-        return val;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":57,"deletions":105,"binary":false,"changes":162,"status":"modified"}]}