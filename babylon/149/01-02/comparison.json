{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.*;\n@@ -41,3 +43,4 @@\n-    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n-    private static final JavaType CHAR_SEQ_TYPE = JavaType.type(CharSequence.class);\n-    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n+    private static final JavaType J_L_BYTESTRING = JavaType.type(StringBuilder.class);\n+    private static final JavaType J_L_CHARSEQUENCE = JavaType.type(CharSequence.class);\n+    private static final JavaType J_L_OBJECT = JavaType.type(Object.class);\n+    private static final MethodRef SB_TO_STRING = MethodRef.method(J_L_BYTESTRING, \"toString\", JavaType.J_L_STRING);\n@@ -45,1 +48,5 @@\n-    public StringConcatTransformer() {}\n+    final private Set<Value> StringBuilders = new HashSet<>();\n+    final private Map<Integer, Value> IntConstants = new HashMap<>();\n+\n+    public StringConcatTransformer() {\n+    }\n@@ -54,2 +61,1 @@\n-    @Override\n-    public Block.Builder apply(Block.Builder builder, Op op) {\n+    @Override public Block.Builder apply(Block.Builder builder, Op op) {\n@@ -76,1 +82,1 @@\n-    private static Value buildString(Block.Builder builder, Value sb){\n+    private Value buildString(Block.Builder builder, Value sb){\n@@ -81,3 +87,6 @@\n-    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n-        if (left.type().equals(SBC_TYPE)) {\n-            return builder.op(append(left, right));\n+    private Value stringBuilder(Block.Builder builder, Value left, Value right) {\n+        if (left.type().equals(J_L_BYTESTRING) && StringBuilders.contains(left)\n+                || right.type().equals(J_L_BYTESTRING) && StringBuilders.contains(right)) {\n+            var res = builder.op(append(builder, left, right));\n+            StringBuilders.add(res);\n+            return res;\n@@ -85,4 +94,61 @@\n-            CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n-            Value sb = builder.apply(newBuilder);\n-            var res = builder.op(append(sb, left));\n-            return builder.op(append(res, right));\n+            CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(J_L_BYTESTRING));\n+            Value sb = builder.op(newBuilder);\n+            StringBuilders.add(sb);\n+            var res = builder.op(append(builder, sb, left));\n+            StringBuilders.add(res);\n+            var res2 = builder.op(append(builder, res, right));\n+            StringBuilders.add(res2);\n+            return res2;\n+        }\n+    }\n+\n+    private Op append(Block.Builder builder, Value left, Value right) {\n+        \/\/Left argument is a blessed stringbuilder\n+        if (left.type().equals(J_L_BYTESTRING) && StringBuilders.contains(left)) {\n+            var rightType = right.type();\n+            if (rightType.equals(J_L_BYTESTRING)) {\n+                rightType = J_L_CHARSEQUENCE;\n+                MethodRef leftMethodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n+                return CoreOp.invoke(leftMethodDesc, left, right);\n+            }\n+\n+            if (rightType instanceof PrimitiveType) {\n+                if (List.of(JavaType.BYTE, JavaType.SHORT).contains(rightType)) {\n+                    Value widened = builder.op(CoreOp.conv(JavaType.INT, right));\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, JavaType.INT);\n+                    return CoreOp.invoke(methodDesc, left, widened);\n+                } else {\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n+                    return CoreOp.invoke(methodDesc, left, right);\n+                }\n+            } else if (rightType.equals(JavaType.J_L_STRING)) {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, rightType);\n+                return CoreOp.invoke(methodDesc, left, right);\n+            } else {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"append\", J_L_BYTESTRING, J_L_OBJECT);\n+                return CoreOp.invoke(methodDesc, left, right);\n+            }\n+        } else if (right.type().equals(J_L_BYTESTRING) && StringBuilders.contains(right)) {\n+            var leftType = left.type();\n+            var zero = getConstant(builder, 0);\n+            if (leftType.equals(J_L_BYTESTRING)) {\n+                leftType = J_L_CHARSEQUENCE;\n+                MethodRef leftMethodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n+                return CoreOp.invoke(leftMethodDesc, right, zero, left);\n+            }\n+            if (leftType instanceof PrimitiveType) {\n+                if (List.of(JavaType.BYTE, JavaType.SHORT).contains(leftType)) {\n+                    Value widened = builder.op(CoreOp.conv(JavaType.INT, left));\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, JavaType.INT);\n+                    return CoreOp.invoke(methodDesc, right, zero, widened);\n+                } else {\n+                    MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n+                    return CoreOp.invoke(methodDesc, right, zero, left);\n+                }\n+            } else if (leftType.equals(JavaType.J_L_STRING)) {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, leftType);\n+                return CoreOp.invoke(methodDesc, right, zero, left);\n+            } else {\n+                MethodRef methodDesc = MethodRef.method(J_L_BYTESTRING, \"insert\", J_L_BYTESTRING, JavaType.INT, J_L_OBJECT);\n+                return CoreOp.invoke(methodDesc, right, zero, left);\n+            }\n@@ -90,0 +156,1 @@\n+        throw new RuntimeException(\"append requires a blessed StringBuilder as one Value argument\");\n@@ -92,4 +159,6 @@\n-    private static Op append(Value stringBuilder, Value arg) {\n-        var argType = arg.type();\n-        if (argType.equals(SBC_TYPE)) {\n-            argType = CHAR_SEQ_TYPE;\n+    private Value getConstant(Block.Builder builder, int con) {\n+        var val = IntConstants.get(con);\n+        if (val == null) {\n+            var constOp = CoreOp.constant(JavaType.INT, con);\n+            val = builder.op(constOp);\n+            IntConstants.put(0, val);\n@@ -97,2 +166,1 @@\n-        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, argType);\n-        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n+        return val;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":88,"deletions":20,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+        model.writeTo(System.out);\n@@ -117,0 +118,4 @@\n+        model.writeTo(System.out);\n+        ssa_model.writeTo(System.out);\n+        ssa_transformed_model.writeTo(System.out);\n+\n@@ -196,1 +201,1 @@\n-    public static String intConcatNestedSplit(int i, String s){\n+    public static String intConcatNestedSplit(int i, String s) {\n@@ -202,1 +207,35 @@\n-}\n\\ No newline at end of file\n+    @CodeReflection\n+    public static String degenerateTree(String a, String b, String c, String d) {\n+        String s = (a + b) + (c + d);\n+        return s;\n+    }\n+\n+    \/\/This String Builder is getting tweaked, check for side effects\n+    @CodeReflection\n+    public static String degenerateTree2(String a, String d) {\n+        StringBuilder sb = new StringBuilder(\"test\");\n+        String s = sb + a;\n+        String t = s + d;\n+        System.out.println(sb);\n+        return t;\n+    }\n+\n+    @CodeReflection\n+    public static String degenerateTree4(String a, String b, String c, String d) {\n+        String s = ((a + b) + c) + d;\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String degenerateTree5(String a, String b, String c, String d) {\n+        String s = (a + (b + (c + d)));\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String widenPrimitives(short a, byte b, int c, int d) {\n+        String s = (a + (b + (c + d + \"hi\")));\n+        return s;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"}]}