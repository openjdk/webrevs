{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.*;\n@@ -41,4 +43,3 @@\n-    private static final JavaType SBC_TYPE = JavaType.type(StringBuilder.class);\n-    private static final MethodRef SB_TO_STRING = MethodRef.method(SBC_TYPE, \"toString\", JavaType.J_L_STRING);\n-\n-    record StringAndBuilder(Value string, Value stringBuilder) { }\n+    private static final JavaType J_L_STRING_BUILDER = JavaType.type(StringBuilder.class);\n+    private static final MethodRef SB_TO_STRING_REF = MethodRef.method(\n+            J_L_STRING_BUILDER, \"toString\", JavaType.J_L_STRING);\n@@ -49,2 +50,17 @@\n-    public Block.Builder apply(Block.Builder builder, Op op) {\n-        if (op instanceof CoreOp.ConcatOp cz) {\n+    public Block.Builder apply(Block.Builder block, Op op) {\n+        switch (op) {\n+            case CoreOp.ConcatOp cz when isRootConcat(cz) -> {\n+                \/\/ Create a string builder and build by traversing tree of operands\n+                Op.Result builder = block.apply(CoreOp._new(FunctionType.functionType(J_L_STRING_BUILDER)));\n+                buildFromTree(block, builder, cz);\n+                \/\/ Convert to string\n+                Value s = block.op(CoreOp.invoke(SB_TO_STRING_REF, builder));\n+                block.context().mapValue(cz.result(), s);\n+            }\n+            case CoreOp.ConcatOp _ -> {\n+                \/\/ Process later when building from root concat\n+            }\n+            default -> block.op(op);\n+        }\n+        return block;\n+    }\n@@ -52,2 +68,6 @@\n-            Value left = builder.context().getValue(cz.operands().get(0));\n-            Value right = builder.context().getValue(cz.operands().get(1));\n+    static boolean isRootConcat(CoreOp.ConcatOp cz) {\n+        \/\/ Root of concat tree, zero uses, two or more uses,\n+        \/\/ or one use that is not a subsequent concat op\n+        Set<Op.Result> uses = cz.result().uses();\n+        return uses.size() != 1 || !(uses.iterator().next().op() instanceof CoreOp.ConcatOp);\n+    }\n@@ -55,1 +75,5 @@\n-            Value result = cz.result();\n+    static void buildFromTree(Block.Builder block, Op.Result builder, CoreOp.ConcatOp cz) {\n+        \/\/ Process concat op's operands from left to right\n+        buildFromTree(block, builder, cz.operands().get(0));\n+        buildFromTree(block, builder, cz.operands().get(1));\n+    }\n@@ -57,2 +81,6 @@\n-            StringAndBuilder newRes = stringBuild(builder, left, right);\n-            builder.context().mapValue(result, newRes.string);\n+    static void buildFromTree(Block.Builder block, Op.Result builder, Value v) {\n+        if (v instanceof Op.Result r &&\n+                r.op() instanceof CoreOp.ConcatOp cz &&\n+                r.uses().size() == 1) {\n+            \/\/ Node of tree, recursively traverse the operands\n+            buildFromTree(block, builder, cz);\n@@ -60,1 +88,3 @@\n-            builder.op(op);\n+            \/\/ Leaf of tree, append value to builder\n+            \/\/ Note leaf can be the result of a ConcatOp with multiple uses\n+            block.op(append(block, builder, block.context().getValue(v)));\n@@ -62,1 +92,0 @@\n-        return builder;\n@@ -65,6 +94,2 @@\n-    \/\/Uses StringBuilder and Immediate String Value\n-    private static StringAndBuilder stringBuild(Block.Builder builder, Value left, Value right) {\n-        var newB = stringBuilder(builder, left, right);\n-        var toStringInvoke = CoreOp.invoke(SB_TO_STRING, newB);\n-        Value newString = builder.apply(toStringInvoke);\n-        return new StringAndBuilder(newString, newB);\n+    private static Op append(Block.Builder block, Value builder, Value arg) {\n+        return append(block, builder, arg, arg.type());\n@@ -73,6 +98,17 @@\n-    private static Value stringBuilder(Block.Builder builder, Value left, Value right) {\n-        CoreOp.NewOp newBuilder = CoreOp._new(FunctionType.functionType(SBC_TYPE));\n-        Value sb = builder.apply(newBuilder);\n-        builder.op(append(sb, left));\n-        builder.op(append(sb, right));\n-        return sb;\n+    private static Op append(Block.Builder block, Value builder, Value arg, TypeElement type) {\n+        \/\/ Check if we need to widen unsupported integer types in the StringBuilder API\n+        \/\/ Strings are fed in as-is, everything else given as an Object.\n+        TypeElement appendType = type;\n+        Value appendValue = arg;\n+        if (type instanceof PrimitiveType || type.equals(JavaType.J_L_STRING)) {\n+            \/\/Widen if we need to.\n+            if (type.equals(JavaType.BYTE) || type.equals(JavaType.SHORT)) {\n+                appendValue = block.op(CoreOp.conv(JavaType.INT, arg));\n+                appendType = JavaType.INT;\n+            }\n+        }\n+        else {\n+            appendType = JavaType.J_L_OBJECT;\n+        }\n+        MethodRef methodDesc = MethodRef.method(J_L_STRING_BUILDER, \"append\", J_L_STRING_BUILDER, appendType);\n+        return CoreOp.invoke(methodDesc, builder, appendValue);\n@@ -81,4 +117,0 @@\n-    private static Op append(Value stringBuilder, Value arg) {\n-        MethodRef leftMethodDesc = MethodRef.method(SBC_TYPE, \"append\", SBC_TYPE, arg.type());\n-        return CoreOp.invoke(leftMethodDesc, stringBuilder, arg);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":61,"deletions":29,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.util.List;\n@@ -82,0 +81,1 @@\n+        valMap.put(StringBuilder.class, new StringBuilder(\"test\"));\n@@ -100,0 +100,1 @@\n+        model.writeTo(System.out);\n@@ -111,0 +112,21 @@\n+        Object[] args = prepArgs(method);\n+        testStringConcat(method, args);\n+    }\n+\n+    \/\/Testing to make sure StringBuilders aren't caught up in the concat transformation\n+    @Test\n+    public void testStringBuilderUnchanged() {\n+        Method method;\n+\n+        try {\n+            method = TestStringConcatTransform.class.getMethod(\"stringBuilderArgCheck\", String.class, String.class, StringBuilder.class);\n+        } catch (NoSuchMethodException e) {\n+           throw new RuntimeException(e);\n+        }\n+        Object[] args = {\"Foo\", \"Bar\", new StringBuilder(\"test\")};\n+        testStringConcat(method, args);\n+\n+        Assert.assertEquals(\"test\", args[2].toString());\n+    }\n+\n+    private void testStringConcat(Method method, Object[] args) {\n@@ -115,1 +137,0 @@\n-        Object[] args = prepArgs(method);\n@@ -131,0 +152,1 @@\n+\n@@ -196,1 +218,1 @@\n-    public static String intConcatNestedSplit(int i, String s){\n+    public static String intConcatNestedSplit(int i, String s) {\n@@ -202,1 +224,41 @@\n-}\n\\ No newline at end of file\n+    @CodeReflection\n+    public static String nonLeftAssociativeTree(String a, String b, String c, String d) {\n+        String s = (a + b) + (c + d);\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String stringBuilderCheck(String a, String d) {\n+        StringBuilder sb = new StringBuilder(\"test\");\n+        String s = sb + a;\n+        String t = s + d;\n+        return t;\n+    }\n+\n+    @CodeReflection\n+    public static String stringBuilderArgCheck(String a, String d, StringBuilder c) {\n+        StringBuilder sb = c;\n+        String s = sb + a;\n+        String t = s + d;\n+        return t;\n+    }\n+\n+    @CodeReflection\n+    public static String leftAssociativeTree(String a, String b, String c, String d) {\n+        String s = ((a + b) + c) + d;\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String rightAssociativeTree(String a, String b, String c, String d) {\n+        String s = (a + (b + (c + d)));\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static String widenPrimitives(short a, byte b, int c, int d) {\n+        String s = (a + (b + (c + d + \"hi\")));\n+        return s;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":66,"deletions":4,"binary":false,"changes":70,"status":"modified"}]}