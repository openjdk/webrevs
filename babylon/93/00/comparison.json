{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include <cuda_runtime_api.h>\n@@ -29,0 +30,1 @@\n+\n@@ -30,1 +32,1 @@\n-: len(len), text(len > 0 ? new char[len] : nullptr) {}\n+        : len(len), text(len > 0 ? new char[len] : nullptr) {}\n@@ -37,0 +39,1 @@\n+\n@@ -41,11 +44,8 @@\n- Ptx *Ptx::nvcc(const char *cudaSource, size_t len) {\n-\n-     uint64_t time = timeSinceEpochMillisec();\n-     std::stringstream  timestampCuda;\n-     timestampCuda <<\".\/tmp\"<<time<<\".cu\";\n-     std::stringstream  timestampPtx;\n-     timestampPtx <<\".\/tmp\"<<time<<\".ptx\";\n-     std::stringstream  timestampStderr;\n-     timestampStderr <<\".\/tmp\"<<time<<\".stderr\";\n-     std::stringstream  timestampStdout;\n-     timestampStdout <<\".\/tmp\"<<time<<\".stdout\";\n+\n+Ptx *Ptx::nvcc(const char *cudaSource, size_t len) {\n+\n+    uint64_t time = timeSinceEpochMillisec();\n+    std::stringstream timestampCuda;\n+    timestampCuda << \".\/tmp\" << time << \".cu\";\n+    std::stringstream timestampPtx;\n+    timestampPtx << \".\/tmp\" << time << \".ptx\";\n@@ -55,4 +55,2 @@\n-    std::cout<<\"cuda \"<<cudaPath<<std::endl;\n-     std::cout<<\"ptx \"<<ptxPath<<std::endl;\n-   \/\/const char *stderrPath = timestampStderr.str().c_str();\n-   \/\/ const char *stdoutPath = timestampStdout.str().c_str();\n+    std::cout << \"cuda \" << cudaPath << std::endl;\n+    std::cout << \"ptx \" << ptxPath << std::endl;\n@@ -63,1 +61,1 @@\n-        cuda.open(cudaPath, std::ofstream::trunc | std::ofstream::trunc);\n+        cuda.open(cudaPath, std::ofstream::trunc);\n@@ -93,1 +91,1 @@\n-            ptx->text[ptx->len-1] = '\\0';\n+            ptx->text[ptx->len - 1] = '\\0';\n@@ -104,4 +102,9 @@\n-CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(void *ptr, size_t sizeInBytes)\n-        :Buffer(ptr,sizeInBytes) {\n-    std::cout<<\"cuMemAlloc()\"<<std::endl;\n-    cuMemAlloc(&devicePtr, (size_t) sizeInBytes);\n+CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(Backend::Program::Kernel *kernel, Arg_t *arg)\n+        : Buffer(kernel, arg) {\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n+    std::cout << \"cuMemAlloc()\" << std::endl;\n+    checkCudaErrors(cuMemAlloc(&devicePtr, (size_t) arg->value.buffer.sizeInBytes));\n+    arg->value.buffer.vendorPtr = static_cast<void *>(this);\n@@ -111,1 +114,1 @@\n-    std::cout<<\"cuMemFree()\"<<std::endl;\n+    std::cout << \"cuMemFree()\" << std::endl;\n@@ -114,0 +117,1 @@\n+\n@@ -115,2 +119,4 @@\n-    std::cout<<\"copyToDevice()\"<<std::endl;\n-    checkCudaErrors(cuMemcpyHtoD(devicePtr, ptr, sizeInBytes));\n+    std::cout << \"copyToDevice()\"\n+              << arg->value.buffer.sizeInBytes\n+              << std::endl;\n+    checkCudaErrors(cuMemcpyHtoD(devicePtr, arg->value.buffer.memorySegment, arg->value.buffer.sizeInBytes));\n@@ -118,0 +124,1 @@\n+\n@@ -119,2 +126,5 @@\n-    std::cout<<\"copyFromDevice()\"<<std::endl;\n-    checkCudaErrors(cuMemcpyDtoH(ptr, devicePtr, sizeInBytes));\n+    std::cout << \"copyFromDevice()\"\n+              << arg->value.buffer.sizeInBytes\n+              << std::endl;\n+    checkCudaErrors(cuMemcpyDtoH(arg->value.buffer.memorySegment, devicePtr, arg->value.buffer.sizeInBytes));\n+\n@@ -122,0 +132,1 @@\n+\n@@ -127,0 +138,1 @@\n+\n@@ -131,2 +143,2 @@\n-    \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n-    ArgSled argSled((ArgArray_t *) argArray);\n+    std::cout << \"ndrange(\" << range << \") \" << std::endl;\n+    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n@@ -141,4 +153,1 @@\n-                CudaBuffer *cudaBuffer = new CudaBuffer(\n-                        (void *) arg->value.buffer.memorySegment,\n-                        (size_t) arg->value.buffer.sizeInBytes);\n-                std::cout << \"copying out!\"<<std::endl;\n+                auto cudaBuffer = new CudaBuffer(this, arg);\n@@ -146,3 +155,2 @@\n-\n-                argslist[arg->idx] = (void *) &cudaBuffer->devicePtr;\n-                arg->value.buffer.vendorPtr = (void *) cudaBuffer;\n+                cudaError_t t = cudaDeviceSynchronize();\n+                argslist[arg->idx] = static_cast<void *>(&cudaBuffer->devicePtr);\n@@ -151,6 +159,7 @@\n-            case 'I': {\n-                argslist[arg->idx] = &arg->value.s32;\n-                break;\n-            }\n-            case 'F': {\n-                argslist[arg->idx] = &arg->value.f32;\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D':\n+            case 'C':\n+            case 'S': {\n+                argslist[arg->idx] = static_cast<void *>(&arg->value);\n@@ -167,3 +176,10 @@\n-#ifdef VERBOSE\n-    std::cout << \"Running the kernel... range = \"<< range << \"range mod 512 \" << (range%512)<< std::endl;\n-#endif\n+    int rangediv1024 = range \/ 1024;\n+    int rangemod1024 = range % 1024;\n+    if (rangemod1024 > 0) {\n+        rangediv1024++;\n+    }\n+    std::cout << \"Running the kernel...\" << std::endl;\n+    std::cout << \"   Requested range   = \" << range << std::endl;\n+    std::cout << \"   Range mod 1024    = \" << rangemod1024 << std::endl;\n+    std::cout << \"   Actual range 1024 = \" << (rangediv1024 * 1024) << std::endl;\n+\n@@ -172,1 +188,1 @@\n-                                   range \/ 1024, 1, 1,\n+                                   rangediv1024, 1, 1,\n@@ -177,1 +193,1 @@\n-    \/\/cudaError_t t = cudaDeviceSynchronize();\n+    cudaError_t t = cudaDeviceSynchronize();\n@@ -184,13 +200,3 @@\n-#ifdef VERBOSE\n-        std::cout << \"looking at ! \"<<arg->argc<<std::endl;\n-#endif\n-        switch (arg->variant) {\n-            case '&': {\n-                std::cout << \"copying back!\"<<std::endl;\n-                CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n-                cudaBuffer->copyFromDevice();\n-\n-                break;\n-            }\n-            default: {\n-            }\n+        if (arg->variant == '&') {\n+            static_cast<CudaBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n+            cudaError_t t = cudaDeviceSynchronize();\n@@ -202,16 +208,3 @@\n-        switch (arg->variant) {\n-            case '&': {\n-#ifdef VERBOSE\n-                std::cout << \"releasing arg \"<<arg->argc<< \" \"<<std::endl;\n-#endif\n-                CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n-\n-                delete cudaBuffer;\n-                break;\n-            }\n-            default: {\n-\n-            }\n-#ifdef VERBOSE\n-                std::cout << \"not releasing arg \"<<arg->idx<< \" \"<<std::endl;\n-#endif\n+        if (arg->variant == '&') {\n+            delete static_cast<CudaBuffer *>(arg->value.buffer.vendorPtr);\n+            arg->value.buffer.vendorPtr = nullptr;\n@@ -220,1 +213,0 @@\n-\n@@ -225,2 +217,1 @@\n-CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule\n-module)\n+CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule module)\n@@ -231,1 +222,0 @@\n-\n@@ -240,1 +230,1 @@\n-    return (long) new CudaKernel(this, function);\n+    return reinterpret_cast<long>(new CudaKernel(this, function));\n@@ -251,2 +241,2 @@\n-    std::cout << \"CudaBackend constructor\" << std::endl;\n-    CUresult err = cuInit(0);\n+    std::cout << \"CudaBackend constructor \" << ((cudaConfig == nullptr) ? \"cudaConfig== null\" : \"got cudaConfig\")\n+              << std::endl;\n@@ -254,0 +244,1 @@\n+    CUresult err = cuInit(0);\n@@ -256,0 +247,9 @@\n+        std::cout << \"CudaBackend device count\" << std::endl;\n+        checkCudaErrors(cuDeviceGet(&device, 0));\n+        std::cout << \"CudaBackend device ok\" << std::endl;\n+        checkCudaErrors(cuCtxCreate(&context, 0, device));\n+        std::cout << \"CudaBackend context created ok\" << std::endl;\n+    } else {\n+        std::cout << \"CudaBackend failed, we seem to have the runtime library but no device, no context, nada \"\n+                  << std::endl;\n+        exit(1);\n@@ -257,3 +257,0 @@\n-    checkCudaErrors(cuDeviceGet(&device, 0));\n-    checkCudaErrors(cuCtxCreate(&context, 0, device));\n-    std::cout << \"created context\" << std::endl;\n@@ -279,1 +276,1 @@\n-    cuDeviceGetName(name, 100, device);\n+    cuDeviceGetName(name, sizeof(name), device);\n@@ -319,1 +316,1 @@\n-        CUjit_option *jitOptions = new CUjit_option[jitNumOptions];\n+        auto jitOptions = new CUjit_option[jitNumOptions];\n@@ -324,1 +321,1 @@\n-        int jitLogBufferSize = 1024;\n+        int jitLogBufferSize = 8192;\n@@ -334,1 +331,1 @@\n-        return (long) new CudaProgram(this, nullptr, ptx, module);\n+        return reinterpret_cast<long>(new CudaProgram(this, nullptr, ptx, module));\n@@ -337,4 +334,4 @@\n-   } else {\n-       std::cout << \"no ptx content!\/\" << std::endl;\n-       exit(1);\n-   }\n+    } else {\n+        std::cout << \"no ptx content!\/\" << std::endl;\n+        exit(1);\n+    }\n@@ -344,3 +341,2 @@\n-    \/\/ Dynamic cast?\n-    CudaBackend::CudaConfig *cudaConfig = (CudaBackend::CudaConfig *) config;\n-    return (long) new CudaBackend(cudaConfig, configSchemaLen, configSchema);\n+    return reinterpret_cast<long>(new CudaBackend(static_cast<CudaBackend::CudaConfig *>(config), configSchemaLen,\n+                                                  configSchema));\n@@ -352,1 +348,3 @@\n-        std::cerr << \"CUDA Driver API error = \" << err << \" from file \" << file << \" line \" << line << std::endl;\n+        std::cerr << \"CUDA error = \" << err\n+                  <<\" \" << cudaGetErrorString(static_cast<cudaError_t>(err))\n+                  <<\" \" << file << \" line \" << line << std::endl;\n@@ -355,1 +353,69 @@\n-}\n\\ No newline at end of file\n+}\n+\n+const char *CudaBackend::errorMsg(CUresult status) {\n+    static struct {\n+        CUresult code;\n+        const char *msg;\n+    } error_table[] = {\n+            {CUDA_SUCCESS, \"success\"},\n+            \/\/ {CL_DEVICE_NOT_FOUND,                \"device not found\",},\n+            \/\/   {CL_DEVICE_NOT_AVAILABLE,            \"device not available\",},\n+            \/\/   {CL_COMPILER_NOT_AVAILABLE,          \"compiler not available\",},\n+            \/\/   {CL_MEM_OBJECT_ALLOCATION_FAILURE,   \"mem object allocation failure\",},\n+            \/\/   {CL_OUT_OF_RESOURCES,                \"out of resources\",},\n+            \/\/   {CL_OUT_OF_HOST_MEMORY,              \"out of host memory\",},\n+            \/\/   {CL_PROFILING_INFO_NOT_AVAILABLE,    \"profiling not available\",},\n+            \/\/   {CL_MEM_COPY_OVERLAP,                \"memcopy overlaps\",},\n+            \/\/   {CL_IMAGE_FORMAT_MISMATCH,           \"image format mismatch\",},\n+            \/\/   {CL_IMAGE_FORMAT_NOT_SUPPORTED,      \"image format not supported\",},\n+            \/\/   {CL_BUILD_PROGRAM_FAILURE,           \"build program failed\",},\n+            \/\/   {CL_MAP_FAILURE,                     \"map failed\",},\n+            \/\/   {CL_INVALID_VALUE,                   \"invalid value\",},\n+            \/\/   {CL_INVALID_DEVICE_TYPE,             \"invalid device type\",},\n+            \/\/   {CL_INVALID_PLATFORM,                \"invlaid platform\",},\n+            \/\/   {CL_INVALID_DEVICE,                  \"invalid device\",},\n+            \/\/   {CL_INVALID_CONTEXT,                 \"invalid context\",},\n+            \/\/   {CL_INVALID_QUEUE_PROPERTIES,        \"invalid queue properties\",},\n+            \/\/   {CL_INVALID_COMMAND_QUEUE,           \"invalid command queue\",},\n+            \/\/   {CL_INVALID_HOST_PTR,                \"invalid host ptr\",},\n+            \/\/   {CL_INVALID_MEM_OBJECT,              \"invalid mem object\",},\n+            \/\/   {CL_INVALID_IMAGE_FORMAT_DESCRIPTOR, \"invalid image format descriptor \",},\n+            \/\/   {CL_INVALID_IMAGE_SIZE,              \"invalid image size\",},\n+            \/\/   {CL_INVALID_SAMPLER,                 \"invalid sampler\",},\n+            \/\/   {CL_INVALID_BINARY,                  \"invalid binary\",},\n+            \/\/   {CL_INVALID_BUILD_OPTIONS,           \"invalid build options\",},\n+            \/\/   {CL_INVALID_PROGRAM,                 \"invalid program \",},\n+            \/\/   {CL_INVALID_PROGRAM_EXECUTABLE,      \"invalid program executable\",},\n+            \/\/   {CL_INVALID_KERNEL_NAME,             \"invalid kernel name\",},\n+            \/\/   {CL_INVALID_KERNEL_DEFINITION,       \"invalid definition\",},\n+            \/\/   {CL_INVALID_KERNEL,                  \"invalid kernel\",},\n+            \/\/   {CL_INVALID_ARG_INDEX,               \"invalid arg index\",},\n+            \/\/   {CL_INVALID_ARG_VALUE,               \"invalid arg value\",},\n+            \/\/   {CL_INVALID_ARG_SIZE,                \"invalid arg size\",},\n+            \/\/   {CL_INVALID_KERNEL_ARGS,             \"invalid kernel args\",},\n+            \/\/   {CL_INVALID_WORK_DIMENSION,          \"invalid work dimension\",},\n+            \/\/   {CL_INVALID_WORK_GROUP_SIZE,         \"invalid work group size\",},\n+            \/\/   {CL_INVALID_WORK_ITEM_SIZE,          \"invalid work item size\",},\n+            \/\/   {CL_INVALID_GLOBAL_OFFSET,           \"invalid global offset\",},\n+            \/\/   {CL_INVALID_EVENT_WAIT_LIST,         \"invalid event wait list\",},\n+            \/\/   {CL_INVALID_EVENT,                   \"invalid event\",},\n+            \/\/   {CL_INVALID_OPERATION,               \"invalid operation\",},\n+            \/\/   {CL_INVALID_GL_OBJECT,               \"invalid gl object\",},\n+            \/\/   {CL_INVALID_BUFFER_SIZE,             \"invalid buffer size\",},\n+            \/\/  {CL_INVALID_MIP_LEVEL,               \"invalid mip level\",},\n+            \/\/   {CL_INVALID_GLOBAL_WORK_SIZE,        \"invalid global work size\",},\n+            {(CUresult) 0, nullptr},\n+    };\n+    static char unknown[256];\n+    int ii;\n+\n+    for (ii = 0; error_table[ii].msg != NULL; ii++) {\n+        if (error_table[ii].code == status) {\n+            \/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n+            return error_table[ii].msg;\n+        }\n+    }\n+    SNPRINTF(unknown, sizeof(unknown), \"unknown error %d\", status);\n+    return unknown;\n+}\n+\n","filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","additions":165,"deletions":99,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+\n@@ -72,0 +73,1 @@\n+\n@@ -73,0 +75,1 @@\n+\n@@ -85,1 +88,1 @@\n-        class CudaBuffer: public Backend::Program::Kernel::Buffer {\n+            class CudaBuffer : public Backend::Program::Kernel::Buffer {\n@@ -87,1 +90,0 @@\n-\n@@ -90,1 +92,2 @@\n-                CudaBuffer(void *ptr, size_t sizeInBytes);\n+                CudaBuffer(Backend::Program::Kernel *kernel, Arg_t *arg);\n+\n@@ -92,0 +95,1 @@\n+\n@@ -93,0 +97,1 @@\n+\n@@ -126,0 +131,1 @@\n+\n@@ -127,0 +133,1 @@\n+\n@@ -135,0 +142,2 @@\n+    static const char *errorMsg(CUresult status);\n+\n","filename":"hat\/backends\/cuda\/include\/cuda_backend.h","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,2 +27,6 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(void *ptr, size_t sizeInBytes, cl_context context)\n-        : Backend::Program::Kernel::Buffer(ptr, sizeInBytes) {\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_t *arg)\n+        : Backend::Program::Kernel::Buffer(kernel, arg) {\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n@@ -30,1 +34,12 @@\n-    clMem = clCreateBuffer(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeInBytes, ptr, &status);\n+    auto openclBackend = dynamic_cast<OpenCLBackend *>(kernel->program->backend);\n+    clMem = clCreateBuffer(openclBackend->context,\n+                           CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE,\n+                           arg->value.buffer.sizeInBytes,\n+                           arg->value.buffer.memorySegment,\n+                           &status);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    arg->value.buffer.vendorPtr = static_cast<void *>(this);\n+    std::cout << \"created buffer \" << std::endl;\n@@ -32,0 +47,1 @@\n+\n@@ -34,0 +50,25 @@\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n+    auto openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    auto openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n+    cl_int status = clEnqueueWriteBuffer(openclBackend->command_queue,\n+                                         clMem,\n+                                         CL_FALSE,\n+                                         0,\n+                                         arg->value.buffer.sizeInBytes,\n+                                         arg->value.buffer.memorySegment,\n+                                         openclKernel->eventc,\n+                                         ((openclKernel->eventc == 0) ? NULL : openclKernel->events),\n+                                         &(openclKernel->events[openclKernel->eventc]));\n+\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+\n+    openclKernel->eventc++;\n+    std::cout << \"enqueued buffer copyToDevice \" << std::endl;\n+\n@@ -35,1 +76,0 @@\n-void OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::copyFromDevice() {\n@@ -37,0 +77,19 @@\n+void OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::copyFromDevice() {\n+    auto openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n+    auto openclBackend = dynamic_cast<OpenCLBackend *>(openclKernel->program->backend);\n+    cl_int status = clEnqueueReadBuffer(openclBackend->command_queue,\n+                                        clMem,\n+                                        CL_FALSE,\n+                                        0,\n+                                        arg->value.buffer.sizeInBytes,\n+                                        arg->value.buffer.memorySegment,\n+                                        openclKernel->eventc,\n+                                        ((openclKernel->eventc == 0) ? NULL : openclKernel->events),\n+                                        &(openclKernel->events[openclKernel->eventc]));\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    openclKernel->eventc++;\n+    std::cout << \"enqueued buffer copyFromDevice \" << std::endl;\n@@ -38,0 +97,1 @@\n+\n@@ -43,1 +103,2 @@\n-        : Backend::Program::Kernel(program), kernel(kernel) {\n+        : Backend::Program::Kernel(program), kernel(kernel), eventMax(0), events(nullptr),\n+          eventc(0) {\n@@ -51,10 +112,2 @@\n-    \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n-    ArgSled argSled((ArgArray_t *) argArray);\n-    cl_int status;\n-    OpenCLBackend *backend = (OpenCLBackend *) program->backend;\n-\n-    bool verbose = false;\n-\n-    \/\/ std::cout << \"allocing events \"<< ((argSled.argc()*3)+1)<< std::endl;\n-\n-    backend->allocEvents(argSled.argc() * 3 + 1);\n+    std::cout << \"ndrange(\" << range << \") \" << std::endl;\n+    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n@@ -62,0 +115,6 @@\n+    if (events != nullptr || eventc != 0) {\n+        std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n+    }\n+    eventMax = argSled.argc() * 4 + 1;\n+    eventc = 0;\n+    events = new cl_event[eventMax];\n@@ -64,11 +123,45 @@\n-\n-        if (arg->variant == '&') {\n-            arg->value.buffer.vendorPtr = new OpenCLBuffer(\n-                    (void *) arg->value.buffer.memorySegment,\n-                    (size_t) arg->value.buffer.sizeInBytes,\n-                    backend->context);\n-            OpenCLBuffer *clbuf = ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n-            if ((status = clEnqueueWriteBuffer(backend->command_queue, clbuf->clMem, CL_FALSE, 0, clbuf->sizeInBytes, clbuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n-                    &(backend->events[backend->eventc]))) !=\n-                CL_SUCCESS) {\n-                std::cerr << \"write failed!\" << errorMsg(status) << std::endl;\n+        switch (arg->variant) {\n+            case '&': {\n+                auto openclBuffer = new OpenCLBuffer(this, arg);\n+                openclBuffer->copyToDevice();\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set buffer arg \" << arg->idx << std::endl;\n+                break;\n+            }\n+            case 'I':\n+            case 'F': {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x32), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set I or F arg \" << arg->idx << std::endl;\n+                break;\n+            }\n+            case 'S':\n+            case 'C': {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x16), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set S or C arg \" << arg->idx << std::endl;\n+                break;\n+            }\n+            case 'J':\n+            case 'D': {\n+                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(arg->value.x64), (void *) &arg->value);\n+                if (status != CL_SUCCESS) {\n+                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+                    exit(1);\n+                }\n+                std::cout << \"set J or D arg \" << arg->idx << std::endl;\n+                break;\n+            }\n+            default: {\n+                std::cout << \"unexpected variant \" << (char) arg->variant << std::endl;\n+                exit(1);\n@@ -76,7 +169,0 @@\n-            backend->eventc++;\n-            clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &((OpenCLBuffer *) arg->value.buffer.vendorPtr)->clMem);\n-\n-        } else if (arg->variant == 'I') {\n-            clSetKernelArg(kernel, arg->idx, sizeof(arg->value.s32), (void *) &arg->value.s32);\n-        } else if (arg->variant == 'F') {\n-            clSetKernelArg(kernel, arg->idx, sizeof(arg->value.f32), (void *) &arg->value.f32);\n@@ -85,0 +171,1 @@\n+\n@@ -87,2 +174,2 @@\n-    if ((status = clEnqueueNDRangeKernel(\n-            backend->command_queue,\n+    cl_int status = clEnqueueNDRangeKernel(\n+            dynamic_cast<OpenCLBackend *>(program->backend)->command_queue,\n@@ -94,3 +181,8 @@\n-            backend->eventc,\n-            ((backend->eventc == 0) ? nullptr : backend->events),\n-            &(backend->events[backend->eventc]))) != CL_SUCCESS) {\n+            eventc,\n+            ((eventc == 0) ? nullptr : events),\n+            &(events[eventc]));\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    std::cout << \"enqueued dispatch  \" << std::endl;\n@@ -98,1 +190,1 @@\n-        std::cout <<  \" globalSize=\" << globalSize << \" \" << error(status) << std::endl;\n+    std::cout <<  \" globalSize=\" << globalSize << \" \" << error(status) << std::endl;\n@@ -100,2 +192,2 @@\n-    }\n-    backend->eventc++;\n+\n+    eventc++;\n@@ -104,1 +196,0 @@\n-\n@@ -106,8 +197,1 @@\n-            OpenCLBuffer *clBuf = ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n-            if ((status = clEnqueueReadBuffer(backend->command_queue, clBuf->clMem, CL_FALSE, 0,\n-                    clBuf->sizeInBytes, clBuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n-                    &(backend->events[backend->eventc]))) !=\n-                CL_SUCCESS) {\n-                std::cout << \"read failed!\";\n-            }\n-            backend->eventc++;\n+            static_cast<OpenCLBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n@@ -116,1 +200,16 @@\n-    backend->waitForEvents();\n+    status = clWaitForEvents(eventc, events);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    for (int i = 0; i < eventc; i++) {\n+        status = clReleaseEvent(events[i]);\n+        if (status != CL_SUCCESS) {\n+            std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+            exit(1);\n+        }\n+    }\n+    delete[] events;\n+    eventMax = 0;\n+    eventc = 0;\n+    events = nullptr;\n@@ -120,1 +219,2 @@\n-            delete ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n+            delete static_cast<OpenCLBuffer *>(arg->value.buffer.vendorPtr);\n+            arg->value.buffer.vendorPtr = nullptr;\n@@ -123,1 +223,0 @@\n-    backend->releaseEvents();\n@@ -147,1 +246,1 @@\n-        : Backend((Backend::Config *) openclConfig, configSchemaLen, configSchema), eventMax(0), events(nullptr), eventc(0) {\n+        : Backend((Backend::Config *) openclConfig, configSchemaLen, configSchema) {\n@@ -155,1 +254,2 @@\n-    cl_device_type requestedType = openclConfig == nullptr ? CL_DEVICE_TYPE_GPU : openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n+    cl_device_type requestedType =\n+            openclConfig == nullptr ? CL_DEVICE_TYPE_GPU : openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n@@ -193,1 +293,2 @@\n-    if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL || status != CL_SUCCESS) {\n+    if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL ||\n+        status != CL_SUCCESS) {\n@@ -214,24 +315,1 @@\n-void OpenCLBackend::allocEvents(int max) {\n-    if (events != nullptr || eventc != 0) {\n-        std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n-    }\n-    eventMax = max;\n-    eventc = 0;\n-    events = new cl_event[eventMax];\n-}\n-\n-void OpenCLBackend::releaseEvents() {\n-    for (int i = 0; i < eventc; i++) {\n-        clReleaseEvent(events[i]);\n-    }\n-    delete[] events;\n-    eventMax = 0;\n-    eventc = 0;\n-    events = nullptr;\n-}\n-\n-void OpenCLBackend::waitForEvents() {\n-    clWaitForEvents(eventc, events);\n-}\n-\n-void OpenCLBackend::showEvents(int width) {\n+void OpenCLBackend::OpenCLProgram::OpenCLKernel::showEvents(int width) {\n@@ -260,1 +338,2 @@\n-            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) != CL_SUCCESS) {\n+            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n+                CL_SUCCESS) {\n@@ -315,1 +394,5 @@\n-    clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n+    cl_int status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n@@ -317,0 +400,1 @@\n+\n@@ -323,1 +407,2 @@\n-    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName, NULL);\n+    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName,\n+                               NULL);\n@@ -359,1 +444,2 @@\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions), &maxWorkItemDimensions, NULL);\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions),\n+                             &maxWorkItemDimensions, NULL);\n@@ -363,1 +449,2 @@\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions,\n+                             maxWorkItemSizes, NULL);\n@@ -369,2 +456,4 @@\n-    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL);\n-    fprintf(stderr, \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \" Size_tNewline, maxWorkGroupSize);\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize,\n+                             NULL);\n+    fprintf(stderr, \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \"\n+    Size_tNewline, maxWorkGroupSize);\n@@ -374,1 +463,2 @@\n-    fprintf(stderr, \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \" LongUnsignedNewline, maxMemAllocSize);\n+    fprintf(stderr, \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \"\n+    LongUnsignedNewline, maxMemAllocSize);\n@@ -378,1 +468,2 @@\n-    fprintf(stderr, \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \" LongUnsignedNewline, globalMemSize);\n+    fprintf(stderr, \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \"\n+    LongUnsignedNewline, globalMemSize);\n@@ -382,1 +473,2 @@\n-    fprintf(stderr, \"         CL_DEVICE_LOCAL_MEM_SIZE........... \" LongUnsignedNewline, localMemSize);\n+    fprintf(stderr, \"         CL_DEVICE_LOCAL_MEM_SIZE........... \"\n+    LongUnsignedNewline, localMemSize);\n@@ -421,1 +513,2 @@\n-    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr || status != CL_SUCCESS) {\n+    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr ||\n+        status != CL_SUCCESS) {\n@@ -442,1 +535,2 @@\n-            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log, nullptr)) != CL_SUCCESS) {\n+            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log,\n+                                                nullptr)) != CL_SUCCESS) {\n@@ -458,1 +552,1 @@\n-    return (long) new OpenCLProgram(this, buildInfo, program);\n+    return reinterpret_cast<long>(new OpenCLProgram(this, buildInfo, program));\n@@ -513,1 +607,1 @@\n-            {0, NULL},\n+            {0,                                  NULL},\n@@ -520,1 +614,1 @@\n-\/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n+            \/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n@@ -530,2 +624,3 @@\n-    \/\/ Dynamic cast?\n-    OpenCLBackend::OpenCLConfig *openclConfig = (OpenCLBackend::OpenCLConfig *) config;\n+    return reinterpret_cast<long>(new OpenCLBackend(static_cast<OpenCLBackend::OpenCLConfig *>(config), configSchemaLen,\n+                                                    configSchema));\n+}\n@@ -533,1 +628,5 @@\n-    return (long) new OpenCLBackend(openclConfig, configSchemaLen, configSchema);\n+void __checkOpenclErrors(cl_int status, const char *file, const int line) {\n+    if (CL_SUCCESS != status) {\n+        std::cerr << \"Opencl Driver API error = \" << cl_int << \" from file \" << file << \" line \" << line << std::endl;\n+        exit(-1);\n+    }\n","filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","additions":197,"deletions":98,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\n@@ -38,0 +39,1 @@\n+\n@@ -50,0 +52,1 @@\n+\n@@ -52,0 +55,4 @@\n+extern void __checkOpenclErrors(cl_int status, const char *file, const int line);\n+\n+#define checkOpenCLErrors(err)  __checkOpenclErrors (err, __FILE__, __LINE__)\n+\n@@ -57,1 +64,0 @@\n-        boolean junk;\n@@ -63,1 +69,1 @@\n-        class OpenCLBuffer : public Backend::Program::Kernel::Buffer {\n+            class OpenCLBuffer : public Backend::Program::Kernel::Buffer {\n@@ -65,1 +71,0 @@\n-\n@@ -67,0 +72,1 @@\n+\n@@ -68,0 +74,1 @@\n+\n@@ -69,1 +76,2 @@\n-                OpenCLBuffer(void *ptr, size_t sizeInBytes, cl_context context);\n+\n+                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_t *arg);\n@@ -76,0 +84,9 @@\n+            size_t eventMax;\n+            cl_event *events;\n+            size_t eventc;\n+        protected:\n+            \/\/ void allocEvents(int max);\n+            \/\/ void releaseEvents();\n+            \/\/ void waitForEvents();\n+            void showEvents(int width);\n+\n@@ -102,3 +119,1 @@\n-    size_t eventMax;\n-    cl_event *events;\n-    size_t eventc;\n+\n@@ -118,9 +133,0 @@\n-protected:\n-\n-    void allocEvents(int max);\n-\n-    void releaseEvents();\n-\n-    void waitForEvents();\n-\n-    void showEvents(int width);\n","filename":"hat\/backends\/opencl\/include\/opencl_backend.h","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    u16_t x16;  \/\/ 'C' or 'S\"\n@@ -90,0 +91,1 @@\n+    s32_t x32;  \/\/ 'I' or 'F'\n@@ -93,0 +95,1 @@\n+    s64_t x64; \/\/ 'D' or 'J'\n@@ -99,1 +102,1 @@\n-    u8_t pad1[8];\n+    u8_t pad8[8];\n@@ -101,1 +104,1 @@\n-    u8_t pad[6];\n+    u8_t pad6[6];\n@@ -106,1 +109,1 @@\n-    u8_t pad[12];\n+    u8_t pad12[12];\n@@ -174,9 +177,0 @@\n-    \/*  void *vendorPtr(){\n-        char *cptr = (char*)vendorPtrPtr();\n-        char *cptr2 =  (char*)cptr[0];\n-        return (void*)cptr2;\n-        }\n-\n-        void vendorPtr(void *vendorPtr){\n-     *vendorPtrPtr() =vendorPtr;\n-     } *\/\n@@ -487,2 +481,2 @@\n-                void *ptr;\n-                size_t sizeInBytes;\n+                Kernel *kernel;\n+                Arg_t *arg;\n@@ -491,1 +485,1 @@\n-                Buffer(void *ptr, size_t sizeInBytes):ptr(ptr), sizeInBytes(sizeInBytes) {\n+                Buffer(Kernel *kernel, Arg_t *arg):kernel(kernel),arg(arg){\n","filename":"hat\/backends\/shared\/include\/shared.h","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+        if (kc.x <kc.maxX){\n@@ -104,0 +105,1 @@\n+        }\n@@ -114,0 +116,1 @@\n+        if (kc.x <kc.maxX){\n@@ -118,0 +121,1 @@\n+        }\n@@ -265,10 +269,10 @@\n-            if (stillLooksLikeAFace) {\n-                int index = resultTable.atomicResultTableCountInc();\n-                if (index < resultTable.length()) {\n-                    ResultTable.Result result = resultTable.result(index);\n-                    result.x(x);\n-                    result.y(y);\n-                    result.width(w);\n-                    result.height(h);\n-                }\n-            }\n+           \/\/ if (stillLooksLikeAFace) {\n+            \/\/    int index = resultTable.atomicResultTableCountInc();\n+              \/\/  if (index < resultTable.length()) {\n+               \/\/     ResultTable.Result result = resultTable.result(index);\n+                \/\/    result.x(x);\n+                 \/\/   result.y(y);\n+                  \/\/  result.width(w);\n+                   \/\/ result.height(h);\n+              \/\/  }\n+           \/\/ }\n@@ -310,1 +314,1 @@\n-        ResultTable resultTable = ResultTable.create(accelerator, 1000);\n+        ResultTable resultTable = ResultTable.create(accelerator, 10000);\n@@ -314,1 +318,1 @@\n-        for (int i = 0; i < 10; i++) {\n+        for (int i = 0; i < 1; i++) {\n@@ -319,0 +323,1 @@\n+            System.out.println(\"results = \"+resultTable.atomicResultTableCount());\n","filename":"hat\/examples\/violajones\/src\/java\/violajones\/ViolaJonesCompute.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+            System.out.println(\"requesting dispatch range \"+ndRange.kid.maxX);\n","filename":"hat\/hat\/src\/java\/hat\/backend\/C99NativeBackend.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}