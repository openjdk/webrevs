{"files":[{"patch":"","filename":"hat\/.help","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/hat\/help","status":"copied"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.analysis.SSA;\n@@ -53,2 +55,0 @@\n-import static optkl.OpTkl.SSATransform;\n-import static optkl.OpTkl.lower;\n@@ -419,1 +419,1 @@\n-            CoreOp.FuncOp loweredFunc = lower(here, funcOp);\n+            CoreOp.FuncOp loweredFunc = funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -424,1 +424,1 @@\n-        CoreOp.FuncOp lowered = lower(here, kernelCallGraph.entrypoint.funcOp());\n+        CoreOp.FuncOp lowered = kernelCallGraph.entrypoint.funcOp().transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -442,1 +442,1 @@\n-        return transform(here, func,(block, op) -> {\n+        return transform(here, func,_->true,(block, op) -> {\n@@ -473,2 +473,1 @@\n-        var here = CallSite.of(CudaBackend.class, \"createFucntion\" );\n-        CoreOp.FuncOp ssa = SSATransform(here, lowered);\n+         CoreOp.FuncOp ssa =SSA.transform(lowered);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.CodeTransformer;\n@@ -59,1 +60,0 @@\n-import static optkl.OpTkl.lower;\n@@ -72,1 +72,1 @@\n-                    lower(CallSite.of(FFIBackend.class), computeContext.computeEntrypoint().funcOp());\n+                    computeContext.computeEntrypoint().funcOp().transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -140,1 +140,1 @@\n-            transformedFuncOp = transform(here, computeMethod.funcOp(),(bldr, op) -> {\n+            transformedFuncOp = transform(here, computeMethod.funcOp(),_->true,(bldr, op) -> {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.CodeTransformer;\n@@ -55,1 +56,0 @@\n-import static optkl.OpTkl.lower;\n@@ -68,1 +68,1 @@\n-                    lower(here, computeContext.computeEntrypoint().funcOp());\n+                    computeContext.computeEntrypoint().funcOp().transform(CodeTransformer.LOWERING_TRANSFORMER);\n@@ -94,1 +94,1 @@\n-        var transformedFuncOp = transform(here,computeMethod.funcOp(),(bldr, op) -> {\n+        var transformedFuncOp = transform(here,computeMethod.funcOp(),_->true, (bldr, op) -> {\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.analysis.SSA;\n@@ -43,0 +44,1 @@\n+import static optkl.OpTkl.lower;\n@@ -94,1 +96,1 @@\n-        CoreOp.FuncOp ssaFunc = OpTkl.SSATransformLower(here, f); \/\/ do we need this nesting?\n+        CoreOp.FuncOp ssaFunc =  SSA.transform(lower(here,f)) ;\/\/ OpTkl.SSATransformLower(here, f); \/\/ do we need this nesting?\n@@ -98,0 +100,1 @@\n+\n@@ -110,1 +113,1 @@\n-                            CoreOp.FuncOp ssaInline = OpTkl.SSATransformLower(here, inline);\n+                            CoreOp.FuncOp ssaInline =SSA.transform(lower(here,inline));\/\/OpTkl.SSATransformLower(here, inline);\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend;\n-\n-import hat.ComputeContext;\n-import hat.Config;\n-import hat.KernelContext;\n-import hat.callgraph.KernelCallGraph;\n-import hat.callgraph.KernelEntrypoint;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.bytecode.BytecodeGenerator;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import optkl.util.CallSite;\n-\n-import static optkl.OpTkl.SSATransform;\n-import static optkl.OpTkl.SSATransformLower;\n-import static optkl.OpTkl.lower;\n-\n-public class DebugBackend extends BackendAdaptor {\n-    public enum HowToRunCompute{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE}\n-    public HowToRunCompute howToRunCompute=HowToRunCompute.REFLECT;\n-    public enum HowToRunKernel{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE, LOWER_TO_SSA,LOWER_TO_SSA_AND_MAP_PTRS}\n-    HowToRunKernel howToRunKernel = HowToRunKernel.LOWER_TO_SSA_AND_MAP_PTRS;\n-\n-    public DebugBackend(Arena arena, MethodHandles.Lookup lookup){\n-       this(arena,lookup,HowToRunCompute.REFLECT, HowToRunKernel.REFLECT);\n-    }\n-\n-    public DebugBackend(Arena arena,MethodHandles.Lookup lookup,HowToRunCompute howToRunCompute, HowToRunKernel howToRunKernel){\n-\n-        super(arena,lookup,Config.fromEnvOrProperty());\n-        this.howToRunCompute = howToRunCompute;\n-        this.howToRunKernel = howToRunKernel;\n-    }\n-\n-    @Override\n-    public void dispatchCompute(ComputeContext computeContext, Object... args) {\n-        var here = CallSite.of(DebugBackend.class,\"dispatchCompute\");\n-        switch (howToRunCompute){\n-\n-            case REFLECT: {\n-                try {\n-                    computeContext.computeCallGraph().entrypoint.method.invoke(null, args);\n-                } catch (IllegalAccessException | InvocationTargetException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                break;\n-            }\n-            case BABYLON_INTERPRETER:{\n-                if (computeContext.computeCallGraph().entrypoint.lowered == null) {\n-                    computeContext.computeCallGraph().entrypoint.lowered = lower(here, computeContext.computeEntrypoint().funcOp());\n-                }\n-                Interpreter.invoke(computeContext.lookup(), computeContext.computeEntrypoint().lowered, args);\n-                break;\n-            }\n-            case BABYLON_CLASSFILE:{\n-                if (computeContext.computeEntrypoint().lowered == null) {\n-                    computeContext.computeEntrypoint().lowered = lower(here, computeContext.computeEntrypoint().funcOp());\n-                }\n-                try {\n-                    if (computeContext.computeEntrypoint().mh == null) {\n-                        computeContext.computeEntrypoint().mh = BytecodeGenerator.generate(computeContext.lookup(), computeContext.computeEntrypoint().lowered);\n-                    }\n-                    computeContext.computeEntrypoint().mh.invokeWithArguments(args);\n-                } catch (Throwable e) {\n-                    System.out.println(computeContext.computeEntrypoint().lowered.toText());\n-                    throw new RuntimeException(e);\n-                }\n-                break;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, KernelContext kernelContext, Object... args) {\n-\n-        var here = CallSite.of(DebugBackend.class, \"dispatchKernel\");\n-        switch (howToRunKernel){\n-            case REFLECT: {\n-                KernelEntrypoint kernelEntrypoint = kernelCallGraph.entrypoint;\n-                for (kernelContext.gix = 0; kernelContext.gix < kernelContext.gsx; kernelContext.gix++) {\n-                    try {\n-                        args[0] = kernelContext;\n-                        kernelEntrypoint.method.invoke(null, args);\n-                    } catch (IllegalAccessException e) {\n-                        throw new RuntimeException(e);\n-                    } catch (InvocationTargetException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-                break;\n-            }\n-            case BABYLON_INTERPRETER:{\n-                var lowered = lower(here, kernelCallGraph.entrypoint.funcOp());\n-                Interpreter.invoke(kernelCallGraph.lookup(), lowered, args);\n-                break;\n-            }\n-            case BABYLON_CLASSFILE:{\n-                var lowered = lower(here, kernelCallGraph.entrypoint.funcOp());\n-                var mh = BytecodeGenerator.generate(kernelCallGraph.lookup(), lowered);\n-                try {\n-                    mh.invokeWithArguments(args);\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-                break;\n-            }\n-\n-            case LOWER_TO_SSA:{\n-                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n-\n-\n-                System.out.println(\"Initial code model\");\n-                System.out.println(highLevelForm.toText());\n-                System.out.println(\"------------------\");\n-                System.out.println(\"TRANSFORM dispatchKernel\"+ DebugBackend.class);\n-                CoreOp.FuncOp loweredForm = lower(here, highLevelForm);\n-                System.out.println(\"Lowered form which maintains original invokes and args\");\n-                System.out.println(loweredForm.toText());\n-                System.out.println(\"-------------- ----\");\n-                System.out.println(\"TRANSFORM dispatchKernel\"+DebugBackend.class);\n-\n-                CoreOp.FuncOp ssaInvokeForm = SSATransform(here, loweredForm);\n-                System.out.println(\"SSA form which maintains original invokes and args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-            }\n-\n-            case LOWER_TO_SSA_AND_MAP_PTRS:{\n-                var highLevelForm = Op.ofMethod(kernelCallGraph.entrypoint.method).orElseThrow();\n-                System.out.println(\"Initial code model\");\n-                System.out.println(highLevelForm.toText());\n-                System.out.println(\"------------------\");\n-                CoreOp.FuncOp loweredForm = lower(here, highLevelForm);\n-                System.out.println(\"Lowered form which maintains original invokes and args\");\n-                System.out.println(loweredForm.toText());\n-                System.out.println(\"-------------- ----\");\n-                CoreOp.FuncOp ssaInvokeForm = SSATransformLower(here, loweredForm);\n-                System.out.println(\"SSA form which maintains original invokes and args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-            }\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -111,0 +111,5 @@\n+    private final ScopedCodeBuilderContext scopedCodeBuilderContext;\n+    public JavaHATCodeBuilder(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp){\n+        super();\n+        scopedCodeBuilderContext= new ScopedCodeBuilderContext(lookup,funcOp);\n+    }\n@@ -112,2 +117,1 @@\n-    public String toText(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n-        var scopedCodeBuilderContext = new ScopedCodeBuilderContext(lookup,funcOp);\n+    public String toText() {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static boolean isKernelContext(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+    private static boolean isKernelContext(MethodHandles.Lookup lookup, TypeElement typeElement) {\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/KernelContextPattern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-public class PatternSelector {\n-    Set<CodeModelPattern> codeModelPatterns = new LinkedHashSet<>();\n-    public PatternSelector add(CodeModelPattern codeModelPattern){\n-        codeModelPatterns.add(codeModelPattern);\n-        return this;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/PatternSelector.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,452 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import optkl.util.CallSite;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-\n-import static optkl.OpTkl.copyLocation;\n-import static optkl.OpTkl.operandOrNull;\n-import static optkl.OpTkl.opstream;\n-\n-public class Trxfmr {\n-    interface HATTransformerCarrier{\n-        Trxfmr hatTransformer();\n-    }\n-    interface CursorCarrier<T extends Cursor>{\n-        T cursor();\n-    }\n-\n-    public interface  Walker extends HATTransformerCarrier {\n-        void op(Op op);\n-        Op op();\n-        void funcOp(CoreOp.FuncOp funcOp);\n-        CoreOp.FuncOp funcOp();\n-              class Impl implements  HATTransformerCarrier,Walker {\n-                private final Trxfmr trxfmr;\n-                public Trxfmr hatTransformer() {\n-                    return trxfmr;\n-                }\n-                private Op op;\n-                private CoreOp.FuncOp funcOp;\n-                @Override\n-                public void op(Op op) {\n-                    this.op = op;\n-                }\n-\n-                @Override\n-                public Op op() {\n-                    return this.op;\n-                }\n-\n-                @Override\n-                public void funcOp(CoreOp.FuncOp funcOp) {\n-                    this.funcOp = funcOp;\n-                }\n-\n-                @Override\n-                public CoreOp.FuncOp funcOp() {\n-                    return this.funcOp;\n-                }\n-\n-                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp) {\n-                    this.trxfmr = trxfmr;\n-                    this.funcOp = funcOp;\n-                }\n-            }\n-        static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n-            return new Impl(trxfmr,funcOp);\n-        }\n-    }\n-\n-    public interface  Cursor extends HATTransformerCarrier, Walker {\n-        enum Action{NONE,REMOVED,REPLACE,ADDED };\n-        void action(Action action);\n-        Action action();\n-        void builder(Block.Builder builder);\n-        Block.Builder builder();\n-        void handled(boolean handled);\n-        boolean handled();\n-        Op.Result replace(Op op, Consumer<Mapper<?>> mapperConsumer);\n-        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n-        default Op.Result replace(Op op){\n-            return replace(op, _->{});\n-        }\n-         static  <T extends Op> Constructor<T> getConstructorOrNull(Class<T> clazz, Class<?> ... classes){\n-            try {\n-                return clazz.getDeclaredConstructor(classes);\n-            }catch (NoSuchMethodException nsm){\n-                return null;\n-            }\n-         }\n-        static  <T extends Op> T createOrNull(Constructor<T> constructor, Object ... args){\n-            try {\n-                return constructor.newInstance(args);\n-            }catch (InstantiationException | IllegalAccessException | InvocationTargetException e){\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-        default <T extends Op> Op.Result add(Function<List<Value>,T> factory, Value...operands){\n-            T instance = factory.apply(Stream.of(operands).map(operand -> builder().context().getValue(operand)).toList());\n-            return add(instance);\n-        }\n-        \/*\n-        default <T extends Op> Op.Result add(Class<T> clazz, Value ...operands){\n-                    if (getConstructorOrNull(clazz,List.class) instanceof Constructor<T> constructor) {\n-                        Op instance = createOrNull(constructor, Stream.of(operands).map(operand -> builder().context().getValue(operand)).toList());\n-                        return add(instance);\n-                    } else if (getConstructorOrNull(clazz,Value.class,Value.class) instanceof Constructor<T> constructor){\n-                      \/\/  Op instance = createOrNull(constructor, builder().context().getValue(operands[0]),builder().context().getValue(operands[1]));\n-                       \/\/ if (constructor.trySetAccessible()) {\n-                       \/\/ constructor.setAccessible(true);\n-                            Op instance = createOrNull(constructor, operands[0], operands[1]);\n-                            return add(instance);\n-                       \/\/ }else{\n-                         \/\/   throw new RuntimeException(\"can't construct \"+clazz.getSimpleName());\n-                       \/\/ }\n-                    } else{\n-                        throw new RuntimeException(\"can't handle this arity\");\n-                    }\n-        } *\/\n-\n-        default Op.Result add(Op op){\n-            return add(op, _->{});\n-        }\n-         default void remove(Consumer<Mapper<?>> mapperConsumer) {\n-            mapperConsumer.accept(Mapper.of(this));\n-        }\n-        default void remove() {\n-            remove(_->{});\n-        }\n-        default Op.Result remove(Op op){\n-            return replace(op, (m)->{});\n-        }\n-        static Cursor of(Trxfmr trxfmr, CoreOp.FuncOp funcOp, Block.Builder builder, Op op){\n-            class Impl extends Walker.Impl implements Cursor {\n-                private Action action;\n-                private Block.Builder builder;\n-                private boolean handled;\n-                @Override\n-                public void handled(boolean handled) {\n-                    this.handled = handled;\n-                }\n-\n-                @Override\n-                public boolean  handled() {\n-                    return this.handled;\n-                }\n-\n-                @Override\n-                public void action(Action action) {\n-                    this.action=action;\n-                }\n-\n-                @Override\n-                public Action action() {\n-                    return action;\n-                }\n-\n-                @Override\n-                public void builder(Block.Builder builder) {\n-                    this.builder = builder;\n-                }\n-\n-                @Override\n-                public Block.Builder builder() {\n-                    return this.builder;\n-                }\n-                @Override\n-                public Op.Result replace(Op replacement, Consumer<Mapper<?>> mapperConsumer) {\n-                    handled(true);\n-                    action(Action.REPLACE);\n-                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), replacement)));\n-                    if (result.type() instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n-                    }else {\n-                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n-                    }\n-                    return result;\n-                }\n-                public Op.Result add(Op newOne, Consumer<Mapper<?>> mapperConsumer) {\n-                    handled(true);\n-                    action(Action.ADDED);\n-                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), newOne)));\n-                    if (result.type() instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n-                    }else{\n-                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n-                    }\n-                    return result;\n-                }\n-                @Override\n-                public void remove( Consumer<Mapper<?>> mapperConsumer) {\n-                    handled(true);\n-                    action(Action.REMOVED);\n-                }\n-                Impl(Trxfmr hatTransformer, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n-                    super(hatTransformer,funcOp);\n-                    builder(builder);\n-                    op(op);\n-                }\n-            }\n-            return new Impl(trxfmr,funcOp, builder,op);\n-        }\n-\n-        default Value getValue(Value value){\n-            return builder().context().getValue(value);\n-        }\n-\n-        default Value operandNValue(int idx){\n-            return getValue(operandOrNull(op(),idx));\n-        }\n-    }\n-\n-    public interface Selector<T extends Selector<T>> extends HATTransformerCarrier{\n-        default T  select(Op...ops){\n-            hatTransformer().selected.addAll(List.of(ops));\n-            return (T)this;\n-        }\n-       static Selector<?> of(Trxfmr trxfmr){\n-            record SelectorImpl(Trxfmr hatTransformer) implements Selector<SelectorImpl>{}\n-            return  new SelectorImpl(trxfmr);\n-        }\n-    }\n-\n-\n-    public interface Mapper<T extends Mapper<T>> extends CursorCarrier{\n-        default  T map(Value from, Value to) {\n-            cursor().builder().context().mapValue(from, to);\n-            return (T)this;\n-        }\n-        default  T map(Op fromOp, Value to) {\n-            map(fromOp.result(), to);\n-            return (T)this;\n-        }\n-        default  T mapOperand(Op fromOp, List<Value> operands, int n) {\n-           return map(fromOp,operands.get(n));\n-        }\n-        default  T mapOperands(Op fromOp, List<Value> operands) {\n-            operands.forEach(v -> {\n-                map(fromOp,v);\n-            });\n-            return (T)this;\n-        }\n-        default  T mapOperands(Op fromOp, Op to) {\n-            return mapOperands(fromOp,to.operands());\n-        }\n-        default  T mapOperand(Op fromOp, Op to, int index) {\n-            return map(fromOp,to.operands().get(index));\n-        }\n-        static Mapper<?> of(Cursor cursor){\n-            record MapperImpl(Cursor cursor) implements Mapper<MapperImpl> { }\n-            return new MapperImpl(cursor);\n-        }\n-    }\n-\n-    public final Set<Op> selected = new LinkedHashSet<>();\n-    public final Map<Op, Op> opmap = new HashMap<>();\n-    public final CallSite callSite;\n-    public CoreOp.FuncOp funcOp;\n-\n-    public CoreOp.FuncOp funcOp(){\n-        return funcOp;\n-    }\n-    public CoreOp.FuncOp funcOp(CoreOp.FuncOp funcOp){\n-        return this.funcOp=funcOp;\n-    }\n-\n-    public Trxfmr(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        this.callSite = callSite;\n-        this.funcOp =  funcOp;\n-        if (callSite!=null && callSite.tracing()) {\n-            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() + \"]: \" + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-\n-    public Trxfmr(CoreOp.FuncOp funcOp) {\n-        this (null,funcOp);\n-\n-    }\n-    public Trxfmr select(Predicate<Op> codeElementPredicate, BiConsumer<Selector<?>,Op> selectorConsumer) {\n-        Selector<?> selector = Selector.of(this);\n-        funcOp().elements().filter(ce->ce instanceof Op).map(ce->(Op)ce).filter(codeElementPredicate).forEach(op->\n-                selectorConsumer.accept(selector,op)\n-        );\n-        return this;\n-    }\n-\n-\n-    public Trxfmr done() {\n-        if (callSite!=null && callSite.tracing()) {\n-            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() + \"]: \" + System.lineSeparator()\n-                    +funcOp().toText());\n-        }\n-        return this;\n-    }\n-\n-\n-\n-    private Op opToOp(Op from, Op to){\n-        opmap.put(from,to);\n-        return to;\n-    }\n-    private Op.Result opToResultOp(Op from, Op.Result result){\n-        opToOp(from, result.op());\n-        return result;\n-    }\n-\n-  \/\/  private void update(){\n-    \/\/    opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n-   \/\/ }\n-\n-\n-    public Trxfmr transform(Predicate<Op> predicate, Consumer<Cursor> cursorConsumer) {\n-        if (callSite != null && callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        var newFuncOp = funcOp().transform((blockBuilder, op) -> {\n-            Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n-            cursor.builder(blockBuilder);\n-            cursor.op(op);\n-            cursor.handled(false);\n-            cursor.action(Cursor.Action.NONE);\n-            boolean isEmpty = selected.isEmpty();\n-            boolean isInSelected = selected.contains(op);\n-            boolean isSelected = isEmpty|isInSelected;\n-            boolean passesPredicate = predicate.test(op);\n-            if (isSelected && passesPredicate) {\n-                cursorConsumer.accept(cursor);\n-                if (!cursor.handled()){\n-                    opToOp(op,cursor.builder().op(op).op());\n-                }\n-            } else {\n-                opToOp(op,cursor.builder().op(op).op());\n-            }\n-            return blockBuilder;\n-        });\n-        funcOp(newFuncOp);\n-     \/\/   update();\n-        return this;\n-    }\n-    public Trxfmr transform(Edge.Selector<?,?> selector,Consumer<Cursor> transformer) {\n-        return transform(selector::contains,transformer);\n-    }\n-    public Trxfmr transform(Consumer<Cursor> transformer) {\n-        return transform(_->true,transformer);\n-    }\n-\n-    public Trxfmr transform(Predicate<Op> predicate, CodeTransformer codeTransformer) {\n-        if (callSite != null && callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        var currentFuncOp = funcOp();\n-        var newFuncOp = currentFuncOp.transform((blockBuilder, op) -> {\n-            Cursor cursor = Cursor.of(this,funcOp,blockBuilder,op);\n-            if ((selected.isEmpty() || selected.contains(op)) &&  predicate.test(op)) {\n-                codeTransformer.acceptOp(cursor.builder(),op);\n-            } else {\n-                opToOp(op,cursor.builder().op(op).op());\n-            }\n-            return cursor.builder();\n-        });\n-        opmap.put(currentFuncOp, newFuncOp);\n-        funcOp(newFuncOp);\n-        opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n-        return this;\n-    }\n-\n-    public Trxfmr transform(CodeTransformer codeTransformer ) {\n-        if (callSite != null && callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        funcOp(funcOp().transform(codeTransformer));\n-        return this;\n-    }\n-\n-\n-    public interface Edge<F extends Op, T extends Op> {\n-        F f();\n-\n-        T t();\n-\n-        Set<Op> ops();\n-\n-\n-\n-         class Selector<F extends Op, T extends Op> {\n-            Map<F, Edge<F, T>> fromMap = new HashMap<>();\n-            Map<T, Edge<F, T>> toMap = new HashMap<>();\n-\n-            public Selector<F, T> add(Edge<F, T> edge) {\n-                fromMap.put(edge.f(), edge);\n-                toMap.put(edge.t(), edge);\n-                return this;\n-            }\n-\n-            Edge<F, T> from(F f) {\n-                return fromMap.get(f);\n-            }\n-\n-            Edge<F, T> to(T t) {\n-                return toMap.get(t);\n-            }\n-\n-            Predicate<Op> predicate =op->fromMap.containsKey((F) op) || toMap.containsKey((T) op);\n-\n-            public boolean contains(Op op) {\n-                return predicate.test(op);\n-            }\n-\n-             public Selector<F, T> select(CoreOp.FuncOp funcOp, Function<CodeElement<?,?>,Edge<F,T>> mapper) {\n-                 opstream(funcOp,mapper).forEach(e->this.add((Edge<F, T>) e));\n-                 return this;\n-             }\n-\n-             public CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Consumer<Cursor> c) {\n-                 return new Trxfmr(CallSite.of(this.getClass()), funcOp)\n-                         .transform(this.predicate,c).done().funcOp();\n-             }\n-         }\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":0,"deletions":452,"binary":false,"changes":452,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.optools.KernelContextPattern;\n@@ -31,2 +30,3 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n+import optkl.InvokeOpHelper;\n+import optkl.Trxfmr;\n+import java.util.List;\n@@ -34,3 +34,1 @@\n-import java.util.Objects;\n-\n-import static optkl.OpTkl.simpleOpMappingTransform;\n+import static optkl.InvokeOpHelper.invokeOpHelper;\n@@ -39,1 +37,0 @@\n-\n@@ -42,12 +39,6 @@\n-        var here = CallSite.of(HATBarrierPhase.class, \"apply\");\n-        before(here, fromFuncOp);\n-        OpTkl.OpMap opMap = simpleOpMappingTransform(\n-                \/* for debugging we will remove *\/ here,\n-                                                   fromFuncOp,\n-                \/* filter op                    *\/ ce -> Objects.nonNull(\n-                                                         KernelContextPattern.KernelContextInvokePattern.matches(lookup(), ce,\n-                                                         invokeOp->invokeOp.invokeDescriptor().name().equals(HATBarrierOp.NAME))),\n-                \/* replace op                   *\/ HATBarrierOp::new\n-        );\n-        after(here, opMap.toFuncOp());\n-        return opMap.toFuncOp();\n+        return Trxfmr.of(fromFuncOp)\n+                .transform(\n+                        \/* predicate *\/     ce-> invokeOpHelper(lookup(),ce) instanceof InvokeOpHelper $&&$ .named(HATBarrierOp.NAME),\n+                        \/* transformation *\/c-> c.replace(new HATBarrierOp(List.of())\n+                        ))\n+                .funcOp();\n@@ -55,1 +46,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n@@ -234,1 +234,1 @@\n-            funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+            funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.optools.Trxfmr;\n+import optkl.Trxfmr;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n@@ -322,1 +322,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n@@ -409,1 +409,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n@@ -455,1 +455,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n@@ -177,1 +177,1 @@\n-        funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-           funcOp = transform(here, funcOp, (blockBuilder, op) -> {\n+           funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.optools.Trxfmr;\n+import optkl.Trxfmr;\n@@ -45,1 +45,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -47,1 +46,0 @@\n-import java.util.ArrayList;\n@@ -51,0 +49,2 @@\n+import static optkl.InvokeOpHelper.invokeOpHelper;\n+\n@@ -190,1 +190,1 @@\n-             c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.operandNValue(0)));\n+             c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand(0)));\n@@ -195,0 +195,1 @@\n+        \/\/ We need to remove our injected ops from the model to execute\n@@ -196,2 +197,3 @@\n-        var javaCodeBuilder = new JavaHATCodeBuilder<>();\n-        System.out.println(javaCodeBuilder.toText(lookup,trxfmr.funcOp()));\n+\n+        var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,trxfmr.funcOp());\n+        System.out.println(javaCodeBuilder.toText());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        var transformed = transform(here, funcOp,(builder, op) -> {\n+        var transformed = transform(here, funcOp,_->true,(builder, op) -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,500 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-\n-import optkl.util.CallSite;\n-import optkl.ifacemapper.Schema;\n-import optkl.ifacemapper.Buffer;\n-import optkl.ifacemapper.MappableIface;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.foreign.*;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.extern.ExternalizedTypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.core.CoreType;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-\n-import java.util.*;\n-import java.util.stream.Stream;\n-\n-import static optkl.OpTkl.SSATransform;\n-\n-public class LayoutExample {\n-\n-    \/*\n-       struct {\n-          StructTwo struct;\n-          int i;\n-       }\n-     *\/\n-\n-        public interface Outer extends Buffer {\n-            interface Inner extends Struct {\n-                int i();\n-\n-                void i(int v);\n-\n-                float f();\n-\n-                void f(float v);\n-\n-              \/\/  Schema schema = Schema.of(Inner.class, b->b.primitive(\"i\").primitive(\"f\"));\n-            }\n-\n-            Inner right();\n-            Inner left();\n-            int i();\n-            void i(int v);\n-\n-\n-            Schema schema = Schema.of(Outer.class, b->b\n-                            .struct(\"left\", left->left\n-                                    .field(\"i\")\n-                                    .field(\"f\")\n-                            )\n-                           \/\/ .struct(\"right\", Inner.schema)\n-                            .field(\"i\")\n-            );\n-        }\n-\n-\n-    @Reflect\n-    static float m(Outer s1) {\n-        \/\/ StructOne* s1\n-        \/\/ s1 -> i\n-        int i = s1.i();\n-        \/\/ s1 -> *s2\n-        Outer.Inner s2 = s1.left();\n-        \/\/ s2 -> i\n-        i += s2.i();\n-        \/\/ s2 -> f\n-        float f = s2.f();\n-        return i + f;\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        var lookup =     MethodHandles.lookup();\n-        Optional<Method> om = Stream.of(LayoutExample.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(\"m\"))\n-                .findFirst();\n-\n-        Method m = om.orElseThrow();\n-        CoreOp.FuncOp f= Op.ofMethod(m).orElseThrow();\n-        var here = CallSite.of(LayoutExample.class, \"main\");\n-        f = SSATransform(here, f);\n-        System.out.println(f.toText());\n-        FunctionType functionType = transformStructClassToPtr(lookup, f);\n-        System.out.println(f.toText());\n-        CoreOp.FuncOp pm = transformInvokesToPtrs(lookup, f, functionType);\n-        System.out.println(pm.toText());\n-    }\n-    static FunctionType transformStructClassToPtr(MethodHandles.Lookup l,\n-                                                CoreOp.FuncOp f) {\n-        List<TypeElement> pTypes = new ArrayList<>();\n-        for (Block.Parameter p : f.parameters()) {\n-            pTypes.add(transformStructClassToPtr(l, p.type()));\n-        }\n-        return CoreType.functionType(\n-                transformStructClassToPtr(l, f.invokableType().returnType()), pTypes);\n-    }\n-\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n-                                                CoreOp.FuncOp f, FunctionType functionType) {\n-\n-        var builder= CoreOp.func(f.funcName(), functionType);\n-\n-        var funcOp = builder.body(funcBlock -> {\n-            funcBlock.body(f.body(), funcBlock.parameters(), (b, op) -> {\n-                if (op instanceof JavaOp.InvokeOp invokeOp\n-                        && invokeOp.hasReceiver()\n-                        && invokeOp.operands().getFirst() instanceof Value receiver) {\n-                    if (bufferOrBufferChildClass(l, receiver.type()) != null) {\n-                        Value ptr = b.context().getValue(receiver);\n-                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, invokeOp.invokeDescriptor().name());\n-                        Op.Result memberPtr = b.op(ptrToMemberOp);\n-\n-                        if (invokeOp.operands().size() == 1) {\n-                            \/\/ Pointer access and (possibly) value load\n-                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n-                                Op.Result v = b.op(new PtrLoadValue(memberPtr));\n-                                b.context().mapValue(invokeOp.result(), v);\n-                            } else {\n-                                b.context().mapValue(invokeOp.result(), memberPtr);\n-                            }\n-                        } else {\n-                            \/\/ @@@\n-                            \/\/ Value store\n-                            throw new UnsupportedOperationException();\n-                        }\n-                    } else {\n-                        b.op(op);\n-                    }\n-                } else {\n-                    b.op(op);\n-                }\n-                return b;\n-            });\n-        });\n-        return funcOp;\n-    }\n-\n-\n-\n-    static boolean isBufferOrBufferChild(Class<?> maybeIface) {\n-        return  maybeIface.isInterface() && (\n-                MappableIface.class.isAssignableFrom(maybeIface)\n-        );\n-\n-    }\n-    static Schema bufferOrBufferChildSchema(MethodHandles.Lookup l, Class<?> maybeBufferOrBufferChild) {\n-        if (isBufferOrBufferChild(maybeBufferOrBufferChild)) {\n-            throw new IllegalArgumentException();\n-        }\n-        Field schemaField;\n-        try {\n-            schemaField = maybeBufferOrBufferChild.getField(\"schema\");\n-           return  (Schema)schemaField.get(null);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    static Class<?> bufferOrBufferChildClass(MethodHandles.Lookup l, TypeElement t) {\n-        try {\n-            if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n-                return null;\n-            }\n-            return isBufferOrBufferChild(c) ? c : null;\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n-        if (bufferOrBufferChildClass(l, type) instanceof Class<?> sc) {\n-            return new PtrType(bufferOrBufferChildSchema(l, sc));\n-        } else {\n-            return type;\n-        }\n-    }\n-\n-    public static final class PtrType implements TypeElement {\n-        static final String NAME = \"ptr\";\n-        MemoryLayout layout;\n-        Schema schema;\n-        final JavaType returnType;\n-\n-        public PtrType(MemoryLayout layout) {\n-            this.layout = layout;\n-            this.returnType = switch (layout) {\n-                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n-                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n-                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            };\n-        }\n-        public PtrType(Schema schema) {\n-            this.schema = schema;\n-            this.layout= null;\/\/schema.layout();\n-            this.returnType = switch (layout) {\n-                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n-                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n-                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            };\n-        }\n-\n-        public JavaType returnType() {\n-            return returnType;\n-        }\n-\n-        public MemoryLayout layout() {\n-            return layout;\n-        }\n-        public Schema schema() {\n-            return schema;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            PtrType ptrType = (PtrType) o;\n-            return Objects.equals(layout, ptrType.layout);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(layout);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(returnType.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-\n-    public static final class PtrToMember extends Op {\n-        public static final String NAME = \"ptr.to.member\";\n-        public static final String ATTRIBUTE_OFFSET = \"offset\";\n-        public static final String ATTRIBUTE_NAME = \"name\";\n-\n-        final String simpleMemberName;\n-        final long memberOffset;\n-        final PtrType resultType;\n-\n-        PtrToMember(PtrToMember that, CodeContext cc) {\n-            super(that, cc);\n-            this.simpleMemberName = that.simpleMemberName;\n-            this.memberOffset = that.memberOffset;\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public PtrToMember transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrToMember(this, cc);\n-        }\n-\n-        public PtrToMember(Value ptr, String simpleMemberName) {\n-            super(List.of(ptr));\n-            this.simpleMemberName = simpleMemberName;\n-\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            \/\/ @@@ Support group layout\n-            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n-            }\n-\n-            \/\/ Find the actual member name from the simple member name\n-            String memberName = findMemberName(structLayout, simpleMemberName);\n-            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n-            this.memberOffset = structLayout.byteOffset(p);\n-            MemoryLayout memberLayout = structLayout.select(p);\n-            \/\/ Remove any simple member name from the layout\n-            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n-                    ? memberLayout.withName(className(memberName))\n-                    : memberLayout.withoutName();\n-            this.resultType = new PtrType(ptrLayout);\n-        }\n-\n-        \/\/ @@@ Change to return member index\n-        static String findMemberName(StructLayout sl, String simpleMemberName) {\n-            for (MemoryLayout layout : sl.memberLayouts()) {\n-                String memberName = layout.name().orElseThrow();\n-                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n-                    return memberName;\n-                }\n-            }\n-            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n-        }\n-\n-        static String simpleMemberName(String memberName) {\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(i + 2)\n-                    : memberName;\n-        }\n-\n-        static String className(String memberName) {\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(0, i)\n-                    : null;\n-        }\n-\n-        @Override\n-        public PtrType resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        @Override\n-        public Map<String, Object> externalize() {\n-            return Map.of(\n-                    \"\", simpleMemberName,\n-                    ATTRIBUTE_OFFSET, memberOffset);\n-        }\n-\n-        public String simpleMemberName() {\n-            return simpleMemberName;\n-        }\n-\n-        public long memberOffset() {\n-            return memberOffset;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-    }\n-\n-\n-    public static final class PtrAddOffset extends Op {\n-        public static final String NAME = \"ptr.add.offset\";\n-\n-        PtrAddOffset(PtrAddOffset that, CodeContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PtrAddOffset transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrAddOffset(this, cc);\n-        }\n-\n-        public PtrAddOffset(Value ptr, Value offset) {\n-            super(List.of(ptr, offset));\n-\n-            if (!(ptr.type() instanceof PtrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n-                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return ptrValue().type();\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-\n-        public Value offsetValue() {\n-            return operands().get(1);\n-        }\n-    }\n-\n-    public static final class PtrLoadValue extends Op {\n-        public static final String NAME = \"ptr.load.value\";\n-\n-        final JavaType resultType;\n-\n-        PtrLoadValue(PtrLoadValue that, CodeContext cc) {\n-            super(that, cc);\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public PtrLoadValue transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrLoadValue(this, cc);\n-        }\n-\n-        public PtrLoadValue(Value ptr) {\n-            super(List.of(ptr));\n-\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            this.resultType = ptrType.returnType();\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-    }\n-\n-    public static final class PtrStoreValue extends Op {\n-        public static final String NAME = \"ptr.store.value\";\n-\n-        PtrStoreValue(PtrStoreValue that, CodeContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PtrStoreValue transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrStoreValue(this, cc);\n-        }\n-\n-        public PtrStoreValue(Value ptr, Value v) {\n-            super(List.of(ptr));\n-\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            if (!(ptrType.returnType().equals(v.type()))) {\n-                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n-                        + ptrType.returnType() + \" \" + v.type());\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-    }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":0,"deletions":500,"binary":false,"changes":500,"status":"deleted"},{"patch":"@@ -1,520 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import java.lang.constant.ClassDesc;\n-import java.lang.foreign.*;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.dialect.core.CoreType;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import jdk.incubator.code.extern.ExternalizedTypeElement;\n-import optkl.util.CallSite;\n-\n-import java.util.*;\n-import java.util.stream.Stream;\n-\n-import static optkl.OpTkl.SSATransform;\n-\n-public class RawLayout {\n-\n-    \/*\n-    struct {\n-      StructTwo struct;\n-      int i;\n-    }\n-     *\/\n-    @Struct\n-    public interface StructOne {\n-        StructTwo struct();\n-\n-        int i();\n-\n-        void i(int v);\n-\n-        static MemoryLayout layout() {\n-            return LAYOUT;\n-        }\n-\n-        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                        StructTwo.layout().withName(StructTwo.layout().name().orElseThrow() + \"::struct\"),\n-                        ValueLayout.JAVA_INT.withName(\"i\"))\n-                \/\/ Symbolic reference to interface\n-                \/\/ @@@ Use externalized type element form?\n-                .withName(\"layouts.LayoutExample$StructOne\");\n-    }\n-\n-    \/*\n-    struct {\n-      int i;\n-      float f;\n-    }\n-     *\/\n-    @Struct\n-    public interface StructTwo {\n-        int i();\n-\n-        void i(int v);\n-\n-        float f();\n-\n-        void f(float v);\n-\n-        static MemoryLayout layout() {\n-            return LAYOUT;\n-        }\n-\n-        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                        ValueLayout.JAVA_INT.withName(\"i\"),\n-                        ValueLayout.JAVA_FLOAT.withName(\"f\"))\n-                \/\/ Symbolic reference to interface\n-                \/\/ @@@ Use externalized type element form?\n-                .withName(\"layouts.LayoutExample$StructTwo\");\n-    }\n-\n-    @Reflect\n-    static float m(StructOne s1) {\n-        \/\/ StructOne* s1\n-        \/\/ s1 -> i\n-        int i = s1.i();\n-        \/\/ s1 -> *s2\n-        StructTwo s2 = s1.struct();\n-        \/\/ s2 -> i\n-        i += s2.i();\n-        \/\/ s2 -> f\n-        float f = s2.f();\n-        return i + f;\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        CoreOp.FuncOp m = getFuncOp(\"m\");\n-        var here = CallSite.of(RawLayout.class, \"main\");\n-        m = SSATransform(here, m);\n-        System.out.println(m.toText());\n-\n-        CoreOp.FuncOp pm = transformInvokesToPtrs(lookup, m);\n-        System.out.println(pm.toText());\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(LayoutExample.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return Op.ofMethod(m).get();\n-    }\n-\n-    \/\/\n-\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Struct {\n-    }\n-\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n-                                                CoreOp.FuncOp f) {\n-        List<TypeElement> pTypes = new ArrayList<>();\n-        for (Block.Parameter p : f.parameters()) {\n-            pTypes.add(transformStructClassToPtr(l, p.type()));\n-        }\n-        FunctionType functionType = CoreType.functionType(\n-                transformStructClassToPtr(l, f.invokableType().returnType()),\n-                pTypes);\n-        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n-            funcBlock.body(f.body(), funcBlock.parameters(), (b, op) -> {\n-                if (op instanceof JavaOp.InvokeOp iop && iop.hasReceiver()) {\n-                    Value receiver = iop.operands().getFirst();\n-                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n-                        Value ptr = b.context().getValue(receiver);\n-                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n-                        Op.Result memberPtr = b.op(ptrToMemberOp);\n-\n-                        if (iop.operands().size() == 1) {\n-                            \/\/ Pointer access and (possibly) value load\n-                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n-                                Op.Result v = b.op(new PtrLoadValue(memberPtr));\n-                                b.context().mapValue(iop.result(), v);\n-                            } else {\n-                                b.context().mapValue(iop.result(), memberPtr);\n-                            }\n-                        } else {\n-                            \/\/ @@@\n-                            \/\/ Value store\n-                            throw new UnsupportedOperationException();\n-                        }\n-                    } else {\n-                        b.op(op);\n-                    }\n-                } else {\n-                    b.op(op);\n-                }\n-                return b;\n-            });\n-        });\n-    };\n-\n-\n-    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n-        if (structClass(l, type) instanceof Class<?> sc) {\n-            return new PtrType(structClassLayout(l, sc));\n-        } else {\n-            return type;\n-        }\n-    }\n-\n-    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n-                                          Class<?> c) {\n-        if (!c.isAnnotationPresent(Struct.class)) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        Method layoutMethod;\n-        try {\n-            layoutMethod = c.getMethod(\"layout\");\n-        } catch (NoSuchMethodException e) {\n-            throw new RuntimeException(e);\n-        }\n-        MethodHandle layoutHandle;\n-        try {\n-            layoutHandle = l.unreflect(layoutMethod);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-        try {\n-            return (MemoryLayout) layoutHandle.invoke();\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n-        try {\n-            return _structClass(l, t);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n-            return null;\n-        }\n-\n-        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n-    }\n-\n-\n-    public static final class PtrType implements TypeElement {\n-        static final String NAME = \"ptr\";\n-        final MemoryLayout layout;\n-        final JavaType rType;\n-\n-        public PtrType(MemoryLayout layout) {\n-            this.layout = layout;\n-            this.rType = switch (layout) {\n-                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n-                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n-                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            };\n-        }\n-\n-        public JavaType rType() {\n-            return rType;\n-        }\n-\n-        public MemoryLayout layout() {\n-            return layout;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            PtrType ptrType = (PtrType) o;\n-            return Objects.equals(layout, ptrType.layout);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(layout);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-\n-    \/\/@OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrToMember extends Op {\n-        public static final String NAME = \"ptr.to.member\";\n-        public static final String ATTRIBUTE_OFFSET = \"offset\";\n-        public static final String ATTRIBUTE_NAME = \"name\";\n-\n-        final String simpleMemberName;\n-        final long memberOffset;\n-        final PtrType resultType;\n-\n-        PtrToMember(PtrToMember that, CodeContext cc) {\n-            super(that, cc);\n-            this.simpleMemberName = that.simpleMemberName;\n-            this.memberOffset = that.memberOffset;\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public PtrToMember transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrToMember(this, cc);\n-        }\n-\n-        public PtrToMember(Value ptr, String simpleMemberName) {\n-            super(List.of(ptr));\n-            this.simpleMemberName = simpleMemberName;\n-\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            \/\/ @@@ Support group layout\n-            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n-            }\n-\n-            \/\/ Find the actual member name from the simple member name\n-            String memberName = findMemberName(structLayout, simpleMemberName);\n-            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n-            this.memberOffset = structLayout.byteOffset(p);\n-            MemoryLayout memberLayout = structLayout.select(p);\n-            \/\/ Remove any simple member name from the layout\n-            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n-                    ? memberLayout.withName(className(memberName))\n-                    : memberLayout.withoutName();\n-            this.resultType = new PtrType(ptrLayout);\n-        }\n-\n-        \/\/ @@@ Change to return member index\n-        static String findMemberName(StructLayout sl, String simpleMemberName) {\n-            for (MemoryLayout layout : sl.memberLayouts()) {\n-                String memberName = layout.name().orElseThrow();\n-                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n-                    return memberName;\n-                }\n-            }\n-            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n-        }\n-\n-        static String simpleMemberName(String memberName) {\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(i + 2)\n-                    : memberName;\n-        }\n-\n-        static String className(String memberName) {\n-            int i = memberName.indexOf(\"::\");\n-            return i != -1\n-                    ? memberName.substring(0, i)\n-                    : null;\n-        }\n-\n-        @Override\n-        public PtrType resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        @Override\n-        public Map<String, Object> externalize() {\n-            return Map.of(\n-                    \"\", simpleMemberName,\n-                    ATTRIBUTE_OFFSET, memberOffset);\n-        }\n-\n-        public String simpleMemberName() {\n-            return simpleMemberName;\n-        }\n-\n-        public long memberOffset() {\n-            return memberOffset;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-    }\n-\n-\n-    \/\/@OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrAddOffset extends Op {\n-        public static final String NAME = \"ptr.add.offset\";\n-\n-        PtrAddOffset(PtrAddOffset that, CodeContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PtrAddOffset transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrAddOffset(this, cc);\n-        }\n-\n-        public PtrAddOffset(Value ptr, Value offset) {\n-            super(List.of(ptr, offset));\n-\n-            if (!(ptr.type() instanceof PtrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n-                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return ptrValue().type();\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-\n-        public Value offsetValue() {\n-            return operands().get(1);\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-    }\n-\n-  \/\/  @OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrLoadValue extends Op {\n-        public static final String NAME = \"ptr.load.value\";\n-\n-        final JavaType resultType;\n-\n-        PtrLoadValue(PtrLoadValue that, CodeContext cc) {\n-            super(that, cc);\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public PtrLoadValue transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrLoadValue(this, cc);\n-        }\n-\n-        public PtrLoadValue(Value ptr) {\n-            super(List.of(ptr));\n-\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            this.resultType = ptrType.rType();\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-    }\n-\n-  \/\/  @OpFactory.OpDeclaration(PtrToMember.NAME)\n-    public static final class PtrStoreValue extends Op {\n-        public static final String NAME = \"ptr.store.value\";\n-\n-        PtrStoreValue(PtrStoreValue that, CodeContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public PtrStoreValue transform(CodeContext cc, CodeTransformer ot) {\n-            return new PtrStoreValue(this, cc);\n-        }\n-\n-        public PtrStoreValue(Value ptr, Value v) {\n-            super(List.of(ptr));\n-\n-            if (!(ptr.type() instanceof PtrType ptrType)) {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-            if (!(ptrType.layout() instanceof ValueLayout)) {\n-                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n-            }\n-            if (!(ptrType.rType().equals(v.type()))) {\n-                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n-                        + ptrType.rType() + \" \" + v.type());\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-\n-        @Override\n-        public String externalizeOpName() {\n-            return NAME;\n-        }\n-\n-        public Value ptrValue() {\n-            return operands().get(0);\n-        }\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":0,"deletions":520,"binary":false,"changes":520,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.backend.DebugBackend;\n@@ -32,1 +31,0 @@\n-import java.lang.foreign.Arena;\n@@ -39,1 +37,1 @@\n-        Accelerator accelerator = new Accelerator(lookup,new DebugBackend(Arena.global(),lookup));\n+        Accelerator accelerator = new Accelerator(lookup);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S08x3ImageTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import optkl.InvokeOpHelper;\n+import optkl.Trxfmr;\n+import static optkl.InvokeOpHelper.invokeOpHelper;\n@@ -38,1 +41,1 @@\n-import optkl.codebuilders.ScopedCodeBuilderContext;\n+import optkl.util.Regex;\n@@ -40,1 +43,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -65,1 +67,1 @@\n-        var javaCodeBuilder = new JavaHATCodeBuilder<>();\n+        var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,rsqrt);\n@@ -67,1 +69,1 @@\n-        System.out.println(javaCodeBuilder.toText(lookup,rsqrt));\n+        System.out.println(javaCodeBuilder.toText());\n@@ -70,0 +72,2 @@\n+\n+\n@@ -72,6 +76,7 @@\n-            if (op instanceof CoreOp.FuncOp f){\n-                var replaceMe =CoreOp.func(\"invAbs\",builder.parentBody());\n-                builder.op(replaceMe);\n-            }else if (op instanceof JavaOp.InvokeOp invokeOp){\n-                var result= builder.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, builder.context().getValue(op.operands().get(0))));\n-                builder.context().mapValue(op.result(), result);\n+            if (invokeOpHelper(lookup,op) instanceof InvokeOpHelper ih\n+                    && ih.named(Regex.of(\"sqrt\")) && ih.isStatic() && ih.returns(double.class) && ih.receives(double.class)){\n+                var absStaticMethod = MethodRef.method(Math.class, \"abs\", double.class, double.class);\n+                var absInvoke =  JavaOp.invoke(InvokeKind.STATIC, false, absStaticMethod.type().returnType(), absStaticMethod,\n+                        builder.context().getValue(op.operands().get(0)));\n+                var absResult= builder.op(absInvoke);\n+                builder.context().mapValue(op.result(), absResult);\n@@ -85,1 +90,1 @@\n-        System.out.println(javaCodeBuilder.toText(lookup,abs));\n+        javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,abs);\n@@ -87,0 +92,22 @@\n+\n+\n+        System.out.println(\"Now using txfmr--------------------------\");\n+        var newAbs =Trxfmr.of(rsqrt)\n+                .transform(ce-> InvokeOpHelper.invokeOpHelper(lookup,ce) instanceof InvokeOpHelper $\n+                                && $.named(Regex.of(\"sqrt\"))\n+                                && $.isStatic()\n+                                && $.returns(double.class)\n+                                && $.receives(double.class), c->\n+                        c.replace(\n+                                JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand( 0))\n+                        )\n+                )\n+                .funcOp();\n+\n+\n+        System.out.println(newAbs.toText());\n+        javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,newAbs);\n+        System.out.println(javaCodeBuilder.toText());\n+        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(MethodHandles.lookup(), newAbs).invoke(100));\n+\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SwapMath.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-            CoreOp.FuncOp transformed = transform(here, javaFunc,(builder, op) -> {\n+            CoreOp.FuncOp transformed = transform(here, javaFunc,_->true,(builder, op) -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.util.Regex;\n+import optkl.util.carriers.LookupCarrier;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public record FieldAccessOpHelper(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp op) implements LookupCarrier,OpHelper<JavaOp.FieldAccessOp> {\n+    @Override\n+    public boolean isStatic(){\n+        return true;\/\/fieldAccessOp.invokeKind().equals(JavaOp.FieldAccessOp.InvokeKind.STATIC);\n+    }\n+    @Override\n+    public boolean isInstance(){\n+        return true;\/\/fieldAccessOp.invokeKind().equals(JavaOp.FieldAccessOp.InvokeKind.INSTANCE);\n+    }\n+    @Override\n+    public String name(){\n+        return op.fieldDescriptor().name();\n+    }\n+\n+    public <T>boolean of(Class<T> clazz){\n+        return isAssignable(clazz,(JavaType) op.resultType());\n+    }\n+\n+    public static FieldAccessOpHelper fieldAccessOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp? new FieldAccessOpHelper(lookup,fieldAccessOp): null;\n+\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccessOpHelper.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.util.Regex;\n+import optkl.util.carriers.LookupCarrier;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public record InvokeOpHelper(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) implements LookupCarrier,OpHelper<JavaOp.InvokeOp>{\n+    @Override public boolean isStatic(){\n+        return op.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.STATIC);\n+    }\n+    @Override public boolean isInstance(){\n+        return op.invokeKind().equals(JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+    }\n+    @Override public String name(){\n+        return op.invokeDescriptor().name();\n+    }\n+    public <T>boolean returns(Class<T> clazz){\n+        return isAssignable(clazz,(JavaType)op.resultType());\n+    }\n+    public boolean receives(Class<?>... classes){\n+        boolean  assignable = true;\n+        for (int i=isStatic()?1:0; assignable && i< classes.length; i++) {\n+            var operand = op.operands().get(i);\n+            TypeElement resultType = operand.type() instanceof VarType varType?varType.valueType():null;\n+            assignable &= isAssignable(classes[i-(isStatic()?1:0)], (JavaType) resultType);\n+        }\n+        return assignable;\n+    }\n+\n+    public static InvokeOpHelper invokeOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        return codeElement instanceof JavaOp.InvokeOp invokeOp? new InvokeOpHelper(lookup,invokeOp): null;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeOpHelper.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.util.Regex;\n+import optkl.util.carriers.LookupCarrier;\n+\n+public interface OpHelper<T extends Op> extends LookupCarrier {\n+    T op();\n+    boolean isStatic();\n+    boolean isInstance();\n+    String name();\n+    default boolean named(Regex regex){\n+        return regex.matches(name());\n+    }\n+    default boolean named(String name){\n+        return name().equals(name);\n+    }\n+    default <C>boolean isAssignable( Class<C> clazz, JavaType javaType){\n+        try {\n+            boolean isit1=  OpTkl.isAssignable(lookup(),javaType,clazz);\n+            var basicType = javaType.toBasicType();\n+            var resolveType = basicType.resolve(lookup());\n+            var isit2 = resolveType.getTypeName().equals(clazz.getName());\n+            var resolveTypeClass = resolveType.getClass();\n+            var isit3 = clazz.isAssignableFrom(resolveTypeClass);\n+            var isit4 = resolveTypeClass.isAssignableFrom(clazz);\n+            \/\/ System.out.println(\"isit1=\"+isit1+\",isit2=\"+isit2+\",isit3=\"+isit3+\",isit4=\"+isit4);\n+            return  isit2;\n+\n+        } catch (ReflectiveOperationException e) {\n+            System.out.println(\"Hmm\");\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -420,4 +420,0 @@\n-static <T> Stream<T> opstream(CoreOp.FuncOp funcOp, Function<CodeElement<?,?>,T> mapper) {\n-   return funcOp.elements().map(mapper).filter(Objects::nonNull);\n-}\n-\n@@ -425,12 +421,0 @@\n-static CoreOp.FuncOp SSATransformLower(CallSite callSite, CoreOp.FuncOp funcOp){\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return  SSA.transform(lower(callSite,funcOp));\n-}\n-static CoreOp.FuncOp SSATransform(CallSite callSite, CoreOp.FuncOp funcOp){\n-   if (callSite.tracing()){\n-      System.out.println(callSite);\n-   }\n-   return  SSA.transform(funcOp);\n-}\n@@ -462,27 +446,0 @@\n-record  OpMap(CoreOp.FuncOp fromFuncOp, CoreOp.FuncOp toFuncOp,  Map<Op,Op> fromToOpMap){}\n-\n-static <InOp extends Op, OutOp extends Op> OutOp replaceOp(Block.Builder blockBuilder, InOp inOp,java.util.function.Function<List<Value>, OutOp> factory) {\n-   List<Value> inputOperands = inOp.operands();\n-   CodeContext context = blockBuilder.context();\n-   List<Value> outputOperands = context.getValues(inputOperands);\n-   OutOp outOp = factory.apply(outputOperands);\n-   Op.Result outputResult = blockBuilder.op(outOp);\n-   Op.Result inputResult = inOp.result();\n-   outOp.setLocation(inOp.location());\n-   context.mapValue(inputResult, outputResult);\n-   return outOp;\n-}\n-static < OutOp extends Op> OpMap simpleOpMappingTransform(CallSite here, CoreOp.FuncOp fromFuncOp, Predicate<Op> opPredicate,\n-                                                          java.util.function.Function<List<Value>, OutOp> opFactory){\n-   Map<Op,Op> fromToOpMap = new LinkedHashMap<>();\n-   CoreOp.FuncOp toFuncOp =  transform(here, fromFuncOp, (blockBuilder, inOp) -> {\n-      if (opPredicate.test(inOp)) {\n-         fromToOpMap.put(inOp, replaceOp(blockBuilder, inOp, opFactory));\n-      }else {\n-         var r = blockBuilder.op(inOp);\n-         fromToOpMap.put(inOp,r.op());\n-      }\n-      return blockBuilder;\n-   });\n-   return new OpMap(fromFuncOp, toFuncOp, fromToOpMap);\n-}\n@@ -491,6 +448,0 @@\n-\n-\n-static boolean returnIsVoid(JavaOp.InvokeOp invokeOp){\n-   return javaReturnType(invokeOp) instanceof PrimitiveType primitiveType && primitiveType.isVoid();\n-}\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,399 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import optkl.util.CallSite;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import static optkl.OpTkl.copyLocation;\n+import static optkl.OpTkl.operandOrNull;\n+\n+public class Trxfmr {\n+    public static Trxfmr of(CoreOp.FuncOp funcOp) {\n+        return new Trxfmr(funcOp);\n+    }\n+    public static Trxfmr of(CallSite callSite,CoreOp.FuncOp funcOp) {\n+        return new Trxfmr(callSite,funcOp);\n+    }\n+\n+    interface TransformerCarrier {\n+        Trxfmr trxfmr();\n+    }\n+    interface CursorCarrier<T extends Cursor>{\n+        T cursor();\n+    }\n+\n+    public interface  Walker extends TransformerCarrier {\n+        void op(Op op);\n+        Op op();\n+        void funcOp(CoreOp.FuncOp funcOp);\n+        CoreOp.FuncOp funcOp();\n+              class Impl implements TransformerCarrier,Walker {\n+                private final Trxfmr trxfmr;\n+                public Trxfmr trxfmr() {\n+                    return trxfmr;\n+                }\n+                private Op op;\n+                private CoreOp.FuncOp funcOp;\n+                @Override\n+                public void op(Op op) {\n+                    this.op = op;\n+                }\n+\n+                @Override\n+                public Op op() {\n+                    return this.op;\n+                }\n+\n+                @Override\n+                public void funcOp(CoreOp.FuncOp funcOp) {\n+                    this.funcOp = funcOp;\n+                }\n+\n+                @Override\n+                public CoreOp.FuncOp funcOp() {\n+                    return this.funcOp;\n+                }\n+\n+                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp) {\n+                    this.trxfmr = trxfmr;\n+                    this.funcOp = funcOp;\n+                }\n+            }\n+        static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n+            return new Impl(trxfmr,funcOp);\n+        }\n+    }\n+\n+    public interface  Cursor extends TransformerCarrier, Walker {\n+        enum Action{NONE,REMOVED,REPLACE,ADDED };\n+        void action(Action action);\n+        Action action();\n+        void builder(Block.Builder builder);\n+        Block.Builder builder();\n+        void handled(boolean handled);\n+        boolean handled();\n+        Op.Result replace(Op op, Consumer<Mapper<?>> mapperConsumer);\n+        Op.Result add(Op op, Consumer<Mapper<?>> mapperConsumer);\n+        default Op.Result replace(Op op){\n+            return replace(op, _->{});\n+        }\n+\n+        default Op.Result add(Op op){\n+            return add(op, _->{});\n+        }\n+         default void remove(Consumer<Mapper<?>> mapperConsumer) {\n+            mapperConsumer.accept(Mapper.of(this));\n+        }\n+        default void remove() {\n+            remove(_->{});\n+        }\n+        default Op.Result remove(Op op){\n+            return replace(op, (m)->{});\n+        }\n+        static Cursor of(Trxfmr trxfmr, CoreOp.FuncOp funcOp, Block.Builder builder, Op op){\n+            class Impl extends Walker.Impl implements Cursor {\n+                private Action action;\n+                private Block.Builder builder;\n+                private boolean handled;\n+                @Override\n+                public void handled(boolean handled) {\n+                    this.handled = handled;\n+                }\n+\n+                @Override\n+                public boolean  handled() {\n+                    return this.handled;\n+                }\n+\n+                @Override\n+                public void action(Action action) {\n+                    this.action=action;\n+                }\n+\n+                @Override\n+                public Action action() {\n+                    return action;\n+                }\n+\n+                @Override\n+                public void builder(Block.Builder builder) {\n+                    this.builder = builder;\n+                }\n+\n+                @Override\n+                public Block.Builder builder() {\n+                    return this.builder;\n+                }\n+                @Override\n+                public Op.Result replace(Op replacement, Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    action(Action.REPLACE);\n+                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), replacement)));\n+                    if (result.type() instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n+                    }else {\n+                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n+                    }\n+                    return result;\n+                }\n+                public Op.Result add(Op newOne, Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    action(Action.ADDED);\n+                    var result = trxfmr.opToResultOp(op(),builder().op(copyLocation(op(), newOne)));\n+                    if (result.type() instanceof PrimitiveType primitiveType && primitiveType.isVoid()) {\n+                    }else{\n+                        mapperConsumer.accept(Mapper.of(this).map(op().result(), result));\n+                    }\n+                    return result;\n+                }\n+                @Override\n+                public void remove( Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    action(Action.REMOVED);\n+                }\n+                Impl(Trxfmr hatTransformer, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n+                    super(hatTransformer,funcOp);\n+                    builder(builder);\n+                    op(op);\n+                }\n+            }\n+            return new Impl(trxfmr,funcOp, builder,op);\n+        }\n+\n+        default Value getValue(Value value){\n+            return builder().context().getValue(value);\n+        }\n+\n+        default Value mappedOperand(int idx){\n+            return getValue(operandOrNull(op(),idx));\n+        }\n+    }\n+\n+    public interface Selector<T extends Selector<T>> extends TransformerCarrier {\n+        default T  select(Op...ops){\n+            trxfmr().selected.addAll(List.of(ops));\n+            return (T)this;\n+        }\n+       static Selector<?> of(Trxfmr trxfmr){\n+            record SelectorImpl(Trxfmr trxfmr) implements Selector<SelectorImpl>{}\n+            return  new SelectorImpl(trxfmr);\n+        }\n+    }\n+\n+\n+    public interface Mapper<T extends Mapper<T>> extends CursorCarrier{\n+        default  T map(Value from, Value to) {\n+            cursor().builder().context().mapValue(from, to);\n+            return (T)this;\n+        }\n+        default  T map(Op fromOp, Value to) {\n+            map(fromOp.result(), to);\n+            return (T)this;\n+        }\n+        default  T mapOperand(Op fromOp, List<Value> operands, int n) {\n+           return map(fromOp,operands.get(n));\n+        }\n+        default  T mapOperands(Op fromOp, List<Value> operands) {\n+            operands.forEach(v -> {\n+                map(fromOp,v);\n+            });\n+            return (T)this;\n+        }\n+        default  T mapOperands(Op fromOp, Op to) {\n+            return mapOperands(fromOp,to.operands());\n+        }\n+        default  T mapOperand(Op fromOp, Op to, int index) {\n+            return map(fromOp,to.operands().get(index));\n+        }\n+        static Mapper<?> of(Cursor cursor){\n+            record MapperImpl(Cursor cursor) implements Mapper<MapperImpl> { }\n+            return new MapperImpl(cursor);\n+        }\n+    }\n+\n+    public final Set<Op> selected = new LinkedHashSet<>();\n+    public final Map<Op, Op> opmap = new HashMap<>();\n+    public final CallSite callSite;\n+    public CoreOp.FuncOp funcOp;\n+\n+    public CoreOp.FuncOp funcOp(){\n+        return funcOp;\n+    }\n+    public CoreOp.FuncOp funcOp(CoreOp.FuncOp funcOp){\n+        return this.funcOp=funcOp;\n+    }\n+\n+    public Trxfmr(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        this.callSite = callSite;\n+        this.funcOp =  funcOp;\n+        if (callSite!=null && callSite.tracing()) {\n+            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() + \"]: \" + System.lineSeparator() + funcOp.toText());\n+        }\n+    }\n+\n+    public Trxfmr(CoreOp.FuncOp funcOp) {\n+        this (null,funcOp);\n+\n+    }\n+    public Trxfmr select(Predicate<Op> codeElementPredicate, BiConsumer<Selector<?>,Op> selectorConsumer) {\n+        Selector<?> selector = Selector.of(this);\n+        funcOp().elements().filter(ce->ce instanceof Op).map(ce->(Op)ce).filter(codeElementPredicate).forEach(op->\n+                selectorConsumer.accept(selector,op)\n+        );\n+        return this;\n+    }\n+\n+\n+    public Trxfmr done() {\n+        if (callSite!=null && callSite.tracing()) {\n+            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() + \"]: \" + System.lineSeparator()\n+                    +funcOp().toText());\n+        }\n+        return this;\n+    }\n+\n+\n+\n+    private Op opToOp(Op from, Op to){\n+        opmap.put(from,to);\n+        return to;\n+    }\n+    private Op.Result opToResultOp(Op from, Op.Result result){\n+        opToOp(from, result.op());\n+        return result;\n+    }\n+\n+    public Trxfmr transform(Predicate<CodeElement<?,?>> predicate, Consumer<Cursor> cursorConsumer) {\n+        if (callSite != null && callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        var newFuncOp = funcOp().transform((blockBuilder, op) -> {\n+            Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n+            cursor.builder(blockBuilder);\n+            cursor.op(op);\n+            cursor.handled(false);\n+            cursor.action(Cursor.Action.NONE);\n+            boolean isEmpty = selected.isEmpty();\n+            boolean isInSelected = selected.contains(op);\n+            boolean isSelected = isEmpty|isInSelected;\n+            boolean passesPredicate = predicate.test(op);\n+            if (isSelected && passesPredicate) {\n+                cursorConsumer.accept(cursor);\n+                if (!cursor.handled()){\n+                    opToOp(op,cursor.builder().op(op).op());\n+                }\n+            } else {\n+                opToOp(op,cursor.builder().op(op).op());\n+            }\n+            return blockBuilder;\n+        });\n+        funcOp(newFuncOp);\n+        return this;\n+    }\n+    public Trxfmr transform(Consumer<Cursor> transformer) {\n+        return transform(_->true,transformer);\n+    }\n+\n+    public Trxfmr transform(Predicate<Op> predicate, CodeTransformer codeTransformer) {\n+        if (callSite != null && callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        var currentFuncOp = funcOp();\n+        var newFuncOp = currentFuncOp.transform((blockBuilder, op) -> {\n+            Cursor cursor = Cursor.of(this,funcOp,blockBuilder,op);\n+            if ((selected.isEmpty() || selected.contains(op)) &&  predicate.test(op)) {\n+                codeTransformer.acceptOp(cursor.builder(),op);\n+            } else {\n+                opToOp(op,cursor.builder().op(op).op());\n+            }\n+            return cursor.builder();\n+        });\n+        opmap.put(currentFuncOp, newFuncOp);\n+        funcOp(newFuncOp);\n+        opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n+        return this;\n+    }\n+\n+    public Trxfmr transform(CodeTransformer codeTransformer ) {\n+        if (callSite != null && callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        funcOp(funcOp().transform(codeTransformer));\n+        return this;\n+    }\n+\n+\n+    public interface Edge<F extends CodeElement<?,?>, T extends CodeElement<?,?>> {\n+        F f();\n+        T t();\n+        Set<Op> ops();\n+         class Selector<F extends CodeElement<?,?>, T extends CodeElement<?,?>> {\n+            Map<F, Edge<F, T>> fromMap = new HashMap<>();\n+            Map<T, Edge<F, T>> toMap = new HashMap<>();\n+\n+            public Selector<F, T> add(Edge<F, T> edge) {\n+                fromMap.put(edge.f(), edge);\n+                toMap.put(edge.t(), edge);\n+                return this;\n+            }\n+\n+            Edge<F, T> from(F f) {\n+                return fromMap.get(f);\n+            }\n+\n+            Edge<F, T> to(T t) {\n+                return toMap.get(t);\n+            }\n+\n+            Predicate<CodeElement<?,?>> predicate =ce->fromMap.containsKey((F) ce) || toMap.containsKey((T) ce);\n+\n+            public boolean contains(Op op) {\n+                return predicate.test(op);\n+            }\n+\n+             public CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Consumer<Cursor> c) {\n+                 return new Trxfmr(CallSite.of(this.getClass()), funcOp)\n+                         .transform(this.predicate,c).done().funcOp();\n+             }\n+         }\n+    }\n+\n+\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":399,"deletions":0,"binary":false,"changes":399,"status":"added"},{"patch":"@@ -80,2 +80,1 @@\n-           var builder=  new JavaHATCodeBuilder();\n-           CoreOp.FuncOp mandel =  Op.ofMethod(Compute.class.getDeclaredMethod(\"mandel\",\n+            CoreOp.FuncOp mandel =  Op.ofMethod(Compute.class.getDeclaredMethod(\"mandel\",\n@@ -85,0 +84,1 @@\n+       var builder=  new JavaHATCodeBuilder(MethodHandles.lookup(),mandel);\n@@ -86,1 +86,1 @@\n-            OpCodeBuilder.writeTo(System.out,mandel);\n+       OpCodeBuilder.writeTo(System.out,mandel);\n@@ -95,1 +95,1 @@\n-           System.out.println(builder);\n+           System.out.println(builder.toText());\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}