{"files":[{"patch":"@@ -60,1 +60,1 @@\n-            return schema.allocate(accelerator, width,height);\n+            return schema.allocate(accelerator, width, height);\n@@ -68,1 +68,1 @@\n-            MemorySegment.copy(Buffer.getMemorySegment(this), valueLayout, offset, bytes, 0, width()*height());\n+            MemorySegment.copy(Buffer.getMemorySegment(this), valueLayout, offset, bytes, 0, width() * height());\n@@ -86,1 +86,1 @@\n-            instance.to(cellGrid.width()*cellGrid.height());\n+            instance.to(cellGrid.width() * cellGrid.height());\n@@ -123,2 +123,21 @@\n-        static public void compute(final ComputeContext computeContext, Control control, CellGrid cellGrid) {\n-            computeContext.dispatchKernel(cellGrid.width()*cellGrid.height(), kc -> Compute.life(kc, control, cellGrid));\n+        static public void compute(final ComputeContext computeContext, Viewer viewer, Control control, CellGrid cellGrid) {\n+            long start = System.currentTimeMillis();\n+            int generation = 0;\n+            while (true) {\n+\n+                computeContext.dispatchKernel(\n+                        cellGrid.width() * cellGrid.height(),\n+                        kc -> Compute.life(kc, control, cellGrid)\n+                );\n+\n+                \/\/swap from\/to\n+                int to = control.from();\n+                control.from(control.to());\n+                control.to(to);\n+                viewer.setGeneration(generation++, System.currentTimeMillis() - start);\n+               \/\/ if (generation % 50 == 0) {\n+                    viewer.update(cellGrid, to);\n+               \/\/ }\n+            }\n+\n+\n@@ -147,1 +166,1 @@\n-        viewer.update();\n+        viewer.update(cellGrid, 0);\n@@ -149,0 +168,1 @@\n+        accelerator.compute(cc -> Compute.compute(cc, viewer, control, cellGrid));\n@@ -150,11 +170,0 @@\n-        final long startMillis = System.currentTimeMillis();\n-\n-        for (int generation = 0; generation < Integer.MAX_VALUE; generation++) {\n-            accelerator.compute(cc -> Compute.compute(cc, control, cellGrid));\n-            \/\/swap from\/to\n-            int tmp = control.from();\n-            control.from(control.to());\n-            control.to(tmp);\n-            long elapsedMs = System.currentTimeMillis() - startMillis;\n-            viewer.setGeneration(generation, ((generation * 1000f) \/ elapsedMs));\n-        }\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Life.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -65,2 +65,1 @@\n-        private Life.CellGrid cellGrid;\n-        private Life.Control control;\n+\n@@ -82,1 +81,1 @@\n-        public MainPanel(BufferedImage image, Life.Control control, Life.CellGrid cellGrid) {\n+        public MainPanel(BufferedImage image) {\n@@ -87,2 +86,0 @@\n-            this.control = control;\n-            this.cellGrid = cellGrid;\n@@ -150,1 +147,0 @@\n-            cellGrid.copySliceTo(rasterData, control.to());\n@@ -152,2 +148,2 @@\n-            g2.fillRect(0-5000, 0-5000, cellGrid.width()+10000, cellGrid.height()+10000);\n-            g2.drawImage(image, 0,0, cellGrid.width(), cellGrid.height(), 0, 0, cellGrid.width(), cellGrid.height(), this);\n+            g2.fillRect(0-5000, 0-5000, image.getWidth()+10000, image.getHeight()+10000);\n+            g2.drawImage(image, 0,0, image.getWidth(), image.getHeight(), 0, 0, image.getWidth(), image.getHeight(), this);\n@@ -159,1 +155,1 @@\n-    private final MainPanel mainPanel;\n+    final MainPanel mainPanel;\n@@ -164,1 +160,1 @@\n-    void setGeneration(int generation, float generationsPerSecond){\n+    void setGeneration(int generation, float ms){\n@@ -166,1 +162,1 @@\n-        this.generationsPerSecond.setText(String.format(\"%5.2f\",generationsPerSecond));\n+        this.generationsPerSecond.setText(String.format(\"%5.2f\",ms\/generation));\n@@ -172,1 +168,1 @@\n-        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY),control,cellGrid);\n+        this.mainPanel = new MainPanel(new BufferedImage(cellGrid.width(), cellGrid.height(), BufferedImage.TYPE_BYTE_GRAY));\n@@ -204,1 +200,2 @@\n-    public void update() {\n+    public void update(Life.CellGrid cellGrid, int to) {\n+        cellGrid.copySliceTo(mainPanel.rasterData, to);\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Viewer.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -72,0 +72,4 @@\n+    public static final MethodRef M_CC_PRE_ESCAPE = MethodRef.method(ComputeContext.class, \"preEscape\",\n+            void.class, Buffer.class);\n+    public static final MethodRef M_CC_POST_ESCAPE = MethodRef.method(ComputeContext.class, \"postEscape\",\n+            void.class, Buffer.class);\n@@ -148,0 +152,7 @@\n+    public void preEscape(Buffer b) {\n+        \/*System.out.println(\"preEscape \" + b);*\/\n+    }\n+    public void postEscape(Buffer b) {\n+        \/*System.out.println(\"postEscape \" + b);*\/\n+    }\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.optools.InvokeOpWrapper;\n@@ -41,0 +42,3 @@\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -48,1 +52,1 @@\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema){\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema) {\n@@ -51,0 +55,1 @@\n+\n@@ -80,0 +85,4 @@\n+                    CopyContext cc = builder.context();\n+                    \/\/We know that the first arg to a compute method is indeed a computeContext\n+                    \/\/ so map the value\n+                    Value computeContext = cc.getValue(originalFuncOpWrapper.parameter(0));\n@@ -81,2 +90,0 @@\n-                        CopyContext cc = builder.context();\n-                        Value computeContext = cc.getValue(originalFuncOpWrapper.parameter(0));\n@@ -84,1 +91,0 @@\n-\n@@ -96,0 +102,4 @@\n+                    } else if (invokeOpWrapper.isComputeContextMethod()) { \/\/dispatchKernel\n+                        builder.op(invokeOpWrapper.op());\n+                    } else if (invokeOpWrapper.isRawKernelCall()) {        \/\/static, void and first arg is KernelContext\n+                        builder.op(invokeOpWrapper.op());\n@@ -97,0 +107,7 @@\n+                        for (int i=0; i<invokeOpWrapper.operandCount();i++ ){\n+                            if (invokeOpWrapper.operandNAsValue(i) instanceof Value value\n+                                    && value.type() instanceof JavaType javaType\n+                                    && InvokeOpWrapper.isIface(javaType)){\n+                                builder.op(CoreOp.invoke(ComputeContext.M_CC_PRE_ESCAPE, computeContext, cc.getValue(value)));\n+                            }\n+                        }\n@@ -98,0 +115,7 @@\n+                        for (int i=0; i<invokeOpWrapper.operandCount();i++ ){\n+                            if (invokeOpWrapper.operandNAsValue(i) instanceof Value value\n+                                    && value.type() instanceof JavaType javaType\n+                                    && InvokeOpWrapper.isIface(javaType)){\n+                                builder.op(CoreOp.invoke(ComputeContext.M_CC_POST_ESCAPE, computeContext, cc.getValue(value)));\n+                            }\n+                        }\n@@ -102,1 +126,1 @@\n-        \/\/ transformed.op().writeTo(System.out);\n+        transformed.op().writeTo(System.out);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -141,1 +141,2 @@\n-        if (FuncOpWrapper.ParamTable.Info.isIfaceBuffer(javaType) && javaType instanceof ClassType classType) {\n+       \/\/ if (FuncOpWrapper.ParamTable.Info.isIfaceBuffer(javaType) && javaType instanceof ClassType classType)\n+        if (InvokeOpWrapper.isIface(javaType) && javaType instanceof ClassType classType) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.optools.InvokeOpWrapper;\n@@ -83,1 +84,1 @@\n-        if (FuncOpWrapper.ParamTable.Info.isIfaceBuffer(javaType) && javaType instanceof ClassType classType) {\n+        if (InvokeOpWrapper.isIface(javaType) && javaType instanceof ClassType classType) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/c99codebuilders\/C99HatKernelBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.optools.InvokeOpWrapper;\n@@ -87,1 +88,1 @@\n-        if (fow.getReturnType() instanceof JavaType javaReturnType && javaReturnType.equals(JavaType.VOID)) {\n+        if (fow.getReturnType().equals(JavaType.VOID)) {\n@@ -89,1 +90,1 @@\n-                \/\/ We check that the proposed kernel first arg is an NDRange.kid and\n+                \/\/ We check that the proposed kernel first arg is an KernelContext and\n@@ -91,2 +92,2 @@\n-                var firstArgIsKid = new Result<Boolean>(false);\n-                var atLeastOneIfaceBufferParam = new Result<Boolean>(false);\n+                var firstArgIsKid = new Result<>(false);\n+                var atLeastOneIfaceBufferParam = new Result<>(false);\n@@ -100,1 +101,1 @@\n-                        } else if (paramInfo.isIfaceBuffer()) {\n+                        } else if (InvokeOpWrapper.isIface(paramInfo.javaType)) {\n@@ -121,3 +122,0 @@\n-    \/\/  public ComputeCallGraph(ComputeContext computeContext, ComputeEntrypoint computeEntrypoint) {\n-    \/\/    super(computeContext, computeEntrypoint);\n-    \/\/ }\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,51 +70,0 @@\n-\n-            public static boolean isIfaceBuffer(Class<?> hopefullyABufferClass) {\n-\n-                if (MappableIface.class.isAssignableFrom(hopefullyABufferClass)) {\n-                    return true;\n-                } else {\n-                    Class<?> enclosingClass = hopefullyABufferClass.getEnclosingClass();\n-                    if (enclosingClass != null) {\n-                        return isIfaceBuffer(enclosingClass);\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-            }\n-\n-            public static boolean isIfaceBuffer(JavaType javaType) {\n-                if (javaType instanceof PrimitiveType) {\n-                    return false;\n-                }\n-                try {\n-                    String className = javaType.toString();\n-                    Class<?> hopefullyABufferClass = Class.forName(className);\n-                    return isIfaceBuffer(hopefullyABufferClass);\n-                } catch (ClassNotFoundException e) {\n-                    return false;\n-                }\n-\n-            }\n-            public boolean isIfaceBuffer() {\n-                return isIfaceBuffer(javaType);\n-\n-            }\n-\n-            public static boolean isKernelContext(JavaType javaType) {\n-                if (javaType instanceof PrimitiveType) {\n-                    return false;\n-                }\n-                try {\n-                    String className = javaType.toString();\n-                    Class<?> hopefullyAKernelContext = Class.forName(className);\n-                    \/\/ Note we alow either the buffer form here.  Common iface? or maybe we should just not use same name\n-                    return hat.KernelContext.class.isAssignableFrom(hopefullyAKernelContext)\n-                        || hat.buffer.KernelContext.class.isAssignableFrom(hopefullyAKernelContext);\n-                } catch (ClassNotFoundException e) {\n-                    return false;\n-                }\n-            }\n-            public boolean isKernelContext() {\n-                return isKernelContext(javaType);\n-\n-            }\n@@ -123,1 +72,0 @@\n-\n@@ -126,1 +74,0 @@\n-            Value dirtyVar;\n@@ -129,1 +76,0 @@\n-\n@@ -135,1 +81,0 @@\n-                this.dirtyVar = null;\n@@ -137,5 +82,0 @@\n-\n-            public void setDirtyVar(Value dirtyVar) {\n-                this.dirtyVar = dirtyVar;\n-            }\n-\n@@ -145,1 +85,0 @@\n-\n@@ -149,1 +88,0 @@\n-\n@@ -171,1 +109,2 @@\n-                    parameterToInfo.computeIfAbsent(parameterToVarOp.getKey(), (parameterKey) -> { \/\/ always called but convenient because computeIfAbsent returns what we added :)\n+                    \/\/ always called but convenient because computeIfAbsent returns what we added :)\n+                    parameterToInfo.computeIfAbsent(parameterToVarOp.getKey(), (parameterKey) -> {\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.ComputeContext;\n@@ -33,0 +34,1 @@\n+import java.lang.reflect.code.type.ClassType;\n@@ -35,0 +37,1 @@\n+import java.lang.reflect.code.type.PrimitiveType;\n@@ -40,0 +43,2 @@\n+\n+\n@@ -53,1 +58,3 @@\n-        return FuncOpWrapper.ParamTable.Info.isIfaceBuffer(javaRefType());\n+        return isIface(javaRefType());\n+    }\n+\n@@ -55,0 +62,6 @@\n+    public boolean isRawKernelCall() {\n+        boolean isRawKernelCall= (operandCount()>1 && operandNAsValue(0) instanceof Value value\n+                && value.type() instanceof JavaType javaType\n+                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, hat.buffer.KernelContext.class))\n+        );\n+        return isRawKernelCall;\n@@ -57,1 +70,5 @@\n-        return FuncOpWrapper.ParamTable.Info.isKernelContext(javaRefType());\n+        return isAssignable(javaRefType(), KernelContext.class);\n+\n+    }\n+    public boolean isComputeContextMethod() {\n+        return isAssignable(javaRefType(), ComputeContext.class);\n@@ -110,3 +127,0 @@\n-    public boolean isKernelContextAccessor() {\n-        return isKernelContextMethod();\n-    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.buffer.Buffer;\n+\n@@ -34,0 +36,2 @@\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.JavaType;\n@@ -232,0 +236,20 @@\n+\n+    public static boolean isIface(JavaType javaType){\n+        return  (isAssignable(javaType, Buffer.class, Buffer.Struct.class, Buffer.Union.class));\n+    }\n+    public static boolean isAssignable(JavaType javaType, Class<?> ... classes) {\n+        if (javaType instanceof ClassType classType) {\n+            try {\n+                Class<?> javaTypeClass = Class.forName(classType.toString());\n+                for (Class<?> clazz : classes) {\n+                    if (clazz.isAssignableFrom(javaTypeClass)) {\n+                        return true;\n+                    }\n+                }\n+            } catch (ClassNotFoundException _) {\n+\n+            }\n+        }\n+        return false;\n+\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}