{"files":[{"patch":"@@ -375,0 +375,21 @@\n+    static List<String> expandTuples(Indexer indexer, List<Value> values) {\n+        var names = new ArrayList<String>();\n+        expandTuples(indexer, names, values);\n+        return names;\n+    }\n+\n+    static void expandTuples(Indexer indexer, List<String> names, List<Value> values) {\n+        for (var v : values) {\n+            if (v instanceof Op.Result or && or.op() instanceof CoreOp.TupleOp op) {\n+                expandTuples(indexer, names, op.operands());\n+            } else if (v.type() instanceof TupleType tt) {\n+                var ct = tt.componentTypes();\n+                for (int i = 0; i < ct.size(); i++) {\n+                    names.add(indexer.nameOf(v, i));\n+                }\n+            } else {\n+                names.add(indexer.nameOf(v));\n+            }\n+        }\n+    }\n+\n@@ -380,2 +401,1 @@\n-        return graph(\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.nameOf(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n+        return graph(IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.nameOf(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n@@ -394,3 +414,2 @@\n-                            opNodes.accept(node(\n-                                    loopOp.opName(),\n-                                    loopOp.operands().stream().map(indexer::nameOf).toList(),\n+                            opNodes.accept(node(loopOp.opName(),\n+                                    expandTuples(indexer, loopOp.operands()),\n@@ -427,9 +446,1 @@\n-                block.terminatingOp().operands().stream().<String>mapMulti((o, oc) -> {\n-                    if (o.type() instanceof TupleType tt) {\n-                        for (int i = 0; i < tt.componentTypes().size(); i++) {\n-                            oc.accept(indexer.nameOf(o, i));\n-                        }\n-                    } else {\n-                        oc.accept(indexer.nameOf(o));\n-                    }\n-                }).toList());\n+                expandTuples(indexer, block.terminatingOp().operands()));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -275,0 +275,26 @@\n+    public record Tuple(Tensor<Long> a, Tensor<Float> b) {}\n+\n+    static Tuple newTuple(Tensor<Long> a, Tensor<Float> b) {\n+        return new Tuple(a, b);\n+    }\n+\n+    static LoopReturn<Tuple> newLoopReturn(Tensor<Boolean> b, Tuple t) {\n+        return new LoopReturn<>(b, t);\n+    }\n+\n+    @CodeReflection\n+    public Tuple loop(Tensor<Boolean> b) {\n+        var c1 = Constant(1l);\n+        var c2 = Constant(1f);\n+        var c3 = Constant(4l);\n+        return Loop(c3, b, newTuple(c1, c2), (i, cond, v) -> newLoopReturn(Identity(cond), newTuple(Add(v.a(), v.a()), Identity(Add(v.b(), v.b())))));\n+    }\n+\n+    @Test\n+    public void testLoop() throws Exception {\n+        var b = Tensor.ofScalar(true);\n+        var res = execute(() -> loop(b));\n+        assertEquals(Tensor.ofScalar(16l), res.a());\n+        assertEquals(Tensor.ofScalar(16f), res.b());\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}