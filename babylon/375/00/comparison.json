{"files":[{"patch":"@@ -90,4 +90,0 @@\n-    public static <T> LoopReturn<T> LoopReturn(Tensor<Boolean> cond, T output) {\n-        return new LoopReturn<>(cond, output);\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+import jdk.incubator.code.type.TupleType;\n@@ -318,3 +319,22 @@\n-    private static final class Indexer extends HashMap<Value, String> {\n-        String getName(Value v) {\n-            return computeIfAbsent(v, _ -> \"#\" + size());\n+    private static final class Indexer {\n+\n+        private final HashMap<Value, String> baseNames = new HashMap();\n+        private final HashMap<String, String> elementsMap = new HashMap();\n+\n+\n+        private String baseName(Value value, int elementIndex) {\n+            var name = baseNames.computeIfAbsent(value, _ -> \"#\" + baseNames.size());\n+            return elementIndex > 0 ? name + '.' + elementIndex : name;\n+        }\n+\n+        String nameOf(Value value) {\n+            return nameOf(value, 0);\n+        }\n+\n+        String nameOf(Value tuple, int elementIndex) {\n+            var name = baseName(tuple, elementIndex);\n+            return elementsMap.getOrDefault(name, name);\n+        }\n+\n+        void mapTupleLoad(Value tupleLoadResult, Value tuple, int elementIndex) {\n+            elementsMap.put(baseName(tupleLoadResult, 0), nameOf(tuple, elementIndex));\n@@ -322,4 +342,5 @@\n-        String getName(Value v, int subIndex) {\n-            var name = getName(v);\n-            if (subIndex != 0) name += \".\" + subIndex;\n-            return name;\n+\n+        void mapTupleElements(Value tuple, List<Value> elements) {\n+            for (int i = 0; i < elements.size(); i++) {\n+                elementsMap.put(baseName(tuple, i), nameOf(elements.get(i)));\n+            }\n@@ -354,1 +375,1 @@\n-        params.forEach(indexer::getName);\n+        params.forEach(indexer::nameOf);\n@@ -358,1 +379,1 @@\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n+                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.nameOf(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n@@ -360,1 +381,1 @@\n-                        tensorInfo(indexer.getName(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n+                        tensorInfo(indexer.nameOf(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n@@ -366,2 +387,2 @@\n-                                    List.of(indexer.getName(ifOp.operands().getFirst())),\n-                                    List.of(indexer.getName(ifOp.result())),\n+                                    List.of(indexer.nameOf(ifOp.operands().getFirst())),\n+                                    IntStream.range(0, ifOp.resultType() instanceof TupleType tt ? tt.componentTypes().size() : 1).mapToObj(o -> indexer.nameOf(ifOp.result(), o)).toList(),\n@@ -371,1 +392,0 @@\n-                        case OnnxOps.LoopReturn _ -> {} \/\/ skip\n@@ -375,2 +395,2 @@\n-                                    loopOp.operands().stream().map(indexer::getName).toList(),\n-                                    List.of(indexer.getName(loopOp.result())),\n+                                    loopOp.operands().stream().map(indexer::nameOf).toList(),\n+                                    IntStream.range(0, loopOp.resultType() instanceof TupleType tt ? tt.componentTypes().size() : 1).mapToObj(o -> indexer.nameOf(loopOp.result(), o)).toList(),\n@@ -383,2 +403,2 @@\n-                                    onnxOp.operands().stream().map(v -> indexer.getName(v)).toList(),\n-                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.getName(onnxOp.result(), o)).toList(),\n+                                    onnxOp.operands().stream().map(indexer::nameOf).toList(),\n+                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.nameOf(onnxOp.result(), o)).toList(),\n@@ -389,1 +409,3 @@\n-                            indexer.put(tlo.result(), indexer.getName(tlo.operands().getFirst(), tlo.index()));\n+                            indexer.mapTupleLoad(tlo.result(), tlo.operands().getFirst(), tlo.index());\n+                        case CoreOp.TupleOp to ->\n+                            indexer.mapTupleElements(to.result(), to.operands());\n@@ -392,1 +414,1 @@\n-                                indexer.put(io.result(), indexer.getName(io.operands().getFirst(), i));\n+                                indexer.mapTupleLoad(io.result(), io.operands().getFirst(), i);\n@@ -394,3 +416,1 @@\n-                                for (int i = 0; i < io.operands().size(); i++) {\n-                                    indexer.put(io.result(),  indexer.getName(io.operands().get(i), i));\n-                                }\n+                                indexer.mapTupleElements(io.result(), io.operands());\n@@ -406,1 +426,9 @@\n-                block.terminatingOp().operands().stream().map(indexer::getName).toList());\n+                block.terminatingOp().operands().stream().<String>mapMulti((o, oc) -> {\n+                    if (o.type() instanceof TupleType tt) {\n+                        for (int i = 0; i < tt.componentTypes().size(); i++) {\n+                            oc.accept(indexer.nameOf(o, i));\n+                        }\n+                    } else {\n+                        oc.accept(indexer.nameOf(o));\n+                    }\n+                }).toList());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":51,"deletions":23,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -240,0 +240,11 @@\n+                \/\/ Transform record static construction\n+                \/\/ @@@ use of NewOp sometimes cause IOOBE from javac at jdk.incubator.code\/jdk.incubator.code.internal.ReflectMethods$BodyScanner.thisValue(ReflectMethods.java:689)\n+                case CoreOp.InvokeOp io when isRecord(l, io.resultType()) -> {\n+                    Op.Result result = bb.op(CoreOp.tuple(bb.context().getValues(io.operands())));\n+                    bb.context().mapValue(io.result(), result);\n+                }\n+                \/\/ Transform record construction\n+                case CoreOp.NewOp no when isRecord(l, no.type()) -> {\n+                    Op.Result result = bb.op(CoreOp.tuple(bb.context().getValues(no.operands())));\n+                    bb.context().mapValue(no.result(), result);\n+                }\n@@ -342,0 +353,11 @@\n+    static boolean isRecord(MethodHandles.Lookup l, TypeElement type) {\n+        if (type instanceof ClassType ct) try {\n+            var t = ct.resolve(l);\n+            while (t instanceof ParameterizedType pt) t = pt.getRawType();\n+            if (t instanceof Class c) return c.isRecord();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return false;\n+    }\n+\n@@ -365,1 +387,0 @@\n-    static final TypeElement LOOP_RETURN_RAW_CLASS = JavaType.type(ExplicitOnnxOps.LoopReturn.class);\n@@ -384,2 +405,0 @@\n-            } else if (ct.rawType().equals(LOOP_RETURN_RAW_CLASS)) {\n-                return JavaType.VOID;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -175,122 +175,0 @@\n-    @OpFactory.OpDeclaration(LoopReturn.NAME)\n-    public static final class LoopReturn extends OnnxOp implements Op.Terminating {\n-        public static final String NAME = \"LoopReturn\";\n-\n-        \/\/ @@@ make or fake body\n-        public enum Attribute implements OnnxOp.OnnxAttribute.None { }\n-\n-        public enum TypeConstraint implements OnnxOp.OnnxTypeConstraint {\n-            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n-            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n-            ;\n-\n-            final OnnxType.TypeVariable typeVariable;\n-\n-            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n-                assert typeVariable.name().equals(name());\n-                this.typeVariable = typeVariable;\n-            }\n-\n-            @Override\n-            public OnnxType.TypeVariable typeVariable() {\n-                return typeVariable;\n-            }\n-        }\n-\n-        public enum InputParameter implements OnnxOp.OnnxParameter {\n-            \/\/ @@@ Onnx spec declares the input parameters as optional, however it is causing problems\n-            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n-            values(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n-            ;\n-\n-            final OnnxType type;\n-            final OnnxOp.OnnxParameter.Quantifier quantifier;\n-\n-            InputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n-                this.type = type;\n-                this.quantifier = quantifier;\n-            }\n-\n-            @Override\n-            public OnnxType type() {\n-                return type;\n-            }\n-\n-            @Override\n-            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n-                return quantifier;\n-            }\n-        }\n-\n-        public enum OutputParameter implements OnnxOp.OnnxParameter {\n-            outputs(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n-            ;\n-\n-            final OnnxType type;\n-            final OnnxOp.OnnxParameter.Quantifier quantifier;\n-\n-            OutputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n-                this.type = type;\n-                this.quantifier = quantifier;\n-            }\n-\n-            @Override\n-            public OnnxType type() {\n-                return type;\n-            }\n-\n-            @Override\n-            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n-                return quantifier;\n-            }\n-        }\n-\n-        public static final OnnxOp.OnnxSchema SCHEMA = new OnnxSchemaRecord(\n-                NAME,\n-                List.of(Attribute.values()),\n-                List.of(TypeConstraint.values()),\n-                List.of(InputParameter.values()),\n-                List.of(OutputParameter.values())\n-        );\n-\n-        public LoopReturn(ExternalizableOp.ExternalizedOp def) {\n-            super(SCHEMA, def);\n-        }\n-\n-        LoopReturn(ExplicitOnnxOps.LoopReturn that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ExplicitOnnxOps.LoopReturn transform(CopyContext cc, OpTransformer ot) {\n-            return new ExplicitOnnxOps.LoopReturn(this, cc, ot);\n-        }\n-\n-        LoopReturn(TypeElement resultType, Value cond, Value v_initial) {\n-            super(SCHEMA, resultType, Set.of(), List.of(cond, v_initial), List.of());\n-        }\n-\n-        @Override\n-        public SequencedSet<OnnxOp.OnnxParameter> onnxOutputs() {\n-            return onnxOutputs(SCHEMA);\n-        }\n-\n-        @Override\n-        public SequencedMap<OnnxOp.OnnxParameter, Object> onnxInputs() {\n-            return onnxInputs(SCHEMA, List.of(cond()));\n-        }\n-\n-\n-        public Value cond() {\n-            return operands().get(0);\n-        }\n-\n-        public List<Value> values() {\n-            return operands().subList(1, operands().size());\n-        }\n-    }\n-\n-    public static LoopReturn LoopReturn(TypeElement resultType, Value cond, Value values) {\n-        return new LoopReturn(resultType, cond, values);\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-        return Loop(max, TRUE, initialValue, (i, cond, v) -> LoopReturn(cond, Add(v, v)));\n+        return Loop(max, TRUE, initialValue, (i, cond, v) -> new LoopReturn<>(cond, Add(v, v)));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                -> LoopReturn(cond, turnLeft(d)));\n+                -> newLoopReturn(cond, turnLeft(d)));\n@@ -147,1 +147,1 @@\n-                return LoopReturn(isWallAt(posInFrontOfMe(pos, dir)), dir);\n+                return newLoopReturn(isWallAt(posInFrontOfMe(pos, dir)), dir);\n@@ -163,1 +163,1 @@\n-            return LoopReturn(Not(atHome(pos)), addToLog(log, pos, direction));\n+            return new LoopReturn<>(Not(atHome(pos)), addToLog(log, pos, direction));\n@@ -175,0 +175,5 @@\n+\n+    \/\/ @@@ use of new LoopReturn may cause IOOBE from javac at jdk.incubator.code\/jdk.incubator.code.internal.ReflectMethods$BodyScanner.thisValue(ReflectMethods.java:689)\n+    static <T> LoopReturn<T> newLoopReturn(Tensor<Boolean> cond, T output) {\n+        return new LoopReturn<>(cond, output);\n+    }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}