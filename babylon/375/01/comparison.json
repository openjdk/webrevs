{"files":[{"patch":"@@ -90,4 +90,0 @@\n-    public static <T> LoopReturn<T> LoopReturn(Tensor<Boolean> cond, T output) {\n-        return new LoopReturn<>(cond, output);\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+import jdk.incubator.code.type.TupleType;\n@@ -318,3 +319,22 @@\n-    private static final class Indexer extends HashMap<Value, String> {\n-        String getName(Value v) {\n-            return computeIfAbsent(v, _ -> \"#\" + size());\n+    private static final class Indexer {\n+\n+        private final HashMap<Value, String> baseNames = new HashMap();\n+        private final HashMap<String, String> elementsMap = new HashMap();\n+\n+\n+        private String baseName(Value value, int elementIndex) {\n+            var name = baseNames.computeIfAbsent(value, _ -> \"#\" + baseNames.size());\n+            return elementIndex > 0 ? name + '.' + elementIndex : name;\n+        }\n+\n+        String nameOf(Value value) {\n+            return nameOf(value, 0);\n+        }\n+\n+        String nameOf(Value tuple, int elementIndex) {\n+            var name = baseName(tuple, elementIndex);\n+            return elementsMap.getOrDefault(name, name);\n+        }\n+\n+        void mapTupleLoad(Value tupleLoadResult, Value tuple, int elementIndex) {\n+            elementsMap.put(baseName(tupleLoadResult, 0), nameOf(tuple, elementIndex));\n@@ -322,4 +342,5 @@\n-        String getName(Value v, int subIndex) {\n-            var name = getName(v);\n-            if (subIndex != 0) name += \".\" + subIndex;\n-            return name;\n+\n+        void mapTupleElements(Value tuple, List<Value> elements) {\n+            for (int i = 0; i < elements.size(); i++) {\n+                elementsMap.put(baseName(tuple, i), nameOf(elements.get(i)));\n+            }\n@@ -354,1 +375,1 @@\n-        params.forEach(indexer::getName);\n+        params.forEach(indexer::nameOf);\n@@ -358,1 +379,1 @@\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n+                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.nameOf(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n@@ -360,1 +381,1 @@\n-                        tensorInfo(indexer.getName(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n+                        tensorInfo(indexer.nameOf(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n@@ -366,2 +387,2 @@\n-                                    List.of(indexer.getName(ifOp.operands().getFirst())),\n-                                    List.of(indexer.getName(ifOp.result())),\n+                                    List.of(indexer.nameOf(ifOp.operands().getFirst())),\n+                                    IntStream.range(0, ifOp.resultType() instanceof TupleType tt ? tt.componentTypes().size() : 1).mapToObj(o -> indexer.nameOf(ifOp.result(), o)).toList(),\n@@ -371,1 +392,0 @@\n-                        case OnnxOps.LoopReturn _ -> {} \/\/ skip\n@@ -375,2 +395,2 @@\n-                                    loopOp.operands().stream().map(indexer::getName).toList(),\n-                                    List.of(indexer.getName(loopOp.result())),\n+                                    loopOp.operands().stream().map(indexer::nameOf).toList(),\n+                                    IntStream.range(0, loopOp.resultType() instanceof TupleType tt ? tt.componentTypes().size() : 1).mapToObj(o -> indexer.nameOf(loopOp.result(), o)).toList(),\n@@ -383,2 +403,2 @@\n-                                    onnxOp.operands().stream().map(v -> indexer.getName(v)).toList(),\n-                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.getName(onnxOp.result(), o)).toList(),\n+                                    onnxOp.operands().stream().map(indexer::nameOf).toList(),\n+                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.nameOf(onnxOp.result(), o)).toList(),\n@@ -389,1 +409,3 @@\n-                            indexer.put(tlo.result(), indexer.getName(tlo.operands().getFirst(), tlo.index()));\n+                            indexer.mapTupleLoad(tlo.result(), tlo.operands().getFirst(), tlo.index());\n+                        case CoreOp.TupleOp to ->\n+                            indexer.mapTupleElements(to.result(), to.operands());\n@@ -392,1 +414,1 @@\n-                                indexer.put(io.result(), indexer.getName(io.operands().getFirst(), i));\n+                                indexer.mapTupleLoad(io.result(), io.operands().getFirst(), i);\n@@ -394,3 +416,1 @@\n-                                for (int i = 0; i < io.operands().size(); i++) {\n-                                    indexer.put(io.result(),  indexer.getName(io.operands().get(i), i));\n-                                }\n+                                indexer.mapTupleElements(io.result(), io.operands());\n@@ -406,1 +426,9 @@\n-                block.terminatingOp().operands().stream().map(indexer::getName).toList());\n+                block.terminatingOp().operands().stream().<String>mapMulti((o, oc) -> {\n+                    if (o.type() instanceof TupleType tt) {\n+                        for (int i = 0; i < tt.componentTypes().size(); i++) {\n+                            oc.accept(indexer.nameOf(o, i));\n+                        }\n+                    } else {\n+                        oc.accept(indexer.nameOf(o));\n+                    }\n+                }).toList());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":51,"deletions":23,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -7,0 +7,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n@@ -12,0 +14,2 @@\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n@@ -16,0 +20,2 @@\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n@@ -83,0 +89,1 @@\n+            System.out.println(func.toText());\n@@ -84,1 +91,1 @@\n-\n+            OnnxProtoPrinter.printModel(protobufModel);\n@@ -103,1 +110,1 @@\n-    public static <T> Tensor<T> execute(OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> T execute(OnnxFunction<T> codeLambda) {\n@@ -107,1 +114,1 @@\n-    public static <T> Tensor<T> execute(MethodHandles.Lookup l, OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> T execute(MethodHandles.Lookup l, OnnxFunction<T> codeLambda) {\n@@ -112,1 +119,1 @@\n-    public static <T> Tensor<T> execute(Arena arena, MethodHandles.Lookup l, OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> T execute(Arena arena, MethodHandles.Lookup l, OnnxFunction<T> codeLambda) {\n@@ -125,1 +132,16 @@\n-        return model.run(arena, arguments).getFirst();\n+        List<Tensor> ret = model.run(arena, arguments);\n+\n+        ClassType retType = ((ClassType)((CoreOp.LambdaOp)q.op()).invokableType().returnType()).rawType();\n+        if (retType.equals(TENSOR_RAW_TYPE)) {\n+            return (T)ret.getFirst();\n+        } else if(retType.equals(LIST_RAW_TYPE)) {\n+            return (T)ret;\n+        } else if(getRecordConstructor(l, retType) instanceof Constructor recordConstructor) {\n+            try {\n+                return (T)recordConstructor.newInstance(ret.toArray());\n+            } catch (ReflectiveOperationException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported return type: \" + q.op().resultType());\n+        }\n@@ -128,0 +150,13 @@\n+    static Constructor getRecordConstructor(MethodHandles.Lookup l, ClassType ct) {\n+        try {\n+            var t = ct.resolve(l);\n+            while (t instanceof ParameterizedType pt) t = pt.getRawType();\n+            if (t instanceof Class c && c.isRecord()) return c.getConstructors()[0];\n+        } catch (ReflectiveOperationException _) {\n+        }\n+        return null;\n+    }\n+\n+    static final JavaType TENSOR_RAW_TYPE = JavaType.type(Tensor.class);\n+    static final JavaType LIST_RAW_TYPE = JavaType.type(List.class);\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -240,0 +240,11 @@\n+                \/\/ Transform record static construction\n+                \/\/ @@@ use of NewOp sometimes cause IOOBE from javac at jdk.incubator.code\/jdk.incubator.code.internal.ReflectMethods$BodyScanner.thisValue(ReflectMethods.java:689)\n+                case CoreOp.InvokeOp io when isRecord(l, io.resultType()) -> {\n+                    Op.Result result = bb.op(CoreOp.tuple(bb.context().getValues(io.operands())));\n+                    bb.context().mapValue(io.result(), result);\n+                }\n+                \/\/ Transform record construction\n+                case CoreOp.NewOp no when isRecord(l, no.type()) -> {\n+                    Op.Result result = bb.op(CoreOp.tuple(bb.context().getValues(no.operands())));\n+                    bb.context().mapValue(no.result(), result);\n+                }\n@@ -342,0 +353,11 @@\n+    static boolean isRecord(MethodHandles.Lookup l, TypeElement type) {\n+        if (type instanceof ClassType ct) try {\n+            var t = ct.resolve(l);\n+            while (t instanceof ParameterizedType pt) t = pt.getRawType();\n+            if (t instanceof Class c) return c.isRecord();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return false;\n+    }\n+\n@@ -365,1 +387,0 @@\n-    static final TypeElement LOOP_RETURN_RAW_CLASS = JavaType.type(ExplicitOnnxOps.LoopReturn.class);\n@@ -384,2 +405,0 @@\n-            } else if (ct.rawType().equals(LOOP_RETURN_RAW_CLASS)) {\n-                return JavaType.VOID;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -175,122 +175,0 @@\n-    @OpFactory.OpDeclaration(LoopReturn.NAME)\n-    public static final class LoopReturn extends OnnxOp implements Op.Terminating {\n-        public static final String NAME = \"LoopReturn\";\n-\n-        \/\/ @@@ make or fake body\n-        public enum Attribute implements OnnxOp.OnnxAttribute.None { }\n-\n-        public enum TypeConstraint implements OnnxOp.OnnxTypeConstraint {\n-            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n-            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n-            ;\n-\n-            final OnnxType.TypeVariable typeVariable;\n-\n-            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n-                assert typeVariable.name().equals(name());\n-                this.typeVariable = typeVariable;\n-            }\n-\n-            @Override\n-            public OnnxType.TypeVariable typeVariable() {\n-                return typeVariable;\n-            }\n-        }\n-\n-        public enum InputParameter implements OnnxOp.OnnxParameter {\n-            \/\/ @@@ Onnx spec declares the input parameters as optional, however it is causing problems\n-            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n-            values(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n-            ;\n-\n-            final OnnxType type;\n-            final OnnxOp.OnnxParameter.Quantifier quantifier;\n-\n-            InputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n-                this.type = type;\n-                this.quantifier = quantifier;\n-            }\n-\n-            @Override\n-            public OnnxType type() {\n-                return type;\n-            }\n-\n-            @Override\n-            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n-                return quantifier;\n-            }\n-        }\n-\n-        public enum OutputParameter implements OnnxOp.OnnxParameter {\n-            outputs(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n-            ;\n-\n-            final OnnxType type;\n-            final OnnxOp.OnnxParameter.Quantifier quantifier;\n-\n-            OutputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n-                this.type = type;\n-                this.quantifier = quantifier;\n-            }\n-\n-            @Override\n-            public OnnxType type() {\n-                return type;\n-            }\n-\n-            @Override\n-            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n-                return quantifier;\n-            }\n-        }\n-\n-        public static final OnnxOp.OnnxSchema SCHEMA = new OnnxSchemaRecord(\n-                NAME,\n-                List.of(Attribute.values()),\n-                List.of(TypeConstraint.values()),\n-                List.of(InputParameter.values()),\n-                List.of(OutputParameter.values())\n-        );\n-\n-        public LoopReturn(ExternalizableOp.ExternalizedOp def) {\n-            super(SCHEMA, def);\n-        }\n-\n-        LoopReturn(ExplicitOnnxOps.LoopReturn that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ExplicitOnnxOps.LoopReturn transform(CopyContext cc, OpTransformer ot) {\n-            return new ExplicitOnnxOps.LoopReturn(this, cc, ot);\n-        }\n-\n-        LoopReturn(TypeElement resultType, Value cond, Value v_initial) {\n-            super(SCHEMA, resultType, Set.of(), List.of(cond, v_initial), List.of());\n-        }\n-\n-        @Override\n-        public SequencedSet<OnnxOp.OnnxParameter> onnxOutputs() {\n-            return onnxOutputs(SCHEMA);\n-        }\n-\n-        @Override\n-        public SequencedMap<OnnxOp.OnnxParameter, Object> onnxInputs() {\n-            return onnxInputs(SCHEMA, List.of(cond()));\n-        }\n-\n-\n-        public Value cond() {\n-            return operands().get(0);\n-        }\n-\n-        public List<Value> values() {\n-            return operands().subList(1, operands().size());\n-        }\n-    }\n-\n-    public static LoopReturn LoopReturn(TypeElement resultType, Value cond, Value values) {\n-        return new LoopReturn(resultType, cond, values);\n-    }\n-\n@@ -399,1 +277,1 @@\n-        Loop(TypeElement resultType, Value m, Value cond, Value v_initial, Body.Builder body) {\n+        Loop(TypeElement resultType, Value m, Value cond, Object v_initial, Body.Builder body) {\n@@ -438,1 +316,1 @@\n-    public static Loop Loop(TypeElement resultType, Value m, Value cond, Value v_initial, Body.Builder body) {\n+    public static Loop Loop(TypeElement resultType, Value m, Value cond, Object v_initial, Body.Builder body) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":2,"deletions":124,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -156,1 +156,13 @@\n-    @Test\n+    @CodeReflection\n+    public List<Tensor<Float>> ifConstList(Tensor<Boolean> cond) {\n+        return If(cond, () -> List.of(Constant(1f)), () -> List.of(Constant(-1f)));\n+    }\n+\n+    public record SingleValueTuple<T>(T val) {}\n+\n+    @CodeReflection\n+    public SingleValueTuple<Tensor<Float>> ifConstRecord(Tensor<Boolean> cond) {\n+        return If(cond, () -> new SingleValueTuple(Constant(1f)), () -> new SingleValueTuple(Constant(-1f)));\n+    }\n+\n+\/\/    @Test\n@@ -168,0 +180,6 @@\n+\n+        assertEquals(expFalse, execute(() -> ifConstList(condFalse)).get(0));\n+        assertEquals(expTrue, execute(() -> ifConstList(condTrue)).get(0));\n+\n+        assertEquals(expFalse, execute(() -> ifConstRecord(condFalse)).val());\n+        assertEquals(expTrue, execute(() -> ifConstRecord(condTrue)).val());\n@@ -239,1 +257,6 @@\n-        return Loop(max, TRUE, initialValue, (i, cond, v) -> LoopReturn(cond, Add(v, v)));\n+        return Loop(max, TRUE, initialValue, (i, cond, v) -> new LoopReturn<>(cond, Add(v, v)));\n+    }\n+\n+    @CodeReflection\n+    public SingleValueTuple<Tensor<Float>> forLoopAddRecord(Tensor<Long> max, Tensor<Float> initialValue) {\n+        return Loop(max, TRUE, new SingleValueTuple<>(initialValue), (i, cond, v) -> new LoopReturn<>(cond, new SingleValueTuple<>(Add(v.val(), v.val()))));\n@@ -249,0 +272,1 @@\n+\/\/        assertEquals(expected, execute(() -> forLoopAddRecord(max, value)).val());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                -> LoopReturn(cond, turnLeft(d)));\n+                -> newLoopReturn(cond, turnLeft(d)));\n@@ -147,1 +147,1 @@\n-                return LoopReturn(isWallAt(posInFrontOfMe(pos, dir)), dir);\n+                return newLoopReturn(isWallAt(posInFrontOfMe(pos, dir)), dir);\n@@ -163,1 +163,1 @@\n-            return LoopReturn(Not(atHome(pos)), addToLog(log, pos, direction));\n+            return new LoopReturn<>(Not(atHome(pos)), addToLog(log, pos, direction));\n@@ -175,0 +175,5 @@\n+\n+    \/\/ @@@ use of new LoopReturn may cause IOOBE from javac at jdk.incubator.code\/jdk.incubator.code.internal.ReflectMethods$BodyScanner.thisValue(ReflectMethods.java:689)\n+    static <T> LoopReturn<T> newLoopReturn(Tensor<Boolean> cond, T output) {\n+        return new LoopReturn<>(cond, output);\n+    }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}