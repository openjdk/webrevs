{"files":[{"patch":"@@ -14,2 +14,0 @@\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n@@ -87,1 +85,1 @@\n-            var trans = OnnxTransformer.ofLambda(l, (CoreOp.LambdaOp)q.op());\n+            var trans = OnnxTransformer.ofQuotedLambda(l, q);\n@@ -89,1 +87,2 @@\n-            byte[] protobufModel = OnnxProtoBuilder.build(func.body().entryBlock(), trans.initializers(getReceiver(q.capturedValues().sequencedValues())));\n+            byte[] protobufModel = OnnxProtoBuilder.build(func.body().entryBlock(),\n+                    trans.initializers(getReceiver(q.capturedValues().sequencedValues())));\n@@ -92,0 +91,1 @@\n+                System.out.println(func.toText());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -19,0 +19,25 @@\n+\/*\n+Analysis and Transformations, in order\n+\n+- Lambda to function, promoting captures to function parameters.\n+  (We need to handle captured Var ops modelling Java method parameters.)\n+- Inline methods.\n+  (We could first choose to transform into a module op of func ops, similar to HAT might do.)\n+- Promote (final) tensor field accesses to parameters.\n+  Each unique field reference is promoted to a function parameter.\n+  (This also accumulates every unique field reference into a list in encounter order,\n+   reflection is used to obtain the tensor values for ONNX initializers.)\n+- Partially evaluate the Java code model, using a clone of the interpreter.\n+- Java code model to ONNX code model.\n+  Lambdas expressions transform recursively (need to restrict where expressions are used\n+  to arguments of invocations)\n+  (Also transforms records to tuples.)\n+  (Using results from partial evaluation.)\n+- Drop unused parameters (i.e., the receiver).\n+  (Could be merged with droping unused operations.)\n+- SSA.\n+- Drop unused operations.\n+\n+ *\/\n+\n+\n@@ -32,7 +57,24 @@\n-    public static OnnxTransformer ofLambda(MethodHandles.Lookup lookup, CoreOp.LambdaOp lambda) {\n-        var lambdaFunc = (CoreOp.FuncOp)lambda.ancestorBody().parentOp().ancestorBody().parentOp();\n-        var flatLambdaFunc = lambdaFunc.transform((bb, op) -> {\n-            switch (op) {\n-                case CoreOp.QuotedOp qo -> {\n-                    bb.context().mapValues(lambdaFunc.parameters(), bb.parameters());\n-                    bb.transformBody(lambda.body(), List.of(), OpTransformer.COPYING_TRANSFORMER);\n+    public static OnnxTransformer ofQuotedLambda(MethodHandles.Lookup lookup, Quoted quotedLambda) {\n+        CoreOp.LambdaOp lambda = (CoreOp.LambdaOp) quotedLambda.op();\n+        assert lambda.parameters().isEmpty();\n+\n+        List<Value> captures = lambda.capturedValues();\n+        List<TypeElement> normalizedCaptureTypes = captures.stream()\n+                .map(v -> v instanceof Op.Result r &&\n+                        r.op() instanceof CoreOp.VarOp vop &&\n+                        vop.initOperand() instanceof Block.Parameter p ? p : v)\n+                .map(Value::type)\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(lambda.invokableType().returnType(), normalizedCaptureTypes);\n+\n+        CoreOp.FuncOp f = CoreOp.FuncOp.func(\"f\", ft).body(b -> {\n+            \/\/ Map input captured values\n+            for (int i = 0; i < captures.size(); i++) {\n+                Value inputCapture = captures.get(i);\n+                Value output;\n+                if (inputCapture instanceof Op.Result r &&\n+                        r.op() instanceof CoreOp.VarOp vop &&\n+                        vop.initOperand() instanceof Block.Parameter) {\n+                    output = b.op(CoreOp.var(b.parameters().get(i)));\n+                } else {\n+                    output = b.parameters().get(i);\n@@ -40,2 +82,1 @@\n-                case CoreOp.ReturnOp _ -> {}\n-                default -> bb.op(op);\n+                b.context().mapValue(inputCapture, output);\n@@ -43,1 +84,2 @@\n-            return bb;\n+\n+            b.transformBody(lambda.body(), List.of(), OpTransformer.COPYING_TRANSFORMER);\n@@ -45,1 +87,2 @@\n-        return new OnnxTransformer(lookup, flatLambdaFunc);\n+\n+        return new OnnxTransformer(lookup, f);\n@@ -71,0 +114,2 @@\n+            \/\/ @@@ This is ugly, in this case we could ask the bb for its furthest ancestor block\n+            \/\/ when we need it\n@@ -108,1 +153,0 @@\n-\n@@ -112,0 +156,1 @@\n+        \/\/ ONNX model transformation\n@@ -119,2 +164,1 @@\n-        var paramTypes = onnxModel.invokableType().parameterTypes();\n-\n+        \/\/ Drop unused parameters transformation, can be merged with drop unused operations transformation\n@@ -122,3 +166,7 @@\n-        if (!paramTypes.isEmpty() && !(paramTypes.getFirst() instanceof OnnxType.TensorType)) {\n-            \/\/ drop receiver\n-            var funcType = FunctionType.functionType(onnxModel.invokableType().returnType(), paramTypes.subList(1, paramTypes.size()));\n+        if (onnxModel.parameters().stream().anyMatch(v -> v.uses().isEmpty())) {\n+            List<Block.Parameter> usedParameters = onnxModel.parameters().stream()\n+                    .filter(v -> !v.uses().isEmpty())\n+                    .toList();\n+            List<TypeElement> usedParameterTypes = usedParameters.stream().map(Value::type).toList();\n+\n+            var funcType = FunctionType.functionType(onnxModel.invokableType().returnType(), usedParameterTypes);\n@@ -126,1 +174,1 @@\n-                bb.context().mapValues(onnxModel.parameters().subList(1, paramTypes.size()), bb.parameters());\n+                bb.context().mapValues(usedParameters, bb.parameters());\n@@ -131,0 +179,1 @@\n+        \/\/ SSA and drop unused operations transformation\n@@ -218,1 +267,1 @@\n-                            opArgs.add(transformBodyTranslateTypes(l, lambda.body(), bb.context(), bodyTransformer(pe)));\n+                            opArgs.add(transformBodyTranslateTypes(l, lambda, bb, bodyTransformer(pe)));\n@@ -223,1 +272,1 @@\n-                        opArgs.add(transformBodyTranslateTypes(l, lambda.body(), bb.context(), bodyTransformer(pe)));\n+                        opArgs.add(transformBodyTranslateTypes(l, lambda, bb, bodyTransformer(pe)));\n@@ -257,5 +306,0 @@\n-                case Op.Terminating _ -> {\n-                    try {\n-                        bb.op(op); \/\/ @@@ how to test the terminating op has been already inserted?\n-                    } catch (IllegalStateException _) {}\n-                }\n@@ -270,2 +314,8 @@\n-    static Body.Builder transformBodyTranslateTypes(MethodHandles.Lookup l, Body body, CopyContext cc, OpTransformer ot) {\n-\/\/        return body.transform(cc, ot);\n+    static Body.Builder transformBodyTranslateTypes(MethodHandles.Lookup l, Op.Invokable iop,\n+                                                    Block.Builder ancestor, OpTransformer ot) {\n+        \/\/ @@@ Pass in function type to override that of body's type?\n+\/\/        return iop.body().transform(cc, ot);\n+        FunctionType inputType = iop.invokableType();\n+        FunctionType outputType = FunctionType.functionType(\n+                type(l, inputType.returnType()),\n+                inputType.parameterTypes().stream().map(pt -> type(l, pt)).toList());\n@@ -273,1 +323,5 @@\n-        Body ancestorBody = body.parentOp().parentBlock() instanceof Block parentBlock ? parentBlock.parentBody() : null;\n+        \/\/ @@@ It's not clear in the API when to pass CopyContext and OpTransformer\n+        \/\/ @@@ create a Body.Builder structurally connected as a descendant of a Block.Builder\n+        \/\/ but not yet connected as the child of an operation\n+        Body.Builder bb = Body.Builder.of(ancestor.parentBody(),\n+                outputType, ancestor.context()); \/\/ translate types\n@@ -275,10 +329,1 @@\n-        Block.Builder ancestorBlockBuilder = ancestorBody != null\n-                ? cc.getBlock(ancestorBody.entryBlock()) : null;\n-        Body.Builder ancestorBodyBuilder = ancestorBlockBuilder != null\n-                ? ancestorBlockBuilder.parentBody() : null;\n-\n-        Body.Builder bb = Body.Builder.of(ancestorBodyBuilder, FunctionType.functionType(type(l, body.yieldType())), cc, ot); \/\/ translate types\n-        for (Block.Parameter p : body.entryBlock().parameters()) {\n-            bb.entryBlock().parameter(type(l, p.type())); \/\/ translate types\n-        }\n-        bb.entryBlock().transformBody(body, bb.entryBlock().parameters(), cc, ot);\n+        bb.entryBlock().transformBody(iop.body(), bb.entryBlock().parameters(), ot);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":83,"deletions":38,"binary":false,"changes":121,"status":"modified"}]}