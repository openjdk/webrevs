{"files":[{"patch":"@@ -6,0 +6,1 @@\n+import java.util.ArrayList;\n@@ -12,0 +13,1 @@\n+import jdk.incubator.code.TypeElement;\n@@ -380,2 +382,1 @@\n-                IntStream.range(0, args.size()).mapToObj(i ->\n-                        tensorInfo(indexer.nameOf(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n+                tensorInfos(indexer, args, scalarArgs),\n@@ -437,0 +438,19 @@\n+    static List<ValueInfoProto> tensorInfos(Indexer indexer, List<Block.Parameter> args, int scalarArgs) {\n+        var infos = new ArrayList<ValueInfoProto>();\n+        for (var arg : args) {\n+            switch (arg.type()) {\n+                case OnnxType.TensorType tt ->\n+                    infos.add(tensorInfo(indexer.nameOf(arg), tt.eType().id(), infos.size() < scalarArgs));\n+                case TupleType tt -> {\n+                    var ct = tt.componentTypes();\n+                    for (int i = 0; i < ct.size(); i++) {\n+                        infos.add(tensorInfo(indexer.nameOf(arg, i), ((OnnxType.TensorType)ct.get(i)).eType().id(), infos.size() < scalarArgs));\n+                    }\n+                }\n+                default ->\n+                    throw new UnsupportedOperationException();\n+            }\n+        }\n+        return infos;\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-        FunctionType ft = FunctionType.functionType(type(inputFunc.invokableType().returnType()),\n-                inputFunc.invokableType().parameterTypes().stream().map(OnnxTransformer::type).toList()\n+        FunctionType ft = FunctionType.functionType(type(l, inputFunc.invokableType().returnType()),\n+                inputFunc.invokableType().parameterTypes().stream().map(te -> type(l, te)).toList()\n@@ -168,1 +168,1 @@\n-                        opArgs.add(type(op.resultType()));\n+                        opArgs.add(type(l, op.resultType()));\n@@ -218,1 +218,1 @@\n-                            opArgs.add(transformBodyTranslateTypes(lambda.body(), bb.context(), bodyTransformer(pe)));\n+                            opArgs.add(transformBodyTranslateTypes(l, lambda.body(), bb.context(), bodyTransformer(pe)));\n@@ -223,1 +223,1 @@\n-                        opArgs.add(transformBodyTranslateTypes(lambda.body(), bb.context(), bodyTransformer(pe)));\n+                        opArgs.add(transformBodyTranslateTypes(l, lambda.body(), bb.context(), bodyTransformer(pe)));\n@@ -276,1 +276,1 @@\n-    static Body.Builder transformBodyTranslateTypes(Body body, CopyContext cc, OpTransformer ot) {\n+    static Body.Builder transformBodyTranslateTypes(MethodHandles.Lookup l, Body body, CopyContext cc, OpTransformer ot) {\n@@ -286,1 +286,1 @@\n-        Body.Builder bb = Body.Builder.of(ancestorBodyBuilder, FunctionType.functionType(type(body.yieldType())), cc, ot); \/\/ translate types\n+        Body.Builder bb = Body.Builder.of(ancestorBodyBuilder, FunctionType.functionType(type(l, body.yieldType())), cc, ot); \/\/ translate types\n@@ -288,1 +288,1 @@\n-            bb.entryBlock().parameter(type(p.type())); \/\/ translate types\n+            bb.entryBlock().parameter(type(l, p.type())); \/\/ translate types\n@@ -330,1 +330,1 @@\n-                            tupleComponentTypes.add(type(JavaType.type(pt)));\n+                            tupleComponentTypes.add(type(l, JavaType.type(pt)));\n@@ -341,1 +341,1 @@\n-                            tupleComponentTypes.add(type(JavaType.parameterized(JavaType.type(Tensor.class), e)));\n+                            tupleComponentTypes.add(type(l, JavaType.parameterized(JavaType.type(Tensor.class), e)));\n@@ -346,0 +346,11 @@\n+                case TypeVariable tv -> {\n+                    \/\/ Resolve type variable\n+                    JavaType e = null;\n+                    for (int j = 0; j < recordClass.getTypeParameters().length; j++) {\n+                        if (recordClass.getTypeParameters()[j].getName().equals(tv.getName())) {\n+                            e = recordType.typeArguments().get(j);\n+                            break;\n+                        }\n+                    }\n+                    tupleComponentTypes.add(type(l, e));\n+                }\n@@ -365,1 +376,1 @@\n-        if (ref.refType() instanceof ClassType ct && ct.toClassName().startsWith(\"oracle.code.onnx.OnnxOperators$\")) {\n+        if (ref.refType() instanceof ClassType ct) {\n@@ -390,1 +401,1 @@\n-    static TypeElement type(TypeElement type) {\n+    static TypeElement type(MethodHandles.Lookup l, TypeElement type) {\n@@ -405,0 +416,2 @@\n+            } else if (isRecord(l, type)) {\n+                return recordTypeToTupleType(l, ct);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-\/\/        assertEquals(expected, execute(() -> forLoopAddRecord(max, value)).val());\n+        assertEquals(expected, execute(() -> forLoopAddRecord(max, value)).val());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}