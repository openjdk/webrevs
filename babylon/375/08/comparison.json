{"files":[{"patch":"@@ -89,5 +89,1 @@\n-    public record LoopReturn<T>(Tensor<Boolean> cond, T output) {}\n-    public static <T> LoopReturn<T> LoopReturn(Tensor<Boolean> cond, T output) {\n-        return new LoopReturn<>(cond, output);\n-    }\n-\n+    public record LoopResult<T>(Tensor<Boolean> cond, T output) {}\n@@ -95,1 +91,1 @@\n-        LoopReturn<T> invoke(Tensor<Long> i, Tensor<Boolean> cond, T input);\n+        LoopResult<T> invoke(Tensor<Long> i, Tensor<Boolean> cond, T input);\n@@ -101,1 +97,1 @@\n-            LoopReturn<T> ret = loopBody.invoke(i, cond, values);\n+            LoopResult<T> ret = loopBody.invoke(i, cond, values);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.util.ArrayList;\n@@ -12,0 +13,1 @@\n+import jdk.incubator.code.TypeElement;\n@@ -15,0 +17,1 @@\n+import jdk.incubator.code.type.TupleType;\n@@ -318,3 +321,22 @@\n-    private static final class Indexer extends HashMap<Value, String> {\n-        String getName(Value v) {\n-            return computeIfAbsent(v, _ -> \"#\" + size());\n+    private static final class Indexer {\n+\n+        private final HashMap<Value, String> baseNames = new HashMap();\n+        private final HashMap<String, String> elementsMap = new HashMap();\n+\n+\n+        private String baseName(Value value, int elementIndex) {\n+            var name = baseNames.computeIfAbsent(value, _ -> \"#\" + baseNames.size());\n+            return elementIndex > 0 ? name + '.' + elementIndex : name;\n+        }\n+\n+        String nameOf(Value value) {\n+            return nameOf(value, 0);\n+        }\n+\n+        String nameOf(Value tuple, int elementIndex) {\n+            var name = baseName(tuple, elementIndex);\n+            return elementsMap.getOrDefault(name, name);\n+        }\n+\n+        void mapTupleLoad(Value tupleLoadResult, Value tuple, int elementIndex) {\n+            elementsMap.put(baseName(tupleLoadResult, 0), nameOf(tuple, elementIndex));\n@@ -322,4 +344,5 @@\n-        String getName(Value v, int subIndex) {\n-            var name = getName(v);\n-            if (subIndex != 0) name += \".\" + subIndex;\n-            return name;\n+\n+        void mapTupleElements(Value tuple, List<Value> elements) {\n+            for (int i = 0; i < elements.size(); i++) {\n+                elementsMap.put(baseName(tuple, i), nameOf(elements.get(i)));\n+            }\n@@ -352,0 +375,21 @@\n+    static List<String> expandTuples(Indexer indexer, List<Value> values) {\n+        var names = new ArrayList<String>();\n+        expandTuples(indexer, names, values);\n+        return names;\n+    }\n+\n+    static void expandTuples(Indexer indexer, List<String> names, List<Value> values) {\n+        for (var v : values) {\n+            if (v instanceof Op.Result or && or.op() instanceof CoreOp.TupleOp op) {\n+                expandTuples(indexer, names, op.operands());\n+            } else if (v.type() instanceof TupleType tt) {\n+                var ct = tt.componentTypes();\n+                for (int i = 0; i < ct.size(); i++) {\n+                    names.add(indexer.nameOf(v, i));\n+                }\n+            } else {\n+                names.add(indexer.nameOf(v));\n+            }\n+        }\n+    }\n+\n@@ -354,1 +398,1 @@\n-        params.forEach(indexer::getName);\n+        params.forEach(indexer::nameOf);\n@@ -357,4 +401,2 @@\n-        return graph(\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n-                IntStream.range(0, args.size()).mapToObj(i ->\n-                        tensorInfo(indexer.getName(args.get(i)), ((OnnxType.TensorType)args.get(i).type()).eType().id(), i < scalarArgs)).toList(),\n+        return graph(IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.nameOf(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n+                tensorInfos(indexer, args, scalarArgs),\n@@ -366,2 +408,2 @@\n-                                    List.of(indexer.getName(ifOp.operands().getFirst())),\n-                                    List.of(indexer.getName(ifOp.result())),\n+                                    List.of(indexer.nameOf(ifOp.operands().getFirst())),\n+                                    IntStream.range(0, ifOp.resultType() instanceof TupleType tt ? tt.componentTypes().size() : 1).mapToObj(o -> indexer.nameOf(ifOp.result(), o)).toList(),\n@@ -371,1 +413,0 @@\n-                        case OnnxOps.LoopReturn _ -> {} \/\/ skip\n@@ -373,4 +414,3 @@\n-                            opNodes.accept(node(\n-                                    loopOp.opName(),\n-                                    loopOp.operands().stream().map(indexer::getName).toList(),\n-                                    List.of(indexer.getName(loopOp.result())),\n+                            opNodes.accept(node(loopOp.opName(),\n+                                    expandTuples(indexer, loopOp.operands()),\n+                                    IntStream.range(0, loopOp.resultType() instanceof TupleType tt ? tt.componentTypes().size() : 1).mapToObj(o -> indexer.nameOf(loopOp.result(), o)).toList(),\n@@ -383,2 +423,2 @@\n-                                    onnxOp.operands().stream().map(v -> indexer.getName(v)).toList(),\n-                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.getName(onnxOp.result(), o)).toList(),\n+                                    onnxOp.operands().stream().map(indexer::nameOf).toList(),\n+                                    IntStream.range(0, onnxOp.onnxOutputs().size()).mapToObj(o -> indexer.nameOf(onnxOp.result(), o)).toList(),\n@@ -389,1 +429,3 @@\n-                            indexer.put(tlo.result(), indexer.getName(tlo.operands().getFirst(), tlo.index()));\n+                            indexer.mapTupleLoad(tlo.result(), tlo.operands().getFirst(), tlo.index());\n+                        case CoreOp.TupleOp to ->\n+                            indexer.mapTupleElements(to.result(), to.operands());\n@@ -392,1 +434,1 @@\n-                                indexer.put(io.result(), indexer.getName(io.operands().getFirst(), i));\n+                                indexer.mapTupleLoad(io.result(), io.operands().getFirst(), i);\n@@ -394,3 +436,1 @@\n-                                for (int i = 0; i < io.operands().size(); i++) {\n-                                    indexer.put(io.result(),  indexer.getName(io.operands().get(i), i));\n-                                }\n+                                indexer.mapTupleElements(io.result(), io.operands());\n@@ -406,1 +446,20 @@\n-                block.terminatingOp().operands().stream().map(indexer::getName).toList());\n+                expandTuples(indexer, block.terminatingOp().operands()));\n+    }\n+\n+    static List<ValueInfoProto> tensorInfos(Indexer indexer, List<Block.Parameter> args, int scalarArgs) {\n+        var infos = new ArrayList<ValueInfoProto>();\n+        for (var arg : args) {\n+            switch (arg.type()) {\n+                case OnnxType.TensorType tt ->\n+                    infos.add(tensorInfo(indexer.nameOf(arg), tt.eType().id(), infos.size() < scalarArgs));\n+                case TupleType tt -> {\n+                    var ct = tt.componentTypes();\n+                    for (int i = 0; i < ct.size(); i++) {\n+                        infos.add(tensorInfo(indexer.nameOf(arg, i), ((OnnxType.TensorType)ct.get(i)).eType().id(), infos.size() < scalarArgs));\n+                    }\n+                }\n+                default ->\n+                    throw new UnsupportedOperationException();\n+            }\n+        }\n+        return infos;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":86,"deletions":27,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -7,0 +7,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n@@ -12,0 +14,2 @@\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n@@ -16,0 +20,2 @@\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.JavaType;\n@@ -86,1 +92,0 @@\n-                System.out.println(func.toText());\n@@ -103,1 +108,1 @@\n-    public static <T> Tensor<T> execute(OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> T execute(OnnxFunction<T> codeLambda) {\n@@ -107,1 +112,1 @@\n-    public static <T> Tensor<T> execute(MethodHandles.Lookup l, OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> T execute(MethodHandles.Lookup l, OnnxFunction<T> codeLambda) {\n@@ -112,1 +117,1 @@\n-    public static <T> Tensor<T> execute(Arena arena, MethodHandles.Lookup l, OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> T execute(Arena arena, MethodHandles.Lookup l, OnnxFunction<T> codeLambda) {\n@@ -125,1 +130,16 @@\n-        return model.run(arena, arguments).getFirst();\n+        List<Tensor> ret = model.run(arena, arguments);\n+\n+        ClassType retType = ((ClassType)((CoreOp.LambdaOp)q.op()).invokableType().returnType()).rawType();\n+        if (retType.equals(TENSOR_RAW_TYPE)) {\n+            return (T)ret.getFirst();\n+        } else if(retType.equals(LIST_RAW_TYPE)) {\n+            return (T)ret;\n+        } else if(getRecordConstructor(l, retType) instanceof Constructor recordConstructor) {\n+            try {\n+                return (T)recordConstructor.newInstance(ret.toArray());\n+            } catch (Exception e) {\n+                throw new IllegalStateException(e);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported return type: \" + q.op().resultType());\n+        }\n@@ -128,0 +148,13 @@\n+    static Constructor getRecordConstructor(MethodHandles.Lookup l, ClassType ct) {\n+        try {\n+            var t = ct.resolve(l);\n+            while (t instanceof ParameterizedType pt) t = pt.getRawType();\n+            if (t instanceof Class c && c.isRecord()) return c.getConstructors()[0];\n+        } catch (ReflectiveOperationException _) {\n+        }\n+        return null;\n+    }\n+\n+    static final JavaType TENSOR_RAW_TYPE = JavaType.type(Tensor.class);\n+    static final JavaType LIST_RAW_TYPE = JavaType.type(List.class);\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-        FunctionType ft = FunctionType.functionType(type(inputFunc.invokableType().returnType()),\n-                inputFunc.invokableType().parameterTypes().stream().map(OnnxTransformer::type).toList()\n+        FunctionType ft = FunctionType.functionType(type(l, inputFunc.invokableType().returnType()),\n+                inputFunc.invokableType().parameterTypes().stream().map(te -> type(l, te)).toList()\n@@ -168,1 +168,1 @@\n-                        opArgs.add(type(op.resultType()));\n+                        opArgs.add(type(l, op.resultType()));\n@@ -218,1 +218,1 @@\n-                            opArgs.add(transformBodyTranslateTypes(lambda.body(), bb.context(), bodyTransformer(pe)));\n+                            opArgs.add(transformBodyTranslateTypes(l, lambda.body(), bb.context(), bodyTransformer(pe)));\n@@ -223,1 +223,1 @@\n-                        opArgs.add(transformBodyTranslateTypes(lambda.body(), bb.context(), bodyTransformer(pe)));\n+                        opArgs.add(transformBodyTranslateTypes(l, lambda.body(), bb.context(), bodyTransformer(pe)));\n@@ -240,0 +240,5 @@\n+                \/\/ Transform record construction\n+                case CoreOp.NewOp no when isRecord(l, no.type()) -> {\n+                    Op.Result result = bb.op(CoreOp.tuple(bb.context().getValues(no.operands())));\n+                    bb.context().mapValue(no.result(), result);\n+                }\n@@ -264,2 +269,2 @@\n-    \/\/ @@@ Ugly copy of Body::transform content to translate types\n-    static Body.Builder transformBodyTranslateTypes(Body body, CopyContext cc, OpTransformer ot) {\n+    \/\/ @@@ Copy of Body::transform content to translate types\n+    static Body.Builder transformBodyTranslateTypes(MethodHandles.Lookup l, Body body, CopyContext cc, OpTransformer ot) {\n@@ -275,1 +280,1 @@\n-        Body.Builder bb = Body.Builder.of(ancestorBodyBuilder, FunctionType.functionType(type(body.yieldType())), cc, ot); \/\/ translate types\n+        Body.Builder bb = Body.Builder.of(ancestorBodyBuilder, FunctionType.functionType(type(l, body.yieldType())), cc, ot); \/\/ translate types\n@@ -277,1 +282,1 @@\n-            bb.entryBlock().parameter(type(p.type())); \/\/ translate types\n+            bb.entryBlock().parameter(type(l, p.type())); \/\/ translate types\n@@ -319,1 +324,1 @@\n-                            tupleComponentTypes.add(type(JavaType.type(pt)));\n+                            tupleComponentTypes.add(type(l, JavaType.type(pt)));\n@@ -330,1 +335,1 @@\n-                            tupleComponentTypes.add(type(JavaType.parameterized(JavaType.type(Tensor.class), e)));\n+                            tupleComponentTypes.add(type(l, JavaType.parameterized(JavaType.type(Tensor.class), e)));\n@@ -335,0 +340,11 @@\n+                case TypeVariable tv -> {\n+                    \/\/ Resolve type variable\n+                    JavaType e = null;\n+                    for (int j = 0; j < recordClass.getTypeParameters().length; j++) {\n+                        if (recordClass.getTypeParameters()[j].getName().equals(tv.getName())) {\n+                            e = recordType.typeArguments().get(j);\n+                            break;\n+                        }\n+                    }\n+                    tupleComponentTypes.add(type(l, e));\n+                }\n@@ -342,0 +358,10 @@\n+    static boolean isRecord(MethodHandles.Lookup l, TypeElement type) {\n+        try {\n+            return type instanceof ClassType ct &&\n+                    ct.erasure().resolve(l) instanceof Class c &&\n+                    c.isRecord();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -343,1 +369,1 @@\n-        if (ref.refType() instanceof ClassType ct && ct.toClassName().startsWith(\"oracle.code.onnx.OnnxOperators$\")) {\n+        if (ref.refType() instanceof ClassType ct) {\n@@ -365,1 +391,0 @@\n-    static final TypeElement LOOP_RETURN_RAW_CLASS = JavaType.type(ExplicitOnnxOps.LoopReturn.class);\n@@ -369,1 +394,1 @@\n-    static TypeElement type(TypeElement type) {\n+    static TypeElement type(MethodHandles.Lookup l, TypeElement type) {\n@@ -384,2 +409,2 @@\n-            } else if (ct.rawType().equals(LOOP_RETURN_RAW_CLASS)) {\n-                return JavaType.VOID;\n+            } else if (isRecord(l, type)) {\n+                return recordTypeToTupleType(l, ct);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -175,122 +175,0 @@\n-    @OpFactory.OpDeclaration(LoopReturn.NAME)\n-    public static final class LoopReturn extends OnnxOp implements Op.Terminating {\n-        public static final String NAME = \"LoopReturn\";\n-\n-        \/\/ @@@ make or fake body\n-        public enum Attribute implements OnnxOp.OnnxAttribute.None { }\n-\n-        public enum TypeConstraint implements OnnxOp.OnnxTypeConstraint {\n-            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n-            B(new OnnxType.TypeVariable(\"B\", List.of(OnnxType.tensor(OnnxType.bool())))),\n-            ;\n-\n-            final OnnxType.TypeVariable typeVariable;\n-\n-            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n-                assert typeVariable.name().equals(name());\n-                this.typeVariable = typeVariable;\n-            }\n-\n-            @Override\n-            public OnnxType.TypeVariable typeVariable() {\n-                return typeVariable;\n-            }\n-        }\n-\n-        public enum InputParameter implements OnnxOp.OnnxParameter {\n-            \/\/ @@@ Onnx spec declares the input parameters as optional, however it is causing problems\n-            cond(TypeConstraint.B.typeVariable(), OnnxOp.OnnxParameter.Quantifier.REQUIRED),\n-            values(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n-            ;\n-\n-            final OnnxType type;\n-            final OnnxOp.OnnxParameter.Quantifier quantifier;\n-\n-            InputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n-                this.type = type;\n-                this.quantifier = quantifier;\n-            }\n-\n-            @Override\n-            public OnnxType type() {\n-                return type;\n-            }\n-\n-            @Override\n-            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n-                return quantifier;\n-            }\n-        }\n-\n-        public enum OutputParameter implements OnnxOp.OnnxParameter {\n-            outputs(TypeConstraint.V.typeVariable(), OnnxOp.OnnxParameter.Quantifier.VARIADIC),\n-            ;\n-\n-            final OnnxType type;\n-            final OnnxOp.OnnxParameter.Quantifier quantifier;\n-\n-            OutputParameter(OnnxType type, OnnxOp.OnnxParameter.Quantifier quantifier) {\n-                this.type = type;\n-                this.quantifier = quantifier;\n-            }\n-\n-            @Override\n-            public OnnxType type() {\n-                return type;\n-            }\n-\n-            @Override\n-            public OnnxOp.OnnxParameter.Quantifier quantifier() {\n-                return quantifier;\n-            }\n-        }\n-\n-        public static final OnnxOp.OnnxSchema SCHEMA = new OnnxSchemaRecord(\n-                NAME,\n-                List.of(Attribute.values()),\n-                List.of(TypeConstraint.values()),\n-                List.of(InputParameter.values()),\n-                List.of(OutputParameter.values())\n-        );\n-\n-        public LoopReturn(ExternalizableOp.ExternalizedOp def) {\n-            super(SCHEMA, def);\n-        }\n-\n-        LoopReturn(ExplicitOnnxOps.LoopReturn that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ExplicitOnnxOps.LoopReturn transform(CopyContext cc, OpTransformer ot) {\n-            return new ExplicitOnnxOps.LoopReturn(this, cc, ot);\n-        }\n-\n-        LoopReturn(TypeElement resultType, Value cond, Value v_initial) {\n-            super(SCHEMA, resultType, Set.of(), List.of(cond, v_initial), List.of());\n-        }\n-\n-        @Override\n-        public SequencedSet<OnnxOp.OnnxParameter> onnxOutputs() {\n-            return onnxOutputs(SCHEMA);\n-        }\n-\n-        @Override\n-        public SequencedMap<OnnxOp.OnnxParameter, Object> onnxInputs() {\n-            return onnxInputs(SCHEMA, List.of(cond()));\n-        }\n-\n-\n-        public Value cond() {\n-            return operands().get(0);\n-        }\n-\n-        public List<Value> values() {\n-            return operands().subList(1, operands().size());\n-        }\n-    }\n-\n-    public static LoopReturn LoopReturn(TypeElement resultType, Value cond, Value values) {\n-        return new LoopReturn(resultType, cond, values);\n-    }\n-\n@@ -399,1 +277,1 @@\n-        Loop(TypeElement resultType, Value m, Value cond, Value v_initial, Body.Builder body) {\n+        Loop(TypeElement resultType, Value m, Value cond, Object v_initial, Body.Builder body) {\n@@ -438,1 +316,1 @@\n-    public static Loop Loop(TypeElement resultType, Value m, Value cond, Value v_initial, Body.Builder body) {\n+    public static Loop Loop(TypeElement resultType, Value m, Value cond, Object v_initial, Body.Builder body) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":2,"deletions":124,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -156,0 +156,12 @@\n+    @CodeReflection\n+    public List<Tensor<Float>> ifConstList(Tensor<Boolean> cond) {\n+        return If(cond, () -> List.of(Constant(1f)), () -> List.of(Constant(-1f)));\n+    }\n+\n+    public record SingleValueTuple<T>(T val) {}\n+\n+    @CodeReflection\n+    public SingleValueTuple<Tensor<Float>> ifConstRecord(Tensor<Boolean> cond) {\n+        return If(cond, () -> new SingleValueTuple<>(Constant(1f)), () -> new SingleValueTuple<>(Constant(-1f)));\n+    }\n+\n@@ -168,0 +180,6 @@\n+\n+        assertEquals(expFalse, execute(() -> ifConstList(condFalse)).get(0));\n+        assertEquals(expTrue, execute(() -> ifConstList(condTrue)).get(0));\n+\n+        assertEquals(expFalse, execute(() -> ifConstRecord(condFalse)).val());\n+        assertEquals(expTrue, execute(() -> ifConstRecord(condTrue)).val());\n@@ -239,1 +257,6 @@\n-        return Loop(max, TRUE, initialValue, (i, cond, v) -> LoopReturn(cond, Add(v, v)));\n+        return Loop(max, TRUE, initialValue, (i, cond, v) -> new LoopResult<>(cond, Add(v, v)));\n+    }\n+\n+    @CodeReflection\n+    public SingleValueTuple<Tensor<Float>> forLoopAddRecord(Tensor<Long> max, Tensor<Float> initialValue) {\n+        return Loop(max, TRUE, new SingleValueTuple<>(initialValue), (i, cond, v) -> new LoopResult<>(cond, new SingleValueTuple<>(Add(v.val(), v.val()))));\n@@ -249,0 +272,19 @@\n+        assertEquals(expected, execute(() -> forLoopAddRecord(max, value)).val());\n+    }\n+\n+    public record Tuple(Tensor<Long> a, Tensor<Float> b) {}\n+\n+    @CodeReflection\n+    public Tuple loop(Tensor<Boolean> b) {\n+        var c1 = Constant(1l);\n+        var c2 = Constant(1f);\n+        var c3 = Constant(4l);\n+        return Loop(c3, b, new Tuple(c1, c2), (i, cond, v) -> new LoopResult<>(Identity(cond), new Tuple(Add(v.a(), v.a()), Identity(Add(v.b(), v.b())))));\n+    }\n+\n+    @Test\n+    public void testLoop() throws Exception {\n+        var b = Tensor.ofScalar(true);\n+        var res = execute(() -> loop(b));\n+        assertEquals(Tensor.ofScalar(16l), res.a());\n+        assertEquals(Tensor.ofScalar(16f), res.b());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-import java.util.Optional;\n@@ -23,2 +22,1 @@\n-    final Tensor<Long> homePos, directionNorth, directionSouth, directionEast, directionWest,\n-                       oneOne, zero, two, three, mOne, mThree, max, limit,\n+    final Tensor<Long> homePos, directionNorth, directionSouth, directionEast, directionWest, oneOne, three, limit,\n@@ -69,2 +67,0 @@\n-        zero = Tensor.ofFlat(arena, 0l);\n-        two = Tensor.ofFlat(arena, 2l);\n@@ -72,3 +68,0 @@\n-        mOne = Tensor.ofFlat(arena, -1l);\n-        mThree = Tensor.ofFlat(arena, -3l);\n-        max = Tensor.ofFlat(arena, Long.MAX_VALUE);\n@@ -98,1 +91,1 @@\n-                -> LoopReturn(cond, turnLeft(d)));\n+                -> new LoopResult<>(cond, turnLeft(d)));\n@@ -122,20 +115,0 @@\n-    @CodeReflection\n-    public Tensor<Long> lastPos(Tensor<Long> pathLog) {\n-        return Slice(pathLog, mThree, mOne, empty(), empty());\n-    }\n-\n-    @CodeReflection\n-    public Tensor<Long> lastDirection(Tensor<Long> pathLog) {\n-        return Slice(pathLog, mOne, max, empty(), empty());\n-    }\n-\n-    @CodeReflection\n-    public Tensor<Long> addToLog(Tensor<Long> pathLog, Tensor<Long> pos, Tensor<Long> direction) {\n-        return Concat(List.of(pathLog, pos, direction), 0);\n-    }\n-\n-    @CodeReflection\n-    public Tensor<Byte> extractDirections(Tensor<Long> pathLog) {\n-        return Cast(Slice(pathLog, two, max, Optional.of(zero), Optional.of(three)), empty(), 3);\n-    }\n-\n@@ -147,1 +120,1 @@\n-                return LoopReturn(isWallAt(posInFrontOfMe(pos, dir)), dir);\n+                return new LoopResult<>(isWallAt(posInFrontOfMe(pos, dir)), dir);\n@@ -152,5 +125,5 @@\n-    public Tensor<Long> walkAroundTheMaze() {\n-        var start = Concat(List.of(homePos, directionEast), 0);\n-        var pathLog = Loop(limit, _true, start, (_, _, log) -> {\n-            var pos = lastPos(log);\n-            var direction = lastDirection(log);\n+    public Tensor<Byte> appendToPath(Tensor<Byte> path, Tensor<Long> direction) {\n+        return Concat(List.of(path, Cast(direction, empty(), 2)), 0);\n+    }\n+\n+    public record LoopData(Tensor<Long> pos, Tensor<Long> direction, Tensor<Byte> path) {}\n@@ -158,0 +131,4 @@\n+    @CodeReflection\n+    public Tensor<Byte> walkAroundTheMaze() {\n+        var initData = new LoopData(homePos, directionEast, Cast(directionEast, empty(), 2));\n+        var outData = Loop(limit, _true, initData, (_, _, loopData) -> {\n@@ -159,2 +136,2 @@\n-            pos = posInFrontOfMe(pos, direction);\n-            direction = turnRight(direction);\n+            var pos = posInFrontOfMe(loopData.pos(), loopData.direction());\n+            var direction = turnRight(loopData.direction());\n@@ -163,1 +140,1 @@\n-            return LoopReturn(Not(atHome(pos)), addToLog(log, pos, direction));\n+            return new LoopResult<>(Not(atHome(pos)), new LoopData(pos, direction, appendToPath(loopData.path(), direction)));\n@@ -165,1 +142,1 @@\n-        return pathLog;\n+        return outData.path();\n@@ -171,1 +148,1 @@\n-            var directions = execute(arena, MethodHandles.lookup(), () -> extractDirections(walkAroundTheMaze()));\n+            var directions = execute(arena, MethodHandles.lookup(), () -> walkAroundTheMaze());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":17,"deletions":40,"binary":false,"changes":57,"status":"modified"}]}