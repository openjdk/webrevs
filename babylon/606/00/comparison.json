{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import hat.codebuilders.CodeBuilder;\n@@ -29,1 +30,7 @@\n-\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVSelectStoreOp;\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorStoreView;\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -31,0 +38,1 @@\n+import jdk.incubator.code.Value;\n@@ -33,0 +41,1 @@\n+\n@@ -75,0 +84,165 @@\n+\n+    @Override\n+    public CudaHATKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+        Value dest = hatVectorStoreView.operands().get(0);\n+        Value index = hatVectorStoreView.operands().get(2);\n+\n+        keyword(\"reinterpret_cast\")\n+                .lt()\n+                .typeName(hatVectorStoreView.buildType())\n+                .space()\n+                .asterisk()\n+                .gt()\n+                .oparen()\n+                .ampersand();\n+\n+        if (dest instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        either(hatVectorStoreView.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+        identifier(\"array\").osbrace();\n+\n+        if (index instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        csbrace().cparen().osbrace().intConstZero().csbrace()\n+                .space().equals().space()\n+                .varName(hatVectorStoreView);\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+\n+        Value op1 = hatVectorBinaryOp.operands().get(0);\n+        Value op2 = hatVectorBinaryOp.operands().get(1);\n+\n+        if (op1 instanceof Op.Result r && r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp1) {\n+            typeName(hatVectorBinaryOp1.buildType()).space()\n+                            .identifier(hatVectorBinaryOp.varName() + \"_1\")\n+                                    .semicolon().nl();\n+            hatVectorBinaryOp1.varName(hatVectorBinaryOp.varName() + \"_1\");\n+            recurse(buildContext, hatVectorBinaryOp1);\n+        }\n+\n+        if (op2 instanceof Op.Result r && r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp2) {\n+            typeName(hatVectorBinaryOp2.buildType()).space()\n+                    .identifier(hatVectorBinaryOp.varName() + \"_2\")\n+                    .semicolon().nl();\n+            hatVectorBinaryOp2.varName(hatVectorBinaryOp.varName() + \"_2\");\n+            recurse(buildContext, hatVectorBinaryOp2);\n+        }\n+\n+        for (int i = 0; i < hatVectorBinaryOp.vectorN(); i++) {\n+\n+           identifier(hatVectorBinaryOp.varName())\n+                   .dot()\n+                   .identifier(hatVectorBinaryOp.mapLane(i))\n+                   .space().equals().space();\n+\n+            if (op1 instanceof Op.Result r) {\n+                if (!(r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp1)) {\n+                    recurse(buildContext, r.op());\n+                } else {\n+                    identifier(hatVectorBinaryOp1.varName());\n+                }\n+            }\n+            dot().identifier(hatVectorBinaryOp.mapLane(i)).space();\n+            identifier(hatVectorBinaryOp.operationType().symbol()).space();\n+\n+            if (op2 instanceof Op.Result r) {\n+                if (!(r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp2)) {\n+                    recurse(buildContext, r.op());\n+                } else {\n+                    identifier(hatVectorBinaryOp2.varName());\n+                }\n+            }\n+            dot().identifier(hatVectorBinaryOp.mapLane(i)).semicolon().nl();\n+        }\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+        Value source = hatVectorLoadOp.operands().get(0);\n+        Value index = hatVectorLoadOp.operands().get(1);\n+\n+        keyword(\"reinterpret_cast\")\n+                .lt()\n+                .typeName(hatVectorLoadOp.buildType())\n+                .space()\n+                .asterisk()\n+                .gt()\n+                .oparen()\n+                .ampersand();\n+\n+        if (source instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        either(hatVectorLoadOp.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+        identifier(\"array\").osbrace();\n+\n+        if (index instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        csbrace().cparen().osbrace().intConstZero().csbrace();\n+\n+        return self();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+        identifier(hatVSelectLoadOp.varName())\n+                .dot()\n+                .identifier(hatVSelectLoadOp.mapLane());\n+        return self();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+        identifier(hatVSelectStoreOp.varName())\n+                .dot()\n+                .identifier(hatVSelectStoreOp.mapLane())\n+                .space().equals().space();\n+        if (hatVSelectStoreOp.resultValue() != null) {\n+            \/\/ We have detected a direct resolved result (resolved name)\n+            varName(hatVSelectStoreOp.resultValue());\n+        } else {\n+            \/\/ otherwise, we traverse to resolve the expression\n+            Value storeValue = hatVSelectStoreOp.operands().get(1);\n+            if (storeValue instanceof Op.Result r) {\n+                recurse(buildContext, r.op());\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+        Value operand = hatVectorVarOp.operands().getFirst();\n+        typeName(hatVectorVarOp.buildType())\n+                .space()\n+                .varName(hatVectorVarOp);\n+\n+        if (operand instanceof Op.Result r && r.op() instanceof HatVectorBinaryOp) {\n+            semicolon().nl();\n+        } else {\n+            space().equals().space();\n+        }\n+\n+        if (operand instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+        varName(hatVectorVarLoadOp);\n+        return self();\n+    }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":175,"deletions":1,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.codebuilders.CodeBuilder;\n@@ -29,0 +30,7 @@\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVSelectStoreOp;\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorStoreView;\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -30,0 +38,1 @@\n+import jdk.incubator.code.Value;\n@@ -71,0 +80,121 @@\n+\n+    @Override\n+    public OpenCLHATKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+        Value dest = hatVectorStoreView.operands().get(0);\n+        Value index = hatVectorStoreView.operands().get(2);\n+\n+        identifier(\"vstore\" + hatVectorStoreView.storeN())\n+                .oparen()\n+                .varName(hatVectorStoreView)\n+                .comma()\n+                .space()\n+                .intConstZero()\n+                .comma()\n+                .space()\n+                .ampersand();\n+\n+        if (dest instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        either(hatVectorStoreView.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+        identifier(\"array\").osbrace();\n+\n+        if (index instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        csbrace().cparen();\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+\n+        oparen();\n+        Value op1 = hatVectorBinaryOp.operands().get(0);\n+        Value op2 = hatVectorBinaryOp.operands().get(1);\n+\n+        if (op1 instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        space().identifier(hatVectorBinaryOp.operationType().symbol()).space();\n+\n+        if (op2 instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        cparen();\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+        Value source = hatVectorLoadOp.operands().get(0);\n+        Value index = hatVectorLoadOp.operands().get(1);\n+\n+        identifier(\"vload\" + hatVectorLoadOp.loadN())\n+                .oparen()\n+                .intConstZero()\n+                .comma()\n+                .space()\n+                .ampersand();\n+\n+        if (source instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+\n+        either(hatVectorLoadOp.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+        identifier(\"array\").osbrace();\n+        if (index instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        csbrace().cparen();\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+        identifier(hatVSelectLoadOp.varName())\n+                .dot()\n+                .identifier(hatVSelectLoadOp.mapLane());\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+        identifier(hatVSelectStoreOp.varName())\n+                .dot()\n+                .identifier(hatVSelectStoreOp.mapLane())\n+                .space().equals().space();\n+        if (hatVSelectStoreOp.resultValue() != null) {\n+            \/\/ We have detected a direct resolved result (resolved name)\n+            varName(hatVSelectStoreOp.resultValue());\n+        } else {\n+            \/\/ otherwise, we traverse to resolve the expression\n+            Value storeValue = hatVSelectStoreOp.operands().get(1);\n+            if (storeValue instanceof Op.Result r) {\n+                recurse(buildContext, r.op());\n+            }\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+        typeName(hatVectorVarOp.buildType())\n+                .space()\n+                .varName(hatVectorVarOp)\n+                .space().equals().space();\n+\n+        Value operand = hatVectorVarOp.operands().getFirst();\n+        if (operand instanceof Op.Result r) {\n+            recurse(buildContext, r.op());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+        varName(hatVectorVarLoadOp);\n+        return self();\n+    }\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+    public static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(HEADLESS, \"SHOW_COMPILATION_PHASES\", \"Show HAT compilation phases\");\n+\n@@ -110,1 +112,3 @@\n-            HEADLESS\n+            HEADLESS,\n+\n+            SHOW_COMPILATION_PHASES\n","filename":"hat\/core\/src\/main\/java\/hat\/Config.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n@@ -35,1 +33,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -42,0 +39,3 @@\n+    int PADDING_BYTES = 12;\n+    int HEADER_BYTES = 4 + PADDING_BYTES;\n+\n@@ -43,1 +43,1 @@\n-            s32Array.arrayLen(\"length\").array(\"array\"));\n+            s32Array.arrayLen(\"length\").pad(12).array(\"array\"));\n@@ -50,1 +50,1 @@\n-        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, 4, length());\n+        MemorySegment.copy(floats, 0, Buffer.getMemorySegment(this), JAVA_FLOAT, HEADER_BYTES, length());\n@@ -59,1 +59,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, 4, floats, 0, length());\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, HEADER_BYTES, floats, 0, length());\n@@ -69,0 +69,10 @@\n+    \/\/ This is an intrinsic for HAT to create views. It does not execute code\n+    \/\/ on the host side, at least for now.\n+    default Float4 float4View(int index) {\n+        return null;\n+    }\n+\n+    default void storeFloat4View(Float4 v, int index) {\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_FLOAT, 0,  v.toArray(), 4 + index, 4);\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-    int width();\n@@ -39,0 +38,1 @@\n+    int width();\n@@ -42,1 +42,0 @@\n-\n@@ -71,1 +70,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+public interface Float4 extends HatVector {\n+\n+    float x();\n+    float y();\n+    float z();\n+    float w();\n+    void x(float x);\n+    void y(float y);\n+    void z(float z);\n+    void w(float w);\n+\n+    Schema<Float4> schema = Schema.of(Float4.class,\n+            float4->float4.fields(\"x\",\"y\",\"z\",\"w\"));\n+\n+    static Float4 create(Accelerator accelerator) {\n+        return schema.allocate(accelerator, 1);\n+    }\n+\n+    static Float4 add(Float4 vA, Float4 vB) {\n+        return null;\n+    }\n+\n+    static Float4 sub(Float4 vA, Float4 vB) {\n+        return null;\n+    }\n+\n+    static Float4 mul(Float4 vA, Float4 vB) {\n+        return null;\n+    }\n+\n+    static Float4 div(Float4 vA, Float4 vB) {\n+        return null;\n+    }\n+\n+    default Float4 add(Float4 vb) {\n+        return null;\n+    }\n+\n+    default Float4 sub(Float4 vb) {\n+        return null;\n+    }\n+\n+    default Float4 mul(Float4 vb) {\n+        return null;\n+    }\n+\n+    default Float4 div(Float4 vb) {\n+        return null;\n+    }\n+\n+    default float[] toArray() {\n+        return new float[] { x(), y(), z(), w() };\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Float4.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+public interface HatVector extends Buffer {\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/HatVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+\n+    int PADDING_BYTES = 12;\n+    int HEADER_BYTES = 4 + PADDING_BYTES;\n+\n@@ -44,1 +48,1 @@\n-            .arrayLen(\"length\").array(\"array\"));\n+            .arrayLen(\"length\").pad(12).array(\"array\"));\n@@ -56,1 +60,1 @@\n-        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, 4, length());\n+        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, HEADER_BYTES, length());\n@@ -60,1 +64,1 @@\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 4, ints, 0, length());\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, HEADER_BYTES, ints, 0, length());\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.function.Function;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n-public interface S32LocalArray extends Buffer {\n-\n-    int length();\n-    int array(long idx);\n-    void array(long idx, int i);\n-\n-    Schema<S32LocalArray> schema = Schema.of(S32LocalArray.class, s32Array->s32Array\n-            .arrayLen(\"length\").array(\"array\"));\n-\n-    static S32LocalArray create(Accelerator accelerator, int length){\n-        return schema.allocate(accelerator, length);\n-    }\n-\n-    static S32LocalArray create(Accelerator accelerator, int length, Function<Integer,Integer> filler){\n-        return schema.allocate(accelerator, length).fill(filler);\n-    }\n-\n-    static S32LocalArray createFrom(Accelerator accelerator, int[] arr) {\n-        return create( accelerator, arr.length).copyFrom(arr);\n-    }\n-\n-    default S32LocalArray copyFrom(int[] ints) {\n-        MemorySegment.copy(ints, 0, Buffer.getMemorySegment(this), JAVA_INT, 4, length());\n-        return this;\n-    }\n-\n-    default S32LocalArray copyTo(int[] ints) {\n-        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 4, ints, 0, length());\n-        return this;\n-    }\n-\n-    default S32LocalArray fill(Function<Integer, Integer> filler) {\n-        for (int i = 0; i < length(); i++) {\n-            array(i, filler.apply(i));\n-        }\n-        return this;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32LocalArray.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -177,3 +177,2 @@\n-            HatDialectifyTier tier = new HatDialectifyTier(entrypoint.funcOp(), computeContext.accelerator.lookup);\n-            CoreOp.FuncOp f = tier.run();\n-            \/\/CoreOp.FuncOp f = dialectifyToHat(entrypoint.funcOp());\n+            HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator.lookup);\n+            CoreOp.FuncOp f = tier.run(entrypoint.funcOp());\n@@ -189,3 +188,2 @@\n-                \/\/CoreOp.FuncOp f = dialectifyToHat(kernelOp);\n-                HatDialectifyTier tier = new HatDialectifyTier(kernelOp, computeContext.accelerator.lookup);\n-                CoreOp.FuncOp f = tier.run();\n+                HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator.lookup);\n+                CoreOp.FuncOp f = tier.run(kernelOp);\n@@ -197,3 +195,2 @@\n-                \/\/CoreOp.FuncOp f = dialectifyToHat(kernel.funcOp());\n-                HatDialectifyTier tier = new HatDialectifyTier(kernel.funcOp(), computeContext.accelerator.lookup);\n-                CoreOp.FuncOp f = tier.run();\n+                HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator.lookup);\n+                CoreOp.FuncOp f = tier.run(kernel.funcOp());\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,5 @@\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVSelectStoreOp;\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorStoreView;\n@@ -35,0 +40,2 @@\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -111,0 +118,14 @@\n+    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp);\n+\n+    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatFloat4StoreOp);\n+\n+    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp);\n+\n+    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp);\n+\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp);\n+\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp);\n+\n+    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp);\n+\n@@ -146,0 +167,7 @@\n+            case HatVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n+            case HatVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n+            case HatVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n+            case HatVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n+            case HatVSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+            case HatVSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+            case HatVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public  abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+public abstract class C99HATComputeBuilder<T extends C99HATComputeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorStoreView;\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -175,0 +180,27 @@\n+\n+    public T varName(HatVectorVarOp hatVectorVarOp) {\n+        identifier(hatVectorVarOp.varName());\n+        return self();\n+    }\n+\n+    public T varName(HatVectorLoadOp vectorLoadOp) {\n+        identifier(vectorLoadOp.varName());\n+        return self();\n+    }\n+\n+    public T varName(HatVectorStoreView hatVectorStoreView) {\n+        identifier(hatVectorStoreView.varName());\n+        return self();\n+    }\n+\n+    public T varName(HatVectorBinaryOp hatVectorBinaryOp) {\n+        identifier(hatVectorBinaryOp.varName());\n+        return self();\n+    }\n+\n+    public T varName(HatVectorVarLoadOp hatVectorVarLoadOp) {\n+        identifier(hatVectorVarLoadOp.varName());\n+        return self();\n+    }\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVSelectStoreOp;\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorStoreView;\n@@ -31,0 +36,2 @@\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -39,0 +46,1 @@\n+import jdk.incubator.code.Value;\n@@ -63,0 +71,3 @@\n+            case HatVectorVarOp $ -> varName($);\n+            case HatVectorLoadOp $ -> varName($);\n+            case HatVectorBinaryOp $ -> varName($);\n@@ -210,2 +221,0 @@\n-\n-\n@@ -608,0 +617,1 @@\n+\n@@ -609,1 +619,1 @@\n-        return   type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n+        return  type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n@@ -611,0 +621,37 @@\n+\n+    public abstract T generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView);\n+\n+    public abstract T generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp);\n+\n+    public abstract T generateVectorLoad(ScopedCodeBuilderContext buildContext,HatVectorLoadOp hatVectorLoadOp);\n+\n+    public abstract T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext,HatVSelectLoadOp hatVSelectLoadOp);\n+\n+    public abstract T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext,HatVSelectStoreOp hatVSelectStoreOp);\n+\n+    @Override\n+    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+       return generateVectorStore(buildContext, hatVectorStoreView);\n+    }\n+\n+    @Override\n+    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+        return generateVectorBinary(buildContext, hatVectorBinaryOp);\n+    }\n+\n+    @Override\n+    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+        return generateVectorLoad(buildContext, hatVectorLoadOp);\n+    }\n+\n+    @Override\n+    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+        return generateVectorSelectLoadOp(buildContext, hatVSelectLoadOp);\n+    }\n+\n+    @Override\n+    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+        return generateVectorSelectStoreOp(buildContext, hatVSelectStoreOp);\n+    }\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -57,0 +60,4 @@\n+            }\n+\n+            if (value instanceof Op.Result result && result.op() instanceof HatVectorVarOp hatVectorVarOp) {\n+                return hatVectorVarOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatVSelectLoadOp extends HatVectorViewOp {\n+\n+    private final TypeElement elementType;\n+    private final int lane;\n+\n+    public HatVSelectLoadOp(String varName, TypeElement typeElement, int lane, List<Value> operands) {\n+        super(varName, operands);\n+        this.elementType = typeElement;\n+        this.lane = lane;\n+    }\n+\n+    public HatVSelectLoadOp(HatVSelectLoadOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.elementType = that.elementType;\n+        this.lane = that.lane;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVSelectLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vselect.\" + lane, elementType);\n+    }\n+\n+    public String mapLane() {\n+        return switch (lane) {\n+            case 0 -> \"x\";\n+            case 1 -> \"y\";\n+            case 2 -> \"z\";\n+            case 3 -> \"w\";\n+            default -> throw new InternalError(\"Invalid lane: \" + lane);\n+        };\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVSelectLoadOp.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatVSelectStoreOp extends HatVectorViewOp {\n+\n+    private final TypeElement elementType;\n+    private final int lane;\n+    private final CoreOp.VarOp resultVarOp;\n+\n+    public HatVSelectStoreOp(String varName, TypeElement typeElement, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n+        super(varName, operands);\n+        this.elementType = typeElement;\n+        this.lane = lane;\n+        this.resultVarOp = resultVarOp;\n+    }\n+\n+    public HatVSelectStoreOp(HatVSelectStoreOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.elementType = that.elementType;\n+        this.lane = that.lane;\n+        this.resultVarOp = that.resultVarOp;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVSelectStoreOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vselect.store.\" + lane, elementType);\n+    }\n+\n+    public String mapLane() {\n+        return switch (lane) {\n+            case 0 -> \"x\";\n+            case 1 -> \"y\";\n+            case 2 -> \"z\";\n+            case 3 -> \"w\";\n+            default -> throw new InternalError(\"Invalid lane: \" + lane);\n+        };\n+    }\n+\n+    public CoreOp.VarOp resultValue() {\n+        return resultVarOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVSelectStoreOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HatVectorAddOp extends HatVectorBinaryOp {\n+\n+    public HatVectorAddOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.ADD, operands);\n+    }\n+\n+    public HatVectorAddOp(HatVectorAddOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorAddOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorAddOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class HatVectorBinaryOp extends HatVectorViewOp {\n+\n+    private final TypeElement elementType;\n+    private final OpType operationType;\n+    private final int vectorN;\n+\n+    public enum OpType {\n+        ADD(\"+\"),\n+        SUB(\"-\"),\n+        MUL(\"*\"),\n+        DIV(\"\/\");\n+\n+        String symbol;\n+\n+        OpType(String symbol) {\n+            this.symbol = symbol;\n+        }\n+\n+        public String symbol() {\n+            return symbol;\n+        }\n+    }\n+\n+    public HatVectorBinaryOp(String varName, TypeElement typeElement, OpType operationType, List<Value> operands) {\n+        super(varName, operands);\n+        this.elementType = typeElement;\n+        this.operationType = operationType;\n+        int l = typeElement.toString().length();\n+        vectorN = Integer.parseInt(typeElement.toString().substring(l - 1, l));\n+    }\n+\n+    public HatVectorBinaryOp(HatVectorBinaryOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.elementType = op.elementType;\n+        this.operationType = op.operationType;\n+        this.vectorN = op.vectorN;\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return this.elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.floatNOp.\" + varName(), elementType);\n+    }\n+\n+    public OpType operationType() {\n+        return operationType;\n+    }\n+\n+    public int vectorN() {\n+        return vectorN;\n+    }\n+\n+    public String buildType() {\n+        if (elementType.toString().startsWith(\"hat.buffer.Float\")) {\n+            return \"float\" + vectorN;\n+        }\n+        throw new RuntimeException(\"Unexpected vector type \" + elementType);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorBinaryOp.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HatVectorDivOp extends HatVectorBinaryOp {\n+\n+    public HatVectorDivOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.DIV, operands);\n+    }\n+\n+    public HatVectorDivOp(HatVectorDivOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorDivOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorDivOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatVectorLoadOp extends HatVectorViewOp {\n+\n+    private final TypeElement typeElement;\n+    private final TypeElement vectorType;\n+    private final int loadN;\n+    private final boolean isSharedOrPrivate;\n+\n+    public HatVectorLoadOp(String varName, TypeElement typeElement, TypeElement vectorType, int loadN, boolean isShared, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.loadN = loadN;\n+        this.vectorType = vectorType;\n+        this.isSharedOrPrivate = isShared;\n+    }\n+\n+    public HatVectorLoadOp(HatVectorLoadOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+        this.loadN = op.loadN;\n+        this.vectorType = op.vectorType;\n+        this.isSharedOrPrivate = op.isSharedOrPrivate;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vectorLoadView.\" + varName(), typeElement);\n+    }\n+\n+    public TypeElement vectorType() {\n+        return vectorType;\n+    }\n+\n+    public int loadN() {\n+        return loadN;\n+    }\n+\n+    public String buildType() {\n+        \/\/ floatN\n+        if (vectorType.toString().startsWith(\"hat.buffer.Float\")) {\n+            return \"float\" + loadN;\n+        }\n+        throw new RuntimeException(\"Unexpected vector type \" + vectorType);\n+    }\n+\n+    public boolean isSharedOrPrivate() {\n+        return this.isSharedOrPrivate;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorLoadOp.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HatVectorMulOp extends HatVectorBinaryOp {\n+\n+    public HatVectorMulOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.MUL, operands);\n+    }\n+\n+    public HatVectorMulOp(HatVectorMulOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorMulOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorMulOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatVectorStoreView extends HatVectorViewOp {\n+\n+    private final TypeElement elementType;\n+    private final int storeN;\n+    private final boolean isSharedOrPrivate;\n+    private final VectorType vectorType;\n+\n+    public HatVectorStoreView(String varName, TypeElement elementType, int storeN, VectorType vectorType, boolean isSharedOrPrivate, List<Value> operands) {\n+        super(varName, operands);\n+        this.elementType = elementType;\n+        this.storeN = storeN;\n+        this.isSharedOrPrivate = isSharedOrPrivate;\n+        this.vectorType = vectorType;\n+    }\n+\n+    public HatVectorStoreView(HatVectorStoreView op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.elementType = op.elementType;\n+        this.storeN = op.storeN;\n+        this.isSharedOrPrivate = op.isSharedOrPrivate;\n+        this.vectorType = op.vectorType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorStoreView(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return elementType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.floatNStoreView.\" + varName(), elementType);\n+    }\n+\n+    public int storeN() {\n+        return storeN;\n+    }\n+\n+    public boolean isSharedOrPrivate() {\n+        return this.isSharedOrPrivate;\n+    }\n+\n+    public String buildType() {\n+        return vectorType.type();\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorStoreView.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HatVectorSubOp extends HatVectorBinaryOp {\n+\n+    public HatVectorSubOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.SUB, operands);\n+    }\n+\n+    public HatVectorSubOp(HatVectorSubOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorSubOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorSubOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatVectorVarLoadOp extends HatVectorViewOp {\n+\n+    private final TypeElement typeElement;\n+\n+    public HatVectorVarLoadOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+    }\n+\n+    public HatVectorVarLoadOp(HatVectorVarLoadOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorVarLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vectorVarLoadOp.\" + varName(), typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorVarLoadOp.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatVectorVarOp extends HatVectorViewOp {\n+\n+    private final VarType typeElement;\n+    private final int loadN;\n+\n+    public HatVectorVarOp(String varName, VarType typeElement, int loadN, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.loadN = loadN;\n+    }\n+\n+    public HatVectorVarOp(HatVectorVarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+        this.loadN = op.loadN;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatVectorVarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vectorVarOp.\" + varName(), typeElement);\n+    }\n+\n+    public String buildType() {\n+        \/\/ floatN\n+        if (typeElement.valueType().toString().startsWith(\"hat.buffer.Float\")) {\n+            return \"float\" + loadN;\n+        }\n+        throw new RuntimeException(\"Unexpected vector type \" + typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorVarOp.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HatVectorViewOp extends HatOP {\n+\n+    private String varName;\n+\n+    public HatVectorViewOp(String varName, List<Value> operands) {\n+        super(operands);\n+        this.varName = varName;\n+    }\n+\n+    protected HatVectorViewOp(HatVectorViewOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.varName = that.varName;\n+    }\n+\n+    public String varName() {\n+        return varName;\n+    }\n+\n+    public void  varName(String varName) {\n+        this.varName = varName;\n+    }\n+\n+    public String mapLane(int lane) {\n+        return switch (lane) {\n+            case 0 -> \"x\";\n+            case 1 -> \"y\";\n+            case 2 -> \"z\";\n+            case 3 -> \"w\";\n+            default -> throw new InternalError(\"Invalid lane: \" + lane);\n+        };\n+    }\n+\n+    public enum VectorType {\n+        FLOAT4(\"float4\");\n+\n+        private final String type;\n+\n+        VectorType(String type) {\n+            this.type = type;\n+        }\n+\n+        public String type() {\n+            return type;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorViewOp.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -31,1 +31,8 @@\n-import hat.dialect.*;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatThreadOP;\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVectorAddOp;\n+import hat.dialect.HatVectorDivOp;\n+import hat.dialect.HatVectorMulOp;\n+import hat.dialect.HatVectorSubOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -33,1 +40,6 @@\n-import jdk.incubator.code.*;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n@@ -35,1 +47,6 @@\n-import jdk.incubator.code.dialect.java.*;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -41,1 +58,8 @@\n-import java.util.*;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n@@ -299,0 +323,1 @@\n+                        || (op instanceof HatVectorVarOp)\n@@ -391,0 +416,1 @@\n+            case HatVSelectLoadOp o -> 0;      \/\/ same as VarLoadOp\n@@ -399,0 +425,1 @@\n+            case HatVectorMulOp o -> 2;\n@@ -400,0 +427,1 @@\n+            case HatVectorDivOp o -> 2;\n@@ -402,0 +430,2 @@\n+            case HatVectorAddOp o -> 3;\n+            case HatVectorSubOp o -> 3;\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+public interface HatCompilationTier {\n+\n+    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatCompilationTier.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Config;\n+\n+public class HatDialectAbstractPhase {\n+\n+    protected final Config config;\n+\n+    HatDialectAbstractPhase(Config config) {\n+        this.config = config;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectAbstractPhase.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Config;\n@@ -41,1 +42,5 @@\n-public class HatDialectifyBarrierPhase implements HatDialectifyPhase {\n+public class HatDialectifyBarrierPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n+\n+    public HatDialectifyBarrierPhase(Config config) {\n+        super(config);\n+    }\n@@ -64,1 +69,3 @@\n-        \/\/System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n+            System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        }\n@@ -88,1 +95,3 @@\n-        \/\/System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n+            System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyBarrierPhase.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Config;\n@@ -45,1 +46,1 @@\n-public class HatDialectifyMemoryPhase implements HatDialectifyPhase {\n+public class HatDialectifyMemoryPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n@@ -55,1 +56,2 @@\n-    public HatDialectifyMemoryPhase(Space space, MethodHandles.Lookup lookup) {\n+    public HatDialectifyMemoryPhase(Space space, MethodHandles.Lookup lookup, Config config) {\n+        super(config);\n@@ -71,1 +73,3 @@\n-            \/\/ IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n+            if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n+                IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n+            }\n@@ -130,1 +134,3 @@\n-            \/\/ IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n+            if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n+                IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n+            }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyMemoryPhase.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Config;\n@@ -45,1 +46,1 @@\n-public class HatDialectifyThreadsPhase implements HatDialectifyPhase {\n+public class HatDialectifyThreadsPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n@@ -49,1 +50,2 @@\n-    public HatDialectifyThreadsPhase(ThreadAccess threadAccess) {\n+    public HatDialectifyThreadsPhase(ThreadAccess threadAccess, Config config) {\n+        super(config);\n@@ -55,1 +57,3 @@\n-        \/\/ IO.println(\"[INFO] Code model before HatDialectifyThreadsPhase: \" + funcOp.toText());\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[INFO] Code model before HatDialectifyThreadsPhase: \" + funcOp.toText());\n+\n@@ -121,1 +125,2 @@\n-        \/\/ IO.println(\"[INFO] Code model after HatDialectifyThreadsPhase: \" + funcOp.toText());\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[INFO] Code model after HatDialectifyThreadsPhase: \" + funcOp.toText());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyThreadsPhase.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Config;\n@@ -31,0 +32,1 @@\n+import java.util.Arrays;\n@@ -35,1 +37,1 @@\n-public class HatDialectifyTier {\n+public class HatDialectifyTier implements HatCompilationTier {\n@@ -37,1 +39,0 @@\n-    private CoreOp.FuncOp funcOp;\n@@ -40,10 +41,12 @@\n-    public HatDialectifyTier(CoreOp.FuncOp funcOp, MethodHandles.Lookup lookup) {\n-        this.funcOp = funcOp;\n-        hatPhases.add(new HatDialectifyBarrierPhase());\n-        for (HatDialectifyMemoryPhase.Space space: HatDialectifyMemoryPhase.Space.values()) {\n-            hatPhases.add(new HatDialectifyMemoryPhase(space, lookup));\n-            hatPhases.add(new HatDialectifyMemoryPhase(space, lookup));\n-        }\n-        for (HatDialectifyThreadsPhase.ThreadAccess threadAccess: HatDialectifyThreadsPhase.ThreadAccess.values()) {\n-            hatPhases.add(new HatDialectifyThreadsPhase(threadAccess));\n-        }\n+    public HatDialectifyTier(MethodHandles.Lookup lookup) {\n+        Config config = Config.fromEnvOrProperty();\n+        hatPhases.add(new HatDialectifyBarrierPhase(config));\n+        Arrays.stream(HatDialectifyMemoryPhase.Space.values())\n+                .forEach(space -> hatPhases.add(new HatDialectifyMemoryPhase(space, lookup, config)));\n+        Arrays.stream(HatDialectifyThreadsPhase.ThreadAccess.values())\n+                .forEach(threadAccess -> hatPhases.add(new HatDialectifyThreadsPhase(threadAccess, config)));\n+        Arrays.stream(HatDialectifyVectorOpPhase.OpView.values())\n+                .forEach(vectorOperation -> hatPhases.add(new HatDialectifyVectorOpPhase(lookup, vectorOperation, config)));\n+        Arrays.stream(HatDialectifyVectorStorePhase.StoreView.values())\n+                .forEach(vectorOperation -> hatPhases.add(new HatDialectifyVectorStorePhase(lookup, vectorOperation, config)));\n+        hatPhases.add(new HatDialectifyVSelectPhase(lookup, config));\n@@ -52,1 +55,3 @@\n-    public CoreOp.FuncOp run() {\n+    \/\/ It computes a set of function code model transformations from FuncOp to FuncOp'.\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyTier.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Config;\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVSelectStoreOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorViewOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyVSelectPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n+\n+    private final MethodHandles.Lookup lookup;\n+\n+    public HatDialectifyVSelectPhase(MethodHandles.Lookup lookup, Config config) {\n+        super(config);\n+        this.lookup = lookup;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n+        return isMethod(invokeOp, \"x\")\n+                || isMethod(invokeOp, \"y\")\n+                || isMethod(invokeOp, \"z\")\n+                || isMethod(invokeOp, \"w\");\n+    }\n+\n+    int getLane(String fieldName) {\n+        return switch (fieldName) {\n+            case \"x\" -> 0;\n+            case \"y\" -> 1;\n+            case \"z\" -> 2;\n+            case \"w\" -> 3;\n+            default -> -1;\n+        };\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n+        String invokeClass = invokeOp.invokeDescriptor().refType().toString();\n+        boolean isHatVectorType = invokeClass.startsWith(\"hat.buffer.Float\");\n+        return isHatVectorType\n+                && OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                && (isVectorLane(invokeOp));\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HatVectorViewOp vectorViewOp) {\n+                return vectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private CoreOp.VarOp findVarOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVarOp(varLoadOp.operands().get(0));\n+    }\n+\n+    private CoreOp.VarOp findVarOp(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVarOp(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n+                return varOp;\n+            }\n+            return null;\n+        }\n+    }\n+\n+\n+    \/\/ Code Model Pattern:\n+    \/\/  %16 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"63:28\";\n+    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.buffer.Float4::x():float\";\n+    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[BEFORE] VSelect Load Transform: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            Value inputOperand = inputOperandsInvoke.getFirst();\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(invokeOp);\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputInvokeOp = invokeOp.operands();\n+                for (Value v : inputInvokeOp) {\n+                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n+                        int lane = getLane(invokeOp.invokeDescriptor().name());\n+                        HatVectorViewOp vSelectOp;\n+                        String name = findNameVector(varLoadOp);\n+                        if (invokeOp.resultType() != JavaType.VOID) {\n+                            vSelectOp = new HatVSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n+                        } else {\n+                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n+                        }\n+                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n+                        vSelectOp.setLocation(invokeOp.location());\n+                        context.mapValue(invokeOp.result(), hatSelectResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ Pass the value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[After] VSelect Load Transform: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    \/\/ Pattern from the code mode:\n+    \/\/ %20 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"64:13\";\n+    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n+    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.buffer.Float4::x(float):void\";\n+    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[BEFORE] VSelect Store Transform \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            Value inputOperand = inputOperandsInvoke.getFirst();\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(invokeOp);\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputInvokeOp = invokeOp.operands();\n+                Value v = inputInvokeOp.getFirst();\n+\n+                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n+                    int lane = getLane(invokeOp.invokeDescriptor().name());\n+                    HatVectorViewOp vSelectOp;\n+                    String name = findNameVector(varLoadOp);\n+                    if (invokeOp.resultType() == JavaType.VOID) {\n+                        \/\/ The operand 1 in the store is the address (lane)\n+                        \/\/ The operand 1 in the store is the storeValue\n+                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n+                        vSelectOp = new HatVSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n+                    } else {\n+                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n+                    }\n+                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n+                    vSelectOp.setLocation(invokeOp.location());\n+                    context.mapValue(invokeOp.result(), resultVStore);\n+                }\n+\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ Pass the value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[AFTER] VSelect Store Transform: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        funcOp = vloadSelectPhase(funcOp);\n+        funcOp = vstoreSelectPhase(funcOp);\n+        return funcOp;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyVSelectPhase.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Config;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatPrivateVarOp;\n+import hat.dialect.HatVectorAddOp;\n+import hat.dialect.HatVectorDivOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorMulOp;\n+import hat.dialect.HatVectorSubOp;\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HatVectorViewOp;\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyVectorOpPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n+\n+    MethodHandles.Lookup lookup;\n+    private final OpView vectorOperation;\n+\n+    public HatDialectifyVectorOpPhase(MethodHandles.Lookup lookup, OpView vectorOperation, Config config) {\n+        super(config);\n+        this.lookup = lookup;\n+        this.vectorOperation = vectorOperation;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private HatVectorBinaryOp.OpType getBinaryOpType(JavaOp.InvokeOp invokeOp) {\n+        return switch (invokeOp.invokeDescriptor().name()) {\n+            case \"add\" -> HatVectorBinaryOp.OpType.ADD;\n+            case \"sub\" -> HatVectorBinaryOp.OpType.SUB;\n+            case \"mul\" -> HatVectorBinaryOp.OpType.MUL;\n+            case \"div\" -> HatVectorBinaryOp.OpType.DIV;\n+            default -> throw new RuntimeException(\"Unknown binary op \" + invokeOp.invokeDescriptor().name());\n+        };\n+    }\n+\n+    public enum OpView {\n+        FLOAT4_LOAD(\"float4View\"),\n+        ADD(\"add\"),\n+        SUB(\"sub\"),\n+        MUL(\"mul\"),\n+        DIV(\"div\");\n+        final String methodName;\n+        OpView(String methodName) {\n+            this.methodName = methodName;\n+        }\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n+        TypeElement typeElement = invokeOp.resultType();\n+        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n+        return isHatVectorType\n+                && OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                && isMethod(invokeOp, vectorOperation.methodName);\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HatVectorViewOp hatVectorViewOp) {\n+                return hatVectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findIsSharedOrPrivate(varLoadOp.operands().get(0));\n+    }\n+\n+    private boolean findIsSharedOrPrivate(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findIsSharedOrPrivate(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && (r.op() instanceof HatLocalVarOp || r.op() instanceof HatPrivateVarOp)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private HatVectorBinaryOp buildVectorBinaryOp(HatVectorBinaryOp.OpType opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n+        return switch (opType) {\n+            case ADD -> new HatVectorAddOp(varName, resultType, outputOperands);\n+            case SUB -> new HatVectorSubOp(varName, resultType, outputOperands);\n+            case MUL -> new HatVectorMulOp(varName, resultType, outputOperands);\n+            case DIV -> new HatVectorDivOp(varName, resultType, outputOperands);\n+        };\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorLoad(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[BEFORE] Vector Load Ops: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = varOp.operands();\n+                        for (Value inputOperand : inputOperandsVarOp) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                    if (isVectorOperation(invokeOp)) {\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node\n+                Op.Result result = invokeOp.result();\n+                List<Op.Result> collect = result.uses().stream().toList();\n+                boolean isShared = findIsSharedOrPrivate(invokeOp.operands().getFirst());\n+                for (Op.Result r : collect) {\n+                    if (r.op() instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = invokeOp.operands();\n+                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                        HatVectorViewOp memoryViewOp = new HatVectorLoadOp(varOp.varName(), varOp.resultType(), invokeOp.resultType(), 4, isShared, outputOperandsVarOp);\n+                        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                        memoryViewOp.setLocation(varOp.location());\n+                        context.mapValue(invokeOp.result(), hatLocalResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                \/\/ pass value\n+                \/\/context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+                List<Value> inputOperandsVarOp = varOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HatVectorViewOp memoryViewOp = new HatVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), hatLocalResult);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[AFTER] Vector Load Ops: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorBinaryOps(CoreOp.FuncOp funcOp) {\n+        Map<JavaOp.InvokeOp, HatVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[BEFORE] Vector Binary Ops: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = varOp.operands();\n+                        for (Value inputOperand : inputOperandsVarOp) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                    if (isVectorOperation(invokeOp)) {\n+                                        HatVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n+                                        binaryOperation.put(invokeOp, binaryOpType);\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                Op.Result result = invokeOp.result();\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+                List<Op.Result> collect = result.uses().stream().toList();\n+                for (Op.Result r : collect) {\n+                    if (r.op() instanceof CoreOp.VarOp varOp) {\n+                        HatVectorBinaryOp.OpType binaryOpType = binaryOperation.get(invokeOp);\n+                        HatVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), outputOperands);\n+                        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n+                        memoryViewOp.setLocation(varOp.location());\n+                        context.mapValue(invokeOp.result(), hatVectorOpResult);\n+                        break;\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                List<Value> inputOperandsVarOp = varOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HatVectorViewOp memoryViewOp = new HatVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), hatVectorResult);\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorBinaryWithContatenationOps(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[BEFORE] Vector Contact Binary Ops: \" + funcOp.toText());\n+\n+        Map<JavaOp.InvokeOp, HatVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            for (Value inputOperand : inputOperandsInvoke) {\n+                                if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                    HatVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n+                                    binaryOperation.put(invokeOp, binaryOpType);\n+                                    consumer.accept(varLoadOp);\n+                                    consumer.accept(invokeOp);\n+                                }\n+                            }\n+                        }\n+                    } else if (codeElement instanceof HatVectorBinaryOp hatVectorBinaryOp) {\n+                        List<Value> inputOperandsInvoke = hatVectorBinaryOp.operands();\n+                        for (Value inputOperand : inputOperandsInvoke) {\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+                HatVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), outputOperands);\n+                Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), hatVectorOpResult);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                List<Value> inputOperandsVarLoad = varLoadOp.operands();\n+                List<Value> outputOperandsVarLoad = context.getValues(inputOperandsVarLoad);\n+                String varLoadName = findNameVector(varLoadOp);\n+                HatVectorViewOp memoryViewOp = new HatVectorVarLoadOp(varLoadName, varLoadOp.resultType(), outputOperandsVarLoad);\n+                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varLoadOp.location());\n+                context.mapValue(varLoadOp.result(), hatVectorResult);\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        if (Objects.requireNonNull(vectorOperation) == OpView.FLOAT4_LOAD) {\n+            funcOp = dialectifyVectorLoad(funcOp);\n+        } else {\n+            \/\/ Find binary operations\n+            funcOp = dialectifyVectorBinaryOps(funcOp);\n+            funcOp = dialectifyVectorBinaryWithContatenationOps(funcOp);\n+        }\n+        return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyVectorOpPhase.java","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Config;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatPrivateVarOp;\n+import hat.dialect.HatVectorStoreView;\n+import hat.dialect.HatVectorViewOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyVectorStorePhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n+\n+    MethodHandles.Lookup lookup;\n+    private final StoreView vectorOperation;\n+\n+    public HatDialectifyVectorStorePhase(MethodHandles.Lookup lookup, StoreView vectorOperation, Config config) {\n+        super(config);\n+        this.lookup = lookup;\n+        this.vectorOperation = vectorOperation;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    public enum StoreView {\n+        FLOAT4_STORE(\"storeFloat4View\");\n+\n+        final String methodName;\n+        StoreView(String methodName) {\n+            this.methodName = methodName;\n+        }\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue) {\n+        if (varValue instanceof Op.Result r\n+                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            TypeElement typeElement = varLoadOp.resultType();\n+            boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n+            return isHatVectorType\n+                    && OpTk.isIfaceBufferMethod(lookup, invokeOp)\n+                    && isMethod(invokeOp, vectorOperation.methodName);\n+        }\n+        return false;\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HatVectorViewOp hatVectorViewOp) {\n+                return hatVectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private boolean findIsSharedOrPrivateSpace(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findIsSharedOrPrivateSpace(varLoadOp.operands().get(0));\n+    }\n+\n+    private boolean findIsSharedOrPrivateSpace(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findIsSharedOrPrivateSpace(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && (r.op() instanceof HatLocalVarOp || r.op() instanceof HatPrivateVarOp)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[BEFORE] Vector Types STORE Transform: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if ((invokeOp.operands().size() >= 3)\n+                                && (isVectorOperation(invokeOp, invokeOp.operands().get(1)))) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node\n+                List<Value> inputOperandsVarOp = invokeOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                \/\/ Find the name of the vector view variable\n+                Value v = invokeOp.operands().get(1);\n+                String name = findNameVector(v);\n+                boolean isSharedOrPrivate = findIsSharedOrPrivateSpace(invokeOp.operands().get(0));\n+\n+                HatVectorViewOp storeView = switch (vectorOperation) {\n+                    case FLOAT4_STORE -> new HatVectorStoreView(name, invokeOp.resultType(), 4, HatVectorViewOp.VectorType.FLOAT4, isSharedOrPrivate,  outputOperandsVarOp);\n+                };\n+                Op.Result hatLocalResult = blockBuilder.op(storeView);\n+                storeView.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), hatLocalResult);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n+            IO.println(\"[AFTER] Vector Types STORE Transform: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyVectorStorePhase.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import hat.buffer.Float4;\n@@ -339,0 +340,121 @@\n+    \/**\n+     * Algorithm for MatMul using 2D Cache (shared memory), Loop Tiling and 2D Register Tiling + Vector Loads\/Stores from\/to\n+     * global memory to shared memory.\n+     *\n+     * <p>\n+     *     We want to probe that HAT can represent more complex optimisations, and make use of the\n+     *     different levels of the GPU's memory hierarchy, such as shared memory (as in CUDA shared memory),\n+     *     and private memory. This code has been tested on NVIDIA A10 GPUs.\n+     * <\/p>\n+     *\n+     * <p>\n+     *     The code has been adapted from CUDA to HAT based on the algorithms presented here:\n+     *     {@url https:\/\/siboehm.com\/articles\/22\/CUDA-MMM}\n+     * <\/p>\n+     *\n+     * @param kc\n+     * @param matrixA\n+     * @param matrixB\n+     * @param matrixC\n+     * @param size\n+     *\/\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2DRegisterTilingVectorized(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+\n+        \/\/ Configuration for the kernel: Keep in mind that if you change the following parameters,\n+        \/\/ also change the scheduling (global and local work sizes).\n+        final int M = size;\n+        final int N = size;\n+        final int K = size;\n+        final int BM = 64;\n+        final int BN = 64;\n+        final int BK = 16;\n+        final int TM = 4;\n+        final int TN = 4;\n+\n+        int bx = kc.bix;\n+        int by = kc.biy;\n+\n+        final int linearLocalId = kc.liy * kc.lsx + kc.lix;\n+        final int threadCol = kc.lix;\n+        final int threadRow = kc.liy;\n+\n+        SharedMemory tileA = SharedMemory.createLocal();\n+        SharedMemory tileB = SharedMemory.createLocal();\n+\n+        int aFrom = by * BM * size;\n+        int bFrom = bx * BN;\n+        int v = bx * BN;\n+        int cFrom = (by * BM * size) + (v);\n+\n+        final int innerRowA = linearLocalId \/ (BK \/ 4);\n+        final int innerColA = linearLocalId % (BK \/ 4);\n+        final int innerRowB = linearLocalId \/ (BN \/ 4);\n+        final int innerColB = linearLocalId % (BN \/ 4);\n+\n+        \/\/ Declarations of the arrays in private memory to perform register tiling\n+        PrivateArray threadResults = PrivateArray.createPrivate();\n+        FlatPrivate regM = FlatPrivate.createPrivate();\n+        FlatPrivate regN = FlatPrivate.createPrivate();\n+\n+        \/\/ initialize values\n+        for (int i = 0; i < (TN * TN); i++) {\n+            threadResults.array(i, 0.0f);\n+        }\n+\n+        final int extraCols = 0;\n+\n+        \/\/ Each thread loops over the tiles\n+        for (int bkIdx = 0; bkIdx < size; bkIdx += BK) {\n+\n+            Float4 loadA = matrixA.float4View((innerRowA * K + innerColA * 4) + aFrom);\n+            tileA.array((innerColA * 4 + 0) * BM + innerRowA, loadA.x());\n+            tileA.array((innerColA * 4 + 1) * BM + innerRowA, loadA.y());\n+            tileA.array((innerColA * 4 + 2) * BM + innerRowA, loadA.z());\n+            tileA.array((innerColA * 4 + 3) * BM + innerRowA, loadA.w());\n+\n+            Float4 loadB = matrixB.float4View((innerRowB * N + innerColB * 4) + bFrom);\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 0, loadB.x());\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 1, loadB.y());\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 2, loadB.z());\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 3, loadB.w());\n+\n+            kc.barrier();\n+\n+            aFrom += (BK);\n+            int f = BK * size;\n+            bFrom += f;\n+\n+            \/\/ Per-thread, we load the data from the shared memory into register for both\n+            \/\/ array A and array B (matrix A and B), and then perform the reduction within\n+            \/\/ the small region in private memory.\n+            for (int dotIdx = 0; dotIdx < BK; dotIdx++) {\n+                \/\/ block into registers\n+                for (int i = 0; i < TM; i++) {\n+                    regM.array(i,  tileA.array(dotIdx * BM + threadRow * TM + i));\n+                }\n+                for (int i = 0; i < TN; i++) {\n+                    regN.array(i,  tileB.array(dotIdx * (BN + extraCols) + threadCol * TN + i));\n+                }\n+                for (int resIdxM = 0; resIdxM < TM; resIdxM++) {\n+                    for (int resIdxN = 0; resIdxN < TN; resIdxN++) {\n+                        float val = regM.array(resIdxM) * regN.array(resIdxN);\n+                        float acc = threadResults.array(resIdxM * TN + resIdxN);\n+                        acc += val;\n+                        threadResults.array((resIdxM * TN + resIdxN), (acc));\n+                    }\n+                }\n+            }\n+            kc.barrier();\n+        }\n+\n+        \/\/ Finally, we store the results of the reductions for the whole 2D register block into global memory.\n+        \/\/ Essentially, each thread compute a small block of TM * TN sub-block size.\n+        for (int resIdxM = 0; resIdxM < TM; resIdxM++) {\n+            for (int resIdxN = 0; resIdxN < TN; resIdxN++) {\n+                float value = threadResults.array(resIdxM * TN + resIdxN);\n+                matrixC.array((((threadRow * TM + resIdxM) * N + threadCol * TN + resIdxN) + (cFrom)), value);\n+            }\n+        }\n+    }\n+\n@@ -433,0 +555,8 @@\n+    @CodeReflection\n+    public static void matrixMultiply2DRegisterTilingVectorizedAccesses(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange cudaRange = new ComputeRange(new GlobalMesh2D(256, 256), new LocalMesh2D(16, 16));\n+        cc.dispatchKernel(cudaRange,\n+                kc -> matrixMultiplyKernel2DRegisterTilingVectorized(kc, matrixA, matrixB, matrixC, globalSize)\n+        );\n+    }\n+\n@@ -459,0 +589,1 @@\n+        _2DREGISTER_TILING_VECTORIZED,\n@@ -480,0 +611,1 @@\n+                case \"2DREGISTERTILING_V\" -> Configuration._2DREGISTER_TILING_VECTORIZED;\n@@ -525,0 +657,3 @@\n+                case _2DREGISTER_TILING_VECTORIZED -> accelerator.compute(cc ->\n+                            matrixMultiply2DRegisterTilingVectorizedAccesses(cc, matrixA, matrixB, matrixC, size));\n+                default -> throw new RuntimeException(\"Unknown configuration: \" + configuration);\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -172,1 +172,2 @@\n-                \"oracle.code.hat.TestArrayView\"\n+                \"oracle.code.hat.TestArrayView\",\n+                \"oracle.code.hat.TestVectorTypes\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import hat.buffer.Buffer;\n@@ -38,1 +37,0 @@\n-import hat.ifacemapper.Schema;\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestArrays.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import hat.buffer.Float4;\n@@ -412,0 +413,3 @@\n+\n+         default void storeFloat4View(Float4 float4, int index) {\n+        }\n@@ -542,0 +546,101 @@\n+    \/\/ Code ported from the HAT example module.\n+    @CodeReflection\n+    public static void matrixMultiplyKernel2DRegisterTilingVectorized(@RO KernelContext kc, @RO F32Array matrixA, @RO F32Array matrixB, @RW F32Array matrixC, int size) {\n+\n+        \/\/ Configuration for the kernel: Keep in mind that if you change the following parameters,\n+        \/\/ also change the scheduling (global and local work sizes).\n+        final int M = size;\n+        final int N = size;\n+        final int K = size;\n+        final int BM = 64;\n+        final int BN = 64;\n+        final int BK = 16;\n+        final int TM = 4;\n+        final int TN = 4;\n+\n+        int bx = kc.bix;\n+        int by = kc.biy;\n+\n+        final int linearLocalId = kc.liy * kc.lsx + kc.lix;\n+        final int threadCol = kc.lix;\n+        final int threadRow = kc.liy;\n+\n+        SharedMemory tileA = SharedMemory.createLocal();\n+        SharedMemory tileB = SharedMemory.createLocal();\n+\n+        int aFrom = by * BM * size;\n+        int bFrom = bx * BN;\n+        int v = bx * BN;\n+        int cFrom = (by * BM * size) + (v);\n+\n+        final int innerRowA = linearLocalId \/ (BK \/ 4);\n+        final int innerColA = linearLocalId % (BK \/ 4);\n+        final int innerRowB = linearLocalId \/ (BN \/ 4);\n+        final int innerColB = linearLocalId % (BN \/ 4);\n+\n+        \/\/ Declarations of the arrays in private memory to perform register tiling\n+        PrivateArray threadResults = PrivateArray.createPrivate();\n+        FlatPrivate regM = FlatPrivate.createPrivate();\n+        FlatPrivate regN = FlatPrivate.createPrivate();\n+\n+        \/\/ initialize values\n+        for (int i = 0; i < (TN * TN); i++) {\n+            threadResults.array(i, 0.0f);\n+        }\n+\n+        final int extraCols = 0;\n+\n+        \/\/ Each thread loops over the tiles\n+        for (int bkIdx = 0; bkIdx < size; bkIdx += BK) {\n+\n+            Float4 loadA = matrixA.float4View((innerRowA * K + innerColA * 4) + aFrom);\n+            tileA.array((innerColA * 4 + 0) * BM + innerRowA, loadA.x());\n+            tileA.array((innerColA * 4 + 1) * BM + innerRowA, loadA.y());\n+            tileA.array((innerColA * 4 + 2) * BM + innerRowA, loadA.z());\n+            tileA.array((innerColA * 4 + 3) * BM + innerRowA, loadA.w());\n+\n+            Float4 loadB = matrixB.float4View((innerRowB * N + innerColB * 4) + bFrom);\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 0, loadB.x());\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 1, loadB.y());\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 2, loadB.z());\n+            tileB.array(innerRowB * (BN + extraCols) + innerColB * 4 + 3, loadB.w());\n+\n+            kc.barrier();\n+\n+            aFrom += (BK);\n+            int f = BK * size;\n+            bFrom += f;\n+\n+            \/\/ Per-thread, we load the data from the shared memory into register for both\n+            \/\/ array A and array B (matrix A and B), and then perform the reduction within\n+            \/\/ the small region in private memory.\n+            for (int dotIdx = 0; dotIdx < BK; dotIdx++) {\n+                \/\/ block into registers\n+                for (int i = 0; i < TM; i++) {\n+                    regM.array(i,  tileA.array(dotIdx * BM + threadRow * TM + i));\n+                }\n+                for (int i = 0; i < TN; i++) {\n+                    regN.array(i,  tileB.array(dotIdx * (BN + extraCols) + threadCol * TN + i));\n+                }\n+                for (int resIdxM = 0; resIdxM < TM; resIdxM++) {\n+                    for (int resIdxN = 0; resIdxN < TN; resIdxN++) {\n+                        float val = regM.array(resIdxM) * regN.array(resIdxN);\n+                        float acc = threadResults.array(resIdxM * TN + resIdxN);\n+                        acc += val;\n+                        threadResults.array((resIdxM * TN + resIdxN), (acc));\n+                    }\n+                }\n+            }\n+            kc.barrier();\n+        }\n+\n+        \/\/ Finally, we store the results of the reductions for the whole 2D register block into global memory.\n+        \/\/ Essentially, each thread compute a small block of TM * TN sub-block size.\n+        for (int resIdxM = 0; resIdxM < TM; resIdxM++) {\n+            for (int resIdxN = 0; resIdxN < TN; resIdxN++) {\n+                float value = threadResults.array(resIdxM * TN + resIdxN);\n+                matrixC.array((((threadRow * TM + resIdxM) * N + threadCol * TN + resIdxN) + (cFrom)), value);\n+            }\n+        }\n+    }\n+\n@@ -550,0 +655,8 @@\n+    @CodeReflection\n+    public static void matrixMultiply2DRegisterTilingVectorized(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, final int size) {\n+        ComputeRange cudaRange = new ComputeRange(new GlobalMesh2D(256, 256), new LocalMesh2D(16, 16));\n+        cc.dispatchKernel(cudaRange,\n+                kc -> matrixMultiplyKernel2DRegisterTilingVectorized(kc, matrixA, matrixB, matrixC, size)\n+        );\n+    }\n+\n@@ -584,0 +697,34 @@\n+\n+    @HatTest\n+    public void testMatMul2DRegisterTilingVectorized() {\n+        var lookup = java.lang.invoke.MethodHandles.lookup();\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\n+\n+        final int size = 1024;\n+        var matrixA = F32Array.create(accelerator, size * size);\n+        var matrixB = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Matrix for the results\n+        var matrixC = F32Array.create(accelerator, size * size);\n+        var resultSeq = F32Array.create(accelerator, size * size);\n+\n+        \/\/ Initialize matrices (A and B have the same size)\n+        Random r = new Random(19);\n+\n+        for (int j = 0; j < matrixA.length(); j++) {\n+            matrixA.array(j, r.nextFloat());\n+            matrixB.array(j, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc ->\n+                TestMatMul.matrixMultiply2DRegisterTilingVectorized(cc, matrixA, matrixB, matrixC, size));\n+\n+        \/\/ Run Seq for reference\n+        runSequential(matrixA, matrixB, resultSeq, size);\n+\n+        for (int j = 0; j < size; j++) {\n+            for (int i = 0; i < size; i++) {\n+                HatAsserts.assertEquals(resultSeq.array(i * size + j), matrixC.array(i * size + j), 0.01f);\n+            }\n+        }\n+    }\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestMatMul.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,572 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.*;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.F32Array;\n+import hat.buffer.Float4;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+public class TestVectorTypes {\n+\n+    @CodeReflection\n+    public static void vectorOps01(@RO KernelContext kernelContext, @RO F32Array a, @RO F32Array b, @RW F32Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4 vB = b.float4View(index * 4);\n+            Float4 vC = Float4.add(vA, vB);\n+            c.storeFloat4View(vC, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps02(@RO KernelContext kernelContext, @RO F32Array a, @RW F32Array b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            float scaleX = vA.x() * 10.0f;\n+            vA.x(scaleX);\n+            b.storeFloat4View(vA, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps03(@RO KernelContext kernelContext, @RO F32Array a, @RW F32Array b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            float scaleX = vA.x() * 10.0f;\n+            float scaleY = vA.y() * 20.0f;\n+            float scaleZ = vA.z() * 30.0f;\n+            float scaleW = vA.w() * 40.0f;\n+            vA.x(scaleX);\n+            vA.y(scaleY);\n+            vA.z(scaleZ);\n+            vA.w(scaleW);\n+            b.storeFloat4View(vA, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps04(@RO KernelContext kernelContext, @RO F32Array a, @RW F32Array b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            vA.x(vA.x() * 10.0f);\n+            vA.y(vA.y() * 20.0f);\n+            vA.z(vA.z() * 30.0f);\n+            vA.w(vA.w() * 40.0f);\n+            b.storeFloat4View(vA, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps05(@RO KernelContext kernelContext, @RO F32Array a, @RO F32Array b, @RW F32Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4 vB = b.float4View(index * 4);\n+            Float4 vC = vA.add(vB).add(vB);\n+            c.storeFloat4View(vC, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps06(@RO KernelContext kernelContext, @RO F32Array a, @RO F32Array b, @RW F32Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4 vB = b.float4View(index * 4);\n+            Float4 vD = Float4.sub(vA, vB);\n+            Float4 vC = vA.sub(vB);\n+            c.storeFloat4View(vC, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps07(@RO KernelContext kernelContext, @RO F32Array a, @RO F32Array b, @RW F32Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4 vB = b.float4View(index * 4);\n+            Float4 vC = vA.add(vB).sub(vB);\n+            c.storeFloat4View(vC, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps08(@RO KernelContext kernelContext, @RO F32Array a, @RO F32Array b, @RW F32Array c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4 vB = b.float4View(index * 4);\n+            Float4 vC = vA.add(vB).mul(vA).div(vB);\n+            c.storeFloat4View(vC, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps09(@RO KernelContext kernelContext, @RO F32Array a, @RO F32Array b, @RW F32Array c) {\n+        \/\/ Checking composition\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            Float4 vB = b.float4View(index * 4);\n+            Float4 vC = vA.add(vA.mul(vB));\n+            c.storeFloat4View(vC, index * 4);\n+        }\n+    }\n+\n+    private interface SharedMemory extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+        Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n+                arr -> arr.array(\"array\", 1024));\n+        static SharedMemory create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+        static SharedMemory createLocal() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+        default Float4 float4View(int index) {\n+            return null;\n+        }\n+        default void storeFloat4View(Float4 float4, int index) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps10(@RO KernelContext kernelContext, @RO F32Array a, @RW F32Array b) {\n+        SharedMemory sm = SharedMemory.createLocal();\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            int lix = kernelContext.lix;\n+            Float4 vA = a.float4View(index * 4);\n+            sm.storeFloat4View(vA, lix * 4);\n+            kernelContext.barrier();\n+            Float4 r = sm.float4View(lix * 4);\n+            b.storeFloat4View(r, index * 4);\n+        }\n+    }\n+\n+    private interface PrivateMemory extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+        Schema<PrivateMemory> schema = Schema.of(PrivateMemory.class,\n+                arr -> arr.array(\"array\", 4));\n+        static PrivateMemory create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+        static PrivateMemory createPrivate() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+        default Float4 float4View(int index) {\n+            return null;\n+        }\n+        default void storeFloat4View(Float4 float4, int index) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps11(@RO KernelContext kernelContext, @RO F32Array a, @RW F32Array b) {\n+        PrivateMemory pm = PrivateMemory.createPrivate();\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4 vA = a.float4View(index * 4);\n+            pm.storeFloat4View(vA, 0);\n+            kernelContext.barrier();\n+            Float4 r = pm.float4View(0);\n+            b.storeFloat4View(r, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps12(@RO KernelContext kernelContext, @RO F32Array a, @RW F32Array b) {\n+        SharedMemory sm = SharedMemory.createLocal();\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            int lix = kernelContext.lix;\n+            Float4 vA = a.float4View(index * 4);\n+            sm.array(lix * 4 + 0, vA.x());\n+            sm.array(lix * 4 + 1, vA.y());\n+            sm.array(lix * 4 + 2, vA.z());\n+            sm.array(lix * 4 + 3, vA.w());\n+            kernelContext.barrier();\n+            Float4 r = sm.float4View(lix * 4);\n+            b.storeFloat4View(r, index * 4);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph01(@RO ComputeContext cc, @RO F32Array a, @RO F32Array b, @RW F32Array c, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps01(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph02(@RO ComputeContext cc, @RW F32Array a, @RW F32Array b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps02(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph03(@RO ComputeContext cc, @RO F32Array a, @RW F32Array b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps03(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph04(@RO ComputeContext cc, @RO F32Array a, @RW F32Array b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps04(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph05(@RO ComputeContext cc, @RO F32Array a, @RO F32Array b, @RW F32Array c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps05(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph06(@RO ComputeContext cc, @RO F32Array a, @RO F32Array b, @RW F32Array c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps06(kernelContext, a, b, c));\n+    }\n+\n+\n+    @CodeReflection\n+    public static void computeGraph07(@RO ComputeContext cc, @RO F32Array a, @RO F32Array b, @RW F32Array c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps07(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph08(@RO ComputeContext cc, @RO F32Array a, @RO F32Array b, @RW F32Array c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps08(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph09(@RO ComputeContext cc, @RO F32Array a, @RO F32Array b, @RW F32Array c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps09(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph10(@RO ComputeContext cc, @RO F32Array a,  @RW F32Array b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps10(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph11(@RO ComputeContext cc, @RO F32Array a,  @RW F32Array b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps11(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph12(@RO ComputeContext cc, @RO F32Array a,  @RW F32Array b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> TestVectorTypes.vectorOps12(kernelContext, a, b));\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes01() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph01(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i++) {\n+            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes02() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph02(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 1)), arrayB.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 2)), arrayB.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 3)), arrayB.array(i + 3), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes03() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph03(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes04() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph04(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes05() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph05(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes06() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph06(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals((arrayA.array(i) - arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes07() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph07(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes08() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph08(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            float val = (((arrayA.array(i) + arrayB.array(i)) * arrayA.array(i)) \/ arrayB.array(i));\n+            HatAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes09() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+        var arrayC = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph09(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            float val = (arrayA.array(i) + (arrayB.array(i)) * arrayA.array(i));\n+            HatAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes10() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph10(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes11() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph11(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testVectorTypes12() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32Array.create(accelerator, size);\n+        var arrayB = F32Array.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> TestVectorTypes.computeGraph12(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestVectorTypes.java","additions":572,"deletions":0,"binary":false,"changes":572,"status":"added"},{"patch":"@@ -30,0 +30,5 @@\n+import hat.dialect.HatVSelectLoadOp;\n+import hat.dialect.HatVSelectStoreOp;\n+import hat.dialect.HatVectorBinaryOp;\n+import hat.dialect.HatVectorLoadOp;\n+import hat.dialect.HatVectorStoreView;\n@@ -34,0 +39,2 @@\n+import hat.dialect.HatVectorVarLoadOp;\n+import hat.dialect.HatVectorVarOp;\n@@ -40,1 +47,2 @@\n-public  class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+public class JavaHATCodeBuilder<T extends JavaHATCodeBuilder<T>> extends HATCodeBuilderWithContext<T> {\n+\n@@ -98,0 +106,30 @@\n+    @Override\n+    public T generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+        blockComment(\"Store Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+        blockComment(\"Binary Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+        blockComment(\"Load Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+        blockComment(\"Select Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+        blockComment(\"Select Vector Not Implemented\");\n+        return self();\n+    }\n+\n@@ -128,0 +166,42 @@\n+    @Override\n+    public T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+        blockComment(\"Vector Variable Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+        blockComment(\"Store Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+        blockComment(\"Binary Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+        blockComment(\"Load Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+        blockComment(\"Select Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+        blockComment(\"Select Vector Not Implemented\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+        blockComment(\"Vector Variable Not Implemented\");\n+        return self();\n+    }\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"}]}