{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.Value;\n@@ -30,0 +31,1 @@\n+import optkl.OpHelper;\n@@ -33,0 +35,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Optional;\n@@ -34,1 +39,0 @@\n-import static experiments.LanewiseUtils.createBinaryOp;\n@@ -39,0 +43,74 @@\n+    \/**\n+     * Look for first real BinaryOp by recursively descending through nested invokes until we find a BinaryOp\n+     *\n+     * @param invoke An Invoke call which either includes a BinaryOp or calls a reflectable method that does.\n+     * @return The binaryOp from either this method or one reachable from it\n+     * @throws RuntimeException if we fail to locate a Binary op\n+     *\n+     * This method is recursive\n+     *\n+     * The assumption is that only one BinaryOp type will be found.\n+     *\n+     * We first trivially test if the target of the invoke has a binary op (stream test on code elements) , if it does we return it\n+     * If not then we find all invokes from this call and scan (recursively) until we find an invoke that contains a Binary Op.\n+     *\n+     * So if we had\n+     *   @Reflect\n+     *   static S32x2 mul(S32x2 lhs, S32x2 rhs) { #1\n+     *        return new S32x2(lhs.x * rhs.x, lhs.y * rhs.y);\n+     *   }\n+     *\n+     *   @Reflect\n+     *   public S32x2 mul(S32x2 rhs) { \/\/ #2\n+     *       return mul(this, rhs);\n+     *   }\n+     *\n+     *   And our invoke was called on the static op form  (#1) we would 'trivially' return MulOp\n+     *\n+     *   If the invoke was on the fluent form  (#2) we would not find one trivially so would\n+     *   recurse inside the fluent op on all methods, until we find an invoke that does.\n+     *\n+\n+     *\/\n+    static JavaOp.BinaryOp getLaneWiseOp(OpHelper.Named.NamedStaticOrInstance.Invoke invoke) {\n+        if (invoke.targetMethodModelOrThrow().elements().filter(o -> o instanceof JavaOp.BinaryOp).map(o -> (JavaOp.BinaryOp) o).findFirst()\n+                instanceof Optional<JavaOp.BinaryOp> optionalBinaryOp && optionalBinaryOp.isPresent()) {\n+            return optionalBinaryOp.get();\n+        } else {\n+            return  OpHelper.Named.NamedStaticOrInstance.Invoke\n+                    .stream(invoke.lookup(),invoke.targetMethodModelOrThrow())\n+                    .map(LanewiseBinaryOpExtraction::getLaneWiseOp)\n+                    .findFirst()\n+                    .get();\n+        }\n+    }\n+\n+    \/**\n+     * Here we determine the lanewise BinaryOp type (see #getLineWiseOP) and reflectively scan JavaOp.class for a suitable factory and invoke.\n+     * @param invoke An invoke helper representing the top level fluent or static call we assume is a binary op\n+     * @param lhs the mapped lhs value\n+     * @param rhs the mapped rhs value\n+     * @return a new binary Op\n+     *\n+     * @throws RuntimeException if we can't find an Op.\n+     *\/\n+\n+    static JavaOp.BinaryOp createBinaryOp(OpHelper.Named.NamedStaticOrInstance.Invoke invoke, Value lhs, Value rhs) {\n+        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);\n+        Class<JavaOp.BinaryOp> clazz = (Class<JavaOp.BinaryOp>) laneWiseBinaryOp.getClass();\n+        var optionalMethod = Arrays.stream(JavaOp.class.getDeclaredMethods()).filter(m ->\n+                m.getParameterCount()==2 && clazz.isAssignableFrom(m.getReturnType())\n+        ).findFirst();\n+        if (optionalMethod.isPresent()) {\n+            try {\n+                return  (JavaOp.BinaryOp) optionalMethod.get().invoke(null, lhs, rhs);\n+            } catch (IllegalAccessException | InvocationTargetException e) {\n+                throw new RuntimeException(e.getMessage());\n+            }\n+        }else{\n+            throw new RuntimeException(\"Failed to find binary op factory for \"+clazz);\n+        }\n+    }\n+\n+\n+\n@@ -50,3 +128,2 @@\n-                    if (binaryOpQuery.matches(c, $ ->\n-                            \/\/ does it look like a fluent binary op we don't care about the name\n-                            $.returns(S32x2.class) && $.isInstance() && $.receives( S32x2.class)\n+                    if (binaryOpQuery.matches(c, $ ->\/\/ trivially look for a fluent style binary Op such as  S32x2.add(S32x2 rhs)\n+                            $.isInstance() && $.returns(S32x2.class) &&  $.receives( S32x2.class)\n@@ -54,1 +131,3 @@\n-                        c.replace(createBinaryOp(match.helper(), c.mappedOperand(0), c.mappedOperand(1)));\n+                        c.replace(\n+                                createBinaryOp(match.helper(), c.mappedOperand(0), c.mappedOperand(1))\n+                        );\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseBinaryOpExtraction.java","additions":84,"deletions":5,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package experiments;\n-\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.InvokeQuery;\n-import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import optkl.Trxfmr;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.Arrays;\n-import java.util.Optional;\n-\n-public class LanewiseUtils {\n-    \/**\n-     * Look for first real BinaryOp by recursively decending through nested invokes until we find a BinaryOp\n-     *\n-     * We first test if the target of the invoke has a binary op, if it does we return it\n-     * If not then we find the first invoke in the target of this invoke that returns a binary Op and return that one\n-     *\n-     * So if we had\n-     *   @Reflect\n-     *   static S32x2 mul(S32x2 lhs, S32x2 rhs) { #1\n-     *        return new S32x2(lhs.x * rhs.x, lhs.y * rhs.y);\n-     *   }\n-     *\n-     *   @Reflect\n-     *   public S32x2 mul(S32x2 rhs) { \/\/ #2\n-     *       return mul(this, rhs);\n-     *   }\n-     *\n-     *   And our invoke was #1 we would return MulOp\n-     *\n-     *   If the invoke was #2 we would recurse inside and then end up at #1 and return Mul Op.\n-     * @return The binaryOp from one of the reachable methods\n-     *\/\n-\n-    static JavaOp.BinaryOp getLaneWiseOp(Invoke invoke) {\n-        if (invoke.targetMethodModelOrThrow().elements().filter(o -> o instanceof JavaOp.BinaryOp).map(o -> (JavaOp.BinaryOp) o).findFirst()\n-                instanceof Optional<JavaOp.BinaryOp> optionalBinaryOp && optionalBinaryOp.isPresent()) {\n-            return optionalBinaryOp.get();\n-        } else {\n-           return  Invoke.stream(invoke.lookup(),invoke.targetMethodModelOrThrow()).map(LanewiseUtils::getLaneWiseOp).findFirst().get();\n-        }\n-    }\n-\n-    static JavaOp.BinaryOp createBinaryOpViaNameSwitch(String name, Value lhs, Value rhs) {\n-        return switch (name) {\n-           case \"add\" -> JavaOp.add(lhs, rhs);\n-           case \"sub\" -> JavaOp.sub(lhs, rhs);\n-           case \"div\" -> JavaOp.div(lhs, rhs);\n-            case \"mul\" -> JavaOp.mul(lhs, rhs);\n-           case \"mod\" -> JavaOp.mod(lhs, rhs);\n-           default -> throw new IllegalStateException(\"missed one\");\n-      };\n-    }\n-\n-    static JavaOp.BinaryOp createBinaryOpFromNameViaReflection(String name, Value lhs, Value rhs) {\n-        var opMethod = Arrays.stream(JavaOp.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get();\n-        try {\n-            return (JavaOp.BinaryOp) opMethod.invoke(null, lhs, rhs);\n-        } catch (IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    static <T extends JavaOp.BinaryOp> T createBinaryOpViaClass(Class<T> clazz, Value lhs, Value rhs) {\n-        String name = clazz.getName();\n-\n-        var opMethod = Arrays.stream(JavaOp.class.getDeclaredMethods())\n-                .filter(m -> {\n-                    Class<?> returnType =  m.getReturnType();\n-                    String returnTypeName = returnType.getName();\n-                    boolean sameName = returnTypeName.equals(name);\n-                    if (sameName){\n-                        sameName=sameName;\n-                    }\n-                    return returnType.isAssignableFrom(clazz) && sameName;\n-                }).findFirst().get();\n-        try {\n-            return (T) opMethod.invoke(null, lhs, rhs);\n-        } catch (IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    static JavaOp.BinaryOp createBinaryOpFromCodeModelViaClass(Invoke invoke, Value lhs, Value rhs) {\n-        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);\n-        Class<JavaOp.BinaryOp> clazz = (Class<JavaOp.BinaryOp>) laneWiseBinaryOp.getClass();\n-        return createBinaryOpViaClass(clazz, lhs, rhs);\n-    }\n-\n-    static JavaOp.BinaryOp createBinaryOpFromCodeModelFromNameViaReflectedName(Invoke invoke, Value lhs, Value rhs) {\n-        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n-        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n-        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n-        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n-        return createBinaryOpFromNameViaReflection(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n-    }\n-    static JavaOp.BinaryOp createBinaryOpFromCodeModelFromNameViaNameSwitch(Invoke invoke, Value lhs, Value rhs) {\n-        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n-        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n-        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n-        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n-        return createBinaryOpViaNameSwitch(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n-    }\n-    static JavaOp.BinaryOp createBinaryOp(Invoke invoke, Value lhs, Value rhs) {\n-        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n-        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n-        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n-        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n-        return createBinaryOpViaNameSwitch(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseUtils.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"}]}