{"files":[{"patch":"@@ -152,1 +152,2 @@\n-    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object[] args) {\n+    \/\/ @@@ Add List<Object> accepting method, varargs array defers to it\n+    public static Quoted quotedOp(CoreOp.FuncOp funcOp, Object... args) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-    public final MethodSymbol opInterpreterInvoke;\n-    public final MethodSymbol opParserFromString;\n-    public final MethodSymbol methodHandlesLookup;\n@@ -54,0 +51,2 @@\n+    public final Type funcOpType;\n+    public final MethodSymbol quotedQuotedOp;\n@@ -62,1 +61,0 @@\n-        Type opInterpreterType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.interpreter.Interpreter\");\n@@ -64,3 +62,4 @@\n-        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n-                names.fromString(\"invoke\"),\n-                new MethodType(List.of(syms.methodHandleLookupType, opType, new ArrayType(syms.objectType, syms.arrayClass)), syms.objectType,\n+        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n+        quotedQuotedOp = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n+                names.fromString(\"quotedOp\"),\n+                new MethodType(List.of(funcOpType, new ArrayType(syms.objectType, syms.arrayClass)), quotedType,\n@@ -68,12 +67,1 @@\n-                opInterpreterType.tsym);\n-        Type opParserType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.extern.OpParser\");\n-        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n-                names.fromString(\"fromStringOfJavaCodeModel\"),\n-                new MethodType(List.of(syms.stringType), opType,\n-                        List.nil(), syms.methodClass),\n-                opParserType.tsym);\n-        methodHandlesLookup = new MethodSymbol(PUBLIC | STATIC,\n-                names.fromString(\"lookup\"),\n-                new MethodType(List.nil(), syms.methodHandleLookupType,\n-                        List.nil(), syms.methodClass),\n-                syms.methodHandlesType.tsym);\n+                quotedType.tsym);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -234,6 +234,1 @@\n-                        JCIdent opMethodId = make.Ident(opMethod.sym);\n-                        ListBuffer<JCExpression> interpreterArgs = new ListBuffer<>();\n-                        \/\/ Obtain MethodHandles.lookup()\n-                        \/\/ @@@ Could probably use MethodHandles.publicLookup()\n-                        JCMethodInvocation lookup = make.App(make.Ident(crSyms.methodHandlesLookup), com.sun.tools.javac.util.List.nil());\n-                        interpreterArgs.append(lookup);\n+                        ListBuffer<JCExpression> args = new ListBuffer<>();\n@@ -241,2 +236,3 @@\n-                        JCMethodInvocation op = make.App(opMethodId);\n-                        interpreterArgs.append(op);\n+                        JCIdent opMethodId = make.Ident(opMethod.sym);\n+                        JCExpression op = make.TypeCast(crSyms.funcOpType, make.App(opMethodId));\n+                        args.add(op);\n@@ -245,5 +241,4 @@\n-                        interpreterArgs.appendList(capturedArgs.toList());\n-\n-                        \/\/ Interpret the func operation to produce the quoted instance\n-                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(crSyms.opInterpreterInvoke), interpreterArgs.toList());\n-                        interpreterInvoke.varargsElement = syms.objectType;\n+                        args.appendList(capturedArgs.toList());\n+                        \/\/ Get the quoted instance by calling Quoted::quotedOp\n+                        JCMethodInvocation quotedInvoke = make.App(make.Ident(crSyms.quotedQuotedOp), args.toList());\n+                        quotedInvoke.varargsElement = syms.objectType;\n@@ -251,1 +246,1 @@\n-                        result = interpreterInvoke;\n+                        result = quotedInvoke;\n@@ -361,0 +356,2 @@\n+    \/\/ @@@ Retain enum for when we might add another storage to test\n+    \/\/ and compare\n@@ -362,1 +359,1 @@\n-        TEXT, CODE_BUILDER;\n+        CODE_BUILDER;\n@@ -380,18 +377,7 @@\n-        var body = switch (codeModelStorageOption) {\n-            case TEXT -> {\n-                \/\/ Code model is stored in textual form as a constant string\n-                \/\/ and is constructed by parsing the string\n-                var opFromStr = make.App(make.Ident(crSyms.opParserFromString),\n-                        com.sun.tools.javac.util.List.of(make.Literal(op.toText())));\n-                yield make.Return(opFromStr);\n-            }\n-            case CODE_BUILDER -> {\n-                \/\/ Code model is stored as code that builds the code model\n-                \/\/ using the builder API and public APIs\n-                var opBuilder = OpBuilder.createBuilderFunction(op,\n-                        b -> b.op(JavaOp.fieldLoad(\n-                                FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n-                var codeModelTranslator = new CodeModelTranslator();\n-                yield codeModelTranslator.translateFuncOp(opBuilder, ms);\n-            }\n-        };\n+        \/\/ Code model is stored as code that builds the code model\n+        \/\/ using the builder API and public APIs\n+        var opBuilder = OpBuilder.createBuilderFunction(op,\n+                b -> b.op(JavaOp.fieldLoad(\n+                        FieldRef.field(JavaOp.class, \"JAVA_DIALECT_FACTORY\", DialectFactory.class))));\n+        var codeModelTranslator = new CodeModelTranslator();\n+        var body = codeModelTranslator.translateFuncOp(opBuilder, ms);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":19,"deletions":33,"binary":false,"changes":52,"status":"modified"}]}