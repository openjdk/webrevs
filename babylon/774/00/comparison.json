{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n@@ -46,0 +47,1 @@\n+import java.util.Optional;\n@@ -130,1 +132,5 @@\n-        this.computeCallGraph = new ComputeCallGraph(this, computeMethod, Op.ofMethod(computeMethod).orElseThrow());\n+        Optional<FuncOp> funcOp =  Op.ofMethod(computeMethod);\n+        if (funcOp.isEmpty()) {\n+            throw new RuntimeException(\"Failed to create ComputeCallGraph (did you miss @Reflect annotation?).\");\n+        }\n+        this.computeCallGraph = new ComputeCallGraph(this, computeMethod, funcOp.get());\n@@ -146,1 +152,1 @@\n-            throw new RuntimeException(\"Failed to create KernelCallGraph (did you miss @Reflect annotation?) \");\n+            throw new RuntimeException(\"Failed to create KernelCallGraph (did you miss @Reflect annotation?).\");\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+\n@@ -112,1 +113,0 @@\n-\n@@ -117,1 +117,0 @@\n-\n@@ -126,1 +125,0 @@\n-\n@@ -193,0 +191,1 @@\n+\n@@ -199,0 +198,1 @@\n+\n@@ -213,0 +213,1 @@\n+\n@@ -216,0 +217,1 @@\n+\n@@ -219,0 +221,1 @@\n+\n@@ -223,2 +226,0 @@\n-\n-\n@@ -240,0 +241,1 @@\n+\n@@ -354,0 +356,1 @@\n+\n@@ -357,0 +360,1 @@\n+\n@@ -360,0 +364,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -97,1 +96,0 @@\n-\n@@ -116,2 +114,0 @@\n-\n-\n@@ -238,0 +234,1 @@\n+\n@@ -249,0 +246,1 @@\n+\n@@ -470,1 +468,0 @@\n-\n@@ -518,2 +515,0 @@\n-\n-\n@@ -523,2 +518,0 @@\n-\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-     public T compute(ScopedCodeBuilderContext buildContext) {\n-\n+    public T compute(ScopedCodeBuilderContext buildContext) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATConfigBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T>implements BabylonKernelOpBuilder<T>  {\n+public abstract class C99HATKernelBuilder<T extends C99HATKernelBuilder<T>> extends C99HATCodeBuilderContext<T> implements BabylonKernelOpBuilder<T>  {\n+\n@@ -56,0 +57,1 @@\n+\n@@ -63,0 +65,1 @@\n+\n@@ -66,0 +69,1 @@\n+\n@@ -73,0 +77,1 @@\n+\n@@ -76,0 +81,1 @@\n+\n@@ -79,0 +85,1 @@\n+\n@@ -82,0 +89,1 @@\n+\n@@ -85,0 +93,1 @@\n+\n@@ -88,0 +97,1 @@\n+\n@@ -96,0 +106,1 @@\n+\n@@ -105,0 +116,1 @@\n+\n@@ -108,0 +120,1 @@\n+\n@@ -111,0 +124,1 @@\n+\n@@ -114,0 +128,1 @@\n+\n@@ -117,0 +132,1 @@\n+\n@@ -120,0 +136,1 @@\n+\n@@ -123,0 +140,1 @@\n+\n@@ -132,2 +150,0 @@\n-\n-\n@@ -142,0 +158,1 @@\n+\n@@ -145,0 +162,1 @@\n+\n@@ -148,0 +166,1 @@\n+\n@@ -161,3 +180,0 @@\n-\n-\n-\n@@ -285,1 +301,1 @@\n-     public record LocalArrayDeclaration(ClassType classType, HATMemoryVarOp varOp) {}\n+    public record LocalArrayDeclaration(ClassType classType, HATMemoryVarOp varOp) {}\n@@ -304,1 +320,0 @@\n-\n@@ -314,0 +329,1 @@\n+\n@@ -322,0 +338,1 @@\n+\n@@ -351,0 +368,1 @@\n+\n@@ -389,1 +407,0 @@\n-\n@@ -415,1 +432,0 @@\n-\n@@ -420,0 +436,1 @@\n+\n@@ -427,0 +444,1 @@\n+\n@@ -446,0 +464,1 @@\n+\n@@ -453,1 +472,0 @@\n-    private T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatf16BinaryOp) {\n@@ -455,0 +473,1 @@\n+    private T binaryOperationsForBfloat16(ScopedCodeBuilderContext buildContext, HATF16BinaryOp hatf16BinaryOp) {\n@@ -456,1 +475,0 @@\n-\n@@ -588,1 +606,0 @@\n-\n@@ -673,1 +690,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+\n@@ -223,0 +224,1 @@\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/ScopedCodeBuilderContext.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.test;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.NDRange;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import optkl.ifacemapper.MappableIface.RO;\n+import optkl.ifacemapper.MappableIface.RW;\n+import jdk.incubator.code.Reflect;\n+import hat.test.annotation.HatTest;\n+import hat.test.exceptions.HATAsserts;\n+import hat.test.exceptions.HATExpectedFailureException;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class TestMissingReflectAnnotation {\n+\n+    @Reflect\n+    public static int squareit(int v) {\n+        return  v * v;\n+\n+    }\n+\n+    @Reflect\n+    public static void squareKernel(@RO KernelContext kc, @RW S32Array array) {\n+        if (kc.gix < kc.gsx){\n+            int value = array.array(kc.gix);\n+            array.array(kc.gix, squareit(value));\n+        }\n+    }\n+\n+    public static void squareKernelWithoutReflectAnnotation(@RO KernelContext kc, @RW S32Array array) {\n+        if (kc.gix < kc.gsx){\n+            int value = array.array(kc.gix);\n+            array.array(kc.gix, squareit(value));\n+        }\n+    }\n+\n+    @Reflect\n+    public static void square(@RO ComputeContext cc, @RW S32Array array) {\n+        cc.dispatchKernel(NDRange.of1D(array.length()),\n+                kc -> squareKernelWithoutReflectAnnotation(kc, array)\n+        );\n+    }\n+\n+    public static void squareWithoutReflectAnnotation(@RO ComputeContext cc, @RW S32Array array) {\n+        cc.dispatchKernel(NDRange.of1D(array.length()),\n+                kc -> squareKernel(kc, array)\n+        );\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testComputeMethodWithoutReflectAnnotation() {\n+        final int size = 64;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var array = S32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        for (int i = 0; i < array.length(); i++) {\n+            array.array(i, i);\n+        }\n+\n+        try {\n+            accelerator.compute(cc -> TestMissingReflectAnnotation.squareWithoutReflectAnnotation(cc, array));\n+        } catch (RuntimeException e) {\n+            HATAsserts.assertEquals(\"Failed to create ComputeCallGraph (did you miss @Reflect annotation?).\", e.getMessage());\n+            return;\n+        }\n+        throw new HATExpectedFailureException(\"Failed to create ComputeCallGraph (did you miss @Reflect annotation?).\");\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testKernelMethodWithoutReflectAnnotation() {\n+        final int size = 64;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var array = S32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        for (int i = 0; i < array.length(); i++) {\n+            array.array(i, i);\n+        }\n+\n+        try {\n+            accelerator.compute(cc -> TestMissingReflectAnnotation.square(cc, array));\n+        } catch (RuntimeException e) {\n+            HATAsserts.assertTrue(e.getMessage().contains(\"Failed to create KernelCallGraph (did you miss @Reflect annotation?).\"));\n+            return;\n+        }\n+        throw new HATExpectedFailureException(\"Failed to create KernelCallGraph (did you miss @Reflect annotation?).\");\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMissingReflectAnnotation.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -44,0 +44,6 @@\n+    public static void assertEquals(String expected, String actual) {\n+        if (!expected.equals(actual)) {\n+            throw new HATAssertionError(\"Expected: \" + expected + \" != actual: \" + actual);\n+        }\n+    }\n+\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/exceptions\/HATAsserts.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}