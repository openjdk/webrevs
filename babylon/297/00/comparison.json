{"files":[{"patch":"@@ -1,74 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-      accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-cuda<\/artifactId>\n-    <version>1.0<\/version>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/hat-backend-cuda-1.0.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/cuda\/pom.xml","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-hat.backend.CudaBackend\n-hat.backend.JavaSequentialBackend\n-hat.backend.JavaMultiThreadedBackend\n","filename":"hat\/backends\/cuda\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"","filename":"hat\/backends\/ffi\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/cuda\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/cuda\/.gitignore","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/cuda\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/cuda\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/cuda\/cpp\/info.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/cuda\/cpp\/info.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/cuda\/include\/cuda_backend.h","status":"renamed"},{"patch":"@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-ffi-cuda<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-ffi<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <configuration>\n+                    <skip>true<\/skip>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-ffi-cuda-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/ffi\/cuda\/pom.xml","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -32,1 +32,1 @@\n-public class CudaBackend extends C99NativeBackend {\n+public class CudaBackend extends C99FFIBackend {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/backends\/cuda\/src\/main\/java\/hat\/backend\/CudaBackend.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/cuda\/src\/main\/java\/hat\/backend\/CudaDeviceInfo.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHatKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/cuda\/src\/main\/java\/hat\/backend\/CudaHatKernelBuilder.java","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.ffi.CudaBackend\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/cpp\/hip_backend.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/cpp\/hip_backend.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/cpp\/info.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/cpp\/info.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/include\/hip_backend.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/include\/hip_backend.h","status":"renamed"},{"patch":"@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-ffi-hip<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-ffi<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <configuration>\n+                    <skip>true<\/skip>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-ffi-hip-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/ffi\/hip\/pom.xml","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/src\/main\/java\/hat\/backend\/HIPBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/src\/main\/java\/hat\/backend\/HIPBackend.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/src\/main\/java\/hat\/backend\/HIPDeviceInfo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/src\/main\/java\/hat\/backend\/HIPDeviceInfo.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/src\/main\/java\/hat\/backend\/HIPHatKernelBuilder.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/src\/main\/java\/hat\/backend\/HIPHatKernelBuilder.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/hip\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/hip\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/mock\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/mock\/.gitignore","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/mock\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/mock\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/mock\/cpp\/info.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/mock\/cpp\/info.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/mock\/cpp\/mock_backend.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-ffi-mock<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-ffi<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <configuration>\n+                    <skip>true<\/skip>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-ffi-mock-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/ffi\/mock\/pom.xml","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -32,1 +32,0 @@\n-import hat.buffer.BufferAllocator;\n@@ -35,1 +34,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -37,6 +35,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-\n-public class MockBackend extends NativeBackend {\n+public class MockBackend extends FFIBackend {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"hat\/backends\/mock\/src\/main\/java\/hat\/backend\/MockBackend.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/mock\/src\/main\/java\/hat\/backend\/MockDeviceInfo.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/TestIt.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/mock\/src\/main\/java\/hat\/backend\/TestIt.java","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.ffi.MockBackend\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"hat\/backends\/ffi\/opencl\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/opencl\/.gitignore","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/opencl\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/opencl\/cpp\/info.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/opencl\/cpp\/info.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/opencl\/include\/opencl_backend.h","status":"renamed"},{"patch":"@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-ffi-opencl<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-ffi<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <configuration>\n+                    <skip>true<\/skip>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-ffi-opencl-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/ffi\/opencl\/pom.xml","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -32,1 +32,0 @@\n-import hat.buffer.BufferAllocator;\n@@ -35,1 +34,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -37,6 +35,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-\n-public class OpenCLBackend extends C99NativeBackend {\n+public class OpenCLBackend extends C99FFIBackend {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLBackend.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLDeviceInfo.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHatKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLHatKernelBuilder.java","status":"copied"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.ffi.OpenCLBackend\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n@@ -29,1 +29,1 @@\n-    <artifactId>hat-backends<\/artifactId>\n+    <artifactId>hat-backends-ffi<\/artifactId>\n@@ -33,1 +33,1 @@\n-        <artifactId>hat-root<\/artifactId>\n+        <artifactId>hat-backends<\/artifactId>\n","filename":"hat\/backends\/ffi\/pom.xml","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"hat\/backends\/pom.xml","status":"copied"},{"patch":"","filename":"hat\/backends\/ffi\/ptx\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/ptx\/.gitignore","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/ptx\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/ptx\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/ptx\/cpp\/info.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/ptx\/cpp\/info.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/ptx\/cpp\/ptx_backend.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/ptx\/cpp\/ptx_backend.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/ptx\/include\/ptx_backend.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/ptx\/include\/ptx_backend.h","status":"renamed"},{"patch":"@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-ffi-ptx<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-ffi<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <configuration>\n+                    <skip>true<\/skip>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-ffi-ptx-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/ffi\/ptx\/pom.xml","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -39,1 +39,1 @@\n-public class PTXBackend extends C99NativeBackend {\n+public class PTXBackend extends C99FFIBackend {\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXBackend.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXCodeBuilder.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXDeviceInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXDeviceInfo.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -28,1 +28,0 @@\n-import hat.ifacemapper.Schema;\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXPtrOp.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXPtrOp.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/PTXRegister.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXRegister.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/java\/hat\/backend\/ffi\/TestIt.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/TestIt.java","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.ffi.PTXBackend\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ffi\/ptx\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"hat\/backends\/ffi\/shared\/cpp\/schema.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/shared\/cpp\/schema.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/shared\/cpp\/schemadump.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/shared\/cpp\/schemadump.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/shared\/cpp\/shared.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/shared\/include\/cursor.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/shared\/include\/cursor.h","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/shared\/include\/schema.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/shared\/include\/schema.h","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/shared\/include\/shared.h","status":"renamed"},{"patch":"@@ -0,0 +1,2 @@\n+hat.backend.java.JavaMultiThreadedBackend\n+hat.backend.java.JavaSequentialBackend\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/CMakeLists.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/CMakeLists.txt","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/README.md","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/README.md","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/cpp\/info.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/cpp\/info.cpp","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/cpp\/spirv_backend.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-ffi-spirv<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-ffi<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <configuration>\n+                    <skip>true<\/skip>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-ffi-spirv-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/ffi\/spirv\/pom.xml","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/scripts\/build-beehive-spirv-toolkit.sh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/scripts\/build-beehive-spirv-toolkit.sh","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/scripts\/build-level-zero.sh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/scripts\/build-level-zero.sh","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/scripts\/generate-level-zero-binding.sh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/scripts\/generate-level-zero-binding.sh","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/hat\/backend\/SpirvBackend.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/hat\/backend\/SpirvBackend.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/hat\/backend\/SpirvDeviceInfo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/hat\/backend\/SpirvDeviceInfo.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/hat\/backend\/TestIt.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/hat\/backend\/TestIt.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","status":"renamed"},{"patch":"","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/UsmArena.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/UsmArena.java","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.SpirvBackend\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,72 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-hip<\/artifactId>\n-    <version>1.0<\/version>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                    <!--We want to inherit properties from parent but not plugin that calls cmake-->\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/hat-backend-hip-1.0.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/hip\/pom.xml","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -0,0 +1,66 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-java-mt<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-java<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-java-mt-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/java\/mt\/pom.xml","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+hat.backend.java.JavaMultiThreadedBackend\n+hat.backend.java.JavaSequentialBackend\n","filename":"hat\/backends\/java\/mt\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>pom<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backends-java<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <modules>\n+        <module>mt<\/module>\n+        <module>seq<\/module>\n+    <\/modules>\n+<\/project>\n","filename":"hat\/backends\/java\/pom.xml","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+--><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n+    <!--Auto generated by mkpoms-->\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <packaging>jar<\/packaging>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-java-seq<\/artifactId>\n+    <version>1.0<\/version>\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <artifactId>hat-backends-java<\/artifactId>\n+        <version>1.0<\/version>\n+    <\/parent>\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <artifactId>hat<\/artifactId>\n+            <version>1.0<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-java-seq-1.0.jar\" toDir=\"${hat.build}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"hat\/backends\/java\/seq\/pom.xml","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/java\/seq\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,473 @@\n+package nbody;\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import opencl.opencl_h;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/\/import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opencl.opencl_h.CL_DEVICE_TYPE_ALL;\n+import static opencl.opencl_h.CL_MEM_READ_WRITE;\n+import static opencl.opencl_h.CL_MEM_USE_HOST_PTR;\n+import static opencl.opencl_h.CL_QUEUE_PROFILING_ENABLE;\n+\n+public class CLWrap {\n+    public static MemorySegment NULL = MemorySegment.NULL;\n+\n+    \/\/ https:\/\/streamhpc.com\/blog\/2013-04-28\/opencl-error-codes\/\n+    static class Platform {\n+        static class Device {\n+            final Platform platform;\n+            final MemorySegment deviceId;\n+\n+            int intDeviceInfo(int query) {\n+                var value = 0;\n+                if ((opencl_h.clGetDeviceInfo(deviceId, query, opencl_h.C_INT.byteSize(), platform.intValuePtr, NULL)) != opencl_h.CL_SUCCESS()) {\n+                    System.out.println(\"Failed to get query \" + query);\n+                } else {\n+                    value = platform.intValuePtr.get(opencl_h.C_INT, 0);\n+                }\n+                return value;\n+            }\n+\n+            String strDeviceInfo(int query) {\n+                String value = null;\n+                if ((opencl_h.clGetDeviceInfo(deviceId, query, 2048, platform.byte2048ValuePtr, platform.intValuePtr)) != opencl_h.CL_SUCCESS()) {\n+                    System.out.println(\"Failed to get query \" + query);\n+                } else {\n+                    int len = platform.intValuePtr.get(opencl_h.C_INT, 0);\n+                    byte[] bytes = platform.byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n+                    value = new String(bytes).substring(0, len - 1);\n+                }\n+                return value;\n+            }\n+\n+            int computeUnits() {\n+                return intDeviceInfo(opencl_h.CL_DEVICE_MAX_COMPUTE_UNITS());\n+            }\n+\n+            String deviceName() {\n+                return strDeviceInfo(opencl_h.CL_DEVICE_NAME());\n+            }\n+\n+            String builtInKernels() {\n+                return strDeviceInfo(opencl_h.CL_DEVICE_BUILT_IN_KERNELS());\n+            }\n+\n+            Device(Platform platform, MemorySegment deviceId) {\n+                this.platform = platform;\n+                this.deviceId = deviceId;\n+            }\n+\n+            public static class Context {\n+                Device device;\n+                MemorySegment context;\n+                MemorySegment queue;\n+\n+                Context(Device device, MemorySegment context) {\n+                    this.device = device;\n+                    this.context = context;\n+                    var statusPtr = device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, 1);\n+\n+                    var queue_props = CL_QUEUE_PROFILING_ENABLE();\n+                    if ((this.queue = opencl_h.clCreateCommandQueue(context, device.deviceId, queue_props, statusPtr)) == NULL) {\n+                        int status = statusPtr.get(opencl_h.C_INT, 0);\n+                        opencl_h.clReleaseContext(context);\n+                        \/\/ delete[] platforms;\n+                        \/\/ delete[] device_ids;\n+                        return;\n+                    }\n+\n+                }\n+\n+                static public class Program {\n+                    Context context;\n+                    String source;\n+                    MemorySegment program;\n+                    String log;\n+\n+                    Program(Context context, String source) {\n+                        this.context = context;\n+                        this.source = source;\n+                        MemorySegment sourcePtr = context.device.platform.openCL.arena.allocateFrom(source);\n+                        var sourcePtrPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, sourcePtr);\n+                    \/\/    sourcePtrPtr.set(opencl_h.C_POINTER, 0, sourcePtr);\n+                        var sourceLenPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_LONG,  source.length());\n+                    \/\/    sourceLenPtr.set(opencl_h.C_LONG, 0, source.length());\n+                        var statusPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n+                        if ((program = opencl_h.clCreateProgramWithSource(context.context, 1, sourcePtrPtr, sourceLenPtr, statusPtr)) == NULL) {\n+                            int status = statusPtr.get(opencl_h.C_INT, 0);\n+                            if (status != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"failed to createProgram \" + status);\n+                            }\n+                            System.out.println(\"failed to createProgram\");\n+                        } else {\n+                            int status = statusPtr.get(opencl_h.C_INT, 0);\n+                            if (status != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"failed to create program \" + status);\n+                            }\n+                            var deviceIdPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, context.device.deviceId);\n+                          \/\/  deviceIdPtr.set(opencl_h.C_POINTER, 0, context.device.deviceId);\n+                            if ((status = opencl_h.clBuildProgram(program, 1, deviceIdPtr, NULL, NULL, NULL)) != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"failed to build\" + status);\n+                                \/\/ dont return we may still be able to get log!\n+                            }\n+\n+                            var logLenPtr = context.device.platform.openCL.arena.allocate(opencl_h.C_LONG, 1);\n+\n+                            if ((status = opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), 0, NULL, logLenPtr)) != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"failed to get log build \" + status);\n+                            } else {\n+                                long logLen = logLenPtr.get(opencl_h.C_LONG, 0);\n+                                var logPtr = context.device.platform.openCL.arena.allocate(opencl_h.C_CHAR, 1 + logLen);\n+                                if ((status = opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), logLen, logPtr, logLenPtr)) != opencl_h.CL_SUCCESS()) {\n+                                    System.out.println(\"clGetBuildInfo (getting log) failed\");\n+                                } else {\n+                                    byte[] bytes = logPtr.toArray(ValueLayout.JAVA_BYTE);\n+                                    log = new String(bytes).substring(0, (int) logLen);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    public static class Kernel {\n+                        Program program;\n+                        MemorySegment kernel;\n+                        String kernelName;\n+\n+                        public Kernel(Program program, String kernelName) {\n+                            this.program = program;\n+                            this.kernelName = kernelName;\n+                            var statusPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, opencl_h.CL_SUCCESS());\n+                            MemorySegment kernelNamePtr = program.context.device.platform.openCL.arena.allocateFrom(kernelName);\n+                            kernel = opencl_h.clCreateKernel(program.program, kernelNamePtr, statusPtr);\n+                            int status = statusPtr.get(opencl_h.C_INT, 0);\n+                            if (status != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"failed to create kernel \" + status);\n+                            }\n+                        }\n+\n+                        public void run(int range, Object... args) {\n+                            var bufPtr = program.context.device.platform.openCL.arena.allocate(opencl_h.cl_mem, args.length);\n+                            var statusPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, opencl_h.CL_SUCCESS());\n+                            int status;\n+                            var eventMax = args.length * 4 + 1;\n+                            int eventc = 0;\n+                            var eventsPtr = program.context.device.platform.openCL.arena.allocate(opencl_h.cl_event, eventMax);\n+                            boolean block = false;\/\/ true;\n+                            for (int i = 0; i < args.length; i++) {\n+                                if (args[i] instanceof MemorySegment memorySegment) {\n+                                    MemorySegment clMem = opencl_h.clCreateBuffer(program.context.context,\n+                                            CL_MEM_USE_HOST_PTR() | CL_MEM_READ_WRITE(),\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            statusPtr);\n+                                    status = statusPtr.get(opencl_h.C_INT, 0);\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n+                                        System.out.println(\"failed to create memory buffer \" + status);\n+                                    }\n+                                    bufPtr.set(opencl_h.cl_mem, i * opencl_h.cl_mem.byteSize(), clMem);\n+                                    status = opencl_h.clEnqueueWriteBuffer(program.context.queue,\n+                                            clMem,\n+                                            block ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE(), \/\/block?\n+                                            0,\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            block ? 0 : eventc,\n+                                            block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n+                                            block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event)\n+                                    );\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n+                                        System.out.println(\"failed to enqueue write \" + status);\n+                                    }\n+                                    if (!block) {\n+                                        eventc++;\n+                                    }\n+                                    var clMemPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, clMem);\n+\n+                                    status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_POINTER.byteSize(), clMemPtr);\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n+                                        System.out.println(\"failed to set arg \" + status);\n+                                    }\n+                                } else {\n+                                    bufPtr.set(opencl_h.cl_mem, i * opencl_h.cl_mem.byteSize(), NULL);\n+                                    switch (args[i]){\n+                                        case Integer intArg->{\n+                                            var intPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, intArg);\n+                                            status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_INT.byteSize(), intPtr);\n+                                            if (status != opencl_h.CL_SUCCESS()) {\n+                                                System.out.println(\"failed to set arg \" + status);\n+                                            }\n+                                        }\n+                                        case Float floatArg->{\n+                                            var floatPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_FLOAT, floatArg);\n+                                            status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_FLOAT.byteSize(), floatPtr);\n+                                            if (status != opencl_h.CL_SUCCESS()) {\n+                                                System.out.println(\"failed to set arg \" + status);\n+                                            }\n+                                        }\n+                                        default -> throw new IllegalStateException(\"Unexpected value: \" + args[i]);\n+                                    }\n+                                }\n+                            }\n+\n+                            \/\/ We need to store x,y,z sizes so this is a kind of int3\n+                            var globalSizePtr = program.context.device.platform.openCL.arena.allocate(opencl_h.C_INT, 3);\n+                            globalSizePtr.set(opencl_h.C_INT, 0, range);\n+                            globalSizePtr.set(opencl_h.C_INT, 1*opencl_h.C_INT.byteSize(), 0);\n+                            globalSizePtr.set(opencl_h.C_INT, 2*opencl_h.C_INT.byteSize(), 0);\n+                            status = opencl_h.clEnqueueNDRangeKernel(\n+                                    program.context.queue,\n+                                    kernel,\n+                                    1, \/\/ this must match the # of dims we are using in this case 1 of 3\n+                                    NULL,\n+                                    globalSizePtr,\n+                                    NULL,\n+                                    block ? 0 : eventc,\n+                                    block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n+                                    block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event\n+                                    )\n+                            );\n+                            if (status != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"failed to enqueue NDRange \" + status);\n+                            }\n+\n+                            if (block) {\n+                                opencl_h.clFlush(program.context.queue);\n+                            } else {\n+                                eventc++;\n+                                status = opencl_h.clWaitForEvents(eventc, eventsPtr);\n+                                if (status != opencl_h.CL_SUCCESS()) {\n+                                    System.out.println(\"failed to wait for ndrange events \" + status);\n+                                }\n+                            }\n+\n+                            for (int i = 0; i < args.length; i++) {\n+                                if (args[i] instanceof MemorySegment memorySegment) {\n+                                    MemorySegment clMem = bufPtr.get(opencl_h.cl_mem, (long) i * opencl_h.cl_mem.byteSize());\n+                                    status = opencl_h.clEnqueueReadBuffer(program.context.queue,\n+                                            clMem,\n+                                            block ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE(),\n+                                            0,\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            block ? 0 : eventc,\n+                                            block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n+                                            block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event)\/\/ block?NULL:readEventPtr\n+                                    );\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n+                                        System.out.println(\"failed to enqueue read \" + status);\n+                                    }\n+                                    if (!block) {\n+                                        eventc++;\n+                                    }\n+                                }\n+                            }\n+                            if (!block) {\n+                                status = opencl_h.clWaitForEvents(eventc, eventsPtr);\n+                                if (status != opencl_h.CL_SUCCESS()) {\n+                                    System.out.println(\"failed to wait for events \" + status);\n+                                }\n+                            }\n+                            for (int i = 0; i < args.length; i++) {\n+                                if (args[i] instanceof MemorySegment memorySegment) {\n+                                    MemorySegment clMem = bufPtr.get(opencl_h.cl_mem, (long) i * opencl_h.cl_mem.byteSize());\n+                                    status = opencl_h.clReleaseMemObject(clMem);\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n+                                        System.out.println(\"failed to release memObject \" + status);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    public Kernel getKernel(String kernelName) {\n+                        return new Kernel(this, kernelName);\n+                    }\n+                }\n+\n+                public Program buildProgram(String source) {\n+                    var program = new Program(this, source);\n+                    return program;\n+                }\n+            }\n+\n+            public Context createContext() {\n+\n+                var statusPtr = platform.openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n+                MemorySegment context;\n+                var deviceIds = platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, this.deviceId);\n+                if ((context = opencl_h.clCreateContext(NULL, 1, deviceIds, NULL, NULL, statusPtr)) == NULL) {\n+                    int status = statusPtr.get(opencl_h.C_INT, 0);\n+                    System.out.println(\"Failed to get context  \");\n+                    return null;\n+                } else {\n+                    int status = statusPtr.get(opencl_h.C_INT, 0);\n+                    if (status != opencl_h.CL_SUCCESS()) {\n+                        System.out.println(\"failed to get context  \" + status);\n+                    }\n+                    return new Context(this, context);\n+                }\n+            }\n+        }\n+\n+        int intPlatformInfo(int query) {\n+            var value = 0;\n+            if ((opencl_h.clGetPlatformInfo(platformId, query, opencl_h.C_INT.byteSize(), intValuePtr, NULL)) != opencl_h.CL_SUCCESS()) {\n+                System.out.println(\"Failed to get query \" + query);\n+            } else {\n+                value = intValuePtr.get(opencl_h.C_INT, 0);\n+            }\n+            return value;\n+        }\n+\n+        String strPlatformInfo(int query) {\n+            String value = null;\n+            int status;\n+            if ((status = opencl_h.clGetPlatformInfo(platformId, query, 2048, byte2048ValuePtr, intValuePtr)) != opencl_h.CL_SUCCESS()) {\n+                System.err.println(\"Failed to get query \" + query);\n+            } else {\n+                int len = intValuePtr.get(opencl_h.C_INT, 0);\n+                byte[] bytes = byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n+                value = new String(bytes).substring(0, len - 1);\n+            }\n+            return value;\n+        }\n+\n+        CLWrap openCL;\n+        MemorySegment platformId;\n+        List<Device> devices = new ArrayList<>();\n+        final MemorySegment intValuePtr;\n+        final MemorySegment byte2048ValuePtr;\n+\n+        String platformName() {\n+            return strPlatformInfo(opencl_h.CL_PLATFORM_NAME());\n+        }\n+\n+        String vendorName() {\n+            return strPlatformInfo(opencl_h.CL_PLATFORM_VENDOR());\n+        }\n+\n+        String version() {\n+            return strPlatformInfo(opencl_h.CL_PLATFORM_VERSION());\n+        }\n+\n+        public Platform(CLWrap openCL, MemorySegment platformId) {\n+            this.openCL = openCL;\n+            this.platformId = platformId;\n+            this.intValuePtr = openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n+            this.byte2048ValuePtr = openCL.arena.allocate(opencl_h.C_CHAR, 2048);\n+            var devicecPtr = openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n+            int status;\n+            if ((status = opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicecPtr)) != opencl_h.CL_SUCCESS()) {\n+                System.err.println(\"Failed getting devicec for platform 0 \");\n+            } else {\n+                int devicec = devicecPtr.get(opencl_h.C_INT, 0);\n+                \/\/  System.out.println(\"platform 0 has \" + devicec + \" device\" + ((devicec > 1) ? \"s\" : \"\"));\n+                var deviceIdsPtr = openCL.arena.allocate(opencl_h.C_POINTER, devicec);\n+                if ((status = opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec, deviceIdsPtr, devicecPtr)) != opencl_h.CL_SUCCESS()) {\n+                    System.err.println(\"Failed getting deviceids  for platform 0 \");\n+                } else {\n+                    \/\/ System.out.println(\"We have \"+devicec+\" device ids\");\n+                    for (int i = 0; i < devicec; i++) {\n+                        devices.add(new Device(this, deviceIdsPtr.get(opencl_h.C_POINTER, i * opencl_h.C_POINTER.byteSize())));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    List<Platform> platforms = new ArrayList<>();\n+\n+    Arena arena;\n+\n+    CLWrap(Arena arena) {\n+        this.arena = arena;\n+        var platformcPtr = arena.allocateFrom(opencl_h.C_INT, 0);\n+\n+        if ((opencl_h.clGetPlatformIDs(0, NULL, platformcPtr)) != opencl_h.CL_SUCCESS()) {\n+            System.out.println(\"Failed to get opencl platforms\");\n+        } else {\n+            int platformc = platformcPtr.get(opencl_h.C_INT, 0);\n+            \/\/ System.out.println(\"There are \"+platformc+\" platforms\");\n+            var platformIdsPtr = arena.allocate(opencl_h.C_POINTER, platformc);\n+            if ((opencl_h.clGetPlatformIDs(platformc, platformIdsPtr, platformcPtr)) != opencl_h.CL_SUCCESS()) {\n+                System.out.println(\"Failed getting platform ids\");\n+            } else {\n+                for (int i = 0; i < platformc; i++) {\n+                    \/\/ System.out.println(\"We should have the ids\");\n+                    platforms.add(new Platform(this, platformIdsPtr.get(opencl_h.C_POINTER, i)));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws IOException {\n+        try (var arena = Arena.ofConfined()) {\n+            CLWrap openCL = new CLWrap(arena);\n+\n+            Platform.Device[] selectedDevice = new Platform.Device[1];\n+            openCL.platforms.forEach(platform -> {\n+                System.out.println(\"Platform Name \" + platform.platformName());\n+                platform.devices.forEach(device -> {\n+                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                    System.out.println(\"   Device Name       \" + device.deviceName());\n+                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+                    selectedDevice[0] = device;\n+                });\n+            });\n+            var context = selectedDevice[0].createContext();\n+            var program = context.buildProgram(\"\"\"\n+                    __kernel void squares(__global int* in,__global int* out ){\n+                        int gid = get_global_id(0);\n+                        out[gid] = in[gid]*in[gid];\n+                    }\n+                    \"\"\");\n+            var kernel = program.getKernel(\"squares\");\n+            var in = arena.allocate(opencl_h.C_INT, 512);\n+            var out = arena.allocate(opencl_h.C_INT, 512);\n+            for (int i = 0; i < 512; i++) {\n+                in.set(opencl_h.C_INT, (int) i * opencl_h.C_INT.byteSize(), i);\n+            }\n+            kernel.run(512, in, out);\n+            for (int i = 0; i < 512; i++) {\n+                System.out.println(i + \" \" + out.get(opencl_h.C_INT, (int) i * opencl_h.C_INT.byteSize()));\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/CLWrap.java","additions":473,"deletions":0,"binary":false,"changes":473,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.jextracted;\n+\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.NDRange;\n+import hat.backend.ffi.C99FFIBackend;\n+import hat.buffer.BackendConfig;\n+import hat.callgraph.KernelCallGraph;\n+import hat.ifacemapper.Schema;\n+\n+public class OpenCLBackend extends C99FFIBackend {\n+\n+    interface OpenCLConfig extends BackendConfig {\n+        boolean gpu();\n+\n+        void gpu(boolean gpu);\n+\n+        Schema<OpenCLConfig> schema = Schema.of(OpenCLConfig.class, s->s.fields(\"gpu\"));\n+\n+        static OpenCLConfig create(Accelerator accelerator, boolean gpu, boolean verbose) {\n+            OpenCLConfig config =schema.allocate(accelerator);\n+            config.gpu(gpu);\n+            return config;\n+        }\n+    }\n+\n+    public OpenCLBackend() {\n+        super(\"opencl_backend\");\n+        getBackend(null);\/\/OpenCLConfig.create( MethodHandles.lookup(),this, true, true));\n+        info();\n+    }\n+\n+\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n+        \/\/System.out.println(\"OpenCL backend received computeContext\");\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+        \/\/System.out.println(\"OpenCL backend dispatching kernel \" + kernelCallGraph.entrypoint.method);\n+        CompiledKernel compiledKernel = kernelCallGraphCompiledCodeMap.computeIfAbsent(kernelCallGraph, (_) -> {\n+            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args);\n+            System.out.println(code);\n+            long programHandle = compileProgram(code);\n+            if (programOK(programHandle)) {\n+                long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n+                return new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+            } else {\n+                throw new IllegalStateException(\"opencl failed to compile \");\n+            }\n+        });\n+        compiledKernel.dispatch(ndRange,args);\n+\n+    }\n+}\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.jextracted;\n@@ -30,1 +30,0 @@\n-\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"hat\/backends\/opencl\/src\/main\/java\/hat\/backend\/OpenCLHatKernelBuilder.java","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.jextracted.OpenCLBackend\n+hat.backend.java.JavaSequentialBackend\n+hat.backend.java.JavaMultiThreadedBackend\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"hat\/backends\/jextracted\/shared\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/bldr\/.gitignore","status":"copied"},{"patch":"@@ -1,74 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-      accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-mock<\/artifactId>\n-    <version>1.0<\/version>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/hat-backend-mock-1.0.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/mock\/pom.xml","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-hat.backend.MockBackend\n-hat.backend.JavaSequentialBackend\n-hat.backend.JavaMultiThreadedBackend\n","filename":"hat\/backends\/mock\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-      accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-opencl<\/artifactId>\n-    <version>1.0<\/version>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/hat-backend-opencl-1.0.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/opencl\/pom.xml","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-hat.backend.OpenCLBackend\n-hat.backend.JavaSequentialBackend\n-hat.backend.JavaMultiThreadedBackend\n","filename":"hat\/backends\/opencl\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n@@ -44,4 +44,2 @@\n-        <module>ptx<\/module>\n-        <module>cuda<\/module>\n-        <module>mock<\/module>\n-        <module>opencl<\/module>\n+        <module>java<\/module>\n+        <module>ffi<\/module>\n@@ -49,40 +47,0 @@\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>compile<\/phase>\n-                        <goals>\n-                            <goal>exec<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <executable>cmake<\/executable>\n-                            <arguments>\n-                                <argument>-DHAT_TARGET=${hat.build}<\/argument>\n-                                <argument>-B<\/argument>\n-                                <argument>${hat.build}\/cmake-build-debug<\/argument>\n-                            <\/arguments>\n-                        <\/configuration>\n-                    <\/execution>\n-                    <execution>\n-                        <id>2<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>exec<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <executable>cmake<\/executable>\n-                            <arguments>\n-                                <argument>--build<\/argument>\n-                                <argument>${hat.build}\/cmake-build-debug<\/argument>\n-                            <\/arguments>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n","filename":"hat\/backends\/pom.xml","additions":7,"deletions":49,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1,74 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-      accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-ptx<\/artifactId>\n-    <version>1.0<\/version>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/hat-backend-ptx-1.0.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/ptx\/pom.xml","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-hat.backend.PTXBackend\n-hat.backend.JavaSequentialBackend\n-hat.backend.JavaMultiThreadedBackend\n","filename":"hat\/backends\/ptx\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package unused;\n-\n-public class Unused {\n-}\n","filename":"hat\/backends\/shared\/src\/main\/java\/unused\/Unused.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-hat.backend.JavaMultiThreadedBackend\n-hat.backend.JavaSequentialBackend\n","filename":"hat\/backends\/shared\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-backends<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-backend-spirv<\/artifactId>\n-    <version>1.0<\/version>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.codehaus.mojo<\/groupId>\n-                <artifactId>exec-maven-plugin<\/artifactId>\n-                <configuration>\n-                    <skip>true<\/skip>\n-                    <!--We want to inherit properties from parent but not plugin that calls cmake-->\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/hat-backend-spirv-1.0.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/backends\/spirv\/pom.xml","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-hat.backend.SpirvBackend\n-hat.backend.JavaSequentialBackend\n-hat.backend.JavaMultiThreadedBackend\n","filename":"hat\/backends\/spirv\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import bldr.CMakeProbe;\n-import bldr.Capabilities;\n@@ -54,6 +52,12 @@\n-     *    |    +--opencl                (*)\n-     *    |    +--ptx                   (*)\n-     *    |    +--mock                  (*)\n-     *    |    +--spirv                 (*)\n-     *    |    +--cuda                  (*)\n-     *    |    +--hip                   (*)\n+     *    |    +--java\n+     *    |    |    +--mt                    (*)\n+     *    |    |    +--seq                   (*)\n+     *    |    +--jextracted\n+     *    |    |    +--opencl                (*)\n+     *    |    +--ffi\n+     *    |    |    +--opencl                (*)\n+     *    |    |    +--ptx                   (*)\n+     *    |    |    +--mock                  (*)\n+     *    |    |    +--spirv                 (*)\n+     *    |    |    +--cuda                  (*)\n+     *    |    |    +--hip                   (*)\n@@ -70,20 +74,29 @@\n-    var hatDir = Dir.current();\n-    var hatCoreDir = hatDir.existingDir(\"hat\");\n-    var backendsDir = hatDir.existingDir(\"backends\");\n-    var examplesDir = hatDir.existingDir(\"examples\");\n-    var stageDir = hatDir.buildDir(\"stage\").create();\n-    var repoDir = stageDir.repoDir(\"repo\").create();\n-    var jextractDir = stageDir.buildDir(\"jextract\").create();\n-    var buildDir = BuildDir.of(hatDir.path(\"build\")).create();\n-    var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n-    var jextract = Jextract.of(fromPATH(\"jextract\").orElseThrow(()-> new RuntimeException(\"Can't locate jextract\")));\n-    var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n-    var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n-    var verbose = false;\n-\n-    var opencl = Capabilities.OpenCL.of();\n-    var opengl = Capabilities.OpenGL.of();\n-    var cuda = Capabilities.CUDA.of();\n-    var hip = Capabilities.HIP.of();\n-    var capabilities= Capabilities.of(opencl, opengl, cuda, hip);\n-    var cmakeProbe = new CMakeProbe(buildDir, capabilities);\n+    var hatDir = DirEntry.current();\n+  var hatCoreDir = hatDir.existingDir(\"hat\");\n+  var backends = hatDir.existingDir(\"backends\");\n+  var examples = hatDir.existingDir(\"examples\");\n+  var stageDir = hatDir.buildDir(\"stage\").create();\n+  var jextractDir = stageDir.buildDir(\"jextract\").create();\n+  var buildDir = BuildDir.of(hatDir.path(\"build\")).create();\n+  var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n+\n+  var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n+  var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n+\n+  var opencl = Capabilities.OpenCL.of();\n+  var opengl = Capabilities.OpenGL.of();\n+  var cuda = Capabilities.CUDA.of();\n+  var hip = Capabilities.HIP.of();\n+  var jextract = Capabilities.JExtract.of();\n+  var cmake = Capabilities.CMake.of();\n+\n+  Capabilities capabilities = Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n+\n+  if (cmake.available()) {\n+    cmake.probe(buildDir, capabilities);\n+  }\n+  capabilities.capabilities().forEach(fw -> println((fw.available() ? \"we have \" : \"no \") + fw.name));\n+  var verbose = false;\n+\n+\n+  if (jextract.available()) {\n@@ -91,21 +104,19 @@\n-        if (extractedOpenCLJar.exists()) {\n-            println(\"We've already extracted and jarred\" + extractedOpenCLJar.path());\n-        } else {\n-            var openclSource = jextractDir.sourceDir(\"opencl\");\n-            if (!openclSource.exists()) {\n-                jextract.extract($ -> {\n-                            $.output(jextractDir).target_package(openclSource.fileName());\n-                            switch (os) {\n-                                case OS.Mac mac -> $\n-                                        .compile_flag(\"-F\" + mac.appLibFrameworks())\n-                                        .library(mac.frameworkLibrary(\"OpenCL\"))\n-                                        .header(mac.frameworkHeader(\"OpenCL\", \"opencl.h\"));\n-                                case OS.Linux linux -> {\n-                                }\n-                                default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n-                            }\n-                        }\n-                );\n-\n-            } else{\n-                 println(\"We've already extracted \" + extractedOpenCLJar.path());\n+      if (!extractedOpenCLJar.exists()) {\n+        var openclSource = jextractDir.sourceDir(\"opencl\");\n+        if (!openclSource.exists()) {\n+          jextract(jextract.executable, $ -> {\n+            $\n+              .verbose(verbose)\n+              .output(jextractDir)\n+              .target_package(openclSource.fileName());\n+            switch (os) {\n+              case OS.Mac mac -> {\n+                $\n+                  .compile_flag(\"-F\" + opencl.appLibFrameworks() + \"\/System\/library\/Frameworks\")\n+                  .library(mac.frameworkLibrary(\"OpenCL\"))\n+                  \/\/.library(Path.of(opencl.lib()))\n+                  .header(Path.of(opencl.includeDir()).resolve(\"Headers\/opencl.h\"));\n+              }\n+              case OS.Linux linux -> {\n+              }\n+              default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n@@ -113,1 +124,1 @@\n-            extractedOpenCLJar.create($ -> $.javac($$ -> $$.source(24).source_path(openclSource)));\n+          });\n@@ -115,0 +126,7 @@\n+        jar(jar -> {\n+              jar\n+                .jar(extractedOpenCLJar)\n+                .javac(javac -> javac.source(24).source_path(openclSource));\n+            }\n+        );\n+      }\n@@ -116,1 +134,1 @@\n-        println(\"According to cmake probe this platform does not have OpenCL\");\n+      println(\"This platform does not have OpenCL\");\n@@ -120,20 +138,17 @@\n-        if (extractedOpenGLJar.exists()) {\n-            println(\"We've already extracted and jarred\" + extractedOpenGLJar.path());\n-        } else {\n-            var openglSource = jextractDir.sourceDir(\"opengl\");\n-            if (!openglSource.exists()) {\n-                jextract.extract($ -> {\n-                            $.output(jextractDir).target_package(openglSource.fileName());\n-                            switch (os) {\n-                                case OS.Mac mac -> $\n-                                        .compile_flag(\"-F\" + mac.appLibFrameworks())\n-                                        .library(mac.frameworkLibrary(\"GLUT\"), mac.frameworkLibrary(\"OpenGL\"))\n-                                        .header(mac.frameworkHeader(\"GLUT\", \"glut.h\"));\n-                                case OS.Linux linux -> {\n-                                }\n-                                default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n-                            }\n-                        }\n-                );\n-            }else{\n-                println(\"We've already extracted \" + extractedOpenGLJar.path());\n+      if (!extractedOpenGLJar.exists()) {\n+        var openglSource = jextractDir.sourceDir(\"opengl\");\n+        if (!openglSource.exists()) {\n+          jextract(jextract.executable, $ -> { $\n+              .verbose(verbose)\n+              .output(jextractDir)\n+              .target_package(openglSource.fileName());\n+            switch (os) {\n+              case OS.Mac mac -> { $\n+                  .compile_flag(\"-F\" + opengl.appLibFrameworks() + \"\/System\/library\/Frameworks\")\n+                  \/\/.library(opengl.lib(\"GLUT\"),opengl.lib(\"OpenGL\"))\n+                  .library(mac.frameworkLibrary(\"GLUT\"), mac.frameworkLibrary(\"OpenGL\"))\n+                  .header(mac.frameworkHeader(\"GLUT\", \"glut.h\"));\n+              }\n+              case OS.Linux linux -> {\n+              }\n+              default -> throw new RuntimeException(\"Unsupported OS: \" + os);\n@@ -141,1 +156,1 @@\n-            extractedOpenGLJar.create($ -> $.javac($$ -> $$.source(24).source_path(openglSource)));\n+          });\n@@ -143,0 +158,5 @@\n+        jar(jar -> jar\n+          .jar(extractedOpenGLJar)\n+          .javac(javac -> javac.source(24).source_path(openglSource))\n+        );\n+      }\n@@ -144,1 +164,1 @@\n-        println(\"According to cmake probe this platform does not have OpenGL\");\n+      println(\"This platform does not have OpenGL\");\n@@ -147,0 +167,1 @@\n+\n@@ -150,1 +171,1 @@\n-        println(\"According to cmake probe this platform does not have CUDA\");\n+      println(\"This platform does not have CUDA\");\n@@ -152,0 +173,14 @@\n+  }\n+  var hatJavacOpts = javacBuilder(javacBuilder -> {javacBuilder\n+    .enable_preview()\n+    .add_modules(\"jdk.incubator.code\")\n+    .add_exports(\n+       \"java.base\",\n+       List.of(\n+          \"jdk.internal\",\n+          \"jdk.internal.vm.annotation\"\n+       ),\n+       \"ALL-UNNAMED\"\n+    )\n+    .source(24);\n+  });\n@@ -153,4 +188,10 @@\n-    var hatOpts = JavaOpts.of()\n-            .enable_preview()\n-            .add_modules(\"jdk.incubator.code\")\n-            .add_exports(\"java.base\", List.of(\"jdk.internal\", \"jdk.internal.vm.annotation\"), \"ALL-UNNAMED\");\n+  var hatJarOptions = jarBuilder(jarBuilder -> jarBuilder\n+    .verbose(verbose)\n+  );\n+  var hatJarFile = buildDir.jarFile(\"hat-1.0.jar\");\n+  jar(jar -> jar\n+    .copy(hatJarOptions)\n+    .jar(hatJarFile)\n+    .maven_style_root(hatCoreDir)\n+    .javac(javac -> javac.copy(hatJavacOpts))\n+  );\n@@ -158,5 +199,0 @@\n-    var hatJar = buildDir.jarFile(\"hat-1.0.jar\", $ -> $\n-            .javac(javac -> javac.opts(hatOpts).source(24)\n-                    .source_path(hatCoreDir.sourceDir(\"src\/main\/java\"))\n-            )\n-    );\n@@ -164,30 +200,13 @@\n-    \/\/ Here we create all backend jars.\n-    backendsDir\n-            .subDirs(backendDir -> !backendDir.matches(\"^.*(spirv|hip|shared|target|.idea)$\"))\n-            .peek(backendDir->println(\"Building backend \" + backendDir.fileName()))\n-            .forEach(backendDir->\n-                 buildDir.jarFile(\"hat-backend-\" + backendDir.fileName() + \"-1.0.jar\",$->$.verbose(verbose)\n-                    .javac($$ -> $$.opts(hatOpts).verbose(verbose)\n-                        .source(24)\n-                        .class_path(hatJar)\n-                        .source_path(backendDir.sourceDir(\"src\/main\/java\"))\n-                    )\n-                   .whenExists(backendDir.dir(\"src\/main\/resources\"), (resources, _) -> $.dir_list(resources))\n-                )\n-            );\n-\n-   \/\/ here we create the example jars\n-    examplesDir\n-            .subDirs(exampleDir -> !exampleDir.matches(\"^.*(experiments|nbody|target|.idea)$\"))\n-            .peek(exampleDir -> println(\"Building example \" + exampleDir.fileName()))\n-            .forEach(exampleDir ->\n-                    buildDir.jarFile(\"hat-example-\" + exampleDir.fileName() + \"-1.0.jar\", $ -> $.verbose(verbose)\n-                            .javac($$ -> $$.opts(hatOpts).verbose(verbose)\n-                            .source(24)\n-                            .class_path(hatJar)\n-                            .source_path(exampleDir.sourceDir(\"src\/main\/java\"))\n-\n-                    )\n-                    .whenExists(exampleDir.dir(\"src\/main\/resources\"), (resources, _) -> $.dir_list(resources))\n-            )\n-    );\n+  \/\/ Here we create all backend jars.\n+  var ffiBackends = backends.existingDir(\"ffi\");\n+  ffiBackends\n+    .subDirs(backend -> !backend.matches(\"^.*(spirv|hip|shared|target|.idea)$\"))\n+    .forEach(backend -> {\n+      var jarFile = buildDir.jarFile(\"hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\");\n+      println(jarFile.fileName());\n+      jar(jar -> jar.copy(hatJarOptions)\n+        .jar(jarFile)\n+        .maven_style_root(backend)\n+        .javac(javac -> javac.copy(hatJavacOpts).class_path(hatJarFile))\n+      );\n+    });\n@@ -195,22 +214,31 @@\n-   \/\/ here we create the example jars which need opengl and opencl \n-    if (opencl.available() && opengl.available()) {\n-        examplesDir\n-            .subDirs(exampleDir -> exampleDir.matches(\"^.*(nbody)$\"))\n-            .peek(exampleDir -> println(\"Building opengl+opengcl example \" + exampleDir.fileName()))\n-            .forEach(exampleDir->\n-                buildDir.jarFile(\"hat-example-\" + exampleDir.fileName() + \"-1.0.jar\", $ -> $\n-                        .verbose(verbose)\n-                        .javac($$ -> $$\n-                                .verbose(verbose)\n-                                .opts(hatOpts)\n-                                .source(24)\n-                                .class_path(hatJar,extractedOpenCLJar, extractedOpenGLJar)\n-                                .source_path(exampleDir.sourceDir(\"src\/main\/java\"))\n-                        )\n-                        .dir_list(exampleDir.dir(\"src\/main\/resources\"))\n-                )\n-            );\n-\n-    }else{\n-       println(\"Skipping nbody example because we need opencl and opengl\");\n-    }\n+  \/\/ Here we create all java backend jars.\n+  var javaBackends = backends.existingDir(\"java\");\n+  javaBackends\n+    .subDirs(backend -> !backend.matches(\"^.*(target|.idea)$\"))\n+    .forEach(backend -> {\n+      var jarFile = buildDir.jarFile(\"hat-backend-java-\" + backend.fileName() + \"-1.0.jar\");\n+      println(jarFile.fileName());\n+      jar(jar -> jar\n+            .copy(hatJarOptions)\n+            .jar(jarFile)\n+            .dir_list(backend.dir(\"src\/main\/resources\"))\n+          \/\/.maven_style_root(backend)\n+      );\n+    });\n+\n+\n+  \/\/ here we create the example jars\n+  examples\n+    .subDirs(example -> !example.matches(\"^.*(experiments|nbody|target|.idea)$\"))\n+    .forEach(example -> {\n+      var jarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n+      println(jarFile.fileName());\n+      jar(jar -> jar.copy(hatJarOptions)\n+        .jar(jarFile)\n+        .maven_style_root(example)\n+        .javac(javac -> javac.copy(hatJavacOpts).class_path(hatJarFile))\n+        .manifest(manifest -> manifest\n+          .main_class(example.fileName() + \".Main\")\n+        )\n+      );\n+    });\n@@ -218,0 +246,10 @@\n+  if (jextract.available() && opencl.available() && opengl.available()) {\n+    var example = examples.dir(\"nbody\");\n+    var jarFile = buildDir.jarFile(\"hat-example-\" + example.fileName() + \"-1.0.jar\");\n+    println(jarFile.fileName());\n+    jar(jar -> jar.copy(hatJarOptions)\n+      .jar(jarFile)\n+      .maven_style_root(example)\n+      .javac(javac -> javac.copy(hatJavacOpts).class_path(hatJarFile, extractedOpenCLJar, extractedOpenGLJar))\n+    );\n+  }\n@@ -219,0 +257,1 @@\n+  if (cmake.available()) {\n@@ -220,5 +259,5 @@\n-        cmake($ -> $\n-                .source_dir(backendsDir)\n-                .build_dir(cmakeBuildDir)\n-                .copy_to(buildDir)\n-        );\n+      cmake($ -> $\n+        .source_dir(ffiBackends)\n+        .build_dir(cmakeBuildDir)\n+        .copy_to(buildDir)\n+      );\n@@ -226,1 +265,0 @@\n-\n@@ -228,1 +266,1 @@\n-            .build(cmakeBuildDir)\n+      .build(cmakeBuildDir)\n@@ -230,0 +268,5 @@\n+  } else {\n+    println(\"No cmake available so we did not build ffi backend shared libs\");\n+  }\n+\n+\n@@ -231,0 +274,1 @@\n+ \n","filename":"hat\/bld","additions":186,"deletions":142,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n@@ -33,0 +39,11 @@\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.BufferedReader;\n@@ -35,0 +52,2 @@\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n@@ -36,0 +55,4 @@\n+import java.io.StringWriter;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n@@ -37,0 +60,1 @@\n+import java.net.URLEncoder;\n@@ -44,0 +68,2 @@\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -45,0 +71,1 @@\n+import java.util.Map;\n@@ -50,0 +77,1 @@\n+import java.util.function.Function;\n@@ -62,1 +90,1 @@\n-    public sealed interface PathHolder permits ClassPathEntry, DirPathHolder, Executable, FilePathHolder {\n+    public sealed interface PathHolder permits ClassPathEntry, DirPathHolder,  FilePathHolder {\n@@ -64,1 +92,3 @@\n-\n+        default Path path(String subdir) {\n+            return path().resolve(subdir);\n+        }\n@@ -81,0 +111,4 @@\n+        default boolean exists(){\n+            return Files.exists(path());\n+        }\n+\n@@ -95,4 +129,1 @@\n-            permits BuildDirHolder, Dir, SourcePathEntry {\n-        default Path path(String subdir) {\n-            return path().resolve(subdir);\n-        }\n+            permits BuildDirHolder, DirEntry, SourcePathEntry {\n@@ -139,1 +170,1 @@\n-            return Files.exists(path()) && Files.isDirectory(path());\n+            return PathHolder.super.exists() && Files.isDirectory(path());\n@@ -153,1 +184,1 @@\n-            return Files.exists(path()) && Files.isRegularFile(path());\n+            return PathHolder.super.exists() && Files.isRegularFile(path());\n@@ -157,1 +188,1 @@\n-    public sealed interface Executable extends PathHolder {\n+    public sealed interface Executable extends FilePathHolder {\n@@ -394,3 +425,3 @@\n-    public record Dir(Path path) implements DirPathHolder<Dir> {\n-        public static Dir of(Path path) {\n-            return new Dir(path);\n+    public record DirEntry(Path path) implements DirPathHolder<DirEntry> {\n+        public static DirEntry of(Path path) {\n+            return new DirEntry(path);\n@@ -399,1 +430,1 @@\n-        public static Dir of(String string) {\n+        public static DirEntry of(String string) {\n@@ -403,1 +434,1 @@\n-        public static Dir ofExisting(String string) {\n+        public static DirEntry ofExisting(String string) {\n@@ -407,1 +438,1 @@\n-        public static Dir current() {\n+        public static DirEntry current() {\n@@ -411,1 +442,1 @@\n-        public Dir parent() {\n+        public DirEntry parent() {\n@@ -415,2 +446,5 @@\n-        public Dir dir(String subdir) {\n-            return Dir.of(path(subdir));\n+        public DirEntry dir(String subdir) {\n+            return DirEntry.of(path(subdir));\n+        }\n+        public FileEntry file(String fileName) {\n+            return FileEntry.of(path(fileName));\n@@ -419,2 +453,2 @@\n-        public Dir existingDir(String subdir) {\n-            return assertExists(Dir.of(path(subdir)));\n+        public DirEntry existingDir(String subdir) {\n+            return assertExists(DirEntry.of(path(subdir)));\n@@ -423,1 +457,1 @@\n-        public Stream<Dir> subDirs() {\n+        public Stream<DirEntry> subDirs() {\n@@ -425,1 +459,1 @@\n-                    .map(d -> Dir.of(d.getPath()));\n+                    .map(d -> DirEntry.of(d.getPath()));\n@@ -428,1 +462,1 @@\n-        public Stream<Dir> subDirs(Predicate<Dir> predicate) {\n+        public Stream<DirEntry> subDirs(Predicate<DirEntry> predicate) {\n@@ -432,7 +466,0 @@\n-        public Dir forEachSubDir(Predicate<Dir> predicate, Consumer<Dir> consumer) {\n-            subDirs().filter(predicate).forEach(consumer);\n-            return this;\n-        }\n-\n-\n-\n@@ -485,10 +512,0 @@\n-        public JarFile jarFile(String name, BiConsumer<JarBuilder, JarFile> biConsumer) {\n-            var result = JarFile.of(path().resolve(name));\n-            return result.create(biConsumer).jarFile;\n-        }\n-\n-        public JarFile jarFile(String name, Consumer<JarBuilder> consumer) {\n-            var result = JarFile.of(path().resolve(name));\n-            return result.create(consumer).jarFile;\n-        }\n-\n@@ -549,0 +566,11 @@\n+        public SearchableTextFile textFile(String file, Consumer<StringBuilder> stringBuilderConsumer) {\n+            SearchableTextFile textFile = SearchableTextFile.of(path().resolve(file));\n+            var sb = new StringBuilder();\n+            stringBuilderConsumer.accept(sb);\n+            try {\n+                Files.writeString(textFile.path, sb.toString());\n+                return textFile;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n@@ -564,10 +592,3 @@\n-    public record JarFile(Path path) implements ClassPathEntry, FilePathHolder {\n-        public static JarFile of(Path path) {\n-            return new JarFile(path);\n-        }\n-\n-        public JarResult create(BiConsumer<JarBuilder, JarFile> jarBuilderConsumer) {\n-            JarBuilder jarBuilder = new JarBuilder();\n-            jarBuilder.jar(this);\n-            jarBuilderConsumer.accept(jarBuilder, this);\n-            return jar(jarBuilder);\n+    public record FileEntry(Path path) implements FilePathHolder{\n+        public static FileEntry of(Path path) {\n+            return new FileEntry(path);\n@@ -575,0 +596,1 @@\n+    }\n@@ -576,5 +598,3 @@\n-        public JarResult create(Consumer<JarBuilder> jarBuilderConsumer) {\n-            JarBuilder jarBuilder = new JarBuilder();\n-            jarBuilder.jar(this);\n-            jarBuilderConsumer.accept(jarBuilder);\n-            return jar(jarBuilder);\n+    public record JarFile(Path path) implements ClassPathEntry,FilePathHolder {\n+        public static JarFile of(Path path) {\n+            return new JarFile(path);\n@@ -647,7 +667,3 @@\n-    public record Jextract(Path path) implements Executable {\n-        public static Jextract of(Path path) {\n-            return new Jextract(path);\n-        }\n-\n-        public void extract(Consumer<JExtractBuilder> jextractBuilderConsumer) {\n-            jextract(this, jextractBuilderConsumer);\n+    public record JExtractExecutable(Path path) implements Executable {\n+        public static JExtractExecutable of(Path path) {\n+            return new JExtractExecutable(path);\n@@ -752,1 +768,1 @@\n-    public record Java(String version, Dir home) {\n+    public record Java(String version, DirEntry home) {\n@@ -756,1 +772,1 @@\n-            new Java(System.getProperty(\"java.version\"), Dir.of(System.getProperty(\"java.home\")));\n+            new Java(System.getProperty(\"java.version\"), DirEntry.of(System.getProperty(\"java.home\")));\n@@ -758,1 +774,1 @@\n-    public record User(Dir home, Dir pwd) {\n+    public record User(DirEntry home, DirEntry pwd) {\n@@ -762,1 +778,1 @@\n-            new User(Dir.of(System.getProperty(\"user.home\")), Dir.of(System.getProperty(\"user.dir\")));\n+            new User(DirEntry.of(System.getProperty(\"user.home\")), DirEntry.of(System.getProperty(\"user.dir\")));\n@@ -764,1 +780,0 @@\n-    public abstract static class Result{\n@@ -766,2 +781,4 @@\n-    }\n-    public abstract static class Builder<T extends Builder<T>> {\n+    public abstract sealed static class Builder<T extends Builder<T>> permits CMakeBuilder, FormatBuilder, JExtractBuilder, JarBuilder, JarBuilder.ManifestBuilder, JavaOpts, TestNGBuilder {\n+        public Builder<?> parent;\n+        public boolean verbose;\n+        public boolean quiet;\n@@ -773,1 +790,9 @@\n-        public boolean verbose;\n+        public T copy(T other){\n+            this.verbose = other.verbose;\n+            this.quiet = other.quiet;\n+            return self();\n+        }\n+        public T quiet(boolean quiet) {\n+            this.quiet = quiet;\n+            return self();\n+        }\n@@ -775,0 +800,4 @@\n+        public T quiet() {\n+            quiet(true);\n+            return self();\n+        }\n@@ -814,0 +843,15 @@\n+\n+        Builder(Builder<?> parent){\n+            this.parent = parent;\n+        }\n+        Builder(){\n+            this(null);\n+        }\n+    }\n+\n+    public abstract static sealed class Result<T extends Builder<T>> permits JExtractResult, JarResult, JavaResult, JavacResult {\n+        public boolean ok;\n+        public T builder;\n+        Result(T builder){\n+            this.builder = builder;\n+        }\n@@ -854,7 +898,0 @@\n-    public abstract static class OptsBuilder<T extends OptsBuilder<T>> extends Builder<T> {\n-        public Strings opts = new Strings();\n-        public T opts(OptsBuilder<?> optsBuilder) {\n-            opts.add(optsBuilder.opts);\n-            return self();\n-        }\n-    }\n@@ -862,2 +899,21 @@\n-    public static class JavaOpts<T extends JavaOpts<T>> extends OptsBuilder<T> {\n-        public Dir jdk = java.home;\n+    public static sealed  class JavaOpts<T extends JavaOpts<T>> extends Builder<T> {\n+        public DirEntry jdk = java.home;\n+        public Boolean enablePreview;\n+        public Strings modules ;\n+        record FromModulePackageToModule(String fromModule, String pkg, String toModule){}\n+        List<FromModulePackageToModule> exports;\n+\n+        public T copy(T other){\n+            super.copy(other);\n+            if (other.jdk != null) {\n+                this.jdk = other.jdk;\n+            }\n+            if (other.enablePreview != null) {\n+                this.enablePreview=other.enablePreview;\n+            }\n+            if (other.modules != null) {\n+               this.modules = new Strings(other.modules);\n+            }\n+            if (other.exports != null) {\n+                this.exports = new ArrayList<>(other.exports);\n+            }\n@@ -865,2 +921,0 @@\n-        public T opts(String... opts) {\n-            this.opts.add(opts);\n@@ -870,0 +924,7 @@\n+        public JavaOpts(Builder<?> parent) {\n+            super(parent);\n+        }\n+        public JavaOpts() {\n+            super();\n+        }\n+\n@@ -874,1 +935,1 @@\n-        public T jdk(Dir jdk) {\n+        public T jdk(DirEntry jdk) {\n@@ -879,2 +940,5 @@\n-        public T add_exports(String fromModule, String pack, String toModule) {\n-             opts.add(\"--add-exports=\" + fromModule + \"\/\" + pack + \"=\" + toModule);\n+        public T add_exports(String fromModule, String pkg, String toModule) {\n+             if (this.exports == null){\n+                 this.exports = new ArrayList<>();\n+             }\n+             exports.add(new FromModulePackageToModule(fromModule, pkg, toModule));\n@@ -885,1 +949,5 @@\n-            List.of(modules).forEach(module -> opts.add(\"--add-modules=\" + module));\n+            if (this.modules == null){\n+                this.modules = new Strings();\n+            }\n+            this.modules.add(modules);\n+\n@@ -890,0 +958,1 @@\n+\n@@ -895,1 +964,1 @@\n-            opts.add(\"--enable-preview\");\n+            this.enablePreview = true;\n@@ -899,0 +968,2 @@\n+\n+\n@@ -901,1 +972,1 @@\n-    public abstract static class JavaToolBuilder<T extends JavaToolBuilder<T>> extends JavaOpts<T> {\n+    public abstract sealed static class JavaToolBuilder<T extends JavaToolBuilder<T>> extends JavaOpts<T> permits JavacBuilder,JavaBuilder{\n@@ -903,0 +974,13 @@\n+        public T copy(T other){\n+            super.copy(other);\n+            if (other.classPath != null) {\n+                this.classPath = ClassPath.of().add(other.classPath);\n+            }\n+            return self();\n+        }\n+        public JavaToolBuilder(Builder<?> parent) {\n+            super(parent);\n+        }\n+        public JavaToolBuilder() {\n+            super();\n+        }\n@@ -914,1 +998,2 @@\n-    public static class JavacBuilder extends JavaToolBuilder<JavacBuilder> {\n+    public static final class JavacBuilder extends JavaToolBuilder<JavacBuilder> {\n+        public DirEntry mavenStyleRoot;\n@@ -917,0 +1002,18 @@\n+        public ClassPath modulePath;\n+        public SourcePath moduleSourcePath;\n+        public Integer source;\n+        public JavacBuilder copy(JavacBuilder other){\n+            super.copy(other);\n+            if (other.mavenStyleRoot != null){\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to maven style dir\");\n+            }\n+            if (other.sourcePath != null){\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a SourcePath\");\n+            }\n+            if (other.moduleSourcePath != null){\n+                throw new RuntimeException(\"You are copying a JavacBuilder which is already bound to a ModuleSourcePath\");\n+            }\n+\n+            if (other.source !=null){\n+                this.source = other.source;\n+            }\n@@ -918,0 +1021,5 @@\n+            if (other.classPath != null){\n+                ClassPath.ofOrUse(this.classPath).add(other.classPath);\n+            }\n+            return this;\n+        }\n@@ -919,1 +1027,1 @@\n-             opts.add(\"--source\", Integer.toString(version));\n+             this.source = version;\n@@ -923,0 +1031,5 @@\n+        public JavacBuilder maven_style_root(DirEntry mavenStyleRoot) {\n+            this.mavenStyleRoot = mavenStyleRoot;\n+            return this;\n+        }\n+\n@@ -945,0 +1058,20 @@\n+\n+        public JavacBuilder module_source_path(List<SourcePathEntry> moduleSourcePathEntries) {\n+            this.moduleSourcePath = SourcePath.ofOrUse(this.moduleSourcePath).add(moduleSourcePathEntries);\n+            return this;\n+        }\n+\n+        public JavacBuilder module_source_path(SourcePathEntry... moduleSourcePathEntries) {\n+            return module_source_path(List.of(moduleSourcePathEntries));\n+        }\n+\n+        public JavacBuilder module_source_path(SourcePath moduleSourcePath) {\n+            return module_source_path(moduleSourcePath.entries());\n+        }\n+\n+        public JavacBuilder(){\n+            super();\n+        }\n+        public JavacBuilder(JarBuilder jarBuilder) {\n+            super(jarBuilder);\n+        }\n@@ -947,2 +1080,1 @@\n-    public static class JavacResult{\n-        JavacBuilder builder;\n+    public static final class JavacResult extends Result<JavacBuilder>{\n@@ -950,0 +1082,1 @@\n+        List<JavaSourceFile> sourceFiles = new ArrayList<>();\n@@ -953,2 +1086,1 @@\n-            this.builder = builder;\n-            opts.add(builder.opts);\n+            super(builder);\n@@ -962,2 +1094,18 @@\n-            result.classDir = javacBuilder.classDir==null?ClassDir.temp():javacBuilder.classDir;\n-            result.opts.add(\"-d\", result.classDir.path().toString());\n+            if (javacBuilder.source != null){\n+                result.opts.add(\"--source\", javacBuilder.source.toString());\n+            }\n+\n+            if (javacBuilder.enablePreview!=null && javacBuilder.enablePreview){\n+                result.opts.add(\"--enable-preview\");\n+            }\n+            if (javacBuilder.modules!=null){\n+                javacBuilder.modules.strings.forEach(module->\n+                    result.opts.add(\"--add-modules\", module)\n+                );\n+            }\n+\n+            if (javacBuilder.exports!=null){\n+                javacBuilder.exports.forEach(fpt->{\n+                    result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n+                });\n+            }\n@@ -965,0 +1113,2 @@\n+            result.classDir = javacBuilder.classDir == null ? ClassDir.temp() : javacBuilder.classDir;\n+            result.opts.add(\"-d\", result.classDir.path().toString());\n@@ -967,0 +1117,6 @@\n+            }else if (javacBuilder.modulePath != null){\n+            \/\/https:\/\/dev.java\/learn\/modules\/building\/\n+                result.opts.add(\"--module-path\", javacBuilder.modulePath.charSeparated());\n+            }else{\n+               \/\/ println(\"Warning no class path or module path \");\n+                \/\/throw new RuntimeException(\"No class path or module path provided\");\n@@ -968,0 +1124,20 @@\n+            var mavenStyleRoot =\n+                    ((javacBuilder.parent instanceof JarBuilder jarBuilder) && jarBuilder.mavenStyleRoot instanceof DirEntry fromJarBuilder)\n+                        ?fromJarBuilder\n+                        :javacBuilder.mavenStyleRoot;\n+\n+\n+            if (mavenStyleRoot == null) {\n+                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()) {\n+                    result.opts.add(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n+                    result.sourceFiles.addAll(javacBuilder.sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                } else if (javacBuilder.moduleSourcePath != null && !javacBuilder.moduleSourcePath.entries.isEmpty()) {\n+                    result.opts.add(\"--module-source-path\", javacBuilder.moduleSourcePath.charSeparated());\n+                    result.sourceFiles.addAll(javacBuilder.moduleSourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                } else {\n+                    throw new RuntimeException(\"No source path or module source path specified\");\n+                }\n+            }else{\n+                var sourcePath = SourcePath.of().add(SourcePathEntry.of(mavenStyleRoot.path.resolve(\"src\/main\/java\")));\n+                result.sourceFiles.addAll(sourcePath.javaFiles().map(JavaSourceFile::new).toList());\n+                result.opts.add(\"--source-path\", sourcePath.charSeparated());\n@@ -969,1 +1145,4 @@\n-            result.opts.add(\"--source-path\", javacBuilder.sourcePath.charSeparated());\n+                if (javacBuilder.sourcePath != null && !javacBuilder.sourcePath.entries.isEmpty()){\n+                   throw new RuntimeException(\"You have specified --source-path AND provided maven_style_root \");\n+                }\n+            }\n@@ -988,1 +1167,1 @@\n-            if (javacBuilder.verbose) {\n+             if (javacBuilder.verbose  || javacBuilder.parent instanceof JarBuilder jarBuilder && jarBuilder.verbose) {\n@@ -998,1 +1177,2 @@\n-                            javacBuilder.sourcePath.javaFiles().map(JavaSourceFile::new).toList()));\n+                            result.sourceFiles\n+                    ));\n@@ -1007,3 +1187,2 @@\n-\n-    public static JavacResult javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-        JavacBuilder javacBuilder = new JavacBuilder();\n+    public static JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer){\n+        JavacBuilder javacBuilder= new JavacBuilder();\n@@ -1011,1 +1190,4 @@\n-        return javac(javacBuilder);\n+        return javacBuilder;\n+    }\n+    public static JavacResult javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+        return javac(javacBuilder(javacBuilderConsumer));\n@@ -1014,1 +1196,1 @@\n-    public static class JavaBuilder extends JavaToolBuilder<JavaBuilder> {\n+    public static final class JavaBuilder extends JavaToolBuilder<JavaBuilder> {\n@@ -1019,0 +1201,2 @@\n+        public Strings nativeAccessModules = new Strings();\n+        private boolean headless;\n@@ -1021,1 +1205,1 @@\n-             opts.add(\"--enable-native-access=\" + module);\n+            nativeAccessModules.add(module);\n@@ -1058,0 +1242,11 @@\n+\n+        public void headless() {\n+            this.headless = true;\n+        }\n+    }\n+\n+    public static final class JavaResult extends Result<JavaBuilder>{\n+        Strings opts = new Strings();\n+        JavaResult(JavaBuilder javaBuilder) {\n+            super(javaBuilder);\n+        }\n@@ -1061,2 +1256,19 @@\n-        Strings execOpts = new Strings();\n-        execOpts.add(javaBuilder.jdk.path().resolve(\"bin\/java\").toString());\n+        JavaResult result = new JavaResult(javaBuilder);\n+        result.opts.add(javaBuilder.jdk.path().resolve(\"bin\/java\").toString());\n+        if (javaBuilder.enablePreview != null && javaBuilder.enablePreview){\n+            result.opts.add(\"--enable-preview\");\n+        }\n+        if (javaBuilder.modules!=null){\n+            javaBuilder.modules.strings.forEach(module->\n+                    result.opts.add(\"--add-modules\", module)\n+            );\n+        }\n+\n+        if (javaBuilder.exports!=null){\n+            javaBuilder.exports.forEach(fpt->{\n+                result.opts.add(\"--add-exports=\" + fpt.fromModule + \"\/\" + fpt.pkg + \"=\" + fpt.toModule);\n+            });\n+        }\n+        if (javaBuilder.headless) {\n+            result.opts.add(\"-Dheadless=true\");\n+        }\n@@ -1064,1 +1276,1 @@\n-            execOpts.add(\"-XstartOnFirstThread\");\n+            result.opts.add(\"-XstartOnFirstThread\");\n@@ -1066,1 +1278,5 @@\n-        execOpts.add(javaBuilder.opts);\n+\n+        javaBuilder.nativeAccessModules.strings.forEach(module->\n+            result.opts.add(\"--enable-native-access=\" + module)\n+        );\n+\n@@ -1068,1 +1284,1 @@\n-            execOpts.add(\"--class-path\", javaBuilder.classPath.charSeparated());\n+            result.opts.add(\"--class-path\", javaBuilder.classPath.charSeparated());\n@@ -1071,1 +1287,1 @@\n-            execOpts.add(\"-Djava.library.path=\" + javaBuilder.libraryPath.charSeparated());\n+            result.opts.add(\"-Djava.library.path=\" + javaBuilder.libraryPath.charSeparated());\n@@ -1073,2 +1289,2 @@\n-        execOpts.add(javaBuilder.mainClass);\n-        execOpts.add(javaBuilder.args);\n+        result.opts.add(javaBuilder.mainClass);\n+        result.opts.add(javaBuilder.args.strings);\n@@ -1077,1 +1293,1 @@\n-            var processBuilder = new ProcessBuilder().inheritIO().command(execOpts.strings);\n+            var processBuilder = new ProcessBuilder().inheritIO().command(result.opts.strings);\n@@ -1080,1 +1296,1 @@\n-                print(execOpts);\n+                println(result.opts.spaceSeperated());\n@@ -1100,1 +1316,1 @@\n-    public static class FormatBuilder extends Bldr.Builder<FormatBuilder> {\n+    public static final class FormatBuilder extends Builder<FormatBuilder> {\n@@ -1140,1 +1356,1 @@\n-    public static class TestNGBuilder extends Bldr.Builder<TestNGBuilder> {\n+    public static final class TestNGBuilder extends Builder<TestNGBuilder> {\n@@ -1247,6 +1463,5 @@\n-        var testJar =\n-                testNGBuilder.testJar.create(\n-                        $ ->\n-                                $.javac(\n-                                        $$ ->\n-                                                $$.source(24)\n+        var testJarResult =\n+                jar(jar->jar\n+                        .jar(testNGBuilder.testJar)\n+                        .javac(javac->javac\n+                                .source(24)\n@@ -1255,1 +1470,3 @@\n-                                                        .source_path(testNGBuilder.sourcePath)));\n+                                                        .source_path(testNGBuilder.sourcePath)\n+                        )\n+                );\n@@ -1262,1 +1479,1 @@\n-                                .class_path(testNGBuilder.classPath, mavenJars, testJar)\n+                                .class_path(testNGBuilder.classPath, mavenJars, testJarResult)\n@@ -1267,1 +1484,38 @@\n-    public static class JarBuilder extends Builder<JarBuilder> {\n+    public static final class JarBuilder extends Builder<JarBuilder> {\n+        public static class Manifest{\n+            public String mainClass;\n+            public String classPath;\n+            public String version;\n+            public String createdBy;\n+            public String buildBy;\n+        }\n+        public static final class ManifestBuilder extends Builder<ManifestBuilder>{\n+\n+            Manifest manifest;\n+\n+            public ManifestBuilder main_class(String mainClass){\n+                this.manifest.mainClass = mainClass;\n+                return self();\n+            }\n+            public ManifestBuilder version(String version){\n+                this.manifest.version = version;\n+                return self();\n+            }\n+            public ManifestBuilder created_by(String createdBy){\n+                this.manifest.createdBy = createdBy;\n+                return self();\n+            }\n+            public ManifestBuilder build_by(String buildBy){\n+                this.manifest.buildBy = buildBy;\n+                return self();\n+            }\n+            public ManifestBuilder class_path(String classPath){\n+                this.manifest.classPath = classPath;\n+                return self();\n+            }\n+\n+            ManifestBuilder(Manifest manifest){\n+                this.manifest = manifest;\n+            }\n+        }\n+        public DirEntry mavenStyleRoot;\n@@ -1271,1 +1525,2 @@\n-\n+      \/\/  public String mainClass;\n+        public Manifest manifest;\n@@ -1277,1 +1532,13 @@\n-        public JarBuilder javac(JavacBuilder javacBuilder) {\n+        public JarBuilder maven_style_root(DirEntry mavenStyleRoot) {\n+            this.mavenStyleRoot = mavenStyleRoot;\n+            return this;\n+        }\n+\n+        public JarBuilder manifest(Consumer<ManifestBuilder> manifestBuilderConsumer){\n+            this.manifest = this.manifest==null?new Manifest():this.manifest;\n+            var manifestBuilder = new ManifestBuilder(manifest);\n+            manifestBuilderConsumer.accept(manifestBuilder);\n+            return self();\n+        }\n+\n+        private JarBuilder javac(JavacBuilder javacBuilder) {\n@@ -1279,0 +1546,1 @@\n+\n@@ -1283,0 +1551,6 @@\n+            if (mavenStyleRoot!=null){\n+                var resources = mavenStyleRoot.dir(\"src\/main\/resources\");\n+                if (resources.exists()) {\n+                    this.dirList.add(resources);\n+                }\n+            }\n@@ -1286,2 +1560,2 @@\n-        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-            JavacBuilder javacBuilder= new JavacBuilder();\n+        public JavacBuilder javacBuilder(Consumer<JavacBuilder> javacBuilderConsumer){\n+            JavacBuilder javacBuilder= new JavacBuilder(this);\n@@ -1289,1 +1563,5 @@\n-            return javac(javacBuilder);\n+            return javacBuilder;\n+        }\n+\n+        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            return javac(javacBuilder(javacBuilderConsumer));\n@@ -1293,1 +1571,1 @@\n-            DirPath.ofOrUse(this.dirList).add(holder);\n+            this.dirList = DirPath.ofOrUse(this.dirList).add(holder);\n@@ -1298,6 +1576,6 @@\n-    public static class JarResult extends Result implements ClassPathEntryProvider{\n-        JarBuilder jarBuilder;\n-        Strings opts = new Strings();\n-        List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n-        List<Path> paths = new ArrayList<>();\n-        JarFile jarFile;\n+    public static final class JarResult extends Result<JarBuilder> implements ClassPathEntryProvider{\n+        public Strings opts = new Strings();\n+        public List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n+        public List<Path> paths = new ArrayList<>();\n+        public JarFile jarFile;\n+        public String mainClass;\n@@ -1305,1 +1583,1 @@\n-            this.jarBuilder = jarBuilder;\n+            super(jarBuilder);\n@@ -1313,0 +1591,4 @@\n+\n+        @Override public String toString(){\n+            return jarFile.path.toString();\n+        }\n@@ -1316,0 +1598,1 @@\n+\n@@ -1320,0 +1603,3 @@\n+            if (jarBuilder.dirList ==null){\n+                throw new RuntimeException(\"Nothing to jar \");\n+            }\n@@ -1354,2 +1640,2 @@\n-    public static JarResult jar(Consumer<JarBuilder> jarBuilderConsumer) {\n-        JarBuilder jarBuilder = new JarBuilder();\n+    public static JarBuilder jarBuilder(Consumer<JarBuilder> jarBuilderConsumer){\n+        JarBuilder jarBuilder= new JarBuilder();\n@@ -1357,1 +1643,5 @@\n-        return jar(jarBuilderConsumer);\n+        return jarBuilder;\n+    }\n+\n+    public static JarResult jar(Consumer<JarBuilder> jarBuilderConsumer) {\n+        return jar(jarBuilder(jarBuilderConsumer));\n@@ -1360,1 +1650,1 @@\n-    public static class CMakeBuilder extends Builder<CMakeBuilder> {\n+    public static final class CMakeBuilder extends Builder<CMakeBuilder> {\n@@ -1363,1 +1653,1 @@\n-        public Dir sourceDir;\n+        public DirEntry sourceDir;\n@@ -1394,1 +1684,1 @@\n-        public CMakeBuilder source_dir(Dir sourceDir) {\n+        public CMakeBuilder source_dir(DirEntry sourceDir) {\n@@ -1455,2 +1745,2 @@\n-    public static class JExtractBuilder extends Builder<JExtractBuilder> {\n-        public List<String> compileFlags = new ArrayList<>();\n+    public static final class JExtractBuilder extends Builder<JExtractBuilder> {\n+        public Strings compileFlags = new Strings();\n@@ -1462,0 +1752,16 @@\n+        public JExtractBuilder copy(JExtractBuilder other){\n+            this.compileFlags = new Strings(other.compileFlags);\n+            if (other.targetPackage != null){\n+                throw new RuntimeException(\"You are copying jextract builder already bound to a target package\");\n+            }\n+            if (other.output != null){\n+                throw new RuntimeException(\"You are copying jextract builder already bound to output directory\");\n+            }\n+            if (!other.libraries.isEmpty()){\n+                throw new RuntimeException(\"You are copying jextract builder already bound to library(ies)\");\n+            }\n+            if (!other.headers.isEmpty()){\n+                throw new RuntimeException(\"You are copying jextract builder already bound to headers library(ies)\");\n+            }\n+            return self();\n+        }\n@@ -1464,1 +1770,1 @@\n-            return this;\n+            return  self();\n@@ -1469,1 +1775,1 @@\n-            return this;\n+            return  self();\n@@ -1474,1 +1780,1 @@\n-            return this;\n+            return  self();\n@@ -1478,2 +1784,2 @@\n-            this.compileFlags.addAll(Arrays.asList(compileFlags));\n-            return this;\n+            this.compileFlags.add(compileFlags);\n+            return  self();\n@@ -1484,1 +1790,8 @@\n-            return this;\n+            return  self();\n+        }\n+    }\n+\n+    public static final class JExtractResult extends Result<JExtractBuilder>{\n+        public Strings opts = new Strings();\n+        JExtractResult(JExtractBuilder builder) {\n+            super(builder);\n@@ -1488,1 +1801,2 @@\n-    public static void jextract(Jextract executable, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n+    public static JExtractResult jextract(JExtractExecutable executable, Consumer<JExtractBuilder> jextractBuilderConsumer) {\n+\n@@ -1493,0 +1807,1 @@\n+        JExtractResult result = new JExtractResult(jExtractBuilder);\n@@ -1494,2 +1809,1 @@\n-        List<String> opts = new ArrayList<>();\n-        opts.add(executable.path().toString());\n+        result.opts.add(executable.path().toString());\n@@ -1498,1 +1812,1 @@\n-            opts.addAll(List.of(\"--target-package\", jExtractBuilder.targetPackage));\n+            result.opts.add(\"--target-package\", jExtractBuilder.targetPackage);\n@@ -1502,1 +1816,1 @@\n-            opts.addAll(List.of(\"--output\", jExtractBuilder.output.path().toString()));\n+            result.opts.add(\"--output\", jExtractBuilder.output.path().toString());\n@@ -1505,1 +1819,1 @@\n-            opts.addAll(List.of(\"--library\", \":\" + library));\n+            result.opts.add(\"--library\", \":\" + library);\n@@ -1509,1 +1823,1 @@\n-            opts.add(header.toString());\n+            result.opts.add(header.toString());\n@@ -1512,2 +1826,2 @@\n-        if (jExtractBuilder.compileFlags != null && !jExtractBuilder.compileFlags.isEmpty()) {\n-            jExtractBuilder.output.textFile(\"compile_flags.txt\", jExtractBuilder.compileFlags);\n+        if (jExtractBuilder.compileFlags != null && !jExtractBuilder.compileFlags.strings.isEmpty()) {\n+            jExtractBuilder.output.textFile(\"compile_flags.txt\", jExtractBuilder.compileFlags.strings);\n@@ -1517,3 +1831,1 @@\n-            StringBuilder sb = new StringBuilder();\n-            opts.forEach(opt -> (sb.isEmpty() ? sb : sb.append(\" \")).append(opt));\n-            println(sb);\n+            println(result.opts.spaceSeperated());\n@@ -1525,1 +1837,1 @@\n-        processBuilder.inheritIO().command(opts);\n+        processBuilder.inheritIO().command(result.opts.strings);\n@@ -1531,0 +1843,1 @@\n+        return result;\n@@ -1628,0 +1941,2160 @@\n+\n+    public static class CMakeProbe implements Capabilities.Probe {\n+        public interface CMakeVar<T> {\n+            String name();\n+\n+            T value();\n+        }\n+\n+        public record CMakeTypedVar(String name, String type, String value, String comment)\n+                implements CMakeVar<String> {\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n+\n+            CMakeTypedVar(Matcher matcher, String comment) {\n+                this(\n+                        \"CMAKE_\" + matcher.group(1).trim(),\n+                        matcher.group(2).trim(),\n+                        matcher.group(3).trim(),\n+                        comment.substring(2).trim());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n+            }\n+        }\n+\n+        public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+            CMakeSimpleVar(Matcher matcher) {\n+                this(\n+                        \"CMAKE_\" + matcher.group(1).trim(),\n+                        (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+            }\n+        }\n+\n+        public record CMakeDirVar(String name, DirPathHolder value) implements CMakeVar {\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n+            }\n+        }\n+\n+        public record CMakeContentVar(String name, String value) implements CMakeVar {\n+            static final Regex startRegex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n+            static final Regex endRegex = Regex.of(\"^(.*)\\\\}>\\\\}$\");\n+        }\n+\n+        public record CMakeRecipeVar(String name, String value) implements CMakeVar<String> {\n+            static final Regex varPattern = Regex.of(\"<([^>]*)>\");\n+            static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n+\n+            CMakeRecipeVar(Matcher matcher) {\n+                this(\n+                        \"CMAKE_\" + matcher.group(1).trim(),\n+                        \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n+            }\n+\n+            public String expandRecursively(Map<String, CMakeVar<?>> varMap, String value) { \/\/ recurse\n+                String result = value;\n+                if (varPattern.pattern().matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                    var v = matcher.group(1);\n+                    if (varMap.containsKey(v)) {\n+                        String replacement = varMap.get(v).value().toString();\n+                        result =\n+                                expandRecursively(\n+                                        varMap,\n+                                        value.substring(0, matcher.start())\n+                                                + replacement\n+                                                + value.substring(matcher.end()));\n+                    }\n+                }\n+                return result;\n+            }\n+\n+            public String expand(Map<String, CMakeVar<?>> vars) {\n+                return expandRecursively(vars, value());\n+            }\n+\n+            static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n+                return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n+            }\n+        }\n+\n+        BuildDir dir;\n+\n+        Map<String, CMakeVar<?>> varMap = new HashMap<>();\n+\n+        public CMakeProbe(BuildDir dir, Capabilities capabilities) {\n+            this.dir = BuildDir.of(dir.path(\"cmakeprobe\"));\n+            this.dir.clean();\n+\n+            try {\n+                this.dir.cmakeLists(cmakeLists-> {\n+                        cmakeLists.append(\n+                             \"\"\"\n+                             cmake_minimum_required(VERSION 3.21)\n+                             project(cmakeprobe)\n+                             set(CMAKE_CXX_STANDARD 14)\n+                             \"\"\"\n+                        );\n+\n+                        capabilities.capabilities()\n+                                    .filter(capability -> capability instanceof Capabilities.CMakeCapability)\n+                                    .map(capability -> (Capabilities.CMakeCapability) capability)\n+                                    .forEach(p ->\n+                                            cmakeLists.append(p.probeStanza()).append(\"\\n\")\n+                                    );\n+                        cmakeLists.append(\n+                             \"\"\"\n+                             get_cmake_property(_variableNames VARIABLES ${VarNames})\n+                             foreach(VarName ${_variableNames})\n+                                 message(\"${VarName}={<{${${VarName}}}>}\")\n+                             endforeach()\n+                             \"\"\"\n+                            );\n+                        });\n+\n+                var cmakeProcessBuilder =\n+                        new ProcessBuilder()\n+                                .directory(this.dir.path().toFile())\n+                                .redirectErrorStream(true)\n+                                .command(\"cmake\", \"-LAH\")\n+                                .start();\n+                List<String> stdinlines =\n+                        new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream()))\n+                                .lines()\n+                                .toList();\n+                cmakeProcessBuilder.waitFor();\n+                this.dir.textFile(\"rawlines\", sb->{\n+                    stdinlines.forEach(line-> sb.append(line).append(\"\\n\"));\n+                   \/\/ stderrlines.forEach(line-> sb.append(\"ERR\").append(line).append(\"\\n\"));\n+                });\n+\n+                String comment = null;\n+                String contentName = null;\n+                StringBuilder content = null;\n+\n+                for (String line : stdinlines) {\n+                    if (line.startsWith(\"\/\/\")) {\n+                        comment = line;\n+                        content = null;\n+\n+                    } else if (comment != null) {\n+                        if (CMakeTypedVar.onMatch(\n+                                line,\n+                                comment,\n+                                v -> {\n+                                    if (varMap.containsKey(v.name())) {\n+                                        var theVar = varMap.get(v.name());\n+                                        if (theVar.value().equals(v.value())) {\n+                                          \/*  println(\n+                                                    \"replacing duplicate variable with typed variant with the name same value\"\n+                                                            + v\n+                                                            + theVar);*\/\n+                                        } else {\n+                                            throw new IllegalStateException(\n+                                                    \"Duplicate variable name different value: \" + v + theVar);\n+                                        }\n+                                        varMap.put(v.name(), v);\n+                                    } else {\n+                                        varMap.put(v.name(), v);\n+                                    }\n+                                })) {\n+                        } else {\n+                            println(\"failed to parse \" + line);\n+                        }\n+                        comment = null;\n+                        content = null;\n+                        contentName = null;\n+                    } else if (!line.isEmpty()) {\n+                        if (content != null) {\n+                            if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher\n+                                    && matcher.matches()) {\n+                                content.append(\"\\n\").append(matcher.group(1));\n+                                var v = new CMakeContentVar(contentName, content.toString());\n+                                contentName = null;\n+                                content = null;\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                content.append(\"\\n\").append(line);\n+                            }\n+                        } else if (!line.endsWith(\"}>}\")\n+                                && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            contentName = \"CMAKE_\" + matcher.group(1);\n+                            content = new StringBuilder(matcher.group(2));\n+                        } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            CMakeVar<String> v = new CMakeRecipeVar(matcher);\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                  \/\/  println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                                } else {\n+                                    throw new IllegalStateException(\n+                                            \"Duplicate variable name different value: \" + v + theVar);\n+                                }\n+                                varMap.put(v.name(), v);\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher\n+                                && matcher.matches()) {\n+                            var v =  new CMakeSimpleVar(matcher);\n+                            if (varMap.containsKey(v.name())) {\n+                                var theVar = varMap.get(v.name());\n+                                if (theVar.value().equals(v.value())) {\n+                                   \/\/ println(\"Skipping duplicate variable name different value: \" + v + theVar);\n+                                } else {\n+                                    \/\/throw new IllegalStateException(\n+                                      \/\/      \"Duplicate variable name different vars: \" + v + theVar);\n+                                }\n+                                \/\/ note we don't replace a Typed with a Simple\n+                            } else {\n+                                varMap.put(v.name(), v);\n+                            }\n+                        } else {\n+                           \/\/ println(\"Skipping \" + line);\n+                        }\n+                    }\n+                }\n+\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            this.dir.textFile(\"vars\", sb-> {\n+                varMap.values().forEach(v->sb.append(v.name()).append(\"<{<\").append(v.value().toString()).append(\">}>\").append(\"\\n\"));\n+            });\n+\n+            capabilities\n+                    .capabilities()\n+                    .filter(capability -> capability instanceof Capabilities.CMakeCapability)\n+                    .map(capability->(Capabilities.CMakeCapability)capability)\n+                    .forEach(capability -> capability.setCmakeProbe(this));\n+\n+        }\n+\n+        ObjectFile cxxCompileObject(\n+                ObjectFile target, CppSourceFile source, List<String> frameworks) {\n+            CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n+            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+            localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n+            localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n+            localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n+            localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.path().toString()));\n+            localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.path().toString()));\n+            String executable = compileObject.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+        ExecutableFile cxxLinkExecutable(\n+                ExecutableFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n+            CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n+            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+            String executable = linkExecutable.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+        SharedLibraryFile cxxCreateSharedLibrary(\n+                SharedLibraryFile target, List<ObjectFile> objFiles, List<String> frameworks) {\n+            CMakeRecipeVar createSharedLibrary =\n+                    (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n+            Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n+            String executable = createSharedLibrary.expand(localVars);\n+            println(executable);\n+            return target;\n+        }\n+\n+\n+        public String value(String key) {\n+            var  v = varMap.get(key);\n+            return v.value().toString();\n+        }\n+\n+        public  boolean hasKey(String includeDirKey) {\n+            return varMap.containsKey(includeDirKey);\n+        }\n+\n+    }\n+\n+    public static class Capabilities {\n+        interface Probe{\n+\n+        }\n+        public static abstract class Capability {\n+            final public String name;\n+            protected Capability(String name) {\n+                this.name=name;\n+            }\n+            public abstract boolean available();\n+\n+\n+        }\n+        public static abstract class CMakeCapability extends Capability {\n+            CMakeProbe cmakeProbe;\n+            CMakeCapability(String name) {\n+                super(name);\n+            }\n+            public  void setCmakeProbe(CMakeProbe cmakeProbe){\n+                this.cmakeProbe = cmakeProbe;\n+            }\n+            public abstract String probeStanza();\n+        }\n+\n+        public Map<String, Capability> capabilityMap = new HashMap<>();\n+\n+        public static Capabilities of(Capability... capabilities) {\n+            return new Capabilities(capabilities);\n+        }\n+\n+        public Stream<Capability> capabilities() {\n+            return capabilityMap.values().stream();\n+        }\n+        public Stream<Capability> capabilities(Predicate<Capability> filter) {\n+            return capabilities().filter(filter);\n+        }\n+\n+        public boolean capabilityIsAvailable(String name) {\n+            return capabilities().anyMatch(c-> c.name.equalsIgnoreCase(name));\n+        }\n+\n+        private Capabilities(Capability... capabilities){\n+            List.of(capabilities).forEach(capability ->\n+                    capabilityMap.put(capability.name, capability)\n+            );\n+\n+        }\n+\n+        public static class OpenCL extends CMakeCapability {\n+            public static String includeDirKey  = \"CMAKE_OpenCL_INCLUDE_DIR\";\n+            public static String libKey  = \"CMAKE_OpenCL_LIBRARY\";\n+            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n+            public OpenCL() {\n+                super(\"OpenCL\");\n+            }\n+            public static OpenCL of(){\n+                return new OpenCL();\n+            }\n+            @Override\n+            public String probeStanza() {\n+                return\n+                        \"\"\"\n+                        find_package(OpenCL)\n+                        if(OPENCL_FOUND)\n+                            if (APPLE)\n+                               set(OPENCL_FRAMEWORK \"-framework OpenGL\")\n+                               set(OPENCL_INCLUDE_DIR \"-framework OpenCL\")\n+                               set(OPENCL_LIBRARY_DIR \"-framework OpenCL\")\n+                            else()\n+                               set(OPENCL_LIB \"OpenCL\")\n+                            endif()\n+                        endif()\n+                        \"\"\";\n+            }\n+            public String appLibFrameworks() {\n+                return cmakeProbe.value(osxSysroot);\n+            }\n+\n+            @Override\n+            public boolean available() {\n+                return cmakeProbe.hasKey(includeDirKey);\n+            }\n+            public String lib(){\n+                return cmakeProbe.value(libKey);\n+            }\n+\n+            public String includeDir(){\n+                return cmakeProbe.value(includeDirKey);\n+            }\n+        }\n+\n+        public static class OpenGL extends CMakeCapability {\n+            public static String includeDirKey  = \"CMAKE_OPENGL_INCLUDE_DIR\";\n+            public static String libKey  = \"CMAKE_OPENGL_LIBRARY\";\n+            public static String osxSysroot = \"CMAKE_OSX_SYSROOT\";\n+            public OpenGL() {\n+                super(\"OpenGL\");\n+            }\n+            public static OpenGL of(){\n+                return new OpenGL();\n+            }\n+            @Override\n+            public boolean available() {\n+                return cmakeProbe.hasKey(includeDirKey);\n+            }\n+            DirEntry includeDir(){\n+                return DirEntry.of(Path.of(cmakeProbe.value(includeDirKey)));\n+            }\n+\n+            public String appLibFrameworks() {\n+                return cmakeProbe.value(osxSysroot);\n+            }\n+           \/\/ public Path frameworkLibrary(String frameworkName) {\n+           \/\/     return Path.of(appLibFrameworks()).resolve(frameworkName + \".framework\/\" + frameworkName);\n+          \/\/  }\n+\n+            public Path lib(String frameworkName ) {\n+                return Path.of(cmakeProbe.value(libKey).split(\";\")[0]).resolve(frameworkName + \".framework\/\" + frameworkName);\n+            }\n+            @Override\n+            public String probeStanza() {\n+                return\n+                        \"\"\"\n+                        find_package(OpenGL)\n+                        if(OPENGL_FOUND)\n+                            if (APPLE)\n+                               set(OPENGL_FRAMEWORK \"-framework OpenGL\")\n+                            else()\n+                               set(OPENCL_LIB \"OpenCL\")\n+                            endif()\n+                        else()\n+                            message(\"NO OPENGL FOUND\")\n+                        endif()\n+                        \"\"\";\n+            }\n+\n+        }\n+\n+        public static class HIP extends CMakeCapability {\n+            public HIP() {\n+                super(\"HIP\");\n+            }\n+            public static HIP of(){\n+                return new HIP();\n+            }\n+            @Override\n+            public boolean available() {\n+                return false;\n+            }\n+            @Override\n+            public String probeStanza() {\n+                return\n+                        \"\"\"\n+                        find_package(HIP)\n+                        if(HIP_FOUND)\n+\n+                        else()\n+                            message(\"NO HIP FOUND\")\n+                        endif()\n+                        \"\"\";\n+            }\n+\n+        }\n+        public static class CUDA extends CMakeCapability {\n+            public static String sdkRootDirKey  = \"CMAKE_CUDA_SDK_ROOT_DIR\";\n+            public static String sdkRootDirNotFoundValue  = \"CUDA_SDK_ROOT_DIR-NOTFOUND\";\n+            public CUDA() {\n+                super(\"CUDA\");\n+            }\n+            public static CUDA of(){\n+                return new CUDA();\n+            }\n+            @Override\n+            public boolean available() {\n+                return cmakeProbe.hasKey(sdkRootDirKey) && !cmakeProbe.value(sdkRootDirKey).equals(sdkRootDirNotFoundValue);\n+            }\n+            @Override\n+            public String probeStanza() {\n+                return\n+                        \"\"\"\n+                        find_package(CUDAToolkit)\n+                        if(CUDAToolkit_FOUND)\n+                            set(CUDA_FOUND true)\n+                            set(CUDA_INCLUDE_DIR ${CUDAToolkit_INCLUDE_DIR})\n+                            set(CUDA_LIBRARY_DIR ${CUDAToolkit_LIBRARY_DIR})\n+                            set(CUDA_LIBRARIES \"-lcudart -lcuda\")\n+                        else()\n+                            message(\"NO CUDA FOUND\")\n+                        endif()\n+                        \"\"\";\n+            }\n+\n+        }\n+\n+        public static class JExtract extends Bldr.Capabilities.Capability{\n+            public Bldr.JExtractExecutable executable;\n+            JExtract(){\n+                super(\"JExtract\");\n+                var  optionalExe = fromPATH(\"jextract\");\n+                if (optionalExe.isEmpty()){\n+                    println(\"jextract not in path\");\n+                }else{\n+                    executable = Bldr.JExtractExecutable.of(optionalExe.get());\n+                }\n+\n+            }\n+            @Override\n+            public boolean available() {\n+                return executable != null && executable.exists();\n+            }\n+\n+            public static JExtract of(){\n+                return new JExtract();\n+            }\n+\n+        }\n+\n+        public static class CMake extends Bldr.Capabilities.Capability{\n+            public Bldr.JExtractExecutable executable;\n+            public Bldr.CMakeProbe cmakeProbe;\n+            CMake(){\n+                super(\"CMake\");\n+                var  optionalExe = fromPATH(\"cmake\");\n+                if (optionalExe.isEmpty()){\n+                    println(\"cmake not in path\");\n+                }else{\n+                    executable = Bldr.JExtractExecutable.of(optionalExe.get());\n+                }\n+\n+            }\n+            @Override\n+            public boolean available() {\n+                return executable != null && executable.exists();\n+            }\n+\n+            public static CMake of(){\n+                return new CMake();\n+            }\n+\n+            public void probe(BuildDir buildDir, Capabilities capabilities) {\n+                this.cmakeProbe = new Bldr.CMakeProbe(buildDir, capabilities);\n+            }\n+        }\n+\n+    }\n+\n+    static record Regex(Pattern pattern) {\n+        Regex(String regex) {\n+            this(Pattern.compile(regex));\n+        }\n+\n+        public static Regex of(String regexString) {\n+            return new Regex(regexString);\n+        }\n+\n+        boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n+            if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n+                matcherConsumer.accept(matcher);\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public static class XMLNode {\n+        org.w3c.dom.Element element;\n+        List<XMLNode> children = new ArrayList<>();\n+        Map<String, String> attrMap = new HashMap<>();\n+\n+        public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>> {\n+            final public org.w3c.dom.Element element;\n+            @SuppressWarnings(\"unchecked\")\n+            public T self() {\n+                return (T) this;\n+            }\n+\n+            public T attr(String name, String value) {\n+                \/\/ var att = element.getOwnerDocument().createAttribute(name);\n+                \/\/ att.setValue(value);\n+                element.setAttribute(name, value);\n+                \/\/ element.appendChild(att);\n+                return self();\n+            }\n+\n+            public T attr(URI uri, String name, String value) {\n+                \/\/ var att = element.getOwnerDocument().createAttribute(name);\n+                \/\/ att.setValue(value);\n+                element.setAttributeNS(uri.toString(), name, value);\n+                \/\/ element.appendChild(att);\n+                return self();\n+            }\n+\n+            public T element(String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n+                var node = element.getOwnerDocument().createElement(name);\n+                element.appendChild(node);\n+                var builder = factory.apply(node);\n+                xmlBuilderConsumer.accept(builder);\n+                return self();\n+            }\n+\n+            public T element(\n+                    URI uri, String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n+                var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n+                element.appendChild(node);\n+                var builder = factory.apply(node);\n+                xmlBuilderConsumer.accept(builder);\n+                return self();\n+            }\n+\n+            AbstractXMLBuilder(Element element) {\n+                this.element = element;\n+            }\n+\n+            public T text(String thisText) {\n+                var node = element.getOwnerDocument().createTextNode(thisText);\n+                element.appendChild(node);\n+                return self();\n+            }\n+\n+            public T comment(String thisComment) {\n+                var node = element.getOwnerDocument().createComment(thisComment);\n+                element.appendChild(node);\n+                return self();\n+            }\n+\n+            <L> T forEach(List<L> list, BiConsumer<T, L> biConsumer) {\n+                list.forEach(l -> biConsumer.accept(self(), l));\n+                return self();\n+            }\n+\n+            <L> T forEach(Stream<L> stream, BiConsumer<T, L> biConsumer) {\n+                stream.forEach(l -> biConsumer.accept(self(), l));\n+                return self();\n+            }\n+\n+            <L> T forEach(Stream<L> stream, Consumer<L> consumer) {\n+                stream.forEach(consumer);\n+                return self();\n+            }\n+\n+            protected T then(Consumer<T> xmlBuilderConsumer) {\n+                xmlBuilderConsumer.accept(self());\n+                return self();\n+            }\n+        }\n+\n+        public static class PomXmlBuilder extends AbstractXMLBuilder<bldr.Bldr.XMLNode.PomXmlBuilder> {\n+            PomXmlBuilder(Element element) {\n+                super(element);\n+            }\n+\n+            public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+                return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+                return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder modelVersion(String s) {\n+                return element(\"modelVersion\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder pom(String groupId, String artifactId, String version) {\n+                return modelVersion(\"4.0.0\").packaging(\"pom\").ref(groupId, artifactId, version);\n+            }\n+\n+            public PomXmlBuilder jar(String groupId, String artifactId, String version) {\n+                return modelVersion(\"4.0.0\").packaging(\"jar\").ref(groupId, artifactId, version);\n+            }\n+\n+            public PomXmlBuilder groupId(String s) {\n+                return element(\"groupId\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder artifactId(String s) {\n+                return element(\"artifactId\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder packaging(String s) {\n+                return element(\"packaging\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder version(String s) {\n+                return element(\"version\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"build\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugins\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder plugin(\n+                    String groupId,\n+                    String artifactId,\n+                    String version,\n+                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\n+                        \"plugin\", $ -> $.ref(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder antPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\n+                        \"org.apache.maven.plugins\",\n+                        \"maven-antrun-plugin\",\n+                        \"1.8\",\n+                        pomXmlBuilderConsumer);\n+            }\n+            public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\n+                        \"org.apache.maven.plugins\",\n+                        \"maven-surefire-plugin\",\n+                        \"3.1.2\",\n+                        pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder compilerPlugin(\n+                    Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\n+                        \"org.apache.maven.plugins\",\n+                        \"maven-compiler-plugin\",\n+                        \"3.11.0\",pomXmlBuilderConsumer\n+                      );\n+            }\n+\n+            public PomXmlBuilder execPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return plugin(\"org.codehaus.mojo\", \"exec-maven-plugin\", \"3.1.0\", pomXmlBuilderConsumer);\n+            }\n+\n+\n+            public PomXmlBuilder plugin(\n+                    String groupId, String artifactId, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugin\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder parent(String groupId, String artifactId, String version) {\n+                return parent(parent -> parent.ref(groupId, artifactId, version));\n+            }\n+\n+            public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"parent\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder pluginManagement(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder file(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"file\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder activation(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"activation\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profiles\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profile\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"arguments\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"executions\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"execution\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder execIdPhaseConf(\n+                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execution(execution -> execution.id(id).phase(phase).goals(gs -> gs.goal(\"exec\")).configuration(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder exec(\n+                    String phase, String executable, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execIdPhaseConf(\n+                        executable + \"-\" + phase,\n+                        phase,\n+                        conf -> conf.executable(executable).arguments(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder cmake(\n+                    String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execIdPhaseConf(\n+                        id, phase, conf -> conf.executable(\"cmake\").arguments(pomXmlBuilderConsumer));\n+            }\n+\n+            public PomXmlBuilder cmake(String id, String phase, String... args) {\n+                return execIdPhaseConf(\n+                        id,\n+                        phase,\n+                        conf ->\n+                                conf.executable(\"cmake\")\n+                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n+            }\n+\n+            public PomXmlBuilder jextract(String id, String phase, String... args) {\n+                return execIdPhaseConf(\n+                        id,\n+                        phase,\n+                        conf ->\n+                                conf.executable(\"jextract\")\n+                                        .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n+            }\n+\n+            public PomXmlBuilder ant(\n+                    String id, String phase, String goal, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return execution(execution -> execution\n+                                        .id(id)\n+                                        .phase(phase)\n+                                        .goals(gs -> gs.goal(goal))\n+                                        .configuration(configuration -> configuration.target(pomXmlBuilderConsumer)));\n+            }\n+\n+            public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"goals\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"target\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"configuration\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder compilerArgs(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder compilerArgs(String... args) {\n+                return element(\"compilerArgs\", $ -> $.forEach(Stream.of(args), $::arg));\n+            }\n+\n+            public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"properties\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependencies\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version) {\n+                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version));\n+            }\n+            public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n+                return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n+            }\n+\n+            public PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n+                return dependency($ -> $.ref(groupId, artifactId, version));\n+            }\n+\n+            public PomXmlBuilder dependency(\n+                    String groupId, String artifactId, String version, String scope) {\n+                return dependency($ -> $.ref(groupId, artifactId, version).scope(scope));\n+            }\n+\n+            public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependency\", pomXmlBuilderConsumer);\n+            }\n+\n+            public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"modules\", pomXmlBuilderConsumer);\n+            }\n+            public PomXmlBuilder modules(List<String> modules) {\n+                return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n+            }\n+            public PomXmlBuilder modules(String... modules) {\n+                return modules(List.of(modules));\n+            }\n+\n+            public PomXmlBuilder module(String name) {\n+                return element(\"module\", $ -> $.text(name));\n+            }\n+\n+            public PomXmlBuilder property(String name, String value) {\n+                return element(name, $ -> $.text(value));\n+            }\n+            public PomXmlBuilder antproperty(String name, String value) {\n+                return element(\"property\", $ -> $.attr(\"name\", name).attr(\"value\", value));\n+            }\n+\n+            public PomXmlBuilder scope(String s) {\n+                return element(\"scope\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder phase(String s) {\n+                return element(\"phase\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder argument(String s) {\n+                return element(\"argument\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder goal(String s) {\n+                return element(\"goal\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder copy(String file, String toDir) {\n+                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n+            }\n+\n+            public PomXmlBuilder antjar(String basedir, String include, String destfile) {\n+                return element(\"jar\", $ -> $.attr(\"basedir\", basedir).attr(\"includes\", include+\"\/**\").attr(\"destfile\", destfile));\n+            }\n+\n+            public PomXmlBuilder echo(String message) {\n+                return element(\"echo\", $ -> $.attr(\"message\", message));\n+            }\n+\n+            public PomXmlBuilder echo(String filename, String message) {\n+                return element(\"echo\", $ -> $.attr(\"message\", message).attr(\"file\", filename));\n+            }\n+\n+            public PomXmlBuilder mkdir(String dirName) {\n+                return element(\"mkdir\", $ -> $.attr(\"dir\", dirName));\n+            }\n+\n+            public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+                return groupId(groupId).artifactId(artifactId);\n+            }\n+\n+            public PomXmlBuilder ref(String groupId, String artifactId, String version) {\n+                return groupIdArtifactId(groupId, artifactId).version(version);\n+            }\n+\n+            public PomXmlBuilder skip(String string) {\n+                return element(\"skip\", $ -> $.text(string));\n+            }\n+\n+            public PomXmlBuilder id(String s) {\n+                return element(\"id\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder arg(String s) {\n+                return element(\"arg\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder argLine(String s) {\n+                return element(\"argLine\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder source(String s) {\n+                return element(\"source\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder target(String s) {\n+                return element(\"target\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder showWarnings(String s) {\n+                return element(\"showWarnings\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder showDeprecation(String s) {\n+                return element(\"showDeprecation\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder failOnError(String s) {\n+                return element(\"failOnError\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder exists(String s) {\n+                return element(\"exists\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder activeByDefault(String s) {\n+                return element(\"activeByDefault\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder executable(String s) {\n+                return element(\"executable\", $ -> $.text(s));\n+            }\n+\n+            public PomXmlBuilder workingDirectory(String s) {\n+                return element(\"workingDirectory\", $ -> $.text(s));\n+            }\n+        }\n+\n+        public static class ImlBuilder extends AbstractXMLBuilder<bldr.Bldr.XMLNode.ImlBuilder> {\n+\n+            ImlBuilder(Element element) {\n+                super(element);\n+            }\n+\n+            public ImlBuilder element(String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n+                return element(name, ImlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder element(URI uri, String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n+                return element(uri, name, ImlBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder modelVersion(String s) {\n+                return element(\"modelVersion\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder groupId(String s) {\n+                return element(\"groupId\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder artifactId(String s) {\n+                return element(\"artifactId\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder packaging(String s) {\n+                return element(\"packaging\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder version(String s) {\n+                return element(\"version\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder build(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"build\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder plugins(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugins\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder plugin(\n+                    String groupId,\n+                    String artifactId,\n+                    String version,\n+                    Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\n+                        \"plugin\",\n+                        $ ->\n+                                $.groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public ImlBuilder plugin(\n+                    String groupId, String artifactId, Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\n+                        \"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n+            }\n+\n+            public ImlBuilder plugin(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"plugin\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder parent(String groupId, String artifactId, String version) {\n+                return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n+            }\n+\n+            public ImlBuilder parent(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"parent\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder pluginManagement(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"pluginManagement\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder file(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"file\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder activation(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"activation\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder profiles(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profiles\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder profile(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"profile\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder arguments(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"arguments\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder executions(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"executions\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder execution(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"execution\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder goals(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"goals\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder target(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"target\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder configuration(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"configuration\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder compilerArgs(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"compilerArgs\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder properties(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"properties\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder dependencies(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependencies\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder dependency(String groupId, String artifactId, String version) {\n+                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version));\n+            }\n+\n+            public ImlBuilder dependency(String groupId, String artifactId, String version, String scope) {\n+                return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version).scope(scope));\n+            }\n+\n+            public ImlBuilder dependency(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"dependency\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder modules(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+                return element(\"modules\", pomXmlBuilderConsumer);\n+            }\n+\n+            public ImlBuilder module(String name) {\n+                return element(\"module\", $ -> $.text(name));\n+            }\n+\n+            public ImlBuilder property(String name, String value) {\n+                return element(name, $ -> $.text(value));\n+            }\n+\n+            public ImlBuilder scope(String s) {\n+                return element(\"scope\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder phase(String s) {\n+                return element(\"phase\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder argument(String s) {\n+                return element(\"argument\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder goal(String s) {\n+                return element(\"goal\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder copy(String file, String toDir) {\n+                return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n+            }\n+\n+            public ImlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+                return groupId(groupId).artifactId(artifactId);\n+            }\n+\n+            public ImlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n+                return groupIdArtifactId(groupId, artifactId).version(version);\n+            }\n+\n+            public ImlBuilder skip(String string) {\n+                return element(\"skip\", $ -> $.text(string));\n+            }\n+\n+            public ImlBuilder id(String s) {\n+                return element(\"id\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder arg(String s) {\n+                return element(\"arg\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder argLine(String s) {\n+                return element(\"argLine\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder source(String s) {\n+                return element(\"source\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder target(String s) {\n+                return element(\"target\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder showWarnings(String s) {\n+                return element(\"showWarnings\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder showDeprecation(String s) {\n+                return element(\"showDeprecation\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder failOnError(String s) {\n+                return element(\"failOnError\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder exists(String s) {\n+                return element(\"exists\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder activeByDefault(String s) {\n+                return element(\"activeByDefault\", $ -> $.text(s));\n+            }\n+\n+            public ImlBuilder executable(String s) {\n+                return element(\"executable\", $ -> $.text(s));\n+            }\n+        }\n+\n+        public static class XMLBuilder extends AbstractXMLBuilder<bldr.Bldr.XMLNode.XMLBuilder> {\n+           XMLBuilder(Element element) {\n+                super(element);\n+            }\n+\n+            public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+                return element(name, XMLBuilder::new, xmlBuilderConsumer);\n+            }\n+\n+            public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+                return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n+            }\n+        }\n+\n+        static XMLNode create(String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+\n+            try {\n+                var doc =\n+                        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+                var element = doc.createElement(nodeName);\n+                doc.appendChild(element);\n+                XMLBuilder xmlBuilder = new XMLBuilder(element);\n+                xmlBuilderConsumer.accept(xmlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static XMLNode createIml(String commentText, Consumer<ImlBuilder> imlBuilderConsumer) {\n+            try {\n+                var doc =\n+                        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+                var comment = doc.createComment(commentText);\n+                doc.appendChild(comment);\n+                var element = doc.createElementNS(uri1.toString(), \"project\");\n+                doc.appendChild(element);\n+                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n+                ImlBuilder imlBuilder = new ImlBuilder(element);\n+                imlBuilderConsumer.accept(imlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public static XMLNode createPom(\n+                String commentText, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            try {\n+                var doc =\n+                        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\n+                var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+                var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+                var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+                var comment = doc.createComment(commentText);\n+                doc.appendChild(comment);\n+                var element = doc.createElementNS(uri1.toString(), \"project\");\n+                doc.appendChild(element);\n+                element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n+                PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n+                pomXmlBuilderConsumer.accept(pomXmlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+            try {\n+                var doc =\n+                        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+                var element = doc.createElementNS(uri.toString(), nodeName);\n+                doc.appendChild(element);\n+                XMLBuilder xmlBuilder = new XMLBuilder(element);\n+                xmlBuilderConsumer.accept(xmlBuilder);\n+                return new XMLNode(element);\n+            } catch (ParserConfigurationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        XMLNode(Element element) {\n+            this.element = element;\n+            this.element.normalize();\n+            NodeList nodeList = element.getChildNodes();\n+            for (int i = 0; i < nodeList.getLength(); i++) {\n+                if (nodeList.item(i) instanceof Element e) {\n+                    this.children.add(new XMLNode(e));\n+                }\n+            }\n+            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+                if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr) {\n+                    this.attrMap.put(attr.getName(), attr.getValue());\n+                }\n+            }\n+        }\n+\n+        public boolean hasAttr(String name) {\n+            return attrMap.containsKey(name);\n+        }\n+\n+        public String attr(String name) {\n+            return attrMap.get(name);\n+        }\n+\n+        static Document parse(InputStream is) {\n+            try {\n+                return javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static Document parse(Path path) {\n+            try {\n+                return parse(Files.newInputStream(path));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        XMLNode(Path path) {\n+            this(parse(path).getDocumentElement());\n+        }\n+\n+        XMLNode(File file) {\n+            this(parse(file.toPath()).getDocumentElement());\n+        }\n+\n+        XMLNode(URL url) throws Throwable {\n+            this(parse(url.openStream()).getDocumentElement());\n+        }\n+\n+        void write(StreamResult streamResult) throws Throwable {\n+            var transformer = TransformerFactory.newInstance().newTransformer();\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n+            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+            transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n+        }\n+\n+        void write(File file) {\n+            try {\n+                write(new StreamResult(file));\n+            } catch (Throwable t) {\n+                throw new RuntimeException(t);\n+            }\n+        }\n+\n+        public void write(XMLFile xmlFile) {\n+            try {\n+                write(new StreamResult(xmlFile.path().toFile()));\n+            } catch (Throwable t) {\n+                throw new RuntimeException(t);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var stringWriter = new StringWriter();\n+            try {\n+                var transformer = TransformerFactory.newInstance().newTransformer();\n+                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+                transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+                transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+                transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n+                return stringWriter.toString();\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        XPathExpression xpath(String expression) {\n+            XPath xpath = XPathFactory.newInstance().newXPath();\n+            try {\n+                return xpath.compile(expression);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Node node(XPathExpression xPathExpression) {\n+            try {\n+                return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Optional<Node> optionalNode(XPathExpression xPathExpression) {\n+            var nodes = nodes(xPathExpression).toList();\n+            return switch (nodes.size()) {\n+                case 0 -> Optional.empty();\n+                case 1 -> Optional.of(nodes.getFirst());\n+                default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n+            };\n+        }\n+\n+        String str(XPathExpression xPathExpression) {\n+            try {\n+                return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        String xpathQueryString(String xpathString) {\n+            try {\n+                return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        NodeList nodeList(XPathExpression xPathExpression) {\n+            try {\n+                return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n+            } catch (XPathExpressionException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Stream<Node> nodes(XPathExpression xPathExpression) {\n+            var nodeList = nodeList(xPathExpression);\n+            List<Node> nodes = new ArrayList<>();\n+            for (int i = 0; i < nodeList.getLength(); i++) {\n+                nodes.add(nodeList.item(i));\n+            }\n+            return nodes.stream();\n+        }\n+\n+        Stream<Element> elements(XPathExpression xPathExpression) {\n+            return nodes(xPathExpression)\n+                    .filter(n -> n instanceof Element)\n+                    .map(n -> (Element) n);\n+        }\n+\n+        Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n+            return elements(xPathExpression).map(e -> new XMLNode(e));\n+        }\n+    }\n+\n+    public static class MavenStyleRepository {\n+        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n+        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n+        public RepoDir dir;\n+\n+        JarFile jarFile(Id id) {\n+            return dir.jarFile(id.artifactAndVersion() + \".jar\");\n+        }\n+\n+        XMLFile pomFile(Id id) {\n+            return dir.xmlFile(id.artifactAndVersion() + \".pom\");\n+        }\n+\n+        public enum Scope {\n+            TEST,\n+            COMPILE,\n+            PROVIDED,\n+            RUNTIME,\n+            SYSTEM;\n+\n+            static Scope of(String name) {\n+                return switch (name.toLowerCase()) {\n+                    case \"test\" -> TEST;\n+                    case \"compile\" -> COMPILE;\n+                    case \"provided\" -> PROVIDED;\n+                    case \"runtime\" -> RUNTIME;\n+                    case \"system\" -> SYSTEM;\n+                    default -> COMPILE;\n+                };\n+            }\n+        }\n+\n+        public record GroupAndArtifactId(GroupId groupId, ArtifactId artifactId) {\n+\n+            public static GroupAndArtifactId of(String groupAndArtifactId) {\n+                int idx = groupAndArtifactId.indexOf('\/');\n+                return of(groupAndArtifactId.substring(0, idx), groupAndArtifactId.substring(idx + 1));\n+            }\n+\n+            public static GroupAndArtifactId of(GroupId groupId, ArtifactId artifactId) {\n+                return new GroupAndArtifactId(groupId, artifactId);\n+            }\n+\n+            public static GroupAndArtifactId of(String groupId, String artifactId) {\n+                return of(GroupId.of(groupId), ArtifactId.of(artifactId));\n+            }\n+\n+            String location() {\n+                return groupId().string().replace('.', '\/') + \"\/\" + artifactId().string();\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return groupId() + \"\/\" + artifactId();\n+            }\n+        }\n+\n+        public sealed interface Id permits DependencyId, bldr.Bldr.MavenStyleRepository.MetaDataId {\n+            MavenStyleRepository mavenStyleRepository();\n+\n+            GroupAndArtifactId groupAndArtifactId();\n+\n+            VersionId versionId();\n+\n+            default String artifactAndVersion() {\n+                return groupAndArtifactId().artifactId().string() + '-' + versionId();\n+            }\n+\n+            default String location() {\n+                return mavenStyleRepository().repoBase + groupAndArtifactId().location() + \"\/\" + versionId();\n+            }\n+\n+            default URL url(String suffix) {\n+                try {\n+                    return new URI(location() + \"\/\" + artifactAndVersion() + \".\" + suffix).toURL();\n+                } catch (MalformedURLException | URISyntaxException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        public record DependencyId(\n+                MavenStyleRepository mavenStyleRepository,\n+                GroupAndArtifactId groupAndArtifactId,\n+                VersionId versionId,\n+                Scope scope,\n+                boolean required)\n+                implements Id {\n+            @Override\n+            public String toString() {\n+                return groupAndArtifactId().toString()\n+                        + \"\/\"\n+                        + versionId()\n+                        + \":\"\n+                        + scope.toString()\n+                        + \":\"\n+                        + (required ? \"Required\" : \"Optiona\");\n+            }\n+        }\n+\n+        public record Pom(MetaDataId metaDataId, XMLNode xmlNode) {\n+            JarFile getJar() {\n+                var jarFile = metaDataId.mavenStyleRepository().jarFile(metaDataId); \/\/ ;\n+                metaDataId.mavenStyleRepository.queryAndCache(metaDataId.jarURL(), jarFile);\n+                return jarFile;\n+            }\n+\n+            String description() {\n+                return xmlNode().xpathQueryString(\"\/project\/description\/text()\");\n+            }\n+\n+            Stream<DependencyId> dependencies() {\n+                return xmlNode()\n+                        .nodes(xmlNode.xpath(\"\/project\/dependencies\/dependency\"))\n+                        .map(node -> new XMLNode((Element) node))\n+                        .map(\n+                                dependency ->\n+                                        new DependencyId(\n+                                                metaDataId().mavenStyleRepository(),\n+                                                bldr.Bldr.MavenStyleRepository.GroupAndArtifactId.of(\n+                                                        bldr.Bldr.MavenStyleRepository.GroupId.of(dependency.xpathQueryString(\"groupId\/text()\")),\n+                                                        bldr.Bldr.MavenStyleRepository.ArtifactId.of(dependency.xpathQueryString(\"artifactId\/text()\"))),\n+                                                bldr.Bldr.MavenStyleRepository.VersionId.of(dependency.xpathQueryString(\"version\/text()\")),\n+                                                bldr.Bldr.MavenStyleRepository.Scope.of(dependency.xpathQueryString(\"scope\/text()\")),\n+                                                !Boolean.parseBoolean(dependency.xpathQueryString(\"optional\/text()\"))));\n+            }\n+\n+            Stream<DependencyId> requiredDependencies() {\n+                return dependencies().filter(DependencyId::required);\n+            }\n+        }\n+\n+        public Optional<Pom> pom(Id id) {\n+            return switch (id) {\n+                case MetaDataId metaDataId -> {\n+                    if (metaDataId.versionId() == VersionId.UNSPECIFIED) {\n+                        \/\/ println(\"what to do when the version is unspecified\");\n+                        yield Optional.empty();\n+                    }\n+                    try {\n+                        yield Optional.of(\n+                                new Pom(\n+                                        metaDataId,\n+                                        queryAndCache(\n+                                                metaDataId.pomURL(), metaDataId.mavenStyleRepository.pomFile(metaDataId))));\n+                    } catch (Throwable e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                case DependencyId dependencyId -> {\n+                    if (metaData(\n+                            id.groupAndArtifactId().groupId().string(),\n+                            id.groupAndArtifactId().artifactId().string())\n+                            instanceof Optional<MetaData> optionalMetaData\n+                            && optionalMetaData.isPresent()) {\n+                        if (optionalMetaData\n+                                .get()\n+                                .metaDataIds()\n+                                .filter(metaDataId -> metaDataId.versionId().equals(id.versionId()))\n+                                .findFirst()\n+                                instanceof Optional<MetaDataId> metaId\n+                                && metaId.isPresent()) {\n+                            yield pom(metaId.get());\n+                        } else {\n+                            yield Optional.empty();\n+                        }\n+                    } else {\n+                        yield Optional.empty();\n+                    }\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected value: \" + id);\n+            };\n+        }\n+\n+        public Optional<Pom> pom(GroupAndArtifactId groupAndArtifactId) {\n+            var metaData = metaData(groupAndArtifactId).orElseThrow();\n+            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n+            return pom(metaDataId);\n+        }\n+\n+        record IdVersions(GroupAndArtifactId groupAndArtifactId, Set<Id> versions) {\n+            static IdVersions of(GroupAndArtifactId groupAndArtifactId) {\n+                return new IdVersions(groupAndArtifactId, new HashSet<>());\n+            }\n+        }\n+\n+        public static class Dag implements ClassPathEntryProvider {\n+            private final MavenStyleRepository repo;\n+            private final List<GroupAndArtifactId> rootGroupAndArtifactIds;\n+            Map<GroupAndArtifactId, IdVersions> nodes = new HashMap<>();\n+            Map<IdVersions, List<IdVersions>> edges = new HashMap<>();\n+\n+            Dag add(Id from, Id to) {\n+                var fromNode =\n+                        nodes.computeIfAbsent(\n+                                from.groupAndArtifactId(), _ -> IdVersions.of(from.groupAndArtifactId()));\n+                fromNode.versions().add(from);\n+                var toNode =\n+                        nodes.computeIfAbsent(\n+                                to.groupAndArtifactId(), _ -> IdVersions.of(to.groupAndArtifactId()));\n+                toNode.versions().add(to);\n+                edges.computeIfAbsent(fromNode, k -> new ArrayList<>()).add(toNode);\n+                return this;\n+            }\n+\n+            void removeUNSPECIFIED() {\n+                nodes\n+                        .values()\n+                        .forEach(\n+                                idversions -> {\n+                                    if (idversions.versions().size() > 1) {\n+                                        List<Id> versions = new ArrayList<>(idversions.versions());\n+                                        idversions.versions().clear();\n+                                        idversions\n+                                                .versions()\n+                                                .addAll(\n+                                                        versions.stream()\n+                                                                .filter(v -> !v.versionId().equals(VersionId.UNSPECIFIED))\n+                                                                .toList());\n+                                        println(idversions);\n+                                    }\n+                                    if (idversions.versions().size() > 1) {\n+                                        throw new IllegalStateException(\"more than one version\");\n+                                    }\n+                                });\n+            }\n+\n+            Dag(MavenStyleRepository repo, List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n+                this.repo = repo;\n+                this.rootGroupAndArtifactIds = rootGroupAndArtifactIds;\n+\n+                Set<Id> unresolved = new HashSet<>();\n+                rootGroupAndArtifactIds.forEach(\n+                        rootGroupAndArtifactId -> {\n+                            var metaData = repo.metaData(rootGroupAndArtifactId).orElseThrow();\n+                            var metaDataId = metaData.latestMetaDataId().orElseThrow();\n+                            var optionalPom = repo.pom(rootGroupAndArtifactId);\n+\n+                            if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n+                                pom.requiredDependencies()\n+                                        .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n+                                        .forEach(\n+                                                dependencyId -> {\n+                                                    add(metaDataId, dependencyId);\n+                                                    unresolved.add(dependencyId);\n+                                                });\n+                            }\n+                        });\n+\n+                while (!unresolved.isEmpty()) {\n+                    var resolveSet = new HashSet<>(unresolved);\n+                    unresolved.clear();\n+                    resolveSet.forEach(id -> {\n+                                if (repo.pom(id) instanceof Optional<Pom> p && p.isPresent()) {\n+                                    p.get()\n+                                            .requiredDependencies()\n+                                            .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n+                                            .forEach(\n+                                                    dependencyId -> {\n+                                                        unresolved.add(dependencyId);\n+                                                        add(id, dependencyId);\n+                                                    });\n+                                }\n+                            });\n+                }\n+                removeUNSPECIFIED();\n+            }\n+\n+            @Override\n+            public List<ClassPathEntry> classPathEntries() {\n+                return classPath().classPathEntries();\n+            }\n+\n+            ClassPath classPath() {\n+\n+                ClassPath jars = ClassPath.of();\n+                nodes\n+                        .keySet()\n+                        .forEach(\n+                                id -> {\n+                                    Optional<Pom> optionalPom = repo.pom(id);\n+                                    if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n+                                        jars.add(pom.getJar());\n+                                    } else {\n+                                        throw new RuntimeException(\"No pom for \" + id + \" needed by \" + id);\n+                                    }\n+                                });\n+                return jars;\n+            }\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(String... rootGroupAndArtifactIds) {\n+            return classPathEntries(Stream.of(rootGroupAndArtifactIds).map(GroupAndArtifactId::of).toList());\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(GroupAndArtifactId... rootGroupAndArtifactIds) {\n+            return classPathEntries(List.of(rootGroupAndArtifactIds));\n+        }\n+\n+        public ClassPathEntryProvider classPathEntries(List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n+          StringBuilder sb = new StringBuilder();\n+          rootGroupAndArtifactIds.forEach(groupAndArtifactId->sb.append(sb.isEmpty() ?\"\":\"-\").append(groupAndArtifactId.groupId+\"-\"+groupAndArtifactId.artifactId));\n+          System.out.println(sb);\n+          ClassPathEntryProvider classPathEntries=null;\n+          var pathFileName = sb+\"-path.xml\";\n+          var pathFile = dir.xmlFile(pathFileName);\n+          if (pathFile.exists()){\n+              System.out.println(pathFileName + \" exists \" + pathFile.path().toString());\n+              XMLNode path = new XMLNode(pathFile.path());\n+              ClassPath classPath = ClassPath.of();\n+              path.nodes(path.xpath(\"\/path\/jar\/text()\")).forEach(e->\n+                      classPath.add(dir.jarFile(e.getNodeValue()))\n+              );\n+              classPathEntries = classPath;\n+          }else {\n+             var finalClassPathEntries =  new Dag(this, rootGroupAndArtifactIds);\n+                  XMLNode.create(\"path\", xml-> {\n+                      finalClassPathEntries.classPathEntries().forEach(cpe ->\n+                              xml.element(\"jar\",jar->jar.text(dir.path().relativize(cpe.path()).toString()))\n+                      );\n+                  }).write(pathFile);\n+             System.out.println(\"created \"+pathFile.path());\n+             classPathEntries = finalClassPathEntries;\n+          }\n+            return classPathEntries;\n+        }\n+\n+        public record VersionId(Integer maj, Integer min, Integer point, String classifier)\n+                implements Comparable<VersionId> {\n+            static Integer integerOrNull(String s) {\n+                return (s == null || s.isEmpty()) ? null : Integer.parseInt(s);\n+            }\n+\n+            public static Pattern pattern = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(.*))?)?$\");\n+            static VersionId UNSPECIFIED = new VersionId(null, null, null, null);\n+\n+            static VersionId of(String version) {\n+                Matcher matcher = pattern.matcher(version);\n+                if (matcher.matches()) {\n+                    return new VersionId(\n+                            integerOrNull(matcher.group(1)),\n+                            integerOrNull(matcher.group(2)),\n+                            integerOrNull(matcher.group(3)),\n+                            matcher.group(4));\n+                } else {\n+                    return UNSPECIFIED;\n+                }\n+            }\n+\n+            int cmp(Integer v1, Integer v2) {\n+                if (v1 == null && v2 == null) {\n+                    return 0;\n+                }\n+                if (v1 == null) {\n+                    return -v2;\n+                } else if (v2 == null) {\n+                    return v1;\n+                } else {\n+                    return v1 - v2;\n+                }\n+            }\n+\n+            @Override\n+            public int compareTo(VersionId o) {\n+                if (cmp(maj(), o.maj()) == 0) {\n+                    if (cmp(min(), o.min()) == 0) {\n+                        if (cmp(point(), o.point()) == 0) {\n+                            return classifier().compareTo(o.classifier());\n+                        } else {\n+                            return cmp(point(), o.point());\n+                        }\n+                    } else {\n+                        return cmp(min(), o.min());\n+                    }\n+                } else {\n+                    return cmp(maj(), o.maj());\n+                }\n+            }\n+\n+            @Override\n+            public String toString() {\n+                StringBuilder sb = new StringBuilder();\n+                if (maj() != null) {\n+                    sb.append(maj());\n+                    if (min() != null) {\n+                        sb.append(\".\").append(min());\n+                        if (point() != null) {\n+                            sb.append(\".\").append(point());\n+                            if (classifier() != null) {\n+                                sb.append(classifier());\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    sb.append(\"UNSPECIFIED\");\n+                }\n+                return sb.toString();\n+            }\n+        }\n+\n+        public record GroupId(String string) {\n+            public static GroupId of(String s) {\n+                return new GroupId(s);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return string;\n+            }\n+        }\n+\n+        public record ArtifactId(String string) {\n+            static ArtifactId of(String string) {\n+                return new ArtifactId(string);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return string;\n+            }\n+        }\n+\n+        public record MetaDataId(\n+                MavenStyleRepository mavenStyleRepository,\n+                GroupAndArtifactId groupAndArtifactId,\n+                VersionId versionId,\n+                Set<String> downloadables,\n+                Set<String> tags)\n+                implements Id {\n+\n+            public URL pomURL() {\n+                return url(\"pom\");\n+            }\n+\n+            public URL jarURL() {\n+                return url(\"jar\");\n+            }\n+\n+            public XMLNode getPom() {\n+                if (downloadables.contains(\".pom\")) {\n+                    return mavenStyleRepository.queryAndCache(\n+                            url(\"pom\"), mavenStyleRepository.dir.xmlFile(artifactAndVersion() + \".pom\"));\n+                } else {\n+                    throw new IllegalStateException(\"no pom\");\n+                }\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return groupAndArtifactId().toString() + \".\" + versionId();\n+            }\n+        }\n+\n+        public MavenStyleRepository(RepoDir dir) {\n+            this.dir = dir.create();\n+        }\n+\n+        JarFile queryAndCache(URL query, JarFile jarFile) {\n+            try {\n+                if (!jarFile.exists()) {\n+                    print(\"Querying and caching \" + jarFile.fileName());\n+                    println(\" downloading \" + query);\n+                    curl(query, jarFile.path());\n+                } else {\n+                    \/\/ println(\"Using cached \" + jarFile.fileName());\n+\n+                }\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            return jarFile;\n+        }\n+\n+        XMLNode queryAndCache(URL query, XMLFile xmlFile) {\n+            XMLNode xmlNode = null;\n+            try {\n+                if (!xmlFile.exists()) {\n+                    print(\"Querying and caching \" + xmlFile.fileName());\n+                    println(\" downloading \" + query);\n+                    xmlNode = new XMLNode(query);\n+                    xmlNode.write(xmlFile.path().toFile());\n+                } else {\n+                    \/\/ println(\"Using cached \" + xmlFile.fileName());\n+                    xmlNode = new XMLNode(xmlFile.path());\n+                }\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            return xmlNode;\n+        }\n+\n+        public record MetaData(\n+                MavenStyleRepository mavenStyleRepository,\n+                GroupAndArtifactId groupAndArtifactId,\n+                XMLNode xmlNode) {\n+\n+            public Stream<MetaDataId> metaDataIds() {\n+                return xmlNode\n+                        .xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n+                        .map(\n+                                xmln ->\n+                                        new MetaDataId(\n+                                                this.mavenStyleRepository,\n+                                                bldr.Bldr.MavenStyleRepository.GroupAndArtifactId.of(\n+                                                        bldr.Bldr.MavenStyleRepository.GroupId.of(xmln.xpathQueryString(\"str[@name='g']\/text()\")),\n+                                                        bldr.Bldr.MavenStyleRepository.ArtifactId.of(xmln.xpathQueryString(\"str[@name='a']\/text()\"))),\n+                                                bldr.Bldr.MavenStyleRepository.VersionId.of(xmln.xpathQueryString(\"str[@name='v']\/text()\")),\n+                                                new HashSet<>(\n+                                                        xmln.nodes(xmln.xpath(\"arr[@name='ec']\/str\/text()\"))\n+                                                                .map(Node::getNodeValue)\n+                                                                .toList()),\n+                                                new HashSet<>(\n+                                                        xmln.nodes(xmln.xpath(\"arr[@name='tags']\/str\/text()\"))\n+                                                                .map(Node::getNodeValue)\n+                                                                .toList())));\n+            }\n+\n+            public Stream<MetaDataId> sortedMetaDataIds() {\n+                return metaDataIds().sorted(Comparator.comparing(MetaDataId::versionId));\n+            }\n+\n+            public Optional<MetaDataId> latestMetaDataId() {\n+                return metaDataIds().max(Comparator.comparing(MetaDataId::versionId));\n+            }\n+\n+            public Optional<MetaDataId> getMetaDataId(VersionId versionId) {\n+                return metaDataIds().filter(id -> versionId.compareTo(id.versionId()) == 0).findFirst();\n+            }\n+        }\n+\n+        public Optional<MetaData> metaData(String groupId, String artifactId) {\n+            return metaData(GroupAndArtifactId.of(groupId, artifactId));\n+        }\n+\n+        public Optional<MetaData> metaData(GroupAndArtifactId groupAndArtifactId) {\n+            try {\n+                var query = \"g:\" + groupAndArtifactId.groupId() + \" AND a:\" + groupAndArtifactId.artifactId();\n+                URL rowQueryUrl =\n+                        new URI(\n+                                searchBase\n+                                        + \"select?q=\"\n+                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n+                                        + \"&core=gav&wt=xml&rows=0\")\n+                                .toURL();\n+                var rowQueryResponse = new XMLNode(rowQueryUrl);\n+                var numFound = rowQueryResponse.xpathQueryString(\"\/response\/result\/@numFound\");\n+\n+                URL url =\n+                        new URI(\n+                                searchBase\n+                                        + \"select?q=\"\n+                                        + URLEncoder.encode(query, StandardCharsets.UTF_8)\n+                                        + \"&core=gav&wt=xml&rows=\"\n+                                        + numFound)\n+                                .toURL();\n+                try {\n+                    \/\/ println(url);\n+                    var xmlNode =\n+                            queryAndCache(url, dir.xmlFile(groupAndArtifactId.artifactId() + \".meta.xml\"));\n+                    \/\/ var numFound2 = xmlNode.xpathQueryString(\"\/response\/result\/@numFound\");\n+                    \/\/ var start = xmlNode.xpathQueryString(\"\/response\/result\/@start\");\n+                    \/\/ var rows =\n+                    \/\/ xmlNode.xpathQueryString(\"\/response\/lst[@name='responseHeader']\/lst[@name='params']\/str[@name='rows']\/text()\");\n+                    \/\/ println(\"numFound = \"+numFound+\" rows =\"+rows+ \" start =\"+start);\n+                    if (numFound.isEmpty() || numFound.equals(\"0\")) {\n+                        return Optional.empty();\n+                    } else {\n+                        return Optional.of(new MetaData(this, groupAndArtifactId, xmlNode));\n+                    }\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class IntelliJ {\n+        public static class IntellijArtifact {\n+            DirEntry projectDir;\n+            XMLNode root;\n+\n+            Stream<XMLNode> query(String xpath) {\n+                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n+            }\n+\n+            IntellijArtifact(DirEntry projectDir, XMLNode root) {\n+                this.projectDir = projectDir;\n+                this.root = root;\n+            }\n+        }\n+\n+        public static class Workspace extends IntellijArtifact {\n+\n+            record Application(XMLNode xmlNode) {\n+            }\n+\n+            List<Application> applications;\n+\n+            Workspace(DirEntry projectDir, XMLNode root) {\n+                super(projectDir, root);\n+                this.applications =\n+                        query(\"\/project\/component[@name='RunManager']\/configuration\")\n+                                .map(Application::new)\n+                                .toList();\n+            }\n+        }\n+\n+        public static class Compiler extends IntellijArtifact {\n+            public record JavacSettings(XMLNode xmlNode) {\n+                public String getAdditionalOptions() {\n+                    return xmlNode.xpathQueryString(\"option[@name='ADDITIONAL_OPTIONS_STRING']\/@value\");\n+                }\n+            }\n+\n+            public JavacSettings javacSettings;\n+\n+            Compiler(DirEntry projectDir, XMLNode root) {\n+                super(projectDir, root);\n+                this.javacSettings =\n+                        new JavacSettings(query(\"\/project\/component[@name='JavacSettings']\").findFirst().get());\n+            }\n+        }\n+\n+        public static class ImlGraph extends IntellijArtifact {\n+            public record Module(Path imlPath, XMLNode xmlNode) {\n+                @Override\n+                public String toString() {\n+                    return name();\n+                }\n+\n+                public String name() {\n+                    return imlPath.getFileName().toString();\n+                }\n+\n+                public SourcePath getSourcePath() {\n+                    return null;\n+                }\n+\n+                Stream<XMLNode> query(String xpath) {\n+                    return xmlNode.nodes(xmlNode.xpath(xpath)).map(e -> new XMLNode((Element) e));\n+                }\n+            }\n+\n+            Stream<XMLNode> query(String xpath) {\n+                return root.nodes(root.xpath(xpath)).map(e -> new XMLNode((Element) e));\n+            }\n+\n+            Set<Module> modules = new HashSet<>();\n+            public Map<Module, List<Module>> fromToDependencies = new HashMap<>();\n+            Map<Module, List<Module>> toFromDependencies = new HashMap<>();\n+\n+            ImlGraph(DirEntry projectDir, XMLNode root) {\n+                super(projectDir, root);\n+                Map<String, Module> nameToModule = new HashMap<>();\n+                query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n+                        .map(\n+                                xmlNode ->\n+                                        Path.of(\n+                                                xmlNode\n+                                                        .attrMap\n+                                                        .get(\"filepath\")\n+                                                        .replace(\"$PROJECT_DIR$\", projectDir.path().toString())))\n+                        .map(path -> new Module(path, new XMLNode(path)))\n+                        .forEach(\n+                                module -> {\n+                                    modules.add(module);\n+                                    nameToModule.put(module.name(), module);\n+                                });\n+                modules.forEach(\n+                        module ->\n+                                module\n+                                        .xmlNode\n+                                        .nodes(root.xpath(\"\/module\/component\/orderEntry[@type='module']\"))\n+                                        .map(e -> new XMLNode((Element) e))\n+                                        .forEach(\n+                                                e -> {\n+                                                    var dep = nameToModule.get(e.attrMap.get(\"module-name\") + \".iml\");\n+                                                    fromToDependencies.computeIfAbsent(module, _ -> new ArrayList<>()).add(dep);\n+                                                    toFromDependencies.computeIfAbsent(dep, _ -> new ArrayList<>()).add(module);\n+                                                }));\n+            }\n+        }\n+\n+        public static class Project {\n+            public DirEntry intellijDir;\n+            public ImlGraph imlGraph;\n+            public Workspace workSpace;\n+            public Compiler compiler;\n+\n+            public Project(DirEntry intellijDir) {\n+                this.intellijDir = intellijDir;\n+                var ideaDir = intellijDir.existingDir(\".idea\");\n+                imlGraph = new ImlGraph(intellijDir, new XMLNode(ideaDir.xmlFile(\"modules.xml\").path()));\n+                workSpace = new Workspace(intellijDir, new XMLNode(ideaDir.xmlFile(\"workspace.xml\").path()));\n+                compiler = new Compiler(intellijDir, new XMLNode(ideaDir.xmlFile(\"compiler.xml\").path()));\n+            }\n+        }\n+\n+    }\n","filename":"hat\/bldr\/Bldr.java","additions":2638,"deletions":165,"binary":false,"changes":2803,"status":"modified"},{"patch":"@@ -1,313 +0,0 @@\n-package bldr;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.regex.Matcher;\n-\n-import static bldr.Bldr.assertExists;\n-import static java.io.IO.println;\n-\n-public class CMakeProbe implements Capabilities.Probe {\n-    public interface CMakeVar<T> {\n-        String name();\n-\n-        T value();\n-    }\n-\n-    public record CMakeTypedVar(String name, String type, String value, String comment)\n-            implements CMakeVar<String> {\n-        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n-\n-        CMakeTypedVar(Matcher matcher, String comment) {\n-            this(\n-                    \"CMAKE_\" + matcher.group(1).trim(),\n-                    matcher.group(2).trim(),\n-                    matcher.group(3).trim(),\n-                    comment.substring(2).trim());\n-        }\n-\n-        static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n-            return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n-        }\n-    }\n-\n-    public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n-        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-        CMakeSimpleVar(Matcher matcher) {\n-            this(\n-                    \"CMAKE_\" + matcher.group(1).trim(),\n-                    (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n-        }\n-\n-        static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-            return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n-        }\n-    }\n-\n-    public record CMakeDirVar(String name, Bldr.DirPathHolder value) implements CMakeVar {\n-        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-        static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-            return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n-        }\n-    }\n-\n-    public record CMakeContentVar(String name, String value) implements CMakeVar {\n-        static final Regex startRegex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n-        static final Regex endRegex = Regex.of(\"^(.*)\\\\}>\\\\}$\");\n-    }\n-\n-    public record CMakeRecipeVar(String name, String value) implements CMakeVar<String> {\n-        static final Regex varPattern = Regex.of(\"<([^>]*)>\");\n-        static final Regex regex = Regex.of(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n-\n-        CMakeRecipeVar(Matcher matcher) {\n-            this(\n-                    \"CMAKE_\" + matcher.group(1).trim(),\n-                    \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n-        }\n-\n-        public String expandRecursively(Map<String, CMakeVar<?>> varMap, String value) { \/\/ recurse\n-            String result = value;\n-            if (varPattern.pattern().matcher(value) instanceof Matcher matcher && matcher.find()) {\n-                var v = matcher.group(1);\n-                if (varMap.containsKey(v)) {\n-                    String replacement = varMap.get(v).value().toString();\n-                    result =\n-                            expandRecursively(\n-                                    varMap,\n-                                    value.substring(0, matcher.start())\n-                                            + replacement\n-                                            + value.substring(matcher.end()));\n-                }\n-            }\n-            return result;\n-        }\n-\n-        public String expand(Map<String, CMakeVar<?>> vars) {\n-            return expandRecursively(vars, value());\n-        }\n-\n-        static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n-            return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n-        }\n-    }\n-\n-    Bldr.BuildDir dir;\n-\n-    Map<String, CMakeVar<?>> varMap = new HashMap<>();\n-\n-    public CMakeProbe(Bldr.BuildDir dir, Capabilities capabilities) {\n-        this.dir = Bldr.BuildDir.of(dir.path(\"cmakeprobe\"));\n-        this.dir.clean();\n-\n-        try {\n-            this.dir.cmakeLists($-> {$\n-                    .append(\n-                         \"\"\"\n-                         cmake_minimum_required(VERSION 3.21)\n-                         project(cmakeprobe)\n-                         set(CMAKE_CXX_STANDARD 14)\n-                         foreach(VarName ${VarNames})\n-                            message(\"${VarName}={<{${${VarName}}}>}\")\n-                         endforeach()\n-                         \"\"\");\n-                        capabilities\n-                                .capabilities()\n-                                .filter(capability -> capability instanceof Capabilities.CMakeCapability)\n-                                .map(capability -> (Capabilities.CMakeCapability) capability)\n-                                .forEach(p -> $.append(\"find_package(\").append(p.name).append(\")\\n\")\n-                        );\n-\n-                        \/\/println(\"content = {\"+$+\"}\");\n-                    });\n-\n-            var cmakeProcessBuilder =\n-                    new ProcessBuilder()\n-                            .directory(this.dir.path().toFile())\n-                            .redirectErrorStream(true)\n-                            .command(\"cmake\", \"-LAH\")\n-                            .start();\n-            List<String> lines =\n-                    new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream()))\n-                            .lines()\n-                            .toList();\n-\n-            String comment = null;\n-            String contentName = null;\n-            StringBuilder content = null;\n-\n-            for (String line : lines) {\n-\n-             \/\/   frameworkMap.values().forEach(framework ->\n-               \/\/     framework.regex.matches(line,\n-                \/\/            m->println(line)\n-                 \/\/   )\n-                \/\/);\n-                if (line.startsWith(\"\/\/\")) {\n-                    comment = line;\n-                    content = null;\n-\n-                } else if (comment != null) {\n-                    if (CMakeTypedVar.onMatch(\n-                            line,\n-                            comment,\n-                            v -> {\n-                                if (varMap.containsKey(v.name())) {\n-                                    var theVar = varMap.get(v.name());\n-                                    if (theVar.value().equals(v.value())) {\n-                                      \/*  println(\n-                                                \"replacing duplicate variable with typed variant with the name same value\"\n-                                                        + v\n-                                                        + theVar);*\/\n-                                    } else {\n-                                        throw new IllegalStateException(\n-                                                \"Duplicate variable name different value: \" + v + theVar);\n-                                    }\n-                                    varMap.put(v.name(), v);\n-                                } else {\n-                                    varMap.put(v.name(), v);\n-                                }\n-                            })) {\n-                    } else {\n-                        println(\"failed to parse \" + line);\n-                    }\n-                    comment = null;\n-                    content = null;\n-                    contentName = null;\n-                } else if (!line.isEmpty()) {\n-                    if (content != null) {\n-                        if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher\n-                                && matcher.matches()) {\n-                            content.append(\"\\n\").append(matcher.group(1));\n-                            var v = new CMakeContentVar(contentName, content.toString());\n-                            contentName = null;\n-                            content = null;\n-                            varMap.put(v.name(), v);\n-                        } else {\n-                            content.append(\"\\n\").append(line);\n-                        }\n-                    } else if (!line.endsWith(\"}>}\")\n-                            && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher\n-                            && matcher.matches()) {\n-                        contentName = \"CMAKE_\" + matcher.group(1);\n-                        content = new StringBuilder(matcher.group(2));\n-                    } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher\n-                            && matcher.matches()) {\n-                        CMakeVar<String> v = new CMakeRecipeVar(matcher);\n-                        if (varMap.containsKey(v.name())) {\n-                            var theVar = varMap.get(v.name());\n-                            if (theVar.value().equals(v.value())) {\n-                              \/\/  println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                            } else {\n-                                throw new IllegalStateException(\n-                                        \"Duplicate variable name different value: \" + v + theVar);\n-                            }\n-                            varMap.put(v.name(), v);\n-                        } else {\n-                            varMap.put(v.name(), v);\n-                        }\n-                    } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher\n-                            && matcher.matches()) {\n-                        var v =  new CMakeSimpleVar(matcher);\n-                        if (varMap.containsKey(v.name())) {\n-                            var theVar = varMap.get(v.name());\n-                            if (theVar.value().equals(v.value())) {\n-                               \/\/ println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                            } else {\n-                                \/\/throw new IllegalStateException(\n-                                  \/\/      \"Duplicate variable name different vars: \" + v + theVar);\n-                            }\n-                            \/\/ note we don't replace a Typed with a Simple\n-                        } else {\n-                            varMap.put(v.name(), v);\n-                        }\n-                    } else {\n-                       \/\/ println(\"Skipping \" + line);\n-                    }\n-                }\n-            }\n-\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe);\n-        }\n-\n-        capabilities\n-                .capabilities()\n-                .filter(capability -> capability instanceof Capabilities.CMakeCapability)\n-                .map(capability->(Capabilities.CMakeCapability)capability)\n-                .forEach(capability -> capability.setCmakeProbe(this));\n-\n-    }\n-\n-    Bldr.ObjectFile cxxCompileObject(\n-            Bldr.ObjectFile target, Bldr.CppSourceFile source, List<String> frameworks) {\n-        CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n-        Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-        localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n-        localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n-        localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n-        localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.path().toString()));\n-        localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.path().toString()));\n-        String executable = compileObject.expand(localVars);\n-        println(executable);\n-        return target;\n-    }\n-\n-    Bldr.ExecutableFile cxxLinkExecutable(\n-            Bldr.ExecutableFile target, List<Bldr.ObjectFile> objFiles, List<String> frameworks) {\n-        CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n-        Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-        String executable = linkExecutable.expand(localVars);\n-        println(executable);\n-        return target;\n-    }\n-\n-    Bldr.SharedLibraryFile cxxCreateSharedLibrary(\n-            Bldr.SharedLibraryFile target, List<Bldr.ObjectFile> objFiles, List<String> frameworks) {\n-        CMakeRecipeVar createSharedLibrary =\n-                (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n-        Map<String, CMakeVar<?>> localVars = new HashMap<>(varMap);\n-        String executable = createSharedLibrary.expand(localVars);\n-        println(executable);\n-        return target;\n-    }\n-\n-\n-    public String value(String key) {\n-        var  v = varMap.get(key);\n-        return v.value().toString();\n-    }\n-\n-    public  boolean hasKey(String includeDirKey) {\n-        return varMap.containsKey(includeDirKey);\n-    }\n-\n-    public static void main(String[] args) {\n-        var hatDir = assertExists(Bldr.Dir.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\"));\n-        var buildDir = hatDir.buildDir(\"build\");\n-        var backends = hatDir.dir(\"backends\");\n-        var backend = backends.dir(\"opencl\");\n-        var cppDir = backend.dir(\"cpp\");\n-        var opencl = Capabilities.OpenCL.of();\n-        var opengl = Capabilities.OpenGL.of();\n-        var cuda =  Capabilities.CUDA.of();\n-        var hip =  Capabilities.HIP.of();\n-        Capabilities capabilities = Capabilities.of(opencl, opengl, cuda, hip);\n-        var cmake = new CMakeProbe(buildDir,capabilities);\n-        var clinfoObj =\n-                cmake.cxxCompileObject(\n-                        buildDir.objectFile(\"clinfo.cpp.o\"),\n-                        cppDir.cppSourceFile(\"clinfo.cpp\"),\n-                        List.of(\"OpenCL\"));\n-        var clinfo =\n-                cmake.cxxLinkExecutable(\n-                        buildDir.executableFile(\"clinfo\"), List.of(clinfoObj), List.of(\"OpenCL\"));\n-    }\n-}\n","filename":"hat\/bldr\/CMakeProbe.java","additions":0,"deletions":313,"binary":false,"changes":313,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-package bldr;\n-\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-\n-public class Capabilities {\n-    interface Probe{\n-\n-    }\n-    public static abstract class Capability {\n-        final public String name;\n-        Capability(String name) {\n-            this.name=name;\n-        }\n-        public abstract boolean available();\n-    }\n-    public static abstract class CMakeCapability extends Capability{\n-        CMakeProbe cmakeProbe;\n-        CMakeCapability(String name) {\n-            super(name);\n-        }\n-        public  void setCmakeProbe(CMakeProbe cmakeProbe){\n-            this.cmakeProbe = cmakeProbe;\n-        }\n-    }\n-\n-    public Map<String, Capability> capabilityMap = new HashMap<>();\n-\n-    public static Capabilities of(Capability ... capabilities) {\n-        return new Capabilities(capabilities);\n-    }\n-\n-    public Stream<Capability> capabilities() {\n-        return capabilityMap.values().stream();\n-    }\n-    public Stream<Capability> capabilities(Predicate<Capability> filter) {\n-        return capabilities().filter(filter);\n-    }\n-\n-    public boolean capabilityIsAvailable(String name) {\n-        return capabilities().anyMatch(c-> c.name.equalsIgnoreCase(name));\n-    }\n-\n-    private Capabilities(Capability ... capabilities){\n-        List.of(capabilities).forEach(capability ->\n-                capabilityMap.put(capability.name, capability)\n-        );\n-    }\n-\n-    public static class OpenCL extends CMakeCapability {\n-        public static String includeDirKey  = \"CMAKE_OpenCL_INCLUDE_DIR\";\n-        public OpenCL() {\n-            super(\"OpenCL\");\n-        }\n-        public static OpenCL of(){\n-            return new OpenCL();\n-        }\n-\n-        @Override\n-        public boolean available() {\n-            return cmakeProbe.hasKey(includeDirKey);\n-        }\n-\n-        Bldr.Dir includeDir(){\n-            return Bldr.Dir.of(Path.of(cmakeProbe.value(includeDirKey)));\n-        }\n-    }\n-\n-    public static class OpenGL extends CMakeCapability {\n-        public static String includeDirKey  = \"CMAKE_OPENGL_INCLUDE_DIR\";\n-        public OpenGL() {\n-            super(\"OpenGL\");\n-        }\n-        public static OpenGL of(){\n-            return new OpenGL();\n-        }\n-        @Override\n-        public boolean available() {\n-            return cmakeProbe.hasKey(includeDirKey);\n-        }\n-        Bldr.Dir includeDir(){\n-            return Bldr.Dir.of(Path.of(cmakeProbe.value(includeDirKey)));\n-        }\n-    }\n-\n-    public static class HIP extends CMakeCapability {\n-        public HIP() {\n-            super(\"HIP\");\n-        }\n-        public static HIP of(){\n-            return new HIP();\n-        }\n-        @Override\n-        public boolean available() {\n-            return false;\n-        }\n-    }\n-    public static class CUDA extends CMakeCapability {\n-        public static String sdkRootDirKey  = \"CMAKE_CUDA_SDK_ROOT_DIR\";\n-        public static String sdkRootDirNotFoundValue  = \"CUDA_SDK_ROOT_DIR-NOTFOUND\";\n-        public CUDA() {\n-            super(\"CUDA\");\n-        }\n-        public static CUDA of(){\n-            return new CUDA();\n-        }\n-        @Override\n-        public boolean available() {\n-            return cmakeProbe.hasKey(sdkRootDirKey) && !cmakeProbe.value(sdkRootDirKey).equals(sdkRootDirNotFoundValue);\n-        }\n-    }\n-\n-\n-\n-}\n","filename":"hat\/bldr\/Capabilities.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,604 +0,0 @@\n-package bldr;\n-\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-\n-import static bldr.Bldr.curl;\n-import static java.io.IO.print;\n-import static java.io.IO.println;\n-\n-public class MavenStyleRepository {\n-    private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n-    private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n-    public Bldr.RepoDir dir;\n-\n-    Bldr.JarFile jarFile(Id id) {\n-        return dir.jarFile(id.artifactAndVersion() + \".jar\");\n-    }\n-\n-    Bldr.XMLFile pomFile(Id id) {\n-        return dir.xmlFile(id.artifactAndVersion() + \".pom\");\n-    }\n-\n-    public enum Scope {\n-        TEST,\n-        COMPILE,\n-        PROVIDED,\n-        RUNTIME,\n-        SYSTEM;\n-\n-        static Scope of(String name) {\n-            return switch (name.toLowerCase()) {\n-                case \"test\" -> TEST;\n-                case \"compile\" -> COMPILE;\n-                case \"provided\" -> PROVIDED;\n-                case \"runtime\" -> RUNTIME;\n-                case \"system\" -> SYSTEM;\n-                default -> COMPILE;\n-            };\n-        }\n-    }\n-\n-    public record GroupAndArtifactId(GroupId groupId, ArtifactId artifactId) {\n-\n-        public static GroupAndArtifactId of(String groupAndArtifactId) {\n-            int idx = groupAndArtifactId.indexOf('\/');\n-            return of(groupAndArtifactId.substring(0, idx), groupAndArtifactId.substring(idx + 1));\n-        }\n-\n-        public static GroupAndArtifactId of(GroupId groupId, ArtifactId artifactId) {\n-            return new GroupAndArtifactId(groupId, artifactId);\n-        }\n-\n-        public static GroupAndArtifactId of(String groupId, String artifactId) {\n-            return of(GroupId.of(groupId), ArtifactId.of(artifactId));\n-        }\n-\n-        String location() {\n-            return groupId().string().replace('.', '\/') + \"\/\" + artifactId().string();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return groupId() + \"\/\" + artifactId();\n-        }\n-    }\n-\n-    public sealed interface Id permits DependencyId, MetaDataId {\n-        MavenStyleRepository mavenStyleRepository();\n-\n-        GroupAndArtifactId groupAndArtifactId();\n-\n-        VersionId versionId();\n-\n-        default String artifactAndVersion() {\n-            return groupAndArtifactId().artifactId().string() + '-' + versionId();\n-        }\n-\n-        default String location() {\n-            return mavenStyleRepository().repoBase + groupAndArtifactId().location() + \"\/\" + versionId();\n-        }\n-\n-        default URL url(String suffix) {\n-            try {\n-                return new URI(location() + \"\/\" + artifactAndVersion() + \".\" + suffix).toURL();\n-            } catch (MalformedURLException | URISyntaxException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    public record DependencyId(\n-            MavenStyleRepository mavenStyleRepository,\n-            GroupAndArtifactId groupAndArtifactId,\n-            VersionId versionId,\n-            Scope scope,\n-            boolean required)\n-            implements Id {\n-        @Override\n-        public String toString() {\n-            return groupAndArtifactId().toString()\n-                    + \"\/\"\n-                    + versionId()\n-                    + \":\"\n-                    + scope.toString()\n-                    + \":\"\n-                    + (required ? \"Required\" : \"Optiona\");\n-        }\n-    }\n-\n-    public record Pom(MetaDataId metaDataId, XMLNode xmlNode) {\n-        Bldr.JarFile getJar() {\n-            var jarFile = metaDataId.mavenStyleRepository().jarFile(metaDataId); \/\/ ;\n-            metaDataId.mavenStyleRepository.queryAndCache(metaDataId.jarURL(), jarFile);\n-            return jarFile;\n-        }\n-\n-        String description() {\n-            return xmlNode().xpathQueryString(\"\/project\/description\/text()\");\n-        }\n-\n-        Stream<DependencyId> dependencies() {\n-            return xmlNode()\n-                    .nodes(xmlNode.xpath(\"\/project\/dependencies\/dependency\"))\n-                    .map(node -> new XMLNode((Element) node))\n-                    .map(\n-                            dependency ->\n-                                    new DependencyId(\n-                                            metaDataId().mavenStyleRepository(),\n-                                            GroupAndArtifactId.of(\n-                                                    GroupId.of(dependency.xpathQueryString(\"groupId\/text()\")),\n-                                                    ArtifactId.of(dependency.xpathQueryString(\"artifactId\/text()\"))),\n-                                            VersionId.of(dependency.xpathQueryString(\"version\/text()\")),\n-                                            Scope.of(dependency.xpathQueryString(\"scope\/text()\")),\n-                                            !Boolean.parseBoolean(dependency.xpathQueryString(\"optional\/text()\"))));\n-        }\n-\n-        Stream<DependencyId> requiredDependencies() {\n-            return dependencies().filter(DependencyId::required);\n-        }\n-    }\n-\n-    public Optional<Pom> pom(Id id) {\n-        return switch (id) {\n-            case MetaDataId metaDataId -> {\n-                if (metaDataId.versionId() == VersionId.UNSPECIFIED) {\n-                    \/\/ println(\"what to do when the version is unspecified\");\n-                    yield Optional.empty();\n-                }\n-                try {\n-                    yield Optional.of(\n-                            new Pom(\n-                                    metaDataId,\n-                                    queryAndCache(\n-                                            metaDataId.pomURL(), metaDataId.mavenStyleRepository.pomFile(metaDataId))));\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-            case DependencyId dependencyId -> {\n-                if (metaData(\n-                        id.groupAndArtifactId().groupId().string(),\n-                        id.groupAndArtifactId().artifactId().string())\n-                        instanceof Optional<MetaData> optionalMetaData\n-                        && optionalMetaData.isPresent()) {\n-                    if (optionalMetaData\n-                            .get()\n-                            .metaDataIds()\n-                            .filter(metaDataId -> metaDataId.versionId().equals(id.versionId()))\n-                            .findFirst()\n-                            instanceof Optional<MetaDataId> metaId\n-                            && metaId.isPresent()) {\n-                        yield pom(metaId.get());\n-                    } else {\n-                        yield Optional.empty();\n-                    }\n-                } else {\n-                    yield Optional.empty();\n-                }\n-            }\n-            default -> throw new IllegalStateException(\"Unexpected value: \" + id);\n-        };\n-    }\n-\n-    public Optional<Pom> pom(GroupAndArtifactId groupAndArtifactId) {\n-        var metaData = metaData(groupAndArtifactId).orElseThrow();\n-        var metaDataId = metaData.latestMetaDataId().orElseThrow();\n-        return pom(metaDataId);\n-    }\n-\n-    record IdVersions(GroupAndArtifactId groupAndArtifactId, Set<Id> versions) {\n-        static IdVersions of(GroupAndArtifactId groupAndArtifactId) {\n-            return new IdVersions(groupAndArtifactId, new HashSet<>());\n-        }\n-    }\n-\n-    public static class Dag implements Bldr.ClassPathEntryProvider {\n-        private final MavenStyleRepository repo;\n-        private final List<GroupAndArtifactId> rootGroupAndArtifactIds;\n-        Map<GroupAndArtifactId, IdVersions> nodes = new HashMap<>();\n-        Map<IdVersions, List<IdVersions>> edges = new HashMap<>();\n-\n-        Dag add(Id from, Id to) {\n-            var fromNode =\n-                    nodes.computeIfAbsent(\n-                            from.groupAndArtifactId(), _ -> IdVersions.of(from.groupAndArtifactId()));\n-            fromNode.versions().add(from);\n-            var toNode =\n-                    nodes.computeIfAbsent(\n-                            to.groupAndArtifactId(), _ -> IdVersions.of(to.groupAndArtifactId()));\n-            toNode.versions().add(to);\n-            edges.computeIfAbsent(fromNode, k -> new ArrayList<>()).add(toNode);\n-            return this;\n-        }\n-\n-        void removeUNSPECIFIED() {\n-            nodes\n-                    .values()\n-                    .forEach(\n-                            idversions -> {\n-                                if (idversions.versions().size() > 1) {\n-                                    List<Id> versions = new ArrayList<>(idversions.versions());\n-                                    idversions.versions().clear();\n-                                    idversions\n-                                            .versions()\n-                                            .addAll(\n-                                                    versions.stream()\n-                                                            .filter(v -> !v.versionId().equals(VersionId.UNSPECIFIED))\n-                                                            .toList());\n-                                    println(idversions);\n-                                }\n-                                if (idversions.versions().size() > 1) {\n-                                    throw new IllegalStateException(\"more than one version\");\n-                                }\n-                            });\n-        }\n-\n-        Dag(MavenStyleRepository repo, List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n-            this.repo = repo;\n-            this.rootGroupAndArtifactIds = rootGroupAndArtifactIds;\n-\n-            Set<Id> unresolved = new HashSet<>();\n-            rootGroupAndArtifactIds.forEach(\n-                    rootGroupAndArtifactId -> {\n-                        var metaData = repo.metaData(rootGroupAndArtifactId).orElseThrow();\n-                        var metaDataId = metaData.latestMetaDataId().orElseThrow();\n-                        var optionalPom = repo.pom(rootGroupAndArtifactId);\n-\n-                        if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n-                            pom.requiredDependencies()\n-                                    .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n-                                    .forEach(\n-                                            dependencyId -> {\n-                                                add(metaDataId, dependencyId);\n-                                                unresolved.add(dependencyId);\n-                                            });\n-                        }\n-                    });\n-\n-            while (!unresolved.isEmpty()) {\n-                var resolveSet = new HashSet<>(unresolved);\n-                unresolved.clear();\n-                resolveSet.forEach(id -> {\n-                            if (repo.pom(id) instanceof Optional<Pom> p && p.isPresent()) {\n-                                p.get()\n-                                        .requiredDependencies()\n-                                        .filter(dependencyId -> !dependencyId.scope.equals(Scope.TEST))\n-                                        .forEach(\n-                                                dependencyId -> {\n-                                                    unresolved.add(dependencyId);\n-                                                    add(id, dependencyId);\n-                                                });\n-                            }\n-                        });\n-            }\n-            removeUNSPECIFIED();\n-        }\n-\n-        @Override\n-        public List<Bldr.ClassPathEntry> classPathEntries() {\n-            return classPath().classPathEntries();\n-        }\n-\n-        Bldr.ClassPath classPath() {\n-\n-            Bldr.ClassPath jars = Bldr.ClassPath.of();\n-            nodes\n-                    .keySet()\n-                    .forEach(\n-                            id -> {\n-                                Optional<Pom> optionalPom = repo.pom(id);\n-                                if (optionalPom.isPresent() && optionalPom.get() instanceof Pom pom) {\n-                                    jars.add(pom.getJar());\n-                                } else {\n-                                    throw new RuntimeException(\"No pom for \" + id + \" needed by \" + id);\n-                                }\n-                            });\n-            return jars;\n-        }\n-    }\n-\n-    public Bldr.ClassPathEntryProvider classPathEntries(String... rootGroupAndArtifactIds) {\n-        return classPathEntries(Stream.of(rootGroupAndArtifactIds).map(GroupAndArtifactId::of).toList());\n-    }\n-\n-    public Bldr.ClassPathEntryProvider classPathEntries(GroupAndArtifactId... rootGroupAndArtifactIds) {\n-        return classPathEntries(List.of(rootGroupAndArtifactIds));\n-    }\n-\n-    public Bldr.ClassPathEntryProvider classPathEntries(List<GroupAndArtifactId> rootGroupAndArtifactIds) {\n-      StringBuilder sb = new StringBuilder();\n-      rootGroupAndArtifactIds.forEach(groupAndArtifactId->sb.append(sb.isEmpty() ?\"\":\"-\").append(groupAndArtifactId.groupId+\"-\"+groupAndArtifactId.artifactId));\n-      System.out.println(sb);\n-      Bldr.ClassPathEntryProvider classPathEntries=null;\n-      var pathFileName = sb+\"-path.xml\";\n-      var pathFile = dir.xmlFile(pathFileName);\n-      if (pathFile.exists()){\n-          System.out.println(pathFileName + \" exists \" + pathFile.path().toString());\n-          XMLNode path = new XMLNode(pathFile.path());\n-          Bldr.ClassPath classPath = Bldr.ClassPath.of();\n-          path.nodes(path.xpath(\"\/path\/jar\/text()\")).forEach(e->\n-                  classPath.add(dir.jarFile(e.getNodeValue()))\n-          );\n-          classPathEntries = classPath;\n-      }else {\n-         var finalClassPathEntries =  new Dag(this, rootGroupAndArtifactIds);\n-              XMLNode.create(\"path\", xml-> {\n-                  finalClassPathEntries.classPathEntries().forEach(cpe ->\n-                          xml.element(\"jar\",jar->jar.text(dir.path().relativize(cpe.path()).toString()))\n-                  );\n-              }).write(pathFile);\n-         System.out.println(\"created \"+pathFile.path());\n-         classPathEntries = finalClassPathEntries;\n-      }\n-        return classPathEntries;\n-    }\n-\n-    public record VersionId(Integer maj, Integer min, Integer point, String classifier)\n-            implements Comparable<VersionId> {\n-        static Integer integerOrNull(String s) {\n-            return (s == null || s.isEmpty()) ? null : Integer.parseInt(s);\n-        }\n-\n-        public static Pattern pattern = Pattern.compile(\"^(\\\\d+)(?:\\\\.(\\\\d+)(?:\\\\.(\\\\d+)(.*))?)?$\");\n-        static VersionId UNSPECIFIED = new VersionId(null, null, null, null);\n-\n-        static VersionId of(String version) {\n-            Matcher matcher = pattern.matcher(version);\n-            if (matcher.matches()) {\n-                return new VersionId(\n-                        integerOrNull(matcher.group(1)),\n-                        integerOrNull(matcher.group(2)),\n-                        integerOrNull(matcher.group(3)),\n-                        matcher.group(4));\n-            } else {\n-                return UNSPECIFIED;\n-            }\n-        }\n-\n-        int cmp(Integer v1, Integer v2) {\n-            if (v1 == null && v2 == null) {\n-                return 0;\n-            }\n-            if (v1 == null) {\n-                return -v2;\n-            } else if (v2 == null) {\n-                return v1;\n-            } else {\n-                return v1 - v2;\n-            }\n-        }\n-\n-        @Override\n-        public int compareTo(VersionId o) {\n-            if (cmp(maj(), o.maj()) == 0) {\n-                if (cmp(min(), o.min()) == 0) {\n-                    if (cmp(point(), o.point()) == 0) {\n-                        return classifier().compareTo(o.classifier());\n-                    } else {\n-                        return cmp(point(), o.point());\n-                    }\n-                } else {\n-                    return cmp(min(), o.min());\n-                }\n-            } else {\n-                return cmp(maj(), o.maj());\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            if (maj() != null) {\n-                sb.append(maj());\n-                if (min() != null) {\n-                    sb.append(\".\").append(min());\n-                    if (point() != null) {\n-                        sb.append(\".\").append(point());\n-                        if (classifier() != null) {\n-                            sb.append(classifier());\n-                        }\n-                    }\n-                }\n-            } else {\n-                sb.append(\"UNSPECIFIED\");\n-            }\n-            return sb.toString();\n-        }\n-    }\n-\n-    public record GroupId(String string) {\n-        public static GroupId of(String s) {\n-            return new GroupId(s);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return string;\n-        }\n-    }\n-\n-    public record ArtifactId(String string) {\n-        static ArtifactId of(String string) {\n-            return new ArtifactId(string);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return string;\n-        }\n-    }\n-\n-    public record MetaDataId(\n-            MavenStyleRepository mavenStyleRepository,\n-            GroupAndArtifactId groupAndArtifactId,\n-            VersionId versionId,\n-            Set<String> downloadables,\n-            Set<String> tags)\n-            implements Id {\n-\n-        public URL pomURL() {\n-            return url(\"pom\");\n-        }\n-\n-        public URL jarURL() {\n-            return url(\"jar\");\n-        }\n-\n-        public XMLNode getPom() {\n-            if (downloadables.contains(\".pom\")) {\n-                return mavenStyleRepository.queryAndCache(\n-                        url(\"pom\"), mavenStyleRepository.dir.xmlFile(artifactAndVersion() + \".pom\"));\n-            } else {\n-                throw new IllegalStateException(\"no pom\");\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return groupAndArtifactId().toString() + \".\" + versionId();\n-        }\n-    }\n-\n-    public MavenStyleRepository(Bldr.RepoDir dir) {\n-        this.dir = dir.create();\n-    }\n-\n-    Bldr.JarFile queryAndCache(URL query, Bldr.JarFile jarFile) {\n-        try {\n-            if (!jarFile.exists()) {\n-                print(\"Querying and caching \" + jarFile.fileName());\n-                println(\" downloading \" + query);\n-                curl(query, jarFile.path());\n-            } else {\n-                \/\/ println(\"Using cached \" + jarFile.fileName());\n-\n-            }\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-        return jarFile;\n-    }\n-\n-    XMLNode queryAndCache(URL query, Bldr.XMLFile xmlFile) {\n-        XMLNode xmlNode = null;\n-        try {\n-            if (!xmlFile.exists()) {\n-                print(\"Querying and caching \" + xmlFile.fileName());\n-                println(\" downloading \" + query);\n-                xmlNode = new XMLNode(query);\n-                xmlNode.write(xmlFile.path().toFile());\n-            } else {\n-                \/\/ println(\"Using cached \" + xmlFile.fileName());\n-                xmlNode = new XMLNode(xmlFile.path());\n-            }\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-        return xmlNode;\n-    }\n-\n-    public record MetaData(\n-            MavenStyleRepository mavenStyleRepository,\n-            GroupAndArtifactId groupAndArtifactId,\n-            XMLNode xmlNode) {\n-\n-        public Stream<MetaDataId> metaDataIds() {\n-            return xmlNode\n-                    .xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n-                    .map(\n-                            xmln ->\n-                                    new MetaDataId(\n-                                            this.mavenStyleRepository,\n-                                            GroupAndArtifactId.of(\n-                                                    GroupId.of(xmln.xpathQueryString(\"str[@name='g']\/text()\")),\n-                                                    ArtifactId.of(xmln.xpathQueryString(\"str[@name='a']\/text()\"))),\n-                                            VersionId.of(xmln.xpathQueryString(\"str[@name='v']\/text()\")),\n-                                            new HashSet<>(\n-                                                    xmln.nodes(xmln.xpath(\"arr[@name='ec']\/str\/text()\"))\n-                                                            .map(Node::getNodeValue)\n-                                                            .toList()),\n-                                            new HashSet<>(\n-                                                    xmln.nodes(xmln.xpath(\"arr[@name='tags']\/str\/text()\"))\n-                                                            .map(Node::getNodeValue)\n-                                                            .toList())));\n-        }\n-\n-        public Stream<MetaDataId> sortedMetaDataIds() {\n-            return metaDataIds().sorted(Comparator.comparing(MetaDataId::versionId));\n-        }\n-\n-        public Optional<MetaDataId> latestMetaDataId() {\n-            return metaDataIds().max(Comparator.comparing(MetaDataId::versionId));\n-        }\n-\n-        public Optional<MetaDataId> getMetaDataId(VersionId versionId) {\n-            return metaDataIds().filter(id -> versionId.compareTo(id.versionId()) == 0).findFirst();\n-        }\n-    }\n-\n-    public Optional<MetaData> metaData(String groupId, String artifactId) {\n-        return metaData(GroupAndArtifactId.of(groupId, artifactId));\n-    }\n-\n-    public Optional<MetaData> metaData(GroupAndArtifactId groupAndArtifactId) {\n-        try {\n-            var query = \"g:\" + groupAndArtifactId.groupId() + \" AND a:\" + groupAndArtifactId.artifactId();\n-            URL rowQueryUrl =\n-                    new URI(\n-                            searchBase\n-                                    + \"select?q=\"\n-                                    + URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                                    + \"&core=gav&wt=xml&rows=0\")\n-                            .toURL();\n-            var rowQueryResponse = new XMLNode(rowQueryUrl);\n-            var numFound = rowQueryResponse.xpathQueryString(\"\/response\/result\/@numFound\");\n-\n-            URL url =\n-                    new URI(\n-                            searchBase\n-                                    + \"select?q=\"\n-                                    + URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                                    + \"&core=gav&wt=xml&rows=\"\n-                                    + numFound)\n-                            .toURL();\n-            try {\n-                \/\/ println(url);\n-                var xmlNode =\n-                        queryAndCache(url, dir.xmlFile(groupAndArtifactId.artifactId() + \".meta.xml\"));\n-                \/\/ var numFound2 = xmlNode.xpathQueryString(\"\/response\/result\/@numFound\");\n-                \/\/ var start = xmlNode.xpathQueryString(\"\/response\/result\/@start\");\n-                \/\/ var rows =\n-                \/\/ xmlNode.xpathQueryString(\"\/response\/lst[@name='responseHeader']\/lst[@name='params']\/str[@name='rows']\/text()\");\n-                \/\/ println(\"numFound = \"+numFound+\" rows =\"+rows+ \" start =\"+start);\n-                if (numFound.isEmpty() || numFound.equals(\"0\")) {\n-                    return Optional.empty();\n-                } else {\n-                    return Optional.of(new MetaData(this, groupAndArtifactId, xmlNode));\n-                }\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"hat\/bldr\/MavenStyleRepository.java","additions":0,"deletions":604,"binary":false,"changes":604,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-package bldr;\n-\n-import java.util.function.Consumer;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-record Regex(Pattern pattern) {\n-    Regex(String regex) {\n-        this(Pattern.compile(regex));\n-    }\n-\n-    public static Regex of(String regexString) {\n-        return new Regex(regexString);\n-    }\n-\n-    boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n-        if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n-            matcherConsumer.accept(matcher);\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-}\n","filename":"hat\/bldr\/Regex.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,936 +0,0 @@\n-package bldr;\n-\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n-\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.transform.OutputKeys;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpression;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.StringWriter;\n-import java.net.URI;\n-import java.net.URL;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-public class XMLNode {\n-    org.w3c.dom.Element element;\n-    List<XMLNode> children = new ArrayList<>();\n-    Map<String, String> attrMap = new HashMap<>();\n-\n-    public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>> {\n-        final public org.w3c.dom.Element element;\n-        @SuppressWarnings(\"unchecked\")\n-        public T self() {\n-            return (T) this;\n-        }\n-\n-        public T attr(String name, String value) {\n-            \/\/ var att = element.getOwnerDocument().createAttribute(name);\n-            \/\/ att.setValue(value);\n-            element.setAttribute(name, value);\n-            \/\/ element.appendChild(att);\n-            return self();\n-        }\n-\n-        public T attr(URI uri, String name, String value) {\n-            \/\/ var att = element.getOwnerDocument().createAttribute(name);\n-            \/\/ att.setValue(value);\n-            element.setAttributeNS(uri.toString(), name, value);\n-            \/\/ element.appendChild(att);\n-            return self();\n-        }\n-\n-        public T element(String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n-            var node = element.getOwnerDocument().createElement(name);\n-            element.appendChild(node);\n-            var builder = factory.apply(node);\n-            xmlBuilderConsumer.accept(builder);\n-            return self();\n-        }\n-\n-        public T element(\n-                URI uri, String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n-            var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n-            element.appendChild(node);\n-            var builder = factory.apply(node);\n-            xmlBuilderConsumer.accept(builder);\n-            return self();\n-        }\n-\n-        AbstractXMLBuilder(org.w3c.dom.Element element) {\n-            this.element = element;\n-        }\n-\n-        public T text(String thisText) {\n-            var node = element.getOwnerDocument().createTextNode(thisText);\n-            element.appendChild(node);\n-            return self();\n-        }\n-\n-        public T comment(String thisComment) {\n-            var node = element.getOwnerDocument().createComment(thisComment);\n-            element.appendChild(node);\n-            return self();\n-        }\n-\n-        <L> T forEach(List<L> list, BiConsumer<T, L> biConsumer) {\n-            list.forEach(l -> biConsumer.accept(self(), l));\n-            return self();\n-        }\n-\n-        <L> T forEach(Stream<L> stream, BiConsumer<T, L> biConsumer) {\n-            stream.forEach(l -> biConsumer.accept(self(), l));\n-            return self();\n-        }\n-\n-        <L> T forEach(Stream<L> stream, Consumer<L> consumer) {\n-            stream.forEach(consumer);\n-            return self();\n-        }\n-\n-        protected T then(Consumer<T> xmlBuilderConsumer) {\n-            xmlBuilderConsumer.accept(self());\n-            return self();\n-        }\n-    }\n-\n-    public static class PomXmlBuilder extends AbstractXMLBuilder<PomXmlBuilder> {\n-        PomXmlBuilder(Element element) {\n-            super(element);\n-        }\n-\n-        public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n-            return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n-            return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder modelVersion(String s) {\n-            return element(\"modelVersion\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder pom(String groupId, String artifactId, String version) {\n-            return modelVersion(\"4.0.0\").packaging(\"pom\").ref(groupId, artifactId, version);\n-        }\n-\n-        public PomXmlBuilder jar(String groupId, String artifactId, String version) {\n-            return modelVersion(\"4.0.0\").packaging(\"jar\").ref(groupId, artifactId, version);\n-        }\n-\n-        public PomXmlBuilder groupId(String s) {\n-            return element(\"groupId\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder artifactId(String s) {\n-            return element(\"artifactId\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder packaging(String s) {\n-            return element(\"packaging\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder version(String s) {\n-            return element(\"version\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"build\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"plugins\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder plugin(\n-                String groupId,\n-                String artifactId,\n-                String version,\n-                Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\n-                    \"plugin\", $ -> $.ref(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n-        }\n-\n-        public PomXmlBuilder antPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return plugin(\n-                    \"org.apache.maven.plugins\",\n-                    \"maven-antrun-plugin\",\n-                    \"1.8\",\n-                    pomXmlBuilderConsumer);\n-        }\n-        public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return plugin(\n-                    \"org.apache.maven.plugins\",\n-                    \"maven-surefire-plugin\",\n-                    \"3.1.2\",\n-                    pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder compilerPlugin(\n-                Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return plugin(\n-                    \"org.apache.maven.plugins\",\n-                    \"maven-compiler-plugin\",\n-                    \"3.11.0\",pomXmlBuilderConsumer\n-                  );\n-        }\n-\n-        public PomXmlBuilder execPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return plugin(\"org.codehaus.mojo\", \"exec-maven-plugin\", \"3.1.0\", pomXmlBuilderConsumer);\n-        }\n-\n-\n-        public PomXmlBuilder plugin(\n-                String groupId, String artifactId, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n-        }\n-\n-        public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"plugin\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder parent(String groupId, String artifactId, String version) {\n-            return parent(parent -> parent.ref(groupId, artifactId, version));\n-        }\n-\n-        public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"parent\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder pluginManagement(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"pluginManagement\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder file(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"file\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder activation(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"activation\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"profiles\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"profile\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"arguments\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"executions\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"execution\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder execIdPhaseConf(\n-                String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return execution(execution -> execution.id(id).phase(phase).goals(gs -> gs.goal(\"exec\")).configuration(pomXmlBuilderConsumer));\n-        }\n-\n-        public PomXmlBuilder exec(\n-                String phase, String executable, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return execIdPhaseConf(\n-                    executable + \"-\" + phase,\n-                    phase,\n-                    conf -> conf.executable(executable).arguments(pomXmlBuilderConsumer));\n-        }\n-\n-        public PomXmlBuilder cmake(\n-                String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return execIdPhaseConf(\n-                    id, phase, conf -> conf.executable(\"cmake\").arguments(pomXmlBuilderConsumer));\n-        }\n-\n-        public PomXmlBuilder cmake(String id, String phase, String... args) {\n-            return execIdPhaseConf(\n-                    id,\n-                    phase,\n-                    conf ->\n-                            conf.executable(\"cmake\")\n-                                    .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n-        }\n-\n-        public PomXmlBuilder jextract(String id, String phase, String... args) {\n-            return execIdPhaseConf(\n-                    id,\n-                    phase,\n-                    conf ->\n-                            conf.executable(\"jextract\")\n-                                    .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n-        }\n-\n-        public PomXmlBuilder ant(\n-                String id, String phase, String goal, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return execution(execution -> execution\n-                                    .id(id)\n-                                    .phase(phase)\n-                                    .goals(gs -> gs.goal(goal))\n-                                    .configuration(configuration -> configuration.target(pomXmlBuilderConsumer)));\n-        }\n-\n-        public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"goals\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"target\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"configuration\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder compilerArgs(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"compilerArgs\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder compilerArgs(String... args) {\n-            return element(\"compilerArgs\", $ -> $.forEach(Stream.of(args), $::arg));\n-        }\n-\n-        public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"properties\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"dependencies\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder dependsOn(String groupId, String artifactId, String version) {\n-            return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version));\n-        }\n-        public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n-            return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n-        }\n-\n-        public PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n-            return dependency($ -> $.ref(groupId, artifactId, version));\n-        }\n-\n-        public PomXmlBuilder dependency(\n-                String groupId, String artifactId, String version, String scope) {\n-            return dependency($ -> $.ref(groupId, artifactId, version).scope(scope));\n-        }\n-\n-        public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"dependency\", pomXmlBuilderConsumer);\n-        }\n-\n-        public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"modules\", pomXmlBuilderConsumer);\n-        }\n-        public PomXmlBuilder modules(List<String> modules) {\n-            return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n-        }\n-        public PomXmlBuilder modules(String... modules) {\n-            return modules(List.of(modules));\n-        }\n-\n-        public PomXmlBuilder module(String name) {\n-            return element(\"module\", $ -> $.text(name));\n-        }\n-\n-        public PomXmlBuilder property(String name, String value) {\n-            return element(name, $ -> $.text(value));\n-        }\n-        public PomXmlBuilder antproperty(String name, String value) {\n-            return element(\"property\", $ -> $.attr(\"name\", name).attr(\"value\", value));\n-        }\n-\n-        public PomXmlBuilder scope(String s) {\n-            return element(\"scope\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder phase(String s) {\n-            return element(\"phase\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder argument(String s) {\n-            return element(\"argument\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder goal(String s) {\n-            return element(\"goal\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder copy(String file, String toDir) {\n-            return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n-        }\n-\n-        public PomXmlBuilder echo(String message) {\n-            return element(\"echo\", $ -> $.attr(\"message\", message));\n-        }\n-\n-        public PomXmlBuilder echo(String filename, String message) {\n-            return element(\"echo\", $ -> $.attr(\"message\", message).attr(\"file\", filename));\n-        }\n-\n-        public PomXmlBuilder mkdir(String dirName) {\n-            return element(\"mkdir\", $ -> $.attr(\"dir\", dirName));\n-        }\n-\n-        public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n-            return groupId(groupId).artifactId(artifactId);\n-        }\n-\n-        public PomXmlBuilder ref(String groupId, String artifactId, String version) {\n-            return groupIdArtifactId(groupId, artifactId).version(version);\n-        }\n-\n-        public PomXmlBuilder skip(String string) {\n-            return element(\"skip\", $ -> $.text(string));\n-        }\n-\n-        public PomXmlBuilder id(String s) {\n-            return element(\"id\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder arg(String s) {\n-            return element(\"arg\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder argLine(String s) {\n-            return element(\"argLine\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder source(String s) {\n-            return element(\"source\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder target(String s) {\n-            return element(\"target\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder showWarnings(String s) {\n-            return element(\"showWarnings\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder showDeprecation(String s) {\n-            return element(\"showDeprecation\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder failOnError(String s) {\n-            return element(\"failOnError\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder exists(String s) {\n-            return element(\"exists\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder activeByDefault(String s) {\n-            return element(\"activeByDefault\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder executable(String s) {\n-            return element(\"executable\", $ -> $.text(s));\n-        }\n-\n-        public PomXmlBuilder workingDirectory(String s) {\n-            return element(\"workingDirectory\", $ -> $.text(s));\n-        }\n-    }\n-\n-    public static class ImlBuilder extends AbstractXMLBuilder<ImlBuilder> {\n-\n-        ImlBuilder(Element element) {\n-            super(element);\n-        }\n-\n-        public ImlBuilder element(String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n-            return element(name, ImlBuilder::new, xmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder element(URI uri, String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n-            return element(uri, name, ImlBuilder::new, xmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder modelVersion(String s) {\n-            return element(\"modelVersion\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder groupId(String s) {\n-            return element(\"groupId\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder artifactId(String s) {\n-            return element(\"artifactId\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder packaging(String s) {\n-            return element(\"packaging\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder version(String s) {\n-            return element(\"version\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder build(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"build\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder plugins(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"plugins\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder plugin(\n-                String groupId,\n-                String artifactId,\n-                String version,\n-                Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\n-                    \"plugin\",\n-                    $ ->\n-                            $.groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n-        }\n-\n-        public ImlBuilder plugin(\n-                String groupId, String artifactId, Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\n-                    \"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n-        }\n-\n-        public ImlBuilder plugin(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"plugin\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder parent(String groupId, String artifactId, String version) {\n-            return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n-        }\n-\n-        public ImlBuilder parent(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"parent\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder pluginManagement(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"pluginManagement\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder file(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"file\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder activation(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"activation\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder profiles(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"profiles\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder profile(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"profile\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder arguments(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"arguments\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder executions(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"executions\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder execution(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"execution\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder goals(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"goals\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder target(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"target\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder configuration(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"configuration\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder compilerArgs(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"compilerArgs\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder properties(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"properties\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder dependencies(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"dependencies\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder dependency(String groupId, String artifactId, String version) {\n-            return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version));\n-        }\n-\n-        public ImlBuilder dependency(String groupId, String artifactId, String version, String scope) {\n-            return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version).scope(scope));\n-        }\n-\n-        public ImlBuilder dependency(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"dependency\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder modules(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n-            return element(\"modules\", pomXmlBuilderConsumer);\n-        }\n-\n-        public ImlBuilder module(String name) {\n-            return element(\"module\", $ -> $.text(name));\n-        }\n-\n-        public ImlBuilder property(String name, String value) {\n-            return element(name, $ -> $.text(value));\n-        }\n-\n-        public ImlBuilder scope(String s) {\n-            return element(\"scope\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder phase(String s) {\n-            return element(\"phase\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder argument(String s) {\n-            return element(\"argument\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder goal(String s) {\n-            return element(\"goal\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder copy(String file, String toDir) {\n-            return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n-        }\n-\n-        public ImlBuilder groupIdArtifactId(String groupId, String artifactId) {\n-            return groupId(groupId).artifactId(artifactId);\n-        }\n-\n-        public ImlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n-            return groupIdArtifactId(groupId, artifactId).version(version);\n-        }\n-\n-        public ImlBuilder skip(String string) {\n-            return element(\"skip\", $ -> $.text(string));\n-        }\n-\n-        public ImlBuilder id(String s) {\n-            return element(\"id\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder arg(String s) {\n-            return element(\"arg\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder argLine(String s) {\n-            return element(\"argLine\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder source(String s) {\n-            return element(\"source\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder target(String s) {\n-            return element(\"target\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder showWarnings(String s) {\n-            return element(\"showWarnings\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder showDeprecation(String s) {\n-            return element(\"showDeprecation\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder failOnError(String s) {\n-            return element(\"failOnError\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder exists(String s) {\n-            return element(\"exists\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder activeByDefault(String s) {\n-            return element(\"activeByDefault\", $ -> $.text(s));\n-        }\n-\n-        public ImlBuilder executable(String s) {\n-            return element(\"executable\", $ -> $.text(s));\n-        }\n-    }\n-\n-    public static class XMLBuilder extends AbstractXMLBuilder<XMLBuilder> {\n-       XMLBuilder(Element element) {\n-            super(element);\n-        }\n-\n-        public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-            return element(name, XMLBuilder::new, xmlBuilderConsumer);\n-        }\n-\n-        public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-            return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n-        }\n-    }\n-\n-    static XMLNode create(String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-\n-        try {\n-            var doc =\n-                    javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-            var element = doc.createElement(nodeName);\n-            doc.appendChild(element);\n-            XMLBuilder xmlBuilder = new XMLBuilder(element);\n-            xmlBuilderConsumer.accept(xmlBuilder);\n-            return new XMLNode(element);\n-        } catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static XMLNode createIml(String commentText, Consumer<ImlBuilder> imlBuilderConsumer) {\n-        try {\n-            var doc =\n-                    javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-            var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n-            var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n-            var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n-            var comment = doc.createComment(commentText);\n-            doc.appendChild(comment);\n-            var element = doc.createElementNS(uri1.toString(), \"project\");\n-            doc.appendChild(element);\n-            element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n-            ImlBuilder imlBuilder = new ImlBuilder(element);\n-            imlBuilderConsumer.accept(imlBuilder);\n-            return new XMLNode(element);\n-        } catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static XMLNode createPom(\n-            String commentText, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n-        try {\n-            var doc =\n-                    javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-\n-            var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n-            var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n-            var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n-            var comment = doc.createComment(commentText);\n-            doc.appendChild(comment);\n-            var element = doc.createElementNS(uri1.toString(), \"project\");\n-            doc.appendChild(element);\n-            element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n-            PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n-            pomXmlBuilderConsumer.accept(pomXmlBuilder);\n-            return new XMLNode(element);\n-        } catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n-        try {\n-            var doc =\n-                    javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n-            var element = doc.createElementNS(uri.toString(), nodeName);\n-            doc.appendChild(element);\n-            XMLBuilder xmlBuilder = new XMLBuilder(element);\n-            xmlBuilderConsumer.accept(xmlBuilder);\n-            return new XMLNode(element);\n-        } catch (ParserConfigurationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    XMLNode(org.w3c.dom.Element element) {\n-        this.element = element;\n-        this.element.normalize();\n-        NodeList nodeList = element.getChildNodes();\n-        for (int i = 0; i < nodeList.getLength(); i++) {\n-            if (nodeList.item(i) instanceof org.w3c.dom.Element e) {\n-                this.children.add(new XMLNode(e));\n-            }\n-        }\n-        for (int i = 0; i < element.getAttributes().getLength(); i++) {\n-            if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr) {\n-                this.attrMap.put(attr.getName(), attr.getValue());\n-            }\n-        }\n-    }\n-\n-    public boolean hasAttr(String name) {\n-        return attrMap.containsKey(name);\n-    }\n-\n-    public String attr(String name) {\n-        return attrMap.get(name);\n-    }\n-\n-    static Document parse(InputStream is) {\n-        try {\n-            return javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n-        } catch (ParserConfigurationException | SAXException | IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static Document parse(Path path) {\n-        try {\n-            return parse(Files.newInputStream(path));\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    XMLNode(Path path) {\n-        this(parse(path).getDocumentElement());\n-    }\n-\n-    XMLNode(File file) {\n-        this(parse(file.toPath()).getDocumentElement());\n-    }\n-\n-    XMLNode(URL url) throws Throwable {\n-        this(parse(url.openStream()).getDocumentElement());\n-    }\n-\n-    void write(StreamResult streamResult) throws Throwable {\n-        var transformer = TransformerFactory.newInstance().newTransformer();\n-        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n-        transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-        transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n-    }\n-\n-    void write(File file) {\n-        try {\n-            write(new StreamResult(file));\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);\n-        }\n-    }\n-\n-    public void write(Bldr.XMLFile xmlFile) {\n-        try {\n-            write(new StreamResult(xmlFile.path().toFile()));\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        var stringWriter = new StringWriter();\n-        try {\n-            var transformer = TransformerFactory.newInstance().newTransformer();\n-            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-            transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n-            return stringWriter.toString();\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    XPathExpression xpath(String expression) {\n-        XPath xpath = XPathFactory.newInstance().newXPath();\n-        try {\n-            return xpath.compile(expression);\n-        } catch (XPathExpressionException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    Node node(XPathExpression xPathExpression) {\n-        try {\n-            return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n-        } catch (XPathExpressionException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    Optional<Node> optionalNode(XPathExpression xPathExpression) {\n-        var nodes = nodes(xPathExpression).toList();\n-        return switch (nodes.size()) {\n-            case 0 -> Optional.empty();\n-            case 1 -> Optional.of(nodes.getFirst());\n-            default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n-        };\n-    }\n-\n-    String str(XPathExpression xPathExpression) {\n-        try {\n-            return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n-        } catch (XPathExpressionException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    String xpathQueryString(String xpathString) {\n-        try {\n-            return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n-        } catch (XPathExpressionException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    NodeList nodeList(XPathExpression xPathExpression) {\n-        try {\n-            return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n-        } catch (XPathExpressionException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    Stream<Node> nodes(XPathExpression xPathExpression) {\n-        var nodeList = nodeList(xPathExpression);\n-        List<Node> nodes = new ArrayList<>();\n-        for (int i = 0; i < nodeList.getLength(); i++) {\n-            nodes.add(nodeList.item(i));\n-        }\n-        return nodes.stream();\n-    }\n-\n-    Stream<org.w3c.dom.Element> elements(XPathExpression xPathExpression) {\n-        return nodes(xPathExpression)\n-                .filter(n -> n instanceof org.w3c.dom.Element)\n-                .map(n -> (Element) n);\n-    }\n-\n-    Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n-        return elements(xPathExpression).map(e -> new XMLNode(e));\n-    }\n-}\n","filename":"hat\/bldr\/XMLNode.java","additions":0,"deletions":936,"binary":false,"changes":936,"status":"deleted"},{"patch":"@@ -0,0 +1,26 @@\n+<code_scheme name=\"scriptformat\" version=\"173\">\n+  <!-- \n+    ~\/Applications\/IntelliJ\\ IDEA\\ Ultimate.app\/Contents\/bin\/format.sh -s bldr\/scriptformat.xml bld.java\n+  -->\n+  <JavaCodeStyleSettings>\n+    <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" \/>\n+    <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" \/>\n+    <option name=\"PACKAGES_TO_USE_IMPORT_ON_DEMAND\">\n+      <value \/>\n+    <\/option>\n+  <\/JavaCodeStyleSettings>\n+  <codeStyleSettings language=\"JAVA\">\n+    <option name=\"ALIGN_MULTILINE_PARAMETERS_IN_CALLS\" value=\"true\" \/>\n+    <option name=\"PREFER_PARAMETERS_WRAP\" value=\"true\" \/>\n+    <option name=\"CALL_PARAMETERS_LPAREN_ON_NEXT_LINE\" value=\"true\" \/>\n+    <option name=\"CALL_PARAMETERS_RPAREN_ON_NEXT_LINE\" value=\"true\" \/>\n+    <option name=\"KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE\" value=\"true\" \/>\n+    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" \/>\n+    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" \/>\n+    <indentOptions>\n+      <option name=\"INDENT_SIZE\" value=\"2\" \/>\n+      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" \/>\n+      <option name=\"TAB_SIZE\" value=\"2\" \/>\n+    <\/indentOptions>\n+  <\/codeStyleSettings>\n+<\/code_scheme>\n","filename":"hat\/bldr\/scriptformat.xml","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- var hatDir = Dir.current();\n+ var hatDir = DirEntry.current();\n","filename":"hat\/clean","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,37 +31,40 @@\n-   └── hat\n-        │\n-        ├── CMakeFile\n-        ├── build\n-        │\n-        ├── intellij\n-        │    ├── .idea\n-        │    │    ├── compiler.xml\n-        │    │    ├── misc.xml\n-        │    │    ├── modules.xml\n-        │    │    ├── uiDesigner.xml\n-        │    │    ├── vcs.xml\n-        │    │    └── workspace.xml\n-        │    │\n-        │    ├── hat.iml\n-        │    ├── backend_(spirv|mock|cuda|ptx|opencl).iml\n-        │    └── (mandel|violajones|experiments).iml\n-        │\n-        ├── hat\n-        │    └── src\n-        │         └── java\n-        │\n-        ├── backends\n-        │    └── (opencl|cuda|ptx|mock|shared)\n-        │          └── src\n-        │              ├── cpp\n-        │              ├── include\n-        │              ├── java\n-        │              └── services\n-        └── examples\n-             ├── mandel\n-             │    └── src\n-             │         └── java\n-             └── violajones\n-                  └── src\n-                       ├── java\n-                       └── resources\n+     .\/\n+     +--build\/                     All jars, native libs and executables\n+     |    +--cmake-build-debug\/    All intermediate cmake artifacts\n+     |\n+     +--stage\/\n+     |    +--repo\/                 All downloaded maven assets\n+     |    |\n+     |    +--jextract\/             All jextracted files\n+     |    |    +--opencl\n+     |    |    +--opengl\n+     |    |    +--cuda\n+     |\n+     +--hat                        * Note maven style layout\n+     |    +--src\/main\/java\n+     |    |    +--hat\/\n+     |    |\n+     |    +--src\/main\/test\n+     |         +--hat\/\n+     |\n+     +--backends\n+     |    +--java\n+     |    |    +--mt                    (*)\n+     |    |    +--seq                   (*)\n+     |    +--jextracted\n+     |    |    +--opencl                (*)\n+     |    +--ffi\n+     |    |    +--opencl                (*)\n+     |    |    +--ptx                   (*)\n+     |    |    +--mock                  (*)\n+     |    |    +--spirv                 (*)\n+     |    |    +--cuda                  (*)\n+     |    |    +--hip                   (*)\n+     |\n+     +--examples\n+     |    +--mandel                (*)\n+     |    +--squares               (*)\n+     |    +--heal                  (*)\n+     |    +--life                  (*)\n+     |    +--violajones            (*)\n+\n","filename":"hat\/docs\/hat-01-01-project-layout.md","additions":40,"deletions":37,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-HAT uses both maven and cmake.\n+We can build HAT using maven and cmake.\n@@ -26,0 +26,2 @@\n+Note: You should not edit the pom.xml files, these are autogenerated (using mkpoms) and your changes will get overwritten.\n+\n@@ -38,0 +40,3 @@\n+You will need jextract for your platform, and the jextract\/bin dir should also be in your path.\n+\n+\n@@ -41,0 +46,1 @@\n+export PATH=${PATH}:\/path\/to\/my\/jextract\/bin\n@@ -69,1 +75,1 @@\n-java sanity.java\n+java @bldr\/sanity\n@@ -72,3 +78,0 @@\n-This will check that your `PATH` includes your babylon JDK's bin dir, and will parse the top level `pom.xml` to ensure that that\n-the properties are pointing to `sane` values.\n-\n@@ -84,7 +87,7 @@\n-hat-1.0.jar                     hat-example-heal-1.0.jar        libptx_backend.dylib\n-hat-backend-cuda-1.0.jar        hat-example-mandel-1.0.jar      libspirv_backend.dylib\n-hat-backend-mock-1.0.jar        hat-example-squares-1.0.jar     mock_info\n-hat-backend-opencl-1.0.jar      hat-example-view-1.0.jar        opencl_info\n-hat-backend-ptx-1.0.jar         hat-example-violajones-1.0.jar  ptx_info\n-hat-backend-spirv-1.0.jar       libmock_backend.dylib           spirv_info\n-hat-example-experiments-1.0.jar libopencl_backend.dylib\n+hat-1.0.jar                         hat-example-heal-1.0.jar        libptx_backend.dylib\n+hat-backend-ffi-cuda-1.0.jar        hat-example-mandel-1.0.jar      libspirv_backend.dylib\n+hat-backend-ffi-mock-1.0.jar        hat-example-squares-1.0.jar     mock_info\n+hat-backend-ffi-opencl-1.0.jar      hat-example-view-1.0.jar        opencl_info\n+hat-backend-ffi-ptx-1.0.jar         hat-example-violajones-1.0.jar  ptx_info\n+hat-backend-ffi-spirv-1.0.jar       libmock_backend.dylib           spirv_info\n+hat-example-experiments-1.0.jar     libopencl_backend.dylib\n@@ -93,1 +96,1 @@\n-The provided `build.sh` script contains the minimal maven commandline\n+The provided `maven-build.bash` script contains the minimal maven commandline\n@@ -96,1 +99,1 @@\n-bash build.sh\n+bash maven-build.bash\n@@ -101,1 +104,1 @@\n-To run an example we should be able to use the maven artifacts in `build`\n+To run an example we use the maven artifacts in `build`\n@@ -106,1 +109,1 @@\n-   --class-path build\/hat-1.0.jar:build\/hat-example-mandel-1.0.jar:build\/hat-backend-opencl-1.0.jar \\\n+   --class-path build\/hat-1.0.jar:build\/hat-example-mandel-1.0.jar:build\/hat-backend-ffi-opencl-1.0.jar \\\n@@ -112,1 +115,1 @@\n-The provided `hatrun.bash` script simplifies this somewhat, we just need to pass the backend name `opencl` and the package name `mandel`\n+The provided `hatrun` java launch script simplifies this somewhat, we just need to pass the backend name `ffi-opencl` and the package name `mandel`\n@@ -116,1 +119,1 @@\n-bash hatrun.bash opencl mandel\n+java @bldr\/hatrun ffi-opencl mandel\n","filename":"hat\/docs\/hat-01-03-building-hat-with-maven.md","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-We might even have `Bldr` create the maven artifacts....\n-\n@@ -41,0 +39,11 @@\n+We also need to include jextract in our PATH.\n+\n+Download jextract from [here](https:\/\/jdk.java.net\/jextract\/) and add it to your PATH as shown below.\n+\n+You will also need cmake\n+\n+```bash\n+sudo apt install cmake\n+\n+```\n+\n@@ -44,0 +53,1 @@\n+export PATH=${PATH}:\/your\/path\/to\/jextract\/bin\n@@ -50,27 +60,1 @@\n-# Introducing Bldr\n-`Bldr` is an evolving set of static methods and types required (so far.. ;) )\n-to be able to build HAT, hat backends and examples.\n-\n-We rely on the ability to launch java source directly (without needing to javac first)\n-\n-* [JEP 458: Launch Multi-File Source-Code Program](https:\/\/openjdk.org\/jeps\/458)\n-* [JEP 330: Launch Single-File Source-Code Programs](https:\/\/openjdk.org\/jeps\/330)\n-\n-The `bld` script (really java source) can be run like this\n-\n-```bash\n-java --add-modules jdk.incubator.code --enable-preview --source 24 bld\n-```\n-\n-In our case the  magic is under the `hat\/bldr`subdir\n-\n-```\n-bldr\n-├── Bldr.java (symlink) -> src\/main\/java\/bldr\/Bldr.java\n-├── args      (text)       \"--enable-preview --source 24\"\n-└── src\n-    └── main\n-        └── java\n-            └── bldr\n-                └── Bldr.java\n-```\n+## Building using bld\n@@ -78,1 +62,1 @@\n-We also have a handy `bldr\/args` which allows us to avoid specifying commmon args `--enable-preview --source 24` which are always needed\n+To build hat (+ backends and examples)\n@@ -84,1 +68,1 @@\n-This `bld` script builds HAT, all the backends and examples and places buildable artifacts in `build` dir\n+This places build artifacts in `build` dir\n@@ -91,7 +75,7 @@\n-hat-1.0.jar                     hat-example-heal-1.0.jar        libptx_backend.dylib\n-hat-backend-cuda-1.0.jar        hat-example-mandel-1.0.jar      libspirv_backend.dylib\n-hat-backend-mock-1.0.jar        hat-example-squares-1.0.jar     mock_info\n-hat-backend-opencl-1.0.jar      hat-example-view-1.0.jar        opencl_info\n-hat-backend-ptx-1.0.jar         hat-example-violajones-1.0.jar  ptx_info\n-hat-backend-spirv-1.0.jar       libmock_backend.dylib           spirv_info\n-hat-example-experiments-1.0.jar libopencl_backend.dylib\n+hat-1.0.jar                         hat-example-heal-1.0.jar        libptx_backend.dylib\n+hat-backend-ffi-cuda-1.0.jar        hat-example-mandel-1.0.jar      libspirv_backend.dylib\n+hat-backend-ffi-mock-1.0.jar        hat-example-squares-1.0.jar     mock_info\n+hat-backend-ffi-opencl-1.0.jar      hat-example-view-1.0.jar        opencl_info\n+hat-backend-ffi-ptx-1.0.jar         hat-example-violajones-1.0.jar  ptx_info\n+hat-backend-ffi-spirv-1.0.jar           libmock_backend.dylib           spirv_info\n+hat-example-experiments-1.0.jar     libopencl_backend.dylib\n@@ -108,1 +92,1 @@\n-java @bldr\/args sanity\n+java @bldr\/sanity\n@@ -119,1 +103,1 @@\n-   --class-path build\/hat-1.0.jar:build\/hat-example-mandel-1.0.jar:build\/hat-backend-opencl-1.0.jar \\\n+   --class-path build\/hat-1.0.jar:build\/hat-example-mandel-1.0.jar:build\/hat-backend-ffi-opencl-1.0.jar \\\n@@ -126,1 +110,1 @@\n-name `opencl|java|cuda|ptx|mock` and the package name `mandel`\n+name `ffi-opencl|ffi-java|ffi-cuda|ffi-ptx|ffi-mock` and the package name `mandel`\n@@ -129,1 +113,1 @@\n-java @bldr\/args hatrun opencl mandel\n+java @bldr\/hatrun ffi-opencl mandel\n@@ -140,0 +124,41 @@\n+\n+# More Bld info\n+`bldr\/Bldr.java` is an evolving set of static methods and types required (so far.. ;) )\n+to be able to build HAT, hat backends and examples via the `bld` script\n+\n+We rely on java's ability to launch java source directly (without needing to javac first)\n+\n+* [JEP 458: Launch Multi-File Source-Code Program](https:\/\/openjdk.org\/jeps\/458)\n+* [JEP 330: Launch Single-File Source-Code Programs](https:\/\/openjdk.org\/jeps\/330)\n+\n+The `bld` script (really java source) can be run like this\n+\n+```bash\n+java --add-modules jdk.incubator.code --enable-preview --source 24 bld\n+```\n+\n+In our case the  magic is under the `hat\/bldr`subdir\n+\n+We also have a handy `bldr\/XXXX` which allows us to avoid specifying commmon args `--enable-preview --source 24` eash time we launch a script\n+\n+```\n+hat\n+├── bldr\n+|   ├── Bldr.java\n+|   ├── sanity      (text)       \"--enable-preview --source 24 sanity\"\n+|   ├── hatrun      (text)       \"--enable-preview --source 24 hatrun\"\n+|   ├── bld         (text)       \"--enable-preview --source 24 bld\"\n+└── bld\n+└── hatrun\n+└── sanity\n+```\n+\n+For example\n+```bash\n+java @bldr\/bld\n+```\n+\n+Is just a shortcut for\n+```bash\n+java --enable-preview --source 24 bld\n+```\n","filename":"hat\/docs\/hat-01-03-building-hat.md","additions":67,"deletions":42,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/blackscholes\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/heal\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/life\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/mandel\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import opencl.opencl_h;\n+\n@@ -40,2 +42,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\/\/import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -46,37 +47,0 @@\n-import static opencl.opencl_h.read;\n-import static opencl.opencl_h.C_POINTER;\n-import static opencl.opencl_h.clBuildProgram;\n-import static opencl.opencl_h.clCreateBuffer;\n-import static opencl.opencl_h.clCreateCommandQueue;\n-import static opencl.opencl_h.clCreateContext;\n-import static opencl.opencl_h.clCreateKernel;\n-import static opencl.opencl_h.clCreateProgramWithSource;\n-import static opencl.opencl_h.clEnqueueNDRangeKernel;\n-import static opencl.opencl_h.clEnqueueReadBuffer;\n-import static opencl.opencl_h.clEnqueueWriteBuffer;\n-import static opencl.opencl_h.clFlush;\n-import static opencl.opencl_h.clGetDeviceIDs;\n-import static opencl.opencl_h.clGetDeviceInfo;\n-import static opencl.opencl_h.clGetPlatformIDs;\n-import static opencl.opencl_h.clGetPlatformInfo;\n-import static opencl.opencl_h.clGetProgramBuildInfo;\n-import static opencl.opencl_h.clReleaseContext;\n-import static opencl.opencl_h.clReleaseMemObject;\n-import static opencl.opencl_h.clSetKernelArg;\n-import static opencl.opencl_h.clWaitForEvents;\n-import static opencl.opencl_h.cl_event;\n-import static opencl.opencl_h.cl_mem;\n-import static opencl.opencl_h.CL_DEVICE_BUILT_IN_KERNELS;\n-import static opencl.opencl_h.CL_DEVICE_MAX_COMPUTE_UNITS;\n-import static opencl.opencl_h.CL_DEVICE_NAME;\n-import static opencl.opencl_h.CL_FALSE;\n-import static opencl.opencl_h.CL_PLATFORM_NAME;\n-import static opencl.opencl_h.CL_PLATFORM_VENDOR;\n-import static opencl.opencl_h.CL_PLATFORM_VERSION;\n-import static opencl.opencl_h.CL_PROGRAM_BUILD_LOG;\n-import static opencl.opencl_h.CL_SUCCESS;\n-import static opencl.opencl_h.CL_TRUE;\n-import static opencl.opencl_h.C_CHAR;\n-import static opencl.opencl_h.C_FLOAT;\n-import static opencl.opencl_h.C_INT;\n-import static opencl.opencl_h.C_LONG;\n@@ -85,1 +49,1 @@\n-    public static MemorySegment NULL = java.lang.foreign.MemorySegment.NULL;\n+    public static MemorySegment NULL = MemorySegment.NULL;\n@@ -95,2 +59,1 @@\n-                int status;\n-                if ((status = clGetDeviceInfo(deviceId, query, JAVA_INT.byteSize(), platform.intValuePtr, NULL)) != CL_SUCCESS()) {\n+                if ((opencl_h.clGetDeviceInfo(deviceId, query, opencl_h.C_INT.byteSize(), platform.intValuePtr, NULL)) != opencl_h.CL_SUCCESS()) {\n@@ -99,1 +62,1 @@\n-                    value = platform.intValuePtr.get(C_INT, 0);\n+                    value = platform.intValuePtr.get(opencl_h.C_INT, 0);\n@@ -106,2 +69,1 @@\n-                int status;\n-                if ((status = clGetDeviceInfo(deviceId, query, 2048, platform.byte2048ValuePtr, platform.intValuePtr)) != CL_SUCCESS()) {\n+                if ((opencl_h.clGetDeviceInfo(deviceId, query, 2048, platform.byte2048ValuePtr, platform.intValuePtr)) != opencl_h.CL_SUCCESS()) {\n@@ -110,1 +72,1 @@\n-                    int len = platform.intValuePtr.get(C_INT, 0);\n+                    int len = platform.intValuePtr.get(opencl_h.C_INT, 0);\n@@ -118,1 +80,1 @@\n-                return intDeviceInfo(CL_DEVICE_MAX_COMPUTE_UNITS());\n+                return intDeviceInfo(opencl_h.CL_DEVICE_MAX_COMPUTE_UNITS());\n@@ -122,1 +84,1 @@\n-                return strDeviceInfo(CL_DEVICE_NAME());\n+                return strDeviceInfo(opencl_h.CL_DEVICE_NAME());\n@@ -126,1 +88,1 @@\n-                return strDeviceInfo(CL_DEVICE_BUILT_IN_KERNELS());\n+                return strDeviceInfo(opencl_h.CL_DEVICE_BUILT_IN_KERNELS());\n@@ -142,1 +104,1 @@\n-                    var statusPtr = device.platform.openCL.arena.allocate(C_INT, 1);\n+                    var statusPtr = device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, 1);\n@@ -145,3 +107,3 @@\n-                    if ((queue = clCreateCommandQueue(context, device.deviceId, queue_props, statusPtr)) == NULL) {\n-                        int status = statusPtr.get(C_INT, 0);\n-                        clReleaseContext(context);\n+                    if ((this.queue = opencl_h.clCreateCommandQueue(context, device.deviceId, queue_props, statusPtr)) == NULL) {\n+                        int status = statusPtr.get(opencl_h.C_INT, 0);\n+                        opencl_h.clReleaseContext(context);\n@@ -164,3 +126,0 @@\n-                        var statusPtr = context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                   \/\/     MemorySegment sourcePtr = context.device.platform.openCL.arena.allocate(C_CHAR, source.length());\n-                     \/\/   MemorySegment.copy(source.getBytes(), 0, sourcePtr, C_CHAR, 0, source.length());\n@@ -168,7 +127,8 @@\n-                        var sourcePtrPtr = context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n-                        sourcePtrPtr.set(C_POINTER, 0, sourcePtr);\n-                        var sourceLenPtr = context.device.platform.openCL.arena.allocate(C_LONG, 1);\n-                        sourceLenPtr.set(C_LONG, 0, source.length());\n-                        if ((program = clCreateProgramWithSource(context.context, 1, sourcePtrPtr, sourceLenPtr, statusPtr)) == NULL) {\n-                            int status = statusPtr.get(C_INT, 0);\n-                            if (status != CL_SUCCESS()) {\n+                        var sourcePtrPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, sourcePtr);\n+                    \/\/    sourcePtrPtr.set(opencl_h.C_POINTER, 0, sourcePtr);\n+                        var sourceLenPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_LONG,  source.length());\n+                    \/\/    sourceLenPtr.set(opencl_h.C_LONG, 0, source.length());\n+                        var statusPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n+                        if ((program = opencl_h.clCreateProgramWithSource(context.context, 1, sourcePtrPtr, sourceLenPtr, statusPtr)) == NULL) {\n+                            int status = statusPtr.get(opencl_h.C_INT, 0);\n+                            if (status != opencl_h.CL_SUCCESS()) {\n@@ -179,2 +139,2 @@\n-                            int status = statusPtr.get(C_INT, 0);\n-                            if (status != CL_SUCCESS()) {\n+                            int status = statusPtr.get(opencl_h.C_INT, 0);\n+                            if (status != opencl_h.CL_SUCCESS()) {\n@@ -183,3 +143,3 @@\n-                            var deviceIdPtr = context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n-                            deviceIdPtr.set(C_POINTER, 0, context.device.deviceId);\n-                            if ((status = clBuildProgram(program, 1, deviceIdPtr, NULL, NULL, NULL)) != CL_SUCCESS()) {\n+                            var deviceIdPtr = context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, context.device.deviceId);\n+                          \/\/  deviceIdPtr.set(opencl_h.C_POINTER, 0, context.device.deviceId);\n+                            if ((status = opencl_h.clBuildProgram(program, 1, deviceIdPtr, NULL, NULL, NULL)) != opencl_h.CL_SUCCESS()) {\n@@ -190,1 +150,1 @@\n-                            var logLenPtr = context.device.platform.openCL.arena.allocate(C_LONG, 1);\n+                            var logLenPtr = context.device.platform.openCL.arena.allocate(opencl_h.C_LONG, 1);\n@@ -192,1 +152,1 @@\n-                            if ((status = clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), 0, NULL, logLenPtr)) != CL_SUCCESS()) {\n+                            if ((status = opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), 0, NULL, logLenPtr)) != opencl_h.CL_SUCCESS()) {\n@@ -195,6 +155,3 @@\n-                                long logLen = logLenPtr.get(C_LONG, 0);\n-\n-                                var logPtr = context.device.platform.openCL.arena.allocate(C_CHAR, 1 + logLen);\n-\n-\n-                                if ((status = clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), logLen, logPtr, logLenPtr)) != CL_SUCCESS()) {\n+                                long logLen = logLenPtr.get(opencl_h.C_LONG, 0);\n+                                var logPtr = context.device.platform.openCL.arena.allocate(opencl_h.C_CHAR, 1 + logLen);\n+                                if ((status = opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), logLen, logPtr, logLenPtr)) != opencl_h.CL_SUCCESS()) {\n@@ -202,1 +159,0 @@\n-\n@@ -206,1 +162,0 @@\n-\n@@ -210,2 +165,0 @@\n-\n-\n@@ -217,1 +170,1 @@\n-                        String name;\n+                        String kernelName;\n@@ -219,1 +172,1 @@\n-                        public Kernel(Program program, String name) {\n+                        public Kernel(Program program, String kernelName) {\n@@ -221,8 +174,6 @@\n-                            this.name = name;\n-                            var statusPtr = program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                            MemorySegment kernelNamePtr = program.context.device.platform.openCL.arena.allocate(C_CHAR, name.length() + 1);\n-                            MemorySegment.copy(name.getBytes(), 0, kernelNamePtr, C_CHAR, 0, name.length());\n-\n-                            kernel = clCreateKernel(program.program, kernelNamePtr, statusPtr);\n-                            int status = statusPtr.get(C_INT, 0);\n-                            if (status != CL_SUCCESS()) {\n+                            this.kernelName = kernelName;\n+                            var statusPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, opencl_h.CL_SUCCESS());\n+                            MemorySegment kernelNamePtr = program.context.device.platform.openCL.arena.allocateFrom(kernelName);\n+                            kernel = opencl_h.clCreateKernel(program.program, kernelNamePtr, statusPtr);\n+                            int status = statusPtr.get(opencl_h.C_INT, 0);\n+                            if (status != opencl_h.CL_SUCCESS()) {\n@@ -234,2 +185,2 @@\n-                            var bufPtr = program.context.device.platform.openCL.arena.allocate(cl_mem, args.length);\n-                            var statusPtr = program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n+                            var bufPtr = program.context.device.platform.openCL.arena.allocate(opencl_h.cl_mem, args.length);\n+                            var statusPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, opencl_h.CL_SUCCESS());\n@@ -239,2 +190,2 @@\n-                            var eventsPtr = program.context.device.platform.openCL.arena.allocate(cl_event, eventMax);\n-                            boolean block =false;\/\/ true;\n+                            var eventsPtr = program.context.device.platform.openCL.arena.allocate(opencl_h.cl_event, eventMax);\n+                            boolean block = false;\/\/ true;\n@@ -243,1 +194,1 @@\n-                                    MemorySegment clMem = clCreateBuffer(program.context.context,\n+                                    MemorySegment clMem = opencl_h.clCreateBuffer(program.context.context,\n@@ -248,2 +199,2 @@\n-                                    status = statusPtr.get(C_INT, 0);\n-                                    if (status != CL_SUCCESS()) {\n+                                    status = statusPtr.get(opencl_h.C_INT, 0);\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n@@ -252,2 +203,2 @@\n-                                    bufPtr.set(cl_mem, i*cl_mem.byteSize(), clMem);\n-                                    status = clEnqueueWriteBuffer(program.context.queue,\n+                                    bufPtr.set(opencl_h.cl_mem, i * opencl_h.cl_mem.byteSize(), clMem);\n+                                    status = opencl_h.clEnqueueWriteBuffer(program.context.queue,\n@@ -255,1 +206,1 @@\n-                                            block?CL_TRUE():CL_FALSE(), \/\/block?\n+                                            block ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE(), \/\/block?\n@@ -259,3 +210,3 @@\n-                                            block?0:eventc,\n-                                            block?NULL:((eventc == 0) ? NULL : eventsPtr),\n-                                            block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event)\n+                                            block ? 0 : eventc,\n+                                            block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n+                                            block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event)\n@@ -263,1 +214,1 @@\n-                                    if (status != CL_SUCCESS()) {\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n@@ -269,2 +220,1 @@\n-                                    var clMemPtr =  program.context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n-                                    clMemPtr.set(C_POINTER, 0, clMem);\n+                                    var clMemPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, clMem);\n@@ -272,2 +222,2 @@\n-                                    status = clSetKernelArg(kernel, i, C_POINTER.byteSize(), clMemPtr);\n-                                    if (status != CL_SUCCESS()) {\n+                                    status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_POINTER.byteSize(), clMemPtr);\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n@@ -277,7 +227,8 @@\n-                                    bufPtr.set(cl_mem, i*cl_mem.byteSize(), NULL);\n-                                    if (args[i] instanceof Integer integer) {\n-                                        var intPtr =  program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n-                                        intPtr.set(C_INT,0,integer.intValue());\n-                                        status = clSetKernelArg(kernel, i, C_INT.byteSize(), intPtr);\n-                                        if (status != CL_SUCCESS()) {\n-                                            System.out.println(\"failed to set arg \" + status);\n+                                    bufPtr.set(opencl_h.cl_mem, i * opencl_h.cl_mem.byteSize(), NULL);\n+                                    switch (args[i]){\n+                                        case Integer intArg->{\n+                                            var intPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_INT, intArg);\n+                                            status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_INT.byteSize(), intPtr);\n+                                            if (status != opencl_h.CL_SUCCESS()) {\n+                                                System.out.println(\"failed to set arg \" + status);\n+                                            }\n@@ -285,5 +236,4 @@\n-                                    }else if (args[i] instanceof Float f) {\n-                                            var floatPtr =  program.context.device.platform.openCL.arena.allocate(C_FLOAT, 1);\n-                                            floatPtr.set(C_FLOAT,0,f.floatValue());\n-                                            status = clSetKernelArg(kernel, i, C_FLOAT.byteSize(), floatPtr);\n-                                            if (status != CL_SUCCESS()) {\n+                                        case Float floatArg->{\n+                                            var floatPtr = program.context.device.platform.openCL.arena.allocateFrom(opencl_h.C_FLOAT, floatArg);\n+                                            status = opencl_h.clSetKernelArg(kernel, i, opencl_h.C_FLOAT.byteSize(), floatPtr);\n+                                            if (status != opencl_h.CL_SUCCESS()) {\n@@ -293,1 +243,2 @@\n-\n+                                        default -> throw new IllegalStateException(\"Unexpected value: \" + args[i]);\n+                                    }\n@@ -297,3 +248,6 @@\n-                            var globalSizePtr = program.context.device.platform.openCL.arena.allocate(C_INT, 3);\n-                            globalSizePtr.set(C_INT, 0, range);\n-                            status = clEnqueueNDRangeKernel(\n+                            \/\/ We need to store x,y,z sizes so this is a kind of int3\n+                            var globalSizePtr = program.context.device.platform.openCL.arena.allocate(opencl_h.C_INT, 3);\n+                            globalSizePtr.set(opencl_h.C_INT, 0, range);\n+                            globalSizePtr.set(opencl_h.C_INT, 1*opencl_h.C_INT.byteSize(), 0);\n+                            globalSizePtr.set(opencl_h.C_INT, 2*opencl_h.C_INT.byteSize(), 0);\n+                            status = opencl_h.clEnqueueNDRangeKernel(\n@@ -302,1 +256,1 @@\n-                                    1,\n+                                    1, \/\/ this must match the # of dims we are using in this case 1 of 3\n@@ -306,3 +260,3 @@\n-                                    block?0:eventc,\n-                                    block?NULL:((eventc == 0) ? NULL : eventsPtr),\n-                                    block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event\n+                                    block ? 0 : eventc,\n+                                    block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n+                                    block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event\n@@ -311,1 +265,1 @@\n-                            if (status != CL_SUCCESS()) {\n+                            if (status != opencl_h.CL_SUCCESS()) {\n@@ -315,1 +269,0 @@\n-\n@@ -317,2 +270,2 @@\n-                                clFlush(program.context.queue);\n-                            }else{\n+                                opencl_h.clFlush(program.context.queue);\n+                            } else {\n@@ -320,3 +273,2 @@\n-\n-                                status = clWaitForEvents(eventc, eventsPtr);\n-                                if (status != CL_SUCCESS()) {\n+                                status = opencl_h.clWaitForEvents(eventc, eventsPtr);\n+                                if (status != opencl_h.CL_SUCCESS()) {\n@@ -329,3 +281,2 @@\n-                                    MemorySegment clMem = bufPtr.get(cl_mem, (long) i*cl_mem.byteSize());\n-\n-                                   status = clEnqueueReadBuffer(program.context.queue,\n+                                    MemorySegment clMem = bufPtr.get(opencl_h.cl_mem, (long) i * opencl_h.cl_mem.byteSize());\n+                                    status = opencl_h.clEnqueueReadBuffer(program.context.queue,\n@@ -333,1 +284,1 @@\n-                                            block?CL_TRUE():CL_FALSE(),\n+                                            block ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE(),\n@@ -337,3 +288,3 @@\n-                                            block?0:eventc,\n-                                            block?NULL:((eventc == 0) ? NULL : eventsPtr),\n-                                            block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event)\/\/ block?NULL:readEventPtr\n+                                            block ? 0 : eventc,\n+                                            block ? NULL : ((eventc == 0) ? NULL : eventsPtr),\n+                                            block ? NULL : eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event)\/\/ block?NULL:readEventPtr\n@@ -341,1 +292,1 @@\n-                                    if (status != CL_SUCCESS()) {\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n@@ -344,1 +295,1 @@\n-                                    if (!block){\n+                                    if (!block) {\n@@ -350,2 +301,2 @@\n-                                status = clWaitForEvents(eventc, eventsPtr);\n-                                if (status != CL_SUCCESS()) {\n+                                status = opencl_h.clWaitForEvents(eventc, eventsPtr);\n+                                if (status != opencl_h.CL_SUCCESS()) {\n@@ -357,3 +308,3 @@\n-                                    MemorySegment clMem = bufPtr.get(cl_mem, (long) i*cl_mem.byteSize());\n-                                    status = clReleaseMemObject(clMem);\n-                                    if (status != CL_SUCCESS()) {\n+                                    MemorySegment clMem = bufPtr.get(opencl_h.cl_mem, (long) i * opencl_h.cl_mem.byteSize());\n+                                    status = opencl_h.clReleaseMemObject(clMem);\n+                                    if (status != opencl_h.CL_SUCCESS()) {\n@@ -380,1 +331,1 @@\n-                var statusPtr = platform.openCL.arena.allocate(C_INT, 1);\n+                var statusPtr = platform.openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n@@ -382,4 +333,3 @@\n-                var deviceIds = platform.openCL.arena.allocate(C_POINTER, 1);\n-                deviceIds.set(C_POINTER, 0, this.deviceId);\n-                if ((context = clCreateContext(NULL, 1, deviceIds, NULL, NULL, statusPtr)) == NULL) {\n-                    int status = statusPtr.get(C_INT, 0);\n+                var deviceIds = platform.openCL.arena.allocateFrom(opencl_h.C_POINTER, this.deviceId);\n+                if ((context = opencl_h.clCreateContext(NULL, 1, deviceIds, NULL, NULL, statusPtr)) == NULL) {\n+                    int status = statusPtr.get(opencl_h.C_INT, 0);\n@@ -389,2 +339,2 @@\n-                    int status = statusPtr.get(C_INT, 0);\n-                    if (status != CL_SUCCESS()) {\n+                    int status = statusPtr.get(opencl_h.C_INT, 0);\n+                    if (status != opencl_h.CL_SUCCESS()) {\n@@ -400,2 +350,1 @@\n-            int status;\n-            if ((status = clGetPlatformInfo(platformId, query, JAVA_INT.byteSize(), intValuePtr, NULL)) != CL_SUCCESS()) {\n+            if ((opencl_h.clGetPlatformInfo(platformId, query, opencl_h.C_INT.byteSize(), intValuePtr, NULL)) != opencl_h.CL_SUCCESS()) {\n@@ -404,1 +353,1 @@\n-                value = intValuePtr.get(C_INT, 0);\n+                value = intValuePtr.get(opencl_h.C_INT, 0);\n@@ -412,1 +361,1 @@\n-            if ((status = clGetPlatformInfo(platformId, query, 2048, byte2048ValuePtr, intValuePtr)) != CL_SUCCESS()) {\n+            if ((status = opencl_h.clGetPlatformInfo(platformId, query, 2048, byte2048ValuePtr, intValuePtr)) != opencl_h.CL_SUCCESS()) {\n@@ -415,1 +364,1 @@\n-                int len = intValuePtr.get(C_INT, 0);\n+                int len = intValuePtr.get(opencl_h.C_INT, 0);\n@@ -429,1 +378,1 @@\n-            return strPlatformInfo(CL_PLATFORM_NAME());\n+            return strPlatformInfo(opencl_h.CL_PLATFORM_NAME());\n@@ -433,1 +382,1 @@\n-            return strPlatformInfo(CL_PLATFORM_VENDOR());\n+            return strPlatformInfo(opencl_h.CL_PLATFORM_VENDOR());\n@@ -437,1 +386,1 @@\n-            return strPlatformInfo(CL_PLATFORM_VERSION());\n+            return strPlatformInfo(opencl_h.CL_PLATFORM_VERSION());\n@@ -443,3 +392,3 @@\n-            this.intValuePtr = openCL.arena.allocate(C_INT, 1);\n-            this.byte2048ValuePtr = openCL.arena.allocate(C_CHAR, 2048);\n-            var devicecPtr = openCL.arena.allocate(C_INT, 1);\n+            this.intValuePtr = openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n+            this.byte2048ValuePtr = openCL.arena.allocate(opencl_h.C_CHAR, 2048);\n+            var devicecPtr = openCL.arena.allocateFrom(opencl_h.C_INT, 0);\n@@ -447,1 +396,1 @@\n-            if ((status = clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicecPtr)) != CL_SUCCESS()) {\n+            if ((status = opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicecPtr)) != opencl_h.CL_SUCCESS()) {\n@@ -450,1 +399,1 @@\n-                int devicec = devicecPtr.get(C_INT, 0);\n+                int devicec = devicecPtr.get(opencl_h.C_INT, 0);\n@@ -452,2 +401,2 @@\n-                var deviceIdsPtr = openCL.arena.allocate(C_POINTER, devicec);\n-                if ((status = clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec, deviceIdsPtr, devicecPtr)) != CL_SUCCESS()) {\n+                var deviceIdsPtr = openCL.arena.allocate(opencl_h.C_POINTER, devicec);\n+                if ((status = opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec, deviceIdsPtr, devicecPtr)) != opencl_h.CL_SUCCESS()) {\n@@ -458,1 +407,1 @@\n-                        devices.add(new Device(this, deviceIdsPtr.get(C_POINTER, i*C_POINTER.byteSize())));\n+                        devices.add(new Device(this, deviceIdsPtr.get(opencl_h.C_POINTER, i * opencl_h.C_POINTER.byteSize())));\n@@ -471,2 +420,1 @@\n-        int status;\n-        var platformcPtr = arena.allocate(C_INT, 1);\n+        var platformcPtr = arena.allocateFrom(opencl_h.C_INT, 0);\n@@ -474,1 +422,1 @@\n-        if ((status = clGetPlatformIDs(0, NULL, platformcPtr)) != CL_SUCCESS()) {\n+        if ((opencl_h.clGetPlatformIDs(0, NULL, platformcPtr)) != opencl_h.CL_SUCCESS()) {\n@@ -477,1 +425,1 @@\n-            int platformc = platformcPtr.get(JAVA_INT, 0);\n+            int platformc = platformcPtr.get(opencl_h.C_INT, 0);\n@@ -479,3 +427,3 @@\n-            var platformIdsPtr = arena.allocate(C_POINTER, platformc);\n-            if ((status = clGetPlatformIDs(platformc, platformIdsPtr, platformcPtr)) != CL_SUCCESS()) {\n-                System.out.println(\"Failed getting ids\");\n+            var platformIdsPtr = arena.allocate(opencl_h.C_POINTER, platformc);\n+            if ((opencl_h.clGetPlatformIDs(platformc, platformIdsPtr, platformcPtr)) != opencl_h.CL_SUCCESS()) {\n+                System.out.println(\"Failed getting platform ids\");\n@@ -485,1 +433,1 @@\n-                    platforms.add(new Platform(this, platformIdsPtr.get(C_POINTER, i)));\n+                    platforms.add(new Platform(this, platformIdsPtr.get(opencl_h.C_POINTER, i)));\n@@ -496,1 +444,1 @@\n-            CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n+            Platform.Device[] selectedDevice = new Platform.Device[1];\n@@ -514,2 +462,2 @@\n-            var in = arena.allocate(C_INT, 512);\n-            var out = arena.allocate(C_INT, 512);\n+            var in = arena.allocate(opencl_h.C_INT, 512);\n+            var out = arena.allocate(opencl_h.C_INT, 512);\n@@ -517,1 +465,1 @@\n-                in.set(C_INT, (int)i*C_INT.byteSize(),i);\n+                in.set(opencl_h.C_INT, (int) i * opencl_h.C_INT.byteSize(), i);\n@@ -519,1 +467,1 @@\n-            kernel.run(512, in, out );\n+            kernel.run(512, in, out);\n@@ -521,1 +469,1 @@\n-                System.out.println(i + \" \" + out.get(C_INT, (int)i*C_INT.byteSize()));\n+                System.out.println(i + \" \" + out.get(opencl_h.C_INT, (int) i * opencl_h.C_INT.byteSize()));\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","additions":134,"deletions":186,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-        NBody.Mode mode = NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n+        NBody.Mode mode = NBody.Mode.OpenCL4;\/\/NBody.Mode.of(\"HAT\", NBody.Mode.OpenCL);\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/squares\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/examples\/violajones\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-import hat.backend.JavaMultiThreadedBackend;\n-import hat.backend.WorkStealer;\n+import hat.backend.java.JavaMultiThreadedBackend;\n+import hat.backend.java.WorkStealer;\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n@@ -65,0 +65,19 @@\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <jar basedir=\"${hat.stage.jextract}\" destfile=\"${hat.build}\/jextracted-opencl-1.0.jar\" includes=\"opencl\/**\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n","filename":"hat\/extractions\/opencl\/pom.xml","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n@@ -67,0 +67,19 @@\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>1<\/id>\n+                        <phase>install<\/phase>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <target>\n+                                <jar basedir=\"${hat.stage.jextract}\" destfile=\"${hat.build}\/jextracted-opengl-1.0.jar\" includes=\"opengl\/**\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n","filename":"hat\/extractions\/opengl\/pom.xml","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/extractions\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/hat\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,3 @@\n-import hat.buffer.Buffer;\n+import hat.backend.ffi.FFIBackend;\n+import hat.backend.java.JavaMultiThreadedBackend;\n+import hat.backend.java.JavaSequentialBackend;\n@@ -34,2 +36,0 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n@@ -56,1 +56,1 @@\n-    Predicate<Backend> FIRST_NATIVE = backend -> backend instanceof NativeBackend nativeBackend && nativeBackend.isAvailable();\n+    Predicate<Backend> FIRST_NATIVE = backend -> backend instanceof FFIBackend FFIBackend && FFIBackend.isAvailable();\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/Backend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package hat.backend;\n-\n-import hat.ComputeContext;\n-import hat.NDRange;\n-import hat.backend.c99codebuilders.C99HatKernelBuilder;\n-import hat.buffer.ArgArray;\n-import hat.buffer.Buffer;\n-import hat.buffer.KernelContext;\n-import hat.callgraph.KernelCallGraph;\n-import hat.ifacemapper.BoundSchema;\n-import hat.ifacemapper.Schema;\n-\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-public abstract class C99NativeBackend extends NativeBackend {\n-    public C99NativeBackend(String libName) {\n-        super(libName);\n-    }\n-\n-    static class CompiledKernel {\n-        public final C99NativeBackend c99NativeBackend;\n-        public final KernelCallGraph kernelCallGraph;\n-        public final String text;\n-        public final long kernelHandle;\n-        public final ArgArray argArray;\n-        public final KernelContext kernelContext;\n-\n-        CompiledKernel(C99NativeBackend c99NativeBackend, KernelCallGraph kernelCallGraph, String text, long kernelHandle, Object[] ndRangeAndArgs) {\n-            this.c99NativeBackend = c99NativeBackend;\n-            this.kernelCallGraph = kernelCallGraph;\n-            this.text = text;\n-            this.kernelHandle = kernelHandle;\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n-            ndRangeAndArgs[0] = this.kernelContext;\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph.computeContext.runtimeInfo, ndRangeAndArgs);\n-        }\n-\n-        public void dispatch(NDRange ndRange, Object[] args) {\n-            kernelContext.maxX(ndRange.kid.maxX);\n-            args[0] = this.kernelContext;\n-            ArgArray.update(argArray, kernelCallGraph.computeContext.runtimeInfo, args);\n-            c99NativeBackend.ndRange(kernelHandle, this.argArray);\n-        }\n-    }\n-\n-    Map<KernelCallGraph, CompiledKernel> kernelCallGraphCompiledCodeMap = new HashMap<>();\n-\n-    public <T extends C99HatKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n-        builder.defines().pragmas().types();\n-        Set<Schema.IfaceType> already = new LinkedHashSet<>();\n-        Arrays.stream(args)\n-                .filter(arg -> arg instanceof Buffer)\n-                .map(arg -> (Buffer) arg)\n-                .forEach(ifaceBuffer -> {\n-                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n-                    boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n-                        if (!already.contains(t)) {\n-                            builder.typedef(boundSchema, t);\n-                            already.add(t);\n-                        }\n-                    });\n-                });\n-\n-        \/\/ Sorting by rank ensures we don't need forward declarations\n-        kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n-\n-        builder.nl().kernelEntrypoint(kernelCallGraph.entrypoint, args).nl();\n-\n-        System.out.println(\"Original\");\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n-        System.out.println(\"Lowered\");\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n-\n-        return builder.toString();\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/C99NativeBackend.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.backend;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.invoke.MethodHandle;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-\n-public class NativeLib {\n-    final public String name;\n-    public final boolean available;\n-\n-\n-    final public Linker nativeLinker;\n-\n-    final public SymbolLookup loaderLookup;\n-\n-    NativeLib(String name) {\n-        this.name = name;\n-\n-        boolean nonFinalAvailable = true;\n-        try {\n-            Runtime.getRuntime().loadLibrary(name);\n-        } catch (UnsatisfiedLinkError e) {\n-            nonFinalAvailable = false;\n-        }\n-        this.available = nonFinalAvailable;\n-\n-        this.nativeLinker = Linker.nativeLinker();\n-\n-        this.loaderLookup = SymbolLookup.loaderLookup();\n-    }\n-\n-\n-    MethodHandle voidFunc(String name, MemoryLayout... args) {\n-        return loaderLookup.find(name)\n-                .map(symbolSegment -> nativeLinker.downcallHandle(symbolSegment,\n-                        FunctionDescriptor.ofVoid(args)))\n-                .orElse(null);\n-    }\n-\n-    MethodHandle typedFunc(String name, MemoryLayout returnLayout, MemoryLayout... args) {\n-        return loaderLookup.find(name)\n-                .map(symbolSegment -> nativeLinker.downcallHandle(symbolSegment,\n-                        FunctionDescriptor.of(returnLayout, args)))\n-                .orElse(null);\n-    }\n-\n-    MethodHandle longFunc(String name, MemoryLayout... args) {\n-        return typedFunc(name, JAVA_LONG, args);\n-    }\n-\n-    MethodHandle booleanFunc(String name, MemoryLayout... args) {\n-        return typedFunc(name, JAVA_BOOLEAN, args);\n-    }\n-\n-    MethodHandle intFunc(String name, MemoryLayout... args) {\n-        return typedFunc(name, JAVA_INT, args);\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeLib.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.backend.ffi;\n+\n+import hat.NDRange;\n+import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.buffer.ArgArray;\n+import hat.buffer.Buffer;\n+import hat.buffer.KernelContext;\n+import hat.callgraph.KernelCallGraph;\n+import hat.ifacemapper.BoundSchema;\n+import hat.ifacemapper.Schema;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public abstract class C99FFIBackend extends FFIBackend {\n+    public C99FFIBackend(String libName) {\n+        super(libName);\n+    }\n+\n+    public static class CompiledKernel {\n+        public final C99FFIBackend c99FFIBackend;\n+        public final KernelCallGraph kernelCallGraph;\n+        public final String text;\n+        public final long kernelHandle;\n+        public final ArgArray argArray;\n+        public final KernelContext kernelContext;\n+\n+        public CompiledKernel(C99FFIBackend c99FFIBackend, KernelCallGraph kernelCallGraph, String text, long kernelHandle, Object[] ndRangeAndArgs) {\n+            this.c99FFIBackend = c99FFIBackend;\n+            this.kernelCallGraph = kernelCallGraph;\n+            this.text = text;\n+            this.kernelHandle = kernelHandle;\n+            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n+            ndRangeAndArgs[0] = this.kernelContext;\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph.computeContext.runtimeInfo, ndRangeAndArgs);\n+        }\n+\n+        public void dispatch(NDRange ndRange, Object[] args) {\n+            kernelContext.maxX(ndRange.kid.maxX);\n+            args[0] = this.kernelContext;\n+            ArgArray.update(argArray, kernelCallGraph.computeContext.runtimeInfo, args);\n+            c99FFIBackend.ndRange(kernelHandle, this.argArray);\n+        }\n+    }\n+\n+    public Map<KernelCallGraph, CompiledKernel> kernelCallGraphCompiledCodeMap = new HashMap<>();\n+\n+    public <T extends C99HatKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n+        builder.defines().pragmas().types();\n+        Set<Schema.IfaceType> already = new LinkedHashSet<>();\n+        Arrays.stream(args)\n+                .filter(arg -> arg instanceof Buffer)\n+                .map(arg -> (Buffer) arg)\n+                .forEach(ifaceBuffer -> {\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                    boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n+                        if (!already.contains(t)) {\n+                            builder.typedef(boundSchema, t);\n+                            already.add(t);\n+                        }\n+                    });\n+                });\n+\n+        \/\/ Sorting by rank ensures we don't need forward declarations\n+        kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n+                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n+\n+        builder.nl().kernelEntrypoint(kernelCallGraph.entrypoint, args).nl();\n+\n+        System.out.println(\"Original\");\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n+        System.out.println(\"Lowered\");\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n+\n+        return builder.toString();\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -49,1 +49,1 @@\n-public abstract class NativeBackend extends NativeBackendDriver {\n+public abstract class FFIBackend extends FFIBackendDriver {\n@@ -59,1 +59,1 @@\n-    public NativeBackend(String libName) {\n+    public FFIBackend(String libName) {\n@@ -91,1 +91,1 @@\n-    static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n+    protected static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","status":"copied"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.ffi;\n@@ -28,0 +28,1 @@\n+import hat.backend.Backend;\n@@ -41,1 +42,1 @@\n-public abstract class NativeBackendDriver implements Backend {\n+public abstract class FFIBackendDriver implements Backend {\n@@ -68,1 +69,1 @@\n-    public final NativeLib nativeLibrary;\n+    public final FFILib nativeLibrary;\n@@ -70,2 +71,2 @@\n-    public NativeBackendDriver(String libName) {\n-        this.nativeLibrary = new NativeLib(libName);\n+    public FFIBackendDriver(String libName) {\n+        this.nativeLibrary = new FFILib(libName);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":6,"deletions":5,"binary":false,"changes":11,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackendDriver.java","status":"copied"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.ffi;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n+public class FFILib {\n+    final public String name;\n+    public final boolean available;\n+\n+\n+    final public Linker nativeLinker;\n+\n+    final public SymbolLookup loaderLookup;\n+\n+    public FFILib(String name) {\n+        this.name = name;\n+\n+        boolean nonFinalAvailable = true;\n+        try {\n+            Runtime.getRuntime().loadLibrary(name);\n+        } catch (UnsatisfiedLinkError e) {\n+            nonFinalAvailable = false;\n+        }\n+        this.available = nonFinalAvailable;\n+\n+        this.nativeLinker = Linker.nativeLinker();\n+\n+        this.loaderLookup = SymbolLookup.loaderLookup();\n+    }\n+\n+\n+    public MethodHandle voidFunc(String name, MemoryLayout... args) {\n+        return loaderLookup.find(name)\n+                .map(symbolSegment -> nativeLinker.downcallHandle(symbolSegment,\n+                        FunctionDescriptor.ofVoid(args)))\n+                .orElse(null);\n+    }\n+\n+    MethodHandle typedFunc(String name, MemoryLayout returnLayout, MemoryLayout... args) {\n+        return loaderLookup.find(name)\n+                .map(symbolSegment -> nativeLinker.downcallHandle(symbolSegment,\n+                        FunctionDescriptor.of(returnLayout, args)))\n+                .orElse(null);\n+    }\n+\n+    public MethodHandle longFunc(String name, MemoryLayout... args) {\n+        return typedFunc(name, JAVA_LONG, args);\n+    }\n+\n+    public MethodHandle booleanFunc(String name, MemoryLayout... args) {\n+        return typedFunc(name, JAVA_BOOLEAN, args);\n+    }\n+\n+    public MethodHandle intFunc(String name, MemoryLayout... args) {\n+        return typedFunc(name, JAVA_INT, args);\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/FFILib.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.java;\n@@ -29,0 +29,1 @@\n+import hat.backend.Backend;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/JavaBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/JavaBackend.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.java;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/JavaMultiThreadedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/JavaMultiThreadedBackend.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.java;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/JavaSequentialBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/JavaSequentialBackend.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.java;\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/java\/WorkStealer.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/WorkStealer.java","status":"renamed"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.backend.jextracted;\n+\n+import hat.NDRange;\n+import hat.backend.ffi.FFIBackend;\n+import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.buffer.ArgArray;\n+import hat.buffer.Buffer;\n+import hat.buffer.KernelContext;\n+import hat.callgraph.KernelCallGraph;\n+import hat.ifacemapper.BoundSchema;\n+import hat.ifacemapper.Schema;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public abstract class C99JExtractedBackend extends FFIBackend {\n+    public C99JExtractedBackend(String libName) {\n+        super(libName);\n+    }\n+\n+    public static class CompiledKernel {\n+        public final C99JExtractedBackend c99NativeBackend;\n+        public final KernelCallGraph kernelCallGraph;\n+        public final String text;\n+        public final long kernelHandle;\n+        public final ArgArray argArray;\n+        public final KernelContext kernelContext;\n+\n+        public CompiledKernel(C99JExtractedBackend c99NativeBackend, KernelCallGraph kernelCallGraph, String text, long kernelHandle, Object[] ndRangeAndArgs) {\n+            this.c99NativeBackend = c99NativeBackend;\n+            this.kernelCallGraph = kernelCallGraph;\n+            this.text = text;\n+            this.kernelHandle = kernelHandle;\n+            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n+            ndRangeAndArgs[0] = this.kernelContext;\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph.computeContext.runtimeInfo, ndRangeAndArgs);\n+        }\n+\n+        public void dispatch(NDRange ndRange, Object[] args) {\n+            kernelContext.maxX(ndRange.kid.maxX);\n+            args[0] = this.kernelContext;\n+            ArgArray.update(argArray, kernelCallGraph.computeContext.runtimeInfo, args);\n+            c99NativeBackend.ndRange(kernelHandle, this.argArray);\n+        }\n+    }\n+\n+    public Map<KernelCallGraph, CompiledKernel> kernelCallGraphCompiledCodeMap = new HashMap<>();\n+\n+    public <T extends C99HatKernelBuilder<T>> String createCode(KernelCallGraph kernelCallGraph, T builder, Object[] args) {\n+        builder.defines().pragmas().types();\n+        Set<Schema.IfaceType> already = new LinkedHashSet<>();\n+        Arrays.stream(args)\n+                .filter(arg -> arg instanceof Buffer)\n+                .map(arg -> (Buffer) arg)\n+                .forEach(ifaceBuffer -> {\n+                    BoundSchema<?> boundSchema = Buffer.getBoundSchema(ifaceBuffer);\n+                    boundSchema.schema().rootIfaceType.visitTypes(0, t -> {\n+                        if (!already.contains(t)) {\n+                            builder.typedef(boundSchema, t);\n+                            already.add(t);\n+                        }\n+                    });\n+                });\n+\n+        \/\/ Sorting by rank ensures we don't need forward declarations\n+        kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n+                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n+\n+        builder.nl().kernelEntrypoint(kernelCallGraph.entrypoint, args).nl();\n+\n+        System.out.println(\"Original\");\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n+        System.out.println(\"Lowered\");\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n+\n+        return builder.toString();\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package hat.backend;\n+package hat.backend.jextracted;\n@@ -29,0 +29,1 @@\n+import hat.backend.ffi.FFIBackendDriver;\n@@ -35,2 +36,0 @@\n-\n-import java.lang.foreign.Arena;\n@@ -45,0 +44,2 @@\n+import java.lang.foreign.Arena;\n+\n@@ -49,1 +50,1 @@\n-public abstract class NativeBackend extends NativeBackendDriver {\n+public abstract class JExtractedBackend extends FFIBackendDriver {\n@@ -59,1 +60,1 @@\n-    public NativeBackend(String libName) {\n+    public JExtractedBackend(String libName) {\n@@ -91,1 +92,1 @@\n-    static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n+    protected static FuncOpWrapper injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":7,"deletions":6,"binary":false,"changes":13,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package hat.backend;\n+package hat.backend.jextracted;\n@@ -28,0 +28,2 @@\n+import hat.backend.Backend;\n+import hat.backend.ffi.FFILib;\n@@ -41,1 +43,1 @@\n-public abstract class NativeBackendDriver implements Backend {\n+public abstract class JExtractedBackendDriver implements Backend {\n@@ -68,1 +70,1 @@\n-    public final NativeLib nativeLibrary;\n+    public final FFILib nativeLibrary;\n@@ -70,2 +72,2 @@\n-    public NativeBackendDriver(String libName) {\n-        this.nativeLibrary = new NativeLib(libName);\n+    public JExtractedBackendDriver(String libName) {\n+        this.nativeLibrary = new FFILib(libName);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackendDriver.java","additions":7,"deletions":5,"binary":false,"changes":12,"previous_filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackendDriver.java","status":"renamed"},{"patch":"@@ -26,2 +26,1 @@\n-import hat.backend.Backend;\n-import hat.backend.JavaMultiThreadedBackend;\n+import hat.backend.java.JavaMultiThreadedBackend;\n@@ -32,8 +31,0 @@\n-import java.lang.reflect.Method;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n@@ -41,1 +32,0 @@\n-import java.util.List;\n","filename":"hat\/hat\/src\/main\/test\/hat\/SquaresTest.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-void main(String[] args) {\n+void main(String[] argv) {\n@@ -45,1 +45,1 @@\n-  var hatDir =  Dir.current();\n+  var hatDir =  DirEntry.current();\n@@ -47,52 +47,39 @@\n-  var examples = hatDir.existingDir(\"examples\");\n-  var buildDir = assertExists(BuildDir.of(hatDir.path(\"build\")));\n-\n-  var extractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n-  var extractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n-\n-\n-  var javaBuilder = javaBuilder()\n-    .enable_preview()\n-    .add_modules(\"jdk.incubator.code\")\n-    .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n-    .enable_native_access(\"ALL-UNNAMED\")\n-    .library_path(buildDir)\n-    .class_path(buildDir.jarFile(\"hat-1.0.jar\"));\n-\n-  int argn = 0;\n-  if (args.length > 0 && args[argn].equals(\"headless\")) {\n-    javaBuilder.opts(\"-Dheadless=true\");\n-    argn++;\n-  }\n-  if ((argn + 2) > args.length) {\n-    print(\"args[\" + args.length + \"] = [ \");\n-    List.of(args).forEach(a -> print(\" \" + a));\n-    println(\" ]\");\n-    println(usage);\n-  } else {\n-    var backendName = args[argn++];\n-    var exampleName = args[argn++];\n-    javaBuilder.when( exampleName.equals(\"nbody\"), $->$\n-       .start_on_first_thread()\n-       .class_path(buildDir.jarFile(\"hat-1.0.jar\"), extractedOpenGLJar, extractedOpenCLJar)\n-    );\n-\n-    if (backendName.equals(\"java\")) {\n-      javaBuilder.class_path(ClassDir.of(backends.path(\"shared\/src\/main\/resources\")));\n-    } else if (backends.dir(backendName) instanceof Dir backend && backend.exists()) {\n-      javaBuilder.class_path(buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\"));\n-    } else {\n-      println(\"No backend \" + backendName);\n-    }\n-\n-    if (buildDir.jarFile(\"hat-example-\" + exampleName + \"-1.0.jar\") instanceof bldr.Bldr.JarFile exampleJar && exampleJar.exists()){\n-      java(javaBuilder\n-        .verbose()\n-        .class_path(exampleJar)\n-        .main_class(exampleName + \".Main\")\n-        .args(Arrays.copyOfRange(args, argn, args.length))\n-      );\n-    } else {\n-      println(\"no example \" + exampleName);\n-    }\n-  }\n+  var examples = hatDir.dir(\"examples\");\n+  var buildDir = hatDir.existingBuildDir(\"build\");\n+  var jextractedOpenCLJar = buildDir.jarFile(\"jextracted-opencl.jar\");\n+  var jextractedOpenGLJar = buildDir.jarFile(\"jextracted-opengl.jar\");\n+  var args = new ArrayList<>(List.of(argv));\n+  java(java -> java\n+     .enable_preview()\n+     .add_exports(\"java.base\", \"jdk.internal\", \"ALL-UNNAMED\")\n+     .enable_native_access(\"ALL-UNNAMED\")\n+     .library_path(buildDir)\n+     .class_path(buildDir.jarFile(\"hat-1.0.jar\"))\n+     .when((!args.isEmpty() && args.getFirst().equals(\"headless\")), ifHeadless -> {\n+        ifHeadless.headless();\n+        args.removeFirst();\n+     })\n+     .either(!args.isEmpty(), haveBackend -> {\n+        var backendName = args.removeFirst();\n+        if (backends.dir(backendName.replace('-','\/')) instanceof DirEntry backend && backend.exists()) {\n+           haveBackend.class_path(buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\"));\n+        } else {\n+           throw new RuntimeException(\"No such backend \" + backendName);\n+        }\n+        if (!args.isEmpty() && args.removeFirst() instanceof String exampleName) {\n+           if (examples.dir(exampleName) instanceof DirEntry example && example.exists()) { haveBackend\n+              .class_path(buildDir.jarFile(\"hat-example-\" + exampleName + \"-1.0.jar\"))\n+              .when(jextractedOpenCLJar.exists() && jextractedOpenGLJar.exists() && exampleName.equals(\"nbody\"), _->{ haveBackend\n+                  .class_path(jextractedOpenCLJar,jextractedOpenGLJar)\n+                  .start_on_first_thread();\n+              })\n+              .main_class(exampleName + \".Main\")\n+              .args(args);\n+           } else {\n+              throw new RuntimeException(\"no such example \" + exampleName);\n+           }\n+        }\n+     }, _ -> {\n+        throw new RuntimeException(\"No backend provided...\\n\" + usage);\n+     })\n+  );\n","filename":"hat\/hatrun","additions":41,"deletions":54,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-   echo '       backend  : opencl|cuda|hip|spirv|ptx|mock'\n+   echo '       backend  : native-opencl|native-cuda|native-hip|native-spirv|native-ptx|native-mock|java-mt|java-seq'\n@@ -59,19 +59,11 @@\n-   if [[ -d backends\/$1 || \"$1\" = \"java\" ]] ; then\n-      export JARS=build\/hat-1.0.jar\n-      if [[ \"$1\" = \"java\" ]] ; then \n-         export BACKEND_JAR_or_DIR=backends\/shared\/src\/main\/resources\n-         echo BACKEND_JAR_or_DIR=${BACKEND_JAR_or_DIR}\n-      else\n-         export BACKEND_JAR_or_DIR=build\/hat-backend-${BACKEND}-1.0.jar\n-         echo BACKEND_JAR_or_DIR=${BACKEND_JAR_or_DIR}\n-         if [[ ! -f ${BACKEND_JAR_or_DIR} ]] ;then\n-            echo \"no backend ${BACKEND_JAR_or_DIR}\"\n-            exit 1\n-         fi\n-      fi\n-      export JARS=${JARS}:${BACKEND_JAR_or_DIR}\n-      if [[ \"$1\" = \"spirv\" ]] ;then \n-         export JARS=${JARS}:build\/levelzero.jar:build\/beehive-spirv-lib-0.0.4.jar;\n-      fi\n-      export OPTS=\"${OPTS} -Djava.library.path=build:\/usr\/local\/lib\"\n-      shift 1\n+   export BACKEND_JAR=build\/hat-backend-${BACKEND}-1.0.jar\n+\n+   export JARS=build\/hat-1.0.jar\n+   echo BACKEND_JAR=${BACKEND_JAR}\n+   if [[ ! -f ${BACKEND_JAR} ]] ;then\n+      echo \"no backend ${BACKEND_JAR}\"\n+      exit 1\n+   fi\n+   export JARS=${JARS}:${BACKEND_JAR}\n+   if [[ \"$1\" = \"spirv\" ]] ;then \n+      export JARS=${JARS}:build\/levelzero.jar:build\/beehive-spirv-lib-0.0.4.jar;\n@@ -79,0 +71,2 @@\n+   export OPTS=\"${OPTS} -Djava.library.path=build:\/usr\/local\/lib\"\n+   shift 1\n@@ -87,1 +81,1 @@\n-      echo \"no example build\/${EXAMPLE_JAR}\"\n+      echo \"no example ${EXAMPLE_JAR}\"\n","filename":"hat\/hatrun.bash","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7,6 +7,10 @@\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_cuda.iml\" filepath=\"$PROJECT_DIR$\/backend_cuda.iml\" \/>\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_mock.iml\" filepath=\"$PROJECT_DIR$\/backend_mock.iml\" \/>\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ptx.iml\" filepath=\"$PROJECT_DIR$\/backend_ptx.iml\" \/>\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_opencl.iml\" filepath=\"$PROJECT_DIR$\/backend_opencl.iml\" \/>\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_spirv.iml\" filepath=\"$PROJECT_DIR$\/backend_spirv.iml\" \/>\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_shared.iml\" filepath=\"$PROJECT_DIR$\/backend_shared.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_cuda.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_cuda.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_mock.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_mock.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_ptx.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_ptx.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_opencl.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_opencl.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_spirv.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_spirv.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_ffi_shared.iml\" filepath=\"$PROJECT_DIR$\/backend_ffi_shared.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_java_mt.iml\" filepath=\"$PROJECT_DIR$\/backend_java_mt.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_java_seq.iml\" filepath=\"$PROJECT_DIR$\/backend_java_seq.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_jextracted_opencl.iml\" filepath=\"$PROJECT_DIR$\/backend_jextracted_opencl.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/backend_jextracted_shared.iml\" filepath=\"$PROJECT_DIR$\/backend_jextracted_shared.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,16 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/cuda\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/cuda\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/cuda\/include\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/cuda\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/cuda\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_shared\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/backend_cuda.iml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\">\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/include\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/cuda\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_ffi_cuda.iml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/mock\">\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/mock\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/mock\/include\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/mock\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/mock\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_ffi_mock.iml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\">\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/include\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/opencl\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_ffi_opencl.iml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\">\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/include\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/ptx\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_ffi_ptx.iml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\">\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/include\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/shared\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_ffi_shared.iml","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/..\/cr-examples\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/..\/cr-examples\/spirv\/src\/main\/java\" isTestSource=\"false\" \/>\n+    <\/content>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/spirv\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/spirv\/src\/main\/resources\" type=\"java-resource\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/spirv\/cpp\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/spirv\/include\" \/>\n+      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ffi\/spirv\/src\/main\/java\" \/>\n+    <\/content>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/..\/..\/beehive-spirv-toolkit\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/..\/..\/beehive-spirv-toolkit\/lib\/src\/main\/java\" isTestSource=\"false\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_ffi_spirv.iml","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/java\/mt\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/java\/mt\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/java\/mt\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_native_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_java_mt.iml","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/java\/seq\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/java\/seq\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/java\/seq\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_native_shared\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_java_seq.iml","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/jextracted\/opencl\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/jextracted\/opencl\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/jextracted\/opencl\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_jextracted_shared\" \/>\n+    <orderEntry type=\"module-library\">\n+      <library>\n+        <CLASSES>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/jextracted-opencl.jar!\/\" \/>\n+        <\/CLASSES>\n+        <JAVADOC \/>\n+        <SOURCES \/>\n+      <\/library>\n+    <\/orderEntry>\n+  <\/component>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_jextracted_opencl.iml","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/jextracted\/shared\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/jextracted\/shared\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/jextracted\/shared\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"hat\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/backend_jextracted_shared.iml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -1,16 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/mock\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/mock\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/mock\/include\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/mock\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/mock\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_shared\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/backend_mock.iml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -1,16 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/opencl\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/opencl\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/opencl\/include\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/opencl\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/opencl\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_shared\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/backend_opencl.iml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -1,16 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ptx\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ptx\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ptx\/include\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ptx\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/ptx\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_shared\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/backend_ptx.iml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/shared\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/shared\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/shared\/include\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/shared\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/shared\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/backend_shared.iml","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/..\/cr-examples\">\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/..\/cr-examples\/spirv\/src\/main\/java\" isTestSource=\"false\" \/>\n-    <\/content>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/backends\/spirv\">\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/spirv\/src\/main\/resources\" type=\"java-resource\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/spirv\/cpp\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/spirv\/include\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/..\/backends\/spirv\/src\/main\/java\" \/>\n-    <\/content>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/..\/..\/beehive-spirv-toolkit\">\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/..\/..\/beehive-spirv-toolkit\/lib\/src\/main\/java\" isTestSource=\"false\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"hat\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_shared\" \/>\n-  <\/component>\n-<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/backend_spirv.iml","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -12,3 +12,0 @@\n-    <orderEntry type=\"module\" module-name=\"backend_opencl\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_cuda\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_spirv\" \/>\n@@ -33,0 +30,1 @@\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n","filename":"hat\/intellij\/nbody.iml","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import bldr.CMakeProbe;\n-import bldr.Capabilities;\n-import static bldr.Capabilities.*;\n+import static bldr.Bldr.Capabilities.*;\n@@ -47,1 +45,1 @@\n-            accompanied this code).\n+      accompanied this code).\n@@ -51,1 +49,1 @@\n-        Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+      Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -53,4 +51,4 @@\n-           Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-           or visit www.oracle.com if you need additional information or have any\n-           questions.                \n-           \"\"\";\n+      Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+      or visit www.oracle.com if you need additional information or have any\n+      questions.                \n+      \"\"\";\n@@ -58,1 +56,6 @@\n-   var hatDir = Dir.current();\n+  var hatDir = DirEntry.current();\n+  var hatCore = hatDir.existingDir(\"hat\");\n+  var backends = hatDir.existingDir(\"backends\");\n+  var examples = hatDir.existingDir(\"examples\");\n+  var extractions = hatDir.existingDir(\"extractions\");\n+  var buildDir = hatDir.existingBuildDir(\"build\");\n@@ -60,8 +63,6 @@\n-    var hatCoreDir = hatDir.existingDir(\"hat\");\n-    var backends = hatDir.existingDir(\"backends\");\n-    var examples = hatDir.existingDir(\"examples\");\n-    var extractions = hatDir.existingDir(\"extractions\");\n-    var buildDir = hatDir.existingBuildDir(\"build\");\n-    var capabilities = Capabilities.of( OpenCL.of(),OpenGL.of(),CUDA.of(),HIP.of());\n-    var cmakeProbe = new CMakeProbe(buildDir,capabilities);\n-    capabilities.capabilities().forEach(fw->println((fw.available()?\"we have \":\"no \")+fw.name));\n+  var opencl = OpenCL.of();\n+  var opengl = OpenGL.of();\n+  var cuda = CUDA.of();\n+  var hip = HIP.of();\n+  var jextract = JExtract.of();\n+  var cmake = CMake.of();\n@@ -69,34 +70,1 @@\n-    hatDir.pom(pomComment, pom -> pom\n-            .comment(\"Auto generated by mkpoms\")\n-            .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n-            .properties(properties -> properties\n-                    .property(\"project.build.sourceEncoding\", \"UTF-8\")\n-                    .property(\"hat.root\", \"${env.PWD}\")\n-                    .property(\"hat.build\", \"${hat.root}\/build\")\n-                    .property(\"hat.stage\", \"${hat.root}\/stage\")\n-                    .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n-                    .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n-                    .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n-                    .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n-            )\n-            .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n-            .build(build -> build\n-                    .plugins(plugins -> plugins\n-                            .compilerPlugin(plugin -> plugin\n-                                    .configuration(configuration -> configuration\n-                                            .compilerArgs(\n-                                                    \"--add-modules=jdk.incubator.code\",\n-                                                    \"--enable-preview\",\n-                                                    \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                                                    \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-                                            )\n-                                            .source(\"24\")\n-                                            .target(\"24\")\n-                                            .showDeprecation(\"true\")\n-                                            .failOnError(\"true\")\n-                                            .showWarnings(\"true\")\n-                                    )\n-                            )\n-                    )\n-            )\n-    );\n+  var capabilities = Capabilities.of(opencl, opengl, cuda, hip, jextract, cmake);\n@@ -104,27 +72,4 @@\n-    \/\/ Now hat\/pom.xml\n-    hatCoreDir.pom(pomComment, pom -> pom\n-            .comment(\"Auto generated by mkpoms\")\n-            .jar(\"oracle.code\", \"hat\", \"1.0\")\n-            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-            .dependsOn(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n-            .build(build -> build\n-                    .pluginManagement(pluginManagement -> pluginManagement\n-                            .plugins(plugins -> plugins\n-                                    .surefirePlugin(plugin -> plugin\n-                                            .configuration(configuration -> configuration\n-                                                    .argLine(\"-enable-preview\")\n-                                            )\n-                                    )\n-                            )\n-                    )\n-                    .plugins(plugins -> plugins\n-                            .antPlugin(plugin -> plugin\n-                                    .executions(executions -> executions\n-                                            .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                                    .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n-                                            )\n-                                    )\n-                            )\n-                    )\n-            )\n-    );\n+  if (cmake.available()) {\n+    cmake.probe(buildDir, capabilities);\n+  }\n+  capabilities.capabilities().forEach(fw -> println((fw.available() ? \"we have \" : \"no \") + fw.name));\n@@ -132,3 +77,34 @@\n-    \/\/ Note that we filter by capability here. So we only create poms (and include modules in parent) if capability is available\n-    var extractionDirs = extractions\n-            .subDirs(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n+  hatDir.pom(pomComment, pom -> pom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .properties(properties -> properties\n+          .property(\"project.build.sourceEncoding\", \"UTF-8\")\n+          .property(\"hat.root\", \"${env.PWD}\")\n+          .property(\"hat.build\", \"${hat.root}\/build\")\n+          .property(\"hat.stage\", \"${hat.root}\/stage\")\n+          .property(\"hat.stage.repo\", \"${hat.stage}\/repo\")\n+          .property(\"hat.stage.jextract\", \"${hat.stage}\/jextract\")\n+          .property(\"mac.app.frameworks\", \"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\")\n+          .property(\"mac.lib.frameworks\", \"\/System\/Library\/Frameworks\")\n+      )\n+      .modules(\"hat\", \"extractions\", \"backends\", \"examples\")\n+      .build(build -> build\n+          .plugins(plugins -> plugins\n+              .compilerPlugin(plugin -> plugin\n+                  .configuration(configuration -> configuration\n+                      .compilerArgs(\n+                          \"--add-modules=jdk.incubator.code\",\n+                          \"--enable-preview\",\n+                          \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                          \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+                      )\n+                      .source(\"24\")\n+                      .target(\"24\")\n+                      .showDeprecation(\"true\")\n+                      .failOnError(\"true\")\n+                      .showWarnings(\"true\")\n+                  )\n+              )\n+          )\n+      )\n+  );\n@@ -136,16 +112,27 @@\n-    extractions.pom(pomComment, pom -> pom\n-            .comment(\"Auto generated by mkpoms\")\n-            .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n-            .modules(extractionDirs.stream().map(PathHolder::fileName).toList())\n-            .build(build -> build\n-                    .plugins(plugins -> plugins\n-                            .antPlugin(plugin -> plugin\n-                                    .executions(executions -> executions\n-                                            .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n-                                                    .mkdir(\"${hat.stage.jextract}\")\n-                                                    .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n-                                            )\n-                                    )\n-                            )\n-                    )\n+  \/\/ Now hat\/pom.xml\n+  hatCore.pom(pomComment, pom -> pom\n+      .comment(\"Auto generated by mkpoms\")\n+      .jar(\"oracle.code\", \"hat\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .dependsOn(\"org.junit.jupiter\", \"junit-jupiter-engine\", \"5.10.0\", \"test\")\n+      .build(build -> build\n+          .pluginManagement(pluginManagement -> pluginManagement\n+              .plugins(plugins -> plugins\n+                  .surefirePlugin(plugin -> plugin\n+                      .configuration(configuration -> configuration\n+                          .argLine(\"-enable-preview\")\n+                      )\n+                  )\n+              )\n+          )\n+          .plugins(plugins -> plugins\n+              .antPlugin(plugin -> plugin\n+                  .executions(executions -> executions\n+                      .ant(\"1\", \"install\", \"run\", ant -> ant\n+                          .copy(\"target\/${project.artifactId}-1.0.jar\", \"${hat.build}\")\n+                      )\n+                  )\n+              )\n+          )\n+      )\n+  );\n@@ -153,2 +140,3 @@\n-            )\n-    );\n+  \/\/ Note that we filter by capability here. So we only create poms (and include modules in parent) if capability is available\n+  var extractionDirs = extractions\n+      .subDirs(extraction -> !extraction.matches(\"^.*(target)$\")).filter(dir -> capabilities.capabilityIsAvailable(dir.fileName())).toList();\n@@ -156,31 +144,124 @@\n-    extractionDirs.forEach(extraction -> extraction\n-            .pom(pomComment, examplePom -> examplePom\n-                .comment(\"Auto generated by mkpoms\")\n-                .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n-                .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n-                .build(build -> build\n-                        .plugins(plugins -> plugins\n-                                .execPlugin(plugin -> plugin\n-                                        .executions(execution -> execution\n-                                                .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n-                                                        .executable(\"jextract\")\n-                                                        .workingDirectory(\"${hat.stage.jextract}\")\n-                                                        .arguments(arguments -> {arguments\n-                                                                    .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n-                                                                    .argument(\"-t\").argument(extraction.fileName());\n-                                                            switch (extraction.fileName()) {\n-                                                                case \"opencl\" -> arguments\n-                                                                        .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n-                                                                        .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n-                                                                case \"opengl\" -> arguments\n-                                                                        .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n-                                                                        .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n-                                                                        .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n-                                                                default ->\n-                                                                        throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n-                                                            }\n-                                                        })\n-                                                )\n-                                        )\n-                                )\n-                        )\n+  extractions.pom(pomComment, pom -> pom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .modules(extractionDirs.stream().map(PathHolder::fileName).toList())\n+      .build(build -> build\n+          .plugins(plugins -> plugins\n+              .antPlugin(plugin -> plugin\n+                  .executions(executions -> executions\n+                      .ant(\"createDir\", \"compile\", \"run\", ant -> ant\n+                          .mkdir(\"${hat.stage.jextract}\")\n+                          .echo(\"${hat.stage.jextract}\/compile_flags.txt\", \"-F${mac.app.frameworks}\")\n+                      )\n+                  )\n+              )\n+          )\n+\n+      )\n+  );\n+\n+  extractionDirs.forEach(extraction -> extraction\n+      .pom(pomComment, examplePom -> examplePom\n+          .comment(\"Auto generated by mkpoms\")\n+          .pom(\"oracle.code\", \"hat-extraction-\" + extraction.fileName(), \"1.0\")\n+          .parent(\"oracle.code\", \"hat-extractions\", \"1.0\")\n+          .build(build -> build\n+              .plugins(plugins -> plugins\n+                  .execPlugin(plugin -> plugin\n+                      .executions(execution -> execution\n+                          .execIdPhaseConf(\"2\", \"compile\", configuration -> configuration\n+                              .executable(\"jextract\")\n+                              .workingDirectory(\"${hat.stage.jextract}\")\n+                              .arguments(arguments -> {\n+                                arguments\n+                                    .argument(\"--output\").argument(\"${hat.stage.jextract}\")\n+                                    .argument(\"-t\").argument(extraction.fileName());\n+                                switch (extraction.fileName()) {\n+                                  case \"opencl\" -> arguments\n+                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenCL.framework\/OpenCL\")\n+                                      .argument(\"${mac.app.frameworks}\/OpenCL.framework\/Headers\/opencl.h\");\n+                                  case \"opengl\" -> arguments\n+                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/GLUT.framework\/GLUT\")\n+                                      .argument(\"-l\").argument(\"${mac.lib.frameworks}\/OpenGL.framework\/OpenGL\")\n+                                      .argument(\"${mac.app.frameworks}\/GLUT.framework\/Headers\/glut.h\");\n+                                  default ->\n+                                      throw new IllegalStateException(\"Unexpected value: \" + extraction.fileName());\n+                                }\n+                              })\n+                          )\n+                      )\n+                  )\n+                  .antPlugin(plugin -> plugin\n+                      .executions(executions -> executions\n+                          .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                   .antjar(\"${hat.stage.jextract}\", extraction.fileName(), \"${hat.build}\/jextracted-\" + extraction.fileName() + \"-1.0.jar\")\n+                               \/\/.copy(\"target\/jextracted\" + extraction.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                          )\n+                      )\n+                  )\n+              )\n+          )\n+      )\n+  );\n+\n+  var exampleDirs = examples.subDirs(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n+\n+  \/\/ Here we create examples\/pom.xml and nested inside we create each example\/*\/pom.xml\n+  examples.pom(pomComment, examplesPom -> examplesPom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+      .modules(exampleDirs.stream().map(PathHolder::fileName).toList())\n+  );\n+\n+  exampleDirs.forEach(example -> example\n+      .pom(pomComment, examplePom -> examplePom\n+          .comment(\"Auto generated by mkpoms\")\n+          .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n+          .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n+          .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+          .build(build -> build\n+              .plugins(plugins -> plugins\n+                  .antPlugin(plugin -> plugin\n+                      .executions(executions -> executions\n+                          .ant(\"1\", \"install\", \"run\", ant -> ant\n+                              .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n+                          )\n+                      )\n+                  )\n+              )\n+          )\n+      )\n+  );\n+  var backendDirs = backends.subDirs(backend -> !backend.matches(\"^.*(jextracted|target|.idea)$\")).toList();\n+\n+  \/\/ Now backends\/pom.xml and backends\/*\/pom.xml\n+  backends.pom(pomComment, backendsPom -> backendsPom\n+      .comment(\"Auto generated by mkpoms\")\n+      .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n+      .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+      .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+      .modules(\"java\", \"ffi\")\n+  );\n+\n+  {\n+    var ffiBackend = backends.dir(\"ffi\");\n+\n+\n+    var ffiBackendDirs = ffiBackend.subDirs(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n+\n+    ffiBackend.pom(pomComment, backendsPom -> backendsPom\n+        .comment(\"Auto generated by mkpoms\")\n+        .pom(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n+        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n+        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+        .modules(ffiBackendDirs.stream().map(PathHolder::fileName).toList())\n+        .build(build -> build\n+            .plugins(plugins -> plugins\n+                .execPlugin(plugin -> plugin\n+                    .executions(executions -> executions\n+                        .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n+                        .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n+                    )\n@@ -188,0 +269,1 @@\n+            )\n@@ -191,4 +273,2 @@\n-    var exampleDirs = examples.subDirs(example -> !example.matches(\"^.*(experiments|target|nbody|.idea)$\")).toList();\n-\n-    \/\/ Here we create examples\/pom.xml and nested inside we create each example\/*\/pom.xml\n-    examples.pom(pomComment, examplesPom -> examplesPom\n+    ffiBackendDirs.forEach(backend -> backend\n+        .pom(pomComment, backendPom -> backendPom\n@@ -196,2 +276,2 @@\n-            .pom(\"oracle.code\", \"hat-examples\", \"1.0\")\n-            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+            .jar(\"oracle.code\", \"hat-backend-ffi-\" + backend.fileName(), \"1.0\")\n+            .parent(\"oracle.code\", \"hat-backends-ffi\", \"1.0\")\n@@ -199,18 +279,11 @@\n-            .modules(exampleDirs.stream().map(PathHolder::fileName).toList())\n-    );\n-\n-    exampleDirs.forEach(example -> example\n-            .pom(pomComment, examplePom -> examplePom\n-                    .comment(\"Auto generated by mkpoms\")\n-                    .jar(\"oracle.code\", \"hat-example-\" + example.fileName(), \"1.0\")\n-                    .parent(\"oracle.code\", \"hat-examples\", \"1.0\")\n-                    .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-                    .build(build -> build\n-                            .plugins(plugins -> plugins\n-                                    .antPlugin(plugin -> plugin\n-                                            .executions(executions -> executions\n-                                                    .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                                            .copy(\"target\/hat-example-\" + example.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                                                    )\n-                                            )\n-                                    )\n+            .build(build -> build\n+                .plugins(plugins -> plugins\n+                    .execPlugin(plugin -> plugin\n+                        .configuration(configuration -> configuration\n+                            .skip(\"true\")\n+                        )\n+                    )\n+                    .antPlugin(plugin -> plugin\n+                        .executions(executions -> executions\n+                            .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                .copy(\"target\/hat-backend-ffi-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n@@ -218,0 +291,1 @@\n+                        )\n@@ -219,0 +293,1 @@\n+                )\n@@ -220,0 +295,1 @@\n+        )\n@@ -221,0 +297,4 @@\n+  }\n+  {\n+    var javaBackend = backends.dir(\"java\");\n+    var javaBackendDirs = javaBackend.subDirs(backend -> !backend.matches(\"^.*(target|.idea)$\")).toList();\n@@ -222,3 +302,7 @@\n-    \/\/ Now backends\/pom.xml and backends\/*\/pom.xml\n-\n-    var backendDirs = backends.subDirs(backend -> !backend.matches(\"^.*(hip|spirv|shared|openclx|target|.idea)$\")).toList();\n+    javaBackend.pom(pomComment, backendsPom -> backendsPom\n+        .comment(\"Auto generated by mkpoms\")\n+        .pom(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n+        .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n+        .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n+        .modules(javaBackendDirs.stream().map(PathHolder::fileName).toList())\n+    );\n@@ -226,1 +310,2 @@\n-    backends.pom(pomComment, backendsPom -> backendsPom\n+    javaBackendDirs.forEach(backend -> backend\n+        .pom(pomComment, backendPom -> backendPom\n@@ -228,2 +313,2 @@\n-            .pom(\"oracle.code\", \"hat-backends\", \"1.0\")\n-            .parent(\"oracle.code\", \"hat-root\", \"1.0\")\n+            .jar(\"oracle.code\", \"hat-backend-java-\" + backend.fileName(), \"1.0\")\n+            .parent(\"oracle.code\", \"hat-backends-java\", \"1.0\")\n@@ -231,1 +316,0 @@\n-            .modules(backendDirs.stream().map(PathHolder::fileName).toList())\n@@ -233,6 +317,5 @@\n-                    .plugins(plugins -> plugins\n-                            .execPlugin(plugin -> plugin\n-                                    .executions(executions -> executions\n-                                            .cmake(\"1\", \"compile\", \"-DHAT_TARGET=${hat.build}\", \"-B\", \"${hat.build}\/cmake-build-debug\")\n-                                            .cmake(\"2\", \"install\", \"--build\", \"${hat.build}\/cmake-build-debug\")\n-                                    )\n+                .plugins(plugins -> plugins\n+                    .antPlugin(plugin -> plugin\n+                        .executions(executions -> executions\n+                            .ant(\"1\", \"install\", \"run\", ant -> ant\n+                                .copy(\"target\/hat-backend-java-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n@@ -240,0 +323,1 @@\n+                        )\n@@ -241,0 +325,1 @@\n+                )\n@@ -242,0 +327,1 @@\n+        )\n@@ -243,0 +329,1 @@\n+  }\n@@ -244,24 +331,0 @@\n-    backendDirs.forEach(backend -> backend\n-            .pom(pomComment, backendPom -> backendPom\n-                    .comment(\"Auto generated by mkpoms\")\n-                    .jar(\"oracle.code\", \"hat-backend-\" + backend.fileName(), \"1.0\")\n-                    .parent(\"oracle.code\", \"hat-backends\", \"1.0\")\n-                    .dependsOn(\"oracle.code\", \"hat\", \"1.0\")\n-                    .build(build -> build\n-                            .plugins(plugins -> plugins\n-                                    .execPlugin(plugin -> plugin\n-                                            .configuration(configuration -> configuration\n-                                                    .skip(\"true\")\n-                                            )\n-                                    )\n-                                    .antPlugin(plugin -> plugin\n-                                            .executions(executions -> executions\n-                                                    .ant(\"1\", \"install\", \"run\", ant -> ant\n-                                                            .copy(\"target\/hat-backend-\" + backend.fileName() + \"-1.0.jar\", \"${hat.build}\")\n-                                                    )\n-                                            )\n-                                    )\n-                            )\n-                    )\n-            )\n-    );\n@@ -269,0 +332,1 @@\n+  var backendJExtracted = backends.dir(\"jextracted\");\n","filename":"hat\/mkpoms","additions":256,"deletions":192,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-      accompanied this code).\n+accompanied this code).\n@@ -19,1 +19,1 @@\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -21,3 +21,3 @@\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"hat\/pom.xml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,4 +30,3 @@\n-  Dir.current()\n-    .forEachSubDir(\n-      regex->regex.matches(\"^.*(hat|examples|backends|docs)$\"),\n-      dir->dir\n+  DirEntry.current()\n+    .subDirs(dir -> dir.matches(\"^.*(hat|examples|backends|docs)$\"))\n+    .forEach(dir->dir\n","filename":"hat\/sanity","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}