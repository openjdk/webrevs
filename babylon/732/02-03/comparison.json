{"files":[{"patch":"@@ -320,47 +320,0 @@\n-                case HATVectorSelectLoadOp vectorSelectLoadOp -> {\n-                    CoreOp.VarOp vop = findVarOp((firstOperandAsRes(op)).op());\n-                    String name = (vop == null) ? \"\" : vop.varName();\n-                    HATVectorSelectLoadOp vSelectOp = new HATVectorSelectLoadOp(\n-                            name,\n-                            op.resultType(),\n-                            getLane(vectorSelectLoadOp.mapLane()),\n-                            bb.context().getValues(op.operands())\n-                    );\n-                    vSelectOp.setLocation(op.location());\n-                    bb.context().mapValue(vectorSelectLoadOp.result(), bb.op(vSelectOp));\n-                    return bb;\n-                }\n-                case HATVectorSelectStoreOp vectorSelectStoreOp -> {\n-                    CoreOp.VarOp vop = findVarOp((firstOperandAsRes(op)).op());\n-                    String name = (vop == null) ? \"\" : vop.varName();\n-                    CoreOp.VarOp resultOp =\n-                            (((Op.Result) op.operands().getLast()).op() instanceof JavaOp.ArithmeticOperation ||\n-                                    ((Op.Result) op.operands().getLast()).op() instanceof HATVectorSelectLoadOp) ?\n-                                    null : findVarOp(((Op.Result) bb.context().getValue(op.operands().get(1))).op());\n-                    HATVectorSelectStoreOp vSelectOp = new HATVectorSelectStoreOp(\n-                            name,\n-                            op.resultType(),\n-                            getLane(vectorSelectStoreOp.mapLane()),\n-                            resultOp,\n-                            bb.context().getValues(op.operands())\n-                    );\n-                    vSelectOp.setLocation(op.location());\n-                    bb.context().mapValue(vectorSelectStoreOp.result(), bb.op(vSelectOp));\n-                    return bb;\n-                }\n-                case HATVectorVarLoadOp vectorVarLoadOp -> {\n-                    Op varOp = findVarOpOrHATVarOP(vectorVarLoadOp);\n-                    String name = (varOp instanceof HATVectorVarOp) ? ((HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n-                    HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vectorVarLoadOp.resultType());\n-                    HATVectorVarLoadOp newVectorVarLoadOp = new HATVectorVarLoadOp(\n-                            name,\n-                            vectorVarLoadOp.resultType(),\n-                            md.vectorTypeElement(),\n-                            md.lanes(),\n-                            bb.context().getValues(vectorVarLoadOp.operands())\n-                    );\n-                    newVectorVarLoadOp.setLocation(vectorVarLoadOp.location());\n-                    Op.Result res = bb.op(newVectorVarLoadOp);\n-                    bb.context().mapValue(vectorVarLoadOp.result(), res);\n-                    return bb;\n-                }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import hat.device.DeviceSchema;\n+import hat.device.DeviceType;\n@@ -39,0 +41,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -44,0 +47,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -220,0 +224,28 @@\n+    public static byte[][] lifeCheck(CellGrid cellGrid) {\n+        int w = cellGrid.width();\n+        int h = cellGrid.height();\n+\n+        byte[][] res = new byte[h][w];\n+\n+        for (int y = 0; y < h; y++) {\n+            for (int x = 0; x < w; x++) {\n+                int idx = y * w + x;\n+                byte cell = cellGrid.array(idx);\n+                if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                    int count =\n+                            (cellGrid.array((y - 1) * w + (x - 1)) & 1)\n+                                    + (cellGrid.array((y + 0) * w + (x - 1)) & 1)\n+                                    + (cellGrid.array((y + 1) * w + (x - 1)) & 1)\n+                                    + (cellGrid.array((y - 1) * w + (x + 0)) & 1)\n+                                    + (cellGrid.array((y + 1) * w + (x + 0)) & 1)\n+                                    + (cellGrid.array((y - 1) * w + (x + 1)) & 1)\n+                                    + (cellGrid.array((y + 0) * w + (x + 1)) & 1)\n+                                    + (cellGrid.array((y + 1) * w + (x + 1))& 1);\n+                    cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+                }\n+                res[x][y] = cell;\n+            }\n+        }\n+        return res;\n+    }\n+\n@@ -285,0 +317,14 @@\n+        \/\/ int w = 20;\n+        \/\/ int h = 20;\n+        \/\/ \/\/ We oversize the grid by adding 1 to n,e,w and s\n+        \/\/ CellGrid cellGrid = CellGrid.create(accelerator, w, h);\n+        \/\/ CellGrid cellGridRes = CellGrid.create(accelerator, w, h);\n+        \/\/\n+        \/\/ Random rand = new Random();\n+        \/\/ byte[][] actualGrid = new byte[w][h];\n+        \/\/ for (int y = 0; y < h; y++) {\n+        \/\/     for (int x = 0; x < w; x++) {\n+        \/\/         actualGrid[x][y] = rand.nextBoolean() ? ALIVE : DEAD;\n+        \/\/     }\n+        \/\/ }\n+\n@@ -321,19 +367,1 @@\n-        byte[][] resultGrid = new byte[][]{\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD},\n-                {DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD},\n-                {DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-        };\n+        byte[][] resultGrid = lifeCheck(cellGrid);\n@@ -418,1 +446,1 @@\n-            palletteArray[i]=(i\/8+1);\/\/ 0-7?\n+            palletteArray[i]=(i\/8+1);\n@@ -425,1 +453,0 @@\n-        \/\/ Well take 1 in 4 samples (so 1024 -> 128 grid) of the pallette.\n@@ -432,1 +459,0 @@\n-                \/\/ System.out.print(charPallette9[palletteValue]);\n@@ -435,1 +461,0 @@\n-            \/\/ System.out.println();\n@@ -652,0 +677,120 @@\n+\n+    \/*\n+     * testing basic DeviceTypes\n+     *\/\n+\n+    public interface SharedDeviceType extends DeviceType {\n+        void array(long index, int value);\n+        int array(long index);\n+        DeviceSchema<SharedDeviceType> schema = DeviceSchema.of(SharedDeviceType.class,\n+                arr -> arr.withArray(\"array\", 1024));\n+        static SharedDeviceType create(Accelerator accelerator) {\n+            return null;\n+        }\n+        static SharedDeviceType createLocal() {\n+            return null;\n+        }\n+\n+        default int[] localArrayView() {\n+            return null;\n+        }\n+    }\n+\n+    public interface PrivateDeviceType extends DeviceType {\n+        void array(long index, int value);\n+        int array(long index);\n+        DeviceSchema<PrivateDeviceType> schema = DeviceSchema.of(PrivateDeviceType.class,\n+                arr -> arr.withArray(\"array\", 32));\n+        static PrivateDeviceType create(Accelerator accelerator) {\n+            return null;\n+        }\n+        static PrivateDeviceType createPrivate() {\n+            return null;\n+        }\n+\n+        default int[] privateArrayView() {\n+            return null;\n+        }\n+    }\n+\n+    @Reflect\n+    public static void kernelBasicDeviceType(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        SharedDeviceType shared = SharedDeviceType.createLocal();\n+        if (kc.gix < kc.gsx){\n+            PrivateDeviceType priv = PrivateDeviceType.createPrivate();\n+\n+            int[] arr = s32Array.arrayView();\n+            int[] privView = priv.privateArrayView();\n+            int[] sharedView = shared.localArrayView();\n+\n+            privView[kc.gix] = arr[kc.gix];\n+            sharedView[kc.gix] = arr[kc.gix];\n+            arr[kc.gix] = privView[kc.gix] + sharedView[kc.gix];\n+        }\n+    }\n+\n+    @Reflect\n+    public static void basicDeviceType(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(NDRange.of1D(s32Array.length()),\n+                kc -> kernelBasicDeviceType(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testBasicDeviceType() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> basicDeviceType(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HATAsserts.assertEquals(2 * i, arr.array(i));\n+        }\n+    }\n+\n+    \/*\n+     * testing DeviceTypes instead of Buffer\n+     *\/\n+\n+    @Reflect\n+    public static void squareKernelDeviceType(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        SharedDeviceType shared = SharedDeviceType.createLocal();\n+        if (kc.gix < kc.gsx){\n+            PrivateDeviceType priv = PrivateDeviceType.createPrivate();\n+\n+            int[] arr = s32Array.arrayView();\n+            int[] privView = priv.privateArrayView();\n+            int[] sharedView = shared.localArrayView();\n+\n+            privView[kc.gix] = arr[kc.gix];\n+            sharedView[privView[kc.gix]] = 16 * privView[kc.gix];\n+            arr[kc.gix] += privView[kc.gix] + sharedView[kc.gix];\n+        }\n+    }\n+\n+    @Reflect\n+    public static void deviceType(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(NDRange.of1D(s32Array.length()),\n+                kc -> squareKernelDeviceType(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testDeviceType() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> deviceType(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HATAsserts.assertEquals(18 * i, arr.array(i));\n+        }\n+    }\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":168,"deletions":23,"binary":false,"changes":191,"status":"modified"}]}