{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import hat.device.DeviceType;\n@@ -66,1 +67,1 @@\n-                case JavaOp.InvokeOp iop -> {\n+                case JavaOp.InvokeOp invokeOp -> {\n@@ -68,1 +69,1 @@\n-                    if (isVectorBinaryOperation(iop)) {\n+                    if (isVectorBinaryOperation(invokeOp)) {\n@@ -70,4 +71,4 @@\n-                                iop.invokeDescriptor().name(),\n-                                iop.externalizeOpName(),\n-                                iop.resultType(),\n-                                bb.context().getValues(iop.operands())\n+                                invokeOp.invokeDescriptor().name(),\n+                                invokeOp.externalizeOpName(),\n+                                invokeOp.resultType(),\n+                                bb.context().getValues(invokeOp.operands())\n@@ -75,1 +76,1 @@\n-                        vBinaryOp.setLocation(iop.location());\n+                        vBinaryOp.setLocation(invokeOp.location());\n@@ -77,2 +78,2 @@\n-                        bb.context().mapValue(iop.result(), res);\n-                        replaced.put(iop.result(), res);\n+                        bb.context().mapValue(invokeOp.result(), res);\n+                        replaced.put(invokeOp.result(), res);\n@@ -80,3 +81,3 @@\n-                    } else if (isBufferArray(iop) &&\n-                            firstOperand(iop) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n-                        replaced.put(iop.result(), r);\n+                    } else if (isBufferArray(invokeOp) &&\n+                            firstOperand(invokeOp) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n+                        replaced.put(invokeOp.result(), r);\n@@ -84,1 +85,1 @@\n-                        bufferVarLoads.put(((Op.Result) firstOperand(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n+                        bufferVarLoads.put((firstOperandAsRes(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n@@ -88,3 +89,3 @@\n-                case CoreOp.VarOp vop -> {\n-                    if (isBufferInitialize(vop) &&\n-                            firstOperand(vop) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n+                case CoreOp.VarOp varOp -> {\n+                    if (isBufferInitialize(varOp) &&\n+                            firstOperand(varOp) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n@@ -92,1 +93,1 @@\n-                        replaced.put(vop.result(), (Op.Result) firstOperand(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n+                        replaced.put(varOp.result(), firstOperandAsRes(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n@@ -94,3 +95,3 @@\n-                    } else if (isVectorOp(vop)) {\n-                        List<Value> operands = (vop.operands().isEmpty()) ? List.of() : List.of(firstOperand(vop));\n-                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vop.resultType().valueType());\n+                    } else if (isVectorOp(varOp)) {\n+                        List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n+                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(varOp.resultType().valueType());\n@@ -98,2 +99,2 @@\n-                                vop.varName(),\n-                                vop.resultType(),\n+                                varOp.varName(),\n+                                varOp.resultType(),\n@@ -104,1 +105,1 @@\n-                        vVarOp.setLocation(vop.location());\n+                        vVarOp.setLocation(varOp.location());\n@@ -106,1 +107,1 @@\n-                        bb.context().mapValue(vop.result(), res);\n+                        bb.context().mapValue(varOp.result(), res);\n@@ -110,3 +111,3 @@\n-                case CoreOp.VarAccessOp.VarLoadOp vlop -> {\n-                    if ((isBufferInitialize(vlop)) &&\n-                            firstOperand(vlop) instanceof Op.Result r) {\n+                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n+                    if ((isBufferInitialize(varLoadOp)) &&\n+                            firstOperand(varLoadOp) instanceof Op.Result r) {\n@@ -114,2 +115,2 @@\n-                            Op.Result replacement = (notGlobalVarOp(vlop)) ?\n-                                    (Op.Result) firstOperand(((Op.Result) firstOperand(r.op())).op()) :\n+                            Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n+                                    firstOperandAsRes((firstOperandAsRes(r.op())).op()) :\n@@ -117,1 +118,1 @@\n-                            replaced.put(vlop.result(), replacement);\n+                            replaced.put(varLoadOp.result(), replacement);\n@@ -121,1 +122,1 @@\n-                            newVarLoad.setLocation(vlop.location());\n+                            newVarLoad.setLocation(varLoadOp.location());\n@@ -123,2 +124,2 @@\n-                            bb.context().mapValue(vlop.result(), res);\n-                            replaced.put(vlop.result(), res);\n+                            bb.context().mapValue(varLoadOp.result(), res);\n+                            replaced.put(varLoadOp.result(), res);\n@@ -129,4 +130,3 @@\n-                \/\/ TODO: implement more generic array handling for any-dimension arrays\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n-                    if (isBufferArray(alop) &&\n-                            firstOperand(alop) instanceof Op.Result r) {\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+                    if (isBufferArray(arrayLoadOp) &&\n+                            firstOperand(arrayLoadOp) instanceof Op.Result r) {\n@@ -134,2 +134,2 @@\n-                        if (isVectorOp(alop)) {\n-                            Op vop = ((Op.Result) firstOperand(buffer.op())).op();\n+                        if (isVectorOp(arrayLoadOp)) {\n+                            Op vop = (firstOperandAsRes(buffer.op())).op();\n@@ -142,1 +142,1 @@\n-                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(alop.resultType());\n+                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(arrayLoadOp.resultType());\n@@ -145,1 +145,1 @@\n-                                    CoreType.varType(((ArrayType) firstOperand(alop).type()).componentType()),\n+                                    CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n@@ -148,2 +148,2 @@\n-                                    notGlobalVarOp(alop),\n-                                    bb.context().getValues(List.of(buffer, alop.operands().getLast()))\n+                                    notGlobalVarOp(arrayLoadOp),\n+                                    bb.context().getValues(List.of(buffer, arrayLoadOp.operands().getLast()))\n@@ -151,1 +151,1 @@\n-                            vLoadOp.setLocation(alop.location());\n+                            vLoadOp.setLocation(arrayLoadOp.location());\n@@ -153,1 +153,16 @@\n-                            bb.context().mapValue(alop.result(), res);\n+                            bb.context().mapValue(arrayLoadOp.result(), res);\n+                        \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                        \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                        \/\/     List<Value> operands = new ArrayList<>();\n+                        \/\/     operands.add(info.buffer);\n+                        \/\/     operands.addAll(info.indices);\n+                        \/\/     HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n+                        \/\/             arrayLoadOp.resultType(),\n+                        \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                        \/\/             info.indices(),\n+                        \/\/             bb.context().getValues(operands)\n+                        \/\/     );\n+                        \/\/     ptrLoadOp.setLocation(arrayLoadOp.location());\n+                        \/\/     Op.Result res = bb.op(ptrLoadOp);\n+                        \/\/     bb.context().mapValue(arrayLoadOp.result(), res);\n+                        \/\/ }\n@@ -161,1 +176,1 @@\n-                                Op.Result y = (Op.Result) getValue(bb, alop.operands().getLast());\n+                                Op.Result y = (Op.Result) getValue(bb, arrayLoadOp.operands().getLast());\n@@ -175,1 +190,1 @@\n-                                Class<?> storedClass = typeElementToClass(alop.result().type());\n+                                Class<?> storedClass = typeElementToClass(arrayLoadOp.result().type());\n@@ -178,1 +193,1 @@\n-                                bb.context().mapValue(alop.result(), invokeRes);\n+                                bb.context().mapValue(arrayLoadOp.result(), invokeRes);\n@@ -180,1 +195,1 @@\n-                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, getValue(bb, alop.operands().get(1)));\n+                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, getValue(bb, arrayLoadOp.operands().get(1)));\n@@ -184,1 +199,1 @@\n-                                Class<?> storedClass = typeElementToClass(alop.result().type());\n+                                Class<?> storedClass = typeElementToClass(arrayLoadOp.result().type());\n@@ -187,1 +202,1 @@\n-                                bb.context().mapValue(alop.result(), invokeRes);\n+                                bb.context().mapValue(arrayLoadOp.result(), invokeRes);\n@@ -193,4 +208,3 @@\n-                \/\/ handles only 1D and 2D arrays\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n-                    if (isBufferArray(asop) &&\n-                            firstOperand(asop) instanceof Op.Result r) {\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+                    if (isBufferArray(arrayStoreOp) &&\n+                            firstOperand(arrayStoreOp) instanceof Op.Result r) {\n@@ -198,2 +212,2 @@\n-                        if (isVectorOp(asop)) {\n-                            Op varOp = findVarOpOrHATVarOP(((Op.Result) asop.operands().getLast()).op());\n+                        if (isVectorOp(arrayStoreOp)) {\n+                            Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n@@ -202,1 +216,1 @@\n-                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(asop).type()).componentType());\n+                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n@@ -209,2 +223,2 @@\n-                                    notGlobalVarOp(asop),\n-                                    bb.context().getValues(List.of(buffer, asop.operands().getLast(), asop.operands().get(1)))\n+                                    notGlobalVarOp(arrayStoreOp),\n+                                    bb.context().getValues(List.of(buffer, arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n@@ -212,1 +226,1 @@\n-                            vStoreOp.setLocation(asop.location());\n+                            vStoreOp.setLocation(arrayStoreOp.location());\n@@ -214,1 +228,19 @@\n-                            bb.context().mapValue(asop.result(), res);\n+                            bb.context().mapValue(arrayStoreOp.result(), res);\n+                        \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                        \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                        \/\/     List<Value> operands = new ArrayList<>();\n+                        \/\/     operands.add(info.buffer());\n+                        \/\/     \/\/ operands.add(arrayStoreOp.operands().getLast());\n+                        \/\/     operands.addAll(info.indices);\n+                        \/\/     HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n+                        \/\/             arrayStoreOp.resultType(),\n+                        \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                        \/\/             info.indices(),\n+                        \/\/             getValue(bb, arrayStoreOp.operands().getLast()),\n+                        \/\/             bb.context().getValues(operands)\n+                        \/\/             \/\/ bb.context().getValues(List.of(info.buffer(), arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n+                        \/\/     );\n+                        \/\/     ptrLoadOp.setLocation(arrayStoreOp.location());\n+                        \/\/     Op.Result res = bb.op(ptrLoadOp);\n+                        \/\/     bb.context().mapValue(arrayStoreOp.result(), res);\n+                        \/\/ }\n@@ -220,1 +252,1 @@\n-                                Op.Result y = (Op.Result) asop.operands().get(1);\n+                                Op.Result y = (Op.Result) arrayStoreOp.operands().get(1);\n@@ -224,1 +256,1 @@\n-                                Op.Result computed = (Op.Result) asop.operands().getLast();\n+                                Op.Result computed = (Op.Result) arrayStoreOp.operands().getLast();\n@@ -237,1 +269,1 @@\n-                                bb.context().mapValue(asop.result(), invokeRes);\n+                                bb.context().mapValue(arrayStoreOp.result(), invokeRes);\n@@ -239,2 +271,2 @@\n-                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, asop.operands().get(1))));\n-                                Value val = getValue(bb, asop.operands().getLast());\n+                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, arrayStoreOp.operands().get(1))));\n+                                Value val = getValue(bb, arrayStoreOp.operands().getLast());\n@@ -253,1 +285,1 @@\n-                                bb.context().mapValue(asop.result(), invokeRes);\n+                                bb.context().mapValue(arrayStoreOp.result(), invokeRes);\n@@ -272,49 +304,16 @@\n-                case HATVectorSelectLoadOp vSelectLoad -> {\n-                    CoreOp.VarOp vop = findVarOp(((Op.Result) firstOperand(op)).op());\n-                    String name = (vop == null) ? \"\" : vop.varName();\n-                    HATVectorSelectLoadOp vSelectOp = new HATVectorSelectLoadOp(\n-                            name,\n-                            op.resultType(),\n-                            getLane(vSelectLoad.mapLane()),\n-                            bb.context().getValues(op.operands())\n-                    );\n-                    vSelectOp.setLocation(op.location());\n-                    bb.context().mapValue(vSelectLoad.result(), bb.op(vSelectOp));\n-                    return bb;\n-                }\n-                case HATVectorSelectStoreOp vSelectStore -> {\n-                    CoreOp.VarOp vop = findVarOp(((Op.Result) firstOperand(op)).op());\n-                    String name = (vop == null) ? \"\" : vop.varName();\n-                    CoreOp.VarOp resultOp =\n-                            (((Op.Result) op.operands().getLast()).op() instanceof JavaOp.ArithmeticOperation ||\n-                                    ((Op.Result) op.operands().getLast()).op() instanceof HATVectorSelectLoadOp) ?\n-                                    null : findVarOp(((Op.Result) bb.context().getValue(op.operands().get(1))).op());\n-                    HATVectorSelectStoreOp vSelectOp = new HATVectorSelectStoreOp(\n-                            name,\n-                            op.resultType(),\n-                            getLane(vSelectStore.mapLane()),\n-                            resultOp,\n-                            bb.context().getValues(op.operands())\n-                    );\n-                    vSelectOp.setLocation(op.location());\n-                    bb.context().mapValue(vSelectStore.result(), bb.op(vSelectOp));\n-                    return bb;\n-                }\n-                case HATVectorVarLoadOp vVarLoad -> {\n-                    List<Value> inputOperandsVarLoad = vVarLoad.operands();\n-                    List<Value> outputOperandsVarLoad = bb.context().getValues(inputOperandsVarLoad);\n-                    Op varOp = findVarOpOrHATVarOP(vVarLoad);\n-                    String name = (varOp instanceof HATVectorVarOp) ? ((HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n-                    HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vVarLoad.resultType());\n-                    HATVectorVarLoadOp newVectorVarLoadOp = new HATVectorVarLoadOp(\n-                            name,\n-                            vVarLoad.resultType(),\n-                            md.vectorTypeElement(),\n-                            md.lanes(),\n-                            outputOperandsVarLoad\n-                    );\n-                    newVectorVarLoadOp.setLocation(vVarLoad.location());\n-                    Op.Result res = bb.op(newVectorVarLoadOp);\n-                    bb.context().mapValue(vVarLoad.result(), res);\n-                    return bb;\n-                }\n+                \/\/ case JavaOp.ArrayLengthOp arrayLengthOp -> {\n+                \/\/     if (isBufferArray(arrayLengthOp) &&\n+                \/\/             firstOperand(arrayLengthOp) instanceof Op.Result r) {\n+                \/\/         ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                \/\/         HATPtrLengthOp ptrLengthOp = new HATPtrLengthOp(\n+                \/\/                 arrayLengthOp.resultType(),\n+                \/\/                 (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                \/\/                 info.indices(),\n+                \/\/                 bb.context().getValues(List.of(info.buffer()))\n+                \/\/         );\n+                \/\/         ptrLengthOp.setLocation(arrayLengthOp.location());\n+                \/\/         Op.Result res = bb.op(ptrLengthOp);\n+                \/\/         bb.context().mapValue(arrayLengthOp.result(), res);\n+                \/\/         return bb;\n+                \/\/     }\n+                \/\/ }\n@@ -333,10 +332,0 @@\n-    int getLane(String fieldName) {\n-        return switch (fieldName) {\n-            case \"x\" -> 0;\n-            case \"y\" -> 1;\n-            case \"z\" -> 2;\n-            case \"w\" -> 3;\n-            default -> -1;\n-        };\n-    }\n-\n@@ -368,4 +357,0 @@\n-    private CoreOp.VarOp findVarOp(Op op) {\n-        return (CoreOp.VarOp) searchForOp(op, Set.of(CoreOp.VarOp.class));\n-    }\n-\n@@ -386,1 +371,5 @@\n-    public Value firstOperand(Op op) {\n+    public static Op.Result firstOperandAsRes(Op op) {\n+        return (firstOperand(op) instanceof Op.Result res) ? res : null;\n+    }\n+\n+    public static Value firstOperand(Op op) {\n@@ -390,1 +379,1 @@\n-    public Value getValue(Block.Builder bb, Value value) {\n+    public static Value getValue(Block.Builder bb, Value value) {\n@@ -402,0 +391,1 @@\n+                iop.invokeDescriptor().name().toLowerCase().contains(\"shared\") ||\n@@ -433,1 +423,2 @@\n-                        OpTk.isAssignable(accelerator.lookup, javaType, MappableIface.class)));\n+                        (OpTk.isAssignable(accelerator.lookup, javaType, MappableIface.class)\n+                        || OpTk.isAssignable(accelerator.lookup, javaType, DeviceType.class))));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":125,"deletions":134,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+        \/\/ array views\n+        hatPhases.add(new HATDialectifyArrayViewPhase(accelerator));\n+\n@@ -74,1 +77,0 @@\n-        hatPhases.add(new HATDialectifyArrayViewPhase(accelerator));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import hat.device.DeviceSchema;\n+import hat.device.DeviceType;\n@@ -39,0 +41,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -44,0 +47,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -220,0 +224,28 @@\n+    public static byte[][] lifeCheck(CellGrid cellGrid) {\n+        int w = cellGrid.width();\n+        int h = cellGrid.height();\n+\n+        byte[][] res = new byte[h][w];\n+\n+        for (int y = 0; y < h; y++) {\n+            for (int x = 0; x < w; x++) {\n+                int idx = y * w + x;\n+                byte cell = cellGrid.array(idx);\n+                if (x > 0 && x < (w - 1) && y > 0 && y < (h - 1)) { \/\/ passports please\n+                    int count =\n+                            (cellGrid.array((y - 1) * w + (x - 1)) & 1)\n+                                    + (cellGrid.array((y + 0) * w + (x - 1)) & 1)\n+                                    + (cellGrid.array((y + 1) * w + (x - 1)) & 1)\n+                                    + (cellGrid.array((y - 1) * w + (x + 0)) & 1)\n+                                    + (cellGrid.array((y + 1) * w + (x + 0)) & 1)\n+                                    + (cellGrid.array((y - 1) * w + (x + 1)) & 1)\n+                                    + (cellGrid.array((y + 0) * w + (x + 1)) & 1)\n+                                    + (cellGrid.array((y + 1) * w + (x + 1))& 1);\n+                    cell = ((count == 3) || ((count == 2) && (cell == ALIVE))) ? ALIVE : DEAD;\/\/ B3\/S23.\n+                }\n+                res[x][y] = cell;\n+            }\n+        }\n+        return res;\n+    }\n+\n@@ -285,0 +317,14 @@\n+        \/\/ int w = 20;\n+        \/\/ int h = 20;\n+        \/\/ \/\/ We oversize the grid by adding 1 to n,e,w and s\n+        \/\/ CellGrid cellGrid = CellGrid.create(accelerator, w, h);\n+        \/\/ CellGrid cellGridRes = CellGrid.create(accelerator, w, h);\n+        \/\/\n+        \/\/ Random rand = new Random();\n+        \/\/ byte[][] actualGrid = new byte[w][h];\n+        \/\/ for (int y = 0; y < h; y++) {\n+        \/\/     for (int x = 0; x < w; x++) {\n+        \/\/         actualGrid[x][y] = rand.nextBoolean() ? ALIVE : DEAD;\n+        \/\/     }\n+        \/\/ }\n+\n@@ -321,19 +367,1 @@\n-        byte[][] resultGrid = new byte[][]{\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD},\n-                {DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  ALIVE, DEAD,  DEAD,  DEAD},\n-                {DEAD,  ALIVE, ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  ALIVE, ALIVE, ALIVE, DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  ALIVE, ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  ALIVE, DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-                {DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD,  DEAD},\n-        };\n+        byte[][] resultGrid = lifeCheck(cellGrid);\n@@ -418,1 +446,1 @@\n-            palletteArray[i]=(i\/8+1);\/\/ 0-7?\n+            palletteArray[i]=(i\/8+1);\n@@ -425,1 +453,0 @@\n-        \/\/ Well take 1 in 4 samples (so 1024 -> 128 grid) of the pallette.\n@@ -432,1 +459,0 @@\n-                \/\/ System.out.print(charPallette9[palletteValue]);\n@@ -435,1 +461,0 @@\n-            \/\/ System.out.println();\n@@ -652,0 +677,120 @@\n+\n+    \/*\n+     * testing basic DeviceTypes\n+     *\/\n+\n+    public interface SharedDeviceType extends DeviceType {\n+        void array(long index, int value);\n+        int array(long index);\n+        DeviceSchema<SharedDeviceType> schema = DeviceSchema.of(SharedDeviceType.class,\n+                arr -> arr.withArray(\"array\", 1024));\n+        static SharedDeviceType create(Accelerator accelerator) {\n+            return null;\n+        }\n+        static SharedDeviceType createLocal() {\n+            return null;\n+        }\n+\n+        default int[] localArrayView() {\n+            return null;\n+        }\n+    }\n+\n+    public interface PrivateDeviceType extends DeviceType {\n+        void array(long index, int value);\n+        int array(long index);\n+        DeviceSchema<PrivateDeviceType> schema = DeviceSchema.of(PrivateDeviceType.class,\n+                arr -> arr.withArray(\"array\", 32));\n+        static PrivateDeviceType create(Accelerator accelerator) {\n+            return null;\n+        }\n+        static PrivateDeviceType createPrivate() {\n+            return null;\n+        }\n+\n+        default int[] privateArrayView() {\n+            return null;\n+        }\n+    }\n+\n+    @Reflect\n+    public static void kernelBasicDeviceType(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        SharedDeviceType shared = SharedDeviceType.createLocal();\n+        if (kc.gix < kc.gsx){\n+            PrivateDeviceType priv = PrivateDeviceType.createPrivate();\n+\n+            int[] arr = s32Array.arrayView();\n+            int[] privView = priv.privateArrayView();\n+            int[] sharedView = shared.localArrayView();\n+\n+            privView[kc.gix] = arr[kc.gix];\n+            sharedView[kc.gix] = arr[kc.gix];\n+            arr[kc.gix] = privView[kc.gix] + sharedView[kc.gix];\n+        }\n+    }\n+\n+    @Reflect\n+    public static void basicDeviceType(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(NDRange.of1D(s32Array.length()),\n+                kc -> kernelBasicDeviceType(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testBasicDeviceType() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> basicDeviceType(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HATAsserts.assertEquals(2 * i, arr.array(i));\n+        }\n+    }\n+\n+    \/*\n+     * testing DeviceTypes instead of Buffer\n+     *\/\n+\n+    @Reflect\n+    public static void squareKernelDeviceType(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        SharedDeviceType shared = SharedDeviceType.createLocal();\n+        if (kc.gix < kc.gsx){\n+            PrivateDeviceType priv = PrivateDeviceType.createPrivate();\n+\n+            int[] arr = s32Array.arrayView();\n+            int[] privView = priv.privateArrayView();\n+            int[] sharedView = shared.localArrayView();\n+\n+            privView[kc.gix] = arr[kc.gix];\n+            sharedView[privView[kc.gix]] = 16 * privView[kc.gix];\n+            arr[kc.gix] += privView[kc.gix] + sharedView[kc.gix];\n+        }\n+    }\n+\n+    @Reflect\n+    public static void deviceType(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(NDRange.of1D(s32Array.length()),\n+                kc -> squareKernelDeviceType(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testDeviceType() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> deviceType(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HATAsserts.assertEquals(18 * i, arr.array(i));\n+        }\n+    }\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":168,"deletions":23,"binary":false,"changes":191,"status":"modified"}]}