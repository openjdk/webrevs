{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import hat.device.DeviceType;\n@@ -66,1 +67,1 @@\n-                case JavaOp.InvokeOp iop -> {\n+                case JavaOp.InvokeOp invokeOp -> {\n@@ -68,1 +69,1 @@\n-                    if (isVectorBinaryOperation(iop)) {\n+                    if (isVectorBinaryOperation(invokeOp)) {\n@@ -70,4 +71,4 @@\n-                                iop.invokeDescriptor().name(),\n-                                iop.externalizeOpName(),\n-                                iop.resultType(),\n-                                bb.context().getValues(iop.operands())\n+                                invokeOp.invokeDescriptor().name(),\n+                                invokeOp.externalizeOpName(),\n+                                invokeOp.resultType(),\n+                                bb.context().getValues(invokeOp.operands())\n@@ -75,1 +76,1 @@\n-                        vBinaryOp.setLocation(iop.location());\n+                        vBinaryOp.setLocation(invokeOp.location());\n@@ -77,2 +78,2 @@\n-                        bb.context().mapValue(iop.result(), res);\n-                        replaced.put(iop.result(), res);\n+                        bb.context().mapValue(invokeOp.result(), res);\n+                        replaced.put(invokeOp.result(), res);\n@@ -80,3 +81,3 @@\n-                    } else if (isBufferArray(iop) &&\n-                            firstOperand(iop) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n-                        replaced.put(iop.result(), r);\n+                    } else if (isBufferArray(invokeOp) &&\n+                            firstOperand(invokeOp) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n+                        replaced.put(invokeOp.result(), r);\n@@ -84,1 +85,1 @@\n-                        bufferVarLoads.put(((Op.Result) firstOperand(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n+                        bufferVarLoads.put((firstOperandAsRes(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n@@ -88,3 +89,3 @@\n-                case CoreOp.VarOp vop -> {\n-                    if (isBufferInitialize(vop) &&\n-                            firstOperand(vop) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n+                case CoreOp.VarOp varOp -> {\n+                    if (isBufferInitialize(varOp) &&\n+                            firstOperand(varOp) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n@@ -92,1 +93,1 @@\n-                        replaced.put(vop.result(), (Op.Result) firstOperand(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n+                        replaced.put(varOp.result(), firstOperandAsRes(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n@@ -94,3 +95,3 @@\n-                    } else if (isVectorOp(vop)) {\n-                        List<Value> operands = (vop.operands().isEmpty()) ? List.of() : List.of(firstOperand(vop));\n-                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vop.resultType().valueType());\n+                    } else if (isVectorOp(varOp)) {\n+                        List<Value> operands = (varOp.operands().isEmpty()) ? List.of() : List.of(firstOperand(varOp));\n+                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(varOp.resultType().valueType());\n@@ -98,2 +99,2 @@\n-                                vop.varName(),\n-                                vop.resultType(),\n+                                varOp.varName(),\n+                                varOp.resultType(),\n@@ -104,1 +105,1 @@\n-                        vVarOp.setLocation(vop.location());\n+                        vVarOp.setLocation(varOp.location());\n@@ -106,1 +107,1 @@\n-                        bb.context().mapValue(vop.result(), res);\n+                        bb.context().mapValue(varOp.result(), res);\n@@ -110,3 +111,3 @@\n-                case CoreOp.VarAccessOp.VarLoadOp vlop -> {\n-                    if ((isBufferInitialize(vlop)) &&\n-                            firstOperand(vlop) instanceof Op.Result r) {\n+                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n+                    if ((isBufferInitialize(varLoadOp)) &&\n+                            firstOperand(varLoadOp) instanceof Op.Result r) {\n@@ -114,2 +115,2 @@\n-                            Op.Result replacement = (notGlobalVarOp(vlop)) ?\n-                                    (Op.Result) firstOperand(((Op.Result) firstOperand(r.op())).op()) :\n+                            Op.Result replacement = (notGlobalVarOp(varLoadOp)) ?\n+                                    firstOperandAsRes((firstOperandAsRes(r.op())).op()) :\n@@ -117,1 +118,1 @@\n-                            replaced.put(vlop.result(), replacement);\n+                            replaced.put(varLoadOp.result(), replacement);\n@@ -121,1 +122,1 @@\n-                            newVarLoad.setLocation(vlop.location());\n+                            newVarLoad.setLocation(varLoadOp.location());\n@@ -123,2 +124,2 @@\n-                            bb.context().mapValue(vlop.result(), res);\n-                            replaced.put(vlop.result(), res);\n+                            bb.context().mapValue(varLoadOp.result(), res);\n+                            replaced.put(varLoadOp.result(), res);\n@@ -129,4 +130,3 @@\n-                \/\/ TODO: implement more generic array handling for any-dimension arrays\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n-                    if (isBufferArray(alop) &&\n-                            firstOperand(alop) instanceof Op.Result r) {\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+                    if (isBufferArray(arrayLoadOp) &&\n+                            firstOperand(arrayLoadOp) instanceof Op.Result r) {\n@@ -134,2 +134,2 @@\n-                        if (isVectorOp(alop)) {\n-                            Op vop = ((Op.Result) firstOperand(buffer.op())).op();\n+                        if (isVectorOp(arrayLoadOp)) {\n+                            Op vop = (firstOperandAsRes(buffer.op())).op();\n@@ -142,1 +142,1 @@\n-                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(alop.resultType());\n+                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(arrayLoadOp.resultType());\n@@ -145,1 +145,1 @@\n-                                    CoreType.varType(((ArrayType) firstOperand(alop).type()).componentType()),\n+                                    CoreType.varType(((ArrayType) firstOperand(arrayLoadOp).type()).componentType()),\n@@ -148,2 +148,2 @@\n-                                    notGlobalVarOp(alop),\n-                                    bb.context().getValues(List.of(buffer, alop.operands().getLast()))\n+                                    notGlobalVarOp(arrayLoadOp),\n+                                    bb.context().getValues(List.of(buffer, arrayLoadOp.operands().getLast()))\n@@ -151,1 +151,1 @@\n-                            vLoadOp.setLocation(alop.location());\n+                            vLoadOp.setLocation(arrayLoadOp.location());\n@@ -153,1 +153,16 @@\n-                            bb.context().mapValue(alop.result(), res);\n+                            bb.context().mapValue(arrayLoadOp.result(), res);\n+                        \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                        \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                        \/\/     List<Value> operands = new ArrayList<>();\n+                        \/\/     operands.add(info.buffer);\n+                        \/\/     operands.addAll(info.indices);\n+                        \/\/     HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n+                        \/\/             arrayLoadOp.resultType(),\n+                        \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                        \/\/             info.indices(),\n+                        \/\/             bb.context().getValues(operands)\n+                        \/\/     );\n+                        \/\/     ptrLoadOp.setLocation(arrayLoadOp.location());\n+                        \/\/     Op.Result res = bb.op(ptrLoadOp);\n+                        \/\/     bb.context().mapValue(arrayLoadOp.result(), res);\n+                        \/\/ }\n@@ -161,1 +176,1 @@\n-                                Op.Result y = (Op.Result) getValue(bb, alop.operands().getLast());\n+                                Op.Result y = (Op.Result) getValue(bb, arrayLoadOp.operands().getLast());\n@@ -175,1 +190,1 @@\n-                                Class<?> storedClass = typeElementToClass(alop.result().type());\n+                                Class<?> storedClass = typeElementToClass(arrayLoadOp.result().type());\n@@ -178,1 +193,1 @@\n-                                bb.context().mapValue(alop.result(), invokeRes);\n+                                bb.context().mapValue(arrayLoadOp.result(), invokeRes);\n@@ -180,1 +195,1 @@\n-                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, getValue(bb, alop.operands().get(1)));\n+                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, getValue(bb, arrayLoadOp.operands().get(1)));\n@@ -184,1 +199,1 @@\n-                                Class<?> storedClass = typeElementToClass(alop.result().type());\n+                                Class<?> storedClass = typeElementToClass(arrayLoadOp.result().type());\n@@ -187,1 +202,1 @@\n-                                bb.context().mapValue(alop.result(), invokeRes);\n+                                bb.context().mapValue(arrayLoadOp.result(), invokeRes);\n@@ -193,4 +208,3 @@\n-                \/\/ handles only 1D and 2D arrays\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n-                    if (isBufferArray(asop) &&\n-                            firstOperand(asop) instanceof Op.Result r) {\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+                    if (isBufferArray(arrayStoreOp) &&\n+                            firstOperand(arrayStoreOp) instanceof Op.Result r) {\n@@ -198,2 +212,2 @@\n-                        if (isVectorOp(asop)) {\n-                            Op varOp = findVarOpOrHATVarOP(((Op.Result) asop.operands().getLast()).op());\n+                        if (isVectorOp(arrayStoreOp)) {\n+                            Op varOp = findVarOpOrHATVarOP(((Op.Result) arrayStoreOp.operands().getLast()).op());\n@@ -202,1 +216,1 @@\n-                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(asop).type()).componentType());\n+                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(arrayStoreOp).type()).componentType());\n@@ -209,2 +223,2 @@\n-                                    notGlobalVarOp(asop),\n-                                    bb.context().getValues(List.of(buffer, asop.operands().getLast(), asop.operands().get(1)))\n+                                    notGlobalVarOp(arrayStoreOp),\n+                                    bb.context().getValues(List.of(buffer, arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n@@ -212,1 +226,1 @@\n-                            vStoreOp.setLocation(asop.location());\n+                            vStoreOp.setLocation(arrayStoreOp.location());\n@@ -214,1 +228,19 @@\n-                            bb.context().mapValue(asop.result(), res);\n+                            bb.context().mapValue(arrayStoreOp.result(), res);\n+                        \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                        \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                        \/\/     List<Value> operands = new ArrayList<>();\n+                        \/\/     operands.add(info.buffer());\n+                        \/\/     \/\/ operands.add(arrayStoreOp.operands().getLast());\n+                        \/\/     operands.addAll(info.indices);\n+                        \/\/     HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n+                        \/\/             arrayStoreOp.resultType(),\n+                        \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                        \/\/             info.indices(),\n+                        \/\/             getValue(bb, arrayStoreOp.operands().getLast()),\n+                        \/\/             bb.context().getValues(operands)\n+                        \/\/             \/\/ bb.context().getValues(List.of(info.buffer(), arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n+                        \/\/     );\n+                        \/\/     ptrLoadOp.setLocation(arrayStoreOp.location());\n+                        \/\/     Op.Result res = bb.op(ptrLoadOp);\n+                        \/\/     bb.context().mapValue(arrayStoreOp.result(), res);\n+                        \/\/ }\n@@ -220,1 +252,1 @@\n-                                Op.Result y = (Op.Result) asop.operands().get(1);\n+                                Op.Result y = (Op.Result) arrayStoreOp.operands().get(1);\n@@ -224,1 +256,1 @@\n-                                Op.Result computed = (Op.Result) asop.operands().getLast();\n+                                Op.Result computed = (Op.Result) arrayStoreOp.operands().getLast();\n@@ -237,1 +269,1 @@\n-                                bb.context().mapValue(asop.result(), invokeRes);\n+                                bb.context().mapValue(arrayStoreOp.result(), invokeRes);\n@@ -239,2 +271,2 @@\n-                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, asop.operands().get(1))));\n-                                Value val = getValue(bb, asop.operands().getLast());\n+                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, arrayStoreOp.operands().get(1))));\n+                                Value val = getValue(bb, arrayStoreOp.operands().getLast());\n@@ -253,1 +285,1 @@\n-                                bb.context().mapValue(asop.result(), invokeRes);\n+                                bb.context().mapValue(arrayStoreOp.result(), invokeRes);\n@@ -272,2 +304,18 @@\n-                case HATVectorSelectLoadOp vSelectLoad -> {\n-                    CoreOp.VarOp vop = findVarOp(((Op.Result) firstOperand(op)).op());\n+                \/\/ case JavaOp.ArrayLengthOp arrayLengthOp -> {\n+                \/\/     if (isBufferArray(arrayLengthOp) &&\n+                \/\/             firstOperand(arrayLengthOp) instanceof Op.Result r) {\n+                \/\/         ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                \/\/         HATPtrLengthOp ptrLengthOp = new HATPtrLengthOp(\n+                \/\/                 arrayLengthOp.resultType(),\n+                \/\/                 (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                \/\/                 info.indices(),\n+                \/\/                 bb.context().getValues(List.of(info.buffer()))\n+                \/\/         );\n+                \/\/         ptrLengthOp.setLocation(arrayLengthOp.location());\n+                \/\/         Op.Result res = bb.op(ptrLengthOp);\n+                \/\/         bb.context().mapValue(arrayLengthOp.result(), res);\n+                \/\/         return bb;\n+                \/\/     }\n+                \/\/ }\n+                case HATVectorSelectLoadOp vectorSelectLoadOp -> {\n+                    CoreOp.VarOp vop = findVarOp((firstOperandAsRes(op)).op());\n@@ -278,1 +326,1 @@\n-                            getLane(vSelectLoad.mapLane()),\n+                            getLane(vectorSelectLoadOp.mapLane()),\n@@ -282,1 +330,1 @@\n-                    bb.context().mapValue(vSelectLoad.result(), bb.op(vSelectOp));\n+                    bb.context().mapValue(vectorSelectLoadOp.result(), bb.op(vSelectOp));\n@@ -285,2 +333,2 @@\n-                case HATVectorSelectStoreOp vSelectStore -> {\n-                    CoreOp.VarOp vop = findVarOp(((Op.Result) firstOperand(op)).op());\n+                case HATVectorSelectStoreOp vectorSelectStoreOp -> {\n+                    CoreOp.VarOp vop = findVarOp((firstOperandAsRes(op)).op());\n@@ -295,1 +343,1 @@\n-                            getLane(vSelectStore.mapLane()),\n+                            getLane(vectorSelectStoreOp.mapLane()),\n@@ -300,1 +348,1 @@\n-                    bb.context().mapValue(vSelectStore.result(), bb.op(vSelectOp));\n+                    bb.context().mapValue(vectorSelectStoreOp.result(), bb.op(vSelectOp));\n@@ -303,4 +351,2 @@\n-                case HATVectorVarLoadOp vVarLoad -> {\n-                    List<Value> inputOperandsVarLoad = vVarLoad.operands();\n-                    List<Value> outputOperandsVarLoad = bb.context().getValues(inputOperandsVarLoad);\n-                    Op varOp = findVarOpOrHATVarOP(vVarLoad);\n+                case HATVectorVarLoadOp vectorVarLoadOp -> {\n+                    Op varOp = findVarOpOrHATVarOP(vectorVarLoadOp);\n@@ -308,1 +354,1 @@\n-                    HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vVarLoad.resultType());\n+                    HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vectorVarLoadOp.resultType());\n@@ -311,1 +357,1 @@\n-                            vVarLoad.resultType(),\n+                            vectorVarLoadOp.resultType(),\n@@ -314,1 +360,1 @@\n-                            outputOperandsVarLoad\n+                            bb.context().getValues(vectorVarLoadOp.operands())\n@@ -316,1 +362,1 @@\n-                    newVectorVarLoadOp.setLocation(vVarLoad.location());\n+                    newVectorVarLoadOp.setLocation(vectorVarLoadOp.location());\n@@ -318,1 +364,1 @@\n-                    bb.context().mapValue(vVarLoad.result(), res);\n+                    bb.context().mapValue(vectorVarLoadOp.result(), res);\n@@ -329,0 +375,53 @@\n+    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {};\n+\n+    record Node<T>(T value, List<Node<T>> edges) {\n+        ArrayAccessInfo getInfo(Map<Op.Result, Op.Result> replaced) {\n+            List<Node<T>> wl = new ArrayList<>();\n+            Set<Node<T>> seen = new HashSet<>();\n+            Op.Result buffer = null;\n+            List<Op.Result> indices = new ArrayList<>();\n+            wl.add(this);\n+            while (!wl.isEmpty()) {\n+                Node<T> cur = wl.removeFirst();\n+                seen.add(cur);\n+                if (cur.value instanceof Op.Result res) {\n+                    if (res.op() instanceof JavaOp.ArrayAccessOp || res.op() instanceof JavaOp.ArrayLengthOp) {\n+                        buffer = res;\n+                        indices.addFirst(res.op() instanceof JavaOp.ArrayAccessOp ? ((Op.Result) res.op().operands().get(1)) : ((Op.Result) res.op().operands().get(0)));\n+                    }\n+                }\n+                for (Node<T> node : edges) {\n+                    if (!seen.contains(node)) wl.add(node);\n+                }\n+            }\n+            buffer = replaced.get((Op.Result) firstOperand(buffer.op()));\n+            return new ArrayAccessInfo(buffer, indices);\n+        }\n+    }\n+\n+    static ArrayAccessInfo arrayAccessInfo(Value value, Map<Op.Result, Op.Result> replaced) {\n+        return expressionGraph(value).getInfo(replaced);\n+    }\n+\n+    \/\/ TODO: check?\n+    static Node<Value> expressionGraph(Value value) {\n+        return expressionGraph(new HashMap<>(), value);\n+    }\n+\n+    static Node<Value> expressionGraph(Map<Value, Node<Value>> visited, Value value) {\n+        \/\/ If value has already been visited return its node\n+        if (visited.containsKey(value)) {\n+            return visited.get(value);\n+        }\n+\n+        \/\/ Find the expression graphs for each operand\n+        List<Node<Value>> edges = new ArrayList<>();\n+        for (Value operand : value.dependsOn()) {\n+            if (operand instanceof Op.Result res && res.op() instanceof JavaOp.InvokeOp iop && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")) continue;\n+            edges.add(expressionGraph(operand));\n+        }\n+        Node<Value> node = new Node<>(value, edges);\n+        visited.put(value, node);\n+        return node;\n+    }\n+\n@@ -386,1 +485,5 @@\n-    public Value firstOperand(Op op) {\n+    public static Op.Result firstOperandAsRes(Op op) {\n+        return (firstOperand(op) instanceof Op.Result res) ? res : null;\n+    }\n+\n+    public static Value firstOperand(Op op) {\n@@ -390,1 +493,1 @@\n-    public Value getValue(Block.Builder bb, Value value) {\n+    public static Value getValue(Block.Builder bb, Value value) {\n@@ -402,0 +505,1 @@\n+                iop.invokeDescriptor().name().toLowerCase().contains(\"shared\") ||\n@@ -433,1 +537,2 @@\n-                        OpTk.isAssignable(accelerator.lookup, javaType, MappableIface.class)));\n+                        (OpTk.isAssignable(accelerator.lookup, javaType, MappableIface.class)\n+                        || OpTk.isAssignable(accelerator.lookup, javaType, DeviceType.class))));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":193,"deletions":88,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+        \/\/ array views\n+        hatPhases.add(new HATDialectifyArrayViewPhase(accelerator));\n+\n@@ -74,1 +77,0 @@\n-        hatPhases.add(new HATDialectifyArrayViewPhase(accelerator));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}