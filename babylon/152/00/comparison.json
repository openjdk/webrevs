{"files":[{"patch":"@@ -30,9 +30,0 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n@@ -40,40 +31,9 @@\n-    interface Feature extends Buffer.StructChild{\n-\n-        interface Rect extends Buffer.StructChild {\n-            StructLayout layout = MemoryLayout.structLayout(\n-                    JAVA_BYTE.withName(\"x\"),\n-                    JAVA_BYTE.withName(\"y\"),\n-                    JAVA_BYTE.withName(\"width\"),\n-                    JAVA_BYTE.withName(\"height\"),\n-                    JAVA_FLOAT.withName(\"weight\")\n-            ).withName(\"Rect\");\n-            Schema schema = Schema.of(Rect.class,rect->rect\n-                    .primitive(\"x\")\n-                    .primitive( \"y\")\n-                    .primitive(\"width\")\n-                    .primitive(\"height\")\n-                    .primitive(\"weight\")\n-            );\n-\n-            byte x();\n-\n-            byte y();\n-\n-            byte width();\n-\n-            byte height();\n-\n-            float weight();\n-\n-            void x(byte x);\n-\n-            void y(byte y);\n-\n-            void width(byte width);\n-\n-            void height(byte height);\n-\n-            void weight(float height);\n-        }\n-\n-\n+    int width();\n+    void width(int width);\n+    int height();\n+    void height(int height);\n+    interface Feature extends Buffer.StructChild {\n+        int id();\n+        float threshold();\n+        void id(int id);\n+        void threshold(float threshold);\n@@ -81,8 +41,1 @@\n-            interface Anon extends Buffer.UnionChild  {\n-                MemoryLayout layout = MemoryLayout.unionLayout(\n-                        JAVA_INT.withName(\"featureId\"),\n-                        JAVA_FLOAT.withName(\"value\")\n-                ).withName(\"Anon\");\n-                Schema schema = Schema.of(Anon.class,anon-> anon\n-                        .primitive(\"featureId\")\n-                        .primitive( \"value\"));\n+            interface Anon extends Buffer.UnionChild {\n@@ -94,10 +47,0 @@\n-\n-            StructLayout layout = MemoryLayout.structLayout(\n-                    JAVA_BOOLEAN.withName(\"hasValue\"),\n-                    MemoryLayout.paddingLayout(3),\n-                    Anon.layout.withName(\"anon\")\n-            ).withName(\"LinkOrValue\");\n-            Schema schema = Schema.of(LinkOrValue.class,linkOrValue-> linkOrValue\n-                    .primitive(\"hasValue\")\n-                    .primitive( \"anon\")\n-            );\n@@ -108,26 +51,0 @@\n-\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"id\"),\n-                JAVA_FLOAT.withName(\"threshold\"),\n-                LinkOrValue.layout.withName(\"left\"),\n-                LinkOrValue.layout.withName(\"right\"),\n-                MemoryLayout.sequenceLayout(3, Rect.layout).withName(\"rect\")\n-        ).withName(Feature.class.getSimpleName());\n-        Schema schema = Schema.of(Feature.class,feature->feature\n-                .primitive(\"id\")\n-                .primitive( \"threshold\")\n-                .primitive(\"left\")\n-                .primitive(\"right\")\n-                .array(\"rect\", 3 )\n-        );\n-        int id();\n-\n-\n-        float threshold();\n-\n-\n-        void id(int id);\n-\n-\n-        void threshold(float threshold);\n-\n@@ -135,1 +52,0 @@\n-\n@@ -137,1 +53,12 @@\n-\n+        interface Rect extends Buffer.StructChild {\n+            byte x();\n+            byte y();\n+            byte width();\n+            byte height();\n+            float weight();\n+            void x(byte x);\n+            void y(byte y);\n+            void width(byte width);\n+            void height(byte height);\n+            void weight(float height);\n+        }\n@@ -139,2 +66,0 @@\n-\n-\n@@ -142,9 +67,4 @@\n-\n-    interface Stage extends Buffer.StructChild{\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"id\"),\n-                JAVA_FLOAT.withName(\"threshold\"),\n-                JAVA_SHORT.withName(\"firstTreeId\"),\n-                JAVA_SHORT.withName(\"treeCount\")\n-        ).withName(Stage.class.getSimpleName());\n-\n+    int featureCount();\n+    void featureCount(int featureCount);\n+    Feature feature(long idx);\n+    interface Stage extends Buffer.StructChild {\n@@ -152,1 +72,0 @@\n-\n@@ -154,1 +73,0 @@\n-\n@@ -156,1 +74,0 @@\n-\n@@ -158,1 +75,0 @@\n-\n@@ -160,1 +76,0 @@\n-\n@@ -162,1 +77,0 @@\n-\n@@ -164,1 +78,0 @@\n-\n@@ -166,4 +79,0 @@\n-\n-        Schema schema = Schema.of(Stage.class,b->\n-                b.primitive(\"id\").primitive( \"threshold\").primitive(\"treeCount\").primitive(\"firstTreeId\")\n-        );\n@@ -171,8 +80,4 @@\n-\n-    interface Tree extends Buffer.StructChild{\n-        StructLayout layout = MemoryLayout.structLayout(\n-                JAVA_INT.withName(\"id\"),\n-                JAVA_SHORT.withName(\"firstFeatureId\"),\n-                JAVA_SHORT.withName(\"featureCount\")\n-        ).withName(Tree.class.getSimpleName());\n-\n+    int stageCount();\n+    void stageCount(int stageCount);\n+    Stage stage(long idx);\n+    interface Tree extends Buffer.StructChild {\n@@ -180,1 +85,0 @@\n-\n@@ -182,2 +86,0 @@\n-\n-\n@@ -185,1 +87,0 @@\n-\n@@ -187,2 +88,0 @@\n-\n-\n@@ -190,1 +89,0 @@\n-\n@@ -192,4 +90,0 @@\n-\n-        Schema schema = Schema.of(Tree.class,b->\n-                b.primitive(\"id\").primitive(\"featureCount\").primitive(\"firstFeatureId\")\n-        );\n@@ -197,88 +91,0 @@\n-\/*\n-    static Cascade create(BufferAllocator bufferAllocator, XMLHaarCascadeModel haarCascade) {\n-\n-        Cascade cascade = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), Cascade.class,\n-                JAVA_INT.withName(\"width\"),\n-                JAVA_INT.withName(\"height\"),\n-                JAVA_INT.withName(\"featureCount\"),\n-                sequenceLayout(haarCascade.features.size(), Feature.layout.withName(Feature.class.getSimpleName())).withName(\"feature\"),\n-                JAVA_INT.withName(\"stageCount\"),\n-                sequenceLayout(haarCascade.stages.size(), Stage.layout.withName(Stage.class.getSimpleName())).withName(\"stage\"),\n-                JAVA_INT.withName(\"treeCount\"),\n-                sequenceLayout(haarCascade.trees.size(), Tree.layout.withName(Tree.class.getSimpleName())).withName(\"tree\")\n-        ));\n-        cascade.width(haarCascade.width());\n-        cascade.height(haarCascade.height());\n-        cascade.featureCount(haarCascade.features.size());\n-        cascade.stageCount(haarCascade.stages.size());\n-        cascade.treeCount(haarCascade.trees.size());\n-        for (int idx = 0; idx < haarCascade.features.size(); idx++) {\n-            Feature cascadeFeature = cascade.feature(idx);\n-            var haarfeature = haarCascade.features.get(idx);\n-            cascadeFeature.id(haarfeature.id());\n-            cascadeFeature.threshold(haarfeature.threshold());\n-            Feature.LinkOrValue cascadeLeft = cascadeFeature.left();\n-            cascadeLeft.hasValue(haarfeature.left.hasValue());\n-            if (haarfeature.left.hasValue()) {\n-                cascadeLeft.anon().value(haarfeature.left.value());\n-            } else {\n-                cascadeLeft.anon().value(haarfeature.left.featureId());\n-            }\n-            Feature.LinkOrValue cascadeRight = cascadeFeature.right();\n-            cascadeRight.hasValue(haarfeature.right.hasValue());\n-            if (haarfeature.right.hasValue()) {\n-                cascadeRight.anon().value(haarfeature.right.value());\n-            } else {\n-                cascadeRight.anon().featureId(haarfeature.right.featureId());\n-            }\n-            for (int r = 0; r < 3; r++) {\n-                var haarrect = haarfeature.rects[r];\n-                if (haarrect != null) {\n-                    Feature.Rect cascadeRect = cascadeFeature.rect(r);\n-                    cascadeRect.x(haarrect.x());\n-                    cascadeRect.y(haarrect.y());\n-                    cascadeRect.width(haarrect.width());\n-                    cascadeRect.height(haarrect.height());\n-                    cascadeRect.weight(haarrect.weight());\n-                }\n-            }\n-        }\n-\n-\n-        for (XMLHaarCascadeModel.Stage haarstage : haarCascade.stages) {\n-            Stage cascadeStage = cascade.stage(haarstage.id);\n-            cascadeStage.id(haarstage.id());\n-            cascadeStage.threshold(haarstage.threshold());\n-            cascadeStage.firstTreeId(haarstage.firstTreeId());\n-            cascadeStage.treeCount(haarstage.treeCount());\n-        }\n-\n-        for (XMLHaarCascadeModel.Tree haarTree : haarCascade.trees) {\n-            Tree cascadeTree = cascade.tree(haarTree.id());\n-            cascadeTree.id(haarTree.id());\n-            cascadeTree.firstFeatureId(haarTree.firstFeatureId());\n-            cascadeTree.featureCount(haarTree.featureCount());\n-        }\n-        return cascade;\n-    } *\/\n-Schema schema = Schema.of(Cascade.class,b-> b\n-        .primitive(\"width\")\n-        .primitive(\"height\")\n-        .arrayLen(\"featureCount\").array(\"feature\")\n-        .arrayLen(\"treeCount\").array(\"tree\")\n-        .fieldControlledArray(\"stageCount\", \"stage\")\n-);\n-    Feature feature(long idx);\n-\n-    int featureCount();\n-\n-    void featureCount(int featureCount);\n-\n-    Stage stage(long idx);\n-\n-    int stageCount();\n-\n-    void stageCount(int stageCount);\n-\n-    Tree tree(long idx);\n-\n@@ -286,1 +92,0 @@\n-\n@@ -288,0 +93,1 @@\n+    Tree tree(long idx);\n@@ -289,3 +95,0 @@\n-    int width();\n-\n-    void width(int width);\n@@ -293,1 +96,13 @@\n-    int height();\n+    Schema<Cascade> schema = Schema.of(Cascade.class, cascade -> cascade\n+            .fields(\"width\",\"height\")\n+            .arrayLen(\"featureCount\").array(\"feature\", feature -> feature\n+                    .fields(\"id\",\"threshold\")\n+                    .fields(\"left\",\"right\",linkOrValue->linkOrValue\n+                            .field(\"hasValue\")\n+                            .field(\"anon\", anon->anon.fields(\"featureId\",\"value\"))\n+                    )\n+                    .array(\"rect\", 3 , rect->rect.fields(\"x\",\"y\",\"width\",\"height\",\"weight\"))\n+            )\n+            .arrayLen(\"treeCount\").array(\"tree\",tree->tree.fields(\"id\",\"featureCount\",\"firstFeatureId\"))\n+            .arrayLen(\"stageCount\").array(\"stage\", stage->stage.fields(\"id\",\"threshold\",\"treeCount\",\"firstTreeId\"))\n+    );\n@@ -295,1 +110,0 @@\n-    void height(int height);\n@@ -297,16 +111,0 @@\n-  \/*  Schema schema2 = Schema.buffer(Cascade.class,cascade-> cascade\n-            .value(\"width\")\n-            .value(\"height\")\n-            .fieldConstrainedArray(\"feature\", a->a.lenField(\"featureCount\"), featureArray-> featureArray\n-                    .struct(feature-> feature\n-                            .value(\"id\")\n-                            .value(\"threshold\")\n-                            .struct(\"left\", l->{})\n-                            .struct(\"right\", r->{})\n-                            .fixedArray(\"rect\", 3, rect->rect\n-                                    .struct()\n-                            )\n-                    )\n-            .fieldConstrainedArray(\"tree\",a->a.lenField(\"treeCount\"))\n-            .fieldConstrainedArray(\"stage\", a->a.lenField(\"stageCount\"))\n-    ); *\/\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Cascade.java","additions":44,"deletions":246,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2024 Intel Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package experiments;\n-\n-\n-public class CascadeSchemaLayoutTest {\n-\n-    public static void main(String[] args) {\n-\n-        Cascade.schema.field.toText(0, t->System.out.print(t));\n-\n-        \/\/var layout = Cascade.schema.field.layout();\n-\n-   \/\/     System.out.println(layout);\n-    }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CascadeSchemaLayoutTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -70,1 +70,1 @@\n-                Schema schema = Schema.of(Inner.class, b->b.primitive(\"i\").primitive(\"f\"));\n+              \/\/  Schema schema = Schema.of(Inner.class, b->b.primitive(\"i\").primitive(\"f\"));\n@@ -81,2 +81,2 @@\n-                                    .primitive(\"i\")\n-                                    .primitive(\"f\")\n+                                    .field(\"i\")\n+                                    .field(\"f\")\n@@ -84,2 +84,2 @@\n-                            .struct(\"right\", Inner.schema)\n-                            .primitive(\"i\")\n+                           \/\/ .struct(\"right\", Inner.schema)\n+                            .field(\"i\")\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.buffer.Buffer;\n+\n+public interface S32Array extends Buffer {\n+    int length();\n+    int array(long idx);\n+    void array(long idx, int i);\n+    Schema<S32Array> schema = Schema.of(S32Array.class, s32Array->s32Array.arrayLen(\"length\").array(\"array\"));\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -4,0 +4,2 @@\n+import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.SegmentMapper;\n@@ -7,4 +9,0 @@\n-import java.lang.foreign.PaddingLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.UnionLayout;\n@@ -12,0 +10,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n@@ -20,13 +20,11 @@\n-public class Schema  {\n-\n-    public static abstract class Field<T extends MemoryLayout> {\n-        private static final Map<Class<?>, MemoryLayout> typeToLayout = new HashMap<>();\n-        static {\n-            typeToLayout.put(Integer.TYPE, ValueLayout.JAVA_INT);\n-            typeToLayout.put(Float.TYPE, ValueLayout.JAVA_FLOAT);\n-            typeToLayout.put(Long.TYPE, ValueLayout.JAVA_LONG);\n-            typeToLayout.put(Double.TYPE, ValueLayout.JAVA_DOUBLE);\n-            typeToLayout.put(Character.TYPE, ValueLayout.JAVA_CHAR);\n-            typeToLayout.put(Short.TYPE, ValueLayout.JAVA_SHORT);\n-            typeToLayout.put(Byte.TYPE, ValueLayout.JAVA_BYTE);\n-            typeToLayout.put(Boolean.TYPE, ValueLayout.JAVA_BOOLEAN);\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public class Schema<T extends Buffer>  {\n+    Field.ParentField field;\n+    Class<T> iface;\n+\n+    public GroupLayout layout(int ... arrayLengths) {\n+\n+        LinkedList<Integer> lengthsToBind = new LinkedList<>();\n+        for (var i:arrayLengths){\n+            lengthsToBind.add(i);\n@@ -34,0 +32,5 @@\n+        List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+        field.addLayout(memoryLayouts,lengthsToBind);\n+        return (GroupLayout) memoryLayouts.getFirst().withName(iface.getSimpleName());\n+    }\n+\n@@ -35,9 +38,59 @@\n-        private static MemoryLayout typeToLayout(Class<?> clazz) {\n-            if (typeToLayout.containsKey(clazz)) {\n-                return typeToLayout.get(clazz);\n-            } else if (clazz.isInterface()) {\n-                if (clazz.isAssignableFrom(Buffer.StructChild.class) || clazz.isAssignableFrom(Buffer.UnionChild.class)) {\n-                    try {\n-                        if (clazz.getDeclaredField(\"schema\") instanceof java.lang.reflect.Field field) {\n-                           throw new IllegalStateException(\"schema ref\");\n-                          \/\/  return ((Schema) field.get(null)).field;\n+\n+    static class AccessStyle {\n+        enum Style {ROOT,\n+            PRIMITIVE_GETTER_AND_SETTER, PRIMITIVE_GETTER, PRIMITIVE_SETTER,\n+            IFACE_GETTER,\n+            PRIMITIVE_ARRAY_SETTER, PRIMITIVE_ARRAY_GETTER,PRIMITIVE_ARRAY_GETTER_AND_SETTER,\n+            IFACE_ARRAY_GETTER;\n+        };\n+        Style style;\n+        Class<?> type;\n+        String name;\n+        AccessStyle(Style style, Class<?> type, String name) {\n+            this.style = style;\n+            this.type = type;\n+            this.name = name;\n+        }\n+        @Override\n+        public String toString() {\n+            return style.name()+\":\"+type.getSimpleName()+\":\"+name;\n+        }\n+        static AccessStyle of(Class<?> iface, String name) {\n+            AccessStyle[] accessStyle= new AccessStyle[]{null};\n+            Arrays.stream(iface.getDeclaredMethods()).filter(m -> m.getName().equals(name)).forEach(m -> {\n+                Class<?> returnType = m.getReturnType();\n+                Class<?>[] parameTypes = m.getParameterTypes();\n+                if (m.getParameterCount() == 0 && returnType.isInterface()) {\n+                    if (accessStyle[0]!=null){\n+                        throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].style);\n+                    }\n+                    accessStyle[0] = new AccessStyle(Style.IFACE_GETTER, returnType, name);\n+                }else    if (m.getParameterCount() == 0 &&returnType.isPrimitive()) {\n+                    if (accessStyle[0]!=null){\n+                       if (accessStyle[0].style == Style.PRIMITIVE_SETTER){\n+                           accessStyle[0] = new AccessStyle(Style.PRIMITIVE_GETTER_AND_SETTER, returnType, name);\n+                       }else{\n+                           throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].style);\n+                       }\n+                    }else {\n+                        accessStyle[0] = new AccessStyle(Style.PRIMITIVE_GETTER, returnType, name);\n+                    }\n+                } else if (m.getParameterCount() == 1 && parameTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                    if (accessStyle[0]!=null){\n+                        if (accessStyle[0].style == Style.PRIMITIVE_GETTER){\n+                            accessStyle[0] = new AccessStyle(Style.PRIMITIVE_GETTER_AND_SETTER, returnType, name);\n+                        }else{\n+                            throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].style);\n+                        }\n+                    }else {\n+                        accessStyle[0] = new AccessStyle(Style.PRIMITIVE_SETTER, returnType, name);\n+                    }\n+                } else if (m.getParameterCount() == 1 && parameTypes[0] == Long.TYPE && returnType.isInterface()) {\n+                    if (accessStyle[0]!=null){\n+                        throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].style);\n+                    }\n+                    accessStyle[0] = new AccessStyle(Style.IFACE_ARRAY_GETTER, returnType, name);\n+                } else if (m.getParameterCount() == 1 && parameTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n+                    if (accessStyle[0]!=null) {\n+                        if (accessStyle[0].style == Style.PRIMITIVE_ARRAY_SETTER) {\n+                            accessStyle[0] = new AccessStyle(Style.PRIMITIVE_ARRAY_GETTER_AND_SETTER, returnType, name);\n@@ -45,1 +98,1 @@\n-                            throw new RuntimeException(\"no Schema field found\");\n+                            throw new IllegalStateException(name + \" already dermined to to be \" + accessStyle[0].style);\n@@ -47,4 +100,13 @@\n-                    } catch (NoSuchFieldException e) {\n-                        throw new RuntimeException(e);\n-                  \/\/  } catch (IllegalAccessException e) {\n-                   \/\/     throw new RuntimeException(e);\n+                    }else {\n+                        accessStyle[0] = new AccessStyle(Style.PRIMITIVE_ARRAY_GETTER, returnType, name);\n+                    }\n+                } else if (returnType == Void.TYPE && parameTypes.length == 2 &&\n+                        parameTypes[0] == Long.TYPE && parameTypes[1].isPrimitive()){\n+                    if (accessStyle[0]!=null) {\n+                        if (accessStyle[0].style == Style.PRIMITIVE_ARRAY_GETTER) {\n+                            accessStyle[0] = new AccessStyle(Style.PRIMITIVE_ARRAY_GETTER_AND_SETTER, parameTypes[1], name);\n+                        } else {\n+                            throw new IllegalStateException(name + \" already dermined to to be \" + accessStyle[0].style);\n+                        }\n+                    }else {\n+                        accessStyle[0] = new AccessStyle(Style.PRIMITIVE_ARRAY_SETTER, parameTypes[1], name);\n@@ -53,1 +115,1 @@\n-                    throw new IllegalStateException(\"no Struct or Union found for \" + clazz);\n+                    System.out.println(\"skiping \" + m);\n@@ -55,2 +117,3 @@\n-            } else {\n-                throw new IllegalStateException(\"wtft\");\n+            });\n+            if (accessStyle[0] == null) {\n+                accessStyle[0] = new AccessStyle(Style.ROOT,iface, \"root\");\n@@ -58,0 +121,1 @@\n+            return accessStyle[0];\n@@ -59,0 +123,27 @@\n+    }\n+    private static final Map<Class<?>, MemoryLayout> typeToLayout = new HashMap<>();\n+    static {\n+        typeToLayout.put(Integer.TYPE, JAVA_INT);\n+        typeToLayout.put(Float.TYPE, ValueLayout.JAVA_FLOAT);\n+        typeToLayout.put(Long.TYPE, ValueLayout.JAVA_LONG);\n+        typeToLayout.put(Double.TYPE, ValueLayout.JAVA_DOUBLE);\n+        typeToLayout.put(Character.TYPE, ValueLayout.JAVA_CHAR);\n+        typeToLayout.put(Short.TYPE, ValueLayout.JAVA_SHORT);\n+        typeToLayout.put(Byte.TYPE, ValueLayout.JAVA_BYTE);\n+        typeToLayout.put(Boolean.TYPE, ValueLayout.JAVA_BOOLEAN);\n+    }\n+    static boolean isBuffer(Class<?> clazz){\n+        return clazz.isInterface() && Buffer.class.isAssignableFrom(clazz);\n+    }\n+    static boolean isStruct(Class<?> clazz){\n+        return clazz.isInterface() && Buffer.StructChild.class.isAssignableFrom(clazz);\n+    }\n+    static boolean isStructOrBuffer(Class<?> clazz){\n+        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.StructChild.class.isAssignableFrom(clazz));\n+    }\n+    static boolean isUnion(Class<?> clazz){\n+        return  clazz.isInterface() && Buffer.UnionChild.class.isAssignableFrom(clazz);\n+    }\n+    static boolean isMappable(Class<?> clazz){\n+        return  isStruct(clazz)||isBuffer(clazz)||isUnion(clazz);\n+    }\n@@ -60,3 +151,14 @@\n-        FieldHolder parent;\n-        String name;\n-        T layout;\n+    private static MemoryLayout typeToLayout(Class<?> clazz) {\n+        if (typeToLayout.containsKey(clazz)) {\n+            return typeToLayout.get(clazz);\n+        } else if (!isMappable(clazz)) {\n+            throw new IllegalStateException(\"What to do with mappable \"+clazz);\n+        } else {\n+            throw new IllegalStateException(\"What to do with UNmappable \"+clazz);\n+        }\n+\n+    }\n+\n+    public static abstract class Field {\n+\n+        ParentField parent;\n@@ -64,1 +166,1 @@\n-        Field(FieldHolder parent, String name) {\n+        Field(ParentField parent) {\n@@ -66,1 +168,0 @@\n-            this.name = name;\n@@ -71,8 +172,4 @@\n-        public static class Builder implements FieldHolder {\n-            Class<?> iface;\n-            List<Field<?>> children = new LinkedList<>();\n-            FieldHolder parent;\n-\n-\n-            public Class<?> iface() {\n-                return iface;\n+        public static class Padding extends Field {\n+            int len;\n+            Padding(ParentField parent, String name, int len) {\n+                super(parent);\n@@ -81,2 +178,4 @@\n-            public List<Field<?>> children() {\n-                return children;\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"padding \");\n@@ -84,3 +183,4 @@\n-\n-            public FieldHolder parent() {\n-                return parent;\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd){\n+                memoryLayouts.add(MemoryLayout.paddingLayout(len));\n+                return memoryLayouts;\n@@ -88,54 +188,6 @@\n-\n-            Class<?> getTypeForName(String name) {\n-                Class<?>[] clazz = new Class[]{null};\n-                Arrays.stream(iface().getDeclaredMethods()).filter(m -> m.getName().equals(name)).forEach(m -> {\n-                    if (m.getParameterCount() == 0 && m.getReturnType().isInterface()) {\n-                        clazz[0] = m.getReturnType();\n-                    }\n-                });\n-                return clazz[0];\n-            }\n-\n-            MemoryLayout layout() {\n-                return null;\n-            }\n-            \/*\n-                List<MemoryLayout> memoryLayouts = new ArrayList<>();\n-                Map<String, Integer> orderMap = new LinkedHashMap<>();\n-                Arrays.stream(order).forEach(s -> orderMap.put(s, orderMap.size())); \/\/ order[0] -> 0, order[1] -> r\n-                Set<String> done = new HashSet<>();\n-                Arrays.stream(bufferClass.getDeclaredMethods())\n-                        .filter(m -> orderMap.containsKey(m.getName()))                        \/\/only methods named in array\n-                        .sorted(Comparator.comparingInt(lhs -> orderMap.get(lhs.getName()))) \/\/ sort by order in the array\n-                        .forEach(m -> {\n-                            String name = m.getName();\n-                            if (!done.contains(name)) {\n-                                MemoryLayout layout = null;\n-                                var rt = m.getReturnType();\n-                                if (rt == Void.TYPE) {\n-                                    if (m.getParameterCount() == 1) {\n-                                        layout = typeToLayout(m.getParameterTypes()[0]);\n-                                    } else if (m.getParameterCount() == 2) {\n-                                        throw new IllegalStateException(\"never\");\n-                                    }\n-                                } else {\n-                                    layout = typeToLayout(rt);\n-                                }\n-                                if (layout instanceof ValueLayout) {\n-                                    memoryLayouts.add(layout.withName(name));\n-                                } else if (layout instanceof StructLayout) {\n-                                    memoryLayouts.add(layout.withName(name + \"::struct\"));\n-                                }\n-                                done.add(name);\n-                            }\n-\n-                        });\n-\n-                MemoryLayout.structLayout(memoryLayouts.toArray(new MemoryLayout[0])).withName(bufferClass.getName());\n-            } *\/\n-\n-            public Builder struct(String name, Class<?> clazz, Consumer<Builder> fb) {\n-                Builder builder = new Builder(clazz);\n-                fb.accept(builder);\n-                children.add(new Struct(this, name, clazz, builder.children));\n-                return this;\n+        }\n+        public static class ArrayLen extends Field {\n+            AccessStyle accessStyle;\n+            ArrayLen(ParentField parent,   AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n@@ -144,2 +196,4 @@\n-            public Builder struct(String name, Consumer<Builder> fb) {\n-                return struct(name, getTypeForName(name), fb);\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"arrayLen \" +accessStyle);\n@@ -147,4 +201,4 @@\n-\n-            public Builder struct(String name, FieldHolder schemaFieldHolder) {\n-                children.add(new Struct(this, name, getTypeForName(name), schemaFieldHolder.children()));\n-                return this;\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd){\n+                memoryLayouts.add(typeToLayout(accessStyle.type).withName(accessStyle.name));\n+                return memoryLayouts;\n@@ -152,4 +206,6 @@\n-\n-            public Builder struct(String name, Schema schema) {\n-                children.add(new Struct(this, name, getTypeForName(name), schema.field.children()));\n-                return this;\n+        }\n+        public static class Primitive extends Field {\n+            AccessStyle accessStyle;\n+            Primitive(ParentField parent,   AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n@@ -158,5 +214,4 @@\n-            public Builder union(String name, Class<?> clazz, Consumer<Builder> fb) {\n-                Builder builder = new Builder(clazz);\n-                fb.accept(builder);\n-                children.add(new Struct(this, name, clazz, builder.children));\n-                return this;\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"primitive \" +accessStyle);\n@@ -165,2 +220,4 @@\n-            public Builder union(String name, Consumer<Builder> fb) {\n-                return union(name, getTypeForName(name), fb);\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd){\n+                memoryLayouts.add(typeToLayout(accessStyle.type).withName(accessStyle.name));\n+                return memoryLayouts;\n@@ -168,0 +225,1 @@\n+        }\n@@ -169,4 +227,3 @@\n-            public Builder union(String name, FieldHolder fieldHolder) {\n-                children.add(new Struct(this, name, getTypeForName(name), fieldHolder.children()));\n-                return this;\n-            }\n+        public static abstract class ParentField extends Field  {\n+            List<Field> children = new ArrayList<>();\n+            AccessStyle accessStyle;\n@@ -174,3 +231,3 @@\n-            public Builder union(String name, Schema schema) {\n-                children.add(new Struct(this, name, getTypeForName(name), schema.field.children()));\n-                return this;\n+            ParentField(ParentField parent, AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n@@ -179,3 +236,8 @@\n-            public Builder primitive(String name) {\n-                children.add(new Primitive(this, name));\n-                return this;\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(\"{\\n\");\n+                children.forEach(c -> {\n+                    c.toText(depth + 1, stringConsumer);\n+                    stringConsumer.accept(\"\\n\");\n+                });\n+                stringConsumer.accept(\"}\");\n@@ -184,2 +246,5 @@\n-            public Builder array(String name, int len) {\n-                children.add(new FixedArray(this, name, getTypeForName(name), len));\n+\n+            public ParentField struct(String name, Consumer<ParentField> fb) {\n+                var struct = new Struct(this, name, AccessStyle.of(accessStyle.type, name));\n+                children.add(struct);\n+                fb.accept(struct);\n@@ -189,2 +254,4 @@\n-            public Builder fieldControlledArray(String name, Primitive primitive) {\n-                children.add(new FieldControlledArray(this, name, getTypeForName(name), primitive));\n+            public ParentField union(String name, Consumer<ParentField> fb) {\n+                var union = new Union(this, name, AccessStyle.of(accessStyle.type, name));\n+                children.add(union);\n+                fb.accept(union);\n@@ -194,4 +261,3 @@\n-            public Builder fieldControlledArray(String name, String controllingFieldName) {\n-                var primitiveField = new Primitive(this, controllingFieldName);\n-                children.add(primitiveField);\n-                return fieldControlledArray(name, primitiveField);\n+            public ParentField field(String name) {\n+                children.add(new Primitive(this, AccessStyle.of(accessStyle.type,name)));\n+                return this;\n@@ -200,3 +266,3 @@\n-            public class ArrayLen {\n-                Builder builder;\n-                Primitive controllingField;\n+            public ParentField field(String name, Consumer<ParentField>parentFieldConsumer) {\n+                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type,name);\n+                children.add(new Primitive(this, newAccessStyle));\n@@ -204,3 +270,0 @@\n-                Builder array(String name) {\n-                    return builder.fieldControlledArray(name, controllingField);\n-                }\n@@ -208,3 +271,7 @@\n-                ArrayLen(Builder builder, Primitive controllingField) {\n-                    this.builder = builder;\n-                    this.controllingField = controllingField;\n+                ParentField field;\n+                if (isStruct(newAccessStyle.type)){\n+                    field = new Field.Struct(this, newAccessStyle.type.getSimpleName(),newAccessStyle);\n+                }else if (isUnion(newAccessStyle.type)) {\n+                    field = new Field.Union(this, newAccessStyle.type.getSimpleName(), newAccessStyle);\n+                }else{\n+                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle.type);\n@@ -212,0 +279,3 @@\n+                parentFieldConsumer.accept(field);\n+                children.add(field);\n+                return this;\n@@ -213,6 +283,17 @@\n-\n-            public ArrayLen arrayLen(String controllingFieldName) {\n-\n-                var primitiveField = new Primitive(this, controllingFieldName);\n-                children.add(primitiveField);\n-                return new ArrayLen(this, primitiveField);\n+            public ParentField fields(String name1,String name2, Consumer<ParentField>parentFieldConsumer) {\n+                AccessStyle newAccessStyle1 = AccessStyle.of(accessStyle.type,name1);\n+                AccessStyle newAccessStyle2 = AccessStyle.of(accessStyle.type,name2);\n+                children.add(new Primitive(this, newAccessStyle1));\n+                children.add(new Primitive(this, newAccessStyle2));\n+\n+                ParentField field;\n+                if (isStruct(newAccessStyle1.type)){\n+                    field = new Field.Struct(this, newAccessStyle1.type.getSimpleName(),newAccessStyle1);\n+                }else if (isUnion(newAccessStyle1.type)) {\n+                    field = new Field.Union(this, newAccessStyle2.type.getSimpleName(), newAccessStyle2);\n+                }else{\n+                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle2.type);\n+                }\n+                parentFieldConsumer.accept(field);\n+                children.add(field);\n+                return this;\n@@ -220,3 +301,5 @@\n-\n-            public void flexArray(String name) {\n-                children.add(new FlexArray(this, name, null));\n+            public ParentField fields(String ...names) {\n+                for (var name:names){\n+                    field(name);\n+                }\n+                return this;\n@@ -225,3 +308,3 @@\n-\n-            Builder(Class<?> iface) {\n-                this.iface = iface;\n+            public ParentField array(String name, int len) {\n+                children.add(new FixedArray(this, name, AccessStyle.of(accessStyle.type,name), len));\n+                return this;\n@@ -229,0 +312,2 @@\n+            public ParentField array(String name, int len, Consumer<ParentField> parentFieldConsumer) {\n+                 AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type,name);\n@@ -230,2 +315,13 @@\n-            void toText(int depth, Consumer<String> stringConsumer) {\n-                children.stream().forEach(c -> c.toText(depth + 1, stringConsumer));\n+                ParentField field;\n+                if (isStruct(newAccessStyle.type)){\n+                    field = new Field.Struct(this, newAccessStyle.type.getSimpleName(),newAccessStyle);\n+                }else if (isUnion(newAccessStyle.type)) {\n+                    field = new Field.Union(this, newAccessStyle.type.getSimpleName(), newAccessStyle);\n+                }else{\n+                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle.type);\n+                }\n+                parentFieldConsumer.accept(field);\n+                children.add(field);\n+                children.add(new FixedArray(this, name, AccessStyle.of(accessStyle.type,name), len));\n+                return this;\n+                \/\/ builder.children.add(field);\n@@ -233,1 +329,0 @@\n-        }\n@@ -235,3 +330,0 @@\n-        public static interface FieldHolder {\n-            List<Field<?>> children();\n-        }\n@@ -239,3 +331,3 @@\n-        public static class Padding<T extends PaddingLayout> extends Field<T> {\n-            Padding(FieldHolder parent, String name) {\n-                super(parent, name);\n+            private ParentField fieldControlledArray(String name, ArrayLen arrayLen) {\n+                children.add(new FieldControlledArray(this, name,  AccessStyle.of(accessStyle.type,name), arrayLen));\n+                return this;\n@@ -244,4 +336,4 @@\n-            @Override\n-            public void toText(int depth, Consumer<String> stringConsumer) {\n-                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n-                stringConsumer.accept(\"padding \");\n+            public ParentField fieldControlledArray(String name, String arrayLenFieldName) {\n+                var arrayLen = new ArrayLen(this,  AccessStyle.of(accessStyle.type,arrayLenFieldName));\n+                children.add(arrayLen);\n+                return fieldControlledArray(name, arrayLen);\n@@ -249,1 +341,0 @@\n-        }\n@@ -251,1 +342,0 @@\n-        public static class Primitive extends Field<ValueLayout> {\n@@ -253,3 +343,3 @@\n-            Primitive(FieldHolder parent, String name) {\n-                super(parent, name);\n-            }\n+            public static class ArrayBuildState {\n+                ParentField builder;\n+                ArrayLen arrayLenField;\n@@ -257,6 +347,3 @@\n-            @Override\n-            public void toText(int depth, Consumer<String> stringConsumer) {\n-                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n-                stringConsumer.accept(\"primitive \" + name);\n-            }\n-        }\n+                ParentField array(String name) {\n+                    return builder.fieldControlledArray(name, arrayLenField);\n+                }\n@@ -264,4 +351,11 @@\n-        public static abstract class StructOrUnion<T extends GroupLayout> extends Field<T> implements Field.FieldHolder {\n-            Class<?> iface;\n-            List<Field<?>> children;\n-            FieldHolder parent;\n+                ParentField array(String name, Consumer<ParentField> parentFieldConsumer) {\n+                   AccessStyle newAccessStyle = AccessStyle.of(builder.accessStyle.type,name);\n+                    builder.fieldControlledArray(name, arrayLenField);\n+                    ParentField field;\n+                    if (isStruct(newAccessStyle.type)){\n+                        field = new Field.Struct(builder, builder.accessStyle.type.getSimpleName(),newAccessStyle);\n+                    }else if (isUnion(newAccessStyle.type)) {\n+                        field = new Field.Union(builder, builder.accessStyle.type.getSimpleName(), newAccessStyle);\n+                    }else{\n+                        throw new IllegalArgumentException(\"Unsupported array type: \" + builder.accessStyle.type);\n+                    }\n@@ -269,3 +363,4 @@\n-            public Class<?> iface() {\n-                return iface;\n-            }\n+                    parentFieldConsumer.accept(field);\n+                    builder.children.add(field);\n+                    return builder;\n+                }\n@@ -273,2 +368,4 @@\n-            public List<Field<?>> children() {\n-                return children;\n+                ArrayBuildState(ParentField builder, ArrayLen arrayLenField) {\n+                    this.builder = builder;\n+                    this.arrayLenField = arrayLenField;\n+                }\n@@ -277,2 +374,4 @@\n-            public FieldHolder parent() {\n-                return parent;\n+            public ArrayBuildState arrayLen(String arrayLenFieldName) {\n+                var arrayLenField = new ArrayLen(this,  AccessStyle.of(accessStyle.type,arrayLenFieldName));\n+                children.add(arrayLenField);\n+                return new ArrayBuildState(this, arrayLenField);\n@@ -281,4 +380,2 @@\n-            StructOrUnion(FieldHolder parent, String name, Class<?> iface, List<Field<?>> children) {\n-                super(parent, name);\n-                this.iface = iface;\n-                this.children = children;\n+            public void flexArray(String name) {\n+                children.add(new FlexArray(this, name, null));\n@@ -287,7 +384,0 @@\n-            @Override\n-            public void toText(int depth, Consumer<String> stringConsumer) {\n-                children.forEach(c -> {\n-                    c.toText(depth + 1, stringConsumer);\n-                    stringConsumer.accept(\"\\n\");\n-                });\n-            }\n@@ -296,4 +386,3 @@\n-\n-        public static class Struct extends StructOrUnion<StructLayout> {\n-            Struct(FieldHolder parent, String name, Class<?> iface, List<Field<?>> schemaFields) {\n-                super(parent, name, iface, schemaFields);\n+        public static class Struct extends ParentField {\n+            Struct(ParentField parent, String name, AccessStyle accessStyle) {\n+                super(parent, accessStyle);\n@@ -305,1 +394,1 @@\n-                stringConsumer.accept(\"struct \" + name);\n+                stringConsumer.accept(\"struct \" + accessStyle);\n@@ -308,0 +397,9 @@\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n+                List<MemoryLayout> structLayouts = new ArrayList<>();\n+                children.forEach(c->{\n+                    c.addLayout(structLayouts, lengthsToBind);\n+                });\n+                memoryLayouts.add(MemoryLayout.structLayout(structLayouts.toArray(new MemoryLayout[0])));\n+                return memoryLayouts;\n+            }\n@@ -310,3 +408,3 @@\n-        public static class Union extends StructOrUnion<UnionLayout> {\n-            Union(FieldHolder parent, String name, Class<?> iface, List<Field<?>> schemaFields) {\n-                super(parent, name, iface, schemaFields);\n+        public static class Union extends ParentField {\n+            Union(ParentField parent, String name, AccessStyle accessStyle) {\n+                super(parent, accessStyle);\n@@ -321,0 +419,9 @@\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n+                List<MemoryLayout> unionLayouts = new ArrayList<>();\n+                children.forEach(c->{\n+                    c.addLayout(unionLayouts, lengthsToBind);\n+                });\n+                memoryLayouts.add(MemoryLayout.unionLayout(unionLayouts.toArray(new MemoryLayout[0])));\n+                return memoryLayouts;\n+            }\n@@ -323,2 +430,3 @@\n-        public abstract static class Array extends Field<SequenceLayout> {\n-            Class<?> elementClass;\n+        public abstract static class Array extends Field {\n+          String name;\n+           AccessStyle elementAccessStyle;\n@@ -326,3 +434,4 @@\n-            Array(FieldHolder parent, String name, Class<?> elementClass) {\n-                super(parent, name);\n-                this.elementClass = elementClass;\n+            Array(ParentField parent, String name,  AccessStyle elementAccessStyle) {\n+                super(parent);\n+                this.name = name;\n+                this.elementAccessStyle = elementAccessStyle;\n@@ -335,2 +444,2 @@\n-            FixedArray(FieldHolder parent, String name, Class<?> elementClass, int len) {\n-                super(parent, name, elementClass);\n+            FixedArray(ParentField parent, String name, AccessStyle elementAccessStyle, int len) {\n+                super(parent, name, elementAccessStyle);\n@@ -345,0 +454,6 @@\n+\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n+                memoryLayouts.add(MemoryLayout.sequenceLayout(len, typeToLayout(elementAccessStyle.type)).withName(elementAccessStyle.name));\n+                return memoryLayouts;\n+            }\n@@ -349,2 +464,2 @@\n-            FlexArray(FieldHolder parent, String name, Class<?> elementClass) {\n-                super(parent, name, elementClass);\n+            FlexArray(ParentField parent, String name, AccessStyle elementAccessStyle) {\n+                super(parent, name, elementAccessStyle);\n@@ -358,0 +473,6 @@\n+\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n+                memoryLayouts.add(MemoryLayout.sequenceLayout(0, typeToLayout(elementAccessStyle.type)).withName(elementAccessStyle.name));\n+                return memoryLayouts;\n+            }\n@@ -361,1 +482,1 @@\n-            Primitive primitive;\n+            ArrayLen arrayLen;\n@@ -363,3 +484,3 @@\n-            FieldControlledArray(FieldHolder parent, String name, Class<?> elementClass, Primitive primitive) {\n-                super(parent, name, elementClass);\n-                this.primitive = primitive;\n+            FieldControlledArray(ParentField parent, String name, AccessStyle elementAccessStyle, ArrayLen arrayLen) {\n+                super(parent, name, elementAccessStyle);\n+                this.arrayLen = arrayLen;\n@@ -371,1 +492,6 @@\n-                stringConsumer.accept(\"field controlled \" + primitive.name + \" \" + name);\n+                stringConsumer.accept(elementAccessStyle.name+\"[\"+elementAccessStyle+\"] where len defined by \" + arrayLen.accessStyle);\n+            }\n+            @Override\n+            List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n+                memoryLayouts.add(MemoryLayout.sequenceLayout(lengthsToBind.removeFirst(), typeToLayout(elementAccessStyle.type)).withName(elementAccessStyle.name));\n+                return memoryLayouts;\n@@ -373,0 +499,1 @@\n+\n@@ -374,0 +501,3 @@\n+\n+\n+        abstract List<MemoryLayout>  addLayout(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind);\n@@ -376,2 +506,3 @@\n-    Field.StructOrUnion field;\n-    Schema(Field.StructOrUnion field) {\n+\n+    Schema(Class<T> iface, Field.ParentField field) {\n+        this.iface = iface;\n@@ -380,0 +511,20 @@\n+    static  class BoundSchema<T extends Buffer>{\n+        Schema<T> schema;\n+        MemoryLayout memoryLayout;\n+        int [] boundLengths;\n+        T instance;\n+        BoundSchema(T instance, Schema<T> schema, MemoryLayout memoryLayout, int[] boundLengths) {\n+            this.instance = instance;\n+            this.schema = schema;\n+            this.memoryLayout = memoryLayout;\n+            this.boundLengths = boundLengths;\n+        }\n+    }\n+\n+    BoundSchema<T> allocate(BufferAllocator bufferAllocator, int ...boundLengths){\n+        var layout = layout(boundLengths);\n+        System.out.println(layout);\n+        var segmentMapper = SegmentMapper.of(MethodHandles.lookup(), iface, layout);\n+        return new BoundSchema<T>(bufferAllocator.allocate(segmentMapper), this,layout,boundLengths);\n+    }\n+\n@@ -381,7 +532,8 @@\n-    public static <T extends Buffer> Schema of(Class<?> iface, Consumer<Field.Builder> fb) {\n-        Field.Builder builder = new Field.Builder(iface);\n-        fb.accept(builder);\n-        if (Buffer.class.isAssignableFrom(iface) || Buffer.StructChild.class.isAssignableFrom(iface)){\n-            return new Schema(new Field.Struct(null, iface.getSimpleName(),iface,builder.children));\n-        }else if (Buffer.StructChild.class.isAssignableFrom(iface)){\n-            return new Schema(new Field.Union(null, iface.getSimpleName(),iface,builder.children));\n+    public static <T extends Buffer>Schema<T> of(Class<T> iface, Consumer<Field.ParentField> fb) {\n+\n+        Field.ParentField field = null;\n+\n+        if (isBuffer(iface)){\n+            field = new Field.Struct(null, iface.getSimpleName(),AccessStyle.of(iface,iface.getSimpleName()));\n+        }else {\n+            throw new IllegalStateException(\"must be a Buffer\");\n@@ -389,1 +541,6 @@\n-        throw new IllegalStateException(\"must be a Sturct, Union or Buffer\");\n+        fb.accept(field);\n+        return new Schema<T>(iface, field);\n+    }\n+\n+    void toText(Consumer<String> stringConsumer){\n+        field.toText(0,stringConsumer);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Schema.java","additions":397,"deletions":240,"binary":false,"changes":637,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package experiments;\n+\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+\n+public class SchemaLayoutTest {\n+\n+    public static void main(String[] args) {\n+        Cascade.schema.toText(t->System.out.print(t));\n+        S32Array.schema.toText(t->System.out.print(t));\n+\n+        BufferAllocator bufferAllocator= new BufferAllocator() {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> s) {return s.allocate(Arena.global());}\n+        };\n+        hat.buffer.S32Array os32  = hat.buffer.S32Array.create(bufferAllocator,100);\n+        System.out.println();\n+        System.out.println(Buffer.getLayout(os32));\n+\n+\n+      \/\/  Function<SegmentMapper<S32Array>,S32Array> allocator = s->s.allocate(Arena.global());\n+        var s32Array = S32Array.schema.allocate(bufferAllocator, 100).instance;\n+        int i = s32Array.length();\n+       \/\/ var cascade = Cascade.schema.allocate(bufferAllocator,10,10,10).instance;\n+\n+        \/\/var layout = Cascade.schema.field.layout();\n+\n+   \/\/     System.out.println(layout);\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/SchemaLayoutTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -6,1 +6,1 @@\n-\n+@FunctionalInterface\n@@ -8,1 +8,1 @@\n-    <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper);\n+    <T extends Buffer>T allocate(SegmentMapper<T> segmentMapper);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/BufferAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/\/usr\/bin\/env jshell  \"$0\" \"$@\"; exit $?\n+\/\/usr\/bin\/env jshell --execution local \"$0\" \"$@\"; exit $?\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.*;\n+public class PomChecker {\n+   public static class XMLNode {\n+      org.w3c.dom.Element element;\n+      List<XMLNode> children = new ArrayList<>();\n+      Map<String, String> attrMap =  new HashMap<>();\n+\n+      XMLNode(org.w3c.dom.Element element) {\n+         this.element = element;\n+         this.element.normalize();\n+         for (int i = 0; i < this.element.getChildNodes().getLength(); i++) {\n+            if (this.element.getChildNodes().item(i) instanceof org.w3c.dom.Element e){\n+               this.children.add(new XMLNode(e));\n+            }\n+         }\n+         for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+            if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr){\n+               this.attrMap.put(attr.getName(),attr.getValue());\n+            }\n+         }\n+      }\n+      public boolean hasAttr(String name) { return attrMap.containsKey(name); }\n+      public String attr(String name) { return attrMap.get(name); }\n+      XMLNode(File file) throws Throwable {\n+         this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file).getDocumentElement());\n+      }\n+      void write(File file) throws Throwable {\n+         var  transformer = TransformerFactory.newInstance().newTransformer();\n+         transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+         transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+         transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+         transformer.transform(new DOMSource(element.getOwnerDocument()), new StreamResult(file));\n+      }\n+   }\n+   static Pattern varPattern=Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+   static public String varExpand(Map<String,String> props, String value){ \/\/ recurse\n+      String result = value;\n+      if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+         var v = matcher.group(1);\n+         result = varExpand(props,value.substring(0, matcher.start())\n+               +(v.startsWith(\"env\")\n+                  ?System.getenv(v.substring(4))\n+                  :props.get(v))\n+               +value.substring(matcher.end()));\n+         \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+      }\n+      return result;\n+   }\n+   static boolean isParent(File possibleParent, File maybeChild){\n+      File parent = maybeChild.getParentFile();\n+      while ( parent != null ) {\n+         if ( parent.equals( possibleParent ) )\n+            return true;\n+         parent = parent.getParentFile();\n+      }\n+      return false;\n+   }\n+\n+\n+   public static void main(String[] args) throws Throwable{\n+      var out = System.out;\n+      var err = System.out;\n+\n+      var osArch = System.getProperty(\"os.arch\");\n+      var osName = System.getProperty(\"os.name\");\n+      var osVersion = System.getProperty(\"os.version\");\n+      var javaVersion = System.getProperty(\"java.version\");\n+      var javaHome = System.getProperty(\"java.home\");\n+      var pwd = new File(System.getProperty(\"user.dir\"));\n+\n+      if (javaVersion.startsWith(\"23\")){\n+         out.println(\"javaVersion \"+javaVersion+\" looks OK\");\n+\n+         var props = new LinkedHashMap<String,String>();\n+         var dir = new File(\".\");\n+         var topPom = new XMLNode(new File(dir,\"pom.xml\"));\n+         var babylonDirKey = \"babylon.dir\";\n+         var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n+         var hatDirKey = \"hat.dir\";\n+         var interestingKeys = Set.of(spirvDirKey, babylonDirKey,hatDirKey);\n+         var requiredDirKeys = Set.of(babylonDirKey, hatDirKey);\n+         var dirKeyToDirMap = new HashMap<String,File>();\n+\n+         topPom.children.stream().filter(e->e.element.getNodeName().equals(\"properties\")).forEach(properties ->\n+               properties.children.stream().forEach(property ->{\n+                  var key = property.element.getNodeName();\n+                  var value = varExpand(props,property.element.getTextContent());\n+                  props.put(key, value);\n+                  if (interestingKeys.contains(key)){\n+                      var file = new File(value);\n+                      if (requiredDirKeys.contains(key) && !file.exists()){\n+                         out.println(\"pom.xml has property '\"+key+\"' with value '\"+value+\"' but that dir does not exists! BAD\");\n+                         System.exit(1);\n+                      }\n+                      dirKeyToDirMap.put(key,file);\n+                  }\n+                  })\n+               );\n+         for (var key:requiredDirKeys){\n+             if (!props.containsKey(key)){\n+                 out.println(\"pom.xml expected to have property '\"+key+\"' \");\n+                 System.exit(1);\n+             }\n+         }\n+\n+         var javaHomeDir = new File(javaHome);\n+         var babylonDir = dirKeyToDirMap.get(babylonDirKey);\n+         if (isParent(babylonDir, javaHomeDir)){\n+            out.println(\"babylon.dir '\"+babylonDir+\"' is parent of JAVA_HOME OK\");\n+\n+            var hatDir = dirKeyToDirMap.get(hatDirKey);\n+            if (hatDir.equals(pwd)){\n+               out.println(\"hat.dir='\"+hatDir+\"' OK\");\n+               var backendsPom = new XMLNode(new File(dir,\"backends\/pom.xml\"));\n+               var modules = backendsPom.children.stream().filter(e->e.element.getNodeName().equals(\"modules\")).findFirst().get();\n+               var spirvModule = modules.children.stream().filter(e->e.element.getTextContent().equals(\"spirv\")).findFirst();\n+\n+               if (spirvModule.isPresent()){\n+\n+                  if (dirKeyToDirMap.containsKey(spirvDirKey)) {\n+                     var spirvDir = dirKeyToDirMap.get(spirvDirKey);\n+                     if (spirvDir.exists()) {\n+                        out.println(\"OK \"+spirvDirKey + \" -> '\" + spirvDir + \"' dir exists and module included in backends\");\n+                     } else {\n+                        out.println(\"ERR \"+spirvDirKey + \" -> '\" + spirvDir + \"' dir does not exists but module included in backends \");\n+                     }\n+                  }else{\n+                     out.println(\"ERR \"+spirvDirKey + \" -> variable dir does not exists but module included in backends \");\n+                  }\n+               } else{\n+                  if (dirKeyToDirMap.containsKey(spirvDirKey)) {\n+                     var spirvDir = dirKeyToDirMap.get(spirvDirKey);\n+                     if (spirvDir.exists()){\n+                        out.println(\"ERR \"+spirvDirKey+\" -> '\"+spirvDir+\"' dir exists but spirv module not included in backends \");\n+                     }else{\n+                        out.println(\"WARN \"+spirvDirKey+\" -> '\"+spirvDir+\"' dir does not exist and not included in backends \");\n+                     }\n+                  }else{\n+                     out.println(\"OK \"+ spirvDirKey + \" -> variable dir does not exist and module not included in backends \");\n+                  }\n+               }\n+            } else{\n+               out.println(\"hat.dir='\"+hatDir+\"' != ${pwd}='\"+pwd+\"' BAD\");\n+            }\n+         }else{\n+            out.println(\"babylon.dir '\"+babylonDir+\"' is not a child of javaHome '\"+javaHome+\"' BAD\");\n+         }\n+      }else{\n+         err.println(\"Incorrect Java version. Is babylon jdk in your path? BAD\");\n+      }\n+   }\n+}\n+\n","filename":"hat\/sanity.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"}]}