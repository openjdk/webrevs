{"files":[{"patch":"@@ -2,0 +2,1 @@\n+bld-debug\n","filename":"hat\/backends\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,250 @@\n+#!\/usr\/bin\/env java --enable-preview --source 24 \n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import module java.compiler;\n+\n+\n+static String join(List<Path> paths, char separator){\n+   StringBuilder sb = new StringBuilder();\n+   paths.forEach(path -> {\n+      if (!sb.isEmpty()) {\n+         sb.append(separator);\n+      }\n+      sb.append(path);\n+   });\n+   return sb.toString();\n+}\n+\n+static void addEntry(JarOutputStream jarStream, Path root, Path path){\n+    try{\n+       var attributes = Files.readAttributes(path, PosixFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+       var entry = new JarEntry(root.relativize(path).toString()+(attributes.isDirectory()?\"\/\":\"\"));\n+       entry.setTime(attributes.lastModifiedTime().toMillis());\n+       jarStream.putNextEntry(entry);\n+       if (attributes.isRegularFile()){\n+          Files.newInputStream(path).transferTo(jarStream);\n+       }\n+       jarStream.closeEntry();\n+    }catch(IOException ioe){\n+      println(ioe);\n+    }\n+}\n+\n+\n+static Path javacjar(Path jar, Path classesDir, List<Path> sourcePath, List<Path> classPath, List<Path> resourcePath) throws IOException{\n+     var src = new ArrayList<Path>();\n+     sourcePath.forEach(path->{\n+         try{\n+            Files.walk(path).forEach(s->{if (s.toString().endsWith(\".java\")){src.add(s);}});\n+         }catch(IOException ioe){\n+            println(ioe);\n+         }\n+     });\n+\n+     if (Files.exists(classesDir)) {\n+       Files.walk(classesDir).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+     }\n+     Files.createDirectories(classesDir);\n+     DiagnosticListener<JavaFileObject> dl = (diagnostic)-> System.out.println(diagnostic.getKind() + \" \" + diagnostic.getMessage(null));\n+\n+     var opts = new ArrayList<String>(List.of(\n+         \"--source\",\"24\",\n+         \"--enable-preview\",\n+         \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+         \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+         \"-d\", classesDir.toString(),\n+         \"--source-path\", join(sourcePath,':')\n+     ));\n+     if (!classPath.isEmpty()){ \n+        opts.addAll(List.of(\n+           \"--class-path\", join(classPath,':')\n+        ));\n+     }\n+     \/\/println(opts);\n+     \n+     List<Path> pathsToJar = new ArrayList<>();\n+     JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n+     ((com.sun.source.util.JavacTask) javac.getTask(new PrintWriter(System.err), javac.getStandardFileManager(dl, null, null), dl, opts, null,\n+        src.stream().map(path->\n+             new SimpleJavaFileObject(path.toUri(),JavaFileObject.Kind.SOURCE){\n+                public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                   try {\n+                     return Files.readString(Path.of(toUri()));\n+                   } catch (IOException e) {\n+                      throw new RuntimeException(e);\n+                  }\n+             }\n+          }).toList()\n+     )).generate().forEach(fileObject->pathsToJar.add(Path.of(fileObject.toUri())));\n+\n+     var jarStream = new JarOutputStream(Files.newOutputStream(jar));\n+     var setOfDirs = new HashSet<Path>();\n+     pathsToJar.stream().sorted().forEach(path -> {\n+          var parentDir = path.getParent();\n+          if (!setOfDirs.contains(parentDir)){\n+             setOfDirs.add(parentDir);\n+             addEntry(jarStream, classesDir, parentDir);\n+          }\n+          addEntry(jarStream, classesDir, path);\n+     });\n+     resourcePath.stream().sorted().forEach(resourceDir->{\n+          if (Files.isDirectory(resourceDir)){\n+             \/\/println(\"Trying \"+resourceDir);\n+             try{\n+               Files.walk(resourceDir).filter(path->Files.isRegularFile(path)).forEach(path->{\n+                 var parentDir = path.getParent();\n+                 if (!setOfDirs.contains(parentDir)){\n+                    setOfDirs.add(parentDir);\n+                    addEntry(jarStream, resourceDir, parentDir);\n+                 }\n+                 addEntry(jarStream, resourceDir, path);\n+               });\n+             }catch(IOException ioe){\n+               println(ioe);\n+             } \n+          \/\/}else{\n+          \/\/ println(\"no resources \"+resourceDir);\n+          }\n+        }\n+     );\n+     jarStream.finish();\n+     jarStream.close();\n+     return jar;\n+}\n+static Path javacjar(Path jar, Path classesDir, List<Path> sourcePath, List<Path> classPath) throws IOException{\n+    return javacjar(jar, classesDir, sourcePath, classPath, List.of( \/*resources*\/));\n+}\n+static Path javacjar(Path jar, Path classesDir, List<Path> sourcePath) throws IOException{\n+    return javacjar(jar, classesDir, sourcePath, List.of( \/*classpath*\/));\n+}\n+\n+static Path path(String name){\n+   return Path.of(name);\n+}\n+\n+static List<Path> paths(Path ...paths){\n+     List<Path> selectedPaths = new ArrayList<>();\n+     Arrays.asList(paths).forEach(path->{\n+        if (Files.isDirectory(path)){\n+           selectedPaths.add(path);\n+        }\n+     });\n+     return selectedPaths;\n+}\n+\n+void main(String[] args) throws IOException, InterruptedException {\n+     var hatDir = path(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n+\n+     Set.of(\"hat\", \"examples\", \"backends\").forEach(dirName->{\n+         try{\n+            Files.walk(Paths.get(dirName)).filter(p->{\n+              var name = p.toString();\n+              return !name.contains(\"cmake-build-debug\")\n+                && !name.contains(\"rleparser\")\n+                && ( name.endsWith(\".java\") || name.endsWith(\".cpp\") || name.endsWith(\".h\"));\n+              }).forEach(path->{\n+                try{\n+                   boolean license = false;\n+                   for (String line: Files.readAllLines(path,  StandardCharsets.UTF_8)){\n+                      if (line.contains(\"\\t\")){\n+                        System.err.println(\"ERR TAB \"+path+\":\"+line);\n+                      }\n+                      if (line.endsWith(\" \")) {\n+                        System.err.println(\"ERR TRAILING WHITESPACE \"+path+\":\"+line);\n+                      }\n+                      if (Pattern.matches(\"^  *(package|import).*$\",line)) { \/\/ I saw this a few times....?\n+                        System.err.println(\"ERR WEIRD INDENT \"+path+\":\"+line);\n+                      }\n+                      if (Pattern.matches(\"^.*Copyright.*202[4-9].*Intel.*$\",line)) { \/\/ not foolproof I know\n+                        license = true;\n+                      }\n+                      if (Pattern.matches(\"^.*Copyright.*202[4-9].*Oracle.*$\",line)) { \/\/ not foolproof I know\n+                        license = true;\n+                      }\n+                   }\n+                   if (!license){\n+                      System.err.println(\"ERR MISSING LICENSE \"+path);\n+                   }\n+                } catch(IOException ioe){\n+                  System.err.println(ioe);\n+                }\n+            });\n+         } catch(IOException ioe){\n+           System.err.println(ioe);\n+         }\n+      });\n+\n+     \n+     var target = hatDir.resolve(\"build\");\n+\n+     var hatJar = javacjar(\n+         target.resolve(\"hat-1.0.jar\"),\n+         target.resolve(\"hat-1.0.jar.classes\"),\n+         List.of(hatDir.resolve(\"hat\/src\/main\/java\"))\n+     );\n+     println(hatJar);\n+\n+     for (var example: List.of(\"mandel\", \"squares\", \"heal\", \"violajones\", \"life\")){\n+       var exampleJar = javacjar(\n+         target.resolve(\"hat-example-\"+example+\"-1.0.jar\"),\n+         target.resolve(\"hat-example-\"+example+\"-1.0.jar.classes\"),\n+         List.of(hatDir.resolve(\"examples\/\"+example+\"\/src\/main\/java\")),\n+         List.of(hatJar),\n+         List.of(hatDir.resolve(\"examples\/\"+example+\"\/src\/main\/resources\"))\n+       );\n+       println(exampleJar);\n+     }\n+     var backendsDir = hatDir.resolve(\"backends\");\n+     for (var backend: List.of(\"opencl\")){\n+       var backendDir = backendsDir.resolve(backend);\n+       var backendJar = javacjar(\n+         target.resolve(\"hat-backend-\"+backend+\"-1.0.jar\"),\n+         target.resolve(\"hat-backend-\"+backend+\"-1.0.jar.classes\"),\n+         List.of(backendDir.resolve(\"src\/main\/java\")),\n+         List.of(hatJar),\n+         List.of(backendDir.resolve(\"src\/main\/resources\"))\n+       );\n+       println(backendJar);\n+     }\n+  \n+     var cmakeBldDebugDir = backendsDir.resolve(\"bld-debug\");\n+     Files.createDirectories(cmakeBldDebugDir);\n+     var cmakeInit  = new ProcessBuilder()\n+        .directory(backendsDir.toFile())\n+        .inheritIO()\n+        .command(\"cmake\",\"-B\", cmakeBldDebugDir.getFileName().toString(), \"-DHAT_TARGET=\"+target)\n+        .start();\n+    cmakeInit.waitFor();\n+\n+     var cmakeBuild  = new ProcessBuilder()\n+        .directory(backendsDir.toFile())\n+        .inheritIO()\n+        .command(\"cmake\",\"--build\", cmakeBldDebugDir.getFileName().toString(),\"--target\", \"copy_libs\")\n+        .start();\n+     cmakeBuild.waitFor();\n+\n+}\n+\n","filename":"hat\/bld","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -34,0 +34,10 @@\n+   if test -d maven-build; then \n+      echo using trad maven-build\n+      build_dir=maven-build\n+   elif test -d build; then \n+      echo using new build dir\n+      build_dir=build\n+   else\n+      echo No maven-build or build dir!\n+      exit 1\n+   fi\n@@ -37,1 +47,1 @@\n-       backend_jar=maven-build\/hat-backend-${backend}-1.0.jar\n+       backend_jar=${build_dir}\/hat-backend-${backend}-1.0.jar\n@@ -41,1 +51,1 @@\n-      example_jar=maven-build\/hat-example-${example}-1.0.jar\n+      example_jar=${build_dir}\/hat-example-${example}-1.0.jar\n@@ -46,1 +56,1 @@\n-            --class-path maven-build\/hat-1.0.jar:${example_jar}:${backend_jar}:maven-build\/levelzero.jar:maven-build\/beehive-spirv-lib-0.0.4.jar \\\n+            --class-path ${build_dir}\/hat-1.0.jar:${example_jar}:${backend_jar}:${build_dir}\/levelzero.jar:${build_dir}\/beehive-spirv-lib-0.0.4.jar \\\n@@ -48,1 +58,1 @@\n-            -Djava.library.path=maven-build:\/usr\/local\/lib \\\n+            -Djava.library.path=${build_dir}:\/usr\/local\/lib \\\n","filename":"hat\/hatrun.bash","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}