{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import hat.optools.InvokeOpWrapper;\n@@ -36,1 +35,0 @@\n-import hat.optools.OpWrapper;\n@@ -455,1 +453,1 @@\n-                if (InvokeOpWrapper.isIfaceBufferMethod(lookup,invokeOp)\n+                if (OpTk.isIfaceBufferMethod(lookup,invokeOp)\n@@ -487,1 +485,1 @@\n-var paramTable = new OpTk.ParamTable(lowered);\n+        var paramTable = new OpTk.ParamTable(lowered);\n@@ -495,1 +493,2 @@\n-        ssa.bodies().getFirst().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lookup,o))));\n+        ssa.bodies().getFirst().blocks().forEach(block ->\n+                builder.blockBody(block, block.ops().stream()));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.optools.OpWrapper;\n@@ -122,1 +121,1 @@\n-             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n+             ampersand().recurse(buildContext, instanceResult.op());\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -120,1 +121,1 @@\n-    public void blockBody(Block block, Stream<OpWrapper<?>> ops) {\n+    public void blockBody(Block block, Stream<Op> ops) {\n@@ -133,1 +134,1 @@\n-            if (op instanceof InvokeOpWrapper invoke && !invoke.isIfaceBufferMethod()) {\n+            if (op instanceof JavaOp.InvokeOp invoke && !OpTk.isIfaceBufferMethod(MethodHandles.lookup(),invoke)) {  \/\/ We should pass lookup down\n@@ -196,14 +197,14 @@\n-    public PTXHATKernelBuilder convert(OpWrapper<?> wrappedOp) {\n-        switch (wrappedOp) {\n-            case FieldLoadOpWrapper op -> fieldLoad(op);\n-            case FieldStoreOpWrapper op -> fieldStore(op);\n-            case BinaryArithmeticOrLogicOperation op -> binaryOperation(op);\n-            case BinaryTestOpWrapper op -> binaryTest(op);\n-            case ConvOpWrapper op -> conv(op);\n-            case ConstantOpWrapper op -> constant(op);\n-            case YieldOpWrapper op -> javaYield(op);\n-            case InvokeOpWrapper op -> methodCall(op);\n-            case VarDeclarationOpWrapper op -> varDeclaration(op);\n-            case VarFuncDeclarationOpWrapper op -> varFuncDeclaration(op);\n-            case ReturnOpWrapper op -> ret(op);\n-            case JavaBreakOpWrapper op -> javaBreak(op);\n+    public PTXHATKernelBuilder convert(Op op) {\n+        switch (op) {\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad($);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStore($);\n+            case JavaOp.BinaryOp $ -> binaryOperation($);\n+            case JavaOp.BinaryTestOp $ -> binaryTest($);\n+            case JavaOp.ConvOp $ -> conv($);\n+            case CoreOp.ConstantOp $ -> constant($);\n+            case CoreOp.YieldOp $ -> javaYield($);\n+            case JavaOp.InvokeOp $ -> methodCall($);\n+            case CoreOp.VarOp $ when OpTk.paramVar($) != null -> varFuncDeclaration($);\n+            case CoreOp.VarOp $ -> varDeclaration($);\n+            case CoreOp.ReturnOp $ -> ret($);\n+            case JavaOp.BreakOp $ -> javaBreak($);\n@@ -211,5 +212,5 @@\n-                switch (wrappedOp.op){\n-                    case CoreOp.BranchOp op -> branch(op);\n-                    case CoreOp.ConditionalBranchOp op -> condBranch(op);\n-                    case JavaOp.NegOp op -> neg(op);\n-                    case PTXPtrOp op -> ptxPtr(op);\n+                switch (op){\n+                    case CoreOp.BranchOp $ -> branch($);\n+                    case CoreOp.ConditionalBranchOp $ -> condBranch($);\n+                    case JavaOp.NegOp $ -> neg($);\n+                    case PTXPtrOp $ -> ptxPtr($);\n@@ -241,2 +242,2 @@\n-    public void fieldLoad(FieldLoadOpWrapper fieldLoadOpWrapper) {\n-        if (OpTk.fieldName(fieldLoadOpWrapper.op).equals(Field.KC_X.toString())) {\n+    public void fieldLoad(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (OpTk.fieldName(fieldLoadOp).equals(Field.KC_X.toString())) {\n@@ -244,1 +245,1 @@\n-                loadKcX(fieldLoadOpWrapper.op.result());\n+                loadKcX(fieldLoadOp.result());\n@@ -246,1 +247,1 @@\n-                mov().u32().space().resultReg(fieldLoadOpWrapper, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n+                mov().u32().space().resultReg(fieldLoadOp, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n@@ -248,1 +249,1 @@\n-        } else if (OpTk.fieldName(fieldLoadOpWrapper.op).equals(Field.KC_MAXX.toString())) {\n+        } else if (OpTk.fieldName(fieldLoadOp).equals(Field.KC_MAXX.toString())) {\n@@ -250,1 +251,1 @@\n-                loadKcX(fieldLoadOpWrapper.op.operands().getFirst());\n+                loadKcX(fieldLoadOp.operands().getFirst());\n@@ -252,1 +253,1 @@\n-            ld().global().u32().space().fieldReg(Field.KC_MAXX, fieldLoadOpWrapper.op.result()).commaSpace()\n+            ld().global().u32().space().fieldReg(Field.KC_MAXX, fieldLoadOp.result()).commaSpace()\n@@ -255,1 +256,1 @@\n-            ld().global().u32().space().resultReg(fieldLoadOpWrapper, PTXRegister.Type.U64).commaSpace().reg(fieldLoadOpWrapper.op.operands().getFirst());\n+            ld().global().u32().space().resultReg(fieldLoadOp, PTXRegister.Type.U64).commaSpace().reg(fieldLoadOp.operands().getFirst());\n@@ -270,1 +271,1 @@\n-    public void fieldStore(FieldStoreOpWrapper op) {\n+    public void fieldStore(JavaOp.FieldAccessOp.FieldStoreOp op) {\n@@ -272,1 +273,1 @@\n-        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.op.operands().getFirst());\n+        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operands().getFirst());\n@@ -297,4 +298,4 @@\n-    public void binaryOperation(BinaryArithmeticOrLogicOperation op) {\n-        symbol(op.op);\n-        if (getResultType(op.op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n-                && (op.op instanceof JavaOp.DivOp || op.op instanceof JavaOp.MulOp)) {\n+    public void binaryOperation(JavaOp.BinaryOp op) {\n+        symbol(op);\n+        if (getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && (op instanceof JavaOp.DivOp || op instanceof JavaOp.MulOp)) {\n@@ -302,2 +303,2 @@\n-        } else if (!getResultType(op.op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n-                && op.op instanceof JavaOp.MulOp) {\n+        } else if (!getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && op instanceof JavaOp.MulOp) {\n@@ -306,2 +307,2 @@\n-        resultType(op.op.resultType(), true).space();\n-        resultReg(op, getResultType(op.op.resultType()));\n+        resultType(op.resultType(), true).space();\n+        resultReg(op, getResultType(op.resultType()));\n@@ -309,1 +310,1 @@\n-        reg(op.op.operands().getFirst());\n+        reg(op.operands().getFirst());\n@@ -311,1 +312,1 @@\n-        reg(op.op.operands().get(1));\n+        reg(op.operands().get(1));\n@@ -314,1 +315,1 @@\n-    public void binaryTest(BinaryTestOpWrapper op) {\n+    public void binaryTest(JavaOp.BinaryTestOp op) {\n@@ -316,1 +317,1 @@\n-        symbol(op.op).resultType(op.op.operands().getFirst().type(), true).space();\n+        symbol(op).resultType(op.operands().getFirst().type(), true).space();\n@@ -319,1 +320,1 @@\n-        reg(op.op.operands().getFirst());\n+        reg(op.operands().getFirst());\n@@ -321,1 +322,1 @@\n-        reg(op.op.operands().get(1));\n+        reg(op.operands().get(1));\n@@ -324,2 +325,2 @@\n-    public void conv(ConvOpWrapper op) {\n-        if (op.op.resultType().equals(JavaType.LONG)) {\n+    public void conv(JavaOp.ConvOp op) {\n+        if (op.resultType().equals(JavaType.LONG)) {\n@@ -328,1 +329,1 @@\n-                        .reg(op.op.operands().getFirst()).commaSpace().intVal(4);\n+                        .reg(op.operands().getFirst()).commaSpace().intVal(4);\n@@ -330,2 +331,2 @@\n-                cvt().u64().dot().regType(op.op.operands().getFirst()).space()\n-                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.op.operands().getFirst()).ptxNl();\n+                cvt().u64().dot().regType(op.operands().getFirst()).space()\n+                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operands().getFirst()).ptxNl();\n@@ -333,4 +334,4 @@\n-        } else if (op.op.resultType().equals(JavaType.FLOAT)) {\n-            cvt().rn().f32().dot().regType(op.op.operands().getFirst()).space()\n-                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.op.operands().getFirst());\n-        } else if (op.op.resultType().equals(JavaType.DOUBLE)) {\n+        } else if (op.resultType().equals(JavaType.FLOAT)) {\n+            cvt().rn().f32().dot().regType(op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.operands().getFirst());\n+        } else if (op.resultType().equals(JavaType.DOUBLE)) {\n@@ -338,1 +339,1 @@\n-            if (op.op.operands().getFirst().type().equals(JavaType.INT)) {\n+            if (op.operands().getFirst().type().equals(JavaType.INT)) {\n@@ -341,3 +342,3 @@\n-            f64().dot().regType(op.op.operands().getFirst()).space()\n-                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.op.operands().getFirst());\n-        } else if (op.op.resultType().equals(JavaType.INT)) {\n+            f64().dot().regType(op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operands().getFirst());\n+        } else if (op.resultType().equals(JavaType.INT)) {\n@@ -345,1 +346,1 @@\n-            if (op.op.operands().getFirst().type().equals(JavaType.DOUBLE) || op.op.operands().getFirst().type().equals(JavaType.FLOAT)) {\n+            if (op.operands().getFirst().type().equals(JavaType.DOUBLE) || op.operands().getFirst().type().equals(JavaType.FLOAT)) {\n@@ -350,2 +351,2 @@\n-            s32().dot().regType(op.op.operands().getFirst()).space()\n-                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.op.operands().getFirst());\n+            s32().dot().regType(op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operands().getFirst());\n@@ -353,2 +354,2 @@\n-            cvt().rn().s32().dot().regType(op.op.operands().getFirst()).space()\n-                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.op.operands().getFirst());\n+            cvt().rn().s32().dot().regType(op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operands().getFirst());\n@@ -442,2 +443,2 @@\n-    private boolean isIndex(ConvOpWrapper op) {\n-        for (Op.Result r : op.op.result().uses()) {\n+    private boolean isIndex(JavaOp.ConvOp op) {\n+        for (Op.Result r : op.result().uses()) {\n@@ -449,4 +450,4 @@\n-    public void constant(ConstantOpWrapper op) {\n-        mov().resultType(op.op.resultType(), false).space().resultReg(op, getResultType(op.op.resultType())).commaSpace();\n-        if (op.op.resultType().toString().equals(\"float\")) {\n-            if (op.op.value().toString().equals(\"0.0\")) {\n+    public void constant(CoreOp.ConstantOp op) {\n+        mov().resultType(op.resultType(), false).space().resultReg(op, getResultType(op.resultType())).commaSpace();\n+        if (op.resultType().toString().equals(\"float\")) {\n+            if (op.value().toString().equals(\"0.0\")) {\n@@ -455,1 +456,1 @@\n-                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op.value().toString()))).toUpperCase());\n+                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.value().toString()))).toUpperCase());\n@@ -458,1 +459,1 @@\n-            append(op.op.value().toString());\n+            append(op.value().toString());\n@@ -462,1 +463,1 @@\n-    public void javaYield(YieldOpWrapper op) {\n+    public void javaYield(CoreOp.YieldOp op) {\n@@ -467,2 +468,2 @@\n-    public void methodCall(InvokeOpWrapper op) {\n-        switch (op.methodRef().toString()) {\n+    public void methodCall(JavaOp.InvokeOp op) {\n+        switch (OpTk.methodRef(op).toString()) {\n@@ -472,1 +473,1 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.op.operands().getFirst()).commaSpace().reg(op.op.operands().get(1)).ptxNl();\n+                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n@@ -477,2 +478,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.op.operands().getFirst()).commaSpace().reg(op.op.operands().get(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.op.operands().get(2));\n+                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operands().get(2));\n@@ -481,1 +482,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.op.operands().getFirst()).name());\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name());\n@@ -486,2 +487,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.op.operands().getFirst()).commaSpace().reg(op.op.operands().get(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.op.operands().get(2));\n+                add().s64().space().regName(temp).commaSpace().reg(op.operands().getFirst()).commaSpace().reg(op.operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operands().get(2));\n@@ -490,1 +491,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.op.operands().getFirst()).name());\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name());\n@@ -493,1 +494,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.op.operands().getFirst()).name(), 4);\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operands().getFirst()).name(), 4);\n@@ -497,1 +498,1 @@\n-                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.op.operands().getFirst()).semicolon();\n+                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operands().getFirst()).semicolon();\n@@ -501,3 +502,3 @@\n-                for (int i = 0; i < op.op.operands().size(); i++) {\n-                    dot().param().space().paramType(op.op.operands().get(i).type()).space().param().intVal(i).ptxNl();\n-                    st().dot().param().paramType(op.op.operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.op.operands().get(i)).ptxNl();\n+                for (int i = 0; i < op.operands().size(); i++) {\n+                    dot().param().space().paramType(op.operands().get(i).type()).space().param().intVal(i).ptxNl();\n+                    st().dot().param().paramType(op.operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operands().get(i)).ptxNl();\n@@ -505,2 +506,2 @@\n-                dot().param().space().paramType(op.op.resultType()).space().retVal().ptxNl();\n-                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.method().getName()).commaSpace();\n+                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().append(OpTk.method(MethodHandles.lookup(),op).getName()).commaSpace();\n@@ -508,2 +509,2 @@\n-                paren(_ -> commaSeparated(op.op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n-                ld().dot().param().paramType(op.op.resultType()).space().resultReg(op, getResultType(op.op.resultType())).commaSpace().osbrace().retVal().csbrace();\n+                paren(_ -> commaSeparated(op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n+                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n@@ -515,2 +516,2 @@\n-    public void varDeclaration(VarDeclarationOpWrapper op) {\n-        ld().dot().param().resultType(op.op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.op.operands().getFirst());\n+    public void varDeclaration(CoreOp.VarOp op) {\n+        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operands().getFirst());\n@@ -519,2 +520,2 @@\n-    public void varFuncDeclaration(VarFuncDeclarationOpWrapper op) {\n-        ld().dot().param().resultType(op.op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.op.operands().getFirst());\n+    public void varFuncDeclaration(CoreOp.VarOp op) {\n+        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operands().getFirst());\n@@ -523,2 +524,2 @@\n-    public void ret(ReturnOpWrapper op) {\n-        if (!op.op.operands().isEmpty()) {\n+    public void ret(CoreOp.ReturnOp op) {\n+        if (!op.operands().isEmpty()) {\n@@ -533,1 +534,1 @@\n-            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.op.operands().getFirst()).ptxNl();\n+            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.operands().getFirst()).ptxNl();\n@@ -538,1 +539,1 @@\n-    public void javaBreak(JavaBreakOpWrapper op) {\n+    public void javaBreak(JavaOp.BreakOp op) {\n@@ -607,2 +608,2 @@\n-    public PTXHATKernelBuilder resultReg(OpWrapper<?> opWrapper, PTXRegister.Type type) {\n-        return append(addReg(opWrapper.op.result(), type));\n+    public PTXHATKernelBuilder resultReg(Op op, PTXRegister.Type type) {\n+        return append(addReg(op.result(), type));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":101,"deletions":100,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.optools.OpWrapper;\n@@ -101,1 +100,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n+              ampersand().recurse(buildContext, instanceResult.op());\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n@@ -54,1 +52,0 @@\n-\/\/import static hat.ComputeContext.WRAPPER.ESCAPE;\n@@ -97,5 +94,0 @@\n-    static void wrapInvoke(InvokeOpWrapper iow, Block.Builder bldr, ComputeContext.WRAPPER wrapper, Value cc, Value iface) {\n-        bldr.op(JavaOp.invoke(wrapper.pre, cc, iface));\n-        bldr.op(iow.op);\n-        bldr.op(JavaOp.invoke(wrapper.post, cc, iface));\n-    }\n@@ -140,4 +132,0 @@\n-        record PrePost(MethodRef pre, MethodRef post) {\n-            static PrePost access() {\n-                return new PrePost(ACCESS.pre, ACCESS.post);\n-            }\n@@ -145,13 +133,0 @@\n-            static PrePost mutate() {\n-                return new PrePost(MUTATE.pre, MUTATE.post);\n-            }\n-\n-            void apply(Block.Builder bldr, CopyContext bldrCntxt, Value computeContext, InvokeOpWrapper invokeOW) {\n-                if (invokeOW.isIfaceMutator()) {                    \/\/ iface.v(newV)\n-                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n-                    bldr.op(invokeOW.op);                         \/\/ iface.v(newV);\n-                    bldr.op(JavaOp.invoke(MUTATE.post, computeContext, iface));\n-                }\n-            }\n-        }\n@@ -169,27 +144,28 @@\n-            returnFO = OpTk.transformInvokes(lookup,prevFO,(bldr, invokeOW) -> {\n-                CopyContext bldrCntxt = bldr.context();\n-                \/\/Map compute method's first param (computeContext) value to transformed model\n-                Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n-                if (invokeOW.isIfaceMutator()) {                    \/\/ iface.v(newV)\n-                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n-                    bldr.op(invokeOW.op);                         \/\/ iface.v(newV);\n-                    bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n-                } else if (invokeOW.isIfaceAccessor()) {            \/\/ iface.v()\n-                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n-                    bldr.op(invokeOW.op);                         \/\/ iface.v();\n-                    bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n-                } else if (invokeOW.isComputeContextMethod() || invokeOW.isRawKernelCall()) { \/\/dispatchKernel\n-                    bldr.op(invokeOW.op);\n-                } else {\n-                    List<Value> list = invokeOW.op.operands();\n-                 \/\/   System.out.println(\"args \"+list.size());\n-                    if (!list.isEmpty()) {\n-                       \/\/ System.out.println(\"method \"+invokeOW.method());\n-                        Annotation[][] parameterAnnotations = invokeOW.method().getParameterAnnotations();\n-                        boolean isVirtual = list.size()>parameterAnnotations.length;\n-                     \/\/   System.out.println(\"params length\"+parameterAnnotations.length);\n-                        List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n-\n-                            for (int i = isVirtual?1:0; i < list.size(); i++) {\n+            returnFO = prevFO.transform((bldr, op) -> {\n+                if (op instanceof JavaOp.InvokeOp invokeO) {\n+                    CopyContext bldrCntxt = bldr.context();\n+                    \/\/Map compute method's first param (computeContext) value to transformed model\n+                    Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n+                    if (OpTk.isIfaceBufferMethod(lookup, invokeO)) {                    \/\/ iface.v(newV)\n+                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n+                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n+                        bldr.op(invokeO);                         \/\/ iface.v(newV);\n+                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n+                    } else if (OpTk.isIfaceBufferMethod(lookup, invokeO)) {            \/\/ iface.v()\n+                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n+                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n+                        bldr.op(invokeO);                         \/\/ iface.v();\n+                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n+                    } else if (OpTk.isComputeContextMethod(lookup,invokeO) || OpTk.isRawKernelCall(lookup,invokeO)) { \/\/dispatchKernel\n+                        bldr.op(invokeO);\n+                    } else {\n+                        List<Value> list = invokeO.operands();\n+                        \/\/   System.out.println(\"args \"+list.size());\n+                        if (!list.isEmpty()) {\n+                            \/\/ System.out.println(\"method \"+invokeOW.method());\n+                            Annotation[][] parameterAnnotations = OpTk.method(lookup, invokeO).getParameterAnnotations();\n+                            boolean isVirtual = list.size() > parameterAnnotations.length;\n+                            \/\/   System.out.println(\"params length\"+parameterAnnotations.length);\n+                            List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+\n+                            for (int i = isVirtual ? 1 : 0; i < list.size(); i++) {\n@@ -197,1 +173,1 @@\n-                                        parameterAnnotations[i-(isVirtual?1:0)],\n+                                        parameterAnnotations[i - (isVirtual ? 1 : 0)],\n@@ -200,31 +176,22 @@\n-                        List<PrePost> prePosts = new ArrayList<>();\n-                        typeAndAccesses.stream()\n-                                .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n-                                .forEach(typeAndAccess -> {\n-                                     if (typeAndAccess.ro()) {\n-                                         bldr.op(JavaOp.invoke(ACCESS.pre, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n-                                  \/\/   }else if (typeAndAccess.wo()||typeAndAccess.rw()) {\n-                                    \/\/     bldr.op(CoreOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n-                                     }else {\n-                                         bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n-                                     }\n-                                });\n-                        \/\/  invokeOW.op().operands().stream()\n-                        \/\/ .filter(value -> value.type() instanceof JavaType javaType && InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, javaType))\n-                        \/\/  .forEach(value ->\n-                        \/\/          bldr.op(CoreOp.invoke(ESCAPE.pre, cc, bldrCntxt.getValue(value)))\n-                        \/\/  );\n-                        bldr.op(invokeOW.op);\n-                        typeAndAccesses.stream()\n-                                .filter(typeAndAccess -> OpTk.isAssignable(lookup, typeAndAccess.javaType,MappableIface.class))\n-                                .forEach(typeAndAccess -> {\n-                                    if (typeAndAccess.ro()) {\n-                                        bldr.op(JavaOp.invoke(ACCESS.post, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n-                                 \/\/   }else if (typeAndAccess.rw() || typeAndAccess.wo()) {\n-                                 \/\/       bldr.op(CoreOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n-                                    }else {\n-                                        bldr.op(JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n-                                    }\n-                                });\n-                    }else{\n-                        bldr.op(invokeOW.op);\n+                            typeAndAccesses.stream()\n+                                    .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\/\/InvokeOpWrapper.isIfaceUsingLookup(prevFOW.lookup, typeAndAccess.javaType))\n+                                    .forEach(typeAndAccess -> {\n+                                        if (typeAndAccess.ro()) {\n+                                            bldr.op(JavaOp.invoke(ACCESS.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                        } else {\n+                                            bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                        }\n+                                    });\n+                            bldr.op(invokeO);\n+                            typeAndAccesses.stream()\n+                                    .filter(typeAndAccess -> OpTk.isAssignable(lookup, typeAndAccess.javaType, MappableIface.class))\n+                                    .forEach(typeAndAccess -> {\n+                                        if (typeAndAccess.ro()) {\n+                                            bldr.op(JavaOp.invoke(ACCESS.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                        } else {\n+                                            bldr.op(JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                        }\n+                                    });\n+                        } else {\n+                            bldr.op(invokeO);\n+                        }\n@@ -232,0 +199,3 @@\n+                    return bldr;\n+                } else {\n+                    bldr.op(op);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":54,"deletions":84,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.optools.OpWrapper;\n@@ -99,1 +98,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n+              ampersand().recurse(buildContext, instanceResult.op());\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n+\/\/import hat.optools.InvokeOpWrapper;\n@@ -89,5 +88,0 @@\n-    static void wrapInvoke(InvokeOpWrapper iow, Block.Builder bldr, ComputeContext.WRAPPER wrapper, Value cc, Value iface) {\n-        bldr.op(JavaOp.invoke(wrapper.pre, cc, iface));\n-        bldr.op(iow.op);\n-        bldr.op(JavaOp.invoke(wrapper.post, cc, iface));\n-    }\n@@ -104,29 +98,31 @@\n-            returnFO = OpTk.transformInvokes(lookup, prevFO,(bldr, invokeOW) -> {\n-                CopyContext bldrCntxt = bldr.context();\n-                \/\/Map compute method's first param (computeContext) value to transformed model\n-                Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n-                if (invokeOW.isIfaceMutator()) {                    \/\/ iface.v(newV)\n-                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n-                    bldr.op(invokeOW.op);                         \/\/ iface.v(newV);\n-                    bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n-                } else if (invokeOW.isIfaceAccessor()) {            \/\/ iface.v()\n-                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n-                    bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n-                    bldr.op(invokeOW.op);                         \/\/ iface.v();\n-                    bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n-                } else if (invokeOW.isComputeContextMethod() || invokeOW.isRawKernelCall()) { \/\/dispatchKernel\n-                    bldr.op(invokeOW.op);\n-                } else {\n-                    invokeOW.op.operands().stream()\n-                            .filter(val -> val.type() instanceof JavaType javaType &&\n-                                    OpTk.isAssignable(lookup,javaType, MappableIface.class))\n-                                           \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n-                            .forEach(val ->\n-                                    bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(val)))\n-                            );\n-                    bldr.op(invokeOW.op);\n-                    invokeOW.op.operands().stream()\n-                            .filter(val -> val.type() instanceof JavaType javaType &&\n-                                    OpTk.isAssignable(lookup,javaType,MappableIface.class))\n-                                           \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n+            returnFO = prevFO.transform((bldr, op)->{\n+\n+                if (op instanceof JavaOp.InvokeOp invokeO) {\n+                    CopyContext bldrCntxt = bldr.context();\n+                    \/\/Map compute method's first param (computeContext) value to transformed model\n+                    Value cc = bldrCntxt.getValue(paramTable.list().getFirst().parameter);\n+                    if (OpTk.isIfaceMutator(lookup,invokeO)) {                    \/\/ iface.v(newV)\n+                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n+                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n+                        bldr.op(invokeO);                         \/\/ iface.v(newV);\n+                        bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n+                    } else if (OpTk.isIfaceAccessor(lookup,invokeO)) {            \/\/ iface.v()\n+                        Value iface = bldrCntxt.getValue(invokeO.operands().getFirst());\n+                        bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n+                        bldr.op(invokeO);                         \/\/ iface.v();\n+                        bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n+                    } else if (OpTk.isComputeContextMethod(lookup,invokeO) || OpTk.isRawKernelCall(lookup,invokeO)) { \/\/dispatchKernel\n+                        bldr.op(invokeO);\n+                    } else {\n+                        invokeO.operands().stream()\n+                                .filter(val -> val.type() instanceof JavaType javaType &&\n+                                        OpTk.isAssignable(lookup, javaType, MappableIface.class))\n+                                \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n+                                .forEach(val ->\n+                                        bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(val)))\n+                                );\n+                        bldr.op(invokeO);\n+                        invokeO.operands().stream()\n+                                .filter(val -> val.type() instanceof JavaType javaType &&\n+                                        OpTk.isAssignable(lookup, javaType, MappableIface.class))\n+                                \/\/ isIfaceUsingLookup(prevFOW.lookup,javaType))\n@@ -134,3 +130,7 @@\n-                            .forEach(val -> bldr.op(\n-                                    JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(val)))\n-                            );\n+                                .forEach(val -> bldr.op(\n+                                        JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(val)))\n+                                );\n+                    }\n+                    return bldr;\n+                }else{\n+                    bldr.op(op);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import hat.optools.LambdaOpWrapper;\n@@ -36,1 +35,0 @@\n-import hat.optools.OpWrapper;\n@@ -219,1 +217,1 @@\n-        Method method = OpTk.getQuotableTargetInvokeOpWrapper(lookup,lambda).method();\n+        Method method = OpTk.method(lookup,OpTk.getQuotableTargetInvokeOpWrapper(lambda));\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.LambdaOpWrapper;\n@@ -37,1 +35,0 @@\n-import hat.optools.OpWrapper;\n@@ -143,1 +140,1 @@\n-        MethodRef methodRef = OpTk.getQuotableTargetMethodRef(accelerator.lookup,lambdaOp);\n+        MethodRef methodRef =OpTk.getQuotableTargetMethodRef(lambdaOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.optools.InvokeOpWrapper;\n@@ -151,1 +150,1 @@\n-                MethodRef methodRef = InvokeOpWrapper.methodRef(invokeOp);\n+                MethodRef methodRef = OpTk.methodRef(invokeOp);\n@@ -153,2 +152,2 @@\n-                Class<?> javaRefClass = InvokeOpWrapper.javaRefClass(lookup,invokeOp).orElseThrow();\n-                Method invokeWrapperCalledMethod = InvokeOpWrapper.method(lookup,invokeOp);\n+                Class<?> javaRefClass = OpTk.javaRefClass(lookup,invokeOp).orElseThrow();\n+                Method invokeWrapperCalledMethod = OpTk.method(lookup,invokeOp);\n@@ -239,1 +238,1 @@\n-        if (entrypoint.method.getDeclaringClass().equals(InvokeOpWrapper.javaRefClass(computeContext.accelerator.lookup,invokeOp).orElseThrow()) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n+        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClass(computeContext.accelerator.lookup,invokeOp).orElseThrow()) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.optools.FuncOpWrapper;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeEntrypoint.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.InvokeOpWrapper;\n@@ -98,3 +97,3 @@\n-                MethodRef methodRef = InvokeOpWrapper.methodRef(invokeOp);\n-                Class<?> javaRefTypeClass = InvokeOpWrapper.javaRefClass(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp).orElseThrow();\n-                Method invokeOpCalledMethod = InvokeOpWrapper.method(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n+                MethodRef methodRef = OpTk.methodRef(invokeOp);\n+                Class<?> javaRefTypeClass = OpTk.javaRefClass(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp).orElseThrow();\n+                Method invokeOpCalledMethod = OpTk.method(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup,invokeOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.optools.FuncOpWrapper;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-\n-import hat.optools.FuncOpWrapper;\n@@ -30,1 +28,0 @@\n-import hat.optools.StructuralOpWrapper;\n@@ -53,1 +50,1 @@\n-                OpTk.wrappedRootOpStream(buildContext.lookup,funcOp)\n+                OpTk.rootOpStream(buildContext.lookup,funcOp)\n@@ -55,1 +52,1 @@\n-                                recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n+                                recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root)).nl()\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import hat.optools.FuncOpWrapper;\n@@ -36,1 +35,0 @@\n-import hat.optools.StructuralOpWrapper;\n@@ -201,2 +199,2 @@\n-                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                StreamCounter.of(OpTk.rootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n+                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -223,2 +221,2 @@\n-                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                StreamCounter.of(OpTk.rootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n+                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -255,2 +253,2 @@\n-                StreamCounter.of(OpTk.wrappedRootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                StreamCounter.of(OpTk.rootOpStream(buildContext.lookup,buildContext.funcOp), (c, root) ->\n+                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,26 +28,2 @@\n-import hat.optools.BinaryArithmeticOrLogicOperation;\n-import hat.optools.BinaryTestOpWrapper;\n-import hat.optools.ConstantOpWrapper;\n-import hat.optools.ConvOpWrapper;\n-import hat.optools.FieldLoadOpWrapper;\n-import hat.optools.FieldStoreOpWrapper;\n-import hat.optools.ForOpWrapper;\n-import hat.optools.FuncCallOpWrapper;\n-import hat.optools.IfOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.JavaBreakOpWrapper;\n-import hat.optools.JavaContinueOpWrapper;\n-import hat.optools.JavaLabeledOpWrapper;\n-import hat.optools.LambdaOpWrapper;\n-import hat.optools.LogicalOpWrapper;\n-import hat.optools.OpWrapper;\n-import hat.optools.ReturnOpWrapper;\n-import hat.optools.TernaryOpWrapper;\n-import hat.optools.TupleOpWrapper;\n-import hat.optools.UnaryArithmeticOrLogicOpWrapper;\n-import hat.optools.VarDeclarationOpWrapper;\n-import hat.optools.VarFuncDeclarationOpWrapper;\n-import hat.optools.VarLoadOpWrapper;\n-import hat.optools.VarStoreOpWrapper;\n-import hat.optools.WhileOpWrapper;\n-import hat.optools.YieldOpWrapper;\n+import hat.optools.OpTk;\n+\/\/import hat.optools.UnaryArithmeticOrLogicOpWrapper;\n@@ -282,1 +258,1 @@\n-         T varLoad(HATCodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper);\n+         T varLoad(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp);\n@@ -284,1 +260,1 @@\n-         T varStore(HATCodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper);\n+         T varStore(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp);\n@@ -286,1 +262,0 @@\n-        \/\/ public T var(BuildContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) ;\n@@ -288,1 +263,1 @@\n-         T varDeclaration(HATCodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper);\n+         T varDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n@@ -290,1 +265,1 @@\n-         T varFuncDeclaration(HATCodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper);\n+         T varFuncDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp);\n@@ -292,1 +267,1 @@\n-         T fieldLoad(HATCodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper);\n+         T fieldLoad(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n@@ -294,1 +269,1 @@\n-         T fieldStore(HATCodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper);\n+         T fieldStore(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp);\n@@ -296,1 +271,1 @@\n-        T unaryOperation(HATCodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper);\n+        T unaryOperation(HATCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp);\n@@ -299,1 +274,1 @@\n-        T binaryOperation(HATCodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper);\n+        T binaryOperation(HATCodeBuilderContext buildContext, Op binaryOp);\n@@ -301,1 +276,1 @@\n-        T logical(HATCodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper);\n+        T logical(HATCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp);\n@@ -303,1 +278,1 @@\n-        T binaryTest(HATCodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper);\n+        T binaryTest(HATCodeBuilderContext buildContext, Op binaryTestOp);\n@@ -305,1 +280,1 @@\n-        T conv(HATCodeBuilderContext buildContext, ConvOpWrapper convOpWrapper);\n+        T conv(HATCodeBuilderContext buildContext, JavaOp.ConvOp convOp);\n@@ -308,1 +283,1 @@\n-        T constant(HATCodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper);\n+        T constant(HATCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp);\n@@ -310,1 +285,1 @@\n-        T javaYield(HATCodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper);\n+        T javaYield(HATCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp);\n@@ -312,1 +287,1 @@\n-        T lambda(HATCodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper);\n+        T lambda(HATCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp);\n@@ -314,1 +289,1 @@\n-        T tuple(HATCodeBuilderContext buildContext, TupleOpWrapper lambdaOpWrapper);\n+        T tuple(HATCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp);\n@@ -316,1 +291,1 @@\n-        T funcCall(HATCodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper);\n+        T funcCall(HATCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp);\n@@ -320,1 +295,1 @@\n-        T javaWhile(HATCodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper);\n+        T javaWhile(HATCodeBuilderContext buildContext, JavaOp.WhileOp whileOp);\n@@ -322,1 +297,1 @@\n-        T javaLabeled(HATCodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapperOp);\n+        T javaLabeled(HATCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp);\n@@ -324,1 +299,1 @@\n-        T javaContinue(HATCodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper);\n+        T javaContinue(HATCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp);\n@@ -326,1 +301,1 @@\n-        T javaBreak(HATCodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper);\n+        T javaBreak(HATCodeBuilderContext buildContext, JavaOp.BreakOp breakOp);\n@@ -331,1 +306,1 @@\n-         T methodCall(HATCodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper);\n+         T methodCall(HATCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp);\n@@ -333,5 +308,1 @@\n-         T ternary(HATCodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper);\n-\n-         T parencedence(HATCodeBuilderContext buildContext, Op parent, OpWrapper<?> child);\n-\n-         T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n+         T ternary(HATCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp);\n@@ -341,32 +312,39 @@\n-         T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, Op child);\n-\n-         T ret(HATCodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper);\n-\n-        default T recurse(HATCodeBuilderContext buildContext, OpWrapper<?> wrappedOp) {\n-            switch (wrappedOp) {\n-                case VarLoadOpWrapper $ -> varLoad(buildContext, $);\n-                case VarStoreOpWrapper $ -> varStore(buildContext, $);\n-                case FieldLoadOpWrapper $ -> fieldLoad(buildContext, $);\n-                case FieldStoreOpWrapper $ -> fieldStore(buildContext, $);\n-                case BinaryArithmeticOrLogicOperation $ -> binaryOperation(buildContext, $);\n-                case UnaryArithmeticOrLogicOpWrapper $ -> unaryOperation(buildContext, $);\n-                case BinaryTestOpWrapper $ -> binaryTest(buildContext, $);\n-                case ConvOpWrapper $ -> conv(buildContext, $);\n-                case ConstantOpWrapper $ -> constant(buildContext, $);\n-                case YieldOpWrapper $ -> javaYield(buildContext, $);\n-                case FuncCallOpWrapper $ -> funcCall(buildContext, $);\n-                case LogicalOpWrapper $ -> logical(buildContext, $);\n-                case InvokeOpWrapper $ -> methodCall(buildContext, $);\n-                case TernaryOpWrapper $ -> ternary(buildContext, $);\n-                case VarDeclarationOpWrapper $ -> varDeclaration(buildContext, $);\n-                case VarFuncDeclarationOpWrapper $ -> varFuncDeclaration(buildContext, $);\n-                case LambdaOpWrapper $ -> lambda(buildContext, $);\n-                case TupleOpWrapper $ -> tuple(buildContext, $);\n-                case WhileOpWrapper $ -> javaWhile(buildContext, $);\n-                case IfOpWrapper $ -> javaIf(buildContext, $.op);\n-                case ForOpWrapper $ -> javaFor(buildContext, $.op);\n-                case ReturnOpWrapper $ -> ret(buildContext, $);\n-                case JavaLabeledOpWrapper $ -> javaLabeled(buildContext, $);\n-                case JavaBreakOpWrapper $ -> javaBreak(buildContext, $);\n-                case JavaContinueOpWrapper $ -> javaContinue(buildContext, $);\n-                default -> throw new IllegalStateException(\"handle nesting of op \" + wrappedOp.op);\n+       \/\/  T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n+\n+        \/\/ T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child);\n+\n+        \/\/ T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child);\n+\n+         T ret(HATCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp);\n+\n+        default T recurse(HATCodeBuilderContext buildContext, Op op) {\n+            switch (op) {\n+                case CoreOp.VarAccessOp.VarLoadOp $ -> varLoad(buildContext, $);\n+                case CoreOp.VarAccessOp.VarStoreOp $ -> varStore(buildContext, $);\n+                case JavaOp.FieldAccessOp.FieldLoadOp $ -> fieldLoad(buildContext, $);\n+                case JavaOp.FieldAccessOp.FieldStoreOp $ -> fieldStore(buildContext, $);\n+\n+\n+\n+                case JavaOp.ConvOp $ -> conv(buildContext, $);\n+                case CoreOp.ConstantOp $ -> constant(buildContext, $);\n+                case CoreOp.YieldOp $ -> javaYield(buildContext, $);\n+                case CoreOp.FuncCallOp $ -> funcCall(buildContext, $);\n+                case JavaOp.InvokeOp $ -> methodCall(buildContext, $);\n+                case JavaOp.ConditionalExpressionOp $ -> ternary(buildContext, $);\n+                case CoreOp.VarOp $ when OpTk.paramVar($) != null -> varFuncDeclaration(buildContext, $);\n+                case CoreOp.VarOp $ -> varDeclaration(buildContext, $);\n+                case JavaOp.LambdaOp $ -> lambda(buildContext, $);\n+                case CoreOp.TupleOp $ -> tuple(buildContext, $);\n+                case JavaOp.WhileOp $ -> javaWhile(buildContext, $);\n+                case JavaOp.IfOp $ -> javaIf(buildContext, $);\n+                case JavaOp.ForOp $ -> javaFor(buildContext, $);\n+                case CoreOp.ReturnOp $ -> ret(buildContext, $);\n+                case JavaOp.LabeledOp $ -> javaLabeled(buildContext, $);\n+                case JavaOp.BreakOp $ -> javaBreak(buildContext, $);\n+                case JavaOp.ContinueOp $ -> javaContinue(buildContext, $);\n+                case JavaOp.BinaryTestOp $ -> binaryTest(buildContext, $);\n+                case JavaOp.BinaryOp $ -> binaryOperation(buildContext, $);\n+                case JavaOp.JavaConditionalOp $ -> logical(buildContext, $);\n+                \/\/ case UnaryArithmeticOrLogicOpWrapper $ -> unaryOperation(buildContext, $);\n+                default -> throw new IllegalStateException(\"handle nesting of op \" + op);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":63,"deletions":85,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import hat.optools.ForOpWrapper;\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.IfOpWrapper;\n@@ -31,2 +28,0 @@\n-import hat.optools.OpWrapper;\n-import hat.optools.WhileOpWrapper;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,15 +31,0 @@\n-import hat.optools.BinaryArithmeticOrLogicOperation;\n-import hat.optools.BinaryTestOpWrapper;\n-import hat.optools.ConstantOpWrapper;\n-import hat.optools.ConvOpWrapper;\n-import hat.optools.FieldLoadOpWrapper;\n-import hat.optools.FieldStoreOpWrapper;\n-import hat.optools.ForOpWrapper;\n-import hat.optools.FuncCallOpWrapper;\n-import hat.optools.IfOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.JavaBreakOpWrapper;\n-import hat.optools.JavaContinueOpWrapper;\n-import hat.optools.JavaLabeledOpWrapper;\n-import hat.optools.LambdaOpWrapper;\n-import hat.optools.LogicalOpWrapper;\n@@ -47,13 +32,0 @@\n-import hat.optools.OpWrapper;\n-import hat.optools.ReturnOpWrapper;\n-import hat.optools.RootSet;\n-import hat.optools.StructuralOpWrapper;\n-import hat.optools.TernaryOpWrapper;\n-import hat.optools.TupleOpWrapper;\n-import hat.optools.UnaryArithmeticOrLogicOpWrapper;\n-import hat.optools.VarDeclarationOpWrapper;\n-import hat.optools.VarFuncDeclarationOpWrapper;\n-import hat.optools.VarLoadOpWrapper;\n-import hat.optools.VarStoreOpWrapper;\n-import hat.optools.WhileOpWrapper;\n-import hat.optools.YieldOpWrapper;\n@@ -164,2 +136,2 @@\n-    public T varLoad(HATCodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper) {\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varAccessOpWrapper.op.operands().getFirst());\n+    public T varLoad(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        CoreOp.VarOp varOp = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n@@ -171,2 +143,2 @@\n-    public T varStore(HATCodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper) {\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varAccessOpWrapper.op.operands().getFirst());\n+    public T varStore(HATCodeBuilderContext buildContext, CoreOp.VarAccessOp.VarStoreOp varStoreOp) {\n+        CoreOp.VarOp varOp = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n@@ -174,1 +146,1 @@\n-        parencedence(buildContext, varAccessOpWrapper, ((Op.Result)varAccessOpWrapper.op.operands().get(1)).op());\n+        parencedence(buildContext, varStoreOp, ((Op.Result)varStoreOp.operands().get(1)).op());\n@@ -179,2 +151,2 @@\n-    public T varDeclaration(HATCodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) {\n-        if (varDeclarationOpWrapper.op.isUninitialized()) {\n+    public T varDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n+        if (varOp.isUninitialized()) {\n@@ -182,1 +154,1 @@\n-            type(buildContext, OpTk.javaType(varDeclarationOpWrapper.op)).space().identifier(OpTk.varName(varDeclarationOpWrapper.op));\n+            type(buildContext, OpTk.javaType(varOp)).space().identifier(OpTk.varName(varOp));\n@@ -184,2 +156,2 @@\n-            type(buildContext, OpTk.javaType(varDeclarationOpWrapper.op)).space().identifier(OpTk.varName(varDeclarationOpWrapper.op)).space().equals().space();\n-            parencedence(buildContext, varDeclarationOpWrapper, ((Op.Result)varDeclarationOpWrapper.op.operands().getFirst()).op());\n+            type(buildContext, OpTk.javaType(varOp)).space().identifier(OpTk.varName(varOp)).space().equals().space();\n+            parencedence(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n@@ -191,1 +163,1 @@\n-    public T varFuncDeclaration(HATCodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper) {\n+    public T varFuncDeclaration(HATCodeBuilderContext buildContext, CoreOp.VarOp varOp) {\n@@ -197,5 +169,5 @@\n-    public T fieldLoad(HATCodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n-        if (OpTk.isKernelContextAccess(fieldLoadOpWrapper.op)) {\n-            identifier(\"kc\").rarrow().identifier(OpTk.fieldName(fieldLoadOpWrapper.op));\n-        } else if (fieldLoadOpWrapper.op.operands().isEmpty() && fieldLoadOpWrapper.op.result().type() instanceof PrimitiveType) {\n-            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOpWrapper.op);\n+    public T fieldLoad(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n+            identifier(\"kc\").rarrow().identifier(OpTk.fieldName(fieldLoadOp));\n+        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n+            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n@@ -204,1 +176,1 @@\n-            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOpWrapper.op);\n+            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp);\n@@ -211,2 +183,2 @@\n-    public T fieldStore(HATCodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper) {\n-        \/\/throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOpWrapper.fieldRef());\n+    public T fieldStore(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldStoreOp fieldStoreOp) {\n+      \/\/  throw new IllegalStateException(\"What is this field store ?\" + fieldStoreOp);\n@@ -245,4 +217,3 @@\n-    public T unaryOperation(HATCodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper) {\n-      \/\/  parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.lhsAsOp());\n-        symbol(unaryOperatorOpWrapper.op);\n-        parencedence(buildContext, unaryOperatorOpWrapper.op, ((Op.Result)unaryOperatorOpWrapper.op.operands().getFirst()).op());\n+    public T unaryOperation(HATCodeBuilderContext buildContext, JavaOp.UnaryOp unaryOp) {\n+        symbol(unaryOp);\n+        parencedence(buildContext, unaryOp, ((Op.Result)unaryOp.operands().getFirst()).op());\n@@ -253,4 +224,4 @@\n-    public T binaryOperation(HATCodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper) {\n-        parencedence(buildContext, binaryOperatorOpWrapper.op, OpTk.lhsAsOp(binaryOperatorOpWrapper.op));\n-        symbol(binaryOperatorOpWrapper.op);\n-        parencedence(buildContext, binaryOperatorOpWrapper.op, OpTk.rhsAsOp(binaryOperatorOpWrapper.op));\n+    public T binaryOperation(HATCodeBuilderContext buildContext, Op binaryOp) {\n+        parencedence(buildContext, binaryOp, OpTk.lhsAsOp(binaryOp));\n+        symbol(binaryOp);\n+        parencedence(buildContext, binaryOp, OpTk.rhsAsOp(binaryOp));\n@@ -261,8 +232,4 @@\n-    public T logical(HATCodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper) {\n-        OpTk.lhsWrappedYieldOpStream(buildContext.lookup,logicalOpWrapper.op).forEach((wrapped) -> {\n-            recurse(buildContext, wrapped);\n-        });\n-        space().symbol(logicalOpWrapper.op).space();\n-        OpTk.rhsWrappedYieldOpStream(buildContext.lookup,logicalOpWrapper.op).forEach((wrapped) -> {\n-            recurse(buildContext, wrapped);\n-        });\n+    public T logical(HATCodeBuilderContext buildContext, JavaOp.JavaConditionalOp logicalOp) {\n+        OpTk.lhsYieldOpStream(logicalOp).forEach(o ->  recurse(buildContext, o));\n+        space().symbol(logicalOp).space();\n+        OpTk.rhsYieldOpStream(logicalOp).forEach(o-> recurse(buildContext, o));\n@@ -273,4 +240,4 @@\n-    public T binaryTest(HATCodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper) {\n-        parencedence(buildContext, binaryTestOpWrapper.op, OpTk.lhsAsOp(binaryTestOpWrapper.op));\n-        symbol(binaryTestOpWrapper.op);\n-        parencedence(buildContext, binaryTestOpWrapper.op, OpTk.rhsAsOp(binaryTestOpWrapper.op));\n+    public T binaryTest(HATCodeBuilderContext buildContext, Op binaryTestOp) {\n+        parencedence(buildContext, binaryTestOp, OpTk.lhsAsOp(binaryTestOp));\n+        symbol(binaryTestOp);\n+        parencedence(buildContext, binaryTestOp, OpTk.rhsAsOp(binaryTestOp));\n@@ -281,4 +248,3 @@\n-\n-    public T conv(HATCodeBuilderContext buildContext, ConvOpWrapper convOpWrapper) {\n-        if (convOpWrapper.op.resultType() == JavaType.DOUBLE) {\n-            paren(_ -> type(buildContext,JavaType.FLOAT));\n+    public T conv(HATCodeBuilderContext buildContext, JavaOp.ConvOp convOp) {\n+        if (convOp.resultType() == JavaType.DOUBLE) {\n+            paren(_ -> type(buildContext,JavaType.FLOAT)); \/\/ why double to float?\n@@ -286,1 +252,1 @@\n-            paren(_ -> type(buildContext,(JavaType)convOpWrapper.op.resultType()));\n+            paren(_ -> type(buildContext,(JavaType)convOp.resultType()));\n@@ -288,1 +254,1 @@\n-        parencedence(buildContext, convOpWrapper, ((Op.Result)convOpWrapper.op.operands().getFirst()).op());\n+        parencedence(buildContext, convOp, ((Op.Result)convOp.operands().getFirst()).op());\n@@ -293,2 +259,2 @@\n-    public T constant(HATCodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper) {\n-        Object object = constantOpWrapper.op.value();\n+    public T constant(HATCodeBuilderContext buildContext, CoreOp.ConstantOp constantOp) {\n+        Object object = constantOp.value();\n@@ -298,1 +264,1 @@\n-            literal(constantOpWrapper.op.value().toString());\n+            literal(constantOp.value().toString());\n@@ -304,3 +270,3 @@\n-    public T javaYield(HATCodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper) {\n-        if (yieldOpWrapper.op.operands().getFirst() instanceof Op.Result result) {\n-            recurse(buildContext, OpWrapper.wrap(buildContext.lookup, result.op()));\n+    public T javaYield(HATCodeBuilderContext buildContext, CoreOp.YieldOp yieldOp) {\n+        if (yieldOp.operands().getFirst() instanceof Op.Result result) {\n+            recurse(buildContext, result.op());\n@@ -312,1 +278,1 @@\n-    public T lambda(HATCodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper) {\n+    public T lambda(HATCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n@@ -317,2 +283,2 @@\n-    public T tuple(HATCodeBuilderContext buildContext, TupleOpWrapper tupleOpWrapper) {\n-        StreamCounter.of(tupleOpWrapper.op.operands(), (c, operand) -> {\n+    public T tuple(HATCodeBuilderContext buildContext, CoreOp.TupleOp tupleOp) {\n+        StreamCounter.of(tupleOp.operands(), (c, operand) -> {\n@@ -323,1 +289,1 @@\n-                recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result.op()));\n+                recurse(buildContext, result.op());\n@@ -332,2 +298,2 @@\n-    public T funcCall(HATCodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper) {\n-          identifier(funcCallOpWrapper.op.funcName());\n+    public T funcCall(HATCodeBuilderContext buildContext, CoreOp.FuncCallOp funcCallOp) {\n+          identifier(funcCallOp.funcName());\n@@ -335,1 +301,1 @@\n-            commaSeparated(funcCallOpWrapper.op.operands(), (e) -> {\n+            commaSeparated(funcCallOp.operands(), (e) -> {\n@@ -337,1 +303,1 @@\n-                    parencedence(buildContext, funcCallOpWrapper, result.op());\n+                    parencedence(buildContext, funcCallOp, result.op());\n@@ -347,3 +313,3 @@\n-    public T javaLabeled(HATCodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapper) {\n-        var labelNameOp = OpWrapper.wrap(buildContext.lookup,javaLabeledOpWrapper.op.bodies().getFirst().entryBlock().ops().getFirst());\n-        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp.op;\n+    public T javaLabeled(HATCodeBuilderContext buildContext, JavaOp.LabeledOp labeledOp) {\n+        var labelNameOp = labeledOp.bodies().getFirst().entryBlock().ops().getFirst();\n+        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp;\n@@ -351,3 +317,2 @@\n-        var forLoopOp = javaLabeledOpWrapper.op.bodies().getFirst().entryBlock().ops().get(1);\n-        recurse(buildContext, OpWrapper.wrap(buildContext.lookup,forLoopOp));\n-        \/\/ var yieldOp = javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(2);\n+        var forLoopOp = labeledOp.bodies().getFirst().entryBlock().ops().get(1);\n+        recurse(buildContext,forLoopOp);\n@@ -357,1 +322,1 @@\n-    public T javaBreak(HATCodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper) {\n+    public T javaBreak(HATCodeBuilderContext buildContext, JavaOp.BreakOp breakOp) {\n@@ -359,1 +324,1 @@\n-        if (!javaBreakOpWrapper.op.operands().isEmpty() && javaBreakOpWrapper.op.operands().getFirst() instanceof Op.Result result) {\n+        if (!breakOp.operands().isEmpty() && breakOp.operands().getFirst() instanceof Op.Result result) {\n@@ -368,3 +333,3 @@\n-    public T javaContinue(HATCodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper) {\n-        if (!javaContinueOpWrapper.op.operands().isEmpty()\n-                && javaContinueOpWrapper.op.operands().getFirst() instanceof Op.Result result\n+    public T javaContinue(HATCodeBuilderContext buildContext, JavaOp.ContinueOp continueOp) {\n+        if (!continueOp.operands().isEmpty()\n+                && continueOp.operands().getFirst() instanceof Op.Result result\n@@ -394,5 +359,2 @@\n-                                StreamCounter.of(RootSet.rootsWithoutVarFuncDeclarationsOrYields(buildContext.lookup,\n-                                        ifOp.bodies().get(c.value()).entryBlock())\n-                                        , (innerc, root) ->\n-                                        nlIf(innerc.isNotFirst())\n-                                                .recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                                StreamCounter.of(OpTk.rootsExcludingVarFuncDeclarationsAndYields(ifOp.bodies().get(c.value()).entryBlock()), (innerc, root) ->\n+                                        nlIf(innerc.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -411,3 +373,1 @@\n-                                    .forEach((yield) ->\n-                                            recurse(buildContext, OpWrapper.wrap(buildContext.lookup,yield))\n-                                    )\n+                                    .forEach((yield) -> recurse(buildContext, yield))\n@@ -423,1 +383,1 @@\n-    public T javaWhile(HATCodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper) {\n+    public T javaWhile(HATCodeBuilderContext buildContext, JavaOp.WhileOp whileOp) {\n@@ -425,1 +385,1 @@\n-                OpTk.conditionWrappedYieldOpStream(buildContext.lookup,whileOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped))\n+                OpTk.conditionYieldOpStream(whileOp).forEach(o -> recurse(buildContext, o))\n@@ -427,2 +387,2 @@\n-                StreamCounter.of(OpTk.loopWrappedRootOpStream(buildContext.lookup,whileOpWrapper.op), (c, root) ->\n-                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                StreamCounter.of(OpTk.loopRootOpStream(buildContext.lookup,whileOp), (c, root) ->\n+                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -438,1 +398,1 @@\n-                    OpTk.initWrappedYieldOpStream(buildContext.lookup,forOp).forEach((wrapped) -> recurse(buildContext, wrapped));\n+                    OpTk.initYieldOpStream(forOp).forEach(o -> recurse(buildContext, o));\n@@ -440,1 +400,1 @@\n-                    OpTk.conditionWrappedYieldOpStream(buildContext.lookup,forOp).forEach((wrapped) -> recurse(buildContext, wrapped));\n+                    OpTk.conditionYieldOpStream(forOp).forEach(o -> recurse(buildContext, o));\n@@ -442,1 +402,1 @@\n-                    StreamCounter.of(OpTk.mutateRootWrappedOpStream(buildContext.lookup,forOp), (c, wrapped) ->\n+                    StreamCounter.of(OpTk.mutateRootOpStream(buildContext.lookup,forOp), (c, wrapped) ->\n@@ -446,2 +406,2 @@\n-                        StreamCounter.of(OpTk.loopWrappedRootOpStream(buildContext.lookup,forOp), (c, root) ->\n-                                nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                        StreamCounter.of(OpTk.loopRootOpStream(buildContext.lookup,forOp), (c, root) ->\n+                                nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -539,2 +499,2 @@\n-    public T methodCall(HATCodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n-        var name = invokeOpWrapper.name();\n+    public T methodCall(HATCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        var name = invokeOp.invokeDescriptor().name();\/\/OpTk.name(invokeOp);\n@@ -542,3 +502,3 @@\n-        if (invokeOpWrapper.isIfaceBufferMethod()) {\n-            var operandCount = invokeOpWrapper.op.operands().size();\n-            var returnType = invokeOpWrapper.javaReturnType();\n+        if (OpTk.isIfaceBufferMethod(buildContext.lookup,invokeOp)) {\n+            var operandCount = invokeOp.operands().size();\n+            var returnType = OpTk.javaReturnType(invokeOp);\n@@ -549,1 +509,1 @@\n-                if (invokeOpWrapper.op.operands().getFirst() instanceof Op.Result instanceResult) {\n+                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -559,1 +519,1 @@\n-                if (invokeOpWrapper.op.operands().getFirst() instanceof Op.Result instanceResult) {\n+                if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -606,1 +566,1 @@\n-                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n+                    recurse(buildContext, instanceResult.op());\n@@ -615,2 +575,2 @@\n-                                if (invokeOpWrapper.op.operands().get(1) instanceof Op.Result result1) {\n-                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result1.op()));\n+                                if (invokeOp.operands().get(1) instanceof Op.Result result1) {\n+                                    equals().recurse(buildContext, result1.op());\n@@ -623,4 +583,4 @@\n-                                if (invokeOpWrapper.op.operands().get(1) instanceof Op.Result result1\n-                                        && invokeOpWrapper.op.operands().get(2) instanceof Op.Result result2) {\n-                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result1.op())));\n-                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result2.op()));\n+                                if (invokeOp.operands().get(1) instanceof Op.Result result1\n+                                        && invokeOp.operands().get(2) instanceof Op.Result result2) {\n+                                    sbrace(_ -> recurse(buildContext, result1.op()));\n+                                    equals().recurse(buildContext, result2.op());\n@@ -637,3 +597,2 @@\n-                        if (invokeOpWrapper.op.operands().size()>1 && invokeOpWrapper.op.operands().get(1) instanceof Op.Result result1) {\n-                            var rhs = OpWrapper.wrap(buildContext.lookup,result1.op());\n-                            sbrace(_ -> recurse(buildContext, rhs));\n+                        if (invokeOp.operands().size()>1 && invokeOp.operands().get(1) instanceof Op.Result result1) {\n+                            sbrace(_ -> recurse(buildContext, result1.op()));\n@@ -651,1 +610,1 @@\n-                    commaSeparated(invokeOpWrapper.op.operands(), (op) -> {\n+                    commaSeparated(invokeOp.operands(), (op) -> {\n@@ -653,1 +612,1 @@\n-                            recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result.op()));\n+                            recurse(buildContext, result.op());\n@@ -664,2 +623,2 @@\n-    public T ternary(HATCodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper) {\n-        OpTk.conditionWrappedYieldOpStream(buildContext.lookup,ternaryOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n+    public T ternary(HATCodeBuilderContext buildContext, JavaOp.ConditionalExpressionOp ternaryOp) {\n+        OpTk.conditionYieldOpStream(ternaryOp).forEach(o -> recurse(buildContext, o));\n@@ -667,1 +626,1 @@\n-        OpTk.thenWrappedYieldOpStream(buildContext.lookup,ternaryOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n+        OpTk.thenYieldOpStream(ternaryOp).forEach(o -> recurse(buildContext, o));\n@@ -669,1 +628,1 @@\n-        OpTk.elseWrappedYieldOpStream(buildContext.lookup,ternaryOpWrapper.op).forEach((wrapped) -> recurse(buildContext, wrapped));\n+        OpTk.elseYieldOpStream(ternaryOp).forEach(o -> recurse(buildContext, o));\n@@ -681,1 +640,1 @@\n-    @Override\n+  \/*  @Override\n@@ -689,1 +648,1 @@\n-    }\n+    } *\/\n@@ -693,1 +652,1 @@\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup,child)));\n+        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, child));\n@@ -696,1 +655,1 @@\n-    @Override\n+  \/*  @Override\n@@ -698,2 +657,2 @@\n-        return parenWhen(precedenceOf(parent.op) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup,child)));\n-    }\n+        return parenWhen(precedenceOf(parent.op) < precedenceOf(child), _ -> recurse(buildContext, child));\n+    } *\/\n@@ -703,1 +662,1 @@\n-    public T ret(HATCodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper) {\n+    public T ret(HATCodeBuilderContext buildContext, CoreOp.ReturnOp returnOp) {\n@@ -705,2 +664,2 @@\n-        if (!returnOpWrapper.op.operands().isEmpty()) {\n-            space().parencedence(buildContext, returnOpWrapper, ((Op.Result)returnOpWrapper.op.operands().getFirst()).op());\n+        if (!returnOp.operands().isEmpty()) {\n+            space().parencedence(buildContext, returnOp, ((Op.Result)returnOp.operands().getFirst()).op());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":106,"deletions":147,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class BinaryArithmeticOrLogicOperation extends BinaryOpWrapper<JavaOp.BinaryOp> {\n-    BinaryArithmeticOrLogicOperation(  JavaOp.BinaryOp op) {\n-        super( op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class BinaryLogicalOpWrapper extends BinaryOpWrapper<JavaOp.BinaryOp> {\n-    BinaryLogicalOpWrapper( JavaOp.BinaryOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Op;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public abstract class BinaryOpWrapper<T extends Op> extends OpWrapper<T> {\n-    BinaryOpWrapper(T op) {\n-        super( op);\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class BinaryTestOpWrapper extends BinaryOpWrapper<JavaOp.BinaryTestOp> {\n-    BinaryTestOpWrapper( JavaOp.BinaryTestOp op) {\n-        super( op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.CodeElement;\n-\n-public abstract class CodeElementWrapper<T extends CodeElement> {\n-    protected T codeElement;\n-\n-    CodeElementWrapper(T codeElement) {\n-        this.codeElement = codeElement;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/CodeElementWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class ConstantOpWrapper extends UnaryOpWrapper<CoreOp.ConstantOp> {\n-    ConstantOpWrapper( CoreOp.ConstantOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class ConvOpWrapper extends UnaryOpWrapper<JavaOp.ConvOp> {\n-    public ConvOpWrapper( JavaOp.ConvOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-public abstract class FieldAccessOpWrapper<T extends JavaOp.FieldAccessOp> extends OpWrapper<T> {\n-    FieldAccessOpWrapper( T op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class FieldLoadOpWrapper extends FieldAccessOpWrapper<JavaOp.FieldAccessOp.FieldLoadOp> implements LoadOpWrapper {\n-    FieldLoadOpWrapper( JavaOp.FieldAccessOp.FieldLoadOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.FieldRef;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class FieldStoreOpWrapper extends FieldAccessOpWrapper<JavaOp.FieldAccessOp.FieldStoreOp> implements StoreOpWrapper {\n-    FieldStoreOpWrapper( JavaOp.FieldAccessOp.FieldStoreOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.stream.Stream;\n-\n-public class ForOpWrapper extends LoopOpWrapper<JavaOp.ForOp> {\n-    ForOpWrapper(JavaOp.ForOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class FuncCallOpWrapper extends OpWrapper<CoreOp.FuncCallOp> {\n-    public FuncCallOpWrapper( CoreOp.FuncCallOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class FuncOpWrapper extends OpWrapper<CoreOp.FuncOp> {\n-    public final OpTk.ParamTable paramTable;\n-    public final MethodHandles.Lookup lookup;\n-    public FuncOpWrapper(MethodHandles.Lookup lookup,CoreOp.FuncOp op) {\n-        super(op);\n-        this.lookup=lookup;\n-        this.paramTable = new OpTk.ParamTable(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class IfOpWrapper extends StructuralOpWrapper<JavaOp.IfOp> {\n-   \/\/public MethodHandles.Lookup lookup;\n-    public IfOpWrapper(\n-            \/\/MethodHandles.Lookup lookup,\n-            JavaOp.IfOp op) {\n-        super(op);\n-     \/\/   this.lookup = lookup;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.ComputeContext;\n-import hat.buffer.Buffer;\n-import hat.buffer.KernelContext;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-\n-import hat.ifacemapper.MappableIface;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-\n-import java.util.Optional;\n-\n-public class InvokeOpWrapper extends OpWrapper<JavaOp.InvokeOp> {\n-\n-     final public MethodHandles.Lookup lookup;\n-    public InvokeOpWrapper( MethodHandles.Lookup lookup,JavaOp.InvokeOp op) {\n-        super(op);\n-        this.lookup=lookup;\n-    }\n-    public static  MethodRef methodRef(JavaOp.InvokeOp op) {\n-        return op.invokeDescriptor();\n-    }\n-\n-    public static JavaType javaRefType(JavaOp.InvokeOp op) {\n-        return (JavaType) methodRef(op).refType();\n-    }\n-\n-\n-    public MethodRef methodRef() {\n-        return methodRef(op);\n-    }\n-\n-    public JavaType javaRefType() {\n-        return javaRefType(op);\n-    }\n-    public static  boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return  OpTk.isAssignable(lookup,javaRefType(invokeOp), MappableIface.class) ;\n-    }\n-    public boolean isIfaceBufferMethod() {\n-        return  OpTk.isAssignable(lookup,javaRefType(), MappableIface.class) ;\n-    }\n-\n-    public boolean isRawKernelCall() {\n-        return (op.operands().size() > 1 && op.operands().getFirst() instanceof Value value\n-                && value.type() instanceof JavaType javaType\n-                && (OpTk.isAssignable(lookup,javaType, hat.KernelContext.class) || OpTk.isAssignable(lookup,javaType, KernelContext.class))\n-        );\n-    }\n-\n-    public boolean isComputeContextMethod() {\n-        return OpTk.isAssignable(lookup,javaRefType(), ComputeContext.class);\n-    }\n-\n-    public static JavaType javaReturnType(JavaOp.InvokeOp op) {\n-        return (JavaType) methodRef(op).type().returnType();\n-    }\n-\n-    public JavaType javaReturnType() {\n-        return javaReturnType(op);\n-    }\n-\n-    public static Method method(MethodHandles.Lookup lookup,JavaOp.InvokeOp op ) {\n-        try {\n-            return methodRef(op).resolveToMethod(lookup, op.invokeKind());\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public Method method() {\n-        return method(lookup,op);\n-    }\n-\n-\n-    public enum IfaceBufferAccess {None, Access, Mutate}\n-\n-    public boolean isIfaceAccessor() {\n-        if (isIfaceBufferMethod() && !javaReturnType().equals(JavaType.VOID)) {\n-            Optional<Class<?>> optionalClazz = javaReturnClass();\n-            return optionalClazz.isPresent() && Buffer.class.isAssignableFrom(optionalClazz.get());\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-\n-    public boolean isIfaceMutator() {\n-        return isIfaceBufferMethod() && javaReturnType().equals(JavaType.VOID);\n-    }\n-\n-    public IfaceBufferAccess getIfaceBufferAccess() {\n-        return isIfaceAccessor() ? IfaceBufferAccess.Access : isIfaceMutator() ? IfaceBufferAccess.Mutate : IfaceBufferAccess.None;\n-    }\n-\n-    public String name() {\n-        return op.invokeDescriptor().name();\n-    }\n-\n-    public static Optional<Class<?>> javaRefClass(MethodHandles.Lookup lookup,JavaOp.InvokeOp op) {\n-        if (javaRefType(op) instanceof ClassType classType) {\n-            return Optional.of((Class<?>) OpTk.classTypeToType(lookup,classType));\n-        }else{\n-            return Optional.empty();\n-        }\n-    }\n-    public Optional<Class<?>> javaRefClass() {\n-       return javaRefClass(lookup,op);\n-    }\n-    public static Optional<Class<?>> javaReturnClass(MethodHandles.Lookup lookup,JavaOp.InvokeOp op) {\n-        if (javaReturnType(op) instanceof ClassType classType) {\n-            return Optional.of((Class<?>) OpTk.classTypeToType(lookup,classType));\n-        }else{\n-            return Optional.empty();\n-        }\n-    }\n-    public Optional<Class<?>> javaReturnClass() {\n-        return javaReturnClass(lookup,op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class JavaBreakOpWrapper extends OpWrapper<JavaOp.BreakOp> {\n-    public JavaBreakOpWrapper( JavaOp.BreakOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class JavaContinueOpWrapper extends OpWrapper<JavaOp.ContinueOp> {\n-    public JavaContinueOpWrapper( JavaOp.ContinueOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class JavaLabeledOpWrapper extends StructuralOpWrapper<JavaOp.LabeledOp> {\n-    public JavaLabeledOpWrapper(JavaOp.LabeledOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-public class LambdaOpWrapper extends OpWrapper<JavaOp.LambdaOp> {\n-    public final MethodHandles.Lookup lookup;\n-    public LambdaOpWrapper( MethodHandles.Lookup lookup, JavaOp.LambdaOp op) {\n-        super(op);\n-        this.lookup=lookup;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-public interface LoadOpWrapper {\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LoadOpWrapper.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class LogicalOpWrapper extends BinaryOpWrapper<JavaOp.JavaConditionalOp> {\n-    LogicalOpWrapper(JavaOp.JavaConditionalOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Op;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.stream.Stream;\n-\n-public abstract class LoopOpWrapper<T extends Op> extends StructuralOpWrapper<T> {\n-    LoopOpWrapper(T op ) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LoopOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.util.*;\n-\n-public class ModuleOpWrapper extends OpWrapper<CoreOp.ModuleOp> {\n-   \/\/ public MethodHandles.Lookup lookup;\n-    public ModuleOpWrapper(\n-            \/\/MethodHandles.Lookup lookup,\n-            CoreOp.ModuleOp op) {\n-        super(op);\n-        \/\/this.lookup=lookup;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import hat.ComputeContext;\n+import hat.buffer.Buffer;\n+import hat.buffer.KernelContext;\n@@ -28,0 +31,1 @@\n+import hat.ifacemapper.MappableIface;\n@@ -34,0 +38,1 @@\n+import jdk.incubator.code.Value;\n@@ -56,0 +61,1 @@\n+import java.util.Set;\n@@ -62,1 +68,0 @@\n-\n@@ -64,1 +69,1 @@\n-        return ((Op.Result)op.operands().getFirst()).op();\n+        return ((Op.Result) op.operands().getFirst()).op();\n@@ -68,1 +73,1 @@\n-        return  ((Op.Result)op.operands().get(1)).op();\n+        return ((Op.Result) op.operands().get(1)).op();\n@@ -71,2 +76,5 @@\n-    public static Stream<OpWrapper<?>> lhsWrappedYieldOpStream(MethodHandles.Lookup lookup,JavaOp.JavaConditionalOp op) {\n-        return op.bodies().get(0).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+   \/\/ public static Stream<OpWrapper<?>> lhsWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.JavaConditionalOp op) {\n+     \/\/   return op.bodies().get(0).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n+   \/\/ }\n+    public static Stream<Op> lhsYieldOpStream(JavaOp.JavaConditionalOp op) {\n+        return op.bodies().get(0).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -75,2 +83,5 @@\n-    public static Stream<OpWrapper<?>> rhsWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.JavaConditionalOp op) {\n-        return op.bodies().get(1).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+   \/\/ public static Stream<OpWrapper<?>> rhsWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.JavaConditionalOp op) {\n+     \/\/   return op.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n+   \/\/ }\n+    public static Stream<Op> rhsYieldOpStream( JavaOp.JavaConditionalOp op) {\n+        return op.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -80,1 +91,1 @@\n-        return fieldAccessOp.fieldDescriptor().refType() instanceof  ClassType classType && classType.toClassName().equals(\"hat.KernelContext\");\n+        return fieldAccessOp.fieldDescriptor().refType() instanceof ClassType classType && classType.toClassName().equals(\"hat.KernelContext\");\n@@ -101,1 +112,1 @@\n-            Class<?> clazz = (Class<?>) classTypeToType(lookup,classType);\n+            Class<?> clazz = (Class<?>) classTypeToType(lookup, classType);\n@@ -113,3 +124,3 @@\n-    public static Stream<OpWrapper<?>> initWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n-        return  op.init().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->OpWrapper.wrap(lookup,o) );\n-    }\n+   \/\/ public static Stream<OpWrapper<?>> initWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n+     \/\/   return op.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n+   \/\/ }\n@@ -117,0 +128,3 @@\n+    public static Stream<Op> initYieldOpStream(JavaOp.ForOp op) {\n+        return op.init().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n+    }\n@@ -118,2 +132,5 @@\n-    public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op ) {\n-        return  op.cond().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o->OpWrapper.wrap(lookup,o) );\n+  \/\/  public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n+    \/\/    return op.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).map(o -> OpWrapper.wrap(lookup, o));\n+   \/\/ }\n+    public static Stream<Op> conditionYieldOpStream(JavaOp.ForOp op) {\n+        return op.cond().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -121,1 +138,1 @@\n-    public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.WhileOp op) {\n+    public static Stream<Op> conditionYieldOpStream( JavaOp.WhileOp op) {\n@@ -123,1 +140,1 @@\n-        return op.bodies().getFirst().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+        return op.bodies().getFirst().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -125,3 +142,3 @@\n-    public static Stream<OpWrapper<?>> conditionWrappedYieldOpStream(MethodHandles.Lookup lookup,JavaOp.ConditionalExpressionOp op) {\n-        \/\/ ADD op.cond() to JavaOp.ConditionalExpressionOp match ForOp?\n-        return op.bodies().getFirst().entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    public static Stream<Op> conditionYieldOpStream( JavaOp.ConditionalExpressionOp op) {\n+        \/\/ ADD op.cond() to JavaOp.WhileOp  match ForOp?\n+        return op.bodies().getFirst().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -129,5 +146,3 @@\n-\n-\n-    public static Stream<OpWrapper<?>> loopWrappedRootOpStream(MethodHandles.Lookup lookup, Op.Loop op) {\n-        var list = new ArrayList<>(RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.loopBody().entryBlock()).toList());\n-        if (list.getLast() instanceof JavaContinueOpWrapper) {\n+    public static Stream<Op> loopRootOpStream(MethodHandles.Lookup lookup, Op.Loop op) {\n+        var list = new ArrayList<>(rootsExcludingVarFuncDeclarationsAndYields( op.loopBody().entryBlock()).toList());\n+        if (list.getLast() instanceof JavaOp.ContinueOp) {\n@@ -140,2 +155,2 @@\n-    public static Stream<OpWrapper<?>> mutateRootWrappedOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n-        return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().get(2).entryBlock());\n+    public static Stream<Op> mutateRootOpStream(MethodHandles.Lookup lookup, JavaOp.ForOp op) {\n+        return rootsExcludingVarFuncDeclarationsAndYields( op.bodies().get(2).entryBlock());\n@@ -144,3 +159,0 @@\n-    public static Stream<OpWrapper<?>> thenWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) {\n-        return op.bodies().get(1).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n-    }\n@@ -148,2 +160,2 @@\n-    public static Stream<OpWrapper<?>> elseWrappedYieldOpStream(MethodHandles.Lookup lookup, JavaOp.ConditionalExpressionOp op) {\n-        return op.bodies().get(2).entryBlock().ops().stream().filter(o->o instanceof CoreOp.YieldOp).map(o-> OpWrapper.wrap(lookup,o));\n+    public static Stream<Op> thenYieldOpStream( JavaOp.ConditionalExpressionOp op) {\n+        return op.bodies().get(1).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -152,2 +164,2 @@\n-    public static boolean hasElse(JavaOp.IfOp op,  int idx) {\n-        return op.bodies().size()>idx && op.bodies().get(idx).entryBlock().ops().size() > 1;\n+    public static Stream<Op> elseYieldOpStream(JavaOp.ConditionalExpressionOp op) {\n+        return op.bodies().get(2).entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp);\n@@ -157,0 +169,4 @@\n+    public static boolean hasElse(JavaOp.IfOp op, int idx) {\n+        return op.bodies().size() > idx && op.bodies().get(idx).entryBlock().ops().size() > 1;\n+    }\n+\n@@ -162,1 +178,2 @@\n-        record RefAndFunc(MethodRef r, FuncOpWrapper f) {}\n+        record RefAndFunc(MethodRef r, CoreOp.FuncOp f) {\n+        }\n@@ -167,1 +184,1 @@\n-                MethodRef methodRef = InvokeOpWrapper.methodRef(invokeOp);\n+                MethodRef methodRef = methodRef(invokeOp);\n@@ -169,1 +186,1 @@\n-                Class<?> javaRefTypeClass = InvokeOpWrapper.javaRefClass(callGraph.computeContext.accelerator.lookup,invokeOp).orElseThrow();\n+                Class<?> javaRefTypeClass = javaRefClass(callGraph.computeContext.accelerator.lookup, invokeOp).orElseThrow();\n@@ -177,1 +194,1 @@\n-                    work.push(new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get())));\n+                    work.push(new RefAndFunc(methodRef,  f.get()));\n@@ -189,1 +206,1 @@\n-            CoreOp.FuncOp tf = rf.f.op.transform(rf.r.name(), (blockBuilder, op) -> {\n+            CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n@@ -191,2 +208,2 @@\n-                  \/\/  InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n-                    MethodRef methodRef = InvokeOpWrapper.methodRef(iop);\n+                    \/\/  InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n+                    MethodRef methodRef = methodRef(iop);\n@@ -202,1 +219,1 @@\n-                            RefAndFunc call = new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get()));\n+                            RefAndFunc call = new RefAndFunc(methodRef, f.get());\n@@ -207,1 +224,1 @@\n-                                    call.f.op.invokableType(),\n+                                    call.f.invokableType(),\n@@ -223,1 +240,1 @@\n-    public  static Type classTypeToType(MethodHandles.Lookup lookup, ClassType classType) {\n+    public static Type classTypeToType(MethodHandles.Lookup lookup, ClassType classType) {\n@@ -234,1 +251,1 @@\n-    public  static boolean isAssignable(MethodHandles.Lookup lookup, JavaType javaType, Class<?> ... classes) {\n+    public static boolean isAssignable(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n@@ -236,1 +253,1 @@\n-            Type type = classTypeToType(lookup,classType);\n+            Type type = classTypeToType(lookup, classType);\n@@ -248,5 +265,2 @@\n-\n-\n-\n-    public static InvokeOpWrapper getQuotableTargetInvokeOpWrapper(MethodHandles.Lookup lookup,JavaOp.LambdaOp lambdaOp) {\n-        return OpWrapper.wrap(lookup, lambdaOp.body().entryBlock().ops().stream()\n+    public static JavaOp.InvokeOp getQuotableTargetInvokeOpWrapper( JavaOp.LambdaOp lambdaOp) {\n+        return lambdaOp.body().entryBlock().ops().stream()\n@@ -255,1 +269,1 @@\n-                .findFirst().get());\n+                .findFirst().get();\n@@ -258,2 +272,2 @@\n-    public static MethodRef getQuotableTargetMethodRef(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp) {\n-        return getQuotableTargetInvokeOpWrapper(lookup,lambdaOp).methodRef();\n+    public static MethodRef getQuotableTargetMethodRef(JavaOp.LambdaOp lambdaOp) {\n+        return methodRef(getQuotableTargetInvokeOpWrapper( lambdaOp));\n@@ -302,1 +316,1 @@\n-\n+\/*\n@@ -304,1 +318,4 @@\n-        return RootSet.rootsWithoutVarFuncDeclarationsOrYields(lookup,op.bodies().getFirst().entryBlock());\n+        return wrappedRootsExcludingVarFuncDeclarationsAndYields(lookup, op.bodies().getFirst().entryBlock());\n+    } *\/\n+    public static Stream<Op> rootOpStream(MethodHandles.Lookup lookup, CoreOp.FuncOp op) {\n+        return rootsExcludingVarFuncDeclarationsAndYields(op.bodies().getFirst().entryBlock());\n@@ -307,6 +324,25 @@\n-    public static CoreOp.FuncOp transformInvokes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp, WrappedInvokeOpTransformer wrappedOpTransformer) {\n-        return funcOp.transform((b, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                wrappedOpTransformer.apply(b, OpWrapper.wrap(lookup,invokeOp));\n-            } else {\n-                b.op(op);\n+\n+    static public Set<Op> roots(Block block) {\n+        record Node<T extends Value>(T node, List<Node<T>> children) {\n+        }\n+        Set<Op> roots = new LinkedHashSet<>();\n+        Map<Op, Node<Value>> trees = new LinkedHashMap<>();\n+        Map<Value, Node<Value>> params = new HashMap<>();\n+        block.ops().forEach(op -> {\n+            List<Node<Value>> children = new ArrayList<>();\n+\n+            op.operands().forEach(operand -> {\n+                if (operand instanceof Op.Result result) {\n+                    children.add(trees.get(result.op()));\n+                } else {\n+                    children.add(params.computeIfAbsent(operand, _ -> new Node<>(operand, List.of())));\n+                }\n+            });\n+            trees.put(op, new Node<>(op.result(), children));\n+        });\n+\n+        trees.keySet().forEach(op -> {\n+            if (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2) {\n+                roots.add(op);\n+            } else if (op instanceof CoreOp.VarOp || op.result().uses().isEmpty()) {\n+                roots.add(op);\n@@ -314,1 +350,0 @@\n-            return b;\n@@ -316,0 +351,28 @@\n+        return roots;\n+    }\n+\n+    static public Stream<Op> rootsExcludingVarFuncDeclarationsAndYields(Block block) {\n+        var roots = roots(block);\n+        return block.ops().stream()\n+                .filter(roots::contains)\n+                .filter(w -> !(w instanceof CoreOp.VarOp varOp && paramVar(varOp) != null))\n+                .filter(w -> !(w instanceof CoreOp.YieldOp));\n+    }\n+\n+    public static MethodRef methodRef(JavaOp.InvokeOp op) {\n+        return op.invokeDescriptor();\n+    }\n+\n+    public static JavaType javaRefType(JavaOp.InvokeOp op) {\n+        return (JavaType) methodRef(op).refType();\n+    }\n+\n+    public static boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return isAssignable(lookup, javaRefType(invokeOp), MappableIface.class);\n+    }\n+\n+    public static boolean isRawKernelCall(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+        return (op.operands().size() > 1 && op.operands().getFirst() instanceof Value value\n+                && value.type() instanceof JavaType javaType\n+                && (isAssignable(lookup, javaType, hat.KernelContext.class) || isAssignable(lookup, javaType, KernelContext.class))\n+        );\n@@ -318,2 +381,2 @@\n-    public interface WrappedInvokeOpTransformer extends BiFunction<Block.Builder, InvokeOpWrapper, Block.Builder> {\n-        Block.Builder apply(Block.Builder block, InvokeOpWrapper op);\n+    public static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n@@ -322,0 +385,42 @@\n+    public static JavaType javaReturnType(JavaOp.InvokeOp op) {\n+        return (JavaType) methodRef(op).type().returnType();\n+    }\n+\n+    public static Method method(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+        try {\n+            return methodRef(op).resolveToMethod(lookup, op.invokeKind());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static boolean isIfaceAccessor(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        if (isIfaceBufferMethod(lookup, invokeOp) && !javaReturnType(invokeOp).equals(JavaType.VOID)) {\n+            Optional<Class<?>> optionalClazz = javaReturnClass(lookup, invokeOp);\n+            return optionalClazz.isPresent() && Buffer.class.isAssignableFrom(optionalClazz.get());\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public static boolean isIfaceMutator(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return isIfaceBufferMethod(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID);\n+    }\n+\n+    public static Optional<Class<?>> javaRefClass(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+        if (javaRefType(op) instanceof ClassType classType) {\n+            return Optional.of((Class<?>) classTypeToType(lookup, classType));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static Optional<Class<?>> javaReturnClass(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+        if (javaReturnType(op) instanceof ClassType classType) {\n+            return Optional.of((Class<?>) classTypeToType(lookup, classType));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+\n@@ -330,0 +435,1 @@\n+\n@@ -336,0 +442,1 @@\n+\n@@ -339,0 +446,1 @@\n+\n@@ -342,0 +450,1 @@\n+\n@@ -346,0 +455,1 @@\n+\n@@ -378,2 +488,3 @@\n-        final public  CoreOp funcOp;\n-        public ParamTable(CoreOp.FuncOp funcOp){\n+        final public CoreOp funcOp;\n+\n+        public ParamTable(CoreOp.FuncOp funcOp) {\n@@ -388,3 +499,3 @@\n-                    }else if (resultOp instanceof JavaOp.InvokeOp invokeOp) {\n-                        parameterInvokeOpMap.add(parameter,invokeOp);\n-                    }else{\n+                    } else if (resultOp instanceof JavaOp.InvokeOp invokeOp) {\n+                        parameterInvokeOpMap.add(parameter, invokeOp);\n+                    } else {\n@@ -399,0 +510,21 @@\n+\n+    public record ParamVar(CoreOp.VarOp varOp, Block.Parameter parameter, CoreOp.FuncOp funcOp) {\n+    }\n+\n+    public static ParamVar paramVar(CoreOp.VarOp varOp) {\n+        return !varOp.isUninitialized()\n+                && varOp.operands().getFirst() instanceof Block.Parameter parameter\n+                && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp ? new ParamVar(varOp, parameter, funcOp) : null;\n+    }\n+\n+    public static boolean isStructural(Op op){\n+        return switch (op){\n+            case JavaOp.ForOp _ -> true;\n+            case JavaOp.WhileOp _ -> true;\n+            case JavaOp.IfOp _ -> true;\n+            case JavaOp.LabeledOp _ ->true;\n+            case JavaOp.YieldOp _ ->true;\n+            case CoreOp.TupleOp _ ->true;\n+            default -> false;\n+        };\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":201,"deletions":69,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class OpWrapper<T extends Op> {\n-    @SuppressWarnings(\"unchecked\")\n-    public static <O extends Op, OW extends OpWrapper<O>> OW wrap(MethodHandles.Lookup lookup,O op) {\n-        return switch (op) {\n-            case CoreOp.FuncOp $ -> (OW) new FuncOpWrapper(lookup, $);\n-            case JavaOp.InvokeOp $ -> (OW) new InvokeOpWrapper(lookup, $);\n-            case JavaOp.LambdaOp $ -> (OW) new LambdaOpWrapper(lookup, $);\n-\n-            case JavaOp.ForOp $ -> (OW) new ForOpWrapper( $);\n-            case JavaOp.WhileOp $ -> (OW) new WhileOpWrapper( $);\n-            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper( $);\n-            case JavaOp.IfOp $ -> (OW) new IfOpWrapper( $);\n-            case CoreOp.TupleOp $ -> (OW) new TupleOpWrapper( $);\n-            case JavaOp.LabeledOp $ -> (OW) new JavaLabeledOpWrapper( $);\n-            case JavaOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper( $);\n-            case JavaOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper( $);\n-            case JavaOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation( $);\n-            case JavaOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper( $);\n-            case CoreOp.VarOp $\n-                \/\/ We have one special case for VarOp\n-                \/\/ This is possibly a premature optimization. But it allows us to treat var declarations differently from params.\n-                \/\/ we want a different wrapper for VarDeclarations which  relate to func parameters.\n-                \/\/ This saves us asking each time if a var is indeed a func param.\n-                    when !$.isUninitialized() && $.operands().getFirst() instanceof Block.Parameter parameter\n-                    && parameter.invokableOperation() instanceof CoreOp.FuncOp funcOp\n-                    -> (OW) new VarFuncDeclarationOpWrapper($, funcOp, parameter);\n-            case CoreOp.VarOp $ -> (OW) new VarDeclarationOpWrapper( $);\n-            case CoreOp.YieldOp $ -> (OW) new YieldOpWrapper( $);\n-            case CoreOp.FuncCallOp $ -> (OW) new FuncCallOpWrapper( $);\n-            case JavaOp.ConvOp $ -> (OW) new ConvOpWrapper( $);\n-            case CoreOp.ConstantOp $ -> (OW) new ConstantOpWrapper( $);\n-            case CoreOp.ReturnOp $ -> (OW) new ReturnOpWrapper( $);\n-            case CoreOp.VarAccessOp.VarStoreOp $ -> (OW) new VarStoreOpWrapper( $);\n-            case CoreOp.VarAccessOp.VarLoadOp $ -> (OW) new VarLoadOpWrapper( $);\n-            case JavaOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper( $);\n-            case JavaOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper( $);\n-            case JavaOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper( $);\n-            case JavaOp.ConditionalExpressionOp $ -> (OW) new TernaryOpWrapper( $);\n-            case JavaOp.BreakOp $ -> (OW) new JavaBreakOpWrapper( $);\n-            case JavaOp.ContinueOp $ -> (OW) new JavaContinueOpWrapper( $);\n-            default -> (OW) new OpWrapper<>(op);\n-        };\n-    }\n-\n-    public final T op;\n-    OpWrapper(T op) {\n-        this.op = op;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class ReturnOpWrapper extends OpWrapper<CoreOp.ReturnOp> {\n-    public ReturnOpWrapper( CoreOp.ReturnOp op) {\n-        super(op);\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-public class RootSet {\n-\n-    public final Set<Op> set;\n-    public RootSet(Stream<Op> ops){\n-        this.set = getRootSet(ops);\n-    }\n-    static public Stream<OpWrapper<?>> rootsWithoutVarFuncDeclarationsOrYields(MethodHandles.Lookup lookup,Block block) {\n-        RootSet rootSet = new RootSet(block.ops().stream());\n-        return block.ops().stream()\n-                .filter(rootSet.set::contains).map(o->OpWrapper.wrap(lookup,o))\n-                .filter(w -> !(w instanceof VarFuncDeclarationOpWrapper))\n-                .filter(w -> !(w instanceof YieldOpWrapper))\n-                .map(o->(OpWrapper<?>) o);\n-    }\n-    private static Set<Op> getRootSet(Stream<Op> ops) {\n-         record Node<T extends Value>(T node, List<Node<T>> children) {\n-        }\n-        Set<Op> roots = new LinkedHashSet<>();\n-        Map<Op, Node<Value>> trees = new LinkedHashMap<>();\n-        Map<Value, Node<Value>> params = new HashMap<>();\n-        ops.forEach(op -> {\n-            List<Node<Value>> children = new ArrayList<>();\n-            for (Value operand : op.operands()) {\n-                if (operand instanceof Op.Result opr) {\n-                    children.add(trees.get(opr.op()));\n-                } else {\n-                    children.add(params.computeIfAbsent(operand, _ -> new Node<>(operand, List.of())));\n-                }\n-            }\n-            trees.put(op, new Node<>(op.result(), children));\n-        });\n-\n-        trees.forEach((op, _) -> {\n-            if (op instanceof CoreOp.VarAccessOp.VarStoreOp) {\n-                Value value = op.operands().get(1);\n-                if (value.uses().size() < 2) {\n-                    roots.add(op);\n-                }\n-            } else if (op instanceof CoreOp.VarOp || op.result().uses().isEmpty()) {\n-                roots.add(op);\n-            }\n-        });\n-        return roots;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RootSet.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-public interface StoreOpWrapper {\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/StoreOpWrapper.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Op;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public abstract class StructuralOpWrapper<T extends Op> extends OpWrapper<T> {\n-    StructuralOpWrapper(T op) {\n-        super(op);\n-\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/StructuralOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class TernaryOpWrapper extends OpWrapper<JavaOp.ConditionalExpressionOp> {\n-    public TernaryOpWrapper( JavaOp.ConditionalExpressionOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class TupleOpWrapper extends StructuralOpWrapper<CoreOp.TupleOp> {\n-    public TupleOpWrapper( CoreOp.TupleOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class UnaryArithmeticOrLogicOpWrapper extends UnaryOpWrapper<JavaOp.UnaryOp> {\n-    UnaryArithmeticOrLogicOpWrapper( JavaOp.UnaryOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Op;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public abstract class UnaryOpWrapper<T extends Op> extends OpWrapper<T> {\n-    UnaryOpWrapper(T op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/UnaryOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public abstract class VarAccessOpWrapper<T extends CoreOp.VarAccessOp> extends OpWrapper<T> {\n-    VarAccessOpWrapper( T op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class VarDeclarationOpWrapper extends VarOpWrapper implements StoreOpWrapper {\n-    public VarDeclarationOpWrapper( CoreOp.VarOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class VarFuncDeclarationOpWrapper extends VarOpWrapper {\n-    final CoreOp.FuncOp funcOp;\n-    final Block.Parameter blockParameter;\n-    final int idx;\n-\n-    public VarFuncDeclarationOpWrapper(CoreOp.VarOp op, CoreOp.FuncOp funcOp, Block.Parameter blockParameter) {\n-        super(op);\n-        this.funcOp = funcOp;\n-        this.blockParameter = blockParameter;\n-        this.idx = blockParameter.index();\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class VarLoadOpWrapper extends VarAccessOpWrapper<CoreOp.VarAccessOp.VarLoadOp> implements LoadOpWrapper {\n-\n-    VarLoadOpWrapper( CoreOp.VarAccessOp.VarLoadOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public abstract class VarOpWrapper extends OpWrapper<CoreOp.VarOp> {\n-    public VarOpWrapper(CoreOp.VarOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class VarStoreOpWrapper extends VarAccessOpWrapper<CoreOp.VarAccessOp.VarStoreOp> implements StoreOpWrapper {\n-\n-\n-    VarStoreOpWrapper( CoreOp.VarAccessOp.VarStoreOp op) {\n-        super(op);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class WhileOpWrapper extends LoopOpWrapper<JavaOp.WhileOp> {\n-   \/\/public final MethodHandles.Lookup lookup;\n-    WhileOpWrapper(\n-            \/\/MethodHandles.Lookup lookup,\n-            JavaOp.WhileOp op) {\n-        super(op);\n-     \/\/   this.lookup=lookup;\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public class YieldOpWrapper extends StructuralOpWrapper<CoreOp.YieldOp> {\n-    public YieldOpWrapper(CoreOp.YieldOp op) {\n-        super(op);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.optools.RootSet;\n+import hat.optools.OpTk;\n@@ -34,1 +34,0 @@\n-import java.util.Set;\n@@ -165,4 +164,1 @@\n-        RootSet rootSet = new RootSet(f.body().entryBlock().ops().stream());\n-\n-       \/\/ Set<Op> roots = RootSet.getRootSet(f.body().entryBlock().ops().stream());\n-        f.body().entryBlock().ops().stream().filter(rootSet.set::contains).forEach(op -> {\n+        OpTk.rootsExcludingVarFuncDeclarationsAndYields(f.body().entryBlock()).forEach(op -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DependencyTree.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.OpWrapper;\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import hat.optools.FieldLoadOpWrapper;\n-import hat.optools.FuncOpWrapper;\n-import hat.optools.InvokeOpWrapper;\n@@ -33,2 +30,0 @@\n-import hat.optools.OpWrapper;\n-import hat.optools.StructuralOpWrapper;\n@@ -37,0 +32,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -54,5 +50,5 @@\n-    public T fieldLoad(HATCodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n-        if (OpTk.isKernelContextAccess(fieldLoadOpWrapper.op)) {\n-            identifier(\"kc\").dot().identifier(OpTk.fieldName(fieldLoadOpWrapper.op));\n-        } else if (fieldLoadOpWrapper.op.operands().isEmpty() && fieldLoadOpWrapper.op.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n-            var value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOpWrapper.op);\n+    public T fieldLoad(HATCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n+            identifier(\"kc\").dot().identifier(OpTk.fieldName(fieldLoadOp));\n+        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) { \/\/ only primitve fields\n+            var value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n@@ -61,1 +57,1 @@\n-            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" + fieldLoadOpWrapper.op);\n+            throw new IllegalStateException(\"An instance field? I guess - we dont get those in HAT \" +fieldLoadOp);\n@@ -66,3 +62,3 @@\n-    public T methodCall(HATCodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n-        if (!invokeOpWrapper.op.operands().isEmpty() && invokeOpWrapper.op.operands().getFirst() instanceof Op.Result instanceResult) {\n-            recurse(buildContext, OpWrapper.wrap(buildContext.lookup, instanceResult.op()));\n+    public T methodCall(HATCodeBuilderContext buildContext, JavaOp.InvokeOp invokeOp) {\n+        if (!invokeOp.operands().isEmpty() && invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+            recurse(buildContext, instanceResult.op());\n@@ -70,1 +66,1 @@\n-        dot().identifier(invokeOpWrapper.name());\n+        dot().identifier(invokeOp.invokeDescriptor().name());\n@@ -72,2 +68,2 @@\n-            commaSeparated(  invokeOpWrapper.op.operands().subList(0,invokeOpWrapper.op.operands().size()-1), o->\n-                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup, ((Op.Result) o).op()))\n+            commaSeparated(  invokeOp.operands().subList(0,invokeOp.operands().size()-1), o->\n+                    recurse(buildContext,  ((Op.Result) o).op())\n@@ -86,1 +82,1 @@\n-                OpTk.wrappedRootOpStream(buildContext.lookup,funcOp)\n+                OpTk.rootOpStream(buildContext.lookup,funcOp)\n@@ -88,1 +84,1 @@\n-                                recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n+                                recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root)).nl()\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.optools.OpWrapper;\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}