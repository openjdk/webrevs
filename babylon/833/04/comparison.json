{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.Supplier;\n@@ -107,2 +108,4 @@\n-    static final MethodRef EX_TYPE_ELEM_OF_LIST = MethodRef.method(EX_TYPE_ELEM, \"of\",\n-            EX_TYPE_ELEM, J_L_STRING, J_U_LIST);\n+    static final FunctionType EXTER_TYPE_BUILDER_F_TYPE = functionType(EX_TYPE_ELEM);\n+\n+    static final MethodRef EX_TYPE_ELEM_OF_ARRAY = MethodRef.method(ExternalizedTypeElement.class, \"of\",\n+            ExternalizedTypeElement.class, String.class, ExternalizedTypeElement[].class);\n@@ -190,1 +193,10 @@\n-    final Block.Builder builder;\n+    Block.Builder builder;\n+\n+    final Stack<Block.Builder> lambdaStack = new Stack<>();\n+\n+    \/\/ safe limit of the operations built by a single method\/lambda body\n+    static final int OP_LIMIT = 1000;\n+    \/\/ safe limit of types \/ exterType calls built by a single builder method\n+    static final int TYPE_LIMIT = 3000;\n+\n+    int opCounter = 0;\n@@ -213,1 +225,1 @@\n-        funcs.add(createExternTypeHelperFunc(registeredExternalizedTypes));\n+        funcs.addAll(createExternTypeHelperFuncs(registeredExternalizedTypes));\n@@ -346,1 +358,1 @@\n-                    var exterType = b.op(funcCall(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class)), i));\n+                    var exterType = b.op(funcCall(EXTER_TYPE_BUILDER_F_NAME, EXTER_TYPE_BUILDER_F_TYPE, i));\n@@ -375,1 +387,1 @@\n-    private static FuncOp createExternTypeHelperFunc(Map<ExternalizedTypeElement, List<Integer>> registeredExterTypes) {\n+    private static List<FuncOp> createExternTypeHelperFuncs(SequencedMap<ExternalizedTypeElement, List<Integer>> registeredExterTypes) {\n@@ -385,17 +397,40 @@\n-        return func(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class))).body(b -> {\n-            Block.Parameter i = b.parameter(INT);\n-            List<Body.Builder> swBodies = new ArrayList<>();\n-            for (Map.Entry<ExternalizedTypeElement, List<Integer>> e : registeredExterTypes.entrySet()) {\n-                Body.Builder l = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n-                Block.Parameter target = l.entryBlock().parameter(INT);\n-                Integer typeIndex = e.getValue().getLast();\n-                Result p = l.entryBlock().op(eq(target, l.entryBlock().op(constant(INT, typeIndex))));\n-                l.entryBlock().op(core_yield(p));\n-\n-                Body.Builder expr = Body.Builder.of(b.parentBody(), functionType(type(ExternalizedTypeElement.class)));\n-                List<Value> args = new ArrayList<>();\n-                args.add(expr.entryBlock().op(constant(J_L_STRING, e.getKey().identifier())));\n-                for (int j = 0; j < e.getValue().size() - 1; j++) {\n-                    Value index = expr.entryBlock().op(constant(INT, e.getValue().get(j)));\n-                    Result opr = expr.entryBlock().op(funcCall(EXTER_TYPE_BUILDER_F_NAME, functionType(type(ExternalizedTypeElement.class)), index));\n-                    args.add(opr);\n+        List<FuncOp> funcs = new ArrayList<>();\n+        Iterator<Map.Entry<ExternalizedTypeElement, List<Integer>>> typesEnntryIterator = registeredExterTypes.sequencedEntrySet().iterator();\n+        int methodCounter = 0;\n+        do {\n+            String followUpBuilderName = EXTER_TYPE_BUILDER_F_NAME + (methodCounter + 1);\n+            funcs.add(func(EXTER_TYPE_BUILDER_F_NAME + (methodCounter > 0 ? methodCounter : \"\"), EXTER_TYPE_BUILDER_F_TYPE).body(b -> {\n+                Block.Parameter i = b.parameter(INT);\n+                List<Body.Builder> swBodies = new ArrayList<>();\n+                for (int counter = 0; counter < TYPE_LIMIT && typesEnntryIterator.hasNext();) {\n+                    Map.Entry<ExternalizedTypeElement, List<Integer>> e = typesEnntryIterator.next();\n+                    counter += e.getValue().size();\n+                    Body.Builder l = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n+                    Block.Parameter target = l.entryBlock().parameter(INT);\n+                    Integer typeIndex = e.getValue().getLast();\n+                    Result p = l.entryBlock().op(eq(target, l.entryBlock().op(constant(INT, typeIndex))));\n+                    l.entryBlock().op(core_yield(p));\n+\n+                    Body.Builder expr = Body.Builder.of(b.parentBody(), EXTER_TYPE_BUILDER_F_TYPE);\n+                    List<Value> args = new ArrayList<>();\n+                    args.add(expr.entryBlock().op(constant(J_L_STRING, e.getKey().identifier())));\n+                    for (int j = 0; j < e.getValue().size() - 1; j++) {\n+                        Value index = expr.entryBlock().op(constant(INT, e.getValue().get(j)));\n+                        Result opr = expr.entryBlock().op(funcCall(EXTER_TYPE_BUILDER_F_NAME, EXTER_TYPE_BUILDER_F_TYPE, index));\n+                        args.add(opr);\n+                    }\n+                    MethodRef mr;\n+                    Result type;\n+                    if (e.getKey().arguments().size() < 5) {\n+                        List<Class<?>> params = new ArrayList<>();\n+                        params.add(String.class);\n+                        params.addAll(Collections.nCopies(e.getKey().arguments().size(), ExternalizedTypeElement.class));\n+                        mr = MethodRef.method(ExternalizedTypeElement.class, \"of\", ExternalizedTypeElement.class, params);\n+                        type = expr.entryBlock().op(invoke(mr, args));\n+                    } else {\n+                        type = expr.entryBlock().op(invoke(InvokeOp.InvokeKind.STATIC, true, EX_TYPE_ELEM, EX_TYPE_ELEM_OF_ARRAY, args));\n+                    }\n+                    expr.entryBlock().op(core_yield(type));\n+\n+                    swBodies.add(l);\n+                    swBodies.add(expr);\n@@ -403,8 +438,9 @@\n-                MethodRef mr;\n-                Result type;\n-                if (e.getKey().arguments().size() < 5) {\n-                    List<Class<?>> params = new ArrayList<>();\n-                    params.add(String.class);\n-                    params.addAll(Collections.nCopies(e.getKey().arguments().size(), ExternalizedTypeElement.class));\n-                    mr = MethodRef.method(ExternalizedTypeElement.class, \"of\", ExternalizedTypeElement.class, params);\n-                    type = expr.entryBlock().op(invoke(mr, args));\n+\n+                \/\/ default case\n+                Body.Builder dl = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n+                dl.entryBlock().parameter(INT);\n+                dl.entryBlock().op(core_yield(dl.entryBlock().op(constant(BOOLEAN, true))));\n+                Body.Builder de = Body.Builder.of(b.parentBody(), EXTER_TYPE_BUILDER_F_TYPE);\n+                if (typesEnntryIterator.hasNext()) {\n+                    \/\/ forward to a follow-up builder method (we are over TYPE_LIMIT)\n+                    de.entryBlock().op(core_yield(de.entryBlock().op(funcCall(followUpBuilderName, EXTER_TYPE_BUILDER_F_TYPE, i))));\n@@ -412,3 +448,2 @@\n-                    mr = MethodRef.method(ExternalizedTypeElement.class, \"of\", ExternalizedTypeElement.class,\n-                            String.class, ExternalizedTypeElement[].class);\n-                    type = expr.entryBlock().op(invoke(InvokeOp.InvokeKind.STATIC, true, type(ExternalizedTypeElement.class), mr, args));\n+                    \/\/ throw\n+                    de.entryBlock().op(throw_(de.entryBlock().op(new_(MethodRef.constructor(IllegalStateException.class)))));\n@@ -416,18 +451,9 @@\n-                expr.entryBlock().op(core_yield(type));\n-\n-                swBodies.add(l);\n-                swBodies.add(expr);\n-            }\n-\n-            \/\/ default case\n-            Body.Builder dl = Body.Builder.of(b.parentBody(), functionType(BOOLEAN));\n-            Block.Parameter target = dl.entryBlock().parameter(INT);\n-            dl.entryBlock().op(core_yield(dl.entryBlock().op(constant(BOOLEAN, true))));\n-            Body.Builder de = Body.Builder.of(b.parentBody(), functionType(type(ExternalizedTypeElement.class)));\n-            de.entryBlock().op(throw_(de.entryBlock().op(new_(MethodRef.constructor(IllegalStateException.class)))));\n-            swBodies.add(dl);\n-            swBodies.add(de);\n-\n-            var r = b.op(switchExpression(i, swBodies));\n-            b.op(return_(r));\n-        });\n+                swBodies.add(dl);\n+                swBodies.add(de);\n+\n+                var r = b.op(switchExpression(i, swBodies));\n+                b.op(return_(r));\n+            }));\n+            methodCounter++;\n+        } while (typesEnntryIterator.hasNext());\n+        return funcs;\n@@ -455,0 +481,8 @@\n+        \/\/ return from lambdas on stack\n+        while (!lambdaStack.isEmpty()) {\n+            var lambdaBuilder = builder;\n+            builder = lambdaStack.pop();\n+            var l = builder.op(lambda(JavaType.parameterized(JavaType.type(Supplier.class), JavaType.type(Op.class)), lambdaBuilder.parentBody()));\n+            builder.op(return_(builder.op(cast(JavaType.type(Op.class), builder.op(invoke(MethodRef.method(Supplier.class, \"get\", Object.class), l))))));\n+        }\n+\n@@ -460,0 +494,6 @@\n+        if (++opCounter == OP_LIMIT) {\n+            \/\/ continue building in a lambda\n+            opCounter = 0;\n+            lambdaStack.push(builder);\n+            builder = Body.Builder.of(builder.parentBody(), functionType(JavaType.type(Supplier.class))).entryBlock();\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":92,"deletions":52,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.invoke.MethodHandles;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestOpBuilderLimits\n+ * @run main Unreflect TestOpBuilderLimits\n+ * @run junit TestOpBuilderLimits\n+ *\/\n+public class TestOpBuilderLimits {\n+\n+    @Reflect\n+    static int bigModelBuilder(int i) {\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;i++;\n+        return i;\n+    }\n+\n+    @Test\n+    public void testOpLimit() throws Exception {\n+        FuncOp fop = Op.ofMethod(TestOpBuilderLimits.class.getDeclaredMethod(\"bigModelBuilder\", int.class)).orElseThrow();\n+        Assertions.assertEquals(bigModelBuilder(0), (int)Interpreter.invoke(MethodHandles.lookup(), fop, 0));\n+    }\n+\n+    interface T<T0, T1, T2, T3, T4, T5, T6, T7> {}\n+    interface A {}\n+    interface B {}\n+\n+    @Reflect\n+    static int manyTypes(int i) {\n+        T<A,A,A,A,A,A,A,A> t0; T<A,A,A,A,A,A,A,B> t1; T<A,A,A,A,A,A,B,A> t2; T<A,A,A,A,A,A,B,B> t3; T<A,A,A,A,A,B,A,A> t4;\n+        T<A,A,A,A,A,B,A,B> t5; T<A,A,A,A,A,B,B,A> t6; T<A,A,A,A,A,B,B,B> t7; T<A,A,A,A,B,A,A,A> t8; T<A,A,A,A,B,A,A,B> t9;\n+        T<A,A,A,A,B,A,B,A> t10; T<A,A,A,A,B,A,B,B> t11; T<A,A,A,A,B,B,A,A> t12; T<A,A,A,A,B,B,A,B> t13; T<A,A,A,A,B,B,B,A> t14;\n+        T<A,A,A,A,B,B,B,B> t15; T<A,A,A,B,A,A,A,A> t16; T<A,A,A,B,A,A,A,B> t17; T<A,A,A,B,A,A,B,A> t18; T<A,A,A,B,A,A,B,B> t19;\n+        T<A,A,A,B,A,B,A,A> t20; T<A,A,A,B,A,B,A,B> t21; T<A,A,A,B,A,B,B,A> t22; T<A,A,A,B,A,B,B,B> t23; T<A,A,A,B,B,A,A,A> t24;\n+        T<A,A,A,B,B,A,A,B> t25; T<A,A,A,B,B,A,B,A> t26; T<A,A,A,B,B,A,B,B> t27; T<A,A,A,B,B,B,A,A> t28; T<A,A,A,B,B,B,A,B> t29;\n+        T<A,A,A,B,B,B,B,A> t30; T<A,A,A,B,B,B,B,B> t31; T<A,A,B,A,A,A,A,A> t32; T<A,A,B,A,A,A,A,B> t33; T<A,A,B,A,A,A,B,A> t34;\n+        T<A,A,B,A,A,A,B,B> t35; T<A,A,B,A,A,B,A,A> t36; T<A,A,B,A,A,B,A,B> t37; T<A,A,B,A,A,B,B,A> t38; T<A,A,B,A,A,B,B,B> t39;\n+        T<A,A,B,A,B,A,A,A> t40; T<A,A,B,A,B,A,A,B> t41; T<A,A,B,A,B,A,B,A> t42; T<A,A,B,A,B,A,B,B> t43; T<A,A,B,A,B,B,A,A> t44;\n+        T<A,A,B,A,B,B,A,B> t45; T<A,A,B,A,B,B,B,A> t46; T<A,A,B,A,B,B,B,B> t47; T<A,A,B,B,A,A,A,A> t48; T<A,A,B,B,A,A,A,B> t49;\n+        T<A,A,B,B,A,A,B,A> t50; T<A,A,B,B,A,A,B,B> t51; T<A,A,B,B,A,B,A,A> t52; T<A,A,B,B,A,B,A,B> t53; T<A,A,B,B,A,B,B,A> t54;\n+        T<A,A,B,B,A,B,B,B> t55; T<A,A,B,B,B,A,A,A> t56; T<A,A,B,B,B,A,A,B> t57; T<A,A,B,B,B,A,B,A> t58; T<A,A,B,B,B,A,B,B> t59;\n+        T<A,A,B,B,B,B,A,A> t60; T<A,A,B,B,B,B,A,B> t61; T<A,A,B,B,B,B,B,A> t62; T<A,A,B,B,B,B,B,B> t63; T<A,B,A,A,A,A,A,A> t64;\n+        T<A,B,A,A,A,A,A,B> t65; T<A,B,A,A,A,A,B,A> t66; T<A,B,A,A,A,A,B,B> t67; T<A,B,A,A,A,B,A,A> t68; T<A,B,A,A,A,B,A,B> t69;\n+        T<A,B,A,A,A,B,B,A> t70; T<A,B,A,A,A,B,B,B> t71; T<A,B,A,A,B,A,A,A> t72; T<A,B,A,A,B,A,A,B> t73; T<A,B,A,A,B,A,B,A> t74;\n+        T<A,B,A,A,B,A,B,B> t75; T<A,B,A,A,B,B,A,A> t76; T<A,B,A,A,B,B,A,B> t77; T<A,B,A,A,B,B,B,A> t78; T<A,B,A,A,B,B,B,B> t79;\n+        T<A,B,A,B,A,A,A,A> t80; T<A,B,A,B,A,A,A,B> t81; T<A,B,A,B,A,A,B,A> t82; T<A,B,A,B,A,A,B,B> t83; T<A,B,A,B,A,B,A,A> t84;\n+        T<A,B,A,B,A,B,A,B> t85; T<A,B,A,B,A,B,B,A> t86; T<A,B,A,B,A,B,B,B> t87; T<A,B,A,B,B,A,A,A> t88; T<A,B,A,B,B,A,A,B> t89;\n+        T<A,B,A,B,B,A,B,A> t90; T<A,B,A,B,B,A,B,B> t91; T<A,B,A,B,B,B,A,A> t92; T<A,B,A,B,B,B,A,B> t93; T<A,B,A,B,B,B,B,A> t94;\n+        T<A,B,A,B,B,B,B,B> t95; T<A,B,B,A,A,A,A,A> t96; T<A,B,B,A,A,A,A,B> t97; T<A,B,B,A,A,A,B,A> t98; T<A,B,B,A,A,A,B,B> t99;\n+        T<A,B,B,A,A,B,A,A> t100; T<A,B,B,A,A,B,A,B> t101; T<A,B,B,A,A,B,B,A> t102; T<A,B,B,A,A,B,B,B> t103; T<A,B,B,A,B,A,A,A> t104;\n+        T<A,B,B,A,B,A,A,B> t105; T<A,B,B,A,B,A,B,A> t106; T<A,B,B,A,B,A,B,B> t107; T<A,B,B,A,B,B,A,A> t108; T<A,B,B,A,B,B,A,B> t109;\n+        T<A,B,B,A,B,B,B,A> t110; T<A,B,B,A,B,B,B,B> t111; T<A,B,B,B,A,A,A,A> t112; T<A,B,B,B,A,A,A,B> t113; T<A,B,B,B,A,A,B,A> t114;\n+        T<A,B,B,B,A,A,B,B> t115; T<A,B,B,B,A,B,A,A> t116; T<A,B,B,B,A,B,A,B> t117; T<A,B,B,B,A,B,B,A> t118; T<A,B,B,B,A,B,B,B> t119;\n+        T<A,B,B,B,B,A,A,A> t120; T<A,B,B,B,B,A,A,B> t121; T<A,B,B,B,B,A,B,A> t122; T<A,B,B,B,B,A,B,B> t123; T<A,B,B,B,B,B,A,A> t124;\n+        T<A,B,B,B,B,B,A,B> t125; T<A,B,B,B,B,B,B,A> t126; T<A,B,B,B,B,B,B,B> t127; T<B,A,A,A,A,A,A,A> t128; T<B,A,A,A,A,A,A,B> t129;\n+        T<B,A,A,A,A,A,B,A> t130; T<B,A,A,A,A,A,B,B> t131; T<B,A,A,A,A,B,A,A> t132; T<B,A,A,A,A,B,A,B> t133; T<B,A,A,A,A,B,B,A> t134;\n+        T<B,A,A,A,A,B,B,B> t135; T<B,A,A,A,B,A,A,A> t136; T<B,A,A,A,B,A,A,B> t137; T<B,A,A,A,B,A,B,A> t138; T<B,A,A,A,B,A,B,B> t139;\n+        T<B,A,A,A,B,B,A,A> t140; T<B,A,A,A,B,B,A,B> t141; T<B,A,A,A,B,B,B,A> t142; T<B,A,A,A,B,B,B,B> t143; T<B,A,A,B,A,A,A,A> t144;\n+        T<B,A,A,B,A,A,A,B> t145; T<B,A,A,B,A,A,B,A> t146; T<B,A,A,B,A,A,B,B> t147; T<B,A,A,B,A,B,A,A> t148; T<B,A,A,B,A,B,A,B> t149;\n+        T<B,A,A,B,A,B,B,A> t150; T<B,A,A,B,A,B,B,B> t151; T<B,A,A,B,B,A,A,A> t152; T<B,A,A,B,B,A,A,B> t153; T<B,A,A,B,B,A,B,A> t154;\n+        T<B,A,A,B,B,A,B,B> t155; T<B,A,A,B,B,B,A,A> t156; T<B,A,A,B,B,B,A,B> t157; T<B,A,A,B,B,B,B,A> t158; T<B,A,A,B,B,B,B,B> t159;\n+        T<B,A,B,A,A,A,A,A> t160; T<B,A,B,A,A,A,A,B> t161; T<B,A,B,A,A,A,B,A> t162; T<B,A,B,A,A,A,B,B> t163; T<B,A,B,A,A,B,A,A> t164;\n+        T<B,A,B,A,A,B,A,B> t165; T<B,A,B,A,A,B,B,A> t166; T<B,A,B,A,A,B,B,B> t167; T<B,A,B,A,B,A,A,A> t168; T<B,A,B,A,B,A,A,B> t169;\n+        T<B,A,B,A,B,A,B,A> t170; T<B,A,B,A,B,A,B,B> t171; T<B,A,B,A,B,B,A,A> t172; T<B,A,B,A,B,B,A,B> t173; T<B,A,B,A,B,B,B,A> t174;\n+        T<B,A,B,A,B,B,B,B> t175; T<B,A,B,B,A,A,A,A> t176; T<B,A,B,B,A,A,A,B> t177; T<B,A,B,B,A,A,B,A> t178; T<B,A,B,B,A,A,B,B> t179;\n+        T<B,A,B,B,A,B,A,A> t180; T<B,A,B,B,A,B,A,B> t181; T<B,A,B,B,A,B,B,A> t182; T<B,A,B,B,A,B,B,B> t183; T<B,A,B,B,B,A,A,A> t184;\n+        T<B,A,B,B,B,A,A,B> t185; T<B,A,B,B,B,A,B,A> t186; T<B,A,B,B,B,A,B,B> t187; T<B,A,B,B,B,B,A,A> t188; T<B,A,B,B,B,B,A,B> t189;\n+        T<B,A,B,B,B,B,B,A> t190; T<B,A,B,B,B,B,B,B> t191; T<B,B,A,A,A,A,A,A> t192; T<B,B,A,A,A,A,A,B> t193; T<B,B,A,A,A,A,B,A> t194;\n+        T<B,B,A,A,A,A,B,B> t195; T<B,B,A,A,A,B,A,A> t196; T<B,B,A,A,A,B,A,B> t197; T<B,B,A,A,A,B,B,A> t198; T<B,B,A,A,A,B,B,B> t199;\n+        T<B,B,A,A,B,A,A,A> t200; T<B,B,A,A,B,A,A,B> t201; T<B,B,A,A,B,A,B,A> t202; T<B,B,A,A,B,A,B,B> t203; T<B,B,A,A,B,B,A,A> t204;\n+        T<B,B,A,A,B,B,A,B> t205; T<B,B,A,A,B,B,B,A> t206; T<B,B,A,A,B,B,B,B> t207; T<B,B,A,B,A,A,A,A> t208; T<B,B,A,B,A,A,A,B> t209;\n+        T<B,B,A,B,A,A,B,A> t210; T<B,B,A,B,A,A,B,B> t211; T<B,B,A,B,A,B,A,A> t212; T<B,B,A,B,A,B,A,B> t213; T<B,B,A,B,A,B,B,A> t214;\n+        T<B,B,A,B,A,B,B,B> t215; T<B,B,A,B,B,A,A,A> t216; T<B,B,A,B,B,A,A,B> t217; T<B,B,A,B,B,A,B,A> t218; T<B,B,A,B,B,A,B,B> t219;\n+        T<B,B,A,B,B,B,A,A> t220; T<B,B,A,B,B,B,A,B> t221; T<B,B,A,B,B,B,B,A> t222; T<B,B,A,B,B,B,B,B> t223; T<B,B,B,A,A,A,A,A> t224;\n+        T<B,B,B,A,A,A,A,B> t225; T<B,B,B,A,A,A,B,A> t226; T<B,B,B,A,A,A,B,B> t227; T<B,B,B,A,A,B,A,A> t228; T<B,B,B,A,A,B,A,B> t229;\n+        T<B,B,B,A,A,B,B,A> t230; T<B,B,B,A,A,B,B,B> t231; T<B,B,B,A,B,A,A,A> t232; T<B,B,B,A,B,A,A,B> t233; T<B,B,B,A,B,A,B,A> t234;\n+        T<B,B,B,A,B,A,B,B> t235; T<B,B,B,A,B,B,A,A> t236; T<B,B,B,A,B,B,A,B> t237; T<B,B,B,A,B,B,B,A> t238; T<B,B,B,A,B,B,B,B> t239;\n+        T<B,B,B,B,A,A,A,A> t240; T<B,B,B,B,A,A,A,B> t241; T<B,B,B,B,A,A,B,A> t242; T<B,B,B,B,A,A,B,B> t243; T<B,B,B,B,A,B,A,A> t244;\n+        T<B,B,B,B,A,B,A,B> t245; T<B,B,B,B,A,B,B,A> t246; T<B,B,B,B,A,B,B,B> t247; T<B,B,B,B,B,A,A,A> t248; T<B,B,B,B,B,A,A,B> t249;\n+        T<B,B,B,B,B,A,B,A> t250; T<B,B,B,B,B,A,B,B> t251; T<B,B,B,B,B,B,A,A> t252; T<B,B,B,B,B,B,A,B> t253; T<B,B,B,B,B,B,B,A> t254;\n+        T<B,B,B,B,B,B,B,B> t255;\n+        return i;\n+    }\n+\n+    @Test\n+    public void testTypeLimit() throws Exception {\n+        FuncOp fop = Op.ofMethod(TestOpBuilderLimits.class.getDeclaredMethod(\"manyTypes\", int.class)).orElseThrow();\n+        Assertions.assertEquals(manyTypes(42), (int)Interpreter.invoke(MethodHandles.lookup(), fop, 42));\n+    }\n+\n+    @Test\n+    public void testLimitsExceeded() throws Exception {\n+        var methods = ClassFile.of().parse(TestOpBuilderLimits.class.getResourceAsStream(\"TestOpBuilderLimits$$CM.class\").readAllBytes()).methods();\n+        Assertions.assertTrue(methods.stream().anyMatch(m -> m.methodName().equalsString(\"lambda$0\")), \"ops limit exceeded\");\n+        Assertions.assertTrue(methods.stream().anyMatch(m -> m.methodName().equalsString(\"$exterType1\")), \"types limit exceeded\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpBuilderLimits.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}