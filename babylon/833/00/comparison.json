{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.Supplier;\n@@ -190,1 +191,7 @@\n-    final Block.Builder builder;\n+    Block.Builder builder;\n+\n+    final Stack<Block.Builder> lambdaStack = new Stack<>();\n+\n+    \/\/ limit of the operations built by a single method\/lambda body\n+    static final int OP_LIMIT = 1000;\n+    int opCounter = 0;\n@@ -455,0 +462,8 @@\n+        \/\/ return from lambdas on stack\n+        while (!lambdaStack.isEmpty()) {\n+            var lambdaBuilder = builder;\n+            builder = lambdaStack.pop();\n+            var l = builder.op(lambda(JavaType.parameterized(JavaType.type(Supplier.class), JavaType.type(Op.class)), lambdaBuilder.parentBody()));\n+            builder.op(return_(builder.op(cast(JavaType.type(Op.class), builder.op(invoke(MethodRef.method(Supplier.class, \"get\", Object.class), l))))));\n+        }\n+\n@@ -460,0 +475,6 @@\n+        if (++opCounter == OP_LIMIT) {\n+            \/\/ continue building in a lambda\n+            opCounter = 0;\n+            lambdaStack.push(builder);\n+            builder = Body.Builder.of(builder.parentBody(), functionType(JavaType.type(Supplier.class))).entryBlock();\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"}]}