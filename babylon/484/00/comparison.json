{"files":[{"patch":"@@ -29,1 +29,1 @@\n-    <artifactId>hat-jextracted-cuda<\/artifactId>\n+    <artifactId>hat-extraction-cuda<\/artifactId>\n@@ -36,1 +36,1 @@\n-    <build>\n+    <build> \n@@ -38,26 +38,19 @@\n- <plugin>\n-              <groupId>org.codehaus.mojo<\/groupId>\n-              <artifactId>exec-maven-plugin<\/artifactId>\n-              <version>3.1.0<\/version>\n-              <configuration>exec.skip<\/configuration>\n-            <\/plugin>\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n+          <plugin>\n+             <groupId>org.apache.maven.plugins<\/groupId>\n+             <artifactId>maven-antrun-plugin<\/artifactId>\n+             <version>1.8<\/version>\n+             <executions>\n+                <execution>\n+                   <id>1<\/id>\n+                   <phase>package<\/phase>\n+                   <goals>\n+                       <goal>run<\/goal>\n+                   <\/goals>\n+                   <configuration>\n+                       <target>\n+                          <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toFile=\"${hat.build}\/${project.artifactId}-${project.version}.jar\"\/>\n+                       <\/target>\n+                    <\/configuration>\n+                <\/execution>\n+             <\/executions>\n+           <\/plugin> \n","filename":"hat\/extractions\/cuda\/pom.xml","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    <artifactId>hat-jextracted-opencl<\/artifactId>\n+    <artifactId>hat-extraction-opencl<\/artifactId>\n@@ -38,38 +38,0 @@\n-           <plugin>\n-              <groupId>org.codehaus.mojo<\/groupId>\n-              <artifactId>exec-maven-plugin<\/artifactId>\n-              <version>3.1.0<\/version>\n-              <executions>\n-                 <execution>\n-                   <id>cmake-B<\/id>\n-                   <phase>generate-sources<\/phase>\n-                   <goals>\n-                      <goal>exec<\/goal>\n-                   <\/goals>\n-                   <configuration>\n-                     <executable>cmake<\/executable>\n-                     <arguments>\n-                        <argument>-DHAT_TARGET=${hat.build}<\/argument>\n-                        <argument>-B<\/argument>\n-                        <argument>${hat.build}\/extract-opencl-cmake-build-debug<\/argument>\n-                     <\/arguments>\n-                   <\/configuration>\n-                <\/execution>\n-                <execution>\n-                   <id>cmake--build<\/id>\n-                   <phase>generate-sources<\/phase>\n-                   <goals>\n-                      <goal>exec<\/goal>\n-                   <\/goals>\n-                   <configuration>\n-                      <executable>cmake<\/executable>\n-                      <arguments>\n-                         <argument>--build<\/argument>\n-                         <argument>${hat.build}\/extract-opencl-cmake-build-debug<\/argument>\n-                         <argument>--target<\/argument>\n-                         <argument>extract_opencl<\/argument>\n-                      <\/arguments>\n-                   <\/configuration>\n-                <\/execution>\n-             <\/executions>\n-          <\/plugin>\n@@ -89,1 +51,1 @@\n-                          <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n+                          <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toFile=\"${hat.build}\/${project.artifactId}-${project.version}.jar\"\/>\n","filename":"hat\/extractions\/opencl\/pom.xml","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    <artifactId>hat-jextracted-opengl<\/artifactId>\n+    <artifactId>hat-extraction-opengl<\/artifactId>\n@@ -38,21 +38,5 @@\n-\n-  <plugin>\n-              <groupId>org.codehaus.mojo<\/groupId>\n-              <artifactId>exec-maven-plugin<\/artifactId>\n-              <version>3.1.0<\/version>\n-              <executions>\n-                 <execution>\n-                   <id>cmake-B<\/id>\n-                   <phase>generate-sources<\/phase>\n-                   <goals>\n-                      <goal>exec<\/goal>\n-                   <\/goals>\n-                   <configuration>\n-                     <executable>cmake<\/executable>\n-                     <arguments>\n-                        <argument>-DHAT_TARGET=${hat.build}<\/argument>\n-                        <argument>-B<\/argument>\n-                        <argument>${hat.build}\/extract-opengl-cmake-build-debug<\/argument>\n-                     <\/arguments>\n-                   <\/configuration>\n-                <\/execution>\n+          <plugin>\n+             <groupId>org.apache.maven.plugins<\/groupId>\n+             <artifactId>maven-antrun-plugin<\/artifactId>\n+             <version>1.8<\/version>\n+             <executions>\n@@ -60,2 +44,2 @@\n-                   <id>cmake--build<\/id>\n-                   <phase>generate-sources<\/phase>\n+                   <id>1<\/id>\n+                   <phase>package<\/phase>\n@@ -63,1 +47,1 @@\n-                      <goal>exec<\/goal>\n+                       <goal>run<\/goal>\n@@ -66,8 +50,4 @@\n-                      <executable>cmake<\/executable>\n-                      <arguments>\n-                         <argument>--build<\/argument>\n-                         <argument>${hat.build}\/extract-opengl-cmake-build-debug<\/argument>\n-                         <argument>--target<\/argument>\n-                         <argument>extract_opengl<\/argument>\n-                      <\/arguments>\n-                   <\/configuration>\n+                       <target>\n+                          <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toFile=\"${hat.build}\/${project.artifactId}-${project.version}.jar\"\/>\n+                       <\/target>\n+                    <\/configuration>\n@@ -76,22 +56,1 @@\n-          <\/plugin>\n-\n-\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>package<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n+           <\/plugin>\n","filename":"hat\/extractions\/opengl\/pom.xml","additions":14,"deletions":55,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n@@ -57,0 +56,44 @@\n+ <build>\n+        <plugins>\n+            <plugin>\n+                <inherited>false<\/inherited>\n+                <groupId>org.codehaus.mojo<\/groupId>\n+                <artifactId>exec-maven-plugin<\/artifactId>\n+                <version>3.1.0<\/version>\n+                <executions>\n+                    <execution>\n+                        <id>cmake-B<\/id>\n+                        <phase>generate-sources<\/phase>\n+                        <goals>\n+                            <goal>exec<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <executable>cmake<\/executable>\n+                            <arguments>\n+                                <argument>-DHAT_TARGET=${hat.build}<\/argument>\n+                                <argument>-B<\/argument>\n+                                <argument>cmake-build-debug<\/argument>\n+                            <\/arguments>\n+                        <\/configuration>\n+                    <\/execution>\n+                    <execution>\n+                        <id>cmake--build<\/id>\n+                        <phase>generate-sources<\/phase>\n+                        <goals>\n+                            <goal>exec<\/goal>\n+                        <\/goals>\n+                        <configuration>\n+                            <executable>cmake<\/executable>\n+                            <arguments>\n+                                <argument>--build<\/argument>\n+                                <argument>cmake-build-debug<\/argument>\n+                                <argument>--target<\/argument>\n+                                <argument>extract<\/argument>\n+                            <\/arguments>\n+                        <\/configuration>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+\n","filename":"hat\/extractions\/pom.xml","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Set;\n-\n-public class Hat {\n-    public static void main(String[] argArr) throws IOException, InterruptedException {\n-\n-        Path userDir = Path.of(System.getProperty(\"user.dir\"));\n-        var project = new Job.Project(userDir.getFileName().toString().equals(\"intellij\") ? userDir.getParent() : userDir);\n-\n-        var mac = new Job.Mac(project.id(\"mac-1.0\"), Set.of());\n-        var linux = new Job.Linux(project.id(\"linux-1.0\"), Set.of());\n-        var opencl = new Job.OpenCL(project.id(\"opencl-1.0\"),  Set.of());\n-        var opengl = new Job.OpenGL(project.id(\"opengl-1.0\"),  Set.of());\n-        var cuda = new Job.Cuda(project.id(\"cuda-1.0\"),  Set.of());\n-\n-        var core = Job.Jar.of(project.id(\"core-1.0\"));\n-        var backend_ffi_native = Job.CMake.of(project.id(\"backend-ffi-1.0\"), core);\n-        var ffiSharedBackend = Job.Jar.of(project.id(\"backend-ffi-shared-1.0\"), core, backend_ffi_native);\n-        var backend_ffi_cuda = Job.Jar.of(project.id(\"backend-ffi-cuda-1.0\"), core, cuda, ffiSharedBackend);\n-        var backend_ffi_opencl = Job.Jar.of(project.id(\"backend-ffi-opencl-1.0\"), opencl, core, ffiSharedBackend);\n-        var backend_ffi_mock = Job.Jar.of(project.id(\"backend-ffi-mock-1.0\"), core, ffiSharedBackend);\n-        var backend_mt_java = Job.Jar.of(project.id(\"backend-java-mt-1.0\"), core);\n-        var backend_seq_java = Job.Jar.of(project.id(\"backend-java-mt-1.0\"), core);\n-        var example_mandel = Job.RunnableJar.of(project.id(\"example-mandel-1.0\"), core);\n-        var example_life = Job.RunnableJar.of(project.id(\"example-life-1.0\"), core);\n-        var example_squares = Job.RunnableJar.of(project.id(\"example-squares-1.0\"), core);\n-        var example_heal = Job.RunnableJar.of(project.id(\"example-heal-1.0\"), core);\n-        var example_violajones = Job.RunnableJar.of(project.id(\"example-violajones-1.0\"), core);\n-        if (mac.isAvailable()) {\n-\n-            var extractions_opengl = Job.JExtract.of(project.id(\"extraction-opengl-1.0\"),\n-                    mac.isAvailable() ? Job.JExtract.Mac.of(opengl, \"GLUT\", \"OpenGL\") : Job.JExtract.Linux.of(opengl, \"GLUT\", \"OpenGL\"),\n-                    mac, opengl, core);\n-            var extractions_opencl = Job.JExtract.of(project.id(\"extraction-opencl-1.0\"),\n-                    mac.isAvailable() ? Job.JExtract.Mac.of(opencl, \"OpenCL\") : Job.JExtract.Linux.of(opengl, \"OpenCL\"),\n-                    mac, opencl, core);\n-            var wraps_wrap = Job.Jar.of(project.id(\"wrap-wrap-1.0\"));\n-            var wraps_clwrap = Job.Jar.of(project.id(\"wrap-clwrap-1.0\"), extractions_opencl, wraps_wrap);\n-\n-            var wraps_glwrap = Job.Jar.of(project.id(\"wrap-glwrap-1.0\"),\n-                    Set.of(project.rootPath().resolve(\"wraps\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLCallbackEventHandler.java\")), \/\/exclude\n-                    extractions_opengl,\n-                    wraps_wrap);\n-            var example_nbody = Job.RunnableJar.of(project.id(\"example-nbody-1.0\"), Set.of(wraps_glwrap, wraps_clwrap, wraps_wrap, core, mac));\n-        }\n-        \/\/if (argArr.length == 0) {\n-          \/\/  project.start(\"run\", \"ffi-opencl\", \"nbody\");\n-        \/\/} else {\n-            project.start(argArr);\n-        \/\/}\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/hat\/Hat.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,1312 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import com.sun.source.util.JavacTask;\n-\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-\n-public class Job {\n-    @FunctionalInterface\n-    public interface Progress extends BiConsumer<Dependency, String> {\n-        void accept(Dependency a, String s);\n-    }\n-\n-    public interface Dependency {\n-        Project.Id id();\n-\n-        Set<Dependency> dependencies();\n-\n-        interface WithPath extends Dependency {\n-        }\n-\n-        interface Buildable extends Dependency {\n-            boolean build();\n-\n-            boolean clean();\n-\n-            List<Path> generatedPaths();\n-        }\n-\n-        interface Executable extends Dependency {\n-        }\n-\n-        interface ExecutableJar extends Executable {\n-            boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> args);\n-        }\n-\n-        interface Runnable extends Executable {\n-            boolean run();\n-        }\n-\n-        interface Optional extends Dependency {\n-            boolean isAvailable();\n-        }\n-    }\n-\n-\n-    public static abstract class AbstractArtifact<T extends AbstractArtifact<T>> implements Dependency {\n-        protected final Project.Id id;\n-\n-        @Override\n-        public Project.Id id() {\n-            return id;\n-        }\n-\n-        final private Set<Dependency> dependencies = new LinkedHashSet<>();\n-\n-        @Override\n-        public Set<Dependency> dependencies() {\n-            return dependencies;\n-        }\n-\n-        AbstractArtifact(Project.Id id, Set<Dependency> dependencies) {\n-            this.id = id;\n-            this.dependencies.addAll(dependencies);\n-        }\n-    }\n-\n-    public static abstract class AbstractArtifactWithPath<T extends AbstractArtifact<T>> extends AbstractArtifact<T>\n-            implements Dependency.WithPath {\n-\n-        AbstractArtifactWithPath(Project.Id id, Set<Dependency> dependencies) {\n-            super(id, dependencies);\n-            if (!Files.exists(id.path())) {\n-                System.err.println(\"The path does not exist: \" + id.path());\n-\n-            }\n-        }\n-    }\n-\n-    public static class Project {\n-\n-        public record Id(Project project, String projectName, String hyphenatedName, String version, Path path,\n-                         String name) {\n-        }\n-\n-        private static Id id(Project project, String hyphenatedName) {\n-            int lastIndex = hyphenatedName.lastIndexOf('-');\n-            var version = hyphenatedName.substring(lastIndex + 1);\n-            String[] splitString = hyphenatedName.substring(0, lastIndex).split(\"-\");\n-            var runName = \"\";\n-            var dirName = \"\";\n-            if (splitString.length == 3) {\n-                runName = splitString[1] + \"-\" + splitString[2];\n-                dirName = splitString[0] + \"s\/\" + splitString[1] + \"\/\" + splitString[2];\n-            } else if (splitString.length == 2) {\n-                runName = splitString[1];\n-                dirName = splitString[0] + \"s\/\" + splitString[1];\n-            } else if (splitString.length == 1) {\n-                runName = splitString[0];\n-                dirName = splitString[0];\n-            }\n-            var id = new Id(project, project.name(), hyphenatedName, version, project.rootPath().resolve(dirName), runName);\n-            return id;\n-        }\n-\n-        Id id(String id) {\n-            return id(this, id);\n-        }\n-\n-\n-        public static class Dag {\n-            static void recurse(Map<Dependency, Set<Dependency>> map, Dependency from) {\n-                var set = map.computeIfAbsent(from, _ -> new LinkedHashSet<>());\n-                var deps = from.dependencies();\n-                deps.forEach(dep -> {\n-                    set.add(dep);\n-                    recurse(map, dep);\n-                });\n-            }\n-\n-            static Set<Dependency> processOrder(Set<Dependency> jars) {\n-                Map<Dependency, Set<Dependency>> map = new LinkedHashMap<>();\n-                Set<Dependency> ordered = new LinkedHashSet<>();\n-                jars.forEach(jar -> recurse(map, jar));\n-                while (!map.isEmpty()) {\n-                    var leaves = map.entrySet().stream()\n-                            .filter(e -> e.getValue().isEmpty())    \/\/ if this entry has zero dependencies\n-                            .map(Map.Entry::getKey)                 \/\/ get the key\n-                            .collect(Collectors.toSet());\n-                    map.forEach((k, v) ->\n-                            leaves.forEach(v::remove)\n-                    );\n-                    leaves.forEach(leaf -> {\n-                        map.remove(leaf);\n-                        ordered.add(leaf);\n-                    });\n-                }\n-                return ordered;\n-            }\n-\n-            static Set<Dependency> build(Set<Dependency> jars) {\n-                var ordered = processOrder(jars);\n-                ordered.stream().filter(d -> d instanceof Dependency.Buildable).map(d -> (Dependency.Buildable) d).forEach(Dependency.Buildable::build);\n-                return ordered;\n-            }\n-\n-            static Set<Dependency> clean(Set<Dependency> jars) {\n-                var ordered = processOrder(jars);\n-                ordered.stream().filter(d -> d instanceof Dependency.Buildable).map(d -> (Dependency.Buildable) d).forEach(Dependency.Buildable::build);\n-                return ordered;\n-            }\n-\n-        }\n-\n-        private final Path rootPath;\n-        private final Path buildPath;\n-        private final Path confPath;\n-        private final Progress progress;\n-        private final Map<String, Dependency> artifacts = new LinkedHashMap<>();\n-\n-        public String name() {\n-            return rootPath().getFileName().toString();\n-        }\n-\n-        public Path rootPath() {\n-            return rootPath;\n-        }\n-\n-        public Path buildPath() {\n-            return buildPath;\n-        }\n-\n-        public Path confPath() {\n-            return confPath;\n-        }\n-\n-        public Project(Path root, Progress progress) {\n-            this.rootPath = root;\n-            if (!Files.exists(root)) {\n-                throw new IllegalArgumentException(\"Root path for project does not exist: \" + root);\n-            }\n-            this.buildPath = root.resolve(\"build\");\n-            this.confPath = root.resolve(\"conf\");\n-            this.progress = progress;\n-        }\n-\n-        public Project(Path root) {\n-            this(root, (a, s) -> System.out.println(a.id().project().name() + \":\" + a.id().name() + \":\" + s));\n-        }\n-\n-        public Dependency add(Dependency dependency) {\n-            artifacts.put(dependency.id().hyphenatedName, dependency);\n-            return dependency;\n-        }\n-\n-        public Dependency getArtifact(String dependency) {\n-            return artifacts.get(dependency);\n-        }\n-\n-        public void rmdir(Path... paths) {\n-            for (Path path : paths) {\n-                \/\/  System.out.println(\"rm -rf \"+path.getFileName().toString());\n-                if (Files.exists(path)) {\n-                    try (var files = Files.walk(path)) {\n-                        files.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n-                    } catch (Throwable t) {\n-                        throw new RuntimeException(t);\n-                    }\n-                }\n-            }\n-        }\n-\n-        public void clean(Path... paths) {\n-            for (Path path : paths) {\n-                if (Files.exists(path)) {\n-                    \/\/ System.out.println(\"rm -rf \"+path.getFileName().toString());\n-                    \/\/ System.out.println(\"mkdir -p \"+path.getFileName().toString());\n-                    try (var files = Files.walk(path)) {\n-                        files.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n-                        mkdir(path);\n-                    } catch (Throwable t) {\n-                        throw new RuntimeException(t);\n-                    }\n-                }\n-            }\n-        }\n-\n-        public void mkdir(Path... paths) {\n-            for (Path path : paths) {\n-                if (!Files.exists(path)) {\n-                    try {\n-                        Files.createDirectories(path);\n-                    } catch (Throwable t) {\n-                        throw new RuntimeException(t);\n-                    }\n-                }\n-            }\n-        }\n-\n-        public Set<Dependency> clean(Set<Dependency> dependencies) {\n-            return Dag.clean(dependencies);\n-        }\n-\n-        public void clean(List<String> names) {\n-            if (names.isEmpty()) {\n-                rmdir(buildPath());\n-            } else {\n-                clean(names.stream().map(this::getArtifact).collect(Collectors.toSet()));\n-            }\n-        }\n-\n-        public Set<Dependency> build(Set<Dependency> dependencies) {\n-            return Dag.build(dependencies);\n-        }\n-\n-        public Set<Dependency> build(Dependency... dependencies) {\n-            return build(Set.of(dependencies));\n-        }\n-\n-        public Set<Dependency> build(List<String> names) {\n-            if (names.isEmpty()) {\n-                return build(new HashSet<>(artifacts.values()));\n-            } else {\n-                return build(names.stream().map(this::getArtifact).collect(Collectors.toSet()));\n-            }\n-        }\n-\n-        void start(String... argArr) throws IOException, InterruptedException {\n-            var args = new ArrayList<>(List.of(argArr));\n-\n-            Map<String, String> opts = Map.of(\n-                    \"bld\", \"Will Bld\",\n-                    \"help\", \"\"\"\n-                             help: This list\n-                              bld: ...buildables | all if none\n-                                   bld\n-                                   bld ffi-opencl\n-                              run: [ffi|my|seq]-[opencl|java|cuda|mock|hip] runnable (i.e has name.Main class)\n-                                   run ffi-opencl mandel\n-                                   run ffi-openc nbody\n-                            clean: ...buildables | all if none\n-                                   clean\n-                                   clean ffi-opencl\n-                            \"\"\",\n-                    \"clean\", \"Will clean\",\n-                    \"run\", \"Will run\"\n-            );\n-            record Action(String name, String help, List<String> args) {\n-                int size() {\n-                    return args.size();\n-                }\n-\n-                boolean isEmpty() {\n-                    return args.isEmpty();\n-                }\n-\n-                String get() {\n-                    var got = (size() > 0) ? args.removeFirst() : null;\n-                    return got;\n-                }\n-\n-                String str() {\n-                    return name + \" '\" + String.join(\" \", args) + \"'\";\n-                }\n-\n-            }\n-\n-            List<Action> actions = new ArrayList<>();\n-            while (!args.isEmpty()) {\n-                String arg = args.removeFirst();\n-                if (opts.containsKey(arg)) {\n-                    List<String> subList = new ArrayList<>();\n-                    while (!args.isEmpty() &&\n-                            args.getFirst() instanceof String next\n-                            && !opts.containsKey(next)) {\n-                        subList.add(args.removeFirst());\n-                    }\n-                    actions.add(new Action(arg, opts.get(arg), subList));\n-                } else {\n-                    System.err.println(\"What \" + arg + \" \" + String.join(\" \", args));\n-                }\n-            }\n-            if (actions.stream().anyMatch(a -> a.name.equals(\"help\"))) {\n-                actions.forEach(action ->\n-                        System.out.println(action.help)\n-                );\n-            } else {\n-                for (var action : actions) {\n-                    switch (action.name()) {\n-                        case \"clean\" -> clean(action.args);\n-                        case \"bld\" -> build(action.args);\n-                        case \"run\" -> {\n-                            if (action.get() instanceof String backendName && !action.isEmpty() && getArtifact(\"backend-\" + backendName + \"-1.0\") instanceof Jar backend) {\n-                                if (action.get() instanceof String runnableName && getArtifact(\"example-\" + runnableName + \"-1.0\") instanceof Dependency.ExecutableJar runnable) {\n-                                    runnable.run(runnable.id().name() + \".Main\", build(runnable, backend), args);\n-                                } else {\n-                                    System.out.println(\"Failed to find runnable \");\n-                                }\n-                            } else {\n-                                System.out.println(\"Failed to find backend !\");\n-                            }\n-                        }\n-                        default -> {\n-                        }\n-                    }\n-                }\n-            }\n-\n-        }\n-    }\n-\n-\n-    public static class Jar extends AbstractArtifactWithPath<Jar> implements Dependency.Buildable {\n-        public interface JavacProgress extends Progress {\n-\n-            default void javacCommandLine(Dependency a, List<String> opts, List<JavaSource> sources) {\n-                accept(a, \"javac \" + String.join(\" \", opts) + \" \" + String.join(\" \", sources.stream().map(JavaSource::getName).collect(Collectors.toList())));\n-            }\n-\n-            default void javacInfo(Dependency a, String s) {\n-                accept(a, \"JAVAC : I\" + s);\n-            }\n-\n-            default void javacProgress(Dependency a, String s) {\n-                accept(a, \"JAVAC : \" + s);\n-            }\n-\n-            default void javacError(Dependency a, String s) {\n-                accept(a, \"JAVAC : !!!\" + s);\n-                throw new RuntimeException(s);\n-            }\n-\n-            default void javacWarning(Dependency a, String s) {\n-                accept(a, \"JAVAC : W \" + s);\n-            }\n-\n-            default void javacClean(Dependency a, Path... paths) {\n-                accept(a, \"clean \" + String.join(\" \", Arrays.stream(paths).map(Path::toString).toList()));\n-            }\n-\n-            default void javacNote(Dependency a, String s) {\n-                accept(a, \"JAVAC :\" + s);\n-            }\n-\n-            default void javacVerbose(Dependency a, String s) {\n-                accept(a, \"JAVAC :\" + s);\n-            }\n-\n-            default void javacCreatedClass(Dependency a, String s) {\n-                accept(a, \"JAVAC_CREATED_CLASS :\" + s);\n-            }\n-\n-            static JavacProgress adapt(Project.Id id) {\n-                return (id.project().progress instanceof JavacProgress progress) ? progress : new JavacProgress() {\n-                    @Override\n-                    public void accept(Dependency a, String s) {\n-                        id.project().progress.accept(a, s);\n-                    }\n-                };\n-            }\n-\n-        }\n-\n-        public interface JarProgress extends Progress {\n-            default void jarProgress(Dependency a, String s) {\n-                accept(a, \"JAR :\" + s);\n-            }\n-\n-            default void jarInfo(Dependency a, String s) {\n-                accept(a, \"JAR : I\" + s);\n-            }\n-\n-            default void jarCommandLine(Dependency a, Path path, List<Path> paths) {\n-                accept(a, \"jar cvf \" + path + \" \" + String.join(paths.stream().map(Path::toString).collect(Collectors.joining(\" \"))));\n-            }\n-\n-            default void jarClean(Dependency a, Path... paths) {\n-                accept(a, \"clean \" + String.join(\" \", Arrays.stream(paths).map(Path::toString).toList()));\n-            }\n-\n-            default void jarError(Dependency a, String s) {\n-                accept(a, \"JAR : !!!\" + s);\n-                throw new RuntimeException(s);\n-            }\n-\n-            default void jarWarning(Dependency a, String s) {\n-                accept(a, \"JAR : W \" + s);\n-            }\n-\n-            default void jarNote(Dependency a, String s) {\n-                accept(a, \"JAR :\" + s);\n-            }\n-\n-            static JarProgress adapt(Project.Id id) {\n-                return (id.project.progress instanceof JarProgress progress) ? progress : new JarProgress() {\n-                    @Override\n-                    public void accept(Dependency a, String s) {\n-                        id.project.progress.accept(a, s);\n-                    }\n-                };\n-            }\n-        }\n-\n-        final Set<Path> exclude;\n-\n-        private Jar(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n-            super(id, dependencies);\n-            this.exclude = exclude;\n-\n-            if (!Files.exists(javaSourcePath())) {\n-                var jsp = javaSourcePath();\n-                System.out.println(\"Failed to find java source \" + jsp + \" path for \" + id.name());\n-            }\n-            id.project.add(this);\n-        }\n-\n-        public static Jar of(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n-            return new Jar(id, exclude, dependencies);\n-        }\n-\n-        public static Jar of(Project.Id id, Set<Dependency> dependencies) {\n-            return new Jar(id, Set.of(), dependencies);\n-        }\n-\n-        public static Jar of(Project.Id id, Set<Path> exclude, Dependency... dependencies) {\n-            return of(id, exclude, Set.of(dependencies));\n-        }\n-\n-        public static Jar of(Project.Id id, Dependency... dependencies) {\n-            return of(id, Set.of(), Set.of(dependencies));\n-        }\n-\n-        public static class JavaSource extends SimpleJavaFileObject {\n-            Path path;\n-\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                try {\n-                    return Files.readString(Path.of(toUri()));\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-\n-            JavaSource(Path path) {\n-                super(path.toUri(), Kind.SOURCE);\n-                this.path = path;\n-            }\n-        }\n-\n-        public Path jarFile() {\n-            return id().project().buildPath().resolve(id().hyphenatedName() + \".jar\");\n-        }\n-\n-        @Override\n-        public List<Path> generatedPaths() {\n-            throw new IllegalStateException(\"who called me\");\n-        }\n-\n-\n-        @Override\n-        public boolean clean() {\n-            RunnableJar.JavacProgress.adapt(id()).javacClean(this, classesDir(), jarFile());\n-            RunnableJar.JarProgress.adapt(id()).jarClean(this, classesDir(), jarFile());\n-            id().project().clean(classesDir(), jarFile());\n-            return true;\n-        }\n-\n-        @Override\n-        public boolean build() {\n-            List<String> opts = new ArrayList<>(\n-                    List.of(\n-                            \"--source=26\",\n-                            \"--enable-preview\",\n-                            \"--add-modules=jdk.incubator.code\",\n-                            \"--add-exports=jdk.incubator.code\/jdk.incubator.code.dialect.java.impl=ALL-UNNAMED\",\n-                            \"-g\",\n-                            \"-d\", classesDirName()\n-                    ));\n-            var deps = classPath(Project.Dag.processOrder(dependencies()));\n-            if (!deps.isEmpty()) {\n-                opts.addAll(List.of(\n-                        \"--class-path=\" + deps\n-                ));\n-            }\n-            opts.addAll(List.of(\n-                            \"--source-path=\" + javaSourcePathName()\n-                    )\n-            );\n-\n-            JavacProgress javacProgress = JavacProgress.adapt(id());\n-\n-            JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n-            javacProgress.javacClean(this, classesDir());\n-            id().project().clean(classesDir());\n-\n-            if (Files.exists(javaSourcePath())) {\n-                try (var files = Files.walk(javaSourcePath())) {\n-                    var listOfSources = files.filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".java\") && !exclude.contains(p)).map(JavaSource::new).toList();\n-\n-                    javacProgress.javacCommandLine(this, opts, listOfSources);\n-                    var diagnosticListener = new DiagnosticListener<JavaFileObject>() {\n-                        @Override\n-                        public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n-                            if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {\n-                                javacProgress.javacError(Jar.this, diagnostic.toString());\n-                            } else if (diagnostic.getKind() == Diagnostic.Kind.WARNING) {\n-                                javacProgress.javacWarning(Jar.this, diagnostic.toString());\n-                            } else if (diagnostic.getKind() == Diagnostic.Kind.MANDATORY_WARNING) {\n-                                javacProgress.javacWarning(Jar.this, \"!!\" + diagnostic.toString());\n-                            } else if (diagnostic.getKind() == Diagnostic.Kind.NOTE) {\n-                                javacProgress.javacNote(Jar.this, diagnostic.toString());\n-                            }\n-                            javacProgress.javacProgress(Jar.this, diagnostic.getKind() + \":\" + diagnostic.toString());\n-                        }\n-                    };\n-                    ((JavacTask) javac.getTask(\n-                            new PrintWriter(System.err),\n-                            javac.getStandardFileManager(diagnosticListener, null, null),\n-                            diagnosticListener,\n-                            opts,\n-                            null,\n-                            listOfSources\n-                    )).generate().forEach(gc ->\n-                            javacProgress.javacCreatedClass(this, gc.getName())\n-                    );\n-\n-                    List<Path> dirsToJar = new ArrayList<>(List.of(classesDir()));\n-                    if (Files.exists(javaResourcePath())) {\n-                        dirsToJar.add(javaResourcePath());\n-                    }\n-                    var jarStream = new JarOutputStream(Files.newOutputStream(jarFile()));\n-                    JarProgress jarProgress = JarProgress.adapt(id());\n-\n-                    record RootAndPath(Path root, Path path) {\n-                    }\n-                    dirsToJar.forEach(r -> {\n-                        try {\n-                            jarProgress.jarCommandLine(this, jarFile(), dirsToJar);\n-\n-                            Files.walk(r)\n-                                    .filter(p -> !Files.isDirectory(p))\n-                                    .map(p -> new RootAndPath(r, p))\n-                                    .sorted(Comparator.comparing(RootAndPath::path))\n-                                    .forEach(\n-                                            rootAndPath -> {\n-                                                try {\n-                                                    var entry = new JarEntry(rootAndPath.root.relativize(rootAndPath.path).toString());\n-                                                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n-                                                    jarStream.putNextEntry(entry);\n-                                                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n-                                                    jarStream.closeEntry();\n-                                                } catch (IOException e) {\n-                                                    throw new RuntimeException(e);\n-                                                }\n-                                            });\n-\n-\n-                        } catch (Exception e) {\n-                            throw new RuntimeException(e);\n-                        }\n-                    });\n-\n-                    jarStream.finish();\n-                    jarStream.close();\n-                    return true;\n-                } catch (Exception e) {\n-                    \/\/   println(e.getMessage());\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                return true;\n-            }\n-        }\n-\n-        protected String classPath(Set<Dependency> dependencies) {\n-            return String.join(\":\", dependencies.stream().filter(p ->\n-                    p instanceof Jar).map(a -> (Jar) a).map(Jar::jarFileName).toList());\n-        }\n-\n-        protected String classPathWithThisLast(Set<Dependency> dependencies) {\n-            Set<Dependency> all = new LinkedHashSet<>(dependencies);\n-            all.remove(this);\n-            all.add(this);\n-            return String.join(\":\", all.stream().filter(p ->\n-                    p instanceof Jar).map(a -> (Jar) a).map(Jar::jarFileName).toList());\n-        }\n-\n-        private Path classesDir() {\n-            return id().project().buildPath().resolve(id().hyphenatedName() + \".classes\");\n-        }\n-\n-        private String classesDirName() {\n-            return classesDir().toString();\n-        }\n-\n-        private String jarFileName() {\n-            return jarFile().toString();\n-        }\n-\n-        private Path javaResourcePath() {\n-            return id().path().resolve(\"src\/main\/resources\");\n-\n-        }\n-\n-        private String javaResourcePathName() {\n-            return javaResourcePath().toString();\n-        }\n-\n-        private String javaSourcePathName() {\n-            return javaSourcePath().toString();\n-        }\n-\n-        protected Path javaSourcePath() {\n-            return id().path().resolve(\"src\/main\/java\");\n-        }\n-    }\n-\n-    public static class RunnableJar extends Jar implements Dependency.ExecutableJar {\n-        public interface JavaProgress extends Progress {\n-            default void javaProgress(Dependency a, String s) {\n-                accept(a, \"JAVA :\" + s);\n-            }\n-\n-            default void javaInfo(Dependency a, String s) {\n-                accept(a, \"JAVA : I\" + s);\n-            }\n-\n-            default void javaCommandLine(Dependency a, String s) {\n-                accept(a, \"JAVA : \" + s);\n-            }\n-\n-            default void javaError(Dependency a, String s) {\n-                accept(a, \"JAVA : !!!\" + s);\n-                throw new RuntimeException(s);\n-            }\n-\n-            default void javaWarning(Dependency a, String s) {\n-                accept(a, \"JAVA : W \" + s);\n-            }\n-\n-            default void javaNote(Dependency a, String s) {\n-                accept(a, \"JAVA :\" + s);\n-            }\n-\n-            static JavaProgress adapt(Project.Id id) {\n-                return (id.project().progress instanceof JavaProgress progress) ? progress : new JavaProgress() {\n-                    @Override\n-                    public void accept(Dependency a, String s) {\n-                        id.project().progress.accept(a, s);\n-                    }\n-                };\n-            }\n-        }\n-\n-        private RunnableJar(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n-            super(id, exclude, dependencies);\n-            id.project.add(this);\n-        }\n-\n-        static public RunnableJar of(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n-            return new RunnableJar(id, exclude, dependencies);\n-        }\n-\n-        static public RunnableJar of(Project.Id id, Set<Path> exclude, Dependency... dependencies) {\n-            return of(id, exclude, Set.of(dependencies));\n-        }\n-\n-        static public RunnableJar of(Project.Id id, Set<Dependency> dependencies) {\n-            return new RunnableJar(id, Set.of(), dependencies);\n-        }\n-\n-        static public RunnableJar of(Project.Id id, Dependency... dependencies) {\n-            return of(id, Set.of(), Set.of(dependencies));\n-        }\n-\n-        @Override\n-        public List<Path> generatedPaths() {\n-            throw new IllegalStateException(\"who called me\");\n-        }\n-\n-        @Override\n-        public boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> args) {\n-            JavaProgress javaProgress = JavaProgress.adapt(id());\n-            List<String> opts = new ArrayList<>();\n-            opts.addAll(List.of(\n-                    \"java\",\n-                    \"--enable-preview\",\n-                    \"--enable-native-access=ALL-UNNAMED\"));\n-            if (id().name().equals(\"nbody\")) {\n-                opts.addAll(List.of(\n-                        \"-XstartOnFirstThread\"\n-                ));\n-            }\n-            opts.addAll(List.of(\n-                    \"--add-exports=jdk.incubator.code\/jdk.incubator.code.dialect.java.impl=ALL-UNNAMED\", \/\/ for OpRenderer\n-                    \"--class-path\", classPathWithThisLast(depsInOrder),\n-                    \"-Djava.library.path=\" + id().project().buildPath,\n-                    mainClassName\n-            ));\n-            opts.addAll(args);\n-            javaProgress.javaCommandLine(this, String.join(\" \", opts));\n-            try {\n-                var process = new ProcessBuilder().command(opts).redirectOutput(ProcessBuilder.Redirect.INHERIT).start();\n-                process.waitFor();\n-                return process.exitValue() == 0;\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-\n-    public static class CMake extends AbstractArtifactWithPath<CMake> implements Dependency.Buildable {\n-\n-\n-        public interface CMakeProgress extends Progress {\n-\n-            default void cmakeProgress(Dependency a, String s) {\n-                accept(a, \"CMAKE :\" + s);\n-            }\n-\n-            default void cmakeInfo(Dependency a, String s) {\n-                accept(a, \"CMAKE :\" + s);\n-            }\n-\n-            default void cmakeError(Dependency a, String s) {\n-                accept(a, \"CMAKE :!!\" + s);\n-            }\n-\n-            default void cmakeCommandLine(Dependency a, String s) {\n-                accept(a, \"CMAKE :\" + s);\n-            }\n-\n-            default void cmakeVerbose(Dependency a, String s) {\n-                accept(a, \"CMAKE :     \" + s);\n-            }\n-\n-            static CMakeProgress adapt(Project.Id id) {\n-                return (id.project().progress instanceof CMakeProgress progress) ? progress : new CMakeProgress() {\n-                    @Override\n-                    public void accept(Dependency a, String s) {\n-                        id.project().progress.accept(a, s);\n-                    }\n-                };\n-            }\n-\n-        }\n-\n-        public boolean cmake(Consumer<String> lineConsumer, List<String> tailopts) {\n-            List<String> opts = new ArrayList<>();\n-            opts.add(\"cmake\");\n-            opts.addAll(tailopts);\n-            boolean success;\n-            CMakeProgress cmakeProgres = CMakeProgress.adapt(id());\n-            cmakeProgres.cmakeCommandLine(this, String.join(\" \", opts));\n-            try {\n-                var process = new ProcessBuilder()\n-                        .command(opts)\n-                        .redirectErrorStream(true)\n-                        \/\/ .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n-                        .start();\n-                process.waitFor();\n-                new BufferedReader(new InputStreamReader(process.getInputStream())).lines()\n-                        .forEach(line -> {\n-                            lineConsumer.accept(line);\n-                            cmakeProgres.cmakeProgress(this, line);\n-                        });\n-                success = (process.exitValue() == 0);\n-\n-                if (!success) {\n-                    cmakeProgres.cmakeError(this, \"ERR \" + String.join(\" \", opts));\n-                    throw new RuntimeException(\"CMake failed\");\n-                }\n-                cmakeProgres.cmakeInfo(this, \"Done \" + String.join(\" \", opts));\n-            } catch (Exception e) {\n-                throw new IllegalStateException(e);\n-            }\n-            return success;\n-        }\n-\n-        @Override\n-        public List<Path> generatedPaths() {\n-            throw new IllegalStateException(\"who called me\");\n-        }\n-\n-        boolean cmake(Consumer<String> lineConsumer, String... opts) {\n-            return cmake(lineConsumer, List.of(opts));\n-        }\n-\n-        public boolean cmakeInit(Consumer<String> lineConsumer) {\n-            return cmake(lineConsumer, \"--fresh\", \"-DHAT_TARGET=\" + id().project().buildPath(), \"-B\", cmakeBuildDir().toString(), \"-S\", cmakeSourceDir().toString());\n-        }\n-\n-        public boolean cmakeBuildTarget(Consumer<String> lineConsumer, String target) {\n-            return cmake(lineConsumer, \"--build\", cmakeBuildDir().toString(), \"--target\", target);\n-        }\n-\n-        public boolean cmakeBuild(Consumer<String> lineConsumer) {\n-            return cmake(lineConsumer, \"--build\", cmakeBuildDir().toString());\n-        }\n-\n-        public boolean cmakeClean(Consumer<String> lineConsumer) {\n-            return cmakeBuildTarget(lineConsumer, \"clean\");\n-        }\n-\n-\n-        @Override\n-        public boolean build() {\n-            cmakeInit(_ -> {\n-            });\n-            cmakeBuild(_ -> {\n-            });\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean clean() {\n-            cmakeInit(_ -> {\n-            });\n-            cmakeClean(_ -> {\n-            });\n-            return false;\n-        }\n-\n-        final Path cmakeSourceDir;\n-        final Path cmakeBuildDir;\n-\n-        Path cmakeSourceDir() {\n-            return cmakeSourceDir;\n-        }\n-\n-        Path cmakeBuildDir() {\n-            return cmakeBuildDir;\n-        }\n-\n-        final Path CMakeLists_txt;\n-\n-        protected CMake(Project.Id gsn, Path cmakeSourceDir, Set<Dependency> dependencies) {\n-            super(gsn, dependencies);\n-            this.cmakeSourceDir = cmakeSourceDir;\n-            this.cmakeBuildDir = cmakeSourceDir.resolve(\"build\");\n-            this.CMakeLists_txt = cmakeSourceDir.resolve(\"CMakeLists.txt\");\n-        }\n-\n-        protected CMake(Project.Id id, Set<Dependency> dependencies) {\n-            this(id, id.path(), dependencies);\n-        }\n-\n-        public static CMake of(Project.Id id, Set<Dependency> dependencies) {\n-            return new CMake(id, dependencies);\n-        }\n-\n-        public static CMake of(Project.Id id, Dependency... dependencies) {\n-            return of(id, Set.of(dependencies));\n-        }\n-\n-    }\n-\n-\n-    public static class JExtract extends Jar {\n-        @Override\n-        public Path javaSourcePath() {\n-            return id.project.confPath.resolve(id().hyphenatedName).resolve(\"src\/main\/java\");\n-        }\n-\n-        public interface JExtractProgress extends Progress {\n-\n-            default void jextractProgress(Dependency a, String s) {\n-                accept(a, \"JEXTRACT :\" + s);\n-            }\n-\n-            default void jextractInfo(Dependency a, String s) {\n-                accept(a, \"JEXTRACT :\" + s);\n-            }\n-\n-            default void jextractCommandLine(Dependency a, String s) {\n-                accept(a, \"JEXTRACT :\" + s);\n-            }\n-\n-            default void jextractVerbose(Dependency a, String s) {\n-                accept(a, \"JEXTRACT :     \" + s);\n-            }\n-\n-            default void jextractError(Dependency a, String s) {\n-                accept(a, \"JEXTRACT :!!     \" + s);\n-            }\n-\n-            static JExtractProgress adapt(Project.Id id) {\n-                return (id.project().progress instanceof JExtractProgress progress) ? progress : new JExtractProgress() {\n-                    @Override\n-                    public void accept(Dependency a, String s) {\n-                        id.project().progress.accept(a, s);\n-                    }\n-                };\n-            }\n-        }\n-\n-\n-        public interface ExtractSpec {\n-            Path header();\n-\n-            List<Path> frameworks();\n-        }\n-\n-        record Mac(Path macSdkSysLibFrameWorks, Path macSysLibFrameWorks, Path header,\n-                   List<Path> frameworks) implements ExtractSpec {\n-            static Mac of(CMakeInfo cMakeInfo, String... frameworks) {\n-                var value = (String) cMakeInfo.properties.get(\"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\");\n-                Path macSdkSysLibFrameWorks = Path.of(value);\n-                Path macSysLibFrameWorks = Path.of(\"\/System\/Library\/Frameworks\");\n-                var firstName = frameworks[0];\n-                return new Mac(\n-                        macSdkSysLibFrameWorks,\n-                        macSysLibFrameWorks,\n-                        macSdkSysLibFrameWorks.resolve(firstName.toUpperCase() + \".framework\/Headers\/\" + firstName + \".h\"),\n-                        Stream.of(frameworks).map(s -> macSysLibFrameWorks.resolve(s + \".framework\/\" + s)).collect(Collectors.toList())\n-                );\n-            }\n-\n-            void writeCompileFlags(Path outputDir) {\n-                try {\n-                    Path compileFLags = outputDir.resolve(\"compile_flags.txt\");\n-                    Files.writeString(compileFLags, \"-F\" + macSdkSysLibFrameWorks + \"\\n\", StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n-                } catch (IOException e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            }\n-        }\n-        record Linux(Path macSdkSysLibFrameWorks, Path macSysLibFrameWorks, Path header,\n-                   List<Path> frameworks) implements ExtractSpec {\n-            static Mac of(CMakeInfo cMakeInfo, String... frameworks) {\n-                var value = (String) cMakeInfo.properties.get(\"\");\n-                Path macSdkSysLibFrameWorks = Path.of(value);\n-                Path macSysLibFrameWorks = Path.of(\"\/System\/Library\/Frameworks\");\n-                var firstName = frameworks[0];\n-                return new Mac(\n-                        macSdkSysLibFrameWorks,\n-                        macSysLibFrameWorks,\n-                        macSdkSysLibFrameWorks.resolve(firstName.toUpperCase() + \".framework\/Headers\/\" + firstName + \".h\"),\n-                        Stream.of(frameworks).map(s -> macSysLibFrameWorks.resolve(s + \".framework\/\" + s)).collect(Collectors.toList())\n-                );\n-            }\n-\n-            void writeCompileFlags(Path outputDir) {\n-                try {\n-                    Path compileFLags = outputDir.resolve(\"compile_flags.txt\");\n-                    Files.writeString(compileFLags, \"-F\" + macSdkSysLibFrameWorks + \"\\n\", StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n-                } catch (IOException e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public boolean build() {\n-            try {\n-                id.project.mkdir(javaSourcePath());\n-\n-                List<String> opts = new ArrayList<>(List.of());\n-                opts.addAll(List.of(\n-                        \"jextract\",\n-                        \"--target-package\", id().name(),\n-                        \"--output\", javaSourcePath().toString()\n-                ));\n-                spec.frameworks().forEach(library -> opts.addAll(List.of(\n-                        \"--library\", \":\" + library\n-                )));\n-                opts.addAll(List.of(\n-                        \"--header-class-name\", id().name() + \"_h\",\n-                        spec.header().toString()\n-                ));\n-                if (spec instanceof Mac mac) {\n-                    mac.writeCompileFlags(id().project().rootPath);\n-                }\n-                boolean success;\n-                JExtractProgress jExtractProgress = JExtractProgress.adapt(id());\n-                jExtractProgress.jextractCommandLine(this, String.join(\" \", opts));\n-                try {\n-                    var process = new ProcessBuilder()\n-                            .command(opts)\n-                            .redirectErrorStream(true)\n-                            .start();\n-                    process.waitFor();\n-                    new BufferedReader(new InputStreamReader(process.getInputStream())).lines()\n-                            .forEach(s -> jExtractProgress.jextractProgress(this, s));\n-                    success = (process.exitValue() == 0);\n-                    if (!success) {\n-                        jExtractProgress.jextractError(this, \"error \" + process.exitValue());\n-                    }\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-                super.build();\n-            } catch (Exception e) {\n-                throw new IllegalStateException(e);\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean clean() {\n-            \/\/ No opp\n-            return false;\n-        }\n-\n-        final ExtractSpec spec;\n-\n-        private JExtract(Project.Id id, ExtractSpec spec, Set<Path> exclude, Set<Dependency> dependencies) {\n-            super(id, exclude, dependencies);\n-            this.spec = spec;\n-            id.project.add(this);\n-        }\n-\n-        static JExtract of(Project.Id id, ExtractSpec spec, Set<Path> exclude, Set<Dependency> dependencies) {\n-            return new JExtract(id, spec, exclude, dependencies);\n-        }\n-\n-        static JExtract of(Project.Id id, ExtractSpec spec, Set<Path> exclude, Dependency... dependencies) {\n-            return of(id, spec, exclude, Set.of(dependencies));\n-        }\n-\n-        static JExtract of(Project.Id id, ExtractSpec spec, Set<Dependency> dependencies) {\n-            return new JExtract(id, spec, Set.of(), dependencies);\n-        }\n-\n-        static JExtract of(Project.Id id, ExtractSpec spec, Dependency... dependencies) {\n-            return of(id, spec, Set.of(), Set.of(dependencies));\n-        }\n-    }\n-\n-\n-    public static abstract class CMakeInfo extends Job.CMake implements Job.Dependency.Optional {\n-       \/* interface Mapper{\n-\n-        }\n-        interface PathMapper extends Mapper{\n-            Path map(String value);\n-            PathMapper impl =  (s)->Path.of(s);\n-        }\n-        interface BooleanMapper extends Mapper{\n-            boolean map(String value);\n-            BooleanMapper impl =  (s)->Boolean.getBoolean(s);\n-        }\n-        interface StringMapper extends Mapper{\n-            String map(String value);\n-            StringMapper impl =  (s)->s;\n-        }*\/\n-\n-        Path asPath(String key) {\n-            return properties.containsKey(key) ? Path.of((String) properties.get(key)) : null;\n-        }\n-\n-        boolean asBoolean(String key) {\n-            return properties.containsKey(key) && Boolean.parseBoolean((String) properties.get(key));\n-        }\n-\n-        String asString(String key) {\n-            return (properties.containsKey(key) && properties.get(key) instanceof String s) ? s : null;\n-        }\n-\n-\n-        final String find;\n-        final String response;\n-        final static String template = \"\"\"\n-                cmake_minimum_required(VERSION 3.22.1)\n-                project(extractions)\n-                find_package(__find__)\n-                get_cmake_property(_variableNames VARIABLES)\n-                foreach (_variableName ${_variableNames})\n-                   message(STATUS \"${_variableName}=${${_variableName}}\")\n-                endforeach()\n-                \"\"\";\n-\n-        final String text;\n-\n-        final Set<String> vars;\n-        Properties properties = new Properties();\n-        final Path propertiesPath;\n-\n-        final Map<String, String> otherVarMap = new LinkedHashMap<>();\n-        final boolean available;\n-\n-        CMakeInfo(Job.Project.Id id, String find, String response, Set<String> vars, Set<Job.Dependency> buildDependencies) {\n-            super(id, id.project().confPath().resolve(\"cmake-info\").resolve(find), buildDependencies);\n-            this.find = find;\n-            this.response = response;\n-            this.vars = vars;\n-            this.text = template.replaceAll(\"__find__\", find).replaceAll(\"__response__\", response);\n-            this.propertiesPath = cmakeSourceDir().resolve(\"properties\");\n-            if (Files.exists(propertiesPath)) {\n-                properties = new Properties();\n-                try {\n-                    properties.load(Files.newInputStream(propertiesPath));\n-\n-                } catch (IOException e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            } else {\n-                id.project().mkdir(cmakeBuildDir());\n-                try {\n-                    Files.writeString(CMakeLists_txt, this.text, StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n-                    Pattern p = Pattern.compile(\"-- *([A-Za-z_0-9]+)=(.*)\");\n-                    cmakeInit((line) -> {\n-                        if (p.matcher(line) instanceof Matcher matcher && matcher.matches()) {\n-                            \/\/   System.out.println(\"GOT \"+matcher.group(1)+\"->\"+matcher.group(2));\n-                            if (vars.contains(matcher.group(1))) {\n-                                properties.put(matcher.group(1), matcher.group(2));\n-                            } else {\n-                                otherVarMap.put(matcher.group(1), matcher.group(2));\n-                            }\n-                        } else {\n-                            \/\/ System.out.println(\"skipped \" + line);\n-                        }\n-                    });\n-                    properties.store(Files.newOutputStream(propertiesPath), \"A comment\");\n-                } catch (IOException ioException) {\n-                    throw new IllegalStateException(ioException);\n-                }\n-            }\n-            available = asBoolean(response);\n-        }\n-\n-        @Override\n-        public boolean isAvailable() {\n-            return available;\n-        }\n-    }\n-\n-    public static class Mac extends Job.AbstractArtifact<Mac> implements Job.Dependency.Optional{\n-        final boolean available;\n-        Mac(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n-            super(id,  buildDependencies);\n-            available = System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n-        }\n-\n-        @Override\n-        public boolean isAvailable() {\n-            return available;\n-        }\n-    }\n-    public static class Linux extends Job.AbstractArtifact<Linux> implements Job.Dependency.Optional{\n-        final boolean available;\n-        Linux(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n-            super(id,  buildDependencies);\n-            available = System.getProperty(\"os.name\").toLowerCase().contains(\"linux\");\n-        }\n-\n-        @Override\n-        public boolean isAvailable() {\n-            return available;\n-        }\n-    }\n-    public static class OpenGL extends Job.CMakeInfo {\n-\n-        final Path glLibrary;\n-        OpenGL(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n-            super(id,  \"OpenGL\", \"OPENGL_FOUND\",Set.of(\n-                    \"OPENGL_FOUND\",\n-                    \"OPENGL_GLU_FOUND\",\n-                    \"OPENGL_gl_LIBRARY\",\n-                    \"OPENGL_glu_LIBRARY\",\n-                    \"OPENGL_INCLUDE_DIR\",\n-                    \"OPENGL_LIBRARIES\",\n-                    \"OPENGL_LIBRARY\",\n-                    \"OpenGL_FOUND\",\n-                    \"CMAKE_HOST_SYSTEM_NAME\",\n-                    \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n-                    \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\"\n-            ), buildDependencies);\n-            System.out.println(\"HERE\");\n-            glLibrary = asPath(\"OpenGL_glu_Library\");\n-        }\n-\n-    }\n-\n-   public static class OpenCL extends Job.CMakeInfo{\n-\n-\n-        OpenCL(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n-            super(id,  \"OpenCL\", \"OPENCL_FOUND\", Set.of(\n-                    \"OPENCL_FOUND\",\n-                    \"CMAKE_HOST_SYSTEM_NAME\",\n-                    \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n-                    \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\",\n-                    \"OpenCL_FOUND\",\n-                    \"OpenCL_INCLUDE_DIRS\",\n-                    \"OpenCL_LIBRARY\",\n-                    \"OpenCL_VERSION_STRING\"\n-            ), buildDependencies);\n-\n-        }\n-    }\n-  public static   class Cuda extends Job.CMakeInfo{\n-        Cuda(Job.Project.Id id, Set<Job.Dependency> buildDependencies) {\n-            super(id,  \"CUDAToolkit\", \"CUDATOOLKIT_FOUND\",Set.of(\n-                    \"CUDATOOLKIT_FOUND\",\n-                    \"CUDA_OpenCL_LIBRARY\",\n-                    \"CUDA_cuFile_LIBRARY\",\n-                    \"CUDA_cuda_driver_LIBRARY\",\n-                    \"CUDA_cudart_LIBRARY\",\n-                    \"CUDAToolkit_BIN_DIR\",\n-                    \"CUDAToolkit_INCLUDE_DIRS\",\n-                    \"CUDAToolkit_NVCC_EXECUTABLE\",\n-                    \"CUDAToolkit_LIBRARY_DIR\",\n-                    \"CUDAToolkit_Version\",\n-                    \"CMAKE_HOST_SYSTEM_NAME\",\n-                    \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n-                    \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\"\n-\n-            ), buildDependencies);\n-        }\n-    }\n-}\n-\n-\n","filename":"hat\/hat\/Job.java","additions":0,"deletions":1312,"binary":false,"changes":1312,"status":"deleted"},{"patch":"@@ -44,1 +44,1 @@\n-                hat-jextracted-opencl-1.0.jar  \/\/ Raw jextracted jars (hat-jextracted-opencl-1.0.jar ....)\n+                hat-extraction-opencl-1.0.jar  \/\/ Raw extraction jars (hat-extraction-opencl-1.0.jar ....)\n@@ -151,3 +151,3 @@\n-        static Script.MavenStyleProject jextracted_cuda;\n-        static Script.MavenStyleProject jextracted_opengl;\n-        static Script.MavenStyleProject jextracted_opencl;\n+        static Script.MavenStyleProject extraction_cuda;\n+        static Script.MavenStyleProject extraction_opengl;\n+        static Script.MavenStyleProject extraction_opencl;\n@@ -182,4 +182,4 @@\n-    var jextracted_opencl_dir = extractionsDir.dir(\"opencl\");\n-    if (jextracted_opencl_dir.dir(\"src\").exists()) {\n-        Artifacts.jextracted_opencl = buildDir.mavenStyleBuild(\n-             jextracted_opencl_dir, \"hat-jextracted-opencl-1.0.jar\"\n+    var extraction_opencl_dir = extractionsDir.dir(\"opencl\");\n+    if (extraction_opencl_dir.dir(\"src\").exists()) {\n+        Artifacts.extraction_opencl = buildDir.mavenStyleBuild(\n+             extraction_opencl_dir, \"hat-extraction-opencl-1.0.jar\"\n@@ -188,1 +188,1 @@\n-        print(\"no src for jextracted_opencl\");\n+        print(\"no src for extraction_opencl\");\n@@ -191,4 +191,4 @@\n-    var jextracted_opengl_dir = extractionsDir.dir(\"opengl\");\n-    if (jextracted_opengl_dir.dir(\"src\").exists()) {\n-        Artifacts.jextracted_opengl = buildDir.mavenStyleBuild(\n-            jextracted_opengl_dir, \"hat-jextracted-opengl-1.0.jar\"\n+    var extraction_opengl_dir = extractionsDir.dir(\"opengl\");\n+    if (extraction_opengl_dir.dir(\"src\").exists()) {\n+        Artifacts.extraction_opengl = buildDir.mavenStyleBuild(\n+            extraction_opengl_dir, \"hat-extraction-opengl-1.0.jar\"\n@@ -197,1 +197,1 @@\n-        print(\"no src for jextracted_opengl\");\n+        print(\"no src for extraction_opengl\");\n@@ -200,4 +200,4 @@\n-    var jextracted_cuda_dir = extractionsDir.dir(\"cuda\");\n-    if (jextracted_cuda_dir.dir(\"src\").exists()) {\n-        Artifacts.jextracted_cuda = buildDir.mavenStyleBuild(\n-            jextracted_cuda_dir, \"hat-jextracted-cuda-1.0.jar\"\n+    var extraction_cuda_dir = extractionsDir.dir(\"cuda\");\n+    if (extraction_cuda_dir.dir(\"src\").exists()) {\n+        Artifacts.extraction_cuda = buildDir.mavenStyleBuild(\n+            extraction_cuda_dir, \"hat-extraction-cuda-1.0.jar\"\n@@ -212,2 +212,2 @@\n-    if (Artifacts.jextracted_opencl != null){\n-    Artifacts.wrap_opencl = buildDir.mavenStyleBuild( wrapsDir.dir(\"opencl\"), \"hat-wrap-opencl-1.0.jar\", Artifacts.wrap_shared, Artifacts.core, Artifacts.jextracted_opencl);\n+    if (Artifacts.extraction_opencl != null){\n+    Artifacts.wrap_opencl = buildDir.mavenStyleBuild( wrapsDir.dir(\"opencl\"), \"hat-wrap-opencl-1.0.jar\", Artifacts.wrap_shared, Artifacts.core, Artifacts.extraction_opencl);\n@@ -225,2 +225,2 @@\n-if (Artifacts.jextracted_opengl != null\n-        && Artifacts.jextracted_opengl.jarFile.exists()) {\n+if (Artifacts.extraction_opengl != null\n+        && Artifacts.extraction_opengl.jarFile.exists()) {\n@@ -228,1 +228,1 @@\n-    if (!Artifacts.jextracted_opengl.jarFile.select(Script.Regex.of(\"^.*glutKeyboardFunc\\\\$func.class$\")).isEmpty()) {\n+    if (!Artifacts.extraction_opengl.jarFile.select(Script.Regex.of(\"^.*glutKeyboardFunc\\\\$func.class$\")).isEmpty()) {\n@@ -230,1 +230,1 @@\n-    }else if (!Artifacts.jextracted_opengl.jarFile.select(Script.Regex.of(\"^.*glutKeyboardFunc\\\\$callback.class$\")).isEmpty()) {\n+    }else if (!Artifacts.extraction_opengl.jarFile.select(Script.Regex.of(\"^.*glutKeyboardFunc\\\\$callback.class$\")).isEmpty()) {\n@@ -239,1 +239,1 @@\n-              buildDir, wrapsDir.dir(\"opengl\"), buildDir.jarFile(\"hat-wrap-opengl-1.0.jar\"), Artifacts.wrap_shared, Artifacts.core, Artifacts.jextracted_opengl\n+              buildDir, wrapsDir.dir(\"opengl\"), buildDir.jarFile(\"hat-wrap-opengl-1.0.jar\"), Artifacts.wrap_shared, Artifacts.core, Artifacts.extraction_opengl\n@@ -244,1 +244,1 @@\n-    if (false && Artifacts.jextracted_cuda != null ) {\n+    if (false && Artifacts.extraction_cuda != null ) {\n@@ -246,1 +246,1 @@\n-           wrapsDir.dir(\"cuda\"), \"hat-wrap-cuda-1.0.jar\", Artifacts.jextracted_cuda\n+           wrapsDir.dir(\"cuda\"), \"hat-wrap-cuda-1.0.jar\", Artifacts.extraction_cuda\n@@ -334,1 +334,1 @@\n-            Artifacts.jextracted_opencl,\n+            Artifacts.extraction_opencl,\n@@ -337,1 +337,1 @@\n-            Artifacts.jextracted_opengl\n+            Artifacts.extraction_opengl\n","filename":"hat\/hat\/bld.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n--agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y --enable-preview --source 26 hat\/run.java\n","filename":"hat\/hat\/debug","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 26 hat\/run.java ffi-opencl life\n","filename":"hat\/hat\/run-ffi-opencl-life","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 26 hat\/run.java  java-mt\n","filename":"hat\/hat\/run-java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,1 +0,0 @@\n---enable-preview --source 26 hat\/run.java ffi-opencl\n","filename":"hat\/hat\/run-opencl","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -147,4 +147,2 @@\n-          var jextracted_opencl_jar = buildDir.jarFile(\"hat-jextracted-opencl-1.0.jar\");\n-          var jextracted_opengl_jar = buildDir.jarFile(\"hat-jextracted-opengl-1.0.jar\");\n-\/\/           jextracted_opencl_jar = buildDir.jarFile(\"hat-extraction-opencl-1.0.jar\");\n- \/\/          jextracted_opengl_jar = buildDir.jarFile(\"hat-extraction-opengl-1.0.jar\");\n+          var extraction_opencl_jar = buildDir.jarFile(\"hat-extraction-opencl-1.0.jar\");\n+          var extraction_opengl_jar = buildDir.jarFile(\"hat-extraction-opengl-1.0.jar\");\n@@ -165,2 +163,2 @@\n-                          jextracted_opengl_jar,\n-                          jextracted_opencl_jar,\n+                          extraction_opengl_jar,\n+                          extraction_opencl_jar,\n","filename":"hat\/hat\/run.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,5 +0,0 @@\n---add-modules jdk.incubator.code\n---enable-preview\n--cp build\/core-1.0.jar:build\/hat-backend-ffi-opencl-1.0.jar\n---enable-native-access=ALL-UNNAMED\n--Djava.library.path=build\n","filename":"hat\/hat\/tst","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -35,3 +35,1 @@\n-        <hat.stage>${hat.root}\/stage<\/hat.stage>\n-        <hat.stage.repo>${hat.stage}\/repo<\/hat.stage.repo>\n-        <hat.stage.jextract>${hat.stage}\/jextract<\/hat.stage.jextract>\n+        <hat.conf>${hat.root}\/conf<\/hat.conf>\n@@ -59,2 +57,0 @@\n-                        <!-- <arg>- -add-exports=java.base\/jdk.internal=ALL-UNNAMED<\/arg> -->\n-                        <!-- <arg>- -add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED<\/arg> -->\n","filename":"hat\/pom.xml","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,6 +48,1 @@\n-            <artifactId>hat-backend-ffi-opencl<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat-jextracted-opencl<\/artifactId>\n+            <artifactId>hat-extraction-cuda<\/artifactId>\n","filename":"hat\/wraps\/cuda\/pom.xml","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,6 +48,1 @@\n-            <artifactId>hat-backend-ffi-opencl<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat-jextracted-opencl<\/artifactId>\n+            <artifactId>hat-extraction-opencl<\/artifactId>\n","filename":"hat\/wraps\/opencl\/pom.xml","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            <artifactId>hat-jextracted-opengl<\/artifactId>\n+            <artifactId>hat-extraction-opengl<\/artifactId>\n","filename":"hat\/wraps\/opengl\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}