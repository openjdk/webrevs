{"files":[{"patch":"@@ -4280,0 +4280,12 @@\n+# 0: symbol\n+compiler.err.quoted.method.inner.class=\\\n+    unsupported quoted method in inner class {0}\n+\n+# 0: symbol\n+compiler.err.quoted.lambda.inner.class=\\\n+    unsupported quoted lambda in inner class {0}\n+\n+# 0: symbol\n+compiler.err.quoted.mref.inner.class=\\\n+    unsupported quoted method reference in inner class {0}\n+\n@@ -4288,4 +4300,0 @@\n-# 0: symbol, 1: symbol, 2: string\n-compiler.note.method.ir.skip=\\\n-    unsupported code reflection node {2} found in method {0}.{1}\n-\n@@ -4296,4 +4304,0 @@\n-\n-# 0: string\n-compiler.note.quoted.ir.skip=\\\n-    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+import static com.sun.tools.javac.code.TypeTag.CLASS;\n@@ -110,0 +111,1 @@\n+import static com.sun.tools.javac.resources.CompilerProperties.Errors.*;\n@@ -170,3 +172,6 @@\n-            \/\/ if the method is annotated, scan it\n-            BodyScanner bodyScanner = new BodyScanner(tree);\n-            try {\n+            if (currentClassSym.type.getEnclosingType().hasTag(CLASS)) {\n+                \/\/ Reflectable methods in inner classes are not supported\n+                log.error(tree, QuotedMethodInnerClass(currentClassSym.enclClass()));\n+            } else {\n+                \/\/ if the method is annotated, scan it\n+                BodyScanner bodyScanner = new BodyScanner(tree);\n@@ -180,3 +185,0 @@\n-            } catch (UnsupportedASTException ex) {\n-                \/\/ whoops, some AST node inside the method body were not supported. Log it and move on.\n-                log.note(ex.tree, MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n@@ -218,0 +220,7 @@\n+            if (currentClassSym.type.getEnclosingType().hasTag(CLASS)) {\n+                \/\/ Quotable lambdas in inner classes are not supported\n+                log.error(tree, QuotedLambdaInnerClass(currentClassSym.enclClass()));\n+                result = tree;\n+                return;\n+            }\n+\n@@ -220,9 +229,8 @@\n-            try {\n-                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n-                if (dumpIR) {\n-                    \/\/ dump the method IR if requested\n-                    log.note(QuotedIrDump(funcOp.toText()));\n-                }\n-                \/\/ create a static method that returns the FuncOp representing the lambda\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n-                classOps.add(opMethod);\n+            CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+            if (dumpIR) {\n+                \/\/ dump the method IR if requested\n+                log.note(QuotedIrDump(funcOp.toText()));\n+            }\n+            \/\/ create a static method that returns the FuncOp representing the lambda\n+            JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+            classOps.add(opMethod);\n@@ -230,23 +238,22 @@\n-                switch (kind) {\n-                    case QUOTED_STRUCTURAL -> {\n-                        \/\/ @@@ Consider replacing with invokedynamic to quoted bootstrap method\n-                        \/\/ Thereby we avoid certain dependencies and hide specific details\n-                        ListBuffer<JCExpression> args = new ListBuffer<>();\n-                        \/\/ Get the func operation\n-                        JCIdent opMethodId = make.Ident(opMethod.sym);\n-                        JCExpression op = make.TypeCast(crSyms.funcOpType, make.App(opMethodId));\n-                        args.add(op);\n-                        \/\/ Append captured vars\n-                        ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner);\n-                        args.appendList(capturedArgs.toList());\n-                        \/\/ Get the quoted instance by calling Quoted::quotedOp\n-                        JCMethodInvocation quotedInvoke = make.App(make.Ident(crSyms.quotedQuotedOp), args.toList());\n-                        quotedInvoke.varargsElement = syms.objectType;\n-                        super.visitLambda(tree);\n-                        result = quotedInvoke;\n-                    }\n-                    case QUOTABLE -> {\n-                        \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n-                        tree.codeModel = opMethod.sym;\n-                        super.visitLambda(tree);\n-                    }\n+            switch (kind) {\n+                case QUOTED_STRUCTURAL -> {\n+                    \/\/ @@@ Consider replacing with invokedynamic to quoted bootstrap method\n+                    \/\/ Thereby we avoid certain dependencies and hide specific details\n+                    ListBuffer<JCExpression> args = new ListBuffer<>();\n+                    \/\/ Get the func operation\n+                    JCIdent opMethodId = make.Ident(opMethod.sym);\n+                    JCExpression op = make.TypeCast(crSyms.funcOpType, make.App(opMethodId));\n+                    args.add(op);\n+                    \/\/ Append captured vars\n+                    ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner);\n+                    args.appendList(capturedArgs.toList());\n+                    \/\/ Get the quoted instance by calling Quoted::quotedOp\n+                    JCMethodInvocation quotedInvoke = make.App(make.Ident(crSyms.quotedQuotedOp), args.toList());\n+                    quotedInvoke.varargsElement = syms.objectType;\n+                    super.visitLambda(tree);\n+                    result = quotedInvoke;\n+                }\n+                case QUOTABLE -> {\n+                    \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                    tree.codeModel = opMethod.sym;\n+                    super.visitLambda(tree);\n@@ -254,4 +261,0 @@\n-            } catch (UnsupportedASTException ex) {\n-                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n-                log.note(ex.tree, QuotedIrSkip(ex.tree.getTag().toString()));\n-                result = tree;\n@@ -274,0 +277,7 @@\n+            if (currentClassSym.type.getEnclosingType().hasTag(CLASS)) {\n+                \/\/ Quotable lambdas in inner classes are not supported\n+                log.error(tree, QuotedMrefInnerClass(currentClassSym.enclClass()));\n+                result = tree;\n+                return;\n+            }\n+\n@@ -276,18 +286,12 @@\n-            try {\n-                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n-                if (dumpIR) {\n-                    \/\/ dump the method IR if requested\n-                    log.note(QuotedIrDump(funcOp.toText()));\n-                }\n-                \/\/ create a method that returns the FuncOp representing the lambda\n-                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n-                classOps.add(opMethod);\n-                tree.codeModel = opMethod.sym;\n-                super.visitReference(tree);\n-                if (recvDecl != null) {\n-                    result = copyReferenceWithReceiverVar(tree, recvDecl);\n-                }\n-            } catch (UnsupportedASTException ex) {\n-                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n-                log.note(ex.tree, QuotedIrSkip(ex.tree.getTag().toString()));\n-                result = tree;\n+            CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+            if (dumpIR) {\n+                \/\/ dump the method IR if requested\n+                log.note(QuotedIrDump(funcOp.toText()));\n+            }\n+            \/\/ create a method that returns the FuncOp representing the lambda\n+            JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp, codeModelStorageOption);\n+            classOps.add(opMethod);\n+            tree.codeModel = opMethod.sym;\n+            super.visitReference(tree);\n+            if (recvDecl != null) {\n+                result = copyReferenceWithReceiverVar(tree, recvDecl);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":64,"deletions":60,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -216,1 +216,0 @@\n-compiler.note.method.ir.skip                                  # code reflection\n@@ -220,1 +219,3 @@\n-compiler.note.quoted.ir.skip                                  # code reflection\n+compiler.err.quoted.method.inner.class                        # code reflection\n+compiler.err.quoted.lambda.inner.class                        # code reflection\n+compiler.err.quoted.mref.inner.class                          # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @modules jdk.incubator.code\n+ * @compile\/fail\/ref=TestNoCodeReflectionInInnerClasses.out -XDrawDiagnostics TestNoCodeReflectionInInnerClasses.java\n+ *\/\n+\n+import jdk.incubator.code.*;\n+\n+class TestNoCodeReflectionInInnerClasses {\n+    class Inner {\n+        @CodeReflection\n+        public void test1() { }\n+\n+        void test2() {\n+            Quotable q = (Runnable & Quotable) () -> { };\n+        }\n+\n+        void test3() {\n+            Quoted q = () -> null;\n+        }\n+\n+        void test4() {\n+            Quotable q = (Runnable & Quotable) this::test2;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+- compiler.warn.incubating.modules: jdk.incubator.code\n+TestNoCodeReflectionInInnerClasses.java:12:21: compiler.err.quoted.method.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+TestNoCodeReflectionInInnerClasses.java:15:48: compiler.err.quoted.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+TestNoCodeReflectionInInnerClasses.java:19:24: compiler.err.quoted.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+TestNoCodeReflectionInInnerClasses.java:23:48: compiler.err.quoted.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+4 errors\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -140,4 +140,2 @@\n-    @Test(dataProvider = \"ints\")\n-    public void testCaptureIntField(int x) {\n-        class Context {\n-            final int x;\n+    static class Context {\n+        final int x;\n@@ -145,3 +143,3 @@\n-            Context(int x) {\n-                this.x = x;\n-            }\n+        Context(int x) {\n+            this.x = x;\n+        }\n@@ -149,3 +147,2 @@\n-            Quotable quotable() {\n-                return (Quotable & IntUnaryOperator) y -> x + y;\n-            }\n+        Quotable quotable() {\n+            return (Quotable & IntUnaryOperator) y -> x + y;\n@@ -153,0 +150,4 @@\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntField(int x) {\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -59,4 +59,2 @@\n-    @Test(dataProvider = \"ints\")\n-    public void testCaptureIntField(int x) {\n-        class Context {\n-            final int x;\n+    static class Context {\n+        final int x;\n@@ -64,3 +62,3 @@\n-            Context(int x) {\n-                this.x = x;\n-            }\n+        Context(int x) {\n+            this.x = x;\n+        }\n@@ -68,3 +66,2 @@\n-            Quoted quoted() {\n-                return (int y) -> x + y;\n-            }\n+        Quoted quoted() {\n+            return (int y) -> x + y;\n@@ -72,0 +69,4 @@\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntField(int x) {\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"}]}