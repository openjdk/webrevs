{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n@@ -73,0 +74,1 @@\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -94,0 +96,1 @@\n+import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n@@ -96,0 +99,1 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n@@ -121,0 +125,1 @@\n+    private final Lower lower;\n@@ -144,2 +149,1 @@\n-\n-\n+        lower = Lower.instance(context);\n@@ -433,0 +437,1 @@\n+        private Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n@@ -448,1 +453,1 @@\n-                Tag.TOPLEVEL, Tag.PACKAGEDEF, Tag.IMPORT, Tag.CLASSDEF, Tag.METHODDEF,\n+                Tag.TOPLEVEL, Tag.PACKAGEDEF, Tag.IMPORT, Tag.METHODDEF,\n@@ -932,10 +937,2 @@\n-                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER -> {\n-                    Value varOp = varOpValue(sym);\n-                    if (varOp.type() instanceof VarType) {\n-                        \/\/ regular var\n-                        result = append(CoreOp.varLoad(varOp));\n-                    } else {\n-                        \/\/ captured value\n-                        result = varOp;\n-                    }\n-                }\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER ->\n+                    result = loadVar(sym);\n@@ -965,0 +962,7 @@\n+        private Value loadVar(Symbol sym) {\n+            Value varOp = varOpValue(sym);\n+            return varOp.type() instanceof VarType ?\n+                    append(CoreOp.varLoad(varOp)) : \/\/ regular var\n+                    varOp;                          \/\/ captured value\n+        }\n+\n@@ -1252,1 +1256,0 @@\n-            \/\/ @@@ Support anonymous classes\n@@ -1254,0 +1257,5 @@\n+                scan(tree.def);\n+            }\n+\n+            \/\/ @@@ Support local classes in pre-construction contexts\n+            if (tree.type.tsym.isDirectlyOrIndirectlyLocal() && (tree.type.tsym.flags() & NOOUTERTHIS) != 0) {\n@@ -1257,0 +1265,1 @@\n+            List<TypeElement> argtypes = new ArrayList<>();\n@@ -1270,0 +1279,7 @@\n+                argtypes.add(outerInstance.type());\n+            }\n+            if (tree.type.tsym.isDirectlyOrIndirectlyLocal()) {\n+                for (Symbol c : localCaptures.get(tree.type.tsym)) {\n+                    args.add(loadVar(c));\n+                    argtypes.add(symbolToErasedDesc(c));\n+                }\n@@ -1276,0 +1292,1 @@\n+            argtypes.addAll(methodRef.type().parameterTypes());\n@@ -1278,1 +1295,1 @@\n-                    methodRef.type().parameterTypes());\n+                    argtypes);\n@@ -2217,2 +2234,15 @@\n-            \/\/ do nothing\n-        }\n+            if (tree.sym.isDirectlyOrIndirectlyLocal()) {\n+                \/\/ we need to keep track of captured locals using same strategy as Lower\n+                class FreeVarScanner extends Lower.BasicFreeVarCollector {\n+                    List<Symbol> freevars = new ArrayList<>();\n+                    Symbol owner;\n+\n+                    FreeVarScanner(Symbol owner) {\n+                        lower.super();\n+                        this.owner = owner;\n+                    }\n+\n+                    @Override\n+                    void addFreeVars(ClassSymbol c) {\n+                        freevars.addAll(localCaptures.getOrDefault(c, List.of()));\n+                    }\n@@ -2220,0 +2250,13 @@\n+                    @Override\n+                    public void visitSymbol(Symbol sym) {\n+                        if (sym.kind == VAR && sym.owner == owner &&\n+                                ((VarSymbol)sym).getConstValue() == null) {\n+                            freevars.add(sym);\n+                        }\n+                    }\n+                }\n+                FreeVarScanner fvs = new FreeVarScanner(tree.sym.owner);\n+                fvs.scan(tree);\n+                localCaptures.put(tree.sym, fvs.freevars);\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+    static int nErrors = 0;\n+\n@@ -52,0 +54,8 @@\n+        if (nErrors > 0) {\n+            throw new AssertionError(\"Test failed with \" + nErrors + \" errors\");\n+        }\n+    }\n+\n+    static void error(String msg, Object... args) {\n+        nErrors++;\n+        System.err.println(\"error: \" + String.format(msg, args));\n@@ -60,1 +70,2 @@\n-            throw new AssertionError(\"No @IR annotation found on reflective method\");\n+            error(\"No @IR annotation found on reflective method\");\n+            return;\n@@ -64,1 +75,2 @@\n-            throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+            error(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected);\n+            return;\n@@ -77,1 +89,2 @@\n-                throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+                error(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected);\n+                return;\n@@ -84,1 +97,2 @@\n-                throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+                error(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected);\n+                return;\n@@ -87,1 +101,2 @@\n-            throw new AssertionError(\"Field annotated with @IR should be of a quotable type (Quoted\/Quotable)\");\n+            error(\"Field annotated with @IR should be of a quotable type (Quoted\/Quotable)\");\n+            return;\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with local class creation expressions.\n+ * @build LocalClassTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester LocalClassTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class LocalClassTest {\n+\n+    final static String CONST_STRING = \"Hello!\";\n+    String nonConstString = \"Hello!\";\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testLocalNoCapture\" (%0 : LocalClassTest)void -> {\n+                %1 : .<LocalClassTest, LocalClassTest$1Foo> = new %0 @\"func<.<LocalClassTest, LocalClassTest$1Foo>, LocalClassTest>\";\n+                invoke %1 @\".<LocalClassTest, LocalClassTest$1Foo>::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void testLocalNoCapture() {\n+        class Foo {\n+            void m() { }\n+        }\n+        new Foo().m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testAnonNoCapture\" (%0 : LocalClassTest)void -> {\n+                %1 : .<LocalClassTest, LocalClassTest$1> = new %0 @\"func<.<LocalClassTest, LocalClassTest$1>, LocalClassTest>\";\n+                invoke %1 @\".<LocalClassTest, LocalClassTest$1>::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void testAnonNoCapture() {\n+        new Object() {\n+            void m() { }\n+        }.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testLocalCaptureParam\" (%0 : LocalClassTest, %1 : java.lang.String)java.lang.String -> {\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                %3 : java.lang.String = var.load %2;\n+                %4 : .<LocalClassTest, LocalClassTest$2Foo> = new %0 %3 @\"func<.<LocalClassTest, LocalClassTest$2Foo>, LocalClassTest, java.lang.String>\";\n+                %5 : java.lang.String = invoke %4 @\".<LocalClassTest, LocalClassTest$2Foo>::m()java.lang.String\";\n+                return %5;\n+            };\n+            \"\"\")\n+    String testLocalCaptureParam(String s) {\n+        class Foo {\n+            String m() { return s; }\n+        }\n+        return new Foo().m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testAnonCaptureParam\" (%0 : LocalClassTest, %1 : java.lang.String)java.lang.String -> {\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                %3 : java.lang.String = var.load %2;\n+                %4 : .<LocalClassTest, LocalClassTest$2> = new %0 %3 @\"func<.<LocalClassTest, LocalClassTest$2>, LocalClassTest, java.lang.String>\";\n+                %5 : java.lang.String = invoke %4 @\".<LocalClassTest, LocalClassTest$2>::m()java.lang.String\";\n+                return %5;\n+            };\n+            \"\"\")\n+    String testAnonCaptureParam(String s) {\n+        return new Object() {\n+            String m() { return s; }\n+        }.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testLocalCaptureParamAndField\" (%0 : LocalClassTest, %1 : java.lang.String)java.lang.String -> {\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                %3 : java.lang.String = constant @\"Hello!\";\n+                %4 : Var<java.lang.String> = var %3 @\"localConst\";\n+                %5 : java.lang.String = var.load %2;\n+                %6 : .<LocalClassTest, LocalClassTest$3Foo> = new %0 %5 @\"func<.<LocalClassTest, LocalClassTest$3Foo>, LocalClassTest, java.lang.String>\";\n+                %7 : java.lang.String = invoke %6 @\".<LocalClassTest, LocalClassTest$3Foo>::m()java.lang.String\";\n+                return %7;\n+            };\n+            \"\"\")\n+    String testLocalCaptureParamAndField(String s) {\n+        final String localConst = \"Hello!\";\n+        class Foo {\n+            String m() { return localConst + s + nonConstString + CONST_STRING; }\n+        }\n+        return new Foo().m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testAnonCaptureParamAndField\" (%0 : LocalClassTest, %1 : java.lang.String)java.lang.String -> {\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                %3 : java.lang.String = constant @\"Hello!\";\n+                %4 : Var<java.lang.String> = var %3 @\"localConst\";\n+                %5 : java.lang.String = var.load %2;\n+                %6 : .<LocalClassTest, LocalClassTest$3> = new %0 %5 @\"func<.<LocalClassTest, LocalClassTest$3>, LocalClassTest, java.lang.String>\";\n+                %7 : java.lang.String = invoke %6 @\".<LocalClassTest, LocalClassTest$3>::m()java.lang.String\";\n+                return %7;\n+            };\n+            \"\"\")\n+    String testAnonCaptureParamAndField(String s) {\n+        final String localConst = \"Hello!\";\n+        return new Object() {\n+            String m() { return localConst + s + nonConstString + CONST_STRING; }\n+        }.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testLocalDependency\" (%0 : LocalClassTest, %1 : int, %2 : int)void -> {\n+                %3 : Var<int> = var %1 @\"s\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : .<LocalClassTest, LocalClassTest$1Bar> = new %0 %5 %6 @\"func<.<LocalClassTest, LocalClassTest$1Bar>, LocalClassTest, int, int>\";\n+                return;\n+            };\n+            \"\"\")\n+    void testLocalDependency(int s, int i) {\n+        class Foo {\n+            int i() { return i; }\n+        }\n+        class Bar {\n+            int s() { return s; }\n+            Foo foo() { return new Foo(); }\n+        }\n+        new Bar();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testAnonDependency\" (%0 : LocalClassTest, %1 : int, %2 : int)void -> {\n+                %3 : Var<int> = var %1 @\"s\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : .<LocalClassTest, LocalClassTest$4> = new %0 %5 %6 @\"func<.<LocalClassTest, LocalClassTest$4>, LocalClassTest, int, int>\";\n+                return;\n+            };\n+            \"\"\")\n+    void testAnonDependency(int s, int i) {\n+        class Foo {\n+            int i() { return i; }\n+        }\n+        new Object() {\n+            int s() { return s; }\n+            Foo foo() { return new Foo(); }\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalClassTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -171,1 +171,1 @@\n-                    %2 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = new %0 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>>\";\n+                    %2 : .<MethodReferenceTest, MethodReferenceTest$A<java.lang.String>> = new %0 @\"func<.<MethodReferenceTest, MethodReferenceTest$A>, MethodReferenceTest>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>>\";\n+                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>, NewTest>\";\n@@ -113,1 +113,1 @@\n-                %3 : .<NewTest, NewTest$B> = new %0 %1 %2 @\"func<.<NewTest, NewTest$B>, int, int>\";\n+                %3 : .<NewTest, NewTest$B> = new %0 %1 %2 @\"func<.<NewTest, NewTest$B>, NewTest, int, int>\";\n@@ -125,1 +125,1 @@\n-                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>>\";\n+                %1 : .<NewTest, NewTest$B> = new %0 @\"func<.<NewTest, NewTest$B>, NewTest>\";\n@@ -138,1 +138,1 @@\n-                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>>\";\n+                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>, .<NewTest, NewTest$B>>\";\n@@ -151,1 +151,1 @@\n-                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>>\";\n+                %2 : .<.<NewTest, NewTest$B>, NewTest$B$C> = new %1 @\"func<.<.<NewTest, NewTest$B>, NewTest$B$C>, .<NewTest, NewTest$B>>\";\n@@ -192,1 +192,1 @@\n-                %6 : .<NewTest, NewTest$BG<java.lang.String>> = new %0 %5 @\"func<.<NewTest, NewTest$BG>, java.util.List>\";\n+                %6 : .<NewTest, NewTest$BG<java.lang.String>> = new %0 %5 @\"func<.<NewTest, NewTest$BG>, NewTest, java.util.List>\";\n@@ -194,1 +194,1 @@\n-                %8 : .<.<NewTest, NewTest$BG<java.lang.String>>, NewTest$BG$CG<java.lang.Number>> = new %6 %7 @\"func<.<.<NewTest, NewTest$BG>, NewTest$BG$CG>, java.util.List>\";\n+                %8 : .<.<NewTest, NewTest$BG<java.lang.String>>, NewTest$BG$CG<java.lang.Number>> = new %6 %7 @\"func<.<.<NewTest, NewTest$BG>, NewTest$BG$CG>, .<NewTest, NewTest$BG<java.lang.String>>, java.util.List>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import javax.tools.JavaFileObject;\n@@ -64,0 +63,9 @@\n+    static final Set<String> EXCLUDED_TEST = Set.of(\n+            \"LocalClassTest.java\",              \/\/ name of local classes is not stable at annotation processing time\n+            \"TestLocalCapture.java\",            \/\/ plain testng test\n+            \"TestCaptureQuoted.java\",           \/\/ plain testng test\n+            \"TestCaptureQuotable.java\",         \/\/ plain testng test\n+            \"QuotedSameInstanceTest.java\",      \/\/ plain testng test\n+            \"CodeModelSameInstanceTest.java\"    \/\/ plain testng test\n+    );\n+\n@@ -72,1 +80,1 @@\n-            if (!file.exists() || !file.getName().endsWith(\".java\")) {\n+            if (!file.exists() || !file.getName().endsWith(\".java\") || isExcluded(file)) {\n@@ -79,0 +87,4 @@\n+    boolean isExcluded(File file) {\n+        return EXCLUDED_TEST.contains(file.getName());\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for captured values in local classes.\n+ * @run testng TestLocalCapture\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp.FuncOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.stream.IntStream;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestLocalCapture {\n+\n+    int x = 13;\n+    final int CONST = 1;\n+\n+    @CodeReflection\n+    public int sum(int y, int z) {\n+        final int localConst = 2;\n+        class Foo {\n+            int sum(int z) { return localConst + x + y + z + CONST; };\n+        }\n+        return new Foo().sum(z);\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testLocalCapture(int y) throws ReflectiveOperationException {\n+        Method sum = TestLocalCapture.class.getDeclaredMethod(\"sum\", int.class, int.class);\n+        FuncOp model = sum.getCodeModel().get();\n+        int found = (int)Interpreter.invoke(MethodHandles.lookup(), model, this, y, 17);\n+        int expected = sum(y, 17);\n+        assertEquals(found, expected);\n+    }\n+\n+    @DataProvider(name = \"ints\")\n+    public Object[][] ints() {\n+        return IntStream.range(0, 50)\n+                .mapToObj(i -> new Object[] { i })\n+                .toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestLocalCapture.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}