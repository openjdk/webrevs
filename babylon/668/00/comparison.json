{"files":[{"patch":"@@ -392,110 +392,0 @@\n-    \/**\n-     * The closure operation, that can model a structured Java lambda expression\n-     * that has no target type (a functional interface).\n-     *\/\n-    @OpDeclaration(ClosureOp.NAME)\n-    public static final class ClosureOp extends CoreOp\n-            implements Op.Invokable, Op.Lowerable, JavaOp.JavaExpression {\n-\n-        public static class Builder {\n-            final Body.Builder ancestorBody;\n-            final FunctionType funcType;\n-\n-            Builder(Body.Builder ancestorBody, FunctionType funcType) {\n-                this.ancestorBody = ancestorBody;\n-                this.funcType = funcType;\n-            }\n-\n-            public ClosureOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n-                c.accept(body.entryBlock());\n-                return new ClosureOp(body);\n-            }\n-        }\n-\n-        static final String NAME = \"closure\";\n-\n-        final Body body;\n-\n-        ClosureOp(ExternalizedOp def) {\n-            this(def.bodyDefinitions().get(0));\n-        }\n-\n-        ClosureOp(ClosureOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public ClosureOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ClosureOp(this, cc, ot);\n-        }\n-\n-        ClosureOp(Body.Builder bodyC) {\n-            super(List.of());\n-\n-            this.body = bodyC.build(this);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        @Override\n-        public FunctionType invokableType() {\n-            return body.bodyType();\n-        }\n-\n-        @Override\n-        public Body body() {\n-            return body;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n-            \/\/ Isolate body with respect to ancestor transformations\n-            b.rebind(b.context(), OpTransformer.LOWERING_TRANSFORMER).op(this);\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return body.bodyType();\n-        }\n-    }\n-\n-    \/**\n-     * The closure call operation, that models a call to a closure, by reference\n-     *\/\n-\/\/  @@@ stack effects equivalent to the invocation of an SAM of on an instance of an anonymous functional interface\n-\/\/  that is the target of the closures lambda expression.\n-    @OpDeclaration(ClosureCallOp.NAME)\n-    public static final class ClosureCallOp extends CoreOp {\n-        static final String NAME = \"closure.call\";\n-\n-        ClosureCallOp(ExternalizedOp def) {\n-            this(def.operands());\n-        }\n-\n-        ClosureCallOp(ClosureCallOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ClosureCallOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ClosureCallOp(this, cc);\n-        }\n-\n-        ClosureCallOp(List<Value> args) {\n-            super(args);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            FunctionType ft = (FunctionType) operands().getFirst().type();\n-            return ft.returnType();\n-        }\n-    }\n-\n@@ -1235,2 +1125,0 @@\n-            case \"closure\" -> new ClosureOp(def);\n-            case \"closure.call\" -> new ClosureCallOp(def);\n@@ -1378,44 +1266,0 @@\n-    \/**\n-     * Creates a closure operation.\n-     *\n-     * @param ancestorBody the ancestor of the body of the closure operation\n-     * @param funcType     the closure operation's function type\n-     * @return the closure operation\n-     *\/\n-    public static ClosureOp.Builder closure(Body.Builder ancestorBody,\n-                                            FunctionType funcType) {\n-        return new ClosureOp.Builder(ancestorBody, funcType);\n-    }\n-\n-    \/**\n-     * Creates a closure operation.\n-     *\n-     * @param body the body of the closure operation\n-     * @return the closure operation\n-     *\/\n-    public static ClosureOp closure(Body.Builder body) {\n-        return new ClosureOp(body);\n-    }\n-\n-    \/**\n-     * Creates a closure call operation.\n-     *\n-     * @param args the closure arguments. The first argument is the closure operation to be called\n-     * @return the closure call operation\n-     *\/\n-    \/\/ @@@: Is this the right signature?\n-    public static ClosureCallOp closureCall(Value... args) {\n-        return closureCall(List.of(args));\n-    }\n-\n-    \/**\n-     * Creates a closure call operation.\n-     *\n-     * @param args the closure arguments. The first argument is the closure operation to be called\n-     * @return the closure call operation\n-     *\/\n-    \/\/ @@@: Is this the right signature?\n-    public static ClosureCallOp closureCall(List<Value> args) {\n-        return new ClosureCallOp(args);\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":0,"deletions":156,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-            ClosureOp,\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -271,4 +271,0 @@\n-    record ClosureRecord(CoreOp.ClosureOp op,\n-                         List<Object> capturedArguments) {\n-    }\n-\n@@ -523,11 +519,0 @@\n-        } else if (o instanceof CoreOp.ClosureOp co) {\n-            List<Object> capturedArguments = co.capturedValues().stream()\n-                    .map(oc::getValue).toList();\n-            return new ClosureRecord(co, capturedArguments);\n-        } else if (o instanceof CoreOp.ClosureCallOp cco) {\n-            List<Object> values = o.operands().stream().map(oc::getValue).toList();\n-            ClosureRecord cr = (ClosureRecord) values.get(0);\n-\n-            List<Object> arguments = new ArrayList<>(values.subList(1, values.size()));\n-            arguments.addAll(cr.capturedArguments);\n-            return Interpreter.invoke(l, cr.op(), arguments);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,143 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit TestClosureOps\n- *\/\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quotable;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import jdk.incubator.code.interpreter.Interpreter;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static jdk.incubator.code.dialect.core.CoreOp.*;\n-import static jdk.incubator.code.dialect.core.CoreType.functionType;\n-import static jdk.incubator.code.dialect.java.JavaOp.add;\n-import static jdk.incubator.code.dialect.java.JavaType.INT;\n-import static jdk.incubator.code.dialect.java.JavaType.type;\n-\n-public class TestClosureOps {\n-\n-    static class Builder {\n-        static final MethodRef ACCEPT_METHOD = MethodRef.method(type(TestClosureOps.Builder.class), \"accept\",\n-                INT, CoreOp.QuotedOp.QUOTED_TYPE);\n-\n-        static int accept(Quoted c) {\n-            Assertions.assertEquals(c.capturedValues().size(), 1);\n-            Assertions.assertEquals(c.capturedValues().values().iterator().next(), 1);\n-\n-            List<Object> arguments = new ArrayList<>();\n-            arguments.add(42);\n-            arguments.addAll(c.capturedValues().values());\n-            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) c.op(),\n-                    arguments);\n-            return r;\n-        }\n-    }\n-\n-    @Test\n-    public void testQuotedWithCapture() {\n-        \/\/ functional type = (int)int\n-        CoreOp.FuncOp f = func(\"f\", functionType(INT, INT))\n-                .body(block -> {\n-                    Block.Parameter i = block.parameters().get(0);\n-\n-                    \/\/ functional type = (int)int\n-                    \/\/ op descriptor = ()Quoted<ClosureOp>\n-                    CoreOp.QuotedOp qop = quoted(block.parentBody(), qblock -> {\n-                        return closure(qblock.parentBody(), functionType(INT, INT))\n-                                .body(cblock -> {\n-                                    Block.Parameter ci = cblock.parameters().get(0);\n-\n-                                    cblock.op(return_(\n-                                            \/\/ capture i from function's body\n-                                            cblock.op(add(i, ci))\n-                                    ));\n-                                });\n-                    });\n-                    Op.Result cquoted = block.op(qop);\n-\n-                    Op.Result or = block.op(JavaOp.invoke(TestClosureOps.Builder.ACCEPT_METHOD, cquoted));\n-                    block.op(return_(or));\n-                });\n-\n-        System.out.println(f.toText());\n-\n-        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n-        Assertions.assertEquals(43, ir);\n-    }\n-\n-    @Test\n-    public void testWithCapture() {\n-        \/\/ functional type = (int)int\n-        CoreOp.FuncOp f = func(\"f\", functionType(INT, INT))\n-                .body(block -> {\n-                    Block.Parameter i = block.parameters().get(0);\n-\n-                    \/\/ functional type = (int)int\n-                    \/\/   captures i\n-                    CoreOp.ClosureOp closure = CoreOp.closure(block.parentBody(),\n-                                    functionType(INT, INT))\n-                            .body(cblock -> {\n-                                Block.Parameter ci = cblock.parameters().get(0);\n-\n-                                cblock.op(return_(\n-                                        cblock.op(add(i, ci))));\n-                            });\n-                    Op.Result c = block.op(closure);\n-\n-                    Op.Result fortyTwo = block.op(constant(INT, 42));\n-                    Op.Result or = block.op(closureCall(c, fortyTwo));\n-                    block.op(return_(or));\n-                });\n-\n-        System.out.println(f.toText());\n-\n-        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n-        Assertions.assertEquals(43, ir);\n-    }\n-\n-    @Test\n-    public void testQuotableModel() {\n-        Quotable quoted = (Runnable & Quotable) () -> {};\n-        Op qop = Op.ofQuotable(quoted).get().op();\n-        Op top = qop.ancestorOp().ancestorOp();\n-        Assertions.assertTrue(top instanceof CoreOp.FuncOp);\n-\n-        CoreOp.FuncOp fop = (CoreOp.FuncOp) top;\n-        Assertions.assertEquals(fop.invokableType().returnType(), JavaType.type(Quoted.class));\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"}]}