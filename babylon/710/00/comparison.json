{"files":[{"patch":"@@ -36,0 +36,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n@@ -2910,0 +2913,100 @@\n+\n+        private static boolean isFinalVar(VarOp varOp) {\n+            return varOp.initOperand() != null && varOp.result().uses().stream().noneMatch(u -> u.op() instanceof VarAccessOp.VarStoreOp);\n+        }\n+\n+        private static boolean isBoxingMethod(MethodRef mr) {\n+            return List.of(J_L_BYTE, J_L_CHARACTER, J_L_SHORT, J_L_INTEGER, J_L_LONG, J_L_FLOAT, J_L_DOUBLE).contains(mr.refType())\n+                    && mr.name().equals(\"valueOf\");\n+        }\n+\n+        private static boolean isConstantExpr(Value v, MethodHandles.Lookup l) {\n+            if (!(v instanceof Result opr)) {\n+                return false;\n+            }\n+            Op op = opr.op();\n+            if (op instanceof ConstantOp cop) {\n+                return cop.resultType() instanceof PrimitiveType || cop.resultType().equals(J_L_STRING);\n+            }\n+            if (op instanceof VarAccessOp.VarLoadOp varLoadOp) {\n+                return isFinalVar(varLoadOp.varOp()) && isConstantExpr(varLoadOp.varOp().initOperand(), l);\n+            }\n+            if (op instanceof ConvOp convOp) {\n+                return (convOp.resultType() instanceof PrimitiveType || convOp.resultType().equals(J_L_STRING)) &&\n+                        isConstantExpr(convOp.operands().get(0), l);\n+            }\n+            if (op instanceof InvokeOp invokeOp) {\n+                return isBoxingMethod(invokeOp.invokeDescriptor()) && isConstantExpr(invokeOp.operands().get(0), l);\n+            }\n+            if (op instanceof FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                Field field;\n+                try {\n+                    field = fieldLoadOp.fieldDescriptor().resolveToField(l);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                return field.isEnumConstant() || field.accessFlags().containsAll(Set.of(AccessFlag.STATIC, AccessFlag.FINAL));\n+            }\n+            if (op instanceof UnaryOp unaryOp) {\n+                return isConstantExpr(unaryOp.operands().get(0), l);\n+            }\n+            if (op instanceof BinaryOp binaryOp) {\n+                return binaryOp.operands().stream().allMatch(o -> isConstantExpr(o, l));\n+            }\n+            if (op instanceof BinaryTestOp binaryTestOp) {\n+                return binaryTestOp.operands().stream().allMatch(o -> isConstantExpr(o, l));\n+            }\n+            if (op instanceof ConditionalExpressionOp cexpr) {\n+                \/\/ bodies must yield constant expressions\n+                return isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(0).entryBlock().terminatingOp()).yieldValue(), l) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(1).entryBlock().terminatingOp()).yieldValue(), l) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cexpr.bodies().get(2).entryBlock().terminatingOp()).yieldValue(), l);\n+            }\n+            \/\/ conditional and, conditional or, example ?\n+            if (op instanceof ConditionalAndOp cand) {\n+                return isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(0).entryBlock().terminatingOp()).yieldValue(), l) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cand.bodies().get(1).entryBlock().terminatingOp()).yieldValue(), l);\n+            }\n+            if (op instanceof ConditionalOrOp cor) {\n+                \/\/ we can have a method isBodyYieldConstantExpr(Body)\n+                return isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(0).entryBlock().terminatingOp()).yieldValue(), l) &&\n+                        isConstantExpr(((CoreOp.YieldOp) cor.bodies().get(1).entryBlock().terminatingOp()).yieldValue(), l);\n+            }\n+            return false;\n+        }\n+\n+        private static boolean isCaseConstantLabel(Body label, MethodHandles.Lookup l) {\n+            if (label.blocks().size() != 1 || !(label.entryBlock().terminatingOp() instanceof CoreOp.YieldOp yop) ||\n+                    !(yop.yieldValue() instanceof Result r)) {\n+                return false;\n+            }\n+\n+            if (r.op() instanceof EqOp eqOp) { \/\/ EqOp for primitives, method invocation for Strings\n+                return isConstantExpr(eqOp.operands().get(1), l);\n+            }\n+            if (r.op() instanceof InvokeOp invokeOp) {\n+                MethodRef OBJECTS_EQUALS_METHOD = MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class);\n+                if (!invokeOp.invokeDescriptor().equals(OBJECTS_EQUALS_METHOD)) {\n+                    return false;\n+                }\n+                \/\/ case null\n+                if (invokeOp.operands().get(1) instanceof Op.Result opr && opr.op() instanceof ConstantOp cop && cop.value() == null) {\n+                    return true;\n+                }\n+                return isConstantExpr(invokeOp.operands().get(1), l);\n+            }\n+            if (r.op() instanceof ConditionalOrOp cor) { \/\/ list of case constant\n+                return cor.bodies().stream().allMatch(b -> isCaseConstantLabel(b, l));\n+            }\n+            return r.op() instanceof ConstantOp cop && cop.resultType().equals(BOOLEAN); \/\/ default label\n+        }\n+\n+        public boolean isCaseConstantSwitch(MethodHandles.Lookup l) {\n+            for (int i = 0; i < bodies.size(); i+=2) {\n+                Body label = bodies.get(i);\n+                if (!isCaseConstantLabel(label, l)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestIsCaseConstantSwitch\n+ *\/\n+public class TestIsCaseConstantSwitch {\n+\n+    @Test\n+    void testIsConstantLabelSwitch() throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(\"caseConstantSwitchExpressions\", int.class, E.class);\n+        CoreOp.FuncOp codeModel = Op.ofMethod(m).get();\n+        List<SwitchExpressionOp> swExprOps = codeModel.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof SwitchExpressionOp)\n+                .map(o -> ((SwitchExpressionOp) o)).toList();\n+        for (SwitchExpressionOp swExprOp : swExprOps) {\n+            Assertions.assertTrue(swExprOp.isCaseConstantSwitch(MethodHandles.lookup()), swExprOp.toText());\n+        }\n+\n+        \/\/ test with methods in TestSwitchExpressionOp and in TestSwitchStatementOp\n+        List<CoreOp.FuncOp> funcOps = Stream.concat(\n+                        Arrays.stream(TestSwitchExpressionOp.class.getDeclaredMethods()),\n+                        Arrays.stream(TestSwitchStatementOp.class.getDeclaredMethods()))\n+                .filter(dm -> dm.getName().startsWith(\"caseConstant\") && dm.isAnnotationPresent(Reflect.class))\n+                .map(dm -> Op.ofMethod(dm).get())\n+                .toList();\n+        for (CoreOp.FuncOp fop : funcOps) {\n+            JavaSwitchOp swOp = ((JavaSwitchOp) fop.body().entryBlock().ops().stream().filter(o -> o instanceof JavaSwitchOp).findFirst().get());\n+            Assertions.assertTrue(swOp.isCaseConstantSwitch(MethodHandles.lookup()), fop.toText());\n+        }\n+    }\n+\n+    class C {\n+        static final int x = 26;\n+    }\n+\n+    enum E {\n+        V;\n+    }\n+\n+    @Reflect\n+    private static void caseConstantSwitchExpressions(int i, E e) {\n+        \/\/ switch label\n+            \/\/ case label\n+                \/\/ list of case constant\n+                    \/\/ every case constant must be either a constant expression or the name of an enum constant\n+                \/\/ null literal\n+                \/\/ list of case patterns\n+            \/\/ default label\n+        final int fv = 25;\n+        String r = switch (i) {\n+            \/\/ literal of primitive type\n+            case 1 -> \"A\";\n+            \/\/ unary operators +, -, ~\n+            case +2 -> \"B\";\n+            case -2 -> \"BB\";\n+            case ~2 -> \"BBB\";\n+            \/\/ multiplicative operators *, \/, %\n+            case 3 * 4 -> \"E\";\n+            case 3 \/ 4 -> \"EE\";\n+            case 3 % 4 -> \"EEE\";\n+            \/\/ shift operators <<, >>, >>>\n+            case 4 << 5 -> \"F\";\n+            case 10 >> 1 -> \"FF\";\n+            case 8 >>> 1 -> \"FFF\";\n+            \/\/ relational operators <, <=, >, >= (and conditional operator)\n+            case 1 < 2 ? 9 : 10 -> \"G\";\n+            case 1 <= 2 ? 11 : 12 -> \"GG\";\n+            case 1 > 2 ? 13 : 14 -> \"GGG\";\n+            case 1 >= 2 ? 15 : 16 -> \"GGGG\";\n+            \/\/ equality operators ==, !=\n+            case 1 == 2 ? 17 : 18 -> \"H\";\n+            case 1 != 2 ? 19 : 20 -> \"HH\";\n+            \/\/ bitwise and logical operators &, ^, |\n+            case 6 & 6 -> \"I\";\n+            case 7 ^ 8 -> \"II\";\n+            case 8 | 10 -> \"III\";\n+            \/\/ conditional-and operator &&\n+            case 2 > 3 && 5 > 6 ? 21 : 22 -> \"J\";\n+            case 2 > 3 || 5 > 6 ? 23 : 24 -> \"JJ\";\n+            \/\/ parenthesized expressions whose contained expression is a constant expression\n+            case (20) -> \"K\";\n+            \/\/ simple names that refer to constant variables\n+            case fv -> \"L\";\n+            \/\/ qualified names of the form TypeName.Identifier that refer to constant variables\n+             case C.x -> \"M\";\n+             \/\/ list of case constants\n+            case 21, 30 -> null;\n+            default -> \"X\";\n+        };\n+\n+        String r2 = switch (r) {\n+            \/\/ string literal\n+            case \"A\" -> \"A+\";\n+            case null -> \"A++\";\n+            default -> \"X\";\n+        };\n+\n+        String r3 = switch (e) {\n+            \/\/ name of an enum constant\n+             case E.V -> \"V\";\n+            case null -> \"N\";\n+            default -> \"D\";\n+        };\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIsCaseConstantSwitch.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}