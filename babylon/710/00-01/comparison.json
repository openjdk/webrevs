{"files":[{"patch":"@@ -2984,1 +2984,2 @@\n-            if (r.op() instanceof EqOp eqOp) { \/\/ EqOp for primitives, method invocation for Strings\n+            \/\/ EqOp for primitives, method invocation for Strings and Reference Types\n+            if (r.op() instanceof EqOp eqOp) {\n@@ -2994,1 +2995,1 @@\n-                    return true;\n+                    return false;\n@@ -3005,0 +3006,3 @@\n+            if (!isIntegralType(this.operands().get(0).type())) {\n+                return false;\n+            }\n@@ -3013,0 +3017,12 @@\n+\n+        private static boolean isIntegralType(TypeElement te) {\n+            return isIntegralPrimitiveType(te) || isIntegralReferenceType(te);\n+        }\n+\n+        private static boolean isIntegralPrimitiveType(TypeElement te) {\n+            return List.of(BYTE, SHORT, CHAR, INT).contains(te);\n+        }\n+\n+        private static boolean isIntegralReferenceType(TypeElement te) {\n+            return List.of(J_L_BYTE, J_L_SHORT, J_L_CHARACTER, J_L_INTEGER).contains(te);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5,1 +5,3 @@\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -9,1 +11,0 @@\n-import java.util.Arrays;\n@@ -18,0 +19,1 @@\n+ * @enablePreview\n@@ -22,24 +24,0 @@\n-    @Test\n-    void testIsConstantLabelSwitch() throws NoSuchMethodException {\n-        Method m = this.getClass().getDeclaredMethod(\"caseConstantSwitchExpressions\", int.class, E.class);\n-        CoreOp.FuncOp codeModel = Op.ofMethod(m).get();\n-        List<SwitchExpressionOp> swExprOps = codeModel.body().entryBlock().ops().stream()\n-                .filter(o -> o instanceof SwitchExpressionOp)\n-                .map(o -> ((SwitchExpressionOp) o)).toList();\n-        for (SwitchExpressionOp swExprOp : swExprOps) {\n-            Assertions.assertTrue(swExprOp.isCaseConstantSwitch(MethodHandles.lookup()), swExprOp.toText());\n-        }\n-\n-        \/\/ test with methods in TestSwitchExpressionOp and in TestSwitchStatementOp\n-        List<CoreOp.FuncOp> funcOps = Stream.concat(\n-                        Arrays.stream(TestSwitchExpressionOp.class.getDeclaredMethods()),\n-                        Arrays.stream(TestSwitchStatementOp.class.getDeclaredMethods()))\n-                .filter(dm -> dm.getName().startsWith(\"caseConstant\") && dm.isAnnotationPresent(Reflect.class))\n-                .map(dm -> Op.ofMethod(dm).get())\n-                .toList();\n-        for (CoreOp.FuncOp fop : funcOps) {\n-            JavaSwitchOp swOp = ((JavaSwitchOp) fop.body().entryBlock().ops().stream().filter(o -> o instanceof JavaSwitchOp).findFirst().get());\n-            Assertions.assertTrue(swOp.isCaseConstantSwitch(MethodHandles.lookup()), fop.toText());\n-        }\n-    }\n-\n@@ -50,4 +28,0 @@\n-    enum E {\n-        V;\n-    }\n-\n@@ -55,1 +29,1 @@\n-    private static void caseConstantSwitchExpressions(int i, E e) {\n+    private static void caseConstantSwitchExpressions() {\n@@ -57,6 +31,6 @@\n-            \/\/ case label\n-                \/\/ list of case constant\n-                    \/\/ every case constant must be either a constant expression or the name of an enum constant\n-                \/\/ null literal\n-                \/\/ list of case patterns\n-            \/\/ default label\n+        \/\/ case label\n+        \/\/ list of case constant\n+        \/\/ every case constant must be either a constant expression or the name of an enum constant\n+        \/\/ null literal\n+        \/\/ list of case patterns\n+        \/\/ default label\n@@ -64,0 +38,1 @@\n+        int i = -1;\n@@ -99,2 +74,2 @@\n-             case C.x -> \"M\";\n-             \/\/ list of case constants\n+            case C.x -> \"M\";\n+            \/\/ list of case constants\n@@ -102,0 +77,4 @@\n+            \/\/ casts\n+            case (int) 31L -> \"N\";\n+            case (int) 34f -> \"NN\";\n+            \/\/ default\n@@ -105,4 +84,5 @@\n-        String r2 = switch (r) {\n-            \/\/ string literal\n-            case \"A\" -> \"A+\";\n-            case null -> \"A++\";\n+        \/\/ we can have a target of type Byte, Short, Character, Integer\n+        \/\/ as long as we don't introduce case null, javac will generate labels identical to what we have in source code\n+        Integer ii = -2;\n+        r = switch (ii) {\n+            case 1 -> \"A\";\n@@ -111,0 +91,38 @@\n+    }\n+\n+    enum E {\n+        V;\n+    }\n+\n+    @Reflect\n+    static void nonCaseConstantSwitchExpressions() {\n+        int r;\n+\n+        String s = \"\";\n+        r = switch (s) {\n+            case \"A\" -> 1;\n+            default -> 0;\n+        };\n+\n+        E e = E.V;\n+        r = switch (e) {\n+            case V -> 1;\n+        };\n+\n+        boolean b = false;\n+        r = switch (b) {\n+            case true -> 1;\n+            default -> 0;\n+        };\n+\n+        long l = 5L;\n+        r = switch (l) {\n+            case 1L -> 1;\n+            default -> 0;\n+        };\n+\n+        float f = 5f;\n+        r = switch (f) {\n+            case 1f -> 1;\n+            default -> 0;\n+        };\n@@ -112,5 +130,4 @@\n-        String r3 = switch (e) {\n-            \/\/ name of an enum constant\n-             case E.V -> \"V\";\n-            case null -> \"N\";\n-            default -> \"D\";\n+        double d = 5d;\n+        r = switch (d) {\n+            case 1d -> 1;\n+            default -> 0;\n@@ -119,0 +136,13 @@\n+        Integer i = 4;\n+        r = switch (i) {\n+            case 1 -> 1;\n+            case null -> -1;\n+            default -> 0;\n+        };\n+    }\n+\n+    static Stream<Arguments> cases() {\n+        return Stream.of(\n+                Arguments.of(\"caseConstantSwitchExpressions\", true),\n+                Arguments.of(\"nonCaseConstantSwitchExpressions\", false)\n+        );\n@@ -121,0 +151,12 @@\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    void testIsConstantLabelSwitch(String methodName, boolean expected) throws NoSuchMethodException {\n+        Method m = this.getClass().getDeclaredMethod(methodName);\n+        CoreOp.FuncOp codeModel = Op.ofMethod(m).get();\n+        List<SwitchExpressionOp> swExprOps = codeModel.body().entryBlock().ops().stream()\n+                .filter(o -> o instanceof SwitchExpressionOp)\n+                .map(o -> ((SwitchExpressionOp) o)).toList();\n+        for (SwitchExpressionOp swExprOp : swExprOps) {\n+            Assertions.assertEquals(expected, swExprOp.isCaseConstantSwitch(MethodHandles.lookup()), swExprOp.toText());\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIsCaseConstantSwitch.java","additions":90,"deletions":48,"binary":false,"changes":138,"status":"modified"}]}