{"files":[{"patch":"@@ -0,0 +1,3 @@\n+Example code showing use of code reflection in translation from Java to\n+the SPIR-V intermediate language.  For more information on SPIR-V see:\n+https:\/\/www.khronos.org\/spir.\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/README.md","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024 Intel Corporation. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>intel.code<\/groupId>\n+    <artifactId>spirv<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>23<\/maven.compiler.source>\n+        <maven.compiler.target>23<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+             <groupId>beehive-lab<\/groupId>\n+             <artifactId>beehive-spirv-lib<\/artifactId>\n+             <version>0.0.3<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules=jdk.incubator.vector<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+             <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-surefire-plugin<\/artifactId>\n+                <version>3.1.2<\/version>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                    <redirectTestOutputToFile>false<\/redirectTestOutputToFile>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+              <groupId>org.codehaus.mojo<\/groupId>\n+              <artifactId>exec-maven-plugin<\/artifactId>\n+              <version>1.4.0<\/version>\n+              <configuration>\n+                <mainClass>intel.code.spirv.ExampleUseTest<\/mainClass>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                <\/configuration>\n+             <\/configuration>\n+            <\/plugin>\n+\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/spirv\/pom.xml","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.Objects;\n+import java.util.List;\n+\n+public final class PointerType extends SpirvType {\n+    static final String NAME = \"spirv.pointer\";\n+    private final TypeElement referentType;\n+    private final TypeElement storageType;\n+\n+    public PointerType(TypeElement referentType, TypeElement storageType)\n+    {\n+        this.referentType = referentType;\n+        this.storageType = storageType;\n+    }\n+\n+    public TypeElement referentType()\n+    {\n+        return referentType;\n+    }\n+\n+    public TypeElement storageType()\n+    {\n+        return storageType;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj)\n+    {\n+        if (obj == null || obj.getClass() != PointerType.class) return false;\n+        PointerType pt = (PointerType)obj;\n+        return pt.referentType().equals(referentType) && pt.storageType.equals(storageType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(referentType, storageType);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of(referentType.toTypeDefinition(), storageType.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,1035 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.function.Function;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.math.BigInteger;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.FloatVector;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.InvalidSPIRVModuleException;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVHeader;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVModule;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVFunction;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVBlock;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.operands.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.Disassembler;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPIRVDisassemblerOptions;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.CLIHighlighter;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPIRVPrintingOptions;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPVByteStreamReader;\n+\n+public class SpirvModuleGenerator {\n+    public static MemorySegment generateModule(String moduleName, CoreOps.FuncOp func) {\n+        SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(func);\n+        MemorySegment module = SpirvModuleGenerator.generateModule(moduleName, spirvFunc);\n+        return module;\n+    }\n+\n+    public static MemorySegment generateModule(String moduleName, SpirvOps.FuncOp func) {\n+        return new SpirvModuleGenerator().generateModuleInternal(moduleName, func);\n+    }\n+\n+    public static void writeModuleToFile(MemorySegment module, String filepath)  {\n+        ByteBuffer buffer = module.asByteBuffer();\n+        File out = new File(filepath);\n+        try (FileChannel channel = new FileOutputStream(out, false).getChannel()) {\n+            channel.write(buffer);\n+        }\n+        catch (IOException e)  {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static String disassembleModule(MemorySegment module) {\n+        SPVByteStreamReader input = new SPVByteStreamReader(new ByteArrayInputStream(module.toArray(ValueLayout.JAVA_BYTE)));\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (PrintStream ps = new PrintStream(out))  {\n+            SPIRVDisassemblerOptions options = new SPIRVDisassemblerOptions(false, false, false, false, true);\n+            Disassembler dis = new Disassembler(input, ps, options);\n+            dis.run();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return new String(out.toByteArray());\n+    }\n+\n+    private record SpirvResult(SPIRVId type, SPIRVId address, SPIRVId value) {}\n+\n+    private final SPIRVModule module;\n+    private final Symbols symbols;\n+\n+    private SpirvModuleGenerator() {\n+        this.module = new SPIRVModule(new SPIRVHeader(1, 2, 29, 0, 0));\n+        this.symbols = new Symbols();\n+    }\n+\n+    private MemorySegment generateModuleInternal(String moduleName, SpirvOps.FuncOp func) {\n+        initModule();\n+        generateFunction(moduleName, moduleName, func);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(module.getByteCount());\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        module.close().write(buffer);\n+        buffer.flip();\n+        return MemorySegment.ofBuffer(buffer);\n+    }\n+\n+    private void generateFunction(String moduleName, String fnName, SpirvOps.FuncOp func) {\n+        TypeElement returnType = func.invokableType().returnType();\n+        SPIRVId functionID = nextId(fnName);\n+        String signature = func.invokableType().returnType().toString();\n+        List<TypeElement> paramTypes = func.invokableType().parameterTypes();\n+        \/\/ build signature string\n+        for (int i = 0; i < paramTypes.size(); i++) {\n+            signature += \"_\" + paramTypes.get(i).toString();\n+        }\n+        \/\/ declare function type if not already present\n+        SPIRVId functionSig = getIdOrNull(signature);\n+        if (functionSig == null) {\n+            SPIRVId[] typeIdsArray = new SPIRVId[paramTypes.size()];\n+            for (int i = 0; i < paramTypes.size(); i++) {\n+                typeIdsArray[i] = spirvType(paramTypes.get(i).toString());\n+            }\n+            functionSig = nextId(fnName + \"Signature\");\n+            module.add(new SPIRVOpTypeFunction(functionSig, spirvType(returnType.toString()), new SPIRVMultipleOperands<>(typeIdsArray)));\n+            addId(signature, functionSig);\n+        }\n+        \/\/ declare function as modeule entry point\n+        SPIRVId spirvReturnType = spirvType(returnType.toString());\n+        SPIRVFunction function = (SPIRVFunction)module.add(new SPIRVOpFunction(spirvReturnType, functionID, SPIRVFunctionControl.DontInline(), functionSig));\n+        SPIRVOpLabel entryPoint = new SPIRVOpLabel(nextId());\n+        SPIRVBlock entryBlock = (SPIRVBlock)function.add(entryPoint);\n+        SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(getId(\"globalInvocationId\"), getId(\"globalSize\"), getId(\"subgroupSize\"), getId(\"subgroupId\"));\n+        module.add(new SPIRVOpEntryPoint(SPIRVExecutionModel.Kernel(), functionID, new SPIRVLiteralString(fnName), operands));\n+\n+        translateBody(func.body(), function, entryBlock);\n+        function.add(new SPIRVOpFunctionEnd());\n+    }\n+\n+    private void translateBody(Body body, SPIRVFunction function, SPIRVBlock entryBlock) {\n+        int labelNumber = 0;\n+        SPIRVBlock spirvBlock = entryBlock;\n+        for (int bi = 1; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            String blockName = String.valueOf(block.hashCode());\n+            SPIRVOpLabel blockLabel = new SPIRVOpLabel(nextId());\n+            SPIRVBlock newBlock = (SPIRVBlock)function.add(blockLabel);\n+            symbols.putBlock(block, newBlock);\n+            symbols.putLabel(block, blockLabel);\n+        }\n+        for (Value param : body.entryBlock().parameters()) {\n+            SPIRVId paramId = nextId();\n+            addResult(param, new SpirvResult(spirvType(param.type().toString()), null, paramId));\n+        }\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            if (bi > 0) {\n+                spirvBlock = symbols.getBlock(block);\n+            }\n+            List<Op> ops = block.ops();\n+            for (Op op : block.ops()) {\n+                \/\/ debug(\"---------- spirv op = %s\", op.toText());\n+                switch (op)  {\n+                    case SpirvOps.VariableOp vop -> {\n+                        String typeName = vop.varType().toString();\n+                        SPIRVId type = spirvType(typeName);\n+                        SPIRVId varType = spirvVariableType(type);\n+                        SPIRVId var = nextId(vop.varName());\n+                        spirvBlock.add(new SPIRVOpVariable(varType, var, SPIRVStorageClass.Function(), new SPIRVOptionalOperand<>()));\n+                        addResult(vop.result(), new SpirvResult(varType, var, null));\n+                    }\n+                    case SpirvOps.FunctionParameterOp fpo -> {\n+                        SPIRVId result = nextId();\n+                        SPIRVId type = spirvType(fpo.resultType().toString());\n+                        function.add(new SPIRVOpFunctionParameter(type, result));\n+                        addResult(fpo.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.LoadOp lo -> {\n+                        if (((JavaType)lo.resultType()).equals(JavaType.type(VectorSpecies.class))) {\n+                            addResult(lo.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\")));\n+                        }\n+                        else {\n+                            SPIRVId type = spirvType(lo.resultType().toString());\n+                            SpirvResult toLoad = getResult(lo.operands().get(0));\n+                            SPIRVId varAddr = toLoad.address();\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(type, result, varAddr, align(type.getName())));\n+                            addResult(lo.result(), new SpirvResult(type, varAddr, result));\n+                        }\n+                    }\n+                    case SpirvOps.StoreOp so -> {\n+                        SpirvResult var = getResult(so.operands().get(0));\n+                        SPIRVId varAddr = var.address();\n+                        SPIRVId value = getResult(so.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpStore(varAddr, value, align(var.type().getName())));\n+                    }\n+                    case SpirvOps.IAddOp _, SpirvOps.FAddOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIAdd(intType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIAdd(longType, ans, lhs, rhs));\n+                        else if (lhsType == floatType) spirvBlock.add(new SPIRVOpFAdd(floatType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.IMulOp _, SpirvOps.FMulOp _, SpirvOps.IDivOp _, SpirvOps.FDivOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId rhsType = getResult(op.operands().get(1)).type();\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) {\n+                            if (op instanceof SpirvOps.IMulOp) spirvBlock.add(new SPIRVOpIMul(intType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOps.IDivOp) spirvBlock.add(new SPIRVOpSDiv(intType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == longType) {\n+                            SPIRVId rhsId = rhsType == intType ? nextId() : rhs;\n+                            if (rhsType == intType) spirvBlock.add(new SPIRVOpSConvert(longType, rhsId, rhs));\n+                            if (op instanceof SpirvOps.IMulOp) spirvBlock.add(new SPIRVOpIMul(longType, ans, lhs, rhsId));\n+                            else if (op instanceof SpirvOps.IDivOp) spirvBlock.add(new SPIRVOpSDiv(longType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == floatType) {\n+                            if (op instanceof SpirvOps.FMulOp) spirvBlock.add(new SPIRVOpFMul(floatType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOps.FDivOp) spirvBlock.add(new SPIRVOpFDiv(floatType, ans, lhs, rhs));\n+                        }\n+                        else unsupported(\"type\", lhsType);\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.ModOp mop -> {\n+                        SPIRVId type = getType(mop.operands().get(0).type().toString());\n+                        SPIRVId lhs = getResult(mop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(mop.operands().get(1)).value();\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpUMod(type, result, lhs, rhs));\n+                        addResult(mop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.IEqualOp eqop -> {\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.CallOp call -> {\n+                        if (call.callDescriptor().equals(MethodDesc.ofString(\"spirvdemo.IntArray::get(long)int\")) ||\n+                            call.callDescriptor().equals(MethodDesc.ofString(\"spirvdemo.FloatArray::get(long)float\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 1;\n+                            SPIRVId index = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, array, index, new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(elementType, result, resultAddr, align(elementType.getName())));\n+                            addResult(call.result(), new SpirvResult(elementType, resultAddr, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.ofString(\"spirvdemo.IntArray::set(long, int)void\")) ||\n+                                call.callDescriptor().equals(MethodDesc.ofString(\"spirvdemo.FloatArray::set(long, float)void\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 2;\n+                            int valueIndex = nIndexes + 1;\n+                            SPIRVId index = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId dest = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, dest, array, index, new SPIRVMultipleOperands<>()));\n+                            SPIRVId value = getResult(call.operands().get(valueIndex)).value();\n+                            spirvBlock.add(new SPIRVOpStore(dest, value, align(elementType.getName())));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"fromArray\", IntVector.class, VectorSpecies.class, int[].class, int.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"fromArray\", FloatVector.class, VectorSpecies.class, float[].class, int.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult speciesResult = getResult(call.operands().get(0));\n+                            SpirvResult arrayResult = getResult(call.operands().get(1));\n+                            String arrayType = arrayResult.type().getName();\n+                            int laneCount = 8;  \/\/TODO: remove hard code, instruction below needs a literal\n+                            String vTypeName = ((JavaType)call.callDescriptor().refType()).toClassName();\n+                            SPIRVId vType = spirvVectorType(vTypeName, laneCount);\n+                            SPIRVId array = arrayResult.value();\n+                            SPIRVId index = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSDiv(getType(\"int\"), vectorIndex, index, speciesResult.value()));\n+                            SPIRVId longIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), longIndex, vectorIndex));\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(longIndex, array, new SPIRVId(laneCount)); \/\/ TODO: lanes must be a literal\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, vector, oclExtension, new SPIRVLiteralExtInstInteger(171, \"vloadn\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"fromMemorySegment\", IntVector.class, VectorSpecies.class, MemorySegment.class, long.class, ByteOrder.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"fromMemorySegment\", FloatVector.class, VectorSpecies.class, MemorySegment.class, long.class, ByteOrder.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SPIRVId species = getResult(call.operands().get(0)).value();\n+                            SPIRVId lanesLong = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), lanesLong, species));\n+                            int laneCount = 8; \/\/TODO: remove hard code, vloadn instruction below needs a literal lane count, get value from env\n+                            SPIRVId segment = getResult(call.operands().get(1)).value();\n+                            String vTypeName = ((JavaType)call.callDescriptor().refType()).toClassName();\n+                            SPIRVId vType = spirvVectorType(vTypeName, laneCount);\n+                            SPIRVId temp = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(getType(\"long\"), temp, segment));\n+                            SPIRVId typedSegment = nextId();\n+                            SPIRVId pointerType = (SPIRVId)map(x -> x.equals(vTypeName), \"jdk.incubator.vector.IntVector\", \"jdk.incubator.vector.FloatVector\", getType(\"ptrInt\"), getType(\"ptrFloat\"));\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(pointerType, typedSegment, temp));\n+                            SPIRVId offset = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSDiv(getType(\"long\"), vectorIndex, offset, lanesLong)); \/\/ divide by lane count\n+                            SPIRVId finalIndex = nextId();\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(vectorIndex, typedSegment, new SPIRVId(laneCount)); \/\/ TODO: lanes must be a literal\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, vector, oclExtension, new SPIRVLiteralExtInstInteger(171, \"vloadn\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"intoArray\", void.class, int[].class, int.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"intoArray\", void.class, float[].class, int.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vector = vectorResult.value();\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SpirvResult arrayResult = getResult(call.operands().get(1));\n+                            SPIRVId array = arrayResult.value();\n+                            SPIRVId index = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpShiftRightArithmetic(getType(\"int\"), vectorIndex, index, vectorExponent(vectorType.getName())));\n+                            SPIRVId longIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), longIndex, vectorIndex));\n+                            SPIRVMultipleOperands<SPIRVId> operandsR = new SPIRVMultipleOperands<>(vector, longIndex, array);\n+                            spirvBlock.add(new SPIRVOpExtInst(getType(\"void\"), nextId(), oclExtension, new SPIRVLiteralExtInstInteger(172, \"vstoren\"), operandsR));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"intoMemorySegment\", void.class, MemorySegment.class, long.class, ByteOrder.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"intoMemorySegment\", void.class, MemorySegment.class, long.class, ByteOrder.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vector = vectorResult.value();\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SpirvResult segmentResult = getResult(call.operands().get(1));;\n+                            SPIRVId segment = segmentResult.value();\n+                            SPIRVId temp = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(getType(\"long\"), temp, segment));\n+                            SPIRVId typedSegment = nextId();\n+                            String vectorElementType = vectorElementType(vectorType).getName();\n+                            SPIRVId pointerType = (SPIRVId)map(x -> x.equals(vectorElementType), \"int\", \"float\", getType(\"ptrInt\"), getType(\"ptrFloat\"));\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(pointerType, typedSegment, temp));\n+                            SPIRVId offset = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            int laneCount = laneCount(vectorType.getName());\n+                            spirvBlock.add(new SPIRVOpShiftRightArithmetic(getType(\"long\"), vectorIndex, offset, vectorExponent(vectorType.getName())));\n+                            SPIRVMultipleOperands<SPIRVId> operandsR = new SPIRVMultipleOperands<>(vector, vectorIndex, typedSegment);\n+                            spirvBlock.add(new SPIRVOpExtInst(getId(\"void\"), nextId(), oclExtension, new SPIRVLiteralExtInstInteger(172, \"vstoren\"), operandsR));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"reduceLanes\", int.class, VectorOperators.Associative.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"reduceLanes\", float.class, VectorOperators.Associative.class))) {\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SPIRVId vector = vectorResult.value();\n+                            String vTypeName = vectorType.getName();\n+                            SPIRVId elementType = vectorElementType(vectorType);\n+                            Op reduceOp = ((Op.Result)call.operands().get(1)).op();\n+                            if (reduceOp instanceof SpirvOps.FieldLoadOp flo) {\n+                                assert flo.fieldDescriptor().refType().equals(JavaType.type(VectorOperators.class));\n+                                assert flo.fieldDescriptor().name().equals(\"ADD\");\n+                                String operation = flo.fieldDescriptor().name();\n+                            }\n+                            else unsupported(\"operation expression\", reduceOp.toText());\n+                            String tempTag = nextTempTag();\n+                            SPIRVId temp_0 = nextId(tempTag + 0);\n+                            spirvBlock.add(new SPIRVOpCompositeExtract(elementType, temp_0, vector, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(0))));\n+                            for (int lane = 1; lane < laneCount(vectorType.getName()); lane++) {\n+                                SPIRVId temp = nextId(tempTag + lane);\n+                                SPIRVId element = nextId();\n+                                spirvBlock.add(new SPIRVOpCompositeExtract(elementType, element, vector, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(lane))));\n+                                if (elementType == getType(\"int\")) {\n+                                    spirvBlock.add(new SPIRVOpIAdd(elementType, temp, getId(tempTag + (lane - 1)), element));\n+                                }\n+                                else if (elementType == getType(\"float\")) {\n+                                    spirvBlock.add(new SPIRVOpFAdd(elementType, temp, getId(tempTag + (lane - 1)), element));\n+                                }\n+                                else unsupported(\"type\", elementType.getName());\n+                            }\n+                            addResult(call.result(), new SpirvResult(elementType, null, getId(tempTag + (laneCount(vectorType.getName()) - 1))));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"add\", IntVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"mul\", IntVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"add\", FloatVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"mul\", FloatVector.class, Vector.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult lhsResult = getResult(call.operands().get(0));\n+                            SPIRVId lhsType = lhsResult.type();\n+                            SPIRVId lhs = lhsResult.value();\n+                            SPIRVId rhs = getResult(call.operands().get(1)).value();\n+                            SPIRVId add = nextId();\n+                            if (call.callDescriptor().name().equals(\"add\")) {\n+                                spirvBlock.add(lhsType.getName().endsWith(\"int\") ? new SPIRVOpIAdd(lhsType, add, lhs, rhs) : new SPIRVOpFAdd(lhsType, add, lhs, rhs));\n+                            }\n+                            else if (call.callDescriptor().name().equals(\"mul\")) {\n+                                spirvBlock.add(lhsType.getName().endsWith(\"int\") ? new SPIRVOpIMul(lhsType, add, lhs, rhs) : new SPIRVOpFMul(lhsType, add, lhs, rhs));\n+                            }\n+                            addResult(call.result(), new SpirvResult(lhsType, null, add));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"fma\", FloatVector.class, Vector.class, Vector.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult aResult = getResult(call.operands().get(0));\n+                            SPIRVId vType = aResult.type();\n+                            SPIRVId a = aResult.value();\n+                            SPIRVId b = getResult(call.operands().get(1)).value();\n+                            SPIRVId c = getResult(call.operands().get(2)).value();\n+                            String vTypeStr = vType.getName();\n+                            assert vTypeStr.endsWith(\"float\");\n+                            SPIRVId result  = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(a, b, c);\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, result, oclExtension, new SPIRVLiteralExtInstInteger(26, \"fma\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"zero\", IntVector.class, VectorSpecies.class))\n+                             || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"zero\", FloatVector.class, VectorSpecies.class))) {\n+                            SpirvResult speciesResult = getResult(call.operands().get(0));\n+                            SPIRVId vType = spirvType(((JavaType)call.callDescriptor().refType()).toClassName());\n+                            String elementType = vectorElementType(vType).getName();\n+                            SPIRVId value = getId(elementType + \"_ZERO\");\n+                            int laneCount = laneCount(vType.getName());\n+                            assert laneCount == 8 || laneCount == 16;\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = spirvOperands(value, laneCount);\n+                            spirvBlock.add(new SPIRVOpCompositeConstruct(vType, vector, operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(IntVector.class, \"lane\", int.class, int.class))\n+                              || call.callDescriptor().equals(MethodDesc.method(FloatVector.class, \"lane\", float.class, int.class)))  {\n+                            SpirvResult lhsResult = getResult(call.operands().get(0));\n+                            SPIRVId lhsType = lhsResult.type();\n+                            SPIRVId lhs = lhsResult.value();\n+                            String vTypeStr = lhsType.getName();\n+                            SPIRVId vType = lhsResult.type();\n+                            SPIRVId elementType = vectorElementType(vType);\n+                            SPIRVId result = nextId();\n+                            Op laneOp = ((Op.Result)call.operands().get(1)).op();\n+                            assert laneOp instanceof SpirvOps.ConstantOp;\n+                            int lane = (int)((SpirvOps.ConstantOp)laneOp).value();\n+                            spirvBlock.add(new SPIRVOpCompositeExtract(elementType, result, lhsResult.value(), new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(lane))));\n+                            addResult(call.result(), new SpirvResult(elementType, null, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodDesc.method(VectorSpecies.class, \"length\", int.class))) {\n+                            addResult(call.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\"))); \/\/ TODO: remove hardcode\n+                        }\n+                        else unsupported(\"method\", call.callDescriptor());\n+                    }\n+                    case SpirvOps.ConstantOp cop -> {\n+                        SPIRVId type = spirvType(cop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        Object value = cop.value();\n+                        if (type == getType(\"int\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentInt(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"long\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentLong(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"float\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentFloat((float)value)));\n+                        }\n+                        else unsupported(\"type\", cop.resultType());\n+                        addResult(cop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.ConvertOp scop -> {\n+                        SPIRVId toType = spirvType(scop.resultType().toString());\n+                        SPIRVId to = nextId();\n+                        SpirvResult valueResult = getResult(scop.operands().get(0));\n+                        SPIRVId from = valueResult.value();\n+                        SPIRVId fromType = valueResult.type();\n+                        if (isIntegerType(fromType)) {\n+                            if (isIntegerType(toType)) {\n+                                spirvBlock.add(new SPIRVOpSConvert(toType, to, from));\n+                            }\n+                            else if (isFloatType(toType)) {\n+                                spirvBlock.add(new SPIRVOpConvertSToF(toType, to, from));\n+                            }\n+                            else unsupported(\"conversion type\", scop.resultType());\n+                        }\n+                        else unsupported(\"conversion type\", scop.operands().get(0));\n+                        addResult(scop.result(), new SpirvResult(toType, null, to));\n+                    }\n+                    case SpirvOps.InBoundAccessChainOp iacop -> {\n+                        SPIRVId type = spirvType(iacop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        SPIRVId object = getResult(iacop.operands().get(0)).value();\n+                        SPIRVId index = getResult(iacop.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(type, result, object, index, new SPIRVMultipleOperands<>()));\n+                        addResult(iacop.result(), new SpirvResult(type, result, null));\n+                    }\n+                    case SpirvOps.FieldLoadOp flo -> {\n+                        if (flo.operands().size() > 0 && flo.operands().get(0).type().equals(JavaType.ofString(\"spirvdemo.GPU$Index\"))) {\n+                            SpirvResult result;\n+                            int group = -1;\n+                            int index = -1;\n+                            String fieldName = flo.fieldDescriptor().name();\n+                            switch(fieldName) {\n+                                case \"x\": group = 0; index = 0; break;\n+                                case \"y\": group = 0; index = 1; break;\n+                                case \"z\": group = 0; index = 2; break;\n+                                case \"w\": group = 1; index = 0; break;\n+                                case \"h\": group = 1; index = 1; break;\n+                                case \"d\": group = 1; index = 2; break;\n+                            }\n+                            switch (group) {\n+                                case 0: result = globalId(index, spirvBlock); break;\n+                                case 1: result = globalSize(index, spirvBlock); break;\n+                                default: throw new RuntimeException(\"Unknown Index field: \" + fieldName);\n+                            }\n+                            addResult(flo.result(), result);\n+                        }\n+                        else if (((JavaType)flo.resultType()).equals(JavaType.type(VectorSpecies.class))) {\n+                            addResult(flo.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\")));\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(VectorOperators.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(ByteOrder.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else unsupported(\"field load\", ((JavaType)flo.fieldDescriptor().refType()).toClassName() + \".\" + flo.fieldDescriptor().name());\n+                    }\n+                    case SpirvOps.BranchOp bop -> {\n+                        SPIRVId trueLabel = symbols.getLabel(bop.branch()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranch(trueLabel));\n+                    }\n+                    case SpirvOps.ConditionalBranchOp cbop -> {\n+                        SPIRVId test = getResult(cbop.operands().get(0)).value();\n+                        SPIRVId trueLabel = symbols.getLabel(cbop.trueBranch()).getResultId();\n+                        SPIRVId falseLabel = symbols.getLabel(cbop.falseBranch()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranchConditional(test, trueLabel, falseLabel, new SPIRVMultipleOperands<SPIRVLiteralInteger>()));\n+                    }\n+                    case SpirvOps.LtOp ltop -> {\n+                        SPIRVId lhs = getResult(ltop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(ltop.operands().get(1)).value();\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpSLessThan(boolType, result, lhs, rhs));\n+                        addResult(ltop.result(), new SpirvResult(boolType, null, result));\n+                    }\n+                    case SpirvOps.ReturnOp rop -> {\n+                        if (rop.operands().size() == 0) {\n+                            spirvBlock.add(new SPIRVOpReturn());\n+                        }\n+                        else {\n+                            SPIRVId returnValue = getResult(rop.operands().get(0)).value();\n+                            spirvBlock.add(new SPIRVOpReturnValue(returnValue));\n+                        }\n+                    }\n+                    default -> unsupported(\"op\", op.getClass());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void initModule() {\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Addresses()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Linkage()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Kernel()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int8()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int16()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int64()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Vector16()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Float16()));\n+        module.add(new SPIRVOpMemoryModel(SPIRVAddressingModel.Physical64(), SPIRVMemoryModel.OpenCL()));\n+\n+        \/\/ OpenCL extension provides built-in variables suitable for kernel programming\n+        \/\/ Import extention and declare fourn variables\n+        SPIRVId oclExtension = nextId(\"oclExtension\");\n+        module.add(new SPIRVOpExtInstImport(oclExtension, new SPIRVLiteralString(\"OpenCL.std\")));\n+\n+        SPIRVId globalInvocationId = nextId(\"globalInvocationId\");\n+        SPIRVId globalSize = nextId(\"globalSize\");\n+        SPIRVId subgroupSize = nextId(\"subgroupSize\");\n+        SPIRVId subgroupId = nextId(\"subgroupId\");\n+\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalInvocationId())));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalInvocationId\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalSize())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupSize())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupId())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupId\"), SPIRVLinkageType.Import())));\n+\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalInvocationId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+    }\n+\n+    private SPIRVId spirvType(String javaType) {\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte\" -> getType(\"byte\");\n+            case \"short\" -> getType(\"short\");\n+            case \"int\" -> getType(\"int\");\n+            case \"long\" -> getType(\"long\");\n+            case \"float\" -> getType(\"float\");\n+            case \"double\" -> getType(\"double\");\n+            case \"int[]\" -> getType(\"int[]\");\n+            case \"float[]\" -> getType(\"float[]\");\n+            case \"double[]\" -> getType(\"double[]\");\n+            case \"long[]\" -> getType(\"long[]\");\n+            case \"bool\" -> getType(\"bool\");\n+            case \"spirvdemo.IntArray\" -> getType(\"int[]\");\n+            case \"spirvdemo.FloatArray\" -> getType(\"float[]\");\n+            case \"jdk.incubator.vector.IntVector\" -> spirvVectorType(\"IntVector\", 8);\n+            case \"jdk.incubator.vector.FloatVector\" -> spirvVectorType(\"FloatVector\", 8);\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Integer>\" -> getType(\"int\");\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Long>\" -> getType(\"long\");\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Float>\" -> getType(\"int\");\n+            case \"VectorSpecies\" -> getType(\"int\");\n+            case \"void\" -> getType(\"void\");\n+            case \"spirvdemo.GPU$Index\" -> getType(\"ptrGPUIndex\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"ptrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvElementType(String javaType) {\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte[]\" -> getType(\"byte\");\n+            case \"short[]\" -> getType(\"short\");\n+            case \"int[]\" -> getType(\"int\");\n+            case \"long[]\" -> getType(\"long\");\n+            case \"float[]\" -> getType(\"float\");\n+            case \"double[]\" -> getType(\"double\");\n+            case \"boolean[]\" -> getType(\"bool\");\n+            case \"spirvdemo.IntArray\" -> getType(\"int\");\n+            case \"spirvdemo.FloatArray\" -> getType(\"float\");\n+            case \"jdk.incubator.vector.LongVector\" -> getType(\"long\");\n+            case \"jdk.incubator.vector.FloatVector\" -> getType(\"float\");\n+            case \"IntVector\" -> getType(\"int\");\n+            case \"LongVector\" -> getType(\"long\");\n+            case \"FloatVector\" -> getType(\"float\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"byte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorElementType(SPIRVId type) {\n+        SPIRVId ans = switch(type.getName()) {\n+            case \"v8int\" -> getType(\"int\");\n+            case \"v16int\" -> getType(\"int\");\n+            case \"v8long\" -> getType(\"long\");\n+            case \"v8float\" -> getType(\"float\");\n+            case \"v16float\" -> getType(\"float\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", type.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVariableType(SPIRVId spirvType) {\n+        SPIRVId ans = switch(spirvType.getName()) {\n+            case \"byte\" -> getType(\"ptrByte\");\n+            case \"short\" -> getType(\"ptrShort\");\n+            case \"int\" -> getType(\"ptrInt\");\n+            case \"long\" -> getType(\"ptrLong\");\n+            case \"float\" -> getType(\"ptrFloat\");\n+            case \"double\" -> getType(\"ptrDouble\");\n+            case \"boolean\" -> getType(\"ptrBool\");\n+            case \"int[]\" -> getType(\"ptrInt[]\");\n+            case \"long[]\" -> getType(\"ptrLong[]\");\n+            case \"float[]\" -> getType(\"ptrFloat[]\");\n+            case \"double[]\" -> getType(\"ptrDouble[]\");\n+            case \"v8int\" -> getType(\"ptrV8int\");\n+            case \"v16int\" -> getType(\"ptrV16int\");\n+            case \"v8long\" -> getType(\"ptrV8long\");\n+            case \"v8float\" -> getType(\"ptrV8float\");\n+            case \"v16float\" -> getType(\"ptrV16float\");\n+            case \"ptrGPUIndex\" -> getType(\"ptrPtrGPUIndex\");\n+            case \"ptrByte\" -> getType(\"ptrPtrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", spirvType.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVectorType(String javaVectorType, int vectorLength) {\n+        String prefix = \"v\" + vectorLength;\n+        String elementType = spirvElementType(javaVectorType).getName();\n+        return getType(prefix + elementType);\n+    }\n+\n+    private int alignment(String spirvType) {\n+        int ans = switch(spirvType) {\n+            case \"byte\" -> 1;\n+            case \"short\" -> 2;\n+            case \"int\" -> 4;\n+            case \"long\" -> 8;\n+            case \"float\" -> 4;\n+            case \"double\" -> 8;\n+            case \"boolean\" -> 1;\n+            case \"v8int\" -> 32;\n+            case \"v16int\" -> 64;\n+            case \"v8long\" -> 64;\n+            case \"v8float\" -> 32;\n+            case \"v16float\" -> 64;\n+            case \"ptrGPUIndex\" -> 32;\n+            case \"int[]\" -> 8;\n+            case \"long[]\" -> 8;\n+            case \"float[]\" -> 8;\n+            case \"double[]\" -> 8;\n+            case \"ptrByte\" -> 8;\n+            case \"ptrInt\" -> 8;\n+            case \"ptrInt[]\" -> 8;\n+            case \"ptrLong\" -> 8;\n+            case \"ptrLong[]\" -> 8;\n+            case \"ptrFloat\" -> 8;\n+            case \"ptrFloat[]\" -> 8;\n+            case \"ptrV8int\" -> 8;\n+            case \"ptrV8float\" -> 8;\n+            case \"ptrPtrGPUIndex\" -> 8;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", spirvType);\n+        return ans;\n+    }\n+\n+    private int laneCount(String vectorType) {\n+        int ans = switch(vectorType) {\n+            case \"v8int\" -> 8;\n+            case \"v8long\" -> 8;\n+            case \"v8float\" -> 8;\n+            case \"v16int\" -> 16;\n+            case \"v16float\" -> 16;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", vectorType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorExponent(String vectorType) {\n+        SPIRVId ans = null;\n+        switch(vectorType) {\n+            case \"v8int\" -> ans = getId(\"int_THREE\");\n+            case \"v8long\" -> ans = getId(\"int_THREE\");\n+            case \"v8float\" -> ans = getId(\"int_THREE\");\n+            case \"v16int\" -> ans = getId(\"int_FOUR\");\n+            case \"v16float\" -> ans = getId(\"int_FOUR\");\n+            default -> unsupported(\"type\", vectorType);\n+        };\n+        return ans;\n+    }\n+\n+    private Set<String> moduleTypes = new HashSet<>();\n+\n+    private SPIRVId getType(String name) {\n+        if (!moduleTypes.contains(name)) {\n+            switch (name) {\n+                case \"void\" -> module.add(new SPIRVOpTypeVoid(nextId(name)));\n+                case \"bool\" -> module.add(new SPIRVOpTypeBool(nextId(name)));\n+                case \"byte\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(8), new SPIRVLiteralInteger(0)));\n+                case \"short\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(16), new SPIRVLiteralInteger(0)));\n+                case \"int\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(32), new SPIRVLiteralInteger(0)));\n+                case \"long\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(64), new SPIRVLiteralInteger(0)));\n+                case \"float\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(32)));\n+                case \"double\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(64)));\n+                case \"ptrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int\")));\n+                case \"ptrLong\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long\")));\n+                case \"ptrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float\")));\n+                case \"short[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"short\")));\n+                case \"int[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"int\")));\n+                case \"long[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"long\")));\n+                case \"float[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"float\")));\n+                case \"double[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"double\")));\n+                case \"boolean[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"boolean\")));\n+                case \"ptrInt[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int[]\")));\n+                case \"ptrLong[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long[]\")));\n+                case \"ptrFloat[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float[]\")));\n+                case \"spirvdemo.GPUIndex\" -> module.add(new SPIRVOpTypeStruct(nextId(name), new SPIRVMultipleOperands<>(getType(\"long\"), getType(\"long\"), getType(\"long\"))));\n+                case \"ptrGPUIndex\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"spirvdemo.GPUIndex\")));\n+                case \"ptrCrossGroupByte\"-> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrPtrGPUIndex\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrGPUIndex\")));\n+                case \"ptrPtrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrByte\")));\n+                case \"v3long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(3)));\n+                case \"v8int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(8)));\n+                case \"v8long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(8)));\n+                case \"v16int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(16)));\n+                case \"v8float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(8)));\n+                case \"v16float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(16)));\n+                case \"ptrV3long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Input(), getType(\"v3long\")));\n+                case \"ptrV8long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8long\")));\n+                case \"ptrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8int\")));\n+                case \"ptrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16int\")));\n+                case \"ptrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8float\")));\n+                case \"ptrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16float\")));\n+                case \"ptrPtrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8int\")));\n+                case \"ptrPtrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16int\")));\n+                case \"ptrPtrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8float\")));\n+                case \"ptrPtrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16float\")));\n+                default -> unsupported(\"type\", name);\n+            }\n+            moduleTypes.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private Set<String> moduleConstants = new HashSet<>();\n+\n+    private SPIRVId getConst(String name) {\n+        if (!moduleConstants.contains(name)) {\n+            switch (name) {\n+                case \"int_ZERO\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_ZERO\"), new SPIRVContextDependentInt(new BigInteger(\"0\"))));\n+                case \"int_ONE\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_ONE\"), new SPIRVContextDependentInt(new BigInteger(\"1\"))));\n+                case \"int_TWO\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_TWO\"), new SPIRVContextDependentInt(new BigInteger(\"2\"))));\n+                case \"int_EIGHT\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_EIGHT\"), new SPIRVContextDependentInt(new BigInteger(\"8\"))));\n+                default -> unsupported(\"constant\", name);\n+            }\n+            moduleConstants.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(int align) {\n+        return new SPIRVOptionalOperand<>(SPIRVMemoryAccess.Aligned(new SPIRVLiteralInteger(align)));\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(String type) {\n+        return align(alignment(type));\n+    }\n+\n+    private SPIRVMultipleOperands<SPIRVId> spirvOperands(SPIRVId value, int count) {\n+        SPIRVId[] values = new SPIRVId[count];\n+        Arrays.fill(values, value);\n+        return new SPIRVMultipleOperands<>(values);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> none() {\n+        return new SPIRVOptionalOperand<>();\n+    }\n+\n+    private SpirvResult globalSize(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalSizeId = getId(\"globalSize\");\n+        SPIRVId globalSizes = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalSizes, globalSizeId, align(32)));\n+        SPIRVId globalSize = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, globalSize, globalSizes, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        return new SpirvResult(longType, null, globalSize);\n+    }\n+\n+    private SpirvResult globalId(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalInvocationId = getId(\"globalInvocationId\");\n+        SPIRVId globalIds = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalIds, globalInvocationId, align(32)));\n+        SPIRVId globalIndex = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, globalIndex, globalIds, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        return new SpirvResult(longType, null, globalIndex);\n+    }\n+\n+    private SPIRVId nextId() {\n+        return module.getNextId();\n+    }\n+\n+    private SPIRVId nextId(String name) {\n+        SPIRVId ans = nextId();\n+        ans.setName(name);\n+        symbols.putId(name, ans);\n+        module.add(new SPIRVOpName(ans, new SPIRVLiteralString(name)));\n+        return ans;\n+    }\n+\n+    private static int counter = 0;\n+\n+    private String nextTempTag() {\n+        counter++;\n+        return \"temp_\" + counter + \"_\";\n+    }\n+\n+    private boolean isIntegerType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"short\") || name.equals(\"int\") || name.equals(\"long\");\n+    }\n+\n+    private boolean isFloatType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"float\") || name.equals(\"double\");\n+    }\n+\n+    private boolean isVectorSpecies(String javaType) {\n+        return javaType.equals(\"VectorSpecies\");\n+    }\n+\n+    private boolean isVectorType(String javaType) {\n+        return javaType.equals(\"IntVector\") || javaType.equals(\"FloatVector\");\n+    }\n+\n+    private void addId(String name, SPIRVId id) {\n+        symbols.putId(name, id);\n+    }\n+\n+    private SPIRVId getId(String name) {\n+        SPIRVId ans = symbols.getId(name);\n+        assert ans != null : name + \" not found\";\n+        return ans;\n+    }\n+\n+    private SPIRVId getIdOrNull(String name) {\n+        return symbols.getId(name);\n+    }\n+\n+    private static Object map(Function<Object, Boolean> test, Object... args) {\n+        int len = args.length;\n+        assert len >= 2 && len % 2 == 0;\n+        int pairs = len \/ 2;\n+        for (int i = 0; i < pairs; i++) {\n+            if (test.apply(args[i])) return args[i + pairs];\n+        }\n+        throw new RuntimeException(\"No match: \" + args[0]);\n+    }\n+\n+    private void unsupported(String message, Object value) {\n+        throw new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private void addResult(Value value, SpirvResult result) {\n+        assert symbols.getResult(value) == null : \"result already present\";\n+        symbols.putResult(value, result);\n+    }\n+\n+    private SpirvResult getResult(Value value) {\n+        return symbols.getResult(value);\n+    }\n+\n+    private static class Symbols {\n+        private final HashMap<Value, SpirvResult> results;\n+        private final HashMap<String, SPIRVId> ids;\n+        private final HashMap<Block, SPIRVBlock> blocks;\n+        private final HashMap<Block, SPIRVOpLabel> labels;\n+\n+        public Symbols() {\n+            this.results = new HashMap<>();\n+            this.ids = new HashMap<>();\n+            this.blocks = new HashMap<>();\n+            this.labels = new HashMap<>();\n+        }\n+\n+        public void putId(String name, SPIRVId id) {\n+            ids.put(name, id);\n+        }\n+\n+        public SPIRVId getId(String name) {\n+            return ids.get(name);\n+        }\n+\n+        public void putBlock(Block block, SPIRVBlock spirvBlock) {\n+            blocks.put(block, spirvBlock);\n+        }\n+\n+        public SPIRVBlock getBlock(Block block) {\n+            return blocks.get(block);\n+        }\n+\n+        public void putLabel(Block block, SPIRVOpLabel spirvLabel) {\n+            labels.put(block, spirvLabel);\n+        }\n+\n+        public SPIRVOpLabel getLabel(Block block) {\n+            return labels.get(block);\n+        }\n+\n+        public void putResult(Value value, SpirvResult result) {\n+            results.put(value, result);\n+        }\n+\n+        public SpirvResult getResult(Value value) {\n+            return results.get(value);\n+        }\n+\n+        public String toString() {\n+            return String.format(\"results %s\\n\\nids %s\\n\\nblocks %s\\nlabels %s\\n\", results.keySet(), ids.keySet(), blocks.keySet(), labels.keySet());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":1035,"deletions":0,"binary":false,"changes":1035,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public abstract class SpirvOp extends Op {\n+    private final TypeElement type;\n+\n+    SpirvOp(String opName) {\n+        super(opName, List.of());\n+        this.type = JavaType.VOID;\n+    }\n+\n+    SpirvOp(String opName, TypeElement type, List<Value> operands) {\n+        super(opName, operands);\n+        this.type = type;\n+    }\n+\n+    SpirvOp(String opName, TypeElement type, List<Value> operands, Map<String, Object> attributes) {\n+        super(opName, operands);\n+        this.type = type;\n+    }\n+\n+    SpirvOp(SpirvOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.type = that.type;\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return type;\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,665 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public class SpirvOps {\n+    private static final String NAME_PREFIX = \"spirv.\";\n+\n+    public static final class ModuleOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"module\";\n+\n+        private final String name;\n+\n+        public ModuleOp(String moduleName) {\n+            super(OPNAME);\n+            this.name = moduleName;\n+        }\n+\n+        public ModuleOp(ModuleOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.name = that.name;\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc);\n+        }\n+    }\n+\n+    public static final class LoadOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"load\";\n+\n+        public LoadOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public LoadOp(LoadOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LoadOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FieldLoadOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"fieldload\";\n+        private final FieldDesc fieldDesc;\n+\n+        public FieldLoadOp(TypeElement resultType, FieldDesc fieldDesc, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+            this.fieldDesc = fieldDesc;\n+        }\n+\n+        public FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.fieldDesc = that.fieldDesc;\n+        }\n+\n+        @Override\n+        public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FieldLoadOp(this, cc);\n+        }\n+\n+        public FieldDesc fieldDescriptor() {\n+            return fieldDesc;\n+        }\n+    }\n+\n+    public static final class StoreOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"store\";\n+\n+        public StoreOp(Value dest, Value value) {\n+            super(NAME, JavaType.VOID, List.of(dest, value));\n+        }\n+\n+        public StoreOp(StoreOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StoreOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StoreOp(this, cc);\n+        }\n+    }\n+\n+    public static final class CallOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"call\";\n+        private MethodDesc descriptor;\n+\n+        public CallOp(MethodDesc descriptor, List<Value> operands) {\n+            super(nameString(descriptor), descriptor.type().returnType(), operands);\n+            this.descriptor = descriptor;\n+        }\n+\n+        public CallOp(CallOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CallOp(this, cc);\n+        }\n+\n+        public MethodDesc callDescriptor() {\n+            return descriptor;\n+        }\n+\n+        private static String nameString(MethodDesc descriptor) {\n+            return OPNAME + \" @\" + descriptor.refType() + \"::\" + descriptor.name();\n+        }\n+    }\n+\n+    public static final class ArrayLengthOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"arraylength\";\n+\n+        public ArrayLengthOp(TypeElement resultType, List<Value> operands) {\n+            super(NAME, resultType, operands);\n+        }\n+\n+        public ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ConstantOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"constant\";\n+        private final Object value;\n+\n+        public ConstantOp(TypeElement resultType, Object value) {\n+                super(OPNAME, resultType, List.of());\n+                this.value = value;\n+        }\n+\n+        public ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+    }\n+\n+    public static final class ConvertOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"sconvert\";\n+\n+        public ConvertOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public ConvertOp(ConvertOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConvertOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvertOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IAddOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"iadd\";\n+\n+        public IAddOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IAddOp(IAddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IAddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IAddOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FAddOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fadd\";\n+\n+        public FAddOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FAddOp(FAddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FAddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FAddOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ISubOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"isub\";\n+\n+        public ISubOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public ISubOp(ISubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ISubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ISubOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FSubOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fsub\";\n+\n+        public FSubOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FSubOp(FSubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FSubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FSubOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IMulOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"imul\";\n+\n+        public IMulOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IMulOp(IMulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IMulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IMulOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FMulOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fmul\";\n+\n+        public FMulOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FMulOp(FMulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FMulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FMulOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IDivOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"idiv\";\n+\n+        public IDivOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IDivOp(IDivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IDivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IDivOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FDivOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fdiv\";\n+\n+        public FDivOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FDivOp(FDivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FDivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FDivOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ModOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"mod\";\n+\n+        public ModOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public ModOp(ModOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ModOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"iequal\";\n+\n+        public IEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IEqualOp(IEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fequal\";\n+\n+        public FEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FEqualOp(FEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class INotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"inotequal\";\n+\n+        public INotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public INotEqualOp(INotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public INotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new INotEqualOp(this, cc);\n+        }\n+    }\n+\n+\n+    public static final class FNotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fnotequal\";\n+\n+        public FNotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FNotEqualOp(FNotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FNotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FNotEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class LtOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"lt\";\n+\n+        public LtOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public LtOp(LtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LtOp(this, cc);\n+        }\n+    }\n+\n+    public static final class BranchOp extends SpirvOp implements Op.BlockTerminating {\n+        public static final String NAME = NAME_PREFIX + \"br\";\n+        private final Block.Reference successor;\n+\n+        public BranchOp(Block.Reference successor) {\n+            super(NAME, JavaType.VOID, List.of());\n+            this.successor = successor;\n+        }\n+\n+        public BranchOp(BranchOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.successor = that.successor;\n+        }\n+\n+        @Override\n+        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BranchOp(this, cc);\n+        }\n+\n+        public Block branch() {\n+            return successor.targetBlock();\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(successor);\n+        }\n+    }\n+\n+    public static final class ConditionalBranchOp extends SpirvOp implements Op.BlockTerminating {\n+        public static final String NAME = NAME_PREFIX + \"brcond\";\n+        private final Block.Reference trueBlock;\n+        private final Block.Reference falseBlock;\n+\n+        public ConditionalBranchOp(Block.Reference trueBlock, Block.Reference falseBlock, List<Value> operands) {\n+                super(NAME, JavaType.VOID, operands);\n+                this.trueBlock = trueBlock;\n+                this.falseBlock = falseBlock;\n+        }\n+\n+        public ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.trueBlock = that.trueBlock;\n+            this.falseBlock = that.falseBlock;\n+        }\n+\n+        @Override\n+        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConditionalBranchOp(this, cc);\n+        }\n+\n+        public Block trueBranch() {\n+            return trueBlock.targetBlock();\n+        }\n+\n+        public Block falseBranch() {\n+            return falseBlock.targetBlock();\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(trueBlock, falseBlock);\n+        }\n+    }\n+\n+    public static final class VariableOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"variable\";\n+        private final String varName;\n+        private final TypeElement varType;\n+\n+        public VariableOp(String varName, TypeElement type, TypeElement varType) {\n+            super(OPNAME + \" @\" + varName, type, List.of());\n+            this.varName = varName;\n+            this.varType = varType;\n+        }\n+\n+        public VariableOp(VariableOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.varName = that.varName;\n+            this.varType = that.varType;\n+        }\n+\n+        @Override\n+        public VariableOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VariableOp(this, cc);\n+        }\n+\n+        public TypeElement varType() {\n+            return varType;\n+        }\n+\n+        public String varName() {\n+            return varName;\n+        }\n+    }\n+\n+    public static final class CompositeExtractOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"compositeExtract\";\n+\n+        public CompositeExtractOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public CompositeExtractOp(CompositeExtractOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CompositeExtractOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CompositeExtractOp(this, cc);\n+        }\n+    }\n+\n+    public static final class InBoundAccessChainOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"inBoundAccessChain\";\n+\n+        public InBoundAccessChainOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public InBoundAccessChainOp(InBoundAccessChainOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public InBoundAccessChainOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InBoundAccessChainOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ReturnOp extends SpirvOp implements Op.Terminating {\n+        public static final String OPNAME = \"return\";\n+\n+        public ReturnOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FunctionParameterOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"function parameter\";\n+\n+        public FunctionParameterOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public FunctionParameterOp(FunctionParameterOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FunctionParameterOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FunctionParameterOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FuncOp extends SpirvOp implements Op.Invokable {\n+        public static enum Control {\n+            INLINE,\n+            DONTINLINE,\n+            PURE,\n+            CONST,\n+            NONE\n+        }\n+\n+        public static final String OPNAME = NAME_PREFIX + \"function\";\n+        private final String functionName;\n+        private final FunctionType functionType;\n+        private final Body body;\n+\n+\n+        public FuncOp(String name, FunctionType functionType, Body.Builder builder) {\n+            super(OPNAME + \"_\" + name);\n+            this.functionName = name;\n+            this.functionType = functionType;\n+            this.body = builder.build(this);\n+        }\n+\n+        public FuncOp(FuncOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.functionName = that.functionName;\n+            this.functionType = that.functionType;\n+            this.body = that.body;\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, cc);\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public String functionName() {\n+            return functionName;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return functionType;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOps.java","additions":665,"deletions":0,"binary":false,"changes":665,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.code.TypeElement;\n+\n+public abstract sealed class SpirvType implements TypeElement permits PointerType, StorageType {\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public sealed abstract class StorageType extends SpirvType\n+    permits StorageType.Input, StorageType.Workgroup, StorageType.CrossWorkgroup, StorageType.Private, StorageType.Function {\n+\n+    public static final Input INPUT = new Input();\n+    public static final Workgroup WORKGROUP = new Workgroup();\n+    public static final CrossWorkgroup CROSSWORKGROUP= new CrossWorkgroup();\n+    public static final Private PRIVATE = new Private();\n+    public static final Function FUNCTION = new Function();\n+\n+    protected final String NAME;\n+\n+    protected StorageType(String name) {\n+        this.NAME = name;\n+    }\n+\n+    static final class Input extends StorageType {\n+        protected Input(){\n+            super(\"Input\");\n+        }\n+    }\n+\n+    static final class Workgroup extends StorageType {\n+        protected Workgroup() {\n+            super(\"Workgroup\");\n+        }\n+    }\n+\n+    static final class CrossWorkgroup extends StorageType\n+    {\n+        protected CrossWorkgroup() {\n+            super(\"CrossWorkgroup\");\n+        }\n+    }\n+\n+    static final class Private extends StorageType\n+    {\n+        protected Private() {\n+            super(\"Private\");\n+        }\n+    }\n+\n+    static final class Function extends StorageType\n+    {\n+        protected Function() {\n+            super(\"Function\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj != null && obj.getClass() != this.getClass();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(NAME);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public class TranslateToSpirvModel  {\n+    private Map<Block, Block.Builder> blockMap;    \/\/ Java block to spirv block builder\n+    private Map<Value, Value> valueMap;            \/\/ Java model Value to Spirv model Value\n+\n+    public static SpirvOps.FuncOp translateFunction(CoreOps.FuncOp func) {\n+        CoreOps.FuncOp lowFunc = lowerMethod(func);\n+        TranslateToSpirvModel instance = new TranslateToSpirvModel();\n+        Body.Builder bodyBuilder = instance.translateBody(lowFunc.body(), lowFunc, null);\n+        return new SpirvOps.FuncOp(lowFunc.funcName(), lowFunc.invokableType(), bodyBuilder);\n+    }\n+\n+    private TranslateToSpirvModel() {\n+        blockMap = new HashMap<>();\n+        valueMap = new HashMap<>();\n+    }\n+\n+    private Body.Builder translateBody(Body body, Op parentOp, Body.Builder parentBody) {\n+        Body.Builder bodyBuilder = Body.Builder.of(parentBody, body.bodyType());\n+        Block.Builder spirvBlock = bodyBuilder.entryBlock();\n+        blockMap.put(body.entryBlock(), spirvBlock);\n+        List<Block> blocks = body.blocks();\n+        \/\/ map Java blocks to spirv blocks\n+        for (Block b : blocks.subList(1, blocks.size()))  {\n+            Block.Builder loweredBlock = spirvBlock.block(b.parameterTypes());\n+            blockMap.put(b, loweredBlock);\n+            spirvBlock = loweredBlock;\n+        }\n+        \/\/ map entry block parameters to spirv function parameter\n+        spirvBlock = bodyBuilder.entryBlock();\n+        List<SpirvOp> paramOps = new ArrayList<>();\n+        List<SpirvOps.VariableOp> varOps = new ArrayList<>();\n+        Block entryBlock = body.entryBlock();\n+        int paramCount = entryBlock.parameters().size();\n+        for (int i = 0; i < paramCount; i++) {\n+            Block.Parameter bp = entryBlock.parameters().get(i);\n+            assert entryBlock.ops().get(i) instanceof CoreOps.VarOp;\n+            SpirvOp funcParam = new SpirvOps.FunctionParameterOp(bp.type(), List.of());\n+            spirvBlock.op(funcParam);\n+            valueMap.put(bp, funcParam.result());\n+            paramOps.add(funcParam);\n+        }\n+        \/\/ SPIR-V Variable ops must be the first ops in a function's entry block and do not include initialization.\n+        \/\/ Emit all SPIR-V Variable ops first and emit initializing stores afterward, at the CR model VarOp position.\n+        for (int i = 0; i < paramCount; i++) {\n+            CoreOps.VarOp jvop = (CoreOps.VarOp)entryBlock.ops().get(i);\n+            TypeElement resultType = new PointerType(jvop.varType(), StorageType.CROSSWORKGROUP);\n+            SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varType());\n+            spirvBlock.op(svop);\n+            valueMap.put(jvop.result(), svop.result());\n+            varOps.add(svop);\n+        }\n+        \/\/ add non-function-parameter variables\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            spirvBlock = blockMap.get(block);\n+            List<Op> ops = block.ops();\n+            for (int i = (bi == 0 ? paramCount : 0); i < ops.size(); i++) {\n+                if (bi > 0) spirvBlock = blockMap.get(block);\n+                Op op = ops.get(i);\n+                if (op instanceof CoreOps.VarOp jvop) {\n+                    TypeElement resultType = new PointerType(jvop.varType(), StorageType.CROSSWORKGROUP);\n+                    SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varType());\n+                    bodyBuilder.entryBlock().op(svop);\n+                    valueMap.put(jvop.result(), svop.result());\n+                    varOps.add(svop);\n+                }\n+            }\n+        }\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            spirvBlock = blockMap.get(block);\n+            for (Op op : block.ops()) {\n+                switch (op) {\n+                    case CoreOps.ReturnOp rop -> {\n+                        spirvBlock.op(new SpirvOps.ReturnOp(rop.resultType(), mapOperands(rop)));\n+                    }\n+                    case CoreOps.VarOp vop -> {\n+                        Value dest = valueMap.get(vop.result());\n+                        Value value = valueMap.get(vop.operands().get(0));\n+                        \/\/ init variable here; declaration has been moved to top of function\n+                        spirvBlock.op(new SpirvOps.StoreOp(dest, value));\n+                    }\n+                    case CoreOps.VarAccessOp.VarLoadOp vlo -> {\n+                        List<Value> operands = mapOperands(vlo);\n+                        SpirvOps.LoadOp load = new SpirvOps.LoadOp(vlo.resultType(), operands);\n+                        spirvBlock.op(load);\n+                        valueMap.put(vlo.result(), load.result());\n+                    }\n+                    case CoreOps.VarAccessOp.VarStoreOp vso -> {\n+                        Value dest = valueMap.get(vso.varOp().result());\n+                        Value value = valueMap.get(vso.operands().get(1));\n+                        spirvBlock.op(new SpirvOps.StoreOp(dest, value));\n+                    }\n+                    case CoreOps.ArrayAccessOp.ArrayLoadOp alo -> {\n+                        Value array = valueMap.get(alo.operands().get(0));\n+                        Value index = valueMap.get(alo.operands().get(1));\n+                        TypeElement arrayType = array.type();\n+                        SpirvOps.ConvertOp convert = new SpirvOps.ConvertOp(JavaType.type(long.class), List.of(index));\n+                        spirvBlock.op(new SpirvOps.LoadOp(arrayType, List.of(array)));\n+                        spirvBlock.op(convert);\n+                        SpirvOp ibac = new SpirvOps.InBoundAccessChainOp(arrayType, List.of(array, convert.result()));\n+                        spirvBlock.op(ibac);\n+                        SpirvOp load = new SpirvOps.LoadOp(alo.resultType(), List.of(ibac.result()));\n+                        spirvBlock.op(load);\n+                        valueMap.put(alo.result(), load.result());\n+                    }\n+                    case CoreOps.ArrayAccessOp.ArrayStoreOp aso -> {\n+                        Value array = valueMap.get(aso.operands().get(0));\n+                        Value index = valueMap.get(aso.operands().get(1));\n+                        TypeElement arrayType = array.type();\n+                        SpirvOp ibac = new SpirvOps.InBoundAccessChainOp(arrayType, List.of(array, index));\n+                        spirvBlock.op(ibac);\n+                        spirvBlock.op(new SpirvOps.StoreOp(ibac.result(), valueMap.get(aso.operands().get(2))));\n+                    }\n+                    case CoreOps.ArrayLengthOp alo -> {\n+                        Op len = new SpirvOps.ArrayLengthOp(JavaType.INT, List.of(valueMap.get(alo.operands().get(0))));\n+                        spirvBlock.op(len);\n+                        valueMap.put(alo.result(), len.result());\n+                    }\n+                    case CoreOps.AddOp aop -> {\n+                        TypeElement type = aop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(aop);\n+                        SpirvOp addOp;\n+                        if (isIntegerType(type)) addOp = new SpirvOps.IAddOp(type, operands);\n+                        else if (isFloatType(type)) addOp = new SpirvOps.FAddOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(addOp);\n+                        valueMap.put(aop.result(), addOp.result());\n+                     }\n+                    case CoreOps.SubOp sop -> {\n+                        TypeElement  type = sop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(sop);\n+                        SpirvOp subOp;\n+                        if (isIntegerType(type)) subOp = new SpirvOps.ISubOp(type, operands);\n+                        else if (isFloatType(type)) subOp = new SpirvOps.FSubOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(subOp);\n+                        valueMap.put(sop.result(), subOp.result());\n+                     }\n+                    case CoreOps.MulOp mop -> {\n+                        TypeElement type = mop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(mop);\n+                        SpirvOp mulOp;\n+                        if (isIntegerType(type)) mulOp = new SpirvOps.IMulOp(type, operands);\n+                        else if (isFloatType(type)) mulOp = new SpirvOps.FMulOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(mulOp);\n+                        valueMap.put(mop.result(), mulOp.result());\n+                    }\n+                    case CoreOps.DivOp dop -> {\n+                        TypeElement type = dop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(dop);\n+                        SpirvOp divOp;\n+                        if (isIntegerType(type)) divOp = new SpirvOps.IDivOp(type, operands);\n+                        else if (isFloatType(type)) divOp = new SpirvOps.FDivOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(divOp);\n+                        valueMap.put(dop.result(), divOp.result());\n+                    }\n+                    case CoreOps.ModOp mop -> {\n+                        TypeElement type = mop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(mop);\n+                        SpirvOp modOp = new SpirvOps.ModOp(type, operands);\n+                        spirvBlock.op(modOp);\n+                        valueMap.put(mop.result(), modOp.result());\n+                    }\n+                    case CoreOps.EqOp eqop -> {\n+                        TypeElement type = eqop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(eqop);\n+                        SpirvOp seqop;\n+                        if (isIntegerType(type)) seqop = new SpirvOps.IEqualOp(type, operands);\n+                        else if (isFloatType(type)) seqop = new SpirvOps.FEqualOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(seqop);\n+                        valueMap.put(eqop.result(), seqop.result());\n+                    }\n+                    case CoreOps.NeqOp neqop -> {\n+                        TypeElement type = neqop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(neqop);\n+                        SpirvOp sneqop;\n+                        if (isIntegerType(type)) sneqop = new SpirvOps.INotEqualOp(type, operands);\n+                        else if (isFloatType(type)) sneqop = new SpirvOps.FNotEqualOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(sneqop);\n+                        valueMap.put(neqop.result(), sneqop.result());\n+                    }\n+                    case CoreOps.LtOp ltop -> {\n+                        TypeElement type = ltop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(ltop);\n+                        SpirvOp sltop = new SpirvOps.LtOp(type, operands);\n+                        spirvBlock.op(sltop);\n+                        valueMap.put(ltop.result(), sltop.result());\n+                    }\n+                    case CoreOps.InvokeOp inv -> {\n+                        List<Value> operands = mapOperands(inv);\n+                        SpirvOp spirvCall = new SpirvOps.CallOp(inv.invokeDescriptor(), operands);\n+                        spirvBlock.op(spirvCall);\n+                        valueMap.put(inv.result(), spirvCall.result());\n+                    }\n+                    case CoreOps.ConstantOp cop -> {\n+                        SpirvOp scop = new SpirvOps.ConstantOp(cop.resultType(), cop.value());\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n+                    case CoreOps.ConvOp cop -> {\n+                        List<Value> operands = mapOperands(cop);\n+                        SpirvOp scop = new SpirvOps.ConvertOp(cop.resultType(), operands);\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n+                    case CoreOps.FieldAccessOp.FieldLoadOp flo -> {\n+                        SpirvOp load = new SpirvOps.FieldLoadOp(flo.resultType(), flo.fieldDescriptor(), mapOperands(flo));\n+                        spirvBlock.op(load);\n+                        valueMap.put(flo.result(), load.result());\n+                    }\n+                    case CoreOps.BranchOp bop -> {\n+                        Block.Reference successor = blockMap.get(bop.branch().targetBlock()).successor();\n+                        spirvBlock.op(new SpirvOps.BranchOp(successor));\n+                    }\n+                    case CoreOps.ConditionalBranchOp cbop -> {\n+                        Block trueBlock = cbop.trueBranch().targetBlock();\n+                        Block falseBlock = cbop.falseBranch().targetBlock();\n+                        Block.Reference spvTrueBlock = blockMap.get(trueBlock).successor();\n+                        Block.Reference spvFalseBlock = blockMap.get(falseBlock).successor();\n+                        spirvBlock.op(new SpirvOps.ConditionalBranchOp(spvTrueBlock, spvFalseBlock, mapOperands(cbop)));\n+                    }\n+                    default -> unsupported(\"op\", op.getClass());\n+                }\n+            } \/\/ops\n+        } \/\/ blocks\n+        return bodyBuilder;\n+    }\n+\n+    private RuntimeException unsupported(String message, Object value) {\n+        return new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private static CoreOps.FuncOp lowerMethod(CoreOps.FuncOp fop) {\n+        CoreOps.FuncOp lfop = fop.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop)  {\n+                return lop.lower(block);\n+            }\n+            else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        return lfop;\n+    }\n+\n+    private List<Value> mapOperands(Op op) {\n+        List<Value> operands = new ArrayList<>();\n+        for (Value javaValue : op.operands()) {\n+            Value spirvValue = valueMap.get(javaValue);\n+            assert spirvValue != null : \"no value mapping from %s\" + javaValue;\n+            operands.add(spirvValue);\n+        }\n+        return operands;\n+    }\n+\n+    private boolean isIntegerType(TypeElement type) {\n+        return type.equals(JavaType.INT) || type.equals(JavaType.LONG);\n+    }\n+\n+    private boolean isFloatType(TypeElement type) {\n+        return type.equals(JavaType.FLOAT) || type.equals(JavaType.DOUBLE);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.Method;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.runtime.CodeReflection;\n+import java.lang.reflect.code.op.CoreOps;\n+import org.junit.jupiter.api.Test;\n+\n+public class ExampleUseTest {\n+\n+    @CodeReflection\n+    public static void matrixMultiply(float[] a, float[] b, float[] c, int size) {\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                float sum = 0f;\n+                for (int k = 0; k < size; k++) {\n+                    sum += a[i * size + k] * b[k * size + j];\n+                }\n+                c[i * size + j] = sum;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        String methodName = \"matrixMultiply\";\n+        Method method = ExampleUseTest.class.getDeclaredMethod(methodName, float[].class, float[].class, float[].class, int.class);\n+\n+        CoreOps.FuncOp javaFunc = method.getCodeModel().get();\n+        SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(javaFunc);\n+        MemorySegment spirvBinary = SpirvModuleGenerator.generateModule(methodName, spirvFunc);\n+\n+        System.out.println(\"\\n------- Java Model -------\");\n+        System.out.println(javaFunc.toText());\n+        System.out.println(\"------- SPIR-V Model -------\");\n+        System.out.println(spirvFunc.toText());\n+        System.out.println(\"------- SPIR-V Module -------\");\n+        System.out.println(SpirvModuleGenerator.disassembleModule(spirvBinary));\n+   }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/test\/java\/intel\/code\/spirv\/ExampleUseTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}