{"files":[{"patch":"@@ -61,1 +61,1 @@\n-            interface Inner extends Buffer.StructChild  {\n+            interface Inner extends Struct {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        interface Point3D extends StructChild {\n+        interface Point3D extends Struct {\n@@ -68,1 +68,1 @@\n-        interface Vertex3D extends StructChild {\n+        interface Vertex3D extends Struct {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10,1 +10,0 @@\n-import hat.buffer.Buffer;\n@@ -24,2 +23,2 @@\n-        interface WeightedPoint extends Buffer.StructChild {\n-            interface Point extends Buffer.StructChild {\n+        interface WeightedPoint extends Struct {\n+            interface Point extends Struct {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-        interface Point extends StructChild {\n+        interface Point extends Struct {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n@@ -31,13 +29,0 @@\n-import hat.ifacemapper.SegmentMapper;\n-import violajones.XMLHaarCascadeModel;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.foreign.MemoryLayout.sequenceLayout;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -46,1 +31,1 @@\n-    interface Feature extends StructChild{\n+    interface Feature extends Struct {\n@@ -48,1 +33,1 @@\n-        interface Rect extends Buffer.StructChild{\n+        interface Rect extends Struct {\n@@ -71,2 +56,2 @@\n-        interface LinkOrValue extends  Buffer.StructChild {\n-            interface Anon  extends Buffer.UnionChild{\n+        interface LinkOrValue extends Struct {\n+            interface Anon  extends Union {\n@@ -106,1 +91,1 @@\n-    interface Stage extends Buffer.StructChild{\n+    interface Stage extends Struct {\n@@ -124,1 +109,1 @@\n-    interface Tree extends Buffer.StructChild{\n+    interface Tree extends Struct {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.buffer.Buffer;\n@@ -33,1 +32,1 @@\n-    interface Result extends Buffer.StructChild {\n+    interface Result extends Struct {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.buffer.Buffer;\n@@ -33,1 +32,1 @@\n-    interface Scale extends Buffer.StructChild {\n+    interface Scale extends Struct {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+import hat.ifacemapper.HatData;\n@@ -157,1 +158,2 @@\n-        return segmentMapper.allocate(Arena.global());\n+        return segmentMapper.allocate(Arena.global(), new HatData() {\n+        });\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.ifacemapper.HatData;\n@@ -42,1 +43,2 @@\n-        return segmentMapper.allocate(arena);\n+        return segmentMapper.allocate(arena, new HatData() {\n+        });\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/JavaBackend.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.ifacemapper.HatData;\n@@ -48,1 +49,2 @@\n-        return segmentMapper.allocate(arena);\n+        return segmentMapper.allocate(arena, new HatData() {\n+        });\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/NativeBackend.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -41,1 +40,1 @@\n-    interface UnionChild extends MappableIface {\n+    interface Union extends MappableIface {\n@@ -44,1 +43,1 @@\n-    interface StructChild extends MappableIface {\n+    interface Struct extends MappableIface {\n@@ -48,1 +47,1 @@\n-        try {\n+       try {\n@@ -63,1 +62,0 @@\n-\n@@ -80,5 +78,0 @@\n-    static <T extends Buffer> T setLength(T buffer, int length) {\n-        Buffer.getMemorySegment(buffer).set(JAVA_INT, Buffer.getLayout(buffer).byteOffset(MemoryLayout.PathElement.groupElement(\"length\")), length);\n-        return buffer;\n-    }\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+import hat.ifacemapper.HatData;\n@@ -19,1 +20,2 @@\n-        KernelContext kernelContext = SegmentMapper.of(lookup, KernelContext.class,layout).allocate(arena);\n+        KernelContext kernelContext = SegmentMapper.of(lookup, KernelContext.class,layout).allocate(arena, new HatData() {\n+        });\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,9 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n@@ -97,0 +106,1 @@\n+                        method.getReturnType() == MemoryLayout.class && method.getName().equals(\"layout\") ||\n@@ -144,0 +154,22 @@\n+\n+    public static MemoryLayout primitiveToLayout(Class<?> type) {\n+        if (type == Integer.TYPE) {\n+            return JAVA_INT;\n+        } else if (type == Float.TYPE) {\n+            return JAVA_FLOAT;\n+        } else if (type == Long.TYPE) {\n+            return JAVA_LONG;\n+        } else if (type == Double.TYPE) {\n+            return JAVA_DOUBLE;\n+        } else if (type == Short.TYPE) {\n+            return JAVA_SHORT;\n+        } else if (type == Character.TYPE) {\n+            return JAVA_CHAR;\n+        } else if (type == Byte.TYPE) {\n+            return JAVA_BYTE;\n+        } else if (type == Boolean.TYPE) {\n+            return JAVA_BOOLEAN;\n+        } else {\n+            throw new IllegalStateException(\"Expecting primitive   \" + type);\n+        }\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/MapperUtil.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+import hat.ifacemapper.accessor.AccessorInfo;\n@@ -11,1 +12,0 @@\n-import java.lang.reflect.Method;\n@@ -17,9 +17,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-\n@@ -69,1 +60,1 @@\n-                fieldToLayoutBinding = new FieldToLayoutBinding(field, memoryLayout);\n+                fieldToLayoutBinding = new FieldToLayoutBinding<>(field, memoryLayout);\n@@ -75,1 +66,1 @@\n-        public MemoryLayout[] array() {\n+        public MemoryLayout[] memoryLayoutListToArray() {\n@@ -91,1 +82,2 @@\n-        public BoundSchema(Schema<T> schema, int ...arrayLengths) {\n+\n+        public BoundSchema(Schema<T> schema, int... arrayLengths) {\n@@ -99,2 +91,2 @@\n-                    ?MemoryLayout.unionLayout(scope.array())\n-                    :MemoryLayout.structLayout(scope.array());\n+                    ? MemoryLayout.unionLayout(scope.memoryLayoutListToArray())\n+                    : MemoryLayout.structLayout(scope.memoryLayoutListToArray());\n@@ -136,42 +128,0 @@\n-    enum Mode {\n-        PRIMITIVE_GETTER_AND_SETTER,\n-        PRIMITIVE_GETTER,\n-        PRIMITIVE_SETTER,\n-        IFACE_GETTER,\n-        PRIMITIVE_ARRAY_SETTER,\n-        PRIMITIVE_ARRAY_GETTER,\n-        PRIMITIVE_ARRAY_GETTER_AND_SETTER,\n-        IFACE_ARRAY_GETTER;\n-\n-        \/**\n-         * From the iface mapper we get these mappings\n-         * <p>\n-         * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n-         * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n-         * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n-         * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n-         *\n-         * @param m The reflected method\n-         * @return Class represeting the type this method is mapped to\n-         *\/\n-        static Mode of(Method m) {\n-            Class<?> returnType = m.getReturnType();\n-            Class<?>[] paramTypes = m.getParameterTypes();\n-            if (paramTypes.length == 0 && returnType.isInterface()) {\n-                return IFACE_GETTER;\n-            } else if (paramTypes.length == 0 && returnType.isPrimitive()) {\n-                return PRIMITIVE_GETTER;\n-            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-                return PRIMITIVE_SETTER;\n-            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n-                return IFACE_ARRAY_GETTER;\n-            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n-                return PRIMITIVE_ARRAY_GETTER;\n-            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n-                return PRIMITIVE_ARRAY_SETTER;\n-            } else {\n-                throw new IllegalStateException(\"no possible mode for \"+m);\n-            }\n-        }\n-    }\n@@ -179,22 +129,1 @@\n-    static Mode modeOf(Class<?> iface, String name) {\n-        var methods = iface.getDeclaredMethods();\n-        Result<Mode> modeResult = new Result<>();\n-        Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n-            var thisMode = Mode.of(matchingMethod);\n-            if (!modeResult.isPresent()){\n-                modeResult.of(thisMode);\n-            } else if (( modeResult.get().equals(Mode.PRIMITIVE_ARRAY_GETTER) && thisMode.equals(Mode.PRIMITIVE_ARRAY_SETTER))\n-                    || ( modeResult.get().equals(Mode.PRIMITIVE_ARRAY_SETTER) && thisMode.equals(Mode.PRIMITIVE_ARRAY_GETTER))) {\n-                modeResult.of(Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER);\n-            } else if (( modeResult.get().equals(Mode.PRIMITIVE_GETTER) && thisMode.equals(Mode.PRIMITIVE_SETTER))\n-                    || ( modeResult.get().equals(Mode.PRIMITIVE_SETTER) && thisMode.equals(Mode.PRIMITIVE_GETTER))) {\n-                modeResult.of(Mode.PRIMITIVE_GETTER_AND_SETTER);\n-            }\n-        });\n-        if ( !modeResult.isPresent() ) {\n-            throw new IllegalStateException(\"no possible mode for \"+iface+\" \"+name);\n-           \/\/ modeResult.of(Mode.PRIMITIVE_GETTER_AND_SETTER);\n-        }\n-        return modeResult.get();\n-    }\n-    \/**\n+    \/*\n@@ -206,3 +135,0 @@\n-     *\n-     * @param iface The reflected method\n-     * @return Class represeting the type this method is mapped to\n@@ -218,1 +144,1 @@\n-                thisType= returnType;\n+                thisType = returnType;\n@@ -220,1 +146,1 @@\n-                thisType=  paramTypes[0];\n+                thisType = paramTypes[0];\n@@ -222,1 +148,1 @@\n-                thisType=  returnType;\n+                thisType = returnType;\n@@ -225,1 +151,1 @@\n-                thisType=  paramTypes[1];\n+                thisType = paramTypes[1];\n@@ -227,1 +153,1 @@\n-                throw new IllegalStateException(\"Can't determine iface mapping type for \"+matchingMethod);\n+                throw new IllegalStateException(\"Can't determine iface mapping type for \" + matchingMethod);\n@@ -231,1 +157,1 @@\n-            } else  {\n+            } else {\n@@ -236,1 +162,1 @@\n-            throw new IllegalStateException(\"No type mapping for \"+iface+\" \"+name);\n+            throw new IllegalStateException(\"No type mapping for \" + iface + \" \" + name);\n@@ -247,1 +173,1 @@\n-        return clazz.isInterface() && Buffer.StructChild.class.isAssignableFrom(clazz);\n+        return clazz.isInterface() && Buffer.Struct.class.isAssignableFrom(clazz);\n@@ -251,1 +177,1 @@\n-        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.StructChild.class.isAssignableFrom(clazz));\n+        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.Struct.class.isAssignableFrom(clazz));\n@@ -255,1 +181,1 @@\n-        return clazz.isInterface() && Buffer.UnionChild.class.isAssignableFrom(clazz);\n+        return clazz.isInterface() && Buffer.Union.class.isAssignableFrom(clazz);\n@@ -260,0 +186,1 @@\n+\n@@ -263,0 +190,1 @@\n+\n@@ -269,0 +197,1 @@\n+\n@@ -270,0 +199,1 @@\n+\n@@ -272,0 +202,1 @@\n+\n@@ -274,0 +205,1 @@\n+\n@@ -291,1 +223,1 @@\n-            Mode mode;\n+            AccessorInfo.Key key;\n@@ -294,1 +226,2 @@\n-            NamedFieldSchemaNode(TypeSchemaNode parent, Mode mode, Class<?> type, String name) {\n+\n+            NamedFieldSchemaNode(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n@@ -296,2 +229,2 @@\n-                this.mode = mode;\n-                 this.type = type;\n+                this.key = key;\n+                this.type = type;\n@@ -304,2 +237,2 @@\n-            ArrayLen(TypeSchemaNode parent, Mode mode, Class<?> type,  String name) {\n-                super(parent,mode,type, name);\n+            ArrayLen(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n@@ -310,1 +243,1 @@\n-                stringConsumer.accept(indent + \"arrayLen \" + mode+\":\"+type);\n+                stringConsumer.accept(indent + \"arrayLen \" + key + \":\" + type);\n@@ -322,2 +255,2 @@\n-            AtomicField(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n-                super(parent, mode, type,name);\n+            AtomicField(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n@@ -328,1 +261,1 @@\n-                stringConsumer.accept(indent + \"atomic \" + mode+\":\"+type);\n+                stringConsumer.accept(indent + \"atomic \" + key + \":\" + type);\n@@ -340,2 +273,2 @@\n-            Field(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n-                super(parent, mode, type,name);\n+            Field(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n@@ -347,1 +280,1 @@\n-                stringConsumer.accept(indent + \"field \" + mode+\":\"+type);\n+                stringConsumer.accept(indent + \"field \" + key + \":\" + type);\n@@ -356,1 +289,1 @@\n-        public static abstract sealed class TypeSchemaNode extends SchemaNode permits Union,Struct {\n+        public static abstract sealed class TypeSchemaNode extends SchemaNode permits Union, Struct {\n@@ -365,0 +298,1 @@\n+\n@@ -370,1 +304,1 @@\n-            TypeSchemaNode(TypeSchemaNode parent,  Class<?> type) {\n+            TypeSchemaNode(TypeSchemaNode parent, Class<?> type) {\n@@ -374,0 +308,1 @@\n+\n@@ -375,1 +310,1 @@\n-             * Get a layout which describes the NameTypeAndMode.\n+             * Get a layout which describes the type.\n@@ -377,1 +312,1 @@\n-             * If NameTypeAndMode holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n+             * If tyoe holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n@@ -384,18 +319,3 @@\n-             MemoryLayout getLayout(Class<?> type, LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                MemoryLayout memoryLayout = null;\n-                if (type == Integer.TYPE) {\n-                    memoryLayout = JAVA_INT;\n-                } else if (type == Float.TYPE) {\n-                    memoryLayout = JAVA_FLOAT;\n-                } else if (type == Long.TYPE) {\n-                    memoryLayout = JAVA_LONG;\n-                } else if (type == Double.TYPE) {\n-                    memoryLayout = JAVA_DOUBLE;\n-                } else if (type == Short.TYPE) {\n-                    memoryLayout = JAVA_SHORT;\n-                } else if (type == Character.TYPE) {\n-                    memoryLayout = JAVA_CHAR;\n-                } else if (type == Byte.TYPE) {\n-                    memoryLayout = JAVA_BYTE;\n-                } else if (type == Boolean.TYPE) {\n-                    memoryLayout = JAVA_BOOLEAN;\n+            MemoryLayout getLayout(Class<?> type, LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n+                if (type.isPrimitive()) {\n+                    return MapperUtil.primitiveToLayout(type);\n@@ -403,2 +323,4 @@\n-                    TypeSchemaNode typeSchemaModeMatchingType = types.stream()\n-                            .filter(typeSchemaNode -> typeSchemaNode.type.equals(type)).findFirst().get();\n+                    TypeSchemaNode typeSchemaKeyMatchingType = types.stream()\n+                            .filter(typeSchemaNode -> typeSchemaNode.type.equals(type))\n+                            .findFirst()\n+                            .orElseThrow();\n@@ -406,11 +328,6 @@\n-                    typeSchemaModeMatchingType.fields.stream()\n-                            .forEach(fieldSchemaNode ->\n-                                fieldSchemaNode.collectLayouts(scope)\n-                            );\n-                    if (isUnion(typeSchemaModeMatchingType.type)) {\n-                        memoryLayout = MemoryLayout.unionLayout(scope.array());\n-                    } else if (isStructOrBuffer(typeSchemaModeMatchingType.type)) {\n-                        memoryLayout = MemoryLayout.structLayout(scope.array());\n-                    } else {\n-                        throw new IllegalStateException(\"Recursing through layout collections and came across  \" + typeSchemaModeMatchingType.type);\n-                    }\n+                    typeSchemaKeyMatchingType.fields.forEach(fieldSchemaNode ->\n+                            fieldSchemaNode.collectLayouts(scope)\n+                    );\n+                    return isUnion(typeSchemaKeyMatchingType.type)\n+                            ? MemoryLayout.unionLayout(scope.memoryLayoutListToArray())\n+                            : MemoryLayout.structLayout(scope.memoryLayoutListToArray());\n@@ -418,1 +335,0 @@\n-                return memoryLayout;\n@@ -421,1 +337,0 @@\n-\n@@ -423,1 +338,1 @@\n-                parentSchemaNodeConsumer.accept(addType(new Struct(this,  typeOf(type,name))));\n+                parentSchemaNodeConsumer.accept(addType(new Struct(this, typeOf(type, name))));\n@@ -428,1 +343,1 @@\n-                parentSchemaNodeConsumer.accept(addType(new Union(this, typeOf(type,name))));\n+                parentSchemaNodeConsumer.accept(addType(new Union(this, typeOf(type, name))));\n@@ -433,1 +348,1 @@\n-                addField(new Field(this, modeOf(type, name), typeOf(type, name), name));\n+                addField(new Field(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name));\n@@ -438,1 +353,1 @@\n-                addField(new AtomicField(this, modeOf(type, name), typeOf(type, name), name));\n+                addField(new AtomicField(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name));\n@@ -448,4 +363,4 @@\n-                 Mode fieldMode = modeOf(type, name);\n-                 Class<?> fieldType = typeOf(type, name);\n-                addField(new Field(this,fieldMode, fieldType, name));\n-                TypeSchemaNode field = isStruct(fieldType)?new SchemaNode.Struct(this, fieldType):new SchemaNode.Union(this, fieldType);\n+                AccessorInfo.Key fieldKey = AccessorInfo.Key.of(type, name);\n+                Class<?> fieldType = typeOf(type, name);\n+                addField(new Field(this, fieldKey, fieldType, name));\n+                TypeSchemaNode field = isStruct(fieldType) ? new SchemaNode.Struct(this, fieldType) : new SchemaNode.Union(this, fieldType);\n@@ -457,4 +372,4 @@\n-                Mode fieldMode1 = modeOf(type, name1);\n-                Mode fieldMode2 = modeOf(type, name2);\n-                if (!fieldMode1.equals(fieldMode2)){\n-                    throw new IllegalStateException(\"fields \"+name1+\" and \"+name2+\" have different modes\");\n+                AccessorInfo.Key fieldKey1 = AccessorInfo.Key.of(type, name1);\n+                AccessorInfo.Key fieldKey2 = AccessorInfo.Key.of(type, name2);\n+                if (!fieldKey1.equals(fieldKey2)) {\n+                    throw new IllegalStateException(\"fields \" + name1 + \" and \" + name2 + \" have different keys\");\n@@ -464,2 +379,2 @@\n-                if (!structOrUnionType.equals(fieldTypeCheck)){\n-                    throw new IllegalStateException(\"fields \"+name1+\" and \"+name2+\" have different types\");\n+                if (!structOrUnionType.equals(fieldTypeCheck)) {\n+                    throw new IllegalStateException(\"fields \" + name1 + \" and \" + name2 + \" have different types\");\n@@ -467,5 +382,5 @@\n-                addField(new Field(this,fieldMode1, structOrUnionType, name1));\n-                addField(new Field(this,fieldMode2,  structOrUnionType, name2));\n-                TypeSchemaNode typeSchemaNode=isStruct(type)\n-                        ? new SchemaNode.Struct(this,  structOrUnionType)\n-                        :new SchemaNode.Union(this,  structOrUnionType);\n+                addField(new Field(this, fieldKey1, structOrUnionType, name1));\n+                addField(new Field(this, fieldKey2, structOrUnionType, name2));\n+                TypeSchemaNode typeSchemaNode = isStruct(type)\n+                        ? new SchemaNode.Struct(this, structOrUnionType)\n+                        : new SchemaNode.Union(this, structOrUnionType);\n@@ -484,1 +399,1 @@\n-                addField(new FixedArray(this, modeOf(type,name), typeOf(type, name),name, len));\n+                addField(new FixedArray(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name, len));\n@@ -489,1 +404,1 @@\n-                Mode arrayMode = modeOf(type, name);\n+                AccessorInfo.Key arrayKey = AccessorInfo.Key.of(type, name);\n@@ -491,1 +406,0 @@\n-               \/\/ ModeAndType newAccessStyle = ModeAndType.of(type, name);\n@@ -493,2 +407,2 @@\n-                                ?new SchemaNode.Struct(this, structOrUnionType)\n-                                :new SchemaNode.Union(this, structOrUnionType);\n+                        ? new SchemaNode.Struct(this, structOrUnionType)\n+                        : new SchemaNode.Union(this, structOrUnionType);\n@@ -497,1 +411,1 @@\n-                addField(new FixedArray(this, arrayMode,structOrUnionType, name, len));\n+                addField(new FixedArray(this, arrayKey, structOrUnionType, name, len));\n@@ -502,1 +416,1 @@\n-                addField(new FieldControlledArray(this,  modeOf(type, name), typeOf(type, name),name, arrayLenFields, stride));\n+                addField(new FieldControlledArray(this, AccessorInfo.Key.of(type, name), typeOf(type, name), name, arrayLenFields, stride));\n@@ -509,1 +423,2 @@\n-                int stride=1;\n+                int stride = 1;\n+\n@@ -513,0 +428,1 @@\n+\n@@ -517,0 +433,1 @@\n+\n@@ -520,3 +437,3 @@\n-                    TypeSchemaNode typeSchemaNode =isStruct(arrayType)\n-                            ?new SchemaNode.Struct(this.typeSchemaNode, arrayType)\n-                            :new SchemaNode.Union(this.typeSchemaNode,arrayType);\n+                    TypeSchemaNode typeSchemaNode = isStruct(arrayType)\n+                            ? new SchemaNode.Struct(this.typeSchemaNode, arrayType)\n+                            : new SchemaNode.Union(this.typeSchemaNode, arrayType);\n@@ -534,4 +451,4 @@\n-            public ArrayBuildState arrayLen(String ... arrayLenFieldNames) {\n-                 List<ArrayLen> arrayLenFields = new ArrayList<>();\n-                 Arrays.stream(arrayLenFieldNames).forEach(arrayLenFieldName-> {\n-                    var arrayLenField = new ArrayLen(this, modeOf(type, arrayLenFieldName), typeOf(type, arrayLenFieldName), arrayLenFieldName);\n+            public ArrayBuildState arrayLen(String... arrayLenFieldNames) {\n+                List<ArrayLen> arrayLenFields = new ArrayList<>();\n+                Arrays.stream(arrayLenFieldNames).forEach(arrayLenFieldName -> {\n+                    var arrayLenField = new ArrayLen(this, AccessorInfo.Key.of(type, arrayLenFieldName), typeOf(type, arrayLenFieldName), arrayLenFieldName);\n@@ -544,6 +461,0 @@\n-            public void flexArray(String name) {\n-                 throw new IllegalStateException(\"flex array\");\n-              \/\/  addField(new FlexArray(this,null, name));\n-            }\n-\n-\n@@ -577,1 +488,1 @@\n-            Struct(TypeSchemaNode parent,  Class<?> type) {\n+            Struct(TypeSchemaNode parent, Class<?> type) {\n@@ -583,2 +494,2 @@\n-            Union(TypeSchemaNode parent,  Class<?> type) {\n-                super(parent,  type);\n+            Union(TypeSchemaNode parent, Class<?> type) {\n+                super(parent, type);\n@@ -588,5 +499,3 @@\n-        public abstract static sealed class Array extends NamedFieldSchemaNode permits FieldControlledArray, FixedArray, FlexArray {\n-          \/\/  ModeAndType elementAccessStyle;\n-            Array(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n-                super(parent, mode,type, name);\n-            \/\/\/    this.elementAccessStyle = elementAccessStyle;\n+        public abstract static sealed class Array extends NamedFieldSchemaNode permits FieldControlledArray, FixedArray {\n+            Array(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name) {\n+                super(parent, key, type, name);\n@@ -599,2 +508,2 @@\n-            FixedArray(TypeSchemaNode parent,Mode mode, Class<?> type, String name, int len) {\n-                super(parent,  mode, type, name);\n+            FixedArray(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name, int len) {\n+                super(parent, key, type, name);\n@@ -617,18 +526,0 @@\n-        public static final  class FlexArray extends Array {\n-            FlexArray(TypeSchemaNode parent,  Mode mode, Class<?> type, String name) {\n-                super(parent,  mode,type, name);\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent + \"array [?] \");\n-            }\n-\n-            void collectLayouts(LayoutToBoundFieldTreeNode layoutToFieldBindingNode) {\n-                layoutToFieldBindingNode.bind(this,\n-                        MemoryLayout.sequenceLayout(0,\n-                                parent.getLayout(type, layoutToFieldBindingNode).withName(type.getSimpleName())\n-                        ).withName(name));\n-            }\n-        }\n-\n@@ -638,2 +529,4 @@\n-            FieldControlledArray(TypeSchemaNode parent,   Mode mode, Class<?> type,String name, List<ArrayLen> arrayLenFields, int stride) {\n-                super(parent, mode, type, name);\n+            int contributingDims;\n+\n+            FieldControlledArray(TypeSchemaNode parent, AccessorInfo.Key key, Class<?> type, String name, List<ArrayLen> arrayLenFields, int stride) {\n+                super(parent, key, type, name);\n@@ -642,0 +535,1 @@\n+                this.contributingDims = arrayLenFields.size();\n@@ -646,1 +540,1 @@\n-                stringConsumer.accept(indent + name + \"[\" + mode+\":\"+type + \"] where len defined by \" + arrayLenFields);\n+                stringConsumer.accept(indent + name + \"[\" + key + \":\" + type + \"] where len defined by \" + arrayLenFields);\n@@ -651,5 +545,4 @@\n-                \/\/ We have more than one ArrayLen\n-                int i=stride;\n-                for (int c = 0 ; c<arrayLenFields.size(); c++ ){\n-                   var v =  layoutToFieldBindingNode.takeArrayLen();\n-                   i*=v;\n+                \/\/ To determine the actual 'array' size we multiply the contributing dims by the stride .\n+                int size = stride; \/\/usually 1 but developer can define.\n+                for (int i = 0; i < contributingDims; i++) {\n+                    size *= layoutToFieldBindingNode.takeArrayLen(); \/\/ this takes an arraylen and bumps the ptr\n@@ -657,2 +550,2 @@\n-                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(\n-                       i,\/\/ layoutToFieldBindingNode.takeArrayLen(),\n+\n+                layoutToFieldBindingNode.bind(this, MemoryLayout.sequenceLayout(size,\n@@ -672,1 +565,1 @@\n-            return s.allocate(Arena.global());\n+            return s.allocate(Arena.global(), new HatData() {});\n@@ -675,0 +568,1 @@\n+\n@@ -679,1 +573,1 @@\n-    public T allocate(BufferAllocator bufferAllocator,int... boundLengths) {\n+    public T allocate(BufferAllocator bufferAllocator, int... boundLengths) {\n@@ -682,0 +576,1 @@\n+\n@@ -683,1 +578,1 @@\n-        return allocate(GlobalArenaAllocator,boundLengths);\n+        return allocate(GlobalArenaAllocator, boundLengths);\n@@ -691,0 +586,1 @@\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":119,"deletions":223,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-                .filter(mi -> mi.key().valueType().isVirtual())\n+                .filter(mi -> mi.key().valueType().equals(ValueType.INTERFACE))\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentInterfaceMapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,0 @@\n-    default T allocate(Arena arena) {\n@@ -323,16 +322,0 @@\n-        \/\/ To help debug we add a tail marker\n-        \/\/ We add 16 bytes and then pad to the next 16 bytes\n-        \/\/ and request alignment on 16 byte boundary\n-        long byteSize = layout().byteSize();\n-        long extendedByteSize = byteSize+16;\n-        long byteSizePad = extendedByteSize%16;\n-        if (byteSizePad != 0){\n-            byteSizePad = 16-byteSizePad;\n-        }\n-        long extendedByteSizePaddedTo16Bytes = extendedByteSize+byteSizePad;\n-        \/\/System.out.println(\"Alloc 16 byte aligned layout + 16 bytes padded to next 16 bytes \"+byteSize+\"=>\"+extendedByteSizePaddedTo16Bytes);\n-        var segment = arena.allocate(extendedByteSizePaddedTo16Bytes, 16);\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-16,0x1face00000facadeL);\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-8, 0x1face00000facadeL);\n-        return get(segment, layout(), hatData());\n-    }\n@@ -386,29 +369,0 @@\n-    \/**\n-     * {@return a new instance of type T projected at the provided external\n-     * {@code segment} at the given {@code index} scaled by the\n-     * {@code layout().byteSize()}}\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * {@snippet lang = java:\n-     *    get(segment, layout().byteSize() * index);\n-     *}\n-     *\n-     * @param segment the external segment to be projected to the new instance\n-     * @param index   a logical index, the offset in bytes (relative to the provided\n-     *                segment address) at which the access operation will occur can\n-     *                be expressed as {@code (index * layout().byteSize())}\n-     * @throws IllegalStateException     if the {@linkplain MemorySegment#scope() scope}\n-     *                                   associated with the provided segment is not\n-     *                                   {@linkplain MemorySegment.Scope#isAlive() alive}\n-     * @throws WrongThreadException      if this method is called from a thread {@code T},\n-     *                                   such that {@code isAccessibleBy(T) == false}\n-     * @throws IllegalArgumentException  if the access operation is\n-     *                                   <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n-     *                                   of the {@link #layout()}\n-     * @throws IndexOutOfBoundsException if {@code index * layout().byteSize()} overflows\n-     * @throws IndexOutOfBoundsException if\n-     *                                   {@code index * layout().byteSize() > segment.byteSize() - layout.byteSize()}\n-     *\/\n-    default T getAtIndex(MemorySegment segment, long index) {\n-        return get(segment, layout().byteSize() * index);\n-    }\n@@ -438,30 +392,0 @@\n-    \/**\n-     * {@return a new sequential {@code Stream} of {@code pageSize} elements of\n-     * type T starting at the element {@code pageNumber * pageSize}}\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * stream(segment)\n-     *     .skip(pageNumber * pageSize)\n-     *     .limit(pageSize);\n-     *}\n-     * but may be much more efficient for large page numbers.\n-     *\n-     * @param segment    to carve out instances from\n-     * @param pageSize   the size of each page\n-     * @param pageNumber the page number to which to skip\n-     * @throws IllegalArgumentException if {@code layout().byteSize() == 0}.\n-     * @throws IllegalArgumentException if {@code segment.byteSize() % layout().byteSize() != 0}.\n-     * @throws IllegalArgumentException if {@code layout().byteSize() % layout().byteAlignment() != 0}.\n-     * @throws IllegalArgumentException if this segment is\n-     *                                  <a href=\"MemorySegment.html#segment-alignment\">incompatible with the\n-     *                                  alignment constraint<\/a> in the layout of this segment mapper.\n-     *\/\n-    default Stream<T> page(MemorySegment segment,\n-                           long pageSize,\n-                           long pageNumber) {\n-        long skipBytes = Math.min(segment.byteSize(), layout().scale(0, pageNumber * pageSize));\n-        MemorySegment skippedSegment = segment.asSlice(skipBytes);\n-        return stream(skippedSegment)\n-                .limit(pageSize);\n-    }\n@@ -585,3 +509,3 @@\n-    default void setAtIndex(MemorySegment segment, long index, T t) {\n-        set(segment, layout().byteSize() * index, t);\n-    }\n+   \/\/ default void setAtIndex(MemorySegment segment, long index, T t) {\n+    \/\/    set(segment, layout().byteSize() * index, t);\n+  \/\/  }\n@@ -757,32 +681,0 @@\n-    \/**\n-     * {@return a segment mapper that maps {@linkplain MemorySegment memory segments}\n-     * to the provided interface {@code type} using the provided {@code layout}\n-     * and using the provided {@code lookup}}\n-     *\n-     * @param lookup to use when performing reflective analysis on the\n-     *               provided {@code type}\n-     * @param type   to map memory segment from and to\n-     * @param layout to be used when mapping the provided {@code type}\n-     * @param length to replace the length of the last element (sequenceLayout)\n-     * @param <T>    the type the returned mapper converts MemorySegments from and to\n-     * @throws IllegalArgumentException if the provided {@code type} is not an interface\n-     * @throws IllegalArgumentException if the provided {@code type} is a hidden interface\n-     * @throws IllegalArgumentException if the provided {@code type} is a sealed interface\n-     * @throws IllegalArgumentException if the provided interface {@code type} directly\n-     *                                  declares any generic type parameter\n-     * @throws IllegalArgumentException if the provided interface {@code type} cannot be\n-     *                                  reflectively analysed using the provided {@code lookup}\n-     * @throws IllegalArgumentException if the provided interface {@code type} contains\n-     *                                  methods for which there are no exact mapping (of names and types) in\n-     *                                  the provided {@code layout} or if the provided {@code type} is not public or\n-     *                                  if the method is otherwise unable to create a segment mapper as specified above\n-     * @implNote The order in which methods appear (e.g. in the {@code toString} method)\n-     * is derived from the provided {@code layout}.\n-     * @implNote The returned class can be a\n-     * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n-     * class; programmers should treat instances that are\n-     * {@linkplain Object#equals(Object) equal} as interchangeable and should\n-     * not use instances for synchronization, or unpredictable behavior may\n-     * occur. For example, in a future release, synchronization may fail.\n-     * @implNote The returned class can be a {@linkplain Class#isHidden() hidden} class.\n-     *\/\n@@ -790,9 +682,0 @@\n-    static <T> SegmentMapper<T> ofIncomplete(MethodHandles.Lookup lookup,\n-                                   Class<T> type,\n-                                   GroupLayout layout, long length) {\n-        var members= layout.memberLayouts().toArray(new MemoryLayout[0]);\n-        SequenceLayout sequenceLayout = (SequenceLayout) members[members.length-1];\n-        var newLayout = MemoryLayout.sequenceLayout(length,sequenceLayout.elementLayout()).withName(sequenceLayout.name().get());\n-        members[members.length-1]=newLayout;\n-        return of(lookup,type,members);\n-    }\n@@ -828,1 +711,4 @@\n-\n+        \/**\n+         * {@return the backing segment of this instance}\n+         *\/\n+        MemoryLayout layout();\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":7,"deletions":121,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import hat.ifacemapper.Schema;\n+import hat.util.Result;\n+\n@@ -30,0 +33,1 @@\n+import java.util.Arrays;\n@@ -34,0 +38,1 @@\n+import static hat.ifacemapper.accessor.AccessorInfo.AccessorType.GETTER_AND_SETTER;\n@@ -58,1 +63,1 @@\n-    public enum AccessorType {GETTER, SETTER}\n+    public enum AccessorType {GETTER, SETTER,GETTER_AND_SETTER}\n@@ -65,1 +70,0 @@\n-\n@@ -69,0 +73,1 @@\n+        SCALAR_VALUE_GETTER_AND_SETTER(SCALAR, VALUE, GETTER_AND_SETTER, EnumSet.of(INTERFACE)),\n@@ -70,1 +75,0 @@\n-        SCALAR_INTERFACE_SETTER(SCALAR, INTERFACE, SETTER, EnumSet.noneOf(ValueType.class)),\n@@ -73,3 +77,2 @@\n-        ARRAY_INTERFACE_GETTER(ARRAY, INTERFACE, GETTER, EnumSet.of(INTERFACE)),\n-        ARRAY_INTERFACE_SETTER(ARRAY, INTERFACE, SETTER, EnumSet.noneOf(ValueType.class));\n-\n+        ARRAY_VALUE_GETTER_AND_SETTER(ARRAY, VALUE, GETTER_AND_SETTER, EnumSet.of(INTERFACE)),\n+        ARRAY_INTERFACE_GETTER(ARRAY, INTERFACE, GETTER, EnumSet.of(INTERFACE));\n@@ -119,0 +122,54 @@\n+\n+        \/**\n+         * From the iface mapper we get these mappings\n+         * <p>\n+         * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n+         * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n+         * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n+         * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n+         *\n+         * @param m The reflected method\n+         * @return Class represeting the type this method is mapped to\n+         *\/\n+        public static Key of(Method m) {\n+            Class<?> returnType = m.getReturnType();\n+            Class<?>[] paramTypes = m.getParameterTypes();\n+            if (paramTypes.length == 0 && returnType.isInterface()) {\n+                return SCALAR_INTERFACE_GETTER;\n+            } else if (paramTypes.length == 0 && returnType.isPrimitive()) {\n+                return SCALAR_VALUE_GETTER;\n+            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                return SCALAR_VALUE_SETTER;\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n+                return ARRAY_INTERFACE_GETTER;\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n+                return ARRAY_VALUE_GETTER;\n+            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n+                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n+                return ARRAY_VALUE_SETTER;\n+            } else {\n+                throw new IllegalStateException(\"no possible key for \" + m);\n+            }\n+        }\n+\n+        public static Key of(Class<?> iface, String name) {\n+            var methods = iface.getDeclaredMethods();\n+            Result<Key> modeResult = new Result<>();\n+            Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n+                var thisMode = Key.of(matchingMethod);\n+                if (!modeResult.isPresent()) {\n+                    modeResult.of(thisMode);\n+                } else if ((modeResult.get().equals(ARRAY_VALUE_GETTER) && thisMode.equals(ARRAY_VALUE_SETTER))\n+                        || (modeResult.get().equals(ARRAY_VALUE_SETTER) && thisMode.equals(ARRAY_VALUE_GETTER))) {\n+                    modeResult.of(ARRAY_VALUE_GETTER_AND_SETTER);\n+                } else if ((modeResult.get().equals(SCALAR_VALUE_GETTER) && thisMode.equals(SCALAR_VALUE_SETTER))\n+                        || (modeResult.get().equals(SCALAR_VALUE_SETTER) && thisMode.equals(SCALAR_VALUE_GETTER))) {\n+                    modeResult.of(SCALAR_VALUE_GETTER_AND_SETTER);\n+                }\n+            });\n+            if (!modeResult.isPresent()) {\n+                throw new IllegalStateException(\"no possible key for \" + iface + \" \" + name);\n+                \/\/ modeResult.of(Mode.PRIMITIVE_GETTER_AND_SETTER);\n+            }\n+            return modeResult.get();\n+        }\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","additions":63,"deletions":6,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-                : getterType(method);\n+                : setterType(method);\n@@ -214,1 +214,1 @@\n-    private static Class<?> getterType(Method method) {\n+    private static Class<?> setterType(Method method) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/Accessors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-public record ArrayInfo(MemoryLayout elementLayout,\n-                        List<Long> dimensions) {\n+public record ArrayInfo(MemoryLayout elementLayout, List<Long> dimensions) {\n@@ -42,1 +41,0 @@\n-            \/\/ We are done. Create an immutable record\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/ArrayInfo.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,11 +4,1 @@\n-    VALUE(false), INTERFACE(true);\n-\n-    private final boolean virtual;\n-\n-    ValueType(boolean virtual) {\n-        this.virtual = virtual;\n-    }\n-\n-    public boolean isVirtual() {\n-        return virtual;\n-    }\n+    VALUE, INTERFACE\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/ValueType.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"}]}