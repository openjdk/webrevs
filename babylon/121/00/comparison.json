{"files":[{"patch":"@@ -40,1 +40,1 @@\n-        ${SHARED_BACKEND}\/cpp\/shared.cpp\n+        ${SHARED_BACKEND}\/cpp\/schema.cpp\n","filename":"hat\/backends\/CMakeLists.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(Backend::Program::Kernel *kernel, Arg_t *arg)\n+CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(Backend::Program::Kernel *kernel, Arg_s *arg)\n@@ -232,1 +232,1 @@\n-    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n@@ -240,1 +240,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n@@ -307,1 +307,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n@@ -322,1 +322,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n","filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_t *arg)\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLBuffer::OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg)\n@@ -111,2 +111,2 @@\n-    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n-    Schema::dumpSled(std::cout, argArray);\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n+    Sled::show(std::cout, argArray);\n@@ -121,1 +121,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n@@ -201,1 +201,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n@@ -223,1 +223,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n","filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_t *arg);\n+                OpenCLBuffer(Backend::Program::Kernel *kernel, Arg_s *arg);\n","filename":"hat\/backends\/opencl\/include\/opencl_backend.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"schema.h\"\n+\n+void Schema::show(std::ostream &out, char *argArray) {\n+\n+}\n+void Schema::show(std::ostream &out, int depth, Node *schemaNode) {\n+\n+}\n+void Schema::show(std::ostream &out, SchemaNode *schemaNode) {\n+\n+}\n+\n+\n+Schema::Array *Schema::Array::parse(Cursor *cursor) {\n+    if (cursor->is('*')) {\n+        flexible = true;\n+    } else if (cursor->peekDigit()) {\n+        elementCount = cursor->getLong();\n+    }\n+    if (cursor->is(':')) {\n+        if (cursor->is('?')) {\n+        } else if (cursor->peekAlpha()) {\n+            elementName = cursor->getIdentifier();\n+        } else {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or identifier for element\");\n+        }\n+        if (cursor->is(':')) {\n+            if (cursor->peekAlpha()) {\n+                elementType = addChild(cursor,new struct SimpleType(this));\n+            } else if (cursor->is('{')){\n+                elementType = addChild(cursor, new struct Struct(this));\n+            } else if (cursor->is('<')){\n+                elementType = addChild(cursor, new struct Union(this));\n+            }else{\n+                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or identifier for element\");\n+            }\n+            if (cursor->is(']')) {\n+                return this;\n+            } else {\n+                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ']'\");\n+            }\n+\n+        } else {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+        }\n+    } else {\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+    }\n+    cursor->error(std::cerr, __FILE__, __LINE__, \"Implement array parser\");\n+    return this;\n+}\n+\n+Schema::StructOrUnion *Schema::StructOrUnion::parse(Cursor *cursor) {\n+    do {\n+        if (cursor->is('?')) {\n+\n+        }else if (cursor->peekAlpha()) {\n+            name = cursor->getIdentifier();\n+        }\n+        if (cursor->is(':')) {\n+            if (cursor->peekAlpha()) {\n+                typeNode = addChild(cursor, new struct SimpleType(this));\n+            } else if (cursor->is('[')) {\n+                typeNode = addChild(cursor, new Array( this));\n+            } else if (cursor->is('{')) {\n+                typeNode = addChild(cursor, new Struct( this));\n+            } else if (cursor->is('<')) {\n+                typeNode = addChild(cursor, new Union( this));\n+            } else {\n+                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting type\");\n+            }\n+        } else {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+        }\n+    } while (cursor->is(separator));\n+    if (cursor->is(terminator)) {\n+        return this;\n+    } else {\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '}' or '>'\");\n+    }\n+    return this;\n+}\n+\n+Schema::NamedStructOrUnion *Schema::NamedStructOrUnion::parse(Cursor *cursor) {\n+    if (cursor->peekDigit()) {\n+        bytes = cursor->getLong();\n+        if (cursor->isEither('#', '+')) {\n+            complete = ((*(cursor->ptr - 1)) == '#');\n+            if (cursor->peekAlpha()) {\n+                identifier = cursor->getIdentifier();\n+                if (cursor->is(':')) {\n+                    if (cursor->is('{')) {\n+                        addChild(cursor, new Struct( this));\n+                    } else if (cursor->is('<')) {\n+                        addChild(cursor, new Union(this));\n+                    } else {\n+                        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '{' or '<'\");\n+                    }\n+                } else {\n+                    cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+                }\n+            } else {\n+                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting identifier \");\n+            }\n+        } else if (cursor->peekAlpha()) {\n+            addChild(cursor, new Field( this));\n+        } else {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '#' \");\n+        }\n+    } else {\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting long byteCount of buffer  \");\n+    }\n+    if (cursor->is(')')) {\n+        return this;\n+    } else {\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ')'\");\n+        return nullptr;\n+    }\n+\n+}\n+Schema::Arg *Schema::Arg::parse(Cursor *cursor) {\n+    if (cursor->isEither('!', '?')) {\n+        if (cursor->is(':')) {\n+            addChild(cursor, new NamedStructOrUnion( this));\n+        } else {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ':'\");\n+        }\n+    } else {\n+        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '?' or '!'\");\n+    }\n+    return this;\n+}\n+Schema::SchemaNode *Schema::SchemaNode::parse(Cursor *cursor) {\n+    if (cursor->peekDigit()) {\n+        int argc = cursor->getInt();\n+        for (int i = 0; i < argc; i++) {\n+            if (cursor->is('(')) {\n+                addChild(cursor, new Arg( this));\n+                if (i < (argc - 1)) {\n+                    if (cursor->is(',')) {\n+                        \/\/\n+                    } else {\n+                        cursor->error(std::cerr, __FILE__, __LINE__, \"expecting ','\");\n+                    }\n+                }\n+            } else {\n+                cursor->error(std::cerr, __FILE__, __LINE__, \"expecting '('\");\n+            }\n+        }\n+    }\n+    return this;\n+}\n+\/*\n+char *Schema::strduprange(char *start, char *end) {\n+    char *s = new char[end - start + 1];\n+    std::memcpy(s, start, end - start);\n+    s[end - start] = '\\0';\n+    return s;\n+}\n+\n+std::ostream &Schema::dump(std::ostream &out, char *start, char *end) {\n+    while (start < end) {\n+        out << (char) *start;\n+        start++;\n+    }\n+    return out;\n+}\n+\n+std::ostream &Schema::indent(std::ostream &out, int depth) {\n+    while (depth > 0) {\n+        out << \"  \";\n+        depth++;\n+    }\n+    return out;\n+}\n+\n+std::ostream &Schema::dump(std::ostream &out, char *label, char *start, char *end) {\n+    out << label << \" '\";\n+    dump(out, start, end) << \"' \" << std::endl;\n+    return out;\n+}\n+*\/\n+\n+\n","filename":"hat\/backends\/shared\/cpp\/schema.cpp","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -26,2 +26,1 @@\n-#include \"shared.h\"\n-\n+#include \"schema.h\"\n@@ -30,14 +29,12 @@\n-    char *mandelSchema = (char *) \"args:[5:?:8+S32Array2D:{width:s32,height:s32,array:[*:?:s32]},?:4+S32Array:{length:s32,array:[*:?:s32]},?:f32,?:f32,?:f32]\";\n-    char *squaresSchema = (char *) \"args:[1:?:4+S32Array:{length:s32,array:[*:?:s32]}]\";\n-    char *colIntegralSchema = (char *)\n-            \"args:[2:\"\n-            \"?:8+F32Array2D:{\"\n-            \"width:s32,\"\n-            \"height:s32,\"\n-            \"array:[*:\"\n-            \"?:f32\"\n-            \"]\"\n-            \"},\"\n-            \"?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}\"\n-            \"]\";\n-    char *rowIntegralSchema = (char *) \"args:[3:?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}]\";\n+    char *rgbToGrey = (char *) R\"(3\n+       (!:32#KernelContext:{\n+          x:s32,\n+          maxX:s32\n+       }),\n+       (?:16+RgbS08x3Image:{\n+           width:s32,height:s32,elementsPerPixel:s32,bufferedImageType:s32,data:[*:?:s8]}),\n+       (?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]})\n+    )\";\n+    char *gradientRow = (char *) \"4(!:32#KernelContext:{x:s32,maxX:s32}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]})\";\n+    char *gradientCol = (char *)\n+            \"3(!:32#KernelContext:{x:s32,maxX:s32}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),(?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]})\";\n@@ -45,1 +42,60 @@\n-    char *cascadeSchema = (char *) \"args:[5:!:163448!Cascade:{width:s32,height:s32,featureCount:s32,feature:[2913:Feature:{id:s32,threshold:f32,left:{hasValue:z8,?:x3,anon:<featureId:s32|value:f32>},right:{hasValue:z8,?:x3,anon:<featureId:s32|value:f32>},rect:[3:Rect:{x:s8,y:s8,width:s8,height:s8,weight:f32}]}],stageCount:s32,stage:[25:Stage:{id:s32,threshold:f32,firstTreeId:s16,treeCount:s16}],treeCount:s32,tree:[2913:Tree:{id:s32,firstFeatureId:s16,featureCount:s16}]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]},?:8+ScaleTable:{length:s32,multiScaleAccumulativeRange:s32,scale:[*:Scale:{scaleValue:f32,scaledXInc:f32,scaledYInc:f32,invArea:f32,scaledFeatureWidth:s32,scaledFeatureHeight:s32,gridWidth:s32,gridHeight:s32,gridSize:s32,accumGridSizeMin:s32,accumGridSizeMax:s32}]},?:8+ResultTable:{length:s32,atomicResultTableCount:s32,result:[*:Result:{x:f32,y:f32,width:f32,height:f32}]}]\";\n+    char *cascadeSchema = (char *) R\"(6\n+        (!:32#KernelContext:{x:s32,maxX:s32}),\n+        (!:163472#Cascade:{\n+            width:s32,\n+            height:s32,\n+            featureCount:s32,\n+            feature:[2913:\n+                Feature:{\n+                   id:s32,\n+                   threshold:f32,\n+                   left:{\n+                        hasValue:z8,\n+                        ?:x3,\n+                        anon:<\n+                             featureId:s32|\n+                             value:f32\n+                        >\n+                   },\n+                   right:{\n+                         hasValue:z8,\n+                         ?:x3,\n+                         anon:<\n+                              featureId:s32|\n+                              value:f32\n+                         >\n+                   },\n+                   rect:[3:\n+                       Rect:{\n+                           x:s8,\n+                           y:s8,\n+                           width:s8,\n+                           height:s8,\n+                           weight:f32\n+                       }\n+                   ]\n+                }\n+            ],\n+            stageCount:s32,\n+            stage:[25:\n+                Stage:{\n+                    id:s32,\n+                    threshold:f32,\n+                    firstTreeId:s16,\n+                    treeCount:s16\n+                }\n+            ],\n+            treeCount:s32,\n+            tree:[2913:\n+                Tree:{\n+                    id:s32,\n+                    firstFeatureId:s16,\n+                    featureCount:s16\n+                }\n+            ]\n+        }\n+        ),\n+        (?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),\n+        (?:8+F32Array2D:{width:s32,height:s32,array:[*:?:f32]}),\n+        (?:8+ScaleTable:{length:s32,multiScaleAccumulativeRange:s32,scale:[*:Scale:{scaleValue:f32,scaledXInc:f32,scaledYInc:f32,invArea:f32,scaledFeatureWidth:s32,scaledFeatureHeight:s32,gridWidth:s32,gridHeight:s32,gridSize:s32,accumGridSizeMin:s32,accumGridSizeMax:s32}]}),\n+        (?:8+ResultTable:{length:s32,atomicResultTableCount:s32,result:[*:Result:{x:f32,y:f32,width:f32,height:f32}]}))\";\n@@ -48,1 +104,4 @@\n-    Schema::dumpSchema(std::cout, schema);\n+    Cursor cursor(schema);\n+    Schema::SchemaNode schemaNode;\n+    schemaNode.parse(&cursor);\n+\n@@ -50,0 +109,1 @@\n+    Schema::show(std::cout, &schemaNode);\n","filename":"hat\/backends\/shared\/cpp\/schemadump.cpp","additions":78,"deletions":18,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-\n+\/*\n@@ -40,2 +40,2 @@\n-\n-extern \"C\" void dumpArgArray(void *ptr) {\n+*\/\n+\/*extern \"C\" void dumpArgArray(void *ptr) {\n@@ -48,121 +48,1 @@\n-\n-\n-    \/\/#define YEP\n-#ifdef YEP\n-    std::cout << std::endl << \"spec->\" << spec << std::endl;\n-\n-    char *data = (char *) ptr;\n-    char *p = spec;\n-    std::stack<State *> stack;\n-\n-    while (*p) {\n-       if (*p == '[' && ::isdigit(*(p+1))) {\n-          p++;\n-          int count = 0;\n-          while (::isdigit(*p)) {\n-             count = (count * 10) + (*p - '0');\n-             p++;\n-          }\n-          if (*p == ':') {\n-             p++;\n-          }\n-          stack.push(State::sequence(p, data, count));\n-          for (int i = 0; i < stack.size(); i++) {\n-             std::cout << \" \";\n-          }\n-          std::cout << (stack.top()->count) << \" of \" << (stack.top()->of) <<std::endl;\n-       } else if (*p == '[') {\n-          p++;\n-          stack.push(State::structOrUnion(p, data));\n-          for (int i = 0; i < stack.size(); i++) {\n-             std::cout << \" \";\n-          }\n-          std::cout << \"{\" << std::endl;\n-       } else if (*p == ']' && !stack.empty() && stack.top()->isMidSequence()) {\n-          stack.top()->count++;\n-          p = stack.top()->start;\n-          for (int i = 0; i < stack.size(); i++) {\n-             std::cout << \" \";\n-          }\n-          \/\/I V vi iii IV I IV V\n-          std::cout << (stack.top()->count) << \" of \" << (stack.top()->of) << std::endl ;\n-       } else if (*p == ']' && !stack.empty() && stack.top()->isSequence()) {\n-          p++;\n-          State *state = stack.top();\n-          if (*p == '(') {\n-             p++;\n-             char *start = p;\n-             while (*p != ')') {\n-                state->name[p - start] = *p;\n-                p++;\n-             }\n-             state->name[p - start] = '\\0';\n-          }\n-          p++;\n-          stack.pop();\n-          for (int i = 0; i < stack.size(); i++) {\n-             std::cout << \" \";\n-          }\n-          std::cout << \"]\" << state->name << std::endl;\n-          delete state;\n-\n-       } else if (*p == ']' && !stack.empty() && stack.top()->isStructOrUnion()) {\n-          p++;\n-          State *state = stack.top();\n-          if (*p == '(') {\n-             p++;\n-             char *start = p;\n-             while (*p != ')') {\n-                state->name[p - start] = *p;\n-                p++;\n-             }\n-             state->name[p - start] = '\\0';\n-          }\n-          p++;\n-          stack.pop();\n-          for (int i = 0; i < stack.size(); i++) {\n-             std::cout << \" \";\n-          }\n-          std::cout << \"}\" << state->name<< std::endl;\n-          delete state;\n-       } else if ( (*p == '|') && !stack.empty() && stack.top()->isStructOrUnion() ) {\n-          p++;\n-          \/\/ we refetch data from the dataStart of the enclosing union\n-          data = (char*)stack.top()->dataStart;\n-       } else if ( (*p == 'i' || *p == 'b' || *p == 's'|| *p == 'f') && !stack.empty() && stack.top()->isStructOrUnion() ) {\n-          char *start = p;\n-          p++;\n-          int sz = 0;\n-          while (::isdigit(*p)) {\n-             sz = sz * 10 + *p - '0';\n-             p++;\n-          }\n-          State *state =  State::member(start,data, sz);\n-          stack.push(state);\n-          if (*p == '(') {\n-             p++;\n-             char *start = p;\n-             while (*p != ')') {\n-                state->name[p - start] = *p;\n-                p++;\n-             }\n-             state->name[p - start] = '\\0';\n-          }\n-          for (int i = 0; i < stack.size(); i++) {\n-             std::cout << \" \";\n-          }\n-          state->value(std::cout, data);\n-          data += (state->sz \/ 8);\n-          stack.pop();\n-          delete state;\n-          p++;\n-       } else if (stack.empty()){\n-          std::cout << \"empty stack and  unhandled -> \"<< p<< std::endl;\n-          p++;\n-       } else {\n-          std::cout <<stack.top()->state()<< \" unhandled -> \"<< p<< std::endl;\n-          p++;\n-       }\n-    }\n-#endif\n-}\n+}*\/\n@@ -188,256 +68,2 @@\n-char *Schema::strduprange(char *start, char *end) {\n-    char *s = new char[end - start + 1];\n-    std::memcpy(s, start, end - start);\n-    s[end - start] = '\\0';\n-    return s;\n-}\n-\n-std::ostream &Schema::dump(std::ostream &out, char *start, char *end) {\n-    while (start < end) {\n-        out << (char) *start;\n-        start++;\n-    }\n-    return out;\n-}\n-\n-std::ostream &Schema::indent(std::ostream &out, int depth) {\n-    while (depth > 0) {\n-        out << \"  \";\n-        depth++;\n-    }\n-    return out;\n-}\n-\n-std::ostream &Schema::dump(std::ostream &out, char *label, char *start, char *end) {\n-    out << label << \" '\";\n-    dump(out, start, end) << \"' \" << std::endl;\n-    return out;\n-}\n-\n-\n-static const int AWAITING_STATE = 0x00001;\n-static const int IN_STATE = 0x00002;\n-static const int HAVE_STATE = 0x00004;\n-\n-static const int NAME_STATE = 0x00010;\n-static const int CAN_BE_ANON_STATE = 0x00020;\n-static const int NUMERIC_STATE = 0x00040;\n-static const int CAN_BE_FLEX_STATE = 0x00080;\n-\n-static const int ARGS_STATE = 0x00100;\n-static const int ARRAY_STATE = 0x00200;\n-static const int BUFFER_STATE = 0x00400;\n-static const int FIELD_STATE = 0x01000;\n-static const int TYPE_STATE = 0x02000;\n-static const int STRUCT_STATE = 0x04000;\n-static const int UNION_STATE = 0x08000;\n-\n-static const int awaitingArgsName = (ARGS_STATE | NAME_STATE | AWAITING_STATE);\n-static const int awaitingArrayName = (ARRAY_STATE | NAME_STATE | AWAITING_STATE);\n-static const int awaitingBufferName = (BUFFER_STATE | NAME_STATE | AWAITING_STATE);\n-static const int awaitingArrayLen = (ARRAY_STATE | NUMERIC_STATE | AWAITING_STATE);\n-static const int awaitingFieldName = (FIELD_STATE | NAME_STATE | AWAITING_STATE);\n-static const int awaitingTypeName = (TYPE_STATE | NAME_STATE | AWAITING_STATE);\n-\n-static const int inArgsName = (ARGS_STATE | NAME_STATE | IN_STATE);\n-static const int inArrayName = (ARRAY_STATE | CAN_BE_ANON_STATE | NAME_STATE | IN_STATE);\n-static const int inBufferName = (BUFFER_STATE | NAME_STATE | IN_STATE);\n-static const int inArrayLen = (ARRAY_STATE | CAN_BE_FLEX_STATE | NUMERIC_STATE | IN_STATE);\n-static const int inBufferSize = (BUFFER_STATE | NUMERIC_STATE | IN_STATE);\n-static const int inFieldName = (FIELD_STATE | CAN_BE_ANON_STATE | NAME_STATE | IN_STATE);\n-static const int inTypeName = (TYPE_STATE | NAME_STATE | IN_STATE);\n-\n-static const int haveArrayName = (ARRAY_STATE | NAME_STATE | HAVE_STATE);\n-static const int haveBufferName = (BUFFER_STATE | NAME_STATE | HAVE_STATE);\n-static const int haveArgsName = (ARGS_STATE | NAME_STATE | HAVE_STATE);\n-static const int haveFieldName = (FIELD_STATE | NAME_STATE | HAVE_STATE);\n-static const int haveTypeName = (TYPE_STATE | NAME_STATE | HAVE_STATE);\n-\n-#define nameit(s) {s, #s}\n-std::map<int, std::string> Schema::stateNameMap = {\n-        nameit(awaitingArrayLen),\n-        nameit(awaitingArrayName),\n-        nameit(awaitingArgsName),\n-        nameit(inArgsName),\n-        nameit(inTypeName),\n-        nameit(inArrayLen),\n-        nameit(inArrayName),\n-        nameit(inBufferName),\n-        nameit(inBufferSize),\n-        nameit(haveArrayName),\n-        nameit(haveArgsName),\n-        nameit(haveTypeName),\n-        nameit(haveFieldName)\n-};\n-\n-int Schema::replaceStateBit(int state, int remove, int set) {\n-    state |= set;\n-    state &= ~remove;\n-    return state;\n-}\n-\n-int Schema::newState(int state, int to) {\n-    return to;\n-}\n-\n-std::ostream &Schema::stateDescribe(std::ostream &out, int state) {\n-    out << \"(\";\n-    if (state & AWAITING_STATE) {\n-        out << \"Awaiting\";\n-    } else if (state & IN_STATE) {\n-        out << \"In\";\n-    } else if (state & HAVE_STATE) {\n-        out << \"Have\";\n-    }\n-\n-    if (state & FIELD_STATE) {\n-        out << \"Field\";\n-    } else if (state & TYPE_STATE) {\n-        out << \"Type\";\n-    } else if (state & BUFFER_STATE) {\n-        out << \"Buffer\";\n-    } else if (state & ARRAY_STATE) {\n-        out << \"Array\";\n-    } else if (state & ARGS_STATE) {\n-        out << \"Args\";\n-    }\n-\n-    if (state & NAME_STATE) {\n-        out << \"Name\";\n-    } else if (state & NUMERIC_STATE) {\n-        out << \"Numeric\";\n-    }\n-\n-    if (state & CAN_BE_ANON_STATE) {\n-        out << \"(? ok)\";\n-    } else if (state & CAN_BE_FLEX_STATE) {\n-        out << \"(* ok)\";\n-    }\n-    out << \")\";\n-    return out;\n-}\n-\n-std::ostream &Schema::stateType(std::ostream &out, int state) {\n-    if (state & FIELD_STATE) {\n-        out << \"field\";\n-    } else if (state & TYPE_STATE) {\n-        out << \"type\";\n-    } else if (state & BUFFER_STATE) {\n-        out << \"buffer\";\n-    } else if (state & ARRAY_STATE) {\n-        out << \"array\";\n-    } else if (state & ARGS_STATE) {\n-        out << \"args\";\n-    } else {\n-        out << \"WTF\";\n-    }\n-    return out;\n-}\n-\n-char *Schema::dumpSchema(std::ostream &out, int state, int depth, char *ptr, void *data) {\n-    char *start = nullptr;\n-    indent(out, depth);\n-    while (ptr != nullptr && *ptr != '\\0') {\n-        if (stateNameMap.count(state) == 0) {\n-            std::cerr << \"no key\" << std::endl;\n-            exit(1);\n-        }\n-        stateDescribe(out, state) << \"> with '\" << ((char) *ptr) << \"'\";\n-        out.flush();\n-        if (state & AWAITING_STATE) {\n-            start = ptr;\n-            if (\n-                    (((state == awaitingArrayName) || (state == awaitingFieldName)) && (*ptr == '?'))\n-                    || ((state & NAME_STATE) && (std::isalpha(*ptr)))\n-                    || ((state & NUMERIC_STATE) && (std::isdigit(*ptr)))\n-                    || ((state == awaitingArrayLen) && (*ptr == '*'))\n-                    ) {\n-                state = replaceStateBit(state, AWAITING_STATE, IN_STATE);\n-                ptr++;\n-            } else if (((*ptr == ',') || (*ptr == '}') || (*ptr == ']') || (*ptr == '>'))) {\n-                ptr++;\n-            } else {\n-                std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n-                          << std::endl;\n-                exit(1);\n-            }\n-        } else if (state & IN_STATE) {\n-            if (\n-                    ((state & NAME_STATE) && (std::isalnum(*ptr) || *ptr == '_'))\n-                    ||  ((state & NUMERIC_STATE) && std::isdigit(*ptr))\n-                    || ((state == inBufferSize) && ((*ptr == '+') || (*ptr == '!')))\n-                    ){\n-                ptr++;\n-            } else if (*ptr == ':') {\n-                stateType(out, state);\n-                dump(out, start, ptr++);\n-                indent(out, depth);\n-                state = replaceStateBit(state, IN_STATE, HAVE_STATE);\n-            } else {\n-                std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n-                          << std::endl;\n-                exit(1);\n-            }\n-        } else if ((state & HAVE_STATE)) {\n-            switch (state) {\n-                case haveArrayName: {\n-                    \/\/ we expect a type\n-                    if (std::isdigit(*ptr)) {\n-                        start = ptr;\n-                        ptr++;\n-                        state = newState(state, inBufferSize);\n-                    } else if (std::isalpha(*ptr)) {\n-                        ptr++;\n-                        state = newState(state, inTypeName);\n-                    } else {\n-                        std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n-                                  << std::endl;\n-                        exit(1);\n-                    }\n-                    break;\n-                }\n-                case haveArgsName: {\n-                    \/\/ we expect a type name  or array, struct, union\n-                    if (*ptr == '[') {\n-                        ptr++;\n-                        state = newState(state, awaitingArrayLen);\n-                        \/\/ we expect a type\n-                    } else if ((*ptr == '{') || (*ptr == '<')) {\n-                        ptr++;\n-                        state = newState(state, awaitingFieldName);\n-                    } else if (std::isalnum(*ptr)) {\n-                        ptr++;\n-                        state =newState(state, inTypeName);\n-                    } else {\n-                        std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n-                                  << std::endl;\n-                        exit(1);\n-                    }\n-                    break;\n-                }\n-                default: {\n-                    std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n-                              << std::endl;\n-                    exit(1);\n-                }\n-            }\n-        } else {\n-            std::cerr << \"err \" << \"<\" << stateNameMap[state] << \"> with '\" << ((char) *ptr) << \"'\" << ptr\n-                      << std::endl;\n-            exit(1);\n-        }\n-\n-    }\n-    return ptr;\n-}\n-\n-char *Schema::dumpSchema(std::ostream &out, char *ptr, void *data) {\n-    return dumpSchema(out, awaitingArgsName, 0, ptr, data);\n-}\n-\n-char *Schema::dumpSchema(std::ostream &out, char *ptr) {\n-    return dumpSchema(out, ptr, nullptr);\n-}\n-\n-void Schema::dumpSled(std::ostream &out, void *argArray) {\n-    ArgSled argSled(static_cast<ArgArray_t *>(argArray));\n+void Sled::show(std::ostream &out, void *argArray) {\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n@@ -445,1 +71,1 @@\n-        Arg_t *arg = argSled.arg(i);\n+        Arg_s *arg = argSled.arg(i);\n@@ -492,2 +118,0 @@\n-\n-    \/\/ dumpSchema(out, argSled.schema()); not stable yet\n@@ -496,1 +120,0 @@\n-\/\/ We need to trampoline through the real backend\n","filename":"hat\/backends\/shared\/cpp\/shared.cpp","additions":7,"deletions":384,"binary":false,"changes":391,"status":"modified"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+#include <vector>\n+#include <cstring>\n+#include <iostream>\n+#include <iomanip>\n+\n+struct Cursor {\n+    char *ptr;\n+    Cursor(char *ptr): ptr(ptr) {\n+    }\n+\n+    virtual ~Cursor() {\n+    }\n+\n+private:\n+    Cursor *skipWhiteSpace() {\n+        while (*ptr == ' ' || *ptr == '\\n' || *ptr == '\\t') {\n+            step(1);\n+        }\n+        return this;\n+    }\n+\n+\n+    Cursor *skipIdentifier() {\n+        while (peekAlpha() || peekDigit()) {\n+            step(1);\n+        }\n+        return this;\n+    }\n+public:\n+    void step(int count) {\n+        while (count--) {\n+            ptr++;\n+        }\n+    }\n+\n+    bool peekAlpha() {\n+        skipWhiteSpace();\n+        return (::isalpha(*ptr));\n+    }\n+\n+    bool peekDigit() {\n+        skipWhiteSpace();\n+        return (::isdigit(*ptr));\n+    }\n+\n+    bool is(char ch) {\n+        skipWhiteSpace();\n+        if (*ptr == ch) {\n+            step(1);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    bool isEither(char ch1, char ch2) {\n+        skipWhiteSpace();\n+        if (*ptr == ch1 || *ptr == ch2) {\n+            step(1);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    bool isEither(char ch1, char ch2, char ch3) {\n+        skipWhiteSpace();\n+        if (*ptr == ch1 || *ptr == ch2 || *ptr == ch3) {\n+            step(1);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/*bool is(char *str) {\n+        skipWhiteSpace();\n+        int count = 0;\n+        char *safePtr = ptr;\n+        while (*str && *ptr && *str == *ptr) {\n+            ptr++;\n+            str++;\n+            count++;\n+        }\n+        if (count > 0 && *str == '\\0') {\n+            step(count);\n+            return true;\n+        }\n+        ptr = safePtr;\n+        return false;\n+    }*\/\n+\n+    int getInt() {\n+        int value = *ptr - '0';\n+        step(1);\n+        if (peekDigit()) {\n+            return value * 10 + getInt();\n+        }\n+        return value;\n+    }\n+\n+    long getLong() {\n+        long value = *ptr - '0';\n+        step(1);\n+        if (peekDigit()) {\n+            return value * 10 + getLong();\n+        }\n+        return value;\n+    }\n+\n+    char *getIdentifier() {\n+        char *identifierStart = ptr;\n+        skipIdentifier();\n+        size_t len = ptr - identifierStart;\n+        char *identifier = new char[len + 1];\n+        std::memcpy(identifier, identifierStart, len);\n+        identifier[len] = '\\0';\n+        return identifier;\n+    }\n+\n+    void error(std::ostream &ostream, const char *file, int line, const char *str) {\n+        ostream << file << \":\" << \"@\" << line << \": parse error \" << str << \" looking at \" << ptr << std::endl;\n+        exit(1);\n+    }\n+\n+};\n+\n+struct Schema {\n+    struct Node {\n+        enum Type {\n+            StructType, UnionType, ArrayType, NamedStructOrUnionType, ArgType, SchemaType, FieldType, SimpleType\n+        };\n+        Type type;\n+        Node *parent;\n+        char *start;\n+        char *end;\n+        std::vector<Node *> children;\n+\n+        Node(Node *parent, Type type):parent(parent), type(type) {\n+        }\n+\n+        Node *addChild(Cursor *cursor, Node *child) {\n+            children.push_back(child);\n+            return child->parse(cursor);\n+        }\n+\n+        virtual Node *parse(Cursor *cursor) {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"In Node virtual parse!\");\n+            return nullptr;\n+        };\n+\n+        virtual ~Node() = default;\n+    };\n+\n+    struct SimpleType : public Node {\n+        char *name;\n+\n+        SimpleType(Node *paren)\n+                : Node(paren, Node::Type::SimpleType), name(nullptr) {\n+\n+        }\n+\n+        virtual SimpleType *parse(Cursor *cursor) {\n+            name = cursor->getIdentifier();\n+            return this;\n+        }\n+\n+        virtual ~SimpleType() {\n+            if (name) {\n+                delete[] name;\n+            }\n+        }\n+    };\n+\n+    struct Array : public Node {\n+        bool flexible;\n+        long elementCount;\n+        char *elementName;\n+        Node *elementType;\n+\n+        Array(Node *paren): Node(paren, Node::Type::ArrayType), flexible(false), elementCount(0), elementName(nullptr), elementType(nullptr) {\n+        }\n+\n+        virtual Array *parse(Cursor *cursor);\n+\n+        virtual ~Array() {\n+            if (elementType) {\n+                delete elementType;\n+            }\n+            if (elementName) {\n+                delete[] elementName;\n+            }\n+        }\n+    };\n+\n+    struct NamedNode : public Node {\n+        char *name;\n+        Node *typeNode;\n+\n+        NamedNode(Node *parent, Node::Type type): Node(parent, type), name(nullptr), typeNode(nullptr) {\n+        }\n+\n+        ~NamedNode() {\n+            if (name) {\n+                delete[] name;\n+            }\n+\n+            if (typeNode) {\n+                delete typeNode;\n+            }\n+        }\n+    };\n+\n+    struct Field : public NamedNode {\n+        explicit Field(Node *parent)\n+                : NamedNode(parent, Type::FieldType) {\n+        }\n+\n+        virtual Field *parse(Cursor *cursor) {\n+            cursor->error(std::cerr, __FILE__, __LINE__, \"Implement field parser\");\n+            return this;\n+        }\n+\n+        ~Field() {\n+        }\n+    };\n+\n+    struct StructOrUnion : public NamedNode {\n+        char separator;\n+        char terminator;\n+\n+        StructOrUnion(Node *parent, Node::Type type, char separator, char terminator)\n+                : NamedNode(parent, type), separator(separator), terminator(terminator) {\n+\n+        }\n+\n+        virtual StructOrUnion *parse(Cursor *cursor);\n+\n+        virtual ~StructOrUnion() {\n+\n+        }\n+    };\n+\n+    struct Union : public StructOrUnion {\n+        Union(Node *parent)\n+                : StructOrUnion(parent, Node::Type::UnionType, '|', '>') {\n+        }\n+\n+        virtual Union *parse(Cursor *cursor) {\n+            return dynamic_cast<Union *>(StructOrUnion::parse(cursor));\n+        }\n+\n+        virtual ~Union() {\n+        }\n+    };\n+\n+    struct Struct : public StructOrUnion {\n+\n+        explicit Struct(Node *parent)\n+                : StructOrUnion(parent, Node::Type::StructType, ',', '}') {\n+        }\n+\n+        virtual Struct *parse(Cursor *cursor) {\n+            return dynamic_cast<Struct *>(StructOrUnion::parse(cursor));\n+        }\n+\n+        virtual ~Struct() {\n+\n+        }\n+    };\n+\n+\n+    struct NamedStructOrUnion : public Node {\n+        bool complete;\n+        long bytes;\n+        char *identifier;\n+\n+        NamedStructOrUnion(Node *paren)\n+                : Node(paren, Node::Type::NamedStructOrUnionType), complete(false), bytes(0L), identifier(nullptr) {\n+        }\n+\n+        virtual NamedStructOrUnion *parse(Cursor *cursor);\n+\n+        virtual ~NamedStructOrUnion() {\n+            if (identifier) {\n+                delete[]identifier;\n+            }\n+\n+        }\n+    };\n+\n+\n+    struct Arg : public Node {\n+        Arg(Node *parent)\n+                : Node(parent, Node::Type::ArgType) {\n+        }\n+\n+        virtual Arg *parse(Cursor *cursor);\n+\n+        virtual ~Arg() {\n+\n+        }\n+    };\n+\n+    struct SchemaNode : public Node {\n+        SchemaNode()\n+                : Node(nullptr, Node::Type::SchemaType) {\n+        }\n+\n+        virtual SchemaNode *parse(Cursor *cursor);\n+\n+        virtual ~SchemaNode() {\n+        }\n+    };\n+\n+    static void show(std::ostream &out, char *schema);\n+    static void show(std::ostream &out, int depth, Node* node);\n+    static void show(std::ostream &out, SchemaNode* schemaNode);\n+};\n\\ No newline at end of file\n","filename":"hat\/backends\/shared\/include\/schema.h","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -78,1 +78,1 @@\n-typedef struct Buffer_s {\n+ struct Buffer_s {\n@@ -84,1 +84,1 @@\n-} Buffer_t;\n+} ;\n@@ -86,1 +86,1 @@\n-typedef union value_u {\n+ union Value_u {\n@@ -98,2 +98,2 @@\n-    Buffer_t buffer; \/\/ '&'\n-} Value_t;\n+    Buffer_s buffer; \/\/ '&'\n+} ;\n@@ -101,1 +101,1 @@\n-typedef struct Arg_s {\n+ struct Arg_s {\n@@ -105,1 +105,1 @@\n-    Value_t value;\n+    Value_u value;\n@@ -107,1 +107,1 @@\n-} Arg_t;\n+};\n@@ -109,1 +109,1 @@\n-typedef struct ArgArray_s {\n+struct ArgArray_s {\n@@ -112,1 +112,1 @@\n-    Arg_t argv[0\/*argc*\/];\n+    Arg_s argv[0\/*argc*\/];\n@@ -116,1 +116,1 @@\n-} ArgArray_t;\n+};\n@@ -120,1 +120,1 @@\n-    ArgArray_t *argArray;\n+    ArgArray_s *argArray;\n@@ -126,2 +126,2 @@\n-    Arg_t *arg(int n) {\n-        Arg_t *a = (argArray->argv + n);\n+    Arg_s *arg(int n) {\n+        Arg_s *a = (argArray->argv + n);\n@@ -132,1 +132,1 @@\n-        hexdump(arg(n), sizeof(Arg_t));\n+        hexdump(arg(n), sizeof(Arg_s));\n@@ -136,1 +136,1 @@\n-        Arg_t *a = arg(n);\n+        Arg_s *a = arg(n);\n@@ -175,1 +175,1 @@\n-        Arg_t *a = arg(argc());\n+        Arg_s *a = arg(argc());\n@@ -193,1 +193,1 @@\n-    ArgSled(ArgArray_t *argArray)\n+    ArgSled(ArgArray_s *argArray)\n@@ -215,1 +215,0 @@\n-\/*\n@@ -217,158 +216,0 @@\n-struct State {\n-   enum StateType {\n-      NONE, STRUCT_OR_UNION, SEQUENCE,MEMBER\n-   };\n-   StateType stateType;\n-   char *start;\n-   void *dataStart;\n-   int count;\n-   int of;\n-   int sz = 0;\n-   char name[128];\n-\n-   State(StateType stateType, char *start, void *dataStart, int count, int sz)\n-      : stateType(stateType), start(start), dataStart(dataStart), count(0), of(count), sz(sz) {\n-         name[0] = '\\0';\n-      }\n-\n-   bool isMember() {\n-      return stateType == MEMBER;\n-   }\n-\n-   bool isI08() {\n-      return stateType == MEMBER && *start == 'b' && sz == 8;\n-   }\n-\n-   bool isI16() {\n-      return stateType == MEMBER && *start == 'i' && sz == 16;\n-   }\n-\n-   bool isI32() {\n-      return stateType == MEMBER && *start == 'i' && sz == 32;\n-   }\n-\n-   bool isI64() {\n-      return stateType == MEMBER && *start == 'i' && sz == 64;\n-   }\n-   bool isS08() {\n-      return stateType == MEMBER && *start == 's' && sz == 8;\n-   }\n-\n-   bool isS16() {\n-      return stateType == MEMBER && *start == 's' && sz == 16;\n-   }\n-\n-   bool isS32() {\n-      return stateType == MEMBER && *start == 's' && sz == 32;\n-   }\n-\n-   bool isS64() {\n-      return stateType == MEMBER && *start == 's' && sz == 64;\n-   }\n-\n-   bool isF32() {\n-      return stateType == MEMBER && *start == 'f' && sz == 32;\n-   }\n-\n-   bool isF64() {\n-      return stateType == MEMBER && *start == 'f' && sz == 64;\n-   }\n-\n-   bool isSequence() {\n-      return stateType == SEQUENCE;\n-   }\n-\n-   bool isEndOfSequence(){\n-      return isSequence() && ((count+1) ==of);\n-   }\n-   bool isMidSequence(){\n-      return isSequence() && ((count+1)<of);\n-   }\n-\n-   bool isStructOrUnion() {\n-      return stateType == STRUCT_OR_UNION;\n-   }\n-\n-   void value(std::ostream &s, void *data){\n-      s << std::setw(8) <<std::left<< typeName() << std::setw(30) << std::left<< name << \" \";\n-      if (isF32()) {\n-         float *fp = (float *) data;\n-         s <<std::setw(10) << std::right<< *fp << std::endl;\n-      } else if (isF64()) {\n-         double *dp = (double *) data;\n-         s <<std::setw(10) << std::right << *dp << std::endl;\n-      } else if (isI08()) {\n-         char *cp = (char *) data;\n-         s <<std::setw(10) << std::right<< ((int) *cp) << std::endl;\n-      } else if (isI16()) {\n-         short *sp = (short *) data;\n-         s <<std::setw(10) << std::right<< *sp << std::endl;\n-      } else if (isI32()) {\n-         int *ip = (int *) data;\n-         s <<std::setw(10) << std::right<< *ip << std::endl;;\n-      } else if (isI64()) {\n-         long *lp = (long *) data;\n-         s <<std::setw(10) << std::right<< *lp << std::endl;\n-      } else if (isS08()) {\n-         char *cp = (char *) data;\n-         s <<std::setw(10) << std::right<< ((int) *cp) << std::endl;\n-      } else if (isS16()) {\n-         short *sp = (short *) data;\n-         s <<std::setw(10) << std::right<< *sp << std::endl;\n-      } else if (isS32()) {\n-         int *ip = (int *) data;\n-         s <<std::setw(10) << std::right<< *ip << std::endl;;\n-      } else if (isS64()) {\n-         long *lp = (long *) data;\n-         s <<std::setw(10) << std::right<< *lp << std::endl;\n-      } else {\n-         s << \"??     \";\n-      }\n-   }\n-\n-   const char* state() {\n-      switch (stateType) {\n-         case NONE:return \"NONE\";\n-         case SEQUENCE:return \"SEQUENCE\";\n-         case MEMBER:return \"MEMBER\";\n-         case STRUCT_OR_UNION:return \"STRUCT_OR_UNION\";\n-      }\n-      return \"?\";\n-   }\n-   const char* typeName() {\n-      if (isF32()) {\n-         return \"f32_t\";\n-      } else if (isF64()) {\n-         return \"f64_t\";\n-      } else if (isI08()) {\n-         return \"i08_t\";\n-      } else if (isI16()) {\n-         return \"i16_t\";\n-      } else if (isI32()) {\n-         return \"i32_t\";;\n-      } else if (isI64()) {\n-         return \"i64_t\";\n-      } else if (isS08()) {\n-         return \"s08_t\";\n-      } else if (isS16()) {\n-         return \"s16_t\";\n-      } else if (isS32()) {\n-         return \"s32_t\";;\n-      } else if (isS64()) {\n-         return \"s64_t\";\n-      } else {\n-         return \"??\";\n-      }\n-   }\n-   static State *sequence(char *start, void *dataStart,  int count) {\n-      return new State(SEQUENCE, start, dataStart, count, 0);\n-   }\n-\n-   static State *structOrUnion(char *start, void *dataStart) {\n-      return new State(STRUCT_OR_UNION, start,dataStart, 0, 0);\n-   }\n-\n-   static State *member(char *start,void *dataStart, int sz) {\n-      return new State(MEMBER, start, dataStart,0, sz);\n-   }\n-};*\/\n@@ -397,1 +238,1 @@\n-extern \"C\" void dumpArgArray(void *ptr);\n+\/\/extern \"C\" void dumpArgArray(void *ptr);\n@@ -402,1 +243,1 @@\n-class Schema {\n+class Sled {\n@@ -404,21 +245,1 @@\n-    static std::map<int, std::string> stateNameMap;\n-\n-    static int replaceStateBit(int state, int remove, int set);\n-    static int newState(int state, int to);\n-    static std::ostream &stateType(std::ostream &out, int state);\n-    static std::ostream &stateDescribe(std::ostream &out, int state);\n-    static char *strduprange(char *start, char *end);\n-\n-    static std::ostream &indent(std::ostream &out, int depth);\n-\n-    static std::ostream &dump(std::ostream &out, char *start, char *end);\n-\n-    static std::ostream &dump(std::ostream &out, char *label, char *start, char *end);\n-\n-    static void dumpSled(std::ostream &out, void *argArray);\n-\n-    static char *dumpSchema(std::ostream &out, int, int depth, char *ptr, void *data);\n-\n-    static char *dumpSchema(std::ostream &out, char *ptr, void *data);\n-\n-    static char *dumpSchema(std::ostream &out, char *ptr);\n+    static void show(std::ostream &out, void *argArray);\n@@ -427,1 +248,2 @@\n-class NDRange{\n+\n+class NDRange {\n@@ -446,1 +268,1 @@\n-                Arg_t *arg;\n+                Arg_s *arg;\n@@ -452,1 +274,2 @@\n-                Buffer(Kernel *kernel, Arg_t *arg) : kernel(kernel), arg(arg) {\n+                Buffer(Kernel *kernel, Arg_s *arg)\n+                        : kernel(kernel), arg(arg) {\n@@ -462,4 +285,10 @@\n-            virtual long ndrange( void *argArray) = 0;\n-\n-            Kernel(Program *program, char * name)\n-                    : program(program), name(strdup(name)) {\n+            virtual long ndrange(void *argArray) = 0;\n+            static char *copy(char *name){\n+                size_t len =::strlen(name);\n+                char *buf = new char[len+1];\n+                memcpy(buf, name, len);\n+                buf[len]='\\0';\n+                return buf;\n+            }\n+            Kernel(Program *program, char *name)\n+                    : program(program), name(copy(name)) {\n@@ -468,3 +297,3 @@\n-            virtual ~Kernel(){\n-                if (name){\n-                    free(name);\n+            virtual ~Kernel() {\n+                if (name) {\n+                    delete[] name;\n@@ -522,1 +351,1 @@\n-extern \"C\" long ndrange(long kernelHandle,  void *argArray);\n+extern \"C\" long ndrange(long kernelHandle, void *argArray);\n","filename":"hat\/backends\/shared\/include\/shared.h","additions":40,"deletions":211,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -345,2 +345,2 @@\n-        StringBuilder argSchema = new StringBuilder(\"args:[\");\n-        argSchema.append(args.length).append(\":\");\n+        StringBuilder argSchema = new StringBuilder();\n+        argSchema.append(args.length);\n@@ -350,10 +350,10 @@\n-                case Boolean z1 -> \"?:z1\";\n-                case Byte s8 -> \"?:s8\";\n-                case Short s16 -> \"?:s16\";\n-                case Character u16 -> \"?:u16\";\n-                case Float f32 -> \"?:f32\";\n-                case Integer s32 -> \"?:s32\";\n-                case Long s64 -> \"?:s64\";\n-                case Double f64 -> \"?:f64\";\n-                case CompleteBuffer buffer -> \"!:\" + buffer.schema();\n-                case IncompleteBuffer buffer -> \"?:\" + buffer.schema();\n+                case Boolean z1 -> \"(?:z1)\";\n+                case Byte s8 -> \"(?:s8)\";\n+                case Short s16 -> \"(?:s16)\";\n+                case Character u16 -> \"(?:u16)\";\n+                case Float f32 -> \"(?:f32)\";\n+                case Integer s32 -> \"(?:s32)\";\n+                case Long s64 -> \"(?:s64)\";\n+                case Double f64 -> \"(?:f64)\";\n+                case CompleteBuffer buffer -> \"(!:\" + buffer.schema()+\")\";\n+                case IncompleteBuffer buffer -> \"(?:\" + buffer.schema()+\")\";\n@@ -367,1 +367,0 @@\n-        argSchema.append(\"]\");\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.util.StreamCounter;\n+\n@@ -33,0 +35,1 @@\n+import java.lang.foreign.UnionLayout;\n@@ -52,41 +55,0 @@\n-\n-    default String buildSchema(StringBuilder sb, MemoryLayout layout, SequenceLayout tailSequenceLayout) {\n-        sb.append((layout.name().isPresent()) ? layout.name().get() : \"?\").append(\":\");\n-        switch (layout) {\n-            case GroupLayout groupLayout -> {\n-                String prefix = groupLayout instanceof StructLayout ? \"{\" : \"<\";\n-                String suffix = groupLayout instanceof StructLayout ? \"}\" : \">\";\n-                String separator = groupLayout instanceof StructLayout ? \",\" : \"|\";\n-                sb.append(prefix);\n-                boolean[] first = {true};\n-                groupLayout.memberLayouts().forEach(l -> {\n-                    if (!first[0]) {\n-                        sb.append(separator);\n-                    } else {\n-                        first[0] = false;\n-                    }\n-                    buildSchema(sb, l, tailSequenceLayout);\n-                });\n-                sb.append(suffix);\n-            }\n-            case ValueLayout valueLayout -> {\n-                sb.append(ArgArray.valueLayoutToSchemaString(valueLayout));\n-            }\n-            case PaddingLayout paddingLayout -> sb.append(\"x\").append(paddingLayout.byteSize());\n-            case SequenceLayout sequenceLayout -> {\n-\n-                sb.append('[');\n-                if (sequenceLayout.equals(tailSequenceLayout) && this instanceof IncompleteBuffer) {\n-                    sb.append(\"*\");\n-                } else {\n-                    sb.append(sequenceLayout.elementCount());\n-                }\n-                sb.append(\":\");\n-                buildSchema(sb, sequenceLayout.elementLayout(), tailSequenceLayout);\n-                sb.append(']');\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -8,4 +8,5 @@\n-        MemoryLayout memoryLayout = layout();\n-        MemorySegment segment = memorySegment();\n-        StringBuilder sb = new StringBuilder(Long.toString(segment.byteSize())).append(\"!\");\n-        return buildSchema(sb, memoryLayout, null);\n+        return new SchemaBuilder()\n+                .literal(memorySegment().byteSize())\n+                .hash()\n+                .layout(layout(),null, false)\n+                .toString();\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/CompleteBuffer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -13,4 +13,6 @@\n-                long offsetOfTailSequenceLayout = memoryLayout.byteOffset(MemoryLayout.PathElement.groupElement(memberLayouts.size() - 1));\n-                \/\/  var offsetOfTailSequenceLayout = tailSequenceLayout.byteOffset();\n-                StringBuilder sb = new StringBuilder(Long.toString(offsetOfTailSequenceLayout)).append(\"+\");\n-                return buildSchema(sb, layout(), tailSequenceLayout);\n+                return new SchemaBuilder()\n+                        .literal(memoryLayout.byteOffset(\n+                                MemoryLayout.PathElement.groupElement(memberLayouts.size() - 1)))\n+                        .plus()\n+                        .layout(layout(),tailSequenceLayout,true)\n+                        .toString();\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/IncompleteBuffer.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+package hat.buffer;\n+\n+import hat.text.CodeBuilder;\n+import hat.util.StreamCounter;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+public class SchemaBuilder extends CodeBuilder<SchemaBuilder> {\n+    SchemaBuilder layout(MemoryLayout layout, SequenceLayout tailSequenceLayout, boolean incomplete) {\n+        either(layout.name().isPresent(), (_) -> identifier(layout.name().get()), (_) -> questionMark()).colon();\n+        switch (layout) {\n+            case StructLayout structLayout -> {\n+                brace((_) -> {\n+                    StreamCounter.of(structLayout.memberLayouts().stream(), (c, l) -> {\n+                        if (c.isNotFirst()) {\n+                            comma();\n+                        }\n+                        layout(l, tailSequenceLayout, incomplete);\n+                    });\n+                });\n+            }\n+            case UnionLayout unionLayout -> {\n+                chevron((_) -> {\n+                    StreamCounter.of(unionLayout.memberLayouts().stream(), (c, l) -> {\n+                        if (c.isNotFirst()) {\n+                            bar();\n+                        }\n+                        layout(l, tailSequenceLayout, incomplete);\n+                    });\n+                });\n+            }\n+            case ValueLayout valueLayout -> {\n+                literal(ArgArray.valueLayoutToSchemaString(valueLayout));\n+            }\n+            case PaddingLayout paddingLayout -> {\n+                literal(\"x\").literal(paddingLayout.byteSize());\n+            }\n+            case SequenceLayout sequenceLayout -> {\n+                sbrace((_) -> {\n+                    if (sequenceLayout.equals(tailSequenceLayout) && incomplete) {\n+                        asterisk();\n+                    } else {\n+                        literal(sequenceLayout.elementCount());\n+                    }\n+                    colon();\n+                    layout(sequenceLayout.elementLayout(), tailSequenceLayout, incomplete);\n+                });\n+            }\n+        }\n+        return this;\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/SchemaBuilder.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -368,1 +368,3 @@\n-\n+    public T chevron(Consumer<T> ct) {\n+        return rawochevron().indent(ct).rawcchevron();\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/text\/CodeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    private StreamCounter() {\n+    public StreamCounter() {\n","filename":"hat\/hat\/src\/main\/java\/hat\/util\/StreamCounter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}