{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import hat.Schema;\n@@ -28,0 +29,1 @@\n+import hat.buffer.BufferAllocator;\n@@ -29,0 +31,3 @@\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n@@ -32,0 +37,1 @@\n+\n@@ -33,0 +39,1 @@\n+\n@@ -34,0 +41,1 @@\n+\n@@ -35,0 +43,1 @@\n+\n@@ -37,0 +46,1 @@\n+\n@@ -38,0 +48,1 @@\n+\n@@ -39,0 +50,1 @@\n+\n@@ -40,0 +52,1 @@\n+\n@@ -43,0 +56,1 @@\n+\n@@ -44,0 +58,1 @@\n+\n@@ -45,0 +60,1 @@\n+\n@@ -47,0 +63,1 @@\n+\n@@ -48,0 +65,1 @@\n+\n@@ -49,0 +67,1 @@\n+\n@@ -51,0 +70,1 @@\n+\n@@ -52,0 +72,1 @@\n+\n@@ -53,0 +74,1 @@\n+\n@@ -55,0 +77,1 @@\n+\n@@ -56,0 +79,1 @@\n+\n@@ -57,0 +81,1 @@\n+\n@@ -58,0 +83,1 @@\n+\n@@ -59,0 +85,1 @@\n+\n@@ -60,0 +87,1 @@\n+\n@@ -61,0 +89,1 @@\n+\n@@ -62,0 +91,1 @@\n+\n@@ -63,0 +93,1 @@\n+\n@@ -65,0 +96,1 @@\n+\n@@ -67,0 +99,1 @@\n+\n@@ -68,0 +101,1 @@\n+\n@@ -70,0 +104,1 @@\n+\n@@ -72,0 +107,1 @@\n+\n@@ -73,0 +109,1 @@\n+\n@@ -74,0 +111,1 @@\n+\n@@ -75,0 +113,1 @@\n+\n@@ -76,0 +115,1 @@\n+\n@@ -77,0 +117,1 @@\n+\n@@ -78,0 +119,1 @@\n+\n@@ -80,0 +122,1 @@\n+\n@@ -81,1 +124,2 @@\n-   \/\/ void stageCount(int stageCount);\n+\n+    \/\/ void stageCount(int stageCount);\n@@ -83,0 +127,1 @@\n+\n@@ -85,0 +130,1 @@\n+\n@@ -86,0 +132,1 @@\n+\n@@ -87,0 +134,1 @@\n+\n@@ -88,0 +136,1 @@\n+\n@@ -89,0 +138,1 @@\n+\n@@ -91,0 +141,1 @@\n+\n@@ -92,1 +143,2 @@\n- \/\/   void treeCount(int treeCount);\n+\n+    \/\/   void treeCount(int treeCount);\n@@ -97,1 +149,1 @@\n-            .fields(\"width\",\"height\")\n+            .fields(\"width\", \"height\")\n@@ -99,2 +151,2 @@\n-                    .fields(\"id\",\"threshold\")\n-                    .fields(\"left\",\"right\",linkOrValue->linkOrValue\n+                    .fields(\"id\", \"threshold\")\n+                    .fields(\"left\", \"right\", linkOrValue -> linkOrValue\n@@ -103,1 +155,1 @@\n-                            .field(\"anon\", anon->anon.fields(\"featureId\",\"value\"))\n+                            .field(\"anon\", anon -> anon.fields(\"featureId\", \"value\"))\n@@ -105,1 +157,1 @@\n-                    .array(\"rect\", 3 , rect->rect.fields(\"x\",\"y\",\"width\",\"height\",\"weight\"))\n+                    .array(\"rect\", 3, rect -> rect.fields(\"x\", \"y\", \"width\", \"height\", \"weight\"))\n@@ -107,2 +159,2 @@\n-            .arrayLen(\"treeCount\").array(\"tree\",tree->tree.fields(\"id\",\"featureCount\",\"firstFeatureId\"))\n-            .arrayLen(\"stageCount\").array(\"stage\", stage->stage.fields(\"id\",\"threshold\",\"treeCount\",\"firstTreeId\"))\n+            .arrayLen(\"treeCount\").array(\"tree\", tree -> tree.fields(\"id\", \"featureCount\", \"firstFeatureId\"))\n+            .arrayLen(\"stageCount\").array(\"stage\", stage -> stage.fields(\"id\", \"threshold\", \"treeCount\", \"firstTreeId\"))\n@@ -111,1 +163,12 @@\n-\n+    public static void main(String[] args) {\n+        BufferAllocator bufferAllocator = new BufferAllocator() {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n+                return s.allocate(Arena.global());\n+            }\n+        };\n+        Cascade.schema.toText(t -> System.out.print(t));\n+        var cascadelayout = Cascade.schema.layout(10, 10, 10);\n+        System.out.println(cascadelayout);\n+        var cascade = Cascade.schema.allocate(bufferAllocator, 10, 10, 10).instance;\n+        System.out.println(Buffer.getLayout(cascade));\n+    }\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Cascade.java","additions":73,"deletions":10,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.Schema;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Schema;\n@@ -28,0 +29,5 @@\n+import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n@@ -40,1 +46,1 @@\n-    void atomicResultTableCount(int atomicResultTableCount);\n+    void atomicResultTableCount(int count);\n@@ -45,1 +51,1 @@\n-            .field(\"atomicResultTableCount\")\n+            .atomic(\"atomicResultTableCount\")\n@@ -48,4 +54,17 @@\n-    default int atomicResultTableCountInc() {\n-        int index = atomicResultTableCount();\n-        atomicResultTableCount(index + 1);\n-        return index;\n+\n+    public static void main(String[] args) {\n+        BufferAllocator bufferAllocator = new BufferAllocator() {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n+                return s.allocate(Arena.global());\n+            }\n+        };\n+        ResultTable.schema.toText(t->System.out.print(t));\n+        System.out.println();\n+        GroupLayout layout = ResultTable.schema.layout(1000);\n+        System.out.println(layout);\n+        System.out.println(\"[i4(length)i4(atomicResultTableCount)[1000:[f4(x)f4(y)f4(width)f4(height)](Result)](result)](ResultTable)\");\n+       \/\/ var boundSchema = ResultTable.schema.allocate(bufferAllocator, 100);\n+\n+      \/\/  var resultTable = ResultTable.schema.allocate(bufferAllocator, 100).instance;\n+      \/\/  int resultTableLen = resultTable.length();\n+      \/\/  System.out.println(Buffer.getLayout(resultTable));\n@@ -53,0 +72,1 @@\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ResultTable.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.Schema;\n@@ -28,0 +29,4 @@\n+import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n@@ -34,0 +39,16 @@\n+\n+    public static void main(String[] args) {\n+        BufferAllocator bufferAllocator = new BufferAllocator() {\n+            public <T extends Buffer> T allocate(SegmentMapper<T> s) {\n+                return s.allocate(Arena.global());\n+            }\n+        };\n+        hat.buffer.S32Array os32  = hat.buffer.S32Array.create(bufferAllocator,100);\n+        System.out.println(\"Layout from hat S32Array \"+ Buffer.getLayout(os32));\n+\n+        var s32Array = S32Array.schema.allocate(bufferAllocator, 100).instance;\n+        int s23ArrayLen = s32Array.length();\n+        System.out.println(\"Layout from schema \"+Buffer.getLayout(s32Array));\n+        ResultTable.schema.toText(t->System.out.print(t));\n+    }\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,625 +0,0 @@\n-package experiments;\n-\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n-public class Schema<T extends Buffer>  {\n-    AbstractField.ParentField field;\n-    Class<T> iface;\n-\n-    public GroupLayout layout(int ... arrayLengths) {\n-        LinkedList<Integer> lengthsToBind = new LinkedList<>();\n-        for (var i:arrayLengths){\n-            lengthsToBind.add(i);\n-        }\n-        List<MemoryLayout> memoryLayouts = new ArrayList<>();\n-        field.collectLayouts(memoryLayouts,lengthsToBind);\n-        return (GroupLayout) memoryLayouts.getFirst().withName(iface.getSimpleName());\n-    }\n-\n-    static class AccessStyle {\n-        enum Mode {\n-            ROOT(false,false,false,false,false),\n-            PRIMITIVE_GETTER_AND_SETTER(false,true,false,true,true),\n-            PRIMITIVE_GETTER(false,true,false,false,true),\n-            PRIMITIVE_SETTER(false,true,false,true,false),\n-            IFACE_GETTER(false,false,true,false,true),\n-            PRIMITIVE_ARRAY_SETTER(true,true,false,true,false),\n-            PRIMITIVE_ARRAY_GETTER(true,true,false,false,true),\n-            PRIMITIVE_ARRAY_GETTER_AND_SETTER(true,true,false,true,true),\n-            IFACE_ARRAY_GETTER(true, false,true,false,true);\n-            boolean array;\n-            boolean primitive;\n-            boolean iface;\n-            boolean setter;\n-            boolean getter;\n-            Mode(boolean array, boolean primitive, boolean iface, boolean setter, boolean getter) {\n-                this.array=array;\n-                this.primitive=primitive;\n-                this.iface = iface;\n-                this.getter = getter;\n-                this.setter = setter;\n-            }\n-            static Mode of(Method m) {\n-                    Class<?> returnType = m.getReturnType();\n-                    Class<?>[] paramTypes = m.getParameterTypes();\n-                    if (paramTypes.length == 0 && returnType.isInterface()) {\n-                        return IFACE_GETTER;\n-                    }else if (paramTypes.length == 0 &&returnType.isPrimitive()) {\n-                        return PRIMITIVE_GETTER;\n-                    } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-                        return PRIMITIVE_SETTER;\n-                    } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n-                        return IFACE_ARRAY_GETTER;\n-                    } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n-                        return PRIMITIVE_ARRAY_GETTER;\n-                    } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                            paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()){\n-                        return PRIMITIVE_ARRAY_SETTER;\n-                    } else {\n-                        System.out.println(\"skiping \" + m);\n-                        return  null;\n-                    }\n-            }\n-        };\n-        Mode mode;\n-        Class<?> type;\n-        String name;\n-        AccessStyle(Mode mode, Class<?> type, String name) {\n-            this.mode = mode;\n-            this.type = type;\n-            this.name = name;\n-        }\n-        @Override\n-        public String toString() {\n-            return mode.name()+\":\"+type.getSimpleName()+\":\"+name;\n-        }\n-        static Class<?> methodToType(Method m){\n-            Class<?> returnType = m.getReturnType();\n-            Class<?>[] paramTypes = m.getParameterTypes();\n-            if (paramTypes.length == 0 && (returnType.isInterface() || returnType.isPrimitive())) {\n-               return returnType;\n-            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-               return paramTypes[0];\n-            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && (returnType.isInterface()|| returnType.isPrimitive())) {\n-               return returnType;\n-            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()){\n-              return  paramTypes[1];\n-            } else {\n-                System.out.println(\"skipping \" + m);\n-                return null;\n-            }\n-        }\n-\n-        static AccessStyle of(Class<?> iface, String name) {\n-            AccessStyle accessStyle= new AccessStyle(null,null,name);\n-            Arrays.stream(iface.getDeclaredMethods()).filter(m -> m.getName().equals(name)).forEach(m -> {\n-                AccessStyle.Mode mode = AccessStyle.Mode.of(m);\n-                Class<?> type = methodToType(m);\n-                if (accessStyle.type == null){\n-                    accessStyle.type = type;\n-                }else if (!accessStyle.type.equals(type)){\n-                    throw new IllegalStateException(\"type mismatch for \"+name);\n-                }\n-                if (accessStyle.mode == null){\n-                    accessStyle.mode = mode;\n-                }else  if (\n-                        (accessStyle.mode == Mode.PRIMITIVE_ARRAY_GETTER && mode == Mode.PRIMITIVE_ARRAY_SETTER)\n-                       || (accessStyle.mode == Mode.PRIMITIVE_ARRAY_SETTER && mode == Mode.PRIMITIVE_ARRAY_GETTER)\n-                ){\n-                    accessStyle.mode = Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER;\n-                } else  if (\n-                    (accessStyle.mode == Mode.PRIMITIVE_GETTER && mode == Mode.PRIMITIVE_SETTER)\n-                            || (accessStyle.mode == Mode.PRIMITIVE_SETTER && mode == Mode.PRIMITIVE_GETTER)\n-                ) {\n-                    accessStyle.mode = Mode.PRIMITIVE_GETTER_AND_SETTER;\n-                }else {\n-                    throw new IllegalStateException(\"mode mismatch for \"+name);\n-                }\n-                \/*\n-                Class<?> returnType = m.getReturnType();\n-                Class<?>[] paramTypes = m.getParameterTypes();\n-                if (m.getParameterCount() == 0 && returnType.isInterface()) {\n-                    if (accessStyle[0]!=null){\n-                        throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].mode);\n-                    }\n-                    accessStyle[0] = new AccessStyle(Mode.IFACE_GETTER, returnType, name);\n-                }else if (m.getParameterCount() == 0 &&returnType.isPrimitive()) {\n-                    if (accessStyle[0]!=null){\n-                       if (accessStyle[0].mode == Mode.PRIMITIVE_SETTER){\n-                           accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_GETTER_AND_SETTER, returnType, name);\n-                       }else{\n-                           throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].mode);\n-                       }\n-                    }else {\n-                        accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_GETTER, returnType, name);\n-                    }\n-                } else if (m.getParameterCount() == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n-                    if (accessStyle[0]!=null){\n-                        if (accessStyle[0].mode == Mode.PRIMITIVE_GETTER){\n-                            accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_GETTER_AND_SETTER, paramTypes[0], name);\n-                        }else{\n-                            throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].mode);\n-                        }\n-                    }else {\n-                        accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_SETTER, paramTypes[0], name);\n-                    }\n-                } else if (m.getParameterCount() == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n-                    if (accessStyle[0]!=null){\n-                        throw new IllegalStateException(name+\" already dermined to to be \"+accessStyle[0].mode);\n-                    }\n-                    accessStyle[0] = new AccessStyle(Mode.IFACE_ARRAY_GETTER, returnType, name);\n-                } else if (m.getParameterCount() == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n-                    if (accessStyle[0]!=null) {\n-                        if (accessStyle[0].mode == Mode.PRIMITIVE_ARRAY_SETTER) {\n-                            accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER, returnType, name);\n-                        } else {\n-                            throw new IllegalStateException(name + \" already dermined to to be \" + accessStyle[0].mode);\n-                        }\n-                    }else {\n-                        accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_ARRAY_GETTER, returnType, name);\n-                    }\n-                } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n-                        paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()){\n-                    if (accessStyle[0]!=null) {\n-                        if (accessStyle[0].mode == Mode.PRIMITIVE_ARRAY_GETTER) {\n-                            accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER, paramTypes[1], name);\n-                        } else {\n-                            throw new IllegalStateException(name + \" already dermined to to be \" + accessStyle[0].mode);\n-                        }\n-                    }else {\n-                        accessStyle[0] = new AccessStyle(Mode.PRIMITIVE_ARRAY_SETTER, paramTypes[1], name);\n-                    }\n-                } else {\n-                    System.out.println(\"skiping \" + m);\n-                } *\/\n-            });\n-            if (accessStyle.type == null && accessStyle.mode==null) {\n-                accessStyle.type = iface;\n-                accessStyle.name=\"root\";\n-                accessStyle.mode=Mode.ROOT;\n-            }\n-            return accessStyle;\n-        }\n-    }\n-    private static final Map<Class<?>, MemoryLayout> typeToLayout = new HashMap<>();\n-    static {\n-        typeToLayout.put(Integer.TYPE, JAVA_INT);\n-        typeToLayout.put(Float.TYPE, ValueLayout.JAVA_FLOAT);\n-        typeToLayout.put(Long.TYPE, ValueLayout.JAVA_LONG);\n-        typeToLayout.put(Double.TYPE, ValueLayout.JAVA_DOUBLE);\n-        typeToLayout.put(Character.TYPE, ValueLayout.JAVA_CHAR);\n-        typeToLayout.put(Short.TYPE, ValueLayout.JAVA_SHORT);\n-        typeToLayout.put(Byte.TYPE, ValueLayout.JAVA_BYTE);\n-        typeToLayout.put(Boolean.TYPE, ValueLayout.JAVA_BOOLEAN);\n-    }\n-    static boolean isBuffer(Class<?> clazz){\n-        return clazz.isInterface() && Buffer.class.isAssignableFrom(clazz);\n-    }\n-    static boolean isStruct(Class<?> clazz){\n-        return clazz.isInterface() && Buffer.StructChild.class.isAssignableFrom(clazz);\n-    }\n-    static boolean isStructOrBuffer(Class<?> clazz){\n-        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.StructChild.class.isAssignableFrom(clazz));\n-    }\n-    static boolean isUnion(Class<?> clazz){\n-        return  clazz.isInterface() && Buffer.UnionChild.class.isAssignableFrom(clazz);\n-    }\n-    static boolean isMappable(Class<?> clazz){\n-        return  isStruct(clazz)||isBuffer(clazz)||isUnion(clazz);\n-    }\n-\n-    public static abstract class AbstractField {\n-        ParentField parent;\n-\n-        AbstractField(ParentField parent) {\n-            this.parent = parent;\n-        }\n-\n-        public abstract void toText(String indent, Consumer<String> stringConsumer);\n-\n-        public static class Padding extends AbstractField {\n-            int len;\n-            Padding(ParentField parent,  int len) {\n-                super(parent);\n-                this.len = len;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent+\"padding \"+len+\" bytes\");\n-            }\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd){\n-                memoryLayouts.add(MemoryLayout.paddingLayout(len));\n-            }\n-        }\n-        public static class ArrayLen extends AbstractField {\n-            AccessStyle accessStyle;\n-            ArrayLen(ParentField parent,   AccessStyle accessStyle) {\n-                super(parent);\n-                this.accessStyle = accessStyle;\n-            }\n-\n-            @Override\n-            public void toText(String indent,  Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent+\"arrayLen \" +accessStyle);\n-            }\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd){\n-                if (accessStyle.type.isPrimitive()){\n-                    memoryLayouts.add(typeToLayout.get(accessStyle.type).withName(accessStyle.name));\n-                }else {\n-                    \/\/ the type is mapped in the parent.\n-                    throw new IllegalStateException(\"type of arraylen should be int or long\");\n-                }\n-            }\n-        }\n-        public static class Field extends AbstractField {\n-            AccessStyle accessStyle;\n-            Field(ParentField parent, AccessStyle accessStyle) {\n-                super(parent);\n-                this.accessStyle = accessStyle;\n-            }\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent+\"field \" +accessStyle);\n-            }\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd){\n-                if (accessStyle.type.isPrimitive()) {\n-                    memoryLayouts.add(typeToLayout.get(accessStyle.type).withName(accessStyle.name));\n-                }else{\n-                    ParentField layoutContainer = parent.children.stream().filter(c->c instanceof ParentField).map(c->(ParentField)c)\n-                            .filter(p->p.accessStyle.type.equals(accessStyle.type)).findFirst().get();\n-\n-                    layoutContainer.collectLayouts(memoryLayouts,lengthsToAdd, accessStyle.name);\n-                 \/\/  throw new IllegalStateException(\"handle case where type of field is not primitive\");\n-                }\n-            }\n-        }\n-        public static abstract class ParentField extends AbstractField {\n-            List<AbstractField> children = new ArrayList<>();\n-            AccessStyle accessStyle;\n-            ParentField(ParentField parent, AccessStyle accessStyle) {\n-                super(parent);\n-                this.accessStyle = accessStyle;\n-            }\n-            public ParentField struct(String name, Consumer<ParentField> fb) {\n-                var struct = new Struct(this,  AccessStyle.of(accessStyle.type, name));\n-                children.add(struct);\n-                fb.accept(struct);\n-                return this;\n-            }\n-\n-            public ParentField union(String name, Consumer<ParentField> fb) {\n-                var union = new Union(this,  AccessStyle.of(accessStyle.type, name));\n-                children.add(union);\n-                fb.accept(union);\n-                return this;\n-            }\n-\n-            public ParentField field(String name) {\n-                children.add(new Field(this, AccessStyle.of(accessStyle.type,name)));\n-                return this;\n-            }\n-            public ParentField pad(int len) {\n-                children.add(new Padding(this, len));\n-                return this;\n-            }\n-            public ParentField field(String name, Consumer<ParentField>parentFieldConsumer) {\n-                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type,name);\n-                children.add(new Field(this, newAccessStyle));\n-                ParentField field;\n-                if (isStruct(newAccessStyle.type)){\n-                    field = new AbstractField.Struct(this,newAccessStyle);\n-                }else if (isUnion(newAccessStyle.type)) {\n-                    field = new AbstractField.Union(this, newAccessStyle);\n-                }else{\n-                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle.type);\n-                }\n-                parentFieldConsumer.accept(field);\n-                children.add(field);\n-                return this;\n-            }\n-            public ParentField fields(String name1,String name2, Consumer<ParentField>parentFieldConsumer) {\n-                AccessStyle newAccessStyle1 = AccessStyle.of(accessStyle.type,name1);\n-                AccessStyle newAccessStyle2 = AccessStyle.of(accessStyle.type,name2);\n-                children.add(new Field(this, newAccessStyle1));\n-                children.add(new Field(this, newAccessStyle2));\n-\n-                ParentField field;\n-                if (isStruct(newAccessStyle1.type)){\n-                    field = new AbstractField.Struct(this, newAccessStyle1);\n-                }else if (isUnion(newAccessStyle1.type)) {\n-                    field = new AbstractField.Union(this, newAccessStyle2);\n-                }else{\n-                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle2.type);\n-                }\n-                parentFieldConsumer.accept(field);\n-                children.add(field);\n-                return this;\n-            }\n-            public ParentField fields(String ...names) {\n-                for (var name:names){\n-                    field(name);\n-                }\n-                return this;\n-            }\n-\n-            public ParentField array(String name, int len) {\n-                children.add(new FixedArray(this, name, AccessStyle.of(accessStyle.type,name), len));\n-                return this;\n-            }\n-\n-            public static ParentField  createStructOrUnion(ParentField parent, AccessStyle accessStyle){\n-                if (isStruct(accessStyle.type)){\n-                    return new AbstractField.Struct(parent, accessStyle);\n-                }else if (isUnion(accessStyle.type)) {\n-                    return  new AbstractField.Union(parent, accessStyle);\n-                }\n-                    throw new IllegalArgumentException(\"Unsupported array type: \" + accessStyle.type);\n-\n-            }\n-            public ParentField array(String name, int len, Consumer<ParentField> parentFieldConsumer) {\n-                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type,name);\n-                ParentField field = createStructOrUnion(this, newAccessStyle);\n-                parentFieldConsumer.accept(field);\n-                children.add(field);\n-                children.add(new FixedArray(this, name, AccessStyle.of(accessStyle.type,name), len));\n-                return this;\n-            }\n-            private ParentField fieldControlledArray(String name, ArrayLen arrayLen) {\n-                children.add(new FieldControlledArray(this, name,  AccessStyle.of(accessStyle.type,name), arrayLen));\n-                return this;\n-            }\n-\n-            public ParentField fieldControlledArray(String name, String arrayLenFieldName) {\n-                var arrayLen = new ArrayLen(this,  AccessStyle.of(accessStyle.type,arrayLenFieldName));\n-                children.add(arrayLen);\n-                return fieldControlledArray(name, arrayLen);\n-            }\n-\n-\n-            public static class ArrayBuildState {\n-                ParentField parentField;\n-                ArrayLen arrayLenField;\n-\n-                ParentField array(String name) {\n-                    return parentField.fieldControlledArray(name, arrayLenField);\n-                }\n-\n-                ParentField array(String name, Consumer<ParentField> parentFieldConsumer) {\n-                   AccessStyle newAccessStyle = AccessStyle.of(parentField.accessStyle.type,name);\n-                    parentField.fieldControlledArray(name, arrayLenField);\n-                    ParentField field = createStructOrUnion(parentField, newAccessStyle);\n-                    parentFieldConsumer.accept(field);\n-                    parentField.children.add(field);\n-                    return parentField;\n-                }\n-\n-                ArrayBuildState(ParentField parentField, ArrayLen arrayLenField) {\n-                    this.parentField = parentField;\n-                    this.arrayLenField = arrayLenField;\n-                }\n-            }\n-\n-            public ArrayBuildState arrayLen(String arrayLenFieldName) {\n-                var arrayLenField = new ArrayLen(this,  AccessStyle.of(accessStyle.type,arrayLenFieldName));\n-                children.add(arrayLenField);\n-                return new ArrayBuildState(this, arrayLenField);\n-            }\n-\n-            public void flexArray(String name) {\n-                children.add(new FlexArray(this, name, null));\n-            }\n-\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n-\n-                collectLayouts(memoryLayouts,lengthsToBind,null);\n-            }\n-\n-\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind, String name) {\n-                List<MemoryLayout> layouts = new ArrayList<>();\n-                children.forEach(c->{\n-                    if (!(c instanceof ParentField)) {\n-                        c.collectLayouts(layouts, lengthsToBind);\n-                    }\n-                });\n-                MemoryLayout memoryLayout = null;\n-                if (isUnion(accessStyle.type)) {\n-                    memoryLayout =(name != null && !name.isEmpty())\n-                            ? MemoryLayout.unionLayout(layouts.toArray(new MemoryLayout[0])).withName(name)\n-                            :MemoryLayout.unionLayout(layouts.toArray(new MemoryLayout[0]));\n-                }else if (isStructOrBuffer(accessStyle.type)){\n-                    memoryLayout =(name != null && !name.isEmpty())\n-                            ? MemoryLayout.structLayout(layouts.toArray(new MemoryLayout[0])).withName(name)\n-                            :MemoryLayout.structLayout(layouts.toArray(new MemoryLayout[0]));\n-                }else{\n-                    throw new IllegalStateException(\"Oh my \");\n-                }\n-                memoryLayouts.add(memoryLayout);\n-            }\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent);\n-                if (isUnion(accessStyle.type)) {\n-                    stringConsumer.accept(\"union\");\n-                }else if(isStructOrBuffer(accessStyle.type)){\n-                    stringConsumer.accept(\"struct\");\n-                }else{\n-                    throw new IllegalStateException(\"Oh my \");\n-                }\n-                stringConsumer.accept(\" \" + accessStyle + \"{\");\n-                stringConsumer.accept(\"\\n\");\n-                children.forEach(c -> {\n-                    c.toText(indent+\" \", stringConsumer);\n-                    stringConsumer.accept(\"\\n\");\n-                });\n-                 stringConsumer.accept(indent);\n-                stringConsumer.accept(\"}\");\n-            }\n-        }\n-        public static class Struct extends ParentField {\n-            Struct(ParentField parent,  AccessStyle accessStyle) {\n-                super(parent, accessStyle);\n-            }\n-        }\n-\n-        public static class Union extends ParentField {\n-            Union(ParentField parent,  AccessStyle accessStyle) {\n-                super(parent, accessStyle);\n-            }\n-        }\n-\n-        public abstract static class Array extends AbstractField {\n-          String name;\n-           AccessStyle elementAccessStyle;\n-\n-            Array(ParentField parent, String name,  AccessStyle elementAccessStyle) {\n-                super(parent);\n-                this.name = name;\n-                this.elementAccessStyle = elementAccessStyle;\n-            }\n-        }\n-\n-        public static class FixedArray extends Array {\n-            int len;\n-\n-            FixedArray(ParentField parent, String name, AccessStyle elementAccessStyle, int len) {\n-                super(parent, name, elementAccessStyle);\n-                this.len = len;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent+\"array [\" + len + \"]\");\n-            }\n-\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n-                if (elementAccessStyle.type.isPrimitive()) {\n-                    memoryLayouts.add(MemoryLayout.sequenceLayout(len, typeToLayout.get(elementAccessStyle.type)).withName(elementAccessStyle.name));\n-                }else{\n-                    ParentField layoutContainer = parent.children.stream().filter(c->c instanceof ParentField).map(c->(ParentField)c)\n-                            .filter(p->p.accessStyle.type.equals(elementAccessStyle.type)).findFirst().get();\n-\n-                    layoutContainer.collectLayouts(memoryLayouts,lengthsToBind, elementAccessStyle.name);\n-                   \/\/ throw new IllegalStateException(\"handle case where fixed array element type is not primitive\");\n-                }\n-            }\n-        }\n-\n-        public static class FlexArray extends Array {\n-            FlexArray(ParentField parent, String name, AccessStyle elementAccessStyle) {\n-                super(parent, name, elementAccessStyle);\n-            }\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent+\"array [?] \");\n-            }\n-\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n-                if (elementAccessStyle.type.isPrimitive()) {\n-                    memoryLayouts.add(MemoryLayout.sequenceLayout(0, typeToLayout.get(elementAccessStyle.type)).withName(elementAccessStyle.name));\n-                }else{\n-                    throw new IllegalStateException(\"handle case where flex array element type is not primitive\");\n-                }\n-            }\n-        }\n-\n-        public static class FieldControlledArray extends Array {\n-            ArrayLen arrayLen;\n-\n-            FieldControlledArray(ParentField parent, String name, AccessStyle elementAccessStyle, ArrayLen arrayLen) {\n-                super(parent, name, elementAccessStyle);\n-                this.arrayLen = arrayLen;\n-            }\n-\n-            @Override\n-            public void toText(String indent, Consumer<String> stringConsumer) {\n-                stringConsumer.accept(indent+elementAccessStyle.name+\"[\"+elementAccessStyle+\"] where len defined by \" + arrayLen.accessStyle);\n-            }\n-            @Override\n-            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind){\n-                if (elementAccessStyle.type.isPrimitive()) {\n-                    memoryLayouts.add(MemoryLayout.sequenceLayout(lengthsToBind.removeFirst(), typeToLayout.get(elementAccessStyle.type)).withName(elementAccessStyle.name));\n-                }else{\n-                    \/\/ We should find a Struct or Union matching the type in the parent\n-                    ParentField layoutContainer = parent.children.stream().filter(c->c instanceof ParentField).map(c->(ParentField)c)\n-                            .filter(p->p.accessStyle.type.equals(elementAccessStyle.type)).findFirst().get();\n-\n-                    layoutContainer.collectLayouts(memoryLayouts,lengthsToBind, elementAccessStyle.name);\n-                  \/\/  GroupLayout last =  (GroupLayout) memoryLayouts.getLast();\n-                   \/\/ System.out.println(last);\n-                   \/\/ last.withName(elementAccessStyle.name);\n-                   \/\/ System.out.println(last);\n-                }\n-            }\n-        }\n-\n-        abstract void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind);\n-    }\n-\n-\n-    Schema(Class<T> iface, AbstractField.ParentField field) {\n-        this.iface = iface;\n-        this.field = field;\n-    }\n-    static  class BoundSchema<T extends Buffer>{\n-        Schema<T> schema;\n-        MemoryLayout memoryLayout;\n-        int [] boundLengths;\n-        T instance;\n-        BoundSchema(T instance, Schema<T> schema, MemoryLayout memoryLayout, int[] boundLengths) {\n-            this.instance = instance;\n-            this.schema = schema;\n-            this.memoryLayout = memoryLayout;\n-            this.boundLengths = boundLengths;\n-        }\n-    }\n-\n-    BoundSchema<T> allocate(BufferAllocator bufferAllocator, int ...boundLengths){\n-        var layout = layout(boundLengths);\n-        System.out.println(layout);\n-        var segmentMapper = SegmentMapper.of(MethodHandles.lookup(), iface, layout);\n-        return new BoundSchema<T>(bufferAllocator.allocate(segmentMapper), this,layout,boundLengths);\n-    }\n-\n-\n-    public static <T extends Buffer>Schema<T> of(Class<T> iface, Consumer<AbstractField.ParentField> fb) {\n-        AbstractField.ParentField field = null;\n-        if (isBuffer(iface)){\n-            field = new AbstractField.Struct(null, AccessStyle.of(iface,iface.getSimpleName()));\n-        }else {\n-            throw new IllegalStateException(\"must be a Buffer\");\n-        }\n-        fb.accept(field);\n-        return new Schema<T>(iface, field);\n-    }\n-\n-    void toText(Consumer<String> stringConsumer){\n-        field.toText(\"\",stringConsumer);\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Schema.java","additions":0,"deletions":625,"binary":false,"changes":625,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.Schema;\n@@ -33,0 +34,1 @@\n+import hat.buffer.Buffer;\n@@ -52,1 +54,5 @@\n-        BufferedImage nasa1996 = ImageIO.read(ViolaJones.class.getResourceAsStream(\n+        boolean headless = Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"));\n+\n+        String imageName = (args.length>2 && args[1].equals(\"--image\"))?args[2]:System.getProperty(\"image\", \"Nasa1996\");\n+        System.out.println(\"Using image \"+imageName+\".jpg\");\n+        BufferedImage nasa1996 = ImageIO.read(ViolaJones.class.getResourceAsStream(\"\/images\/\"+imageName+\".jpg\"));\n@@ -56,2 +62,2 @@\n-             \"\/images\/Nasa1996.jpg\"\n-        ));\n+        \/\/     \"\/images\/Nasa1996.jpg\"\n+      \/\/  ));\n@@ -65,0 +71,6 @@\n+\n+       var boundSchema = Cascade.schema.allocate(accelerator,haarCascade.featureCount(),haarCascade.stageCount(),haarCascade.treeCount());\n+       var cascade2 = boundSchema.instance;\n+\n+       System.out.println(\"Original   \"+Buffer.getLayout(cascade));\n+        System.out.println(\"Schema     \"+Buffer.getLayout(cascade2));\n@@ -67,0 +79,1 @@\n+        System.out.println(\"result table layout \"+Buffer.getLayout(resultTable));\n@@ -68,1 +81,1 @@\n-        if (!Boolean.getBoolean(\"headless\")){\n+        if (!headless){\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCompute.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import hat.Schema;\n+import hat.buffer.Buffer;\n@@ -45,1 +47,1 @@\n-    interface Feature extends CompleteBuffer{\n+    interface Feature extends StructChild{\n@@ -47,1 +49,1 @@\n-        interface Rect extends CompleteBuffer{\n+        interface Rect extends Buffer.StructChild{\n@@ -78,2 +80,2 @@\n-        interface LinkOrValue extends CompleteBuffer {\n-            interface Anon {\n+        interface LinkOrValue extends  Buffer.StructChild {\n+            interface Anon  extends Buffer.UnionChild{\n@@ -133,1 +135,1 @@\n-    interface Stage extends CompleteBuffer{\n+    interface Stage extends Buffer.StructChild{\n@@ -158,1 +160,1 @@\n-    interface Tree extends CompleteBuffer{\n+    interface Tree extends Buffer.StructChild{\n@@ -272,1 +274,14 @@\n-\n+    Schema<Cascade> schema = Schema.of(Cascade.class, c -> c\n+            .fields(\"width\",\"height\")\n+            .arrayLen(\"featureCount\").array(\"feature\", feature -> feature\n+                    .fields(\"id\",\"threshold\")\n+                    .fields(\"left\",\"right\",linkOrValue->linkOrValue\n+                            .field(\"hasValue\")\n+                            .pad(3)\n+                            .field(\"anon\", anon->anon.fields(\"featureId\",\"value\"))\n+                    )\n+                    .array(\"rect\", 3 , rect->rect.fields(\"x\",\"y\",\"width\",\"height\",\"weight\"))\n+            )\n+            .arrayLen(\"stageCount\").array(\"stage\", stage->stage.fields(\"id\",\"threshold\",\"treeCount\",\"firstTreeId\"))\n+            .arrayLen(\"treeCount\").array(\"tree\",tree->tree.fields(\"id\",\"firstFeatureId\",\"featureCount\"))\n+    );\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Schema;\n@@ -94,0 +95,12 @@\n+\n+    Schema<ResultTable> schema = Schema.of(ResultTable.class, resultTable->resultTable\n+            .atomic(\"atomicResultTableCount\")\n+            .arrayLen(\"length\").array(\"result\", array->array\n+                    .fields(\n+                            \"x\",\n+                            \"y\",\n+                            \"width\",\n+                            \"height\"\n+                    )\n+            )\n+    );\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.Schema;\n@@ -44,2 +45,0 @@\n-\n-\n@@ -201,1 +200,14 @@\n-\n+    Schema<ScaleTable> schema = Schema.of(ScaleTable.class, scaleTable->scaleTable\n+            .field(\"multiScaleAccumulativeRange\")\n+            .arrayLen(\"length\").array(\"scale\", array->array\n+                    .fields(\n+                    \"scaleValue\",\n+                            \"scaledXInc\", \"scaledYInc\",\n+                            \"invArea\",\n+                            \"scaledFeatureWidth\",\"scaledFeatureHeight\",\n+                            \"gridWidth\", \"gridHeight\",\n+                            \"gridSize\",\n+                            \"accumGridSizeMin\", \"accumGridSizeMax\"\n+                    )\n+            )\n+    );\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,663 @@\n+package hat;\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.BufferAllocator;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+public class Schema<T extends Buffer> {\n+    AbstractField.ParentField field;\n+    Class<T> iface;\n+\n+    static class LayoutCollector{\n+        List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+        int[] arrayLengths;\n+        int idx;\n+        LayoutCollector(int[] arrayLength){\n+            this.arrayLengths = arrayLength;\n+        }\n+    }\n+    public GroupLayout layout(int... arrayLengths) {\n+       \/\/ LayoutCollector layoutCollector = new LayoutCollector(arrayLengths);\n+        LinkedList<Integer> lengthsToBind = new LinkedList<>();\n+        for (var i : arrayLengths) {\n+            lengthsToBind.add(i);\n+        }\n+        List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+        field.collectLayouts(memoryLayouts, lengthsToBind);\n+       \/\/ field.collectLayouts(layoutCollector);\n+        return (GroupLayout) memoryLayouts.getFirst().withName(iface.getSimpleName());\n+    }\n+\n+    static class AccessStyle {\n+        enum Mode {\n+            ROOT(false, false, false, false, false),\n+            PRIMITIVE_GETTER_AND_SETTER(false, true, false, true, true),\n+            PRIMITIVE_GETTER(false, true, false, false, true),\n+            PRIMITIVE_SETTER(false, true, false, true, false),\n+            IFACE_GETTER(false, false, true, false, true),\n+            PRIMITIVE_ARRAY_SETTER(true, true, false, true, false),\n+            PRIMITIVE_ARRAY_GETTER(true, true, false, false, true),\n+            PRIMITIVE_ARRAY_GETTER_AND_SETTER(true, true, false, true, true),\n+            IFACE_ARRAY_GETTER(true, false, true, false, true);\n+            boolean array;\n+            boolean primitive;\n+            boolean iface;\n+            boolean setter;\n+            boolean getter;\n+\n+            Mode(boolean array, boolean primitive, boolean iface, boolean setter, boolean getter) {\n+                this.array = array;\n+                this.primitive = primitive;\n+                this.iface = iface;\n+                this.getter = getter;\n+                this.setter = setter;\n+            }\n+\n+            \/**\n+             * From the iface mapper\n+             * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n+             * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n+             * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n+             * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n+             *\n+             * @param m The reflected method\n+             * @return Class represeting the type this method is mapped to\n+             *\/\n+            static Mode of(Method m) {\n+                Class<?> returnType = m.getReturnType();\n+                Class<?>[] paramTypes = m.getParameterTypes();\n+                if (paramTypes.length == 0 && returnType.isInterface()) {\n+                    return IFACE_GETTER;\n+                } else if (paramTypes.length == 0 && returnType.isPrimitive()) {\n+                    return PRIMITIVE_GETTER;\n+                } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                    return PRIMITIVE_SETTER;\n+                } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isInterface()) {\n+                    return IFACE_ARRAY_GETTER;\n+                } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && returnType.isPrimitive()) {\n+                    return PRIMITIVE_ARRAY_GETTER;\n+                } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n+                        paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n+                    return PRIMITIVE_ARRAY_SETTER;\n+                } else {\n+                    System.out.println(\"skiping \" + m);\n+                    return null;\n+                }\n+            }\n+\n+            Mode possiblyPromote(Mode mode) {\n+                if ((this.equals(PRIMITIVE_ARRAY_GETTER) && mode.equals(PRIMITIVE_ARRAY_SETTER))\n+                        || (this.equals(PRIMITIVE_ARRAY_SETTER) && mode.equals(PRIMITIVE_ARRAY_GETTER))) {\n+                    return Mode.PRIMITIVE_ARRAY_GETTER_AND_SETTER;\n+                } else if ((this.equals(PRIMITIVE_GETTER) && mode.equals(Mode.PRIMITIVE_SETTER))\n+                        || (this.equals(PRIMITIVE_SETTER) && mode.equals(Mode.PRIMITIVE_GETTER))) {\n+                    return Mode.PRIMITIVE_GETTER_AND_SETTER;\n+                } else {\n+                    return this;\n+                }\n+            }\n+        }\n+\n+        Mode mode;\n+        Class<?> type;\n+        String name;\n+        List<Method> methods = new ArrayList<>();\n+        AccessStyle(Mode mode, Class<?> type, String name) {\n+            this.mode = mode;\n+            this.type = type;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return mode.name() + \":\" + type.getSimpleName() + \":\" + name;\n+        }\n+\n+        \/**\n+         * From the iface mapper\n+         * T foo()             getter iface|primitive  0 args                  , return T     returnType T\n+         * T foo(long)    arraygetter iface|primitive  arg[0]==long            , return T     returnType T\n+         * void foo(T)            setter       primitive  arg[0]==T               , return void  returnType T\n+         * void foo(long, T) arraysetter       primitive  arg[0]==long, arg[1]==T , return void  returnType T\n+         *\n+         * @param m The reflected method\n+         * @return Class represeting the type this method is mapped to\n+         *\/\n+        static Class<?> methodToType(Method m) {\n+            Class<?> returnType = m.getReturnType();\n+            Class<?>[] paramTypes = m.getParameterTypes();\n+            if (paramTypes.length == 0 && (returnType.isInterface() || returnType.isPrimitive())) {\n+                return returnType;\n+            } else if (paramTypes.length == 1 && paramTypes[0].isPrimitive() && returnType == Void.TYPE) {\n+                return paramTypes[0];\n+            } else if (paramTypes.length == 1 && paramTypes[0] == Long.TYPE && (returnType.isInterface() || returnType.isPrimitive())) {\n+                return returnType;\n+            } else if (returnType == Void.TYPE && paramTypes.length == 2 &&\n+                    paramTypes[0] == Long.TYPE && paramTypes[1].isPrimitive()) {\n+                return paramTypes[1];\n+            } else {\n+                System.out.println(\"skipping \" + m);\n+                return null;\n+            }\n+        }\n+\n+        static AccessStyle of(Class<?> iface, String name) {\n+            AccessStyle accessStyle = new AccessStyle(null, null, name);\n+            var methods = iface.getDeclaredMethods();\n+            Arrays.stream(methods).filter(method -> method.getName().equals(name)).forEach(matchingMethod -> {\n+                AccessStyle.Mode mode = AccessStyle.Mode.of(matchingMethod);\n+                Class<?> type = methodToType(matchingMethod);\n+                accessStyle.methods.add(matchingMethod);\n+                accessStyle.type = type;\n+                if (accessStyle.type == null) {\n+                    accessStyle.type = type;\n+                } else if (!accessStyle.type.equals(type)) {\n+                    throw new IllegalStateException(\"type mismatch for \" + name);\n+                }\n+                \/\/  The enum knows how to promote GETTER to GETTER_AND_SETTER if prev mode was GETTER and this SETTER and vice versa\n+                accessStyle.mode = (accessStyle.mode == null) ? mode : accessStyle.mode.possiblyPromote(mode);\n+            });\n+            if (accessStyle.type == null && accessStyle.mode == null) {\n+                accessStyle.type = iface;\n+                accessStyle.name = \"root\";\n+                accessStyle.mode = Mode.ROOT;\n+            }\n+            return accessStyle;\n+        }\n+    }\n+\n+    static boolean isBuffer(Class<?> clazz) {\n+        return clazz.isInterface() && Buffer.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isStruct(Class<?> clazz) {\n+        return clazz.isInterface() && Buffer.StructChild.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isStructOrBuffer(Class<?> clazz) {\n+        return clazz.isInterface() && (Buffer.class.isAssignableFrom(clazz) || Buffer.StructChild.class.isAssignableFrom(clazz));\n+    }\n+\n+    static boolean isUnion(Class<?> clazz) {\n+        return clazz.isInterface() && Buffer.UnionChild.class.isAssignableFrom(clazz);\n+    }\n+\n+    static boolean isMappable(Class<?> clazz) {\n+        return isStruct(clazz) || isBuffer(clazz) || isUnion(clazz);\n+    }\n+\n+    public static abstract class AbstractField {\n+        ParentField parent;\n+\n+        AbstractField(ParentField parent) {\n+            this.parent = parent;\n+        }\n+\n+        public abstract void toText(String indent, Consumer<String> stringConsumer);\n+\n+        public static class Padding extends AbstractField {\n+            int len;\n+\n+            Padding(ParentField parent, int len) {\n+                super(parent);\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"padding \" + len + \" bytes\");\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd) {\n+                memoryLayouts.add(MemoryLayout.paddingLayout(len));\n+            }\n+        }\n+\n+        \/**\n+         * Get a layout which describes the accessStyle.\n+         *\n+         * If accessStyle holds a primitive (int, float) then just map to JAVA_INT, JAVA_FLOAT value layouts\n+         * Otherwise we look through the parent's children.  Which should include a struct\/union matching the type.\n+         * @param accessStyle\n+         * @param lengthsToBind\n+         * @return\n+         *\/\n+        MemoryLayout getLayout(AccessStyle accessStyle, LinkedList<Integer> lengthsToBind) {\n+            MemoryLayout memoryLayout = null;\n+            if (accessStyle.type == Integer.TYPE) {\n+                memoryLayout = JAVA_INT;\n+            } else if (accessStyle.type == Float.TYPE) {\n+                memoryLayout = JAVA_FLOAT;\n+            } else if (accessStyle.type == Long.TYPE) {\n+                memoryLayout = JAVA_LONG;\n+            } else if (accessStyle.type == Double.TYPE) {\n+                memoryLayout = JAVA_DOUBLE;\n+            } else if (accessStyle.type == Short.TYPE) {\n+                memoryLayout = JAVA_SHORT;\n+            } else if (accessStyle.type == Character.TYPE) {\n+                memoryLayout = JAVA_CHAR;\n+            } else if (accessStyle.type == Byte.TYPE) {\n+                memoryLayout = JAVA_BYTE;\n+            } else if (accessStyle.type == Boolean.TYPE) {\n+                memoryLayout = JAVA_BOOLEAN;\n+            } else {\n+                ParentField o = parent.childFields.stream().filter(c -> c instanceof ParentField).map(c -> (ParentField) c)\n+                        .filter(p -> p.accessStyle.type.equals(accessStyle.type)).findFirst().get();\n+                List<MemoryLayout> layouts = new ArrayList<>();\n+                o.childFields.forEach(c -> {\n+                    if (!(c instanceof AbstractField.ParentField)) {\n+                        c.collectLayouts(layouts, lengthsToBind);\n+                    }\n+                });\n+                MemoryLayout[] childLayoutsAsArray = layouts.toArray(new MemoryLayout[0]);\n+                if (isUnion(o.accessStyle.type)) {\n+                    memoryLayout = MemoryLayout.unionLayout(childLayoutsAsArray);\n+                } else if (isStructOrBuffer(o.accessStyle.type)) {\n+                    memoryLayout = MemoryLayout.structLayout(childLayoutsAsArray);\n+                } else {\n+                    throw new IllegalStateException(\"Recursing through layout collections and came across  \"+o.accessStyle.type);\n+                }\n+            }\n+            return memoryLayout;\n+        }\n+\n+        public static class ArrayLen extends AbstractField {\n+            AccessStyle accessStyle;\n+\n+            ArrayLen(ParentField parent, AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"arrayLen \" + accessStyle);\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToAdd) {\n+                memoryLayouts.add(getLayout(accessStyle, lengthsToAdd).withName(accessStyle.name));\n+            }\n+        }\n+\n+        public static class AtomicField extends AbstractField {\n+            AccessStyle accessStyle;\n+\n+            AtomicField(ParentField parent, AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"atomic \" + accessStyle);\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n+                memoryLayouts.add(getLayout(accessStyle, lengthsToBind).withName(accessStyle.name));\n+            }\n+        }\n+\n+        public static class Field extends AbstractField {\n+            AccessStyle accessStyle;\n+\n+            Field(ParentField parent, AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"field \" + accessStyle);\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n+                MemoryLayout fieldTypeLayout = getLayout(accessStyle, lengthsToBind).withName(accessStyle.name);\n+                memoryLayouts.add(fieldTypeLayout);\n+            }\n+        }\n+\n+        public static abstract class ParentField extends AbstractField {\n+            private List<AbstractField> childFields = new ArrayList<>();\n+            Map<Class<?>,AbstractField> typeMap = new HashMap<>();\n+            AccessStyle accessStyle;\n+            <T extends AbstractField> T addChildField(T child) {\n+                childFields.add(child);\n+                return child;\n+            }\n+            ParentField(ParentField parent, AccessStyle accessStyle) {\n+                super(parent);\n+                this.accessStyle = accessStyle;\n+            }\n+\n+            public ParentField struct(String name, Consumer<ParentField> fb) {\n+                var struct = new Struct(this, AccessStyle.of(accessStyle.type, name));\n+                addChildField(struct);\n+                typeMap.put(accessStyle.type,struct);\n+                fb.accept(struct);\n+                return this;\n+            }\n+\n+            public ParentField union(String name, Consumer<ParentField> fb) {\n+                var union = new Union(this, AccessStyle.of(accessStyle.type, name));\n+                addChildField(union);\n+                typeMap.put(accessStyle.type,union);\n+                fb.accept(union);\n+                return this;\n+            }\n+\n+            public ParentField field(String name) {\n+                addChildField(new Field(this, AccessStyle.of(accessStyle.type, name)));\n+                return this;\n+            }\n+\n+            public ParentField atomic(String name) {\n+                addChildField(new AtomicField(this, AccessStyle.of(accessStyle.type, name)));\n+                return this;\n+            }\n+\n+            public ParentField pad(int len) {\n+                addChildField(new Padding(this, len));\n+                return this;\n+            }\n+\n+            public ParentField field(String name, Consumer<ParentField> parentFieldConsumer) {\n+                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type, name);\n+                addChildField(new Field(this, newAccessStyle));\n+                ParentField field;\n+                if (isStruct(newAccessStyle.type)) {\n+                    field = new AbstractField.Struct(this, newAccessStyle);\n+                } else if (isUnion(newAccessStyle.type)) {\n+                    field = new AbstractField.Union(this, newAccessStyle);\n+                } else {\n+                    throw new IllegalArgumentException(\"Unsupported field type: \" + newAccessStyle.type);\n+                }\n+                parentFieldConsumer.accept(field);\n+                addChildField(field);\n+                typeMap.put(newAccessStyle.type,field);\n+                return this;\n+            }\n+\n+            public ParentField fields(String name1, String name2, Consumer<ParentField> parentFieldConsumer) {\n+                AccessStyle newAccessStyle1 = AccessStyle.of(accessStyle.type, name1);\n+                AccessStyle newAccessStyle2 = AccessStyle.of(accessStyle.type, name2);\n+                addChildField(new Field(this, newAccessStyle1));\n+                addChildField(new Field(this, newAccessStyle2));\n+\n+                ParentField field;\n+                if (isStruct(newAccessStyle1.type)) {\n+                    field = new AbstractField.Struct(this, newAccessStyle1);\n+                } else if (isUnion(newAccessStyle1.type)) {\n+                    field = new AbstractField.Union(this, newAccessStyle2);\n+                } else {\n+                    throw new IllegalArgumentException(\"Unsupported array type: \" + newAccessStyle2.type);\n+                }\n+                parentFieldConsumer.accept(field);\n+                addChildField(field);\n+                return this;\n+            }\n+\n+            public ParentField fields(String... names) {\n+                for (var name : names) {\n+                    field(name);\n+                }\n+                return this;\n+            }\n+\n+            public ParentField array(String name, int len) {\n+                addChildField(new FixedArray(this, name, AccessStyle.of(accessStyle.type, name), len));\n+                return this;\n+            }\n+\n+            public static ParentField createStructOrUnion(ParentField parent, AccessStyle accessStyle) {\n+                if (isStruct(accessStyle.type)) {\n+                    return new AbstractField.Struct(parent, accessStyle);\n+                } else if (isUnion(accessStyle.type)) {\n+                    return new AbstractField.Union(parent, accessStyle);\n+                }\n+                throw new IllegalArgumentException(\"Unsupported array type: \" + accessStyle.type);\n+\n+            }\n+\n+            public ParentField array(String name, int len, Consumer<ParentField> parentFieldConsumer) {\n+                AccessStyle newAccessStyle = AccessStyle.of(accessStyle.type, name);\n+                ParentField field = createStructOrUnion(this, newAccessStyle);\n+                parentFieldConsumer.accept(field);\n+                addChildField(field);\n+                typeMap.put(accessStyle.type,field);\n+                addChildField(new FixedArray(this, name, AccessStyle.of(accessStyle.type, name), len));\n+                return this;\n+            }\n+\n+            private ParentField fieldControlledArray(String name, ArrayLen arrayLen) {\n+                addChildField(new FieldControlledArray(this, name, AccessStyle.of(accessStyle.type, name), arrayLen));\n+                return this;\n+            }\n+\n+\n+            public static class ArrayBuildState {\n+                ParentField parentField;\n+                ArrayLen arrayLenField;\n+\n+                public ParentField array(String name) {\n+                    return parentField.fieldControlledArray(name, arrayLenField);\n+                }\n+\n+                public ParentField array(String name, Consumer<ParentField> parentFieldConsumer) {\n+                    AccessStyle newAccessStyle = AccessStyle.of(parentField.accessStyle.type, name);\n+                    parentField.fieldControlledArray(name, arrayLenField);\n+                    ParentField field = createStructOrUnion(parentField, newAccessStyle);\n+                    parentFieldConsumer.accept(field);\n+                    parentField.addChildField(field);\n+                    parentField.typeMap.put(parentField.accessStyle.type,field);\n+                    return parentField;\n+                }\n+\n+                ArrayBuildState(ParentField parentField, ArrayLen arrayLenField) {\n+                    this.parentField = parentField;\n+                    this.arrayLenField = arrayLenField;\n+                }\n+            }\n+\n+            public ArrayBuildState arrayLen(String arrayLenFieldName) {\n+                var arrayLenField = new ArrayLen(this, AccessStyle.of(accessStyle.type, arrayLenFieldName));\n+                addChildField(arrayLenField);\n+                return new ArrayBuildState(this, arrayLenField);\n+            }\n+\n+            public void flexArray(String name) {\n+                addChildField(new FlexArray(this, name, null));\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n+                List<MemoryLayout> layouts = new ArrayList<>();\n+                childFields.forEach(c -> {\n+                    if (!(c instanceof ParentField)) {\n+                        c.collectLayouts(layouts, lengthsToBind);\n+                    }\n+                });\n+                MemoryLayout memoryLayout = null;\n+                if (isUnion(accessStyle.type)) {\n+                    memoryLayout =MemoryLayout.unionLayout(layouts.toArray(new MemoryLayout[0]));\n+                } else if (isStructOrBuffer(accessStyle.type)) {\n+                    memoryLayout = MemoryLayout.structLayout(layouts.toArray(new MemoryLayout[0]));\n+                } else {\n+                    throw new IllegalStateException(\"Oh my \");\n+                }\n+                memoryLayouts.add(memoryLayout);\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent);\n+                if (isUnion(accessStyle.type)) {\n+                    stringConsumer.accept(\"union\");\n+                } else if (isStructOrBuffer(accessStyle.type)) {\n+                    stringConsumer.accept(\"struct\");\n+                } else {\n+                    throw new IllegalStateException(\"Oh my \");\n+                }\n+                stringConsumer.accept(\" \" + accessStyle + \"{\");\n+                stringConsumer.accept(\"\\n\");\n+                childFields.forEach(c -> {\n+                    c.toText(indent + \" \", stringConsumer);\n+                    stringConsumer.accept(\"\\n\");\n+                });\n+                stringConsumer.accept(indent);\n+                stringConsumer.accept(\"}\");\n+            }\n+        }\n+\n+        public static class Struct extends ParentField {\n+            Struct(ParentField parent, AccessStyle accessStyle) {\n+                super(parent, accessStyle);\n+            }\n+        }\n+\n+        public static class Union extends ParentField {\n+            Union(ParentField parent, AccessStyle accessStyle) {\n+                super(parent, accessStyle);\n+            }\n+        }\n+\n+        public abstract static class Array extends AbstractField {\n+            String name;\n+            AccessStyle elementAccessStyle;\n+\n+            Array(ParentField parent, String name, AccessStyle elementAccessStyle) {\n+                super(parent);\n+                this.name = name;\n+                this.elementAccessStyle = elementAccessStyle;\n+            }\n+\n+\n+        }\n+\n+        public static class FixedArray extends Array {\n+            int len;\n+\n+            FixedArray(ParentField parent, String name, AccessStyle elementAccessStyle, int len) {\n+                super(parent, name, elementAccessStyle);\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"array [\" + len + \"]\");\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n+                MemoryLayout elementLayout = getLayout(elementAccessStyle, lengthsToBind).withName(elementAccessStyle.type.getSimpleName());;\n+                SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(len, elementLayout).withName(elementAccessStyle.name);\n+                memoryLayouts.add(sequenceLayout);\n+            }\n+        }\n+\n+        public static class FlexArray extends Array {\n+            FlexArray(ParentField parent, String name, AccessStyle elementAccessStyle) {\n+                super(parent, name, elementAccessStyle);\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + \"array [?] \");\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n+                MemoryLayout elementLayout = getLayout(elementAccessStyle, lengthsToBind).withName(elementAccessStyle.type.getSimpleName());;\n+                SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(0, elementLayout).withName(elementAccessStyle.name);\n+                memoryLayouts.add(sequenceLayout);\n+            }\n+        }\n+\n+        public static class FieldControlledArray extends Array {\n+            ArrayLen arrayLen;\n+\n+            FieldControlledArray(ParentField parent, String name, AccessStyle elementAccessStyle, ArrayLen arrayLen) {\n+                super(parent, name, elementAccessStyle);\n+                this.arrayLen = arrayLen;\n+            }\n+\n+            @Override\n+            public void toText(String indent, Consumer<String> stringConsumer) {\n+                stringConsumer.accept(indent + elementAccessStyle.name + \"[\" + elementAccessStyle + \"] where len defined by \" + arrayLen.accessStyle);\n+            }\n+\n+            @Override\n+            void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind) {\n+                MemoryLayout elementLayout = getLayout(elementAccessStyle, lengthsToBind).withName(elementAccessStyle.type.getSimpleName());\n+                SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(lengthsToBind.removeFirst(), elementLayout).withName(elementAccessStyle.name);\n+                memoryLayouts.add(sequenceLayout);\n+            }\n+        }\n+     \/\/   abstract void collectLayouts(LayoutCollector layoutCollector);\n+        abstract void collectLayouts(List<MemoryLayout> memoryLayouts, LinkedList<Integer> lengthsToBind);\n+    }\n+\n+\n+    Schema(Class<T> iface, AbstractField.ParentField field) {\n+        this.iface = iface;\n+        this.field = field;\n+    }\n+\n+    public static class BoundSchema<T extends Buffer> {\n+        Schema<T> schema;\n+        MemoryLayout memoryLayout;\n+        int[] boundLengths;\n+        public T instance;\n+\n+        BoundSchema(T instance, Schema<T> schema, MemoryLayout memoryLayout, int[] boundLengths) {\n+            this.instance = instance;\n+            this.schema = schema;\n+            this.memoryLayout = memoryLayout;\n+            this.boundLengths = boundLengths;\n+        }\n+    }\n+\n+    public BoundSchema<T> allocate(BufferAllocator bufferAllocator, int... boundLengths) {\n+        var layout = layout(boundLengths);\n+        var segmentMapper = SegmentMapper.of(MethodHandles.lookup(), iface, layout);\n+        return new BoundSchema<T>(bufferAllocator.allocate(segmentMapper), this, layout, boundLengths);\n+    }\n+\n+\n+    public static <T extends Buffer> Schema<T> of(Class<T> iface, Consumer<AbstractField.ParentField> parentFieldConsumer) {\n+        AccessStyle accessStyle = AccessStyle.of(iface, iface.getSimpleName());\n+        var struct = new AbstractField.Struct(null, accessStyle);\n+        parentFieldConsumer.accept(struct);\n+        return new Schema<>(iface, struct);\n+    }\n+\n+    public void toText(Consumer<String> stringConsumer) {\n+        field.toText(\"\", stringConsumer);\n+    }\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/Schema.java","additions":663,"deletions":0,"binary":false,"changes":663,"status":"added"}]}