{"files":[{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.tools.jdot;\n+import java.util.function.Consumer;\n+\n+public class DotBuilder<T extends DotBuilder<T>> {\n+    Consumer<String> consumer;\n+    T self(){\n+        return (T) this;\n+    }\n+    public DotBuilder(Consumer<String> consumer) {\n+        this.consumer = consumer;\n+    }\n+\n+    public T accept(String s) {\n+        consumer.accept(s);\n+        return self();\n+    }\n+\n+    public T  digraph(String name, Consumer<T> consumer) {\n+        accept(\"strict\").space().accept(\"digraph\").space().accept(name).obrace().nl();\n+        consumer.accept(self());\n+        return nl().cbrace().nl();\n+    }\n+\n+    public T obrace() {\n+        return accept(\"{\");\n+    }\n+\n+    public T cbrace() {\n+        return accept(\"}\");\n+    }\n+\n+    public  T osbrace() {\n+        return accept(\"[\");\n+    }\n+\n+    public T csbrace() {\n+        return accept(\"]\");\n+    }\n+\n+    public T space() {\n+        return accept(\" \");\n+    }\n+\n+    public T nl() {\n+        return accept(\"\\n\");\n+    }\n+\n+    public  T semicolon() {\n+        return accept(\";\");\n+    }\n+\n+    public T equals() {\n+        return accept(\"=\");\n+    }\n+\n+    public T arrow() {\n+        return accept(\"->\");\n+    }\n+\n+    public T nodeShape(String shape) {\n+        return accept(\"node\").space().osbrace().assign(\"shape\", shape).csbrace().semicolon();\n+    }\n+\n+    public T assign(String name, String value) {\n+        return accept(name).equals().dquote(value);\n+    }\n+    public T label(String value) {\n+        return assign(\"label\", value);\n+    }\n+    public T record(String nodeName, String labelValue) {\n+        return node(nodeName, _->sbrace(_->label(labelValue)));\n+    }\n+\n+    T dquote(String s) {\n+        int portIndex= s.indexOf(\":\");\n+        if (portIndex != -1) {\n+            String nodeName = s.substring(0, portIndex);\n+            String port = s.substring( portIndex);\n+            return accept(\"\\\"\").accept(nodeName).accept(\"\\\"\").accept(port);\n+        }else {\n+            return accept(\"\\\"\").accept(s).accept(\"\\\"\");\n+        }\n+    }\n+\n+    public T node(String name, Consumer<T> consumer) {\n+        dquote(name);\n+        consumer.accept(self());\n+        return semicolon().nl();\n+    }\n+\n+    public T edge(String fromNodeName, String toNodeName) {\n+        return dquote(fromNodeName).arrow().dquote(toNodeName).semicolon().nl();\n+    }\n+\n+    public T sbrace(Consumer<T> consumer) {\n+        osbrace();\n+        consumer.accept(self());\n+        return csbrace();\n+    }\n+    public static class StringDotBuilder extends DotBuilder<StringDotBuilder> {\n+            public StringDotBuilder(Consumer<String> consumer) {\n+            super(consumer);\n+        }\n+    }\n+    public static String dotDigraph(String name, Consumer<StringDotBuilder> consumer) {\n+        StringBuilder sb = new StringBuilder();\n+         var db = new StringDotBuilder(sb::append);\n+         db.digraph(name, consumer);\n+         return sb.toString();\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/jdot\/DotBuilder.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,712 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.tools.jdot.ui;\n+\n+import hat.tools.jdot.DotBuilder;\n+import hat.tools.json.Json;\n+import hat.tools.json.JsonArray;\n+import hat.tools.json.JsonNumber;\n+import hat.tools.json.JsonObject;\n+import hat.tools.json.JsonString;\n+import hat.tools.json.JsonValue;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.Shape;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.font.TextAttribute;\n+import java.awt.geom.CubicCurve2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.geom.RectangularShape;\n+import java.awt.geom.RoundRectangle2D;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+public class JDot {\n+    public static final String FloatRegex = \"([0-9]+|[0-9]*\\\\.[0-9]*)\"; \/\/ not completely foolproof but seems to work for  json0 DOT\n+    public static final String FloatPointRegex = FloatRegex + \",\" + FloatRegex;\n+    public static final Pattern RectRegex = Pattern.compile(FloatPointRegex + \",\" + FloatPointRegex);\n+    public static final Pattern PointRegex = Pattern.compile(FloatPointRegex);\n+\n+    public static class JsonQuery {\n+        public static JsonValue query(JsonValue jsonValue, String path) {\n+            return jsonValue instanceof JsonObject jsonObject && jsonObject.members().get(path) instanceof JsonValue v ? v : null;\n+        }\n+\n+        public static String str(JsonValue jsonValue, String path) {\n+            return query(jsonValue, path) instanceof JsonString jsonString ? jsonString.value() : null;\n+        }\n+\n+        public static Number num(JsonValue jsonValue, String path) {\n+            return (query(jsonValue, path) instanceof JsonNumber jsonNumber) ? jsonNumber.toNumber() : null;\n+        }\n+\n+        public static Float floatOr(JsonValue jsonValue, String path, float defaultValue) {\n+            return JsonQuery.num(jsonValue, path) instanceof JsonNumber n ? n.toNumber().floatValue() : defaultValue;\n+        }\n+\n+        public static Float floatStrOr(JsonValue jsonValue, String path, float defaultValue) {\n+            return JsonQuery.str(jsonValue, path) instanceof String s ? Float.parseFloat(s) : defaultValue;\n+        }\n+\n+        public static List<JsonValue> arr(JsonValue jsonValue, String path) {\n+            return (jsonValue instanceof JsonObject jsonObject\n+                    && jsonObject.members().get(path) instanceof JsonArray jsonArray) ? jsonArray.values() : null;\n+        }\n+\n+        public static Number obj(JsonValue jsonValue, String path) {\n+            return (jsonValue instanceof JsonObject jsonObject\n+                    && jsonObject.members().get(path) instanceof JsonNumber jsonNumber) ? jsonNumber.toNumber() : null;\n+        }\n+\n+        public static Color colorOr(JsonValue jsonValue, String path, Color defaultColor) {\n+            return JsonQuery.str(jsonValue, path) instanceof String s ? Color.getColor(s) : defaultColor;\n+        }\n+\n+    }\n+\n+    public interface Label {\n+        String value();\n+    }\n+\n+    public static class SimpleLabel implements Label {\n+        public String value;\n+\n+        @Override\n+        public String value() {\n+            return value;\n+        }\n+\n+        SimpleLabel(String value) {\n+            this.value = value;\n+        }\n+    }\n+\n+\n+    abstract static class Renderable {\n+        final JsonValue jsonValue;\n+        public Color color;\n+        public Color fillColor;\n+        public Color fontColor;\n+        final int id;\n+\n+\n+        public abstract void render(Graphics2D g2d);\n+\n+        Renderable(JsonValue jsonValue) {\n+            this.jsonValue = jsonValue;\n+            this.id = JsonQuery.num(jsonValue, \"_gvid\").intValue();\n+            this.color = JsonQuery.colorOr(jsonValue, \"color\", Color.BLACK);\n+            this.fillColor = JsonQuery.colorOr(jsonValue, \"fillcolor\", Color.WHITE);\n+            this.fontColor = JsonQuery.colorOr(jsonValue, \"fontcolor\", Color.BLACK);\n+        }\n+    }\n+\n+    abstract static class RenderableShape<T extends Shape> extends Renderable {\n+        final String name;\n+        final float width;\n+        final float height;\n+        T shape;\n+\n+        Label label;\n+\n+        RenderableShape(JsonValue jsonValue) {\n+            super(jsonValue);\n+            this.name = JsonQuery.str(jsonValue, \"name\");\n+            \/\/ for reasons inexplicable.  width and height are inches so need to be *72 or *60 ?\n+            this.height = JsonQuery.floatStrOr(jsonValue, \"height\", 0f) * 60;\n+            this.width = JsonQuery.floatStrOr(jsonValue, \"width\", 0f) * 60;\n+        }\n+    }\n+\n+    static class Line extends RenderableShape<Line2D.Float> {\n+        Line(JsonValue jsonValue, Point2D.Float start, Point2D.Float end) {\n+            super(jsonValue);\n+            shape = new Line2D.Float(start, end);\n+        }\n+\n+        public void render(Graphics2D g2d) {\n+            g2d.setColor(color);\n+            g2d.draw(this.shape);\n+        }\n+    }\n+\n+    abstract static class TextBox<T extends RectangularShape> extends RenderableShape<T> {\n+\n+        TextBox(JsonValue jsonValue) {\n+            super(jsonValue);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d) {\n+            g2d.setColor(this.fillColor);\n+            g2d.fill(this.shape);\n+            g2d.setColor(this.color);\n+            g2d.draw(this.shape);\n+            g2d.setColor(this.fontColor);\n+            FontMetrics metrics = g2d.getFontMetrics(g2d.getFont());\n+            float xStr = (float) this.shape.getCenterX() - ((float) metrics.stringWidth(label.value()) \/ 2);\n+            float yStr = (float) this.shape.getCenterY() - ((float) metrics.getHeight() \/ 2) + metrics.getAscent();\n+            g2d.drawString(label.value(), xStr, yStr);\n+        }\n+    }\n+\n+    static class RoundedTextBox extends TextBox<RoundRectangle2D.Float> {\n+        RoundedTextBox(JsonValue jsonValue, List<Point2D.Float> points) {\n+            super(jsonValue); \/\/ we need the name\n+            this.shape = new RoundRectangle2D.Float(\n+                    points.getFirst().x - width \/ 2,\n+                    points.getFirst().y - height \/ 2,\n+                    width, height,\n+                    20,\n+                    20);\n+            this.label = new SimpleLabel(name);\n+        }\n+\n+    }\n+\n+    abstract static class SquareTextBox extends TextBox<Rectangle2D.Float> {\n+        SquareTextBox(JsonValue jsonValue, Point2D.Float[] points, SimpleLabel label) {\n+            super(jsonValue);\n+            this.shape = new Rectangle2D.Float(points[0].x, points[0].y, points[1].x - points[0].x, points[1].y - points[0].y);\n+            this.label = label;\n+        }\n+    }\n+\n+    abstract static class RecordShape<T extends RectangularShape> extends RenderableShape<T> {\n+\n+        \/*\n+                           \" One | Two \"                    [One|Two]\n+                           \" One | Two | Three \"            [One|Two|Three]\n+                           \" One | Two | Three | Four \"     [One|Two|Three|Four]\n+                                                            +---+-------+----+\n+                                                            |   | Two   |    |\n+                           \" One |{ Two | Three }| Four \"   |One+-------+Four+\n+                                                            |   | Three |    |\n+                                                            +---+-------+----+\n+        *\/\n+        private final RecordLabel recordLabel;\n+\n+        public static class RecordLabel implements Label {\n+            public static class Box implements Label {\n+                public static class Port {\n+                    String name = \"\";\n+\n+                    void append(char ch) {\n+                        name += ch;\n+                    }\n+                }\n+\n+                public Box parent;\n+                public boolean v;\n+                public Port port;\n+                private String value;\n+\n+                @Override\n+                public String value() {\n+                    return value;\n+                }\n+\n+                Rectangle2D.Float rect;\n+\n+                public Box(Box parent, boolean v, Rectangle2D.Float rect) {\n+                    this.parent = parent;\n+                    this.v = v;\n+                    this.rect = rect;\n+                    this.value = \"\";\n+                    this.port = null;\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return (v ? \"V\" : \"H\") + \"Box \" + (port == null ? \"\" : \"<\" + port.name + \">\") + value + \" \" +\n+                            \"x1=\" + rect.getMinX() + \" y1=\" + rect.getMinY() + \"x2=\" + rect.getMaxX() + \" y2=\" + rect.getMaxY() + \" w=\" + rect.getWidth() + \" h=\" + rect.getHeight();\n+                }\n+\n+                public void append(char ch) {\n+                    value += ch;\n+                }\n+\n+                public void portAppend(char ch) {\n+                    port.name += ch;\n+                }\n+            }\n+\n+            private final String value;\n+\n+            @Override\n+            public String value() {\n+                return value;\n+            }\n+\n+            List<Box> boxes = new ArrayList<>();\n+\n+            RecordLabel(String value,\n+                        List<Rectangle2D.Float> rects) {\n+                this.value = value;\n+                \/\/ this.points = points;\n+                int boxIdx = 0;\n+\n+                \/*\n+                 *  <name> port\n+                 *  | is  used to separate record 'boxes'\n+                 *                            +---------------------+\n+                 *  |here|there|everywhere -> |here|there|everywhere|\n+                 *                            +---------------------+\n+                 *  {} used (with bar) to change dir\n+                 *                            +---------------+\n+                 *                            |    |there     |\n+                 *  |here|{there|everywhere}  |here+----------+\n+                 *                            |    |everywhere|\n+                 *                            +---------------+\n+                 *\/\n+\n+                int len = value.length();\n+                enum STATE {\n+                    NORMAL,\n+                    INPORT,\n+                    ESCAPING,\n+                    ERR\n+                }\n+                STATE state = STATE.NORMAL;\n+                boxes.add(new Box(null, false, rects.get(boxIdx++)));\n+                boolean v = false;\n+                for (int idx = 0; idx < len && state != STATE.ERR; idx++) {\n+                    char ch = value.charAt(idx);\n+\n+                    switch (state) {\n+                        case NORMAL -> {\n+                            switch (ch) {\n+                                case '\\\\' -> state = STATE.ESCAPING;\n+                                case '<' -> {\n+                                    if (boxes.getLast().port == null) {\n+                                        state = STATE.INPORT;\n+                                        boxes.getLast().port = new Box.Port();\n+                                    } else {\n+                                        state = STATE.ERR;\n+                                        System.out.println(\"one port per box!\");\n+                                    }\n+                                }\n+                                case '|' -> {\n+                                    if ((idx + 1 < len) && (value.charAt(idx + 1) == '{')) {\n+                                        v = !v;\n+                                        idx++;\n+                                    }\n+                                    this.boxes.add(new Box(this.boxes.getLast(), v, rects.get(boxIdx++)));\n+                                }\n+                                case '{' -> {\n+                                    v = !v;\n+                                    this.boxes.add(new Box(this.boxes.getLast(), v, rects.get(boxIdx++)));\n+                                }\n+                                case '}' -> v = !v;\n+                                default -> boxes.getLast().append(ch);\n+\n+                            }\n+                        }\n+                        case INPORT -> {\n+                            switch (ch) {\n+                                case '>' -> state = STATE.NORMAL;\n+                                default -> {\n+                                    if (Character.isAlphabetic(ch) || Character.isDigit(ch)) {\n+                                        boxes.getLast().port.append(ch);\n+                                    } else {\n+                                        state = STATE.ERR;\n+                                        System.out.println(\"invalid char '\" + ch + \"' in port\");\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        case ESCAPING -> {\n+                            boxes.getLast().append(ch);\n+                            state = STATE.NORMAL;\n+                        }\n+                    }\n+                }\n+                if (state == STATE.ERR) {\n+                    throw new IllegalStateException(\"err!\");\n+                }\n+            }\n+\n+\n+            @Override\n+            public String toString() {\n+                StringBuilder sb = new StringBuilder();\n+                boxes.forEach(b -> sb.append(\"    \").append(b).append('\\n'));\n+                sb.append(\"}\").append('\\n');\n+                return sb.toString();\n+            }\n+        }\n+\n+        public RecordShape(JsonValue jsonValue, List<Rectangle2D.Float> rects) {\n+            super(jsonValue);\n+            this.recordLabel = new RecordLabel(JsonQuery.str(jsonValue, \"label\"), rects);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d) {\n+            Map<TextAttribute, Object> attributes = new HashMap<>();\n+            \/\/ The Text was too close to the edge of the box, so this hack rescales the font 96% so we can avoid the edges.\n+            var currentFont = g2d.getFont();\n+            attributes.put(TextAttribute.FAMILY, currentFont.getFamily());\n+            attributes.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_SEMIBOLD);\n+            attributes.put(TextAttribute.SIZE, (int) (currentFont.getSize() * .96));\n+            var myFont = Font.getFont(attributes);\n+            g2d.setFont(myFont);\n+            FontMetrics metrics = g2d.getFontMetrics(g2d.getFont());\n+            \/\/ These are the boxes that comprise the record\n+            recordLabel.boxes.forEach(box -> {\n+                g2d.setColor(this.fillColor);\n+                g2d.fill(box.rect);\n+                g2d.setColor(this.color);\n+                g2d.draw(box.rect);\n+                g2d.setColor(this.fontColor);\n+                Rectangle2D stringBounds = metrics.getStringBounds(box.value(), g2d);\n+                g2d.drawString(box.value(), (float) (box.rect.getCenterX() - stringBounds.getCenterX()), (float) (box.rect.getCenterY() - stringBounds.getCenterY()));\n+\n+            });\n+            \/\/g2d.setColor(Color.RED); \/\/useful for debugging\n+            \/\/g2d.fill(this.shape);\n+\n+            \/\/switch back to the original sized font\n+            g2d.setFont(currentFont);\n+        }\n+    }\n+\n+    static Rectangle2D.Float sqRect(List<Point2D.Float> points) {\n+        return new Rectangle2D.Float(points.getFirst().x - 1, points.getFirst().y - 1, 2f, 2f);\n+    }\n+\n+    static RoundRectangle2D.Float roundRect(List<Point2D.Float> points, float radius) {\n+        var sqr = sqRect(points);\n+        return new RoundRectangle2D.Float(sqr.x, sqr.y, sqr.width, sqr.height, radius, radius);\n+    }\n+\n+    static class RoundedRecordShape extends RecordShape<RoundRectangle2D.Float> {\n+        public RoundedRecordShape(JsonValue jsonValue, List<Point2D.Float> points, List<Rectangle2D.Float> rects) {\n+            super(jsonValue, rects);\n+            this.shape = roundRect(points, 20f);\n+        }\n+    }\n+\n+    static class SqRecordShape extends RecordShape<Rectangle2D.Float> {\n+        public SqRecordShape(JsonValue jsonValue, List<Point2D.Float> points, List<Rectangle2D.Float> rects) {\n+            super(jsonValue, rects);\n+            this.shape = sqRect(points);\n+        }\n+    }\n+\n+    static class Curve extends Renderable {\n+        List<Point2D.Float> pos;\n+        List<Shape> shapesToDraw = new ArrayList<>();\n+        List<Shape> tailShapesToFill = new ArrayList<>();\n+        List<Shape> headShapesToFill = new ArrayList<>();\n+        Line2D.Float headLine;\n+        Line2D.Float tailLine;\n+        Path2D.Float tailPath;\n+        long head;\n+        long tail;\n+        float weight;\n+        char posType;\n+\n+        \/*\n+         * From the DOT docs.\n+         * spline = (endp)? (startp)? point (triple)+\n+         * and triple = point point point\n+         * and endp = \"e,%f,%f\"\n+         * and startp = \"s,%f,%f\"\n+         * If a spline has points p₁ p₂ p₃ ... pₙ, (n = 1 (mod 3)), the points correspond to the\n+         * control points of a cubic B-spline from p₁ to pₙ. If startp is given, it touches one node\n+         * of the edge, and the arrowhead goes from p₁ to startp. If startp is not given, p₁ touches a node.\n+         *  Similarly for pₙ and endp.\n+         *\/\n+\n+        public Curve(JsonValue jasonValue, char posType, List<Point2D.Float> pos) {\n+                    \/*\n+                     https:\/\/stackoverflow.com\/questions\/71744148\/graphviz-dot-output-what-are-the-4-6-pos-coordinates-for-an-edge\n+                     https:\/\/forum.graphviz.org\/t\/fun-with-edges\/888\/4\n+                     https:\/\/stackoverflow.com\/questions\/3162645\/convert-a-quadratic-bezier-to-a-cubic-one\n+                     https:\/\/stackoverflow.com\/questions\/65410883\/bezier-curve-forcing-a-curve-of-4-points-to-pass-through-control-points-in-3d\n+                    *\/\n+\n+            super(jasonValue);\n+            this.head = JsonQuery.obj(jsonValue, \"head\").longValue();\n+            this.tail = JsonQuery.obj(jsonValue, \"tail\").longValue();\n+            this.weight = JsonQuery.floatOr(jsonValue, \"weight\", 0f);\n+            this.posType = posType;\n+            this.pos = pos;\n+            if (this.posType == 'e') {\n+                \/*\n+                 * triple = (point point point)\n+                 * curve = (endp\/pos[0])? (startp\/pos[1])? point\/pos[2] triple+\n+                 *\/\n+\n+                this.headLine = new Line2D.Float(pos.get(1).x, pos.get(1).y, pos.get(2).x, pos.get(2).y);\n+\n+                int n = this.pos.size();\n+                for (int posIdx = 1; posIdx < (n - 1); posIdx += 3) {\n+                    this.shapesToDraw.add(\n+                            new CubicCurve2D.Float(\n+                                    this.pos.get(posIdx).x,\n+                                    this.pos.get(posIdx).y,\n+                                    this.pos.get(posIdx + 1).x,\n+                                    this.pos.get(posIdx + 1).y,\n+                                    this.pos.get(posIdx + 2).x,\n+                                    this.pos.get(posIdx + 2).y,\n+                                    this.pos.get(posIdx + 3).x,\n+                                    this.pos.get(posIdx + 3).y));\n+                }\n+                this.tailLine = new Line2D.Float(this.pos.get(n - 1).x, this.pos.get(n - 1).y, this.pos.getFirst().x, this.pos.getFirst().y);\n+                float hypot = (float) Math.hypot(this.tailLine.x1 - this.tailLine.x2, this.tailLine.y1 - this.tailLine.y2);\n+                this.tailPath = new Path2D.Float();\n+                tailPath.moveTo(hypot \/ 2, 0);\n+                tailPath.lineTo(0, hypot);\n+                tailPath.lineTo(-hypot \/ 2, 0);\n+                tailPath.closePath();\n+                this.tailShapesToFill.add(tailPath);\n+            } else {\n+                throw new IllegalStateException(\"no support for \" + posType);\n+            }\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d) {\n+            g2d.setColor(color);\n+            shapesToDraw.forEach(g2d::draw);\n+            \/\/ we create our own g2d copy\n+            \/\/ Translate to the end of the tail\n+            \/\/ Rotate perpendicular to the tail line segment\n+            final Graphics2D tail2d = (Graphics2D) g2d.create();\n+\n+            tail2d.translate(tailLine.x1, tailLine.y1);\n+            tail2d.rotate(-Math.atan2(tailLine.x2 - tailLine.x1, tailLine.y2 - tailLine.y1));\n+            tailShapesToFill.forEach(tail2d::fill);\n+            \/\/ we create our own g2d copy\n+            \/\/ Translate to the end of the head\n+            \/\/ Rotate perpendicular to the head line segment\n+            final Graphics2D head2d = (Graphics2D) g2d.create();\n+            head2d.translate(headLine.x1, headLine.y1);\n+            head2d.rotate(-Math.atan2(headLine.x2 - headLine.x1, headLine.y2 - headLine.y1));\n+            headShapesToFill.forEach(head2d::fill);\n+        }\n+    }\n+\n+\n+    double scale = 1;\n+\n+    public JScrollPane pane;\n+\n+    JComponent viewer;\n+\n+    final JsonValue jsonValue;\n+    final Rectangle2D.Float bounds;\n+\n+\n+    public JDot(JsonValue jsonValue) {\n+        this.jsonValue = jsonValue;\n+        String bb = JsonQuery.str(jsonValue, \"bb\");\n+        this.bounds = RectRegex.matcher(bb) instanceof Matcher m && m.matches() && m.groupCount() == 4\n+                ? new Rectangle2D.Float(Float.parseFloat(m.group(1)), Float.parseFloat(m.group(2)),\n+                Float.parseFloat(m.group(3)), Float.parseFloat(m.group(4)))\n+                : null;\n+\n+        List<Renderable> renderables = new ArrayList<>();\n+\n+\n+        JsonQuery.arr(jsonValue, \"edges\").forEach(edgeJsonValue -> {\n+            var posStr = JsonQuery.str(edgeJsonValue, \"pos\");\n+\n+            var points = Arrays.stream(posStr.substring(2).split(\" \"))\n+                    .map(s -> (PointRegex.matcher(s) instanceof Matcher m && m.matches() && m.groupCount() == 2)\n+                            ? new Point2D.Float(Float.parseFloat(m.group(1)), bounds.height - Float.parseFloat(m.group(2)))\n+                            : null).toList();\n+            var curve = new Curve(edgeJsonValue, posStr.charAt(0), points);\n+            renderables.add(curve);\n+        });\n+        JsonQuery.arr(jsonValue, \"objects\").forEach(objectJsonValue -> {\n+            var shape = JsonQuery.str(objectJsonValue, \"shape\");\n+            var posStr = JsonQuery.str(objectJsonValue, \"pos\");\n+            var points = Arrays.stream(posStr.split(\" \"))\n+                    .map(s -> (PointRegex.matcher(s) instanceof Matcher m && m.matches() && m.groupCount() == 2)\n+                            ? new Point2D.Float(Float.parseFloat(m.group(1)), bounds.height - Float.parseFloat(m.group(2)))\n+                            : null).toList();\n+\n+            if (shape != null && shape.equals(\"record\")) {\n+                var rectString = JsonQuery.str(objectJsonValue, \"rects\").split(\" \");\n+                var recordRects = Arrays.stream(rectString).map(s -> {\n+                    if (RectRegex.matcher(s) instanceof Matcher m && m.matches() && m.groupCount() == 4) {\n+                        var x1 = Float.parseFloat(m.group(1));\n+                        var y1 = bounds.height - Float.parseFloat(m.group(4));\n+                        var x2 = Float.parseFloat(m.group(3));\n+                        var y2 = bounds.height - Float.parseFloat(m.group(2));\n+                        return new Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);\n+                    } else {\n+                        return null;\n+                    }\n+                }).toList();\n+                renderables.add(new RoundedRecordShape(objectJsonValue, points, recordRects));\n+            } else {\n+                renderables.add(new RoundedTextBox(objectJsonValue, points));\n+            }\n+        });\n+\n+        this.viewer =\n+                new JComponent() {\n+                    @Override\n+                    public void paintComponent(Graphics g1d) {\n+                        super.paintComponent(g1d);\n+                        if (g1d instanceof Graphics2D g2d) {\n+                            g2d.scale(scale, scale);\n+                            g2d.setRenderingHints(new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON));\n+                            renderables.forEach(e -> e.render(g2d));\n+                        }\n+                    }\n+                };\n+\n+        viewer.addMouseListener(\n+                new MouseAdapter() {\n+                    @Override\n+                    public void mouseClicked(MouseEvent e) {\n+                        \/\/ System.out.println(e.getPoint());\n+                        \/\/ synchronized (doorBell) {\n+                        \/\/   doorBell.notify();\n+                        \/\/ }\n+                    }\n+                });\n+        viewer.addMouseWheelListener(\n+                e -> {\n+                    scale *= (e.getWheelRotation() < 0) ? 1.01 : 1 \/ 1.01;\n+                    viewer.repaint();\n+                });\n+\n+        this.pane = new JScrollPane(this.viewer);\n+        pane.setPreferredSize(new Dimension((int) (bounds.width * scale), (int) (bounds.height * scale)));\n+    }\n+\n+    static JsonValue dotToJson(Path dotFile) {\n+        final Path dotExecutable =\n+                Stream.of(\n+                                System.getProperty(\"DOT_PATH\"),\n+                                \"\/usr\/bin\/dot\",\n+                                \"\/opt\/homebrew\/bin\/dot\"\n+                        )\n+                        .filter(Objects::nonNull) \/\/ incase we hve no var\n+                        .map(Path::of)\n+                        .filter(Files::isExecutable)\n+                        .findFirst()\n+                        .orElse(null);\n+        try {\n+            Process process = new ProcessBuilder()\n+                    .command(dotExecutable.toString(), \"-Tjson0\", dotFile.toString())\n+                   \/\/ .redirectErrorStream(true)\n+                    .start();\n+\n+            String jsonText = String.join(\"\\n\", new BufferedReader(new InputStreamReader(process.getInputStream())).readAllLines());\n+\n+            process.waitFor();\n+\n+              boolean success = (process.exitValue() == 0);\n+            if (!success) {\n+                throw new RuntimeException(\"DOT  exited with code \" + process.exitValue());\n+            }\n+            return Json.parse(jsonText);\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static JsonValue dotToJson(String dotText) {\n+        try {\n+            Path tmp = Files.createTempFile(\"\", \".dot\");\n+            tmp.toFile().deleteOnExit();\n+            Files.writeString(tmp, dotText);\n+            return dotToJson(tmp);\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public JDot(Path dotFile) {\n+        this(dotToJson(dotFile));\n+    }\n+\n+    public JDot(String dotText) {\n+        this(dotToJson(dotText));\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        SwingUtilities.invokeLater(() -> {\n+            JDot jDot = new JDot(DotBuilder.dotDigraph(\"cmake\",db->db\n+                            .assign(\"rankdir\", \"RL\")\n+                            .nodeShape(\"record\")\n+                            .record(\"backend-ffi-opencl\", \"backend|{ffi|extracted}|opencl\")\n+                            .record(\"backend-ffi-shared\", \"backend|ffi|<in>shared\")\n+                            .record(\"backend-ffi\", \"backend|ffi\")\n+                            .record(\"core\",  \"core\")\n+                            .record(\"cmake-info-opencl\", \"<in>cmake|info|opencl\")\n+                            .edge(\"backend-ffi-opencl\",\"backend-ffi-shared:se\")\n+                            .edge(\"backend-ffi-shared\",\"backend-ffi:n\")\n+                            .edge(\"backend-ffi\",\"core:s\")\n+                            .edge(\"backend-ffi-opencl\",\"cmake-info-opencl:ne\")\n+                    ));\n+            var frame = new JFrame();\n+            frame.setLayout(new BorderLayout());\n+            frame.getContentPane().add(jDot.pane);\n+            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+            frame.pack();\n+            frame.setVisible(true);\n+        });\n+    }\n+\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/jdot\/ui\/JDot.java","additions":712,"deletions":0,"binary":false,"changes":712,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonParser;\n+import hat.tools.json.impl.Utils;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * This class provides static methods for producing and manipulating a {@link JsonValue}.\n+ * <p>\n+ * {@link #parse(String)} and {@link #parse(char[])} produce a {@code JsonValue}\n+ * by parsing data adhering to the JSON syntax defined in RFC 8259.\n+ * <p>\n+ * {@link #toDisplayString(JsonValue)} is a formatter that produces a\n+ * representation of the JSON value suitable for display.\n+ * <p>\n+ * {@link #fromUntyped(Object)} and {@link #toUntyped(JsonValue)} provide a conversion\n+ * between {@code JsonValue} and an untyped object.\n+ *\n+ * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259 RFC 8259: The JavaScript\n+ *      Object Notation (JSON) Data Interchange Format\n+ * @since 99\n+ *\/\n+public final class Json {\n+\n+    \/**\n+     * Parses and creates a {@code JsonValue} from the given JSON document.\n+     * If parsing succeeds, it guarantees that the input document conforms to\n+     * the JSON syntax. If the document contains any JSON Object that has\n+     * duplicate names, a {@code JsonParseException} is thrown.\n+     * <p>\n+     * {@code JsonValue}s created by this method produce their String and underlying\n+     * value representation lazily.\n+     * <p>\n+     * {@code JsonObject}s preserve the order of their members declared in and parsed from\n+     * the JSON document.\n+     *\n+     * @param in the input JSON document as {@code String}. Non-null.\n+     * @throws JsonParseException if the input JSON document does not conform\n+     *      to the JSON document format or a JSON object containing\n+     *      duplicate names is encountered.\n+     * @throws NullPointerException if {@code in} is {@code null}\n+     * @return the parsed {@code JsonValue}\n+     *\/\n+    public static JsonValue parse(String in) {\n+        Objects.requireNonNull(in);\n+        return new JsonParser(in.toCharArray()).parseRoot();\n+    }\n+\n+    \/**\n+     * Parses and creates a {@code JsonValue} from the given JSON document.\n+     * If parsing succeeds, it guarantees that the input document conforms to\n+     * the JSON syntax. If the document contains any JSON Object that has\n+     * duplicate names, a {@code JsonParseException} is thrown.\n+     * <p>\n+     * {@code JsonValue}s created by this method produce their String and underlying\n+     * value representation lazily.\n+     * <p>\n+     * {@code JsonObject}s preserve the order of their members declared in and parsed from\n+     * the JSON document.\n+     *\n+     * @param in the input JSON document as {@code char[]}. Non-null.\n+     * @throws JsonParseException if the input JSON document does not conform\n+     *      to the JSON document format or a JSON object containing\n+     *      duplicate names is encountered.\n+     * @throws NullPointerException if {@code in} is {@code null}\n+     * @return the parsed {@code JsonValue}\n+     *\/\n+    public static JsonValue parse(char[] in) {\n+        Objects.requireNonNull(in);\n+        return new JsonParser(Arrays.copyOf(in, in.length)).parseRoot();\n+    }\n+\n+    \/**\n+     * {@return a {@code JsonValue} created from the given {@code src} object}\n+     * The mapping from an untyped {@code src} object to a {@code JsonValue}\n+     * follows the table below.\n+     * <table class=\"striped\">\n+     * <caption>Untyped to JsonValue mapping<\/caption>\n+     * <thead>\n+     *    <tr>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">Untyped Object<\/th>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">JsonValue<\/th>\n+     *    <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr>\n+     *     <th>{@code List<Object>}<\/th>\n+     *     <th>{@code JsonArray}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Boolean}<\/th>\n+     *     <th>{@code JsonBoolean}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code `null`}<\/th>\n+     *     <th>{@code JsonNull}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Number*}<\/th>\n+     *     <th>{@code JsonNumber}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code Map<String, Object>}<\/th>\n+     *     <th>{@code JsonObject}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code String}<\/th>\n+     *     <th>{@code JsonString}<\/th>\n+     * <\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * <i><sup>*<\/sup>The supported {@code Number} subclasses are: {@code Byte},\n+     * {@code Short}, {@code Integer}, {@code Long}, {@code Float},\n+     * {@code Double}, {@code BigInteger}, and {@code BigDecimal}.<\/i>\n+     *\n+     * <p>If {@code src} is an instance of {@code JsonValue}, it is returned as is.\n+     * If {@code src} contains a circular reference, {@code IllegalArgumentException}\n+     * will be thrown. For example, the following code throws an exception,\n+     * {@snippet lang=java:\n+     *     var map = new HashMap<String, Object>();\n+     *     map.put(\"foo\", false);\n+     *     map.put(\"bar\", map);\n+     *     Json.fromUntyped(map);\n+     * }\n+     *\n+     * @param src the data to produce the {@code JsonValue} from. May be null.\n+     * @throws IllegalArgumentException if {@code src} cannot be converted\n+     *      to {@code JsonValue} or contains a circular reference.\n+     * @see #toUntyped(JsonValue)\n+     *\/\n+    public static JsonValue fromUntyped(Object src) {\n+        return fromUntyped(src, Collections.newSetFromMap(new IdentityHashMap<>()));\n+    }\n+\n+    static JsonValue fromUntyped(Object src, Set<Object> identitySet) {\n+        return switch (src) {\n+            \/\/ Structural: JSON object, JSON array\n+            case Map<?, ?> map -> {\n+                if (!identitySet.add(map)) {\n+                    throw new IllegalArgumentException(\"Circular reference detected\");\n+                }\n+                Map<String, JsonValue> m = LinkedHashMap.newLinkedHashMap(map.size());\n+                for (Map.Entry<?, ?> entry : new LinkedHashMap<>(map).entrySet()) {\n+                    if (!(entry.getKey() instanceof String strKey)) {\n+                        throw new IllegalArgumentException(\"Key is not a String: \" + entry.getKey());\n+                    } else {\n+                        var unescapedKey = Utils.unescape(\n+                                strKey.toCharArray(), 0, strKey.length());\n+                        if (m.containsKey(unescapedKey)) {\n+                            throw new IllegalArgumentException(\n+                                    \"Duplicate member name: '%s'\".formatted(unescapedKey));\n+                        } else {\n+                            m.put(unescapedKey, Json.fromUntyped(entry.getValue(), identitySet));\n+                        }\n+                    }\n+                }\n+                \/\/ Bypasses defensive copy in JsonObject.of(m)\n+                yield Utils.objectOf(m);\n+            }\n+            case List<?> list -> {\n+                if (!identitySet.add(list)) {\n+                    throw new IllegalArgumentException(\"Circular reference detected\");\n+                }\n+                List<JsonValue> l = new ArrayList<>(list.size());\n+                for (Object o : list) {\n+                    l.add(Json.fromUntyped(o, identitySet));\n+                }\n+                \/\/ Bypasses defensive copy in JsonArray.of(l)\n+                yield Utils.arrayOf(l);\n+            }\n+            \/\/ JSON primitives\n+            case String str -> JsonString.of(str);\n+            case Boolean bool -> JsonBoolean.of(bool);\n+            case Byte b -> JsonNumber.of(b);\n+            case Integer i -> JsonNumber.of(i);\n+            case Long l -> JsonNumber.of(l);\n+            case Short s -> JsonNumber.of(s);\n+            case Float f -> JsonNumber.of(f);\n+            case Double d -> JsonNumber.of(d);\n+            case BigInteger bi -> JsonNumber.of(bi);\n+            case BigDecimal bd -> JsonNumber.of(bd);\n+            case null -> JsonNull.of();\n+            \/\/ JsonValue\n+            case JsonValue jv -> jv;\n+            default -> throw new IllegalArgumentException(\"Type not recognized.\");\n+        };\n+    }\n+\n+    \/**\n+     * {@return an {@code Object} created from the given {@code src}\n+     * {@code JsonValue}} The mapping from a {@code JsonValue} to an\n+     * untyped {@code src} object follows the table below.\n+     * <table class=\"striped\">\n+     * <caption>JsonValue to Untyped mapping<\/caption>\n+     * <thead>\n+     *    <tr>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">JsonValue<\/th>\n+     *       <th scope=\"col\" class=\"TableHeadingColor\">Untyped Object<\/th>\n+     *    <\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr>\n+     *     <th>{@code JsonArray}<\/th>\n+     *     <th>{@code List<Object>}(unmodifiable)<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonBoolean}<\/th>\n+     *     <th>{@code Boolean}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonNull}<\/th>\n+     *     <th>{@code `null`}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonNumber}<\/th>\n+     *     <th>{@code Number}<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonObject}<\/th>\n+     *     <th>{@code Map<String, Object>}(unmodifiable)<\/th>\n+     * <\/tr>\n+     * <tr>\n+     *     <th>{@code JsonString}<\/th>\n+     *     <th>{@code String}<\/th>\n+     * <\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * <p>\n+     * A {@code JsonObject} in {@code src} is converted to a {@code Map} whose\n+     * entries occur in the same order as the {@code JsonObject}'s members.\n+     *\n+     * @param src the {@code JsonValue} to convert to untyped. Non-null.\n+     * @throws NullPointerException if {@code src} is {@code null}\n+     * @see #fromUntyped(Object)\n+     *\/\n+    public static Object toUntyped(JsonValue src) {\n+        Objects.requireNonNull(src);\n+        return switch (src) {\n+            case JsonObject jo -> jo.members().entrySet().stream()\n+                    .collect(LinkedHashMap::new, \/\/ to allow `null` value\n+                            (m, e) -> m.put(e.getKey(), Json.toUntyped(e.getValue())),\n+                            HashMap::putAll);\n+            case JsonArray ja -> ja.values().stream()\n+                    .map(Json::toUntyped)\n+                    .toList();\n+            case JsonBoolean jb -> jb.value();\n+            case JsonNull _ -> null;\n+            case JsonNumber n -> n.toNumber();\n+            case JsonString js -> js.value();\n+        };\n+    }\n+\n+    \/**\n+     * {@return the String representation of the given {@code JsonValue} that conforms\n+     * to the JSON syntax} As opposed to the compact output returned by {@link\n+     * JsonValue#toString()}, this method returns a JSON string that is better\n+     * suited for display.\n+     *\n+     * @param value the {@code JsonValue} to create the display string from. Non-null.\n+     * @throws NullPointerException if {@code value} is {@code null}\n+     * @see JsonValue#toString()\n+     *\/\n+    public static String toDisplayString(JsonValue value) {\n+        Objects.requireNonNull(value);\n+        return toDisplayString(value, 0 , false);\n+    }\n+\n+    private static String toDisplayString(JsonValue jv, int indent, boolean isField) {\n+        return switch (jv) {\n+            case JsonObject jo -> toDisplayString(jo, indent, isField);\n+            case JsonArray ja -> toDisplayString(ja, indent, isField);\n+            default -> \" \".repeat(isField ? 1 : indent) + jv;\n+        };\n+    }\n+\n+    private static String toDisplayString(JsonObject jo, int indent, boolean isField) {\n+        var prefix = \" \".repeat(indent);\n+        var s = new StringBuilder(isField ? \" \" : prefix);\n+        if (jo.members().isEmpty()) {\n+            s.append(\"{}\");\n+        } else {\n+            s.append(\"{\\n\");\n+            jo.members().forEach((name, valu) -> {\n+                if (valu instanceof JsonValue val) {\n+                    s.append(prefix)\n+                            .append(\" \".repeat(INDENT))\n+                            .append(\"\\\"\")\n+                            .append(name)\n+                            .append(\"\\\":\")\n+                            .append(Json.toDisplayString(val, indent + INDENT, true))\n+                            .append(\",\\n\");\n+                } else {\n+                    throw new InternalError(\"type mismatch\");\n+                }\n+            });\n+            s.setLength(s.length() - 2); \/\/ trim final comma\n+            s.append(\"\\n\").append(prefix).append(\"}\");\n+        }\n+        return s.toString();\n+    }\n+\n+    private static String toDisplayString(JsonArray ja, int indent, boolean isField) {\n+        var prefix = \" \".repeat(indent);\n+        var s = new StringBuilder(isField ? \" \" : prefix);\n+        if (ja.values().isEmpty()) {\n+            s.append(\"[]\");\n+        } else {\n+            s.append(\"[\\n\");\n+            for (JsonValue v: ja.values()) {\n+                if (v instanceof JsonValue jv) {\n+                    s.append(Json.toDisplayString(jv,indent + INDENT, false)).append(\",\\n\");\n+                } else {\n+                    throw new InternalError(\"type mismatch\");\n+                }\n+            }\n+            s.setLength(s.length() - 2); \/\/ trim final comma\/newline\n+            s.append(\"\\n\").append(prefix).append(\"]\");\n+        }\n+        return s.toString();\n+    }\n+\n+    \/\/ default indentation for display string\n+    private static final int INDENT = 2;\n+\n+    \/\/ no instantiation is allowed for this class\n+    private Json() {}\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/Json.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonArrayImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The interface that represents JSON array.\n+ * <p>\n+ * A {@code JsonArray} can be produced by {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(List)} can be used to obtain a {@code JsonArray}.\n+ *\n+ * @since 99\n+ *\/\n+public non-sealed interface JsonArray extends JsonValue {\n+\n+    \/**\n+     * {@return an unmodifiable list of the {@code JsonValue} elements in\n+     * this {@code JsonArray}}\n+     *\/\n+    List<JsonValue> values();\n+\n+    \/**\n+     * {@return the {@code JsonArray} created from the given\n+     * list of {@code JsonValue}s}\n+     *\n+     * @param src the list of {@code JsonValue}s. Non-null.\n+     * @throws NullPointerException if {@code src} is {@code null}, or contains\n+     *      any values that are {@code null}\n+     *\/\n+    static JsonArray of(List<? extends JsonValue> src) {\n+        var values = new ArrayList<JsonValue>(src); \/\/ implicit null check\n+        if (values.contains(null)) {\n+            throw new NullPointerException(\"src contains null value(s)\");\n+        }\n+        return new JsonArrayImpl(values);\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the given object is also a {@code JsonArray}\n+     * and the two {@code JsonArray}s represent the same elements} Two\n+     * {@code JsonArray}s {@code ja1} and {@code ja2} represent the same\n+     * elements if {@code ja1.values().equals(ja2.values())}.\n+     *\n+     * @see #values()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value for this {@code JsonArray}} The hash code of a\n+     * {@code JsonArray} is calculated by {@code Objects.hash(JsonArray.values()}.\n+     * Thus, for two {@code JsonArray}s {@code ja1} and {@code ja2},\n+     * {@code ja1.equals(ja2)} implies that {@code ja1.hashCode() == ja2.hashCode()}\n+     * as required by the general contract of {@link Object#hashCode}.\n+     *\n+     * @see #values()\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonArray.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonBooleanImpl;\n+\n+\/**\n+ * The interface that represents JSON boolean.\n+ * <p>\n+ * A {@code JsonBoolean} can be produced by {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(boolean)} can be used to\n+ * obtain a {@code JsonBoolean}.\n+ *\n+ * @since 99\n+ *\/\n+public non-sealed interface JsonBoolean extends JsonValue {\n+\n+    \/**\n+     * {@return the {@code boolean} value represented by this\n+     * {@code JsonBoolean}}\n+     *\/\n+    boolean value();\n+\n+    \/**\n+     * {@return the {@code JsonBoolean} created from the given\n+     * {@code boolean}}\n+     *\n+     * @param src the given {@code boolean}.\n+     *\/\n+    static JsonBoolean of(boolean src) {\n+        return src ? JsonBooleanImpl.TRUE : JsonBooleanImpl.FALSE;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the given object is also a {@code JsonBoolean}\n+     * and the two {@code JsonBoolean}s represent the same boolean value} Two\n+     * {@code JsonBoolean}s {@code jb1} and {@code jb2} represent the same\n+     * boolean values if {@code jb1.value().equals(jb2.value())}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value for this {@code JsonBoolean}} The hash code value\n+     * of a {@code JsonBoolean} is defined to be the hash code of {@code JsonBoolean}'s\n+     * {@link #value()}. Thus, for two {@code JsonBooleans}s {@code jb1} and {@code jb2},\n+     * {@code jb1.equals(jb2)} implies that {@code jb1.hashCode() == jb2.hashCode()}\n+     * as required by the general contract of {@link Object#hashCode}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonBoolean.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonNullImpl;\n+\n+\/**\n+ * The interface that represents JSON null.\n+ * <p>\n+ * A {@code JsonNull} can be produced by {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of()} can be used to obtain a {@code JsonNull}.\n+ *\n+ * @since 99\n+ *\/\n+public non-sealed interface JsonNull extends JsonValue {\n+\n+    \/**\n+     * {@return the {@code JsonNull} that represents a \"null\" JSON value}\n+     *\/\n+    static JsonNull of() {\n+        return JsonNullImpl.NULL;\n+    }\n+\n+    \/**\n+     * {@return true if the given {@code obj} is a {@code JsonNull}}\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value of this {@code JsonNull}}\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonNull.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonNumberImpl;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+\/**\n+ * The interface that represents JSON number, an arbitrary-precision\n+ * number represented in base 10 using decimal digits.\n+ * <p>\n+ * A {@code JsonNumber} can be produced by {@link Json#parse(String)}.\n+ * Alternatively, {@link #of(double)} and its overloads can be used to obtain\n+ * a {@code JsonNumber} from a {@code Number}.\n+ * When a JSON number is parsed, a {@code JsonNumber} object is created\n+ * as long as the parsed value adheres to the JSON number\n+ * <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6\">\n+ * syntax<\/a>. The value of the {@code JsonNumber}\n+ * can be retrieved from {@link #toString()} as the string representation\n+ * from which the JSON number is originally parsed, with\n+ * {@link #toNumber()} as a {@code Number} instance, or with\n+ * {@link #toBigDecimal()}.\n+ *\n+ * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6 RFC 8259:\n+ *      The JavaScript Object Notation (JSON) Data Interchange Format - Numbers\n+ * @since 99\n+ *\/\n+public non-sealed interface JsonNumber extends JsonValue {\n+\n+    \/**\n+     * {@return the {@code Number} parsed or translated from the\n+     * {@link #toString string representation} of this {@code JsonNumber}}\n+     * <p>\n+     * This method operates on the string representation and depending on that\n+     * representation computes and returns an instance of {@code Long}, {@code BigInteger},\n+     * {@code Double}, or {@code BigDecimal}.\n+     * <p>\n+     * If the string representation is the decimal string representation of\n+     * a {@code long} value, parsable by {@link Long#parseLong(String)},\n+     * then that {@code long} value is returned in its boxed form as {@code Long}.\n+     * Otherwise, if the string representation is the decimal string representation of a\n+     * {@code BigInteger}, translatable by {@link BigInteger#BigInteger(String)},\n+     * then that {@code BigInteger} is returned.\n+     * Otherwise, if the string representation is the decimal string representation of\n+     * a {@code double} value, parsable by {@link Double#parseDouble(String)},\n+     * and the {@code double} value is not {@link Double#isInfinite() infinite}, then that\n+     * {@code double} value is returned in its boxed form as {@code Double}.\n+     * Otherwise, and in all other cases, the string representation is the decimal string\n+     * representation of a {@code BigDecimal}, translatable by\n+     * {@link BigDecimal#BigDecimal(String)}, and that {@code BigDecimal} is\n+     * returned.\n+     * <p>\n+     * The computation may not preserve all information in the string representation.\n+     * In all of the above cases one or more leading zero digits are not preserved.\n+     * In the third case, returning {@code Double}, decimal to binary conversion may lose\n+     * decimal precision, and will not preserve one or more trailing zero digits in the fraction\n+     * part.\n+     *\n+     * @apiNote\n+     * Pattern matching can be used to match against {@code Long},\n+     * {@code Double}, {@code BigInteger}, or {@code BigDecimal} reference\n+     * types. For example:\n+     * {@snippet lang=java:\n+     * switch(jsonNumber.toNumber()) {\n+     *     case Long l -> { ... }\n+     *     case Double d -> { ... }\n+     *     case BigInteger bi -> { ... }\n+     *     case BigDecimal bd -> { ... }\n+     *     default -> { } \/\/ should not happen\n+     * }\n+     *}\n+     * @throws NumberFormatException if the {@code Number} cannot be parsed or translated from the string representation\n+     * @see #toBigDecimal()\n+     * @see #toString()\n+     *\/\n+    Number toNumber();\n+\n+    \/**\n+     * {@return the {@code BigDecimal} translated from the\n+     * {@link #toString string representation} of this {@code JsonNumber}}\n+     * <p>\n+     * The string representation is the decimal string representation of a\n+     * {@code BigDecimal}, translatable by {@link BigDecimal#BigDecimal(String)},\n+     * and that {@code BigDecimal} is returned.\n+     * <p>\n+     * The translation may not preserve all information in the string representation.\n+     * The sign is not preserved for the decimal string representation {@code -0.0}. One or more\n+     * leading zero digits are not preserved.\n+     *\n+     * @throws NumberFormatException if the {@code BigDecimal} cannot be translated from the string representation\n+     *\/\n+    BigDecimal toBigDecimal();\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * decimal string representation of the given {@code double} value,\n+     * produced by applying the value to {@link Double#toString(double)}.\n+     *\n+     * @param num the given {@code double} value.\n+     * @return a JSON number created from a {@code double} value\n+     * @throws IllegalArgumentException if the given {@code double} value\n+     * is {@link Double#isNaN() NaN} or is {@link Double#isInfinite() infinite}.\n+     *\/\n+    static JsonNumber of(double num) {\n+        \/\/ non-integral types\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * decimal string representation of the given {@code long} value,\n+     * produced by applying the value to {@link Long#toString(long)}.\n+     *\n+     * @param num the given {@code long} value.\n+     * @return a JSON number created from a {@code long} value\n+     *\/\n+    static JsonNumber of(long num) {\n+        \/\/ integral types\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * string representation of the given {@code BigInteger} value.\n+     *\n+     * @param num the given {@code BigInteger} value.\n+     * @return a JSON number created from a {@code BigInteger} value\n+     *\/\n+    static JsonNumber of(BigInteger num) {\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * Creates a JSON number whose string representation is the\n+     * string representation of the given {@code BigDecimal} value.\n+     *\n+     * @param num the given {@code BigDecimal} value.\n+     * @return a JSON number created from a {@code BigDecimal} value\n+     *\/\n+    static JsonNumber of(BigDecimal num) {\n+        return new JsonNumberImpl(num);\n+    }\n+\n+    \/**\n+     * {@return the decimal string representation of this {@code JsonNumber}}\n+     *\n+     * If this {@code JsonNumber} is created by parsing a JSON number in a JSON document,\n+     * it preserves the string representation in the document, regardless of its\n+     * precision or range. For example, a JSON number like\n+     * {@code 3.141592653589793238462643383279} in the JSON document will be\n+     * returned exactly as it appears.\n+     * If this {@code JsonNumber} is created via one of the factory methods,\n+     * such as {@link JsonNumber#of(double)}, then the string representation is\n+     * specified by the factory method.\n+     *\/\n+    @Override\n+    String toString();\n+\n+    \/**\n+     * {@return true if the given {@code obj} is equal to this {@code JsonNumber}}\n+     * The comparison is based on the string representation of this {@code JsonNumber},\n+     * ignoring the case.\n+     *\n+     * @see #toString()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value of this {@code JsonNumber}} The returned hash code\n+     * is calculated based on the string representation of this {@code JsonNumber},\n+     * ignoring the case.\n+     *\n+     * @see #toString()\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonNumber.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonObjectImpl;\n+import hat.tools.json.impl.Utils;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * The interface that represents JSON object.\n+ * <p>\n+ * A {@code JsonObject} can be produced by a {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(Map)} can be used to obtain a {@code JsonObject}.\n+ * Implementations of {@code JsonObject} cannot be created from sources that\n+ * contain duplicate member names. If duplicate names appear during\n+ * a {@link Json#parse(String)}, a {@code JsonParseException} is thrown.\n+ *\n+ * @since 99\n+ *\/\n+public non-sealed interface JsonObject extends JsonValue {\n+\n+    \/**\n+     * {@return an unmodifiable map of the {@code String} to {@code JsonValue}\n+     * members in this {@code JsonObject}}\n+     *\/\n+    Map<String, JsonValue> members();\n+\n+    \/**\n+     * {@return the {@code JsonObject} created from the given\n+     * map of {@code String} to {@code JsonValue}s}\n+     *\n+     * The {@code JsonObject}'s members occur in the same order as the given\n+     * map's entries.\n+     * <p>\n+     * If a key in the provided {@code map} contains escape characters, they are\n+     * unescaped before being added to the resulting {@code JsonObject}. If multiple\n+     * keys unescape to the same value, an {@code IllegalArgumentException} is thrown.\n+     *\n+     * @param map the map of {@code JsonValue}s. Non-null.\n+     * @throws IllegalArgumentException if {@code map} contains multiple keys\n+     *      that unescape to the same value\n+     * @throws NullPointerException if {@code map} is {@code null}, contains\n+     *      any keys that are {@code null}, or contains any values that are {@code null}\n+     *\/\n+    static JsonObject of(Map<String, ? extends JsonValue> map) {\n+        Map<String, JsonValue> ret = new LinkedHashMap<>(map.size()); \/\/ implicit NPE on map\n+        for (var e : map.entrySet()) {\n+            var key = e.getKey();\n+            \/\/ Implicit NPE on key\n+            var unescapedKey = Utils.unescape(key.toCharArray(), 0, key.length());\n+            var val = e.getValue();\n+            if (ret.containsKey(unescapedKey)) {\n+                throw new IllegalArgumentException(\n+                        \"Multiple keys unescape to the same value: '%s'\".formatted(unescapedKey));\n+            } else {\n+                ret.put(unescapedKey, Objects.requireNonNull(val));\n+            }\n+        }\n+        return new JsonObjectImpl(ret);\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the given object is also a {@code JsonObject}\n+     * and the two {@code JsonObject}s represent the same mappings} Two\n+     * {@code JsonObject}s {@code jo1} and {@code jo2} represent the same\n+     * mappings if {@code jo1.members().equals(jo2.members())}.\n+     *\n+     * @see #members()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value for this {@code JsonObject}} The hash code value\n+     * of a {@code JsonObject} is defined to be the hash code of {@code JsonObject}'s\n+     * {@link #members()} value. Thus, for two {@code JsonObject}s {@code jo1} and {@code jo2},\n+     * {@code jo1.equals(jo2)} implies that {@code jo1.hashCode() == jo2.hashCode()}\n+     * as required by the general contract of {@link Object#hashCode}.\n+     *\n+     * @see #members()\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonObject.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+import java.io.Serial;\n+\n+\/**\n+ * Signals that an error has been detected while parsing the\n+ * JSON document.\n+ *\n+ * @since 99\n+ *\/\n+public class JsonParseException extends RuntimeException {\n+\n+    @Serial\n+    private static final long serialVersionUID = 7022545379651073390L;\n+\n+    \/**\n+     * Position of the error row in the document\n+     * @serial\n+     *\/\n+    private final int row;\n+\n+    \/**\n+     * Position of the error column in the document\n+     * @serial\n+     *\/\n+    private final int col;\n+\n+    \/**\n+     * Constructs a JsonParseException with the specified detail message.\n+     * @param message the detail message\n+     * @param row the row of the error on parsing the document\n+     * @param col the column of the error on parsing the document\n+     *\/\n+    public JsonParseException(String message, int row, int col) {\n+        super(message);\n+        this.row = row;\n+        this.col = col;\n+    }\n+\n+    \/**\n+     * {@return the row of the error on parsing the document}\n+     *\/\n+    public int getErrorRow() {\n+        return row;\n+    }\n+\n+    \/**\n+     * {@return the column of the error on parsing the document}\n+     *\/\n+    public int getErrorColumn() {\n+        return col;\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonParseException.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\n+import hat.tools.json.impl.JsonStringImpl;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * The interface that represents JSON string. Any character may be escaped,\n+ * see the JSON string <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6\">\n+ * syntax<\/a> for the full list of two-character sequence escapes as well as\n+ * the characters that must be escaped.\n+ * <p>\n+ * A {@code JsonString} can be produced by a {@link Json#parse(String)}.\n+ * <p> Alternatively, {@link #of(String)} can be used to obtain a {@code JsonString}\n+ * from a {@code String}.\n+ *\n+ * @spec https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-7 RFC 8259:\n+ *      The JavaScript Object Notation (JSON) Data Interchange Format - Strings\n+ * @since 99\n+ *\/\n+public non-sealed interface JsonString extends JsonValue {\n+\n+    \/**\n+     * {@return the {@code JsonString} created from the given\n+     * {@code String}}\n+     *\n+     * @param src the given {@code String}. Non-null.\n+     * @throws IllegalArgumentException if the given {@code src} is\n+     *          not a valid JSON string.\n+     * @throws NullPointerException if {@code src} is {@code null}\n+     *\/\n+    static JsonString of(String src) {\n+        Objects.requireNonNull(src);\n+        return new JsonStringImpl(src);\n+    }\n+\n+    \/**\n+     * {@return the {@code String} value represented by this {@code JsonString}}\n+     * Any escaped characters in the original JSON string are converted to their\n+     * unescaped form in the returned {@code String}.\n+     *\n+     * @see #toString()\n+     *\/\n+    String value();\n+\n+    \/**\n+     * {@return the {@code String} value represented by this {@code JsonString}\n+     * surrounded by quotation marks} Any escaped characters in the original JSON\n+     * string are converted to their unescaped form in the returned {@code String}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    String toString();\n+\n+    \/**\n+     * {@return true if the given {@code obj} is equal to this {@code JsonString}}\n+     * Two {@code JsonString}s {@code js1} and {@code js2} represent the same value\n+     * if {@code js1.value().equals(js2.value())}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the hash code value of this {@code JsonString}} The hash code of a\n+     * {@code JsonString} is calculated by {@code Objects.hash(JsonString.value())}.\n+     *\n+     * @see #value()\n+     *\/\n+    @Override\n+    int hashCode();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonString.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json;\n+\n+\/**\n+ * The interface that represents a JSON value.\n+ * <p>\n+ * Instances of {@code JsonValue} are immutable and thread safe.\n+ * <p>\n+ * A {@code JsonValue} can be produced by {@link Json#parse(String)} or {@link\n+ * Json#fromUntyped(Object)}. See {@link #toString()}  for converting a {@code\n+ * JsonValue} to its corresponding JSON String. For example,\n+ * {@snippet lang=java:\n+ *     List<Object> values = Arrays.asList(\"foo\", true, 25);\n+ *     JsonValue json = Json.fromUntyped(values);\n+ *     json.toString(); \/\/ returns \"[\\\"foo\\\",true,25]\"\n+ * }\n+ *\n+ * A class implementing a non-sealed {@code JsonValue} sub-interface must adhere\n+ * to the following:\n+ * <ul>\n+ * <li>The class's implementations of {@code equals}, {@code hashCode},\n+ * and {@code toString} compute their results solely from the values\n+ * of the class's instance fields (and the members of the objects they\n+ * reference), not from the instance's identity.<\/li>\n+ * <li>The class's methods treat instances as <em>freely substitutable<\/em>\n+ * when equal, meaning that interchanging any two instances {@code x} and\n+ * {@code y} that are equal according to {@code equals()} produces no\n+ * visible change in the behavior of the class's methods.<\/li>\n+ * <li>The class performs no synchronization using an instance's monitor.<\/li>\n+ * <li>The class does not provide any instance creation mechanism that promises\n+ * a unique identity on each method call&mdash;in particular, any factory\n+ * method's contract must allow for the possibility that if two independently-produced\n+ * instances are equal according to {@code equals()}, they may also be\n+ * equal according to {@code ==}.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Users of {@code JsonValue} instances should ensure the following:\n+ * <ul>\n+ * <li> When two instances of {@code JsonValue} are equal (according to {@code equals()}), users\n+ * should not attempt to distinguish between their identities, whether directly via reference\n+ * equality or indirectly via an appeal to synchronization, identity hashing,\n+ * serialization, or any other identity-sensitive mechanism.<\/li>\n+ * <li> Synchronization on instances of {@code JsonValue} is strongly discouraged,\n+ * because the programmer cannot guarantee exclusive ownership of the\n+ * associated monitor.<\/li>\n+ * <\/ul>\n+ *\n+ * @since 99\n+ *\/\n+public sealed interface JsonValue\n+        permits JsonString, JsonNumber, JsonObject, JsonArray, JsonBoolean, JsonNull {\n+\n+    \/**\n+     * {@return the String representation of this {@code JsonValue} that conforms\n+     * to the JSON syntax} If this {@code JsonValue} is created by parsing a\n+     * JSON document, it preserves the text representation of the corresponding\n+     * JSON element, except that the returned string does not contain any white\n+     * spaces or newlines to produce a compact representation.\n+     * For a String representation suitable for display, use\n+     * {@link Json#toDisplayString(JsonValue)}.\n+     *\n+     * @see Json#toDisplayString(JsonValue)\n+     *\/\n+    String toString();\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/JsonValue.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonArray;\n+import hat.tools.json.JsonValue;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * JsonArray implementation class\n+ *\/\n+public final class JsonArrayImpl implements JsonArray {\n+\n+    private final List<JsonValue> theValues;\n+\n+    public JsonArrayImpl(List<JsonValue> from) {\n+        theValues = from;\n+    }\n+\n+    @Override\n+    public List<JsonValue> values() {\n+        return Collections.unmodifiableList(theValues);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var s = new StringBuilder(\"[\");\n+        for (JsonValue v: values()) {\n+            s.append(v.toString()).append(\",\");\n+        }\n+        if (!values().isEmpty()) {\n+            s.setLength(s.length() - 1); \/\/ trim final comma\n+        }\n+        return s.append(\"]\").toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonArray oja &&\n+                Objects.equals(values(), oja.values());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(values());\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonArrayImpl.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonBoolean;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonBoolean implementation class\n+ *\/\n+public final class JsonBooleanImpl implements JsonBoolean {\n+\n+    private final Boolean theBoolean;\n+\n+    public static final JsonBooleanImpl TRUE = new JsonBooleanImpl(true);\n+    public static final JsonBooleanImpl FALSE = new JsonBooleanImpl(false);\n+\n+    private JsonBooleanImpl(Boolean bool) {\n+        theBoolean = bool;\n+    }\n+\n+    @Override\n+    public boolean value() {\n+        return theBoolean;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value());\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonBoolean ojb &&\n+                Objects.equals(value(), ojb.value());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value());\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonBooleanImpl.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonNull;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonNull implementation class\n+ *\/\n+public final class JsonNullImpl implements JsonNull {\n+\n+    public static final JsonNullImpl NULL = new JsonNullImpl();\n+    private static final String VALUE = \"null\";\n+    private static final int HASH = Objects.hash(VALUE);\n+\n+    private JsonNullImpl() {}\n+\n+    @Override\n+    public String toString() {\n+        return VALUE;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj instanceof JsonNull;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return HASH;\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonNullImpl.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonNumber;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Locale;\n+\n+\/**\n+ * JsonNumber implementation class\n+ *\/\n+public final class JsonNumberImpl implements JsonNumber {\n+\n+    private final char[] doc;\n+    private final int startOffset;\n+    private final int endOffset;\n+    private Number theNumber;\n+\n+    public JsonNumberImpl(Number num) {\n+        if (num == null ||\n+            num instanceof Double d && (d.isNaN() || d.isInfinite())) {\n+            throw new IllegalArgumentException(\"Not a valid JSON number\");\n+        }\n+        theNumber = num;\n+        \/\/ unused\n+        startOffset = -1;\n+        endOffset = -1;\n+        doc = null;\n+    }\n+\n+    public JsonNumberImpl(char[] doc, int start, int end) {\n+        this.doc = doc;\n+        startOffset = start;\n+        endOffset = end;\n+    }\n+\n+    @Override\n+    public Number toNumber() {\n+        var n = theNumber;\n+        if (n == null) {\n+            n = theNumber = computeNumber();\n+        }\n+        return n;\n+    }\n+\n+    private Number computeNumber() {\n+        var str = toString();\n+        \/\/ Check if integral (Java literal format)\n+        boolean integerOnly = true;\n+        for (int index = 0; index < str.length(); index++) {\n+            char c = str.charAt(index);\n+            if (c == '.' || c == 'e' || c == 'E') {\n+                integerOnly = false;\n+                break;\n+            }\n+        }\n+        if (integerOnly) {\n+            try {\n+                return Long.parseLong(str);\n+            } catch (NumberFormatException _) {\n+                return new BigInteger(str);\n+            }\n+        } else {\n+            var db = Double.parseDouble(str);\n+            if (Double.isInfinite(db)) {\n+                return toBigDecimal();\n+            } else {\n+                return db;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal toBigDecimal() {\n+        return new BigDecimal(toString());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(doc, startOffset, endOffset - startOffset);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonNumber ojn &&\n+                toString().compareToIgnoreCase(ojn.toString()) == 0;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return toString().toLowerCase(Locale.ROOT).hashCode();\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonNumberImpl.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonObject;\n+import hat.tools.json.JsonValue;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * JsonObject implementation class\n+ *\/\n+public final class JsonObjectImpl implements JsonObject {\n+\n+    private final Map<String, JsonValue> theMembers;\n+\n+    public JsonObjectImpl(Map<String, JsonValue> map) {\n+        theMembers = map;\n+    }\n+\n+    @Override\n+    public Map<String, JsonValue> members() {\n+        return Collections.unmodifiableMap(theMembers);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var s = new StringBuilder(\"{\");\n+        for (Map.Entry<String, JsonValue> kv: members().entrySet()) {\n+            s.append(\"\\\"\").append(kv.getKey()).append(\"\\\":\")\n+             .append(kv.getValue().toString())\n+             .append(\",\");\n+        }\n+        if (!members().isEmpty()) {\n+            s.setLength(s.length() - 1); \/\/ trim final comma\n+        }\n+        return s.append(\"}\").toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonObject ojo &&\n+                Objects.equals(members(), ojo.members());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(members());\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonObjectImpl.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,485 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonArray;\n+import hat.tools.json.JsonObject;\n+import hat.tools.json.JsonParseException;\n+import hat.tools.json.JsonString;\n+import hat.tools.json.JsonValue;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+\/**\n+ * Parses a JSON Document char[] into a tree of JsonValues. JsonObject and JsonArray\n+ * nodes create their data structures which maintain the connection to children.\n+ * JsonNumber and JsonString contain only a start and end offset, which\n+ * are used to lazily procure their underlying value\/string on demand. Singletons\n+ * are used for JsonBoolean and JsonNull.\n+ *\/\n+public final class JsonParser {\n+\n+    \/\/ Access to the underlying JSON contents\n+    private final char[] doc;\n+    \/\/ Current offset during parsing\n+    private int offset;\n+    \/\/ For exception message on failure\n+    private int line;\n+    private int lineStart;\n+    private StringBuilder builder;\n+\n+    public JsonParser(char[] doc) {\n+        this.doc = doc;\n+    }\n+\n+    \/\/ Parses the lone JsonValue root\n+    public JsonValue parseRoot() {\n+        JsonValue root = parseValue();\n+        if (hasInput()) {\n+            throw failure(\"Unexpected character(s)\");\n+        }\n+        return root;\n+    }\n+\n+    \/*\n+     * Parse any one of the JSON value types: object, array, number, string,\n+     * true, false, or null.\n+     *      JSON-text = ws value ws\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-3\n+     *\/\n+    private JsonValue parseValue() {\n+        skipWhitespaces();\n+        if (!hasInput()) {\n+            throw failure(\"Missing JSON value\");\n+        }\n+        var val = switch (doc[offset]) {\n+            case '{' -> parseObject();\n+            case '[' -> parseArray();\n+            case '\"' -> parseString();\n+            case 't' -> parseTrue();\n+            case 'f' -> parseFalse();\n+            case 'n' -> parseNull();\n+            \/\/ While JSON Number does not support leading '+', '.', or 'e'\n+            \/\/ we still accept, so that we can provide a better error message\n+            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '+', 'e', '.'\n+                    -> parseNumber();\n+            default -> throw failure(\"Unexpected character(s)\");\n+        };\n+        skipWhitespaces();\n+        return val;\n+    }\n+\n+    \/*\n+     * The parsed JsonObject contains a map which holds all lazy member mappings.\n+     * No offsets are required as member values hold their own offsets.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-4\n+     *\/\n+    private JsonObject parseObject() {\n+        \/\/ @@@ Do not preserve encounter order, requires adjustment to the API\n+\/\/        var members = new LinkedHashMap<String, JsonValue>();\n+        var members = new HashMap<String, JsonValue>();\n+        offset++; \/\/ Walk past the '{'\n+        skipWhitespaces();\n+        \/\/ Check for empty case\n+        if (currCharEquals('}')) {\n+            offset++;\n+            return new JsonObjectImpl(members);\n+        }\n+        while (hasInput()) {\n+            \/\/ Get the member name, which should be unescaped\n+            \/\/ Why not parse the name as a JsonString and then return its value()?\n+            \/\/ Would requires 2 passes; we should build the String as we parse.\n+            var name = parseName();\n+\n+            if (members.containsKey(name)) {\n+                throw failure(\"The duplicate member name: '%s' was already parsed\".formatted(name));\n+            }\n+\n+            \/\/ Move from name to ':'\n+            skipWhitespaces();\n+            if (!currCharEquals(':')) {\n+                throw failure(\n+                        \"Expected ':' after the member name\");\n+            }\n+\n+            \/\/ Move from ':' to JsonValue\n+            offset++;\n+            members.put(name, parseValue());\n+            \/\/ Ensure current char is either ',' or '}'\n+            if (currCharEquals('}')) {\n+                offset++;\n+                return new JsonObjectImpl(members);\n+            } else if (currCharEquals(',')) {\n+                \/\/ Add the comma, and move to the next key\n+                offset++;\n+                skipWhitespaces();\n+            } else {\n+                \/\/ Neither ',' nor '}' so fail\n+                break;\n+            }\n+        }\n+        throw failure(\"Object was not closed with '}'\");\n+    }\n+\n+    \/*\n+     * Member name equality and storage in the map should be done with the\n+     * unescaped String value.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-8.3\n+     *\/\n+    private String parseName() {\n+        if (!currCharEquals('\"')) {\n+            throw failure(\"Invalid member name\");\n+        }\n+        offset++; \/\/ Move past the starting quote\n+        var escape = false;\n+        boolean useBldr = false;\n+        var start = offset;\n+        for (; hasInput(); offset++) {\n+            var c = doc[offset];\n+            if (escape) {\n+                var escapeLength = 0;\n+                switch (c) {\n+                    \/\/ Allowed JSON escapes\n+                    case '\"', '\\\\', '\/' -> {}\n+                    case 'b' -> c = '\\b';\n+                    case 'f' -> c = '\\f';\n+                    case 'n' -> c = '\\n';\n+                    case 'r' -> c = '\\r';\n+                    case 't' -> c = '\\t';\n+                    case 'u' -> {\n+                        if (offset + 4 < doc.length) {\n+                            escapeLength = 4;\n+                            offset++; \/\/ Move to first char in sequence\n+                            c = codeUnit();\n+                            \/\/ Move to the last hex digit, since outer loop will increment offset\n+                            offset += 3;\n+                        } else {\n+                            throw failure(\"Invalid Unicode escape sequence\");\n+                        }\n+                    }\n+                    default -> throw failure(\"Illegal escape\");\n+                }\n+                if (!useBldr) {\n+                    initBuilder();\n+                    \/\/ Append everything up to the first escape sequence\n+                    builder.append(doc, start, offset - escapeLength - 1 - start);\n+                    useBldr = true;\n+                }\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+                continue;\n+            } else if (c == '\\\"') {\n+                offset++;\n+                if (useBldr) {\n+                    var name = builder.toString();\n+                    builder.setLength(0);\n+                    return name;\n+                } else {\n+                    return new String(doc, start, offset - start - 1);\n+                }\n+            } else if (c < ' ') {\n+                throw failure(\"Unescaped control code\");\n+            }\n+            if (useBldr) {\n+                builder.append(c);\n+            }\n+        }\n+        throw failure(\"Closing quote missing\");\n+    }\n+\n+    \/*\n+     * The parsed JsonArray contains a List which holds all lazy children\n+     * elements. No offsets are required as children values hold their own offsets.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-5\n+     *\/\n+    private JsonArray parseArray() {\n+        var list = new ArrayList<JsonValue>();\n+        offset++; \/\/ Walk past the '['\n+        skipWhitespaces();\n+        \/\/ Check for empty case\n+        if (currCharEquals(']')) {\n+            offset++;\n+            return new JsonArrayImpl(list);\n+        }\n+        for (; hasInput(); offset++) {\n+            \/\/ Get the JsonValue\n+            list.add(parseValue());\n+            \/\/ Ensure current char is either ']' or ','\n+            if (currCharEquals(']')) {\n+                offset++;\n+                return new JsonArrayImpl(list);\n+            } else if (!currCharEquals(',')) {\n+                break;\n+            }\n+        }\n+        throw failure(\"Array was not closed with ']'\");\n+    }\n+\n+    \/*\n+     * The parsed JsonString will contain offsets correlating to the beginning\n+     * and ending quotation marks. All Unicode characters are allowed except the\n+     * following that require escaping: quotation mark, reverse solidus, and the\n+     * control characters (U+0000 through U+001F). Any character may be escaped\n+     * either through a Unicode escape sequence or two-char sequence.\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-7\n+     *\/\n+    private JsonString parseString() {\n+        int start = offset;\n+        offset++; \/\/ Move past the starting quote\n+        var escape = false;\n+        for (; hasInput(); offset++) {\n+            var c = doc[offset];\n+            if (escape) {\n+                switch (c) {\n+                    \/\/ Allowed JSON escapes\n+                    case '\"', '\\\\', '\/', 'b', 'f', 'n', 'r', 't' -> {}\n+                    case 'u' -> {\n+                        if (offset + 4 < doc.length) {\n+                            offset++; \/\/ Move to first char in sequence\n+                            checkEscapeSequence();\n+                            offset += 3; \/\/ Move to the last hex digit, outer loop increments\n+                        } else {\n+                            throw failure(\"Invalid Unicode escape sequence\");\n+                        }\n+                    }\n+                    default -> throw failure(\"Illegal escape\");\n+                }\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+            } else if (c == '\\\"') {\n+                return new JsonStringImpl(doc, start, offset += 1);\n+            } else if (c < ' ') {\n+                throw failure(\"Unescaped control code\");\n+            }\n+        }\n+        throw failure(\"Closing quote missing\");\n+    }\n+\n+    \/*\n+     * Parsing true, false, and null return singletons. These JsonValues\n+     * do not require offsets to lazily compute their values.\n+     *\/\n+    private JsonBooleanImpl parseTrue() {\n+        if (charsEqual(\"rue\", offset + 1)) {\n+            offset += 4;\n+            return JsonBooleanImpl.TRUE;\n+        }\n+        throw failure(\"Expected true\");\n+    }\n+\n+    private JsonBooleanImpl parseFalse() {\n+        if (charsEqual( \"alse\", offset + 1)) {\n+            offset += 5;\n+            return JsonBooleanImpl.FALSE;\n+        }\n+        throw failure(\"Expected false\");\n+    }\n+\n+    private JsonNullImpl parseNull() {\n+        if (charsEqual(\"ull\", offset + 1)) {\n+            offset += 4;\n+            return JsonNullImpl.NULL;\n+        }\n+        throw failure(\"Expected null\");\n+    }\n+\n+    \/*\n+     * The parsed JsonNumber contains offsets correlating to the first and last\n+     * allowed chars permitted in the JSON numeric grammar:\n+     *      number = [ minus ] int [ frac ] [ exp ]\n+     * See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-6\n+     *\/\n+    private JsonNumberImpl parseNumber() {\n+        boolean sawDecimal = false;\n+        boolean sawExponent = false;\n+        boolean sawZero = false;\n+        boolean sawWhitespace = false;\n+        boolean havePart = false;\n+        boolean sawInvalid = false;\n+        boolean sawSign = false;\n+        var start = offset;\n+        for (; hasInput() && !sawWhitespace && !sawInvalid; offset++) {\n+            switch (doc[offset]) {\n+                case '-' -> {\n+                    if (offset != start && !sawExponent || sawSign) {\n+                        throw failure(\"Invalid '-' position\");\n+                    }\n+                    sawSign = true;\n+                }\n+                case '+' -> {\n+                    if (!sawExponent || havePart || sawSign) {\n+                        throw failure(\"Invalid '+' position\");\n+                    }\n+                    sawSign = true;\n+                }\n+                case '0' -> {\n+                    if (!havePart) {\n+                        sawZero = true;\n+                    }\n+                    havePart = true;\n+                }\n+                case '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n+                    if (!sawDecimal && !sawExponent && sawZero) {\n+                        throw failure(\"Invalid '0' position\");\n+                    }\n+                    havePart = true;\n+                }\n+                case '.' -> {\n+                    if (sawDecimal) {\n+                        throw failure(\"Invalid '.' position\");\n+                    } else {\n+                        if (!havePart) {\n+                            throw failure(\"Invalid '.' position\");\n+                        }\n+                        sawDecimal = true;\n+                        havePart = false;\n+                    }\n+                }\n+                case 'e', 'E' -> {\n+                    if (sawExponent) {\n+                        throw failure(\"Invalid '[e|E]' position\");\n+                    } else {\n+                        if (!havePart) {\n+                            throw failure(\"Invalid '[e|E]' position\");\n+                        }\n+                        sawExponent = true;\n+                        havePart = false;\n+                        sawSign = false;\n+                    }\n+                }\n+                case ' ', '\\t', '\\r', '\\n' -> {\n+                    sawWhitespace = true;\n+                    offset --;\n+                }\n+                default -> {\n+                    offset--;\n+                    sawInvalid = true;\n+                }\n+            }\n+        }\n+        if (!havePart) {\n+            throw failure(\"Input expected after '[.|e|E]'\");\n+        }\n+        return new JsonNumberImpl(doc, start, offset);\n+    }\n+\n+    \/\/ Utility functions\n+\n+    \/\/ Called when a SB is required to un-escape a member name\n+    private void initBuilder() {\n+        if (builder == null) {\n+            builder = new StringBuilder();\n+        }\n+    }\n+\n+    \/\/ Validate unicode escape sequence\n+    \/\/ This method does not increment offset\n+    private void checkEscapeSequence() {\n+        for (int index = 0; index < 4; index++) {\n+            char c = doc[offset + index];\n+            if ((c < 'a' || c > 'f') && (c < 'A' || c > 'F') && (c < '0' || c > '9')) {\n+                throw failure(\"Invalid Unicode escape sequence\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Unescapes the Unicode escape sequence and produces a char\n+    private char codeUnit() {\n+        try {\n+            return Utils.codeUnit(doc, offset);\n+        } catch (IllegalArgumentException _) {\n+            \/\/ Catch and re-throw as JPE with correct row\/col\n+            throw failure(\"Invalid Unicode escape sequence\");\n+        }\n+    }\n+\n+    \/\/ Returns true if the parser has not yet reached the end of the Document\n+    private boolean hasInput() {\n+        return offset < doc.length;\n+    }\n+\n+    \/\/ Walk to the next non-white space char from the current offset\n+    private void skipWhitespaces() {\n+        while (hasInput()) {\n+            if (notWhitespace()) {\n+                break;\n+            }\n+            offset++;\n+        }\n+    }\n+\n+    \/\/ see https:\/\/datatracker.ietf.org\/doc\/html\/rfc8259#section-2\n+    private boolean notWhitespace() {\n+        return switch (doc[offset]) {\n+            case ' ', '\\t','\\r' -> false;\n+            case '\\n' -> {\n+                \/\/ Increments the row and col\n+                line += 1;\n+                lineStart = offset + 1;\n+                yield false;\n+            }\n+            default -> true;\n+        };\n+    }\n+\n+    private JsonParseException failure(String message) {\n+        var errMsg = composeParseExceptionMessage(\n+                message, line, lineStart, offset);\n+        return new JsonParseException(errMsg, line, offset - lineStart);\n+    }\n+\n+    \/\/ returns true if the char at the specified offset equals the input char\n+    \/\/ and is within bounds of the char[]\n+    private boolean currCharEquals(char c) {\n+        return hasInput() && c == doc[offset];\n+    }\n+\n+    \/\/ Returns true if the substring starting at the given offset equals the\n+    \/\/ input String and is within bounds of the JSON document\n+    private boolean charsEqual(String str, int o) {\n+        if (o + str.length() - 1 < doc.length) {\n+            for (int index = 0; index < str.length(); index++) {\n+                if (doc[o] != str.charAt(index)) {\n+                    return false; \/\/ char does not match\n+                }\n+                o++;\n+            }\n+            return true; \/\/ all chars match\n+        }\n+        return false; \/\/ not within bounds\n+    }\n+\n+    \/\/ Utility method to compose parse exception message\n+    private String composeParseExceptionMessage(String message, int line, int lineStart, int offset) {\n+        return \"%s: (%s) at Row %d, Col %d.\"\n+            .formatted(message, new String(doc, offset, Math.min(offset + 8, doc.length) - offset),\n+                line, offset - lineStart);\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonParser.java","additions":485,"deletions":0,"binary":false,"changes":485,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonString;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * JsonString implementation class\n+ *\/\n+public final class JsonStringImpl implements JsonString {\n+\n+    private final char[] doc;\n+    private final int startOffset;\n+    private final int endOffset;\n+    private final String str;\/\/ = StableSupplier.of(this::unescape);\n+\n+    public JsonStringImpl(String str) {\n+        doc = (\"\\\"\" + str + \"\\\"\").toCharArray();\n+        startOffset = 0;\n+        endOffset = doc.length;\n+        this.str = unescape();\n+    }\n+\n+    public JsonStringImpl(char[] doc, int start, int end) {\n+        this.doc = doc;\n+        startOffset = start;\n+        endOffset = end;\n+        str = unescape();\n+    }\n+\n+    @Override\n+    public String value() {\n+        var ret = str;\n+        return str.substring(1, ret.length() - 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return str;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof JsonString ojs &&\n+                Objects.equals(value(), ojs.value());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value());\n+    }\n+\n+    private String unescape() {\n+        return Utils.unescape(doc, startOffset, endOffset);\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/JsonStringImpl.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.tools.json.impl;\n+\n+\n+import hat.tools.json.JsonArray;\n+import hat.tools.json.JsonObject;\n+import hat.tools.json.JsonValue;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Shared utilities for Json classes.\n+ *\/\n+public class Utils {\n+\n+    \/\/ Non instantiable\n+    private Utils() {}\n+\n+    \/\/ Equivalent to JsonObject\/Array.of() factories without the need for defensive copy\n+    \/\/ and other input validation\n+    public static JsonArray arrayOf(List<JsonValue> list) {\n+        return new JsonArrayImpl(list);\n+    }\n+\n+    public static JsonObject objectOf(Map<String, JsonValue> map) {\n+        return new JsonObjectImpl(map);\n+    }\n+\n+    \/\/ Used for escaping String values, applicable to JSON Strings and member names\n+    public static String unescape(char[] doc, int startOffset, int endOffset) {\n+        StringBuilder sb = null; \/\/ Only use if required\n+        var escape = false;\n+        int offset = startOffset;\n+        boolean useBldr = false;\n+        for (; offset < endOffset; offset++) {\n+            var c = doc[offset];\n+            if (escape) {\n+                var length = 0;\n+                switch (c) {\n+                    case '\"', '\\\\', '\/' -> {}\n+                    case 'b' -> c = '\\b';\n+                    case 'f' -> c = '\\f';\n+                    case 'n' -> c = '\\n';\n+                    case 'r' -> c = '\\r';\n+                    case 't' -> c = '\\t';\n+                    case 'u' -> {\n+                        if (offset + 4 < endOffset) {\n+                            c = codeUnit(doc, offset + 1);\n+                            length = 4;\n+                        } else {\n+                            throw new IllegalArgumentException(\"Illegal Unicode escape sequence\");\n+                        }\n+                    }\n+                    default -> throw new IllegalArgumentException(\"Illegal escape sequence\");\n+                }\n+                if (!useBldr) {\n+                    useBldr = true;\n+                    \/\/ At best, we know the size of the first escaped value\n+                    sb = new StringBuilder(endOffset - startOffset - length - 1)\n+                            .append(doc, startOffset, offset - 1 - startOffset);\n+                }\n+                offset+=length;\n+                escape = false;\n+            } else if (c == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+            if (useBldr) {\n+                sb.append(c);\n+            }\n+        }\n+        if (useBldr) {\n+            return sb.toString();\n+        } else {\n+            return new String(doc, startOffset, endOffset - startOffset);\n+        }\n+    }\n+\n+    \/\/ Validate and construct corresponding value of Unicode escape sequence\n+    \/\/ This method does not increment offset\n+    static char codeUnit(char[] doc, int o) {\n+        char val = 0;\n+        for (int index = 0; index < 4; index ++) {\n+            char c = doc[o + index];\n+            val <<= 4;\n+            val += (char) (\n+                    switch (c) {\n+                        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> c - '0';\n+                        case 'a', 'b', 'c', 'd', 'e', 'f' -> c - 'a' + 10;\n+                        case 'A', 'B', 'C', 'D', 'E', 'F' -> c - 'A' + 10;\n+                        default -> throw new IllegalArgumentException(\"Illegal Unicode escape sequence\");\n+                    });\n+        }\n+        return val;\n+    }\n+}\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/json\/impl\/Utils.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+import javax.swing.text.Element;\n@@ -49,0 +50,2 @@\n+import java.awt.geom.Rectangle2D;\n+import java.util.List;\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/AbstractTextModelViewer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.swing.text.BadLocationException;\n@@ -39,0 +38,1 @@\n+import java.awt.Stroke;\n@@ -45,1 +45,0 @@\n-import java.util.LinkedHashSet;\n@@ -48,1 +47,0 @@\n-import java.util.Set;\n@@ -54,1 +52,2 @@\n-    int lineNumber =0;\n+    int lineNumber = 0;\n+\n@@ -67,16 +66,8 @@\n-            try {\n-                var fromPoint1 = viewer.jtextPane.modelToView2D(from.getStartOffset());\n-                var fromPoint2 = viewer.jtextPane.modelToView2D(from.getEndOffset());\n-                var fromRect = new Rectangle2D.Double(fromPoint1.getBounds().getMinX(), fromPoint1.getMinY()\n-                        , fromPoint2.getBounds().getWidth(), fromPoint2.getBounds().getHeight());\n-                var toPoint1 = viewer.jtextPane.modelToView2D(to.getStartOffset() + 3);\n-                var toPoint2 = viewer.jtextPane.modelToView2D(to.getEndOffset());\n-                var toRect = new Rectangle2D.Double(toPoint1.getBounds().getMinX(), toPoint1.getMinY()\n-                        , toPoint2.getBounds().getWidth(), toPoint2.getBounds().getHeight());\n-                g2d.setColor(Color.GRAY);\n-                var x0 = fromRect.getBounds().getMinX();\n-                var y0 = fromRect.getBounds().getCenterY();\n-                var x1 = toRect.getBounds().getMinX();\n-                var y1 = toRect.getBounds().getCenterY();\n-                final AffineTransform tx = AffineTransform.getTranslateInstance(x1, y1);\n-                tx.rotate(Math.atan2(y1 - y0, x1 - x0));\n+            if (viewer.getRect(from) instanceof Rectangle2D.Double frect\n+                    && viewer.getRect(to) instanceof Rectangle2D.Double trect) {\n+                g2d.setColor(Color.BLACK);\n+                Line2D.Double arrow = new Line2D.Double(\n+                        frect.getBounds().getMinX(), frect.getBounds().getCenterY(),\n+                        trect.getBounds().getMinX(), trect.getBounds().getCenterY());\n+                final AffineTransform tx = AffineTransform.getTranslateInstance(arrow.x2, arrow.y2);\n+                tx.rotate(Math.atan2(arrow.y2 - arrow.y1, arrow.x2 - arrow.x1));\/\/ point the arrow to the target\n@@ -84,5 +75,10 @@\n-                var line = new Line2D.Double(x0, y0, x1, y1);\n-                g2d.setStroke(new BasicStroke(2));\n-                g2d.draw(line);\n-            } catch (BadLocationException e) {\n-                throw new RuntimeException(e);\n+                \/\/ Create a copy of the Graphics instance\n+                Graphics2D g2d2 = (Graphics2D) g2d.create();\n+                \/\/ Set the stroke of the copy, not the original\n+                Stroke dashed = new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,\n+                        0, new float[]{4f, 2f, 5f, 1f}, 0);\n+                g2d2.setStroke(dashed);\n+\n+                \/\/    g2d2.setStroke(new BasicStroke(1));\n+                g2d2.draw(arrow);\n+\n@@ -119,0 +115,1 @@\n+        final var thisTextViewer = this;\n@@ -124,1 +121,1 @@\n-                var clicked = getElementFromMouseEvent(e);\n+                var clickedElement = getElementFromMouseEvent(e);\n@@ -126,23 +123,13 @@\n-                javaTextModelViewer.removeHighlights();\n-                if (clicked != null) {\n-                    var optionalElementSpan = opToJava.keySet().stream()\n-                            .filter(fromElementSpan -> fromElementSpan.includes(clicked.getStartOffset())).findFirst();\n-                    if (optionalElementSpan.isPresent()) {\n-                        ElementSpan elementSpan = optionalElementSpan.get();\n-                        lineNumber = getLine(elementSpan.element().getStartOffset())+1;\n-                    }\n-                    if (opToJava.keySet().stream()\n-                            .anyMatch(fromElementSpan -> fromElementSpan.includes(clicked.getStartOffset()))) {\n-                        opToJava.keySet().stream().\n-                                filter(fromElementSpan -> fromElementSpan.includes(clicked.getStartOffset()))\n-                                .forEach(fromElementSpan -> {\n-                                    fromElementSpan.textViewer().highLight(fromElementSpan.element());\n-                                    opToJava.get(fromElementSpan).forEach(targetElementSpan -> {\n-                                        Element targetElement = targetElementSpan.element();\n-\n-                                        targetElementSpan.textViewer().highLight(targetElement);\n-                                        targetElementSpan.textViewer().scrollTo(targetElement);\n-                                    });\n-                                });\n-                    } else {\n-                        System.out.println(\"not a locationmapping  from op\");\n+                if (javaTextModelViewer != null) {\n+                    javaTextModelViewer.removeHighlights();\n+                    if (clickedElement != null) {\n+                        var elementsReferencedByClickedElement = opToJava.keySet().stream()\n+                                .filter(fromElementSpan ->\n+                                        fromElementSpan.includes(clickedElement.getStartOffset())\n+                                ).toList();\n+                        if (!elementsReferencedByClickedElement.isEmpty()) {\n+                            lineNumber = getLine(elementsReferencedByClickedElement.getFirst().element()) + 1;\n+                            elementsReferencedByClickedElement.forEach(fromElementSpan -> {\n+                                thisTextViewer.highlight(fromElementSpan, opToJava.get(fromElementSpan));\n+                            });\n+                        }\n@@ -150,2 +137,0 @@\n-                } else {\n-                    System.out.println(\"nothing from op\");\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/FuncOpTextModelViewer.java","additions":36,"deletions":51,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.swing.text.Element;\n@@ -46,0 +45,1 @@\n+        private JavaTextModelViewer viewer;\n@@ -54,0 +54,3 @@\n+        void setViewer(JavaTextModelViewer viewer) {\n+            this.viewer = viewer;\n+        }\n@@ -56,2 +59,0 @@\n-    ;\n-\n@@ -60,0 +61,2 @@\n+        final var thisTextViewer = this;\n+        ((JavaTextPane) this.jtextPane).setViewer(this);\n@@ -63,1 +66,1 @@\n-                var clicked = getElementFromMouseEvent(e);\n+                var clickedElement = getElementFromMouseEvent(e);\n@@ -66,14 +69,9 @@\n-                if (clicked != null) {\n-                    if (javaToOp.keySet().stream().anyMatch(fromElementSpan -> fromElementSpan.includes(clicked.getStartOffset()))) {\n-                        javaToOp.keySet().stream().\n-                                filter(fromElementSpan -> fromElementSpan.includes(clicked.getStartOffset()))\n-                                .forEach(fromElementSpan -> {\n-                                    fromElementSpan.textViewer().highLight(fromElementSpan.element());\n-                                    javaToOp.get(fromElementSpan).forEach(targetElementSpan -> {\n-                                        Element targetElement = targetElementSpan.element();\n-                                        targetElementSpan.textViewer().highLight(targetElement);\n-                                        targetElementSpan.textViewer().scrollTo(targetElement);\n-                                    });\n-                                });\n-                    } else {\n-                        System.out.println(\"not a mappable java line  from op\");\n+                if (clickedElement != null) {\n+                    var elementsReferencedByClickedElement = javaToOp.keySet().stream()\n+                            .filter(fromElementSpan ->\n+                                    fromElementSpan.includes(clickedElement.getStartOffset())\n+                            ).toList();\n+                    if (!elementsReferencedByClickedElement.isEmpty()) {\n+                        elementsReferencedByClickedElement.forEach(fromElementSpan -> {\n+                            thisTextViewer.highlight(fromElementSpan, javaToOp.get(fromElementSpan));\n+                        });\n@@ -81,2 +79,0 @@\n-                } else {\n-                    System.out.println(\"nothing from java\");\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/JavaTextModelViewer.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.tools.textmodel.ui;\n+\n+import hat.tools.jdot.DotBuilder;\n+import hat.tools.jdot.ui.JDot;\n+import hat.tools.textmodel.BabylonTextModel;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import javax.swing.BoxLayout;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JSplitPane;\n+import javax.swing.SwingUtilities;\n+import java.awt.BorderLayout;\n+import java.awt.Font;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SSAIDViewer extends JPanel {\n+\n+    public SSAIDViewer(BabylonTextModel cr) {\n+        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));\n+        var font = new Font(\"Monospaced\", Font.PLAIN, 14);\n+\n+        var funcOpTextModelViewer = new FuncOpTextModelViewer(cr, font, false);\n+\n+        var dotViewer = new JDot(DotBuilder.dotDigraph(\"name\", g -> {\n+            g.nodeShape(\"record\");\n+            cr.ssaEdgeList.forEach(edge -> {\n+                var ssaDef = edge.ssaDef();\n+                String def = \"%\" + ssaDef.id;\n+                g.record(def, def);\n+            });\n+            cr.ssaEdgeList.forEach(edge -> {\n+                var ssaDef = edge.ssaDef();\n+                String def = \"%\" + ssaDef.id;\n+                int line = ssaDef.pos().line();\n+                cr.ssaEdgeList.forEach(e -> {\n+                    var ssaRef = e.ssaRef();\n+                    if (ssaRef.pos().line() == line) {\n+                        String ref = \"%\" + ssaRef.id;\n+                        g.edge(def, ref);\n+                    }\n+                });\n+            });\n+        }));\n+        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);\n+        splitPane.setLeftComponent(funcOpTextModelViewer.scrollPane);\n+        splitPane.setRightComponent(dotViewer.pane);\n+        add(splitPane);\n+    }\n+\n+    public static void launch(BabylonTextModel crDoc) {\n+        SwingUtilities.invokeLater(() -> {\n+            var viewer = new SSAIDViewer(crDoc);\n+            var frame = new JFrame();\n+            frame.setLayout(new BorderLayout());\n+            frame.getContentPane().add(viewer);\n+            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+            frame.pack();\n+            frame.setVisible(true);\n+        });\n+\n+    }\n+\n+    public static void launch(CoreOp.FuncOp javaFunc) {\n+        BabylonTextModel crDoc = BabylonTextModel.of(javaFunc);\n+        launch(crDoc);\n+    }\n+\n+    public static void launch(Path path) throws IOException {\n+        BabylonTextModel crDoc = BabylonTextModel.of(Files.readString(path));\n+        launch(crDoc);\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        SSAIDViewer.launch(Path.of(args[0]));\n+    }\n+}\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/SSAIDViewer.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -73,1 +73,0 @@\n-      \/\/  this.rhs.jtextPane.addCaretListener(_ -> repaint());\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/TextGutter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.awt.Point;\n@@ -40,0 +41,1 @@\n+import java.awt.geom.Rectangle2D;\n@@ -42,0 +44,1 @@\n+import java.util.TreeMap;\n@@ -48,1 +51,3 @@\n-    protected List<Span> lines;\n+    public record Line(int line, int startOffset, int endOffset) implements Span {}\n+    protected List<Line> lines;\n+    protected TreeMap<Integer,Line> offsetToLineTreeMap;\n@@ -98,0 +103,3 @@\n+    public int getOffset(Point p) {\n+        return jtextPane.viewToModel2D(p);\n+    }\n@@ -99,1 +107,1 @@\n-        return jtextPane.viewToModel2D(e.getPoint());\n+        return getOffset(e.getPoint());\n@@ -111,7 +119,3 @@\n-    public int getLine(int offset) {\n-       for (int l= 0; l < lines.size(); l++) {\n-            if (lines.get(l).includes(offset)) {\n-               return l+1;\n-            }\n-        }\n-       return 0;\n+    public int getLine(Element element) {\n+       var lineSpan = offsetToLineTreeMap.ceilingEntry(element.getStartOffset());\n+       return lineSpan.getValue().line+1;\n@@ -124,0 +128,1 @@\n+        offsetToLineTreeMap = new TreeMap<>();\n@@ -126,1 +131,1 @@\n-            Span line = new Span.Impl(accumOffset, accumOffset + linesOfText[currentLine].length() + 1);\/\/ +1 for newline\n+            Line line = new Line(lines.size(), accumOffset, accumOffset + linesOfText[currentLine].length() + 1);\/\/ +1 for newline\n@@ -129,0 +134,1 @@\n+            offsetToLineTreeMap.put(accumOffset, line);\n@@ -135,5 +141,1 @@\n-        var highlighter = jtextPane.getHighlighter();\n-        highlighter.removeAllHighlights();\n-        \/\/for (var highlight : highlighter.getHighlights()) {\n-          \/\/      highlighter.removeHighlight(highlight);\n-       \/\/ }\n+        jtextPane.getHighlighter().removeAllHighlights();\n@@ -177,0 +179,20 @@\n+    public Rectangle2D.Double getRect(Element from) {\n+        try {\n+            var fromPoint1 = jtextPane.modelToView2D(from.getStartOffset());\n+            var fromPoint2 = jtextPane.modelToView2D(from.getEndOffset());\n+            return new Rectangle2D.Double(fromPoint1.getBounds().getMinX(), fromPoint1.getMinY()\n+                    , fromPoint2.getBounds().getWidth(), fromPoint2.getBounds().getHeight());\n+        }catch (Exception e){\n+            return null;\n+        }\n+    }\n+\n+    public void highlight(ElementSpan fromElementSpan, List<ElementSpan> toElementSpans) {\n+        highLight(fromElementSpan.element());\n+        toElementSpans.forEach(targetElementSpan -> {\n+            var targetTextViewer = targetElementSpan.textViewer();\n+            var targetElement = targetElementSpan.element();\n+            targetTextViewer.highLight(targetElement);\n+            targetTextViewer.scrollTo(targetElement);\n+        });\n+    }\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/TextViewer.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"}]}