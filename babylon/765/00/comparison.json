{"files":[{"patch":"@@ -47,5 +47,5 @@\n-        NA(1),\n-        RO(2),\n-        WO(4),\n-        RW(6),\n-        NOT_BUFFER(0);\n+        NOT_BUFFER((byte)0),\n+        NA((byte)1),\n+        RO((byte)(1<<1)),\n+        WO((byte)(1<<2)),\n+        RW((byte) (RO.value|WO.value));\n@@ -53,2 +53,2 @@\n-        public final int value;\n-        AccessType(int i) {\n+        public final byte value;\n+        AccessType(byte i) {\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+\n+    default BF16Impl[] arrayview() {return null;}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16Array.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,24 +27,2 @@\n-import hat.dialect.HATBarrierOp;\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16ConvOp;\n-import hat.dialect.HATF16ToFloatConvOp;\n-import hat.dialect.HATF16VarLoadOp;\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATMemoryLoadOp;\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorMakeOfOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorSelectStoreOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.HATVectorVarOp;\n+import hat.dialect.*;\n+import hat.optools.OpTk;\n@@ -108,0 +86,6 @@\n+    T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrLoadOp hatPtrLoadOp);\n+\n+    T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrStoreOp hatPtrStoreOp);\n+\n+    T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrLengthOp hatPtrLengthOp);\n+\n@@ -157,0 +141,3 @@\n+            case HATPtrLoadOp $ -> hatPtrLoadOp(buildContext, $);\n+            case HATPtrStoreOp $ -> hatPtrStoreOp(buildContext, $);\n+            case HATPtrLengthOp $ -> hatPtrLengthOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import hat.buffer.BF16;\n-import hat.buffer.BF16Array;\n+import hat.buffer.*;\n@@ -30,20 +29,1 @@\n-import hat.buffer.F16;\n-import hat.buffer.F16Array;\n-import hat.dialect.HATBarrierOp;\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16VarLoadOp;\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATMemoryLoadOp;\n-import hat.dialect.HATMemoryOp;\n-import hat.dialect.HATPrivateInitVarOp;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorMakeOfOp;\n-import hat.dialect.HATVectorOfOp;\n-import hat.dialect.HATVectorVarLoadOp;\n-import hat.dialect.ReducedFloatType;\n+import hat.dialect.*;\n@@ -53,0 +33,1 @@\n+import jdk.incubator.code.Op;\n@@ -61,0 +42,1 @@\n+import optkl.codebuilders.CodeBuilder;\n@@ -536,0 +518,59 @@\n+    public T hatPtrLoadOp(ScopedCodeBuilderContext builderContext, HATPtrLoadOp hatPtrLoadOp) {\n+        ptrAccess(builderContext, hatPtrLoadOp);\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatPtrStoreOp(ScopedCodeBuilderContext builderContext, HATPtrStoreOp hatPtrStoreOp) {\n+        ptrAccess(builderContext, hatPtrStoreOp).equals().recurse(builderContext, ((Op.Result) hatPtrStoreOp.operands().getLast()).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatPtrLengthOp(ScopedCodeBuilderContext builderContext, HATPtrLengthOp hatPtrLengthOp) {\n+        ptrAccess(builderContext, hatPtrLengthOp);\n+        return self();\n+    }\n+\n+    T ptrAccess(ScopedCodeBuilderContext builderContext, HATPtrOp hatPtrOp) {\n+        boolean isLocalOrPrivateDS = false;\n+        if (((Op.Result) hatPtrOp.operands().getFirst()).op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            Op resolve = builderContext.scope.resolve(varLoadOp.operands().getFirst());\n+            if (resolve instanceof HATMemoryOp) {\n+                isLocalOrPrivateDS = true;\n+            }\n+        }\n+        identifier(hatPtrName(hatPtrOp));\n+        either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n+\n+        if (hatPtrOp instanceof HATPtrLengthOp) {\n+            identifier(\"length\");\n+        } else {\n+            boolean finalIsLocalOrPrivateDS = isLocalOrPrivateDS;\n+            identifier(\"array\").sbrace(_ -> {\n+                paren(_ -> identifier(\"long\"));\n+                paren(_ -> {\n+                    if (hatPtrOp.strides().size() > 1) {\n+                        paren(_ -> recurse(builderContext, ((Op.Result) hatPtrOp.operands().get(2)).op()));\n+                        asterisk().identifier(hatPtrName(hatPtrOp));\n+                        either(finalIsLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow).identifier(hatPtrOp.strides() != null ? hatPtrOp.strides().getFirst() : \"width\");\n+                        add().paren(_ -> recurse(builderContext, ((Op.Result) hatPtrOp.operands().get(1)).op()));\n+                    } else {\n+                        recurse(builderContext, ((Op.Result) hatPtrOp.operands().get(1)).op());\n+                    }\n+                });\n+            });\n+        }\n+        return self();\n+    }\n+\n+    public String hatPtrName(HATPtrOp hatPtrOp) {\n+        Op op = ((Op.Result) ((Op.Result) (hatPtrOp.operands().getFirst())).op().operands().getFirst()).op();\n+        return switch (op) {\n+            case CoreOp.VarOp varOp -> varOp.varName();\n+            case HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+            case HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+            case null, default -> \"\";\n+        };\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":63,"deletions":22,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.*;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATPtrLengthOp extends HATPtrOp {\n+\n+    private static final String NAME = \"HATPtrLengthOp\";\n+\n+    public HATPtrLengthOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+        super(resultType, bufferClass, operands);\n+    }\n+\n+    public HATPtrLengthOp(HATPtrLengthOp op, CodeContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+        return new HATPtrLengthOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrLengthOp.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.*;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATPtrLoadOp extends HATPtrOp {\n+\n+    private static final String NAME = \"HATPtrLoadOp\";\n+\n+    public HATPtrLoadOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+        super(resultType, bufferClass, operands);\n+    }\n+\n+    public HATPtrLoadOp(HATPtrLoadOp op, CodeContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+        return new HATPtrLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrLoadOp.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import hat.device.DeviceSchema;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.*;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class HATPtrOp extends HATOp {\n+\n+    private final TypeElement resultType;\n+    private final Class<?> bufferClass;\n+    private final List<String> strides;\n+\n+    private static final String NAME = \"HATPtrOp\";\n+\n+    public HATPtrOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+        super(operands);\n+        this.resultType = resultType;\n+        this.bufferClass = bufferClass;\n+        List<String> fields = getFieldsOfBuffer(bufferClass);\n+        this.strides = (fields == null) ? List.of() : fields.subList(0, fields.size() - 1);\n+    }\n+\n+    public HATPtrOp(HATPtrOp op, CodeContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+        this.bufferClass = op.bufferClass;\n+        this.strides = op.strides;\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    public Class<?> bufferClass() {\n+        return bufferClass;\n+    }\n+\n+\n+    public List<String> strides() {\n+        return strides;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+    }\n+\n+    public static List<String> getFieldsOfBuffer(Class<?> clazz) {\n+        try {\n+            if (!Modifier.isPublic(clazz.getModifiers())) return null;\n+            Object obj = clazz.getField(\"schema\").get(null);\n+            if (obj instanceof DeviceSchema<?> deviceSchema) {\n+                return null;\n+            } else if (obj instanceof Schema<?> schema) {\n+                return schema.rootIfaceType.fields.stream().map(fieldNode -> fieldNode.name).toList();\n+            }\n+            return null;\n+        } catch (IllegalAccessException | NoSuchFieldException e) {\n+            throw new RuntimeException(e);\n+        }\n+        \/\/ return Schema.of(clazz).rootIfaceType.fields;\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrOp.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.*;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATPtrStoreOp extends HATPtrOp {\n+\n+    private static final String NAME = \"HATPtrStoreOp\";\n+\n+    public HATPtrStoreOp(TypeElement resultType, Class<?> bufferClass, List<Value> operands) {\n+        super(resultType, bufferClass, operands);\n+    }\n+\n+    public HATPtrStoreOp(HATPtrStoreOp op, CodeContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+        return new HATPtrStoreOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.resultType());\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPtrStoreOp.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -362,0 +362,3 @@\n+            case HATPtrStoreOp o -> 13;\n+            case HATPtrLengthOp o -> 0;\n+            case HATPtrLoadOp o -> 0;\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,11 +29,1 @@\n-import hat.dialect.HATLocalVarOp;\n-import hat.dialect.HATPhaseUtils;\n-import hat.dialect.HATPrivateVarOp;\n-import hat.dialect.HATVectorAddOp;\n-import hat.dialect.HATVectorBinaryOp;\n-import hat.dialect.HATVectorDivOp;\n-import hat.dialect.HATVectorLoadOp;\n-import hat.dialect.HATVectorMulOp;\n-import hat.dialect.HATVectorStoreView;\n-import hat.dialect.HATVectorSubOp;\n-import hat.dialect.HATVectorVarOp;\n+import hat.dialect.*;\n@@ -49,1 +39,0 @@\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -53,4 +42,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -157,50 +143,13 @@\n-                            \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                            \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                            \/\/     List<Value> operands = new ArrayList<>();\n-                            \/\/     operands.add(info.buffer);\n-                            \/\/     operands.addAll(info.indices);\n-                            \/\/     HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n-                            \/\/             arrayLoadOp.resultType(),\n-                            \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n-                            \/\/             info.indices(),\n-                            \/\/             bb.context().getValues(operands)\n-                            \/\/     );\n-                            \/\/     ptrLoadOp.setLocation(arrayLoadOp.location());\n-                            \/\/     Op.Result res = bb.op(ptrLoadOp);\n-                            \/\/     bb.context().mapValue(arrayLoadOp.result(), res);\n-                            \/\/ }\n-                            return bb;\n-                        }\n-                        if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n-                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n-                                \/\/ idea: we want to calculate the idx for the buffer access\n-                                \/\/ idx = (long) (((long) rowOp.idx * (long) buffer.width()) + alop.idx)\n-                                Op.Result x = (Op.Result) getValue(bb, rowOp.operands().getLast());\n-                                Op.Result y = (Op.Result) getValue(bb, arrayLoadOp.operands().getLast());\n-                                Op.Result ogBufferLoad = replaced.get((Op.Result) firstOperand(rowOp));\n-                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) firstOperand(ogBufferLoad.op()), (Op.Result) firstOperand(ogBufferLoad.op()));\n-                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(getValue(bb, ogBuffer)));\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n-                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n-                                Op.Result width = bb.op(JavaOp.invoke(m, getValue(bb, bufferLoad)));\n-                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, x));\n-                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, y));\n-                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, width)));\n-                                Op.Result mul = bb.op(JavaOp.mul(getValue(bb, longY), getValue(bb, longWidth)));\n-                                Op.Result idx = bb.op(JavaOp.add(getValue(bb, longX), getValue(bb, mul)));\n-\n-                                Class<?> storedClass = OpTk.typeElementToClass(accelerator.lookup,arrayLoadOp.result().type());\n-                                MethodRef arrayMethod = MethodRef.method(c, \"array\", storedClass, long.class);\n-                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, getValue(bb, ogBufferLoad), getValue(bb, idx)));\n-                                bb.context().mapValue(arrayLoadOp.result(), invokeRes);\n-                            } else {\n-                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, getValue(bb, arrayLoadOp.operands().get(1)));\n-                                Op.Result convRes = bb.op(conv);\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n-                                Class<?> storedClass = OpTk.typeElementToClass(accelerator.lookup,arrayLoadOp.result().type());\n-                                MethodRef m = MethodRef.method(c, \"array\", storedClass, long.class);\n-                                Op.Result invokeRes = bb.op(JavaOp.invoke(m, getValue(bb, buffer), convRes));\n-                                bb.context().mapValue(arrayLoadOp.result(), invokeRes);\n-                            }\n+                        } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                            ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                            List<Value> operands = new ArrayList<>();\n+                            operands.add(info.buffer);\n+                            operands.addAll(info.indices);\n+                            HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n+                                    arrayLoadOp.resultType(),\n+                                    (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                    bb.context().getValues(operands)\n+                            );\n+                            ptrLoadOp.setLocation(arrayLoadOp.location());\n+                            Op.Result res = bb.op(ptrLoadOp);\n+                            bb.context().mapValue(arrayLoadOp.result(), res);\n@@ -232,58 +181,14 @@\n-                            \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                            \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                            \/\/     List<Value> operands = new ArrayList<>();\n-                            \/\/     operands.add(info.buffer());\n-                            \/\/     \/\/ operands.add(arrayStoreOp.operands().getLast());\n-                            \/\/     operands.addAll(info.indices);\n-                            \/\/     HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n-                            \/\/             arrayStoreOp.resultType(),\n-                            \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n-                            \/\/             info.indices(),\n-                            \/\/             getValue(bb, arrayStoreOp.operands().getLast()),\n-                            \/\/             bb.context().getValues(operands)\n-                            \/\/             \/\/ bb.context().getValues(List.of(info.buffer(), arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n-                            \/\/     );\n-                            \/\/     ptrLoadOp.setLocation(arrayStoreOp.location());\n-                            \/\/     Op.Result res = bb.op(ptrLoadOp);\n-                            \/\/     bb.context().mapValue(arrayStoreOp.result(), res);\n-                            \/\/ }\n-                            return bb;\n-                        }\n-                        if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n-                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n-                                Op.Result x = (Op.Result) rowOp.operands().getLast();\n-                                Op.Result y = (Op.Result) arrayStoreOp.operands().get(1);\n-                                Op.Result ogBufferLoad = replaced.get((Op.Result) firstOperand(rowOp));\n-                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) firstOperand(ogBufferLoad.op()), (Op.Result) firstOperand(ogBufferLoad.op()));\n-                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(getValue(bb, ogBuffer)));\n-                                Op.Result computed = (Op.Result) arrayStoreOp.operands().getLast();\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n-                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n-                                Op.Result width = bb.op(JavaOp.invoke(m, getValue(bb, bufferLoad)));\n-                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, x)));\n-                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, y)));\n-                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, width)));\n-                                Op.Result mul = bb.op(JavaOp.mul(getValue(bb, longY), getValue(bb, longWidth)));\n-                                Op.Result idx = bb.op(JavaOp.add(getValue(bb, longX), getValue(bb, mul)));\n-\n-                                MethodRef arrayMethod = MethodRef.method(c, \"array\", void.class, long.class, int.class);\n-                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, getValue(bb, ogBufferLoad), getValue(bb, idx), getValue(bb, computed)));\n-                                bb.context().mapValue(arrayStoreOp.result(), invokeRes);\n-                            } else {\n-                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, arrayStoreOp.operands().get(1))));\n-                                Value val = getValue(bb, arrayStoreOp.operands().getLast());\n-\n-                                boolean noRootVlop = (buffer.op() instanceof CoreOp.VarOp);\n-                                ClassType classType = (noRootVlop) ?\n-                                        (ClassType) ((CoreOp.VarOp) buffer.op()).varValueType() :\n-                                        (ClassType) buffer.type();\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n-                                Class<?> storedClass = typeElementToClass(val.type());\n-                                MethodRef m = MethodRef.method(c, \"array\", void.class, long.class, storedClass);\n-                                Op.Result invokeRes = (noRootVlop) ?\n-                                        bb.op(JavaOp.invoke(m, getValue(bb, r), idx, val)) :\n-                                        bb.op(JavaOp.invoke(m, getValue(bb, buffer), idx, val));\n-                                bb.context().mapValue(arrayStoreOp.result(), invokeRes);\n-                            }\n+                        } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                            ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                            List<Value> operands = new ArrayList<>();\n+                            operands.add(info.buffer());\n+                            operands.addAll(info.indices);\n+                            operands.add(arrayStoreOp.operands().getLast());\n+                            HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n+                                    arrayStoreOp.resultType(),\n+                                    (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                    bb.context().getValues(operands)\n+                            );\n+                            ptrLoadOp.setLocation(arrayStoreOp.location());\n+                            Op.Result res = bb.op(ptrLoadOp);\n+                            bb.context().mapValue(arrayStoreOp.result(), res);\n@@ -294,10 +199,13 @@\n-                case JavaOp.ArrayLengthOp alen -> {\n-                    if (isBufferArray(alen) &&\n-                            firstOperand(alen) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.get(r);\n-                        Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n-                        MethodRef m = MethodRef.method(c, \"length\", int.class);\n-                        JavaOp.InvokeOp newInvokeOp = JavaOp.invoke(m, getValue(bb, buffer));\n-                        newInvokeOp.setLocation(alen.location());\n-                        Op.Result res = bb.op(newInvokeOp);\n-                        bb.context().mapValue(alen.result(), res);\n+                case JavaOp.ArrayLengthOp arrayLengthOp -> {\n+                    if (isBufferArray(arrayLengthOp) &&\n+                            firstOperand(arrayLengthOp) instanceof Op.Result r) {\n+                        ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                        HATPtrLengthOp ptrLengthOp = new HATPtrLengthOp(\n+                                arrayLengthOp.resultType(),\n+                                (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                                bb.context().getValues(List.of(info.buffer()))\n+                        );\n+                        ptrLengthOp.setLocation(arrayLengthOp.location());\n+                        Op.Result res = bb.op(ptrLengthOp);\n+                        bb.context().mapValue(arrayLengthOp.result(), res);\n+                        return bb;\n@@ -305,1 +213,0 @@\n-                    return bb;\n@@ -307,16 +214,0 @@\n-                \/\/ case JavaOp.ArrayLengthOp arrayLengthOp -> {\n-                \/\/     if (isBufferArray(arrayLengthOp) &&\n-                \/\/             firstOperand(arrayLengthOp) instanceof Op.Result r) {\n-                \/\/         ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                \/\/         HATPtrLengthOp ptrLengthOp = new HATPtrLengthOp(\n-                \/\/                 arrayLengthOp.resultType(),\n-                \/\/                 (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n-                \/\/                 info.indices(),\n-                \/\/                 bb.context().getValues(List.of(info.buffer()))\n-                \/\/         );\n-                \/\/         ptrLengthOp.setLocation(arrayLengthOp.location());\n-                \/\/         Op.Result res = bb.op(ptrLengthOp);\n-                \/\/         bb.context().mapValue(arrayLengthOp.result(), res);\n-                \/\/         return bb;\n-                \/\/     }\n-                \/\/ }\n@@ -331,0 +222,53 @@\n+    record ArrayAccessInfo(Op.Result buffer, List<Op.Result> indices) {};\n+\n+    record Node<T>(T value, List<Node<T>> edges) {\n+        ArrayAccessInfo getInfo(Map<Op.Result, Op.Result> replaced) {\n+            List<Node<T>> wl = new ArrayList<>();\n+            Set<Node<T>> seen = new HashSet<>();\n+            Op.Result buffer = null;\n+            List<Op.Result> indices = new ArrayList<>();\n+            wl.add(this);\n+            while (!wl.isEmpty()) {\n+                Node<T> cur = wl.removeFirst();\n+                seen.add(cur);\n+                if (cur.value instanceof Op.Result res) {\n+                    if (res.op() instanceof JavaOp.ArrayAccessOp || res.op() instanceof JavaOp.ArrayLengthOp) {\n+                        buffer = res;\n+                        indices.addFirst(res.op() instanceof JavaOp.ArrayAccessOp ? ((Op.Result) res.op().operands().get(1)) : ((Op.Result) res.op().operands().get(0)));\n+                    }\n+                }\n+                if (!cur.edges().isEmpty()) {\n+                    Node<T> next = cur.edges().getFirst();\n+                    if (!seen.contains(next)) wl.add(next);\n+                }\n+            }\n+            buffer = replaced.get((Op.Result) firstOperand(buffer.op()));\n+            return new ArrayAccessInfo(buffer, indices);\n+        }\n+    }\n+\n+    static ArrayAccessInfo arrayAccessInfo(Value value, Map<Op.Result, Op.Result> replaced) {\n+        return expressionGraph(value).getInfo(replaced);\n+    }\n+\n+    static Node<Value> expressionGraph(Value value) {\n+        return expressionGraph(new HashMap<>(), value);\n+    }\n+\n+    static Node<Value> expressionGraph(Map<Value, Node<Value>> visited, Value value) {\n+        \/\/ If value has already been visited return its node\n+        if (visited.containsKey(value)) {\n+            return visited.get(value);\n+        }\n+\n+        \/\/ Find the expression graphs for each operand\n+        List<Node<Value>> edges = new ArrayList<>();\n+        for (Value operand : value.dependsOn()) {\n+            if (operand instanceof Op.Result res && res.op() instanceof JavaOp.InvokeOp iop && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")) continue;\n+            edges.add(expressionGraph(operand));\n+        }\n+        Node<Value> node = new Node<>(value, edges);\n+        visited.put(value, node);\n+        return node;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":95,"deletions":151,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -186,7 +186,2 @@\n-        default byte[] arrayView() {\n-            int size = this.width() * this.height();\n-            byte[] arr = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = this.array(i);\n-            }\n-            return arr;\n+        default byte[][] arrayView() {\n+            return null;\n@@ -253,1 +248,2 @@\n-        public static void lifePerIdx(int idx, @RO Control control, @RO CellGrid cellGrid, @WO CellGrid cellGridRes) {\n+        \/\/ TODO: switch cellGridRes to WO\n+        public static void lifePerIdx(int idx, @RO Control control, @RO CellGrid cellGrid, @RW CellGrid cellGridRes) {\n@@ -279,2 +275,2 @@\n-            byte[] bytes = cellGrid.arrayView();\n-            byte cell = bytes[idx];\n+            byte[][] bytes = cellGrid.arrayView();\n+            byte cell = bytes[x][y];\n@@ -283,8 +279,8 @@\n-                        (bytes[(y - 1) * w + (x - 1)] & 1)\n-                                + (bytes[(y + 0) * w + (x - 1)] & 1)\n-                                + (bytes[(y + 1) * w + (x - 1)] & 1)\n-                                + (bytes[(y - 1) * w + (x + 0)] & 1)\n-                                + (bytes[(y + 1) * w + (x + 0)] & 1)\n-                                + (bytes[(y - 1) * w + (x + 1)] & 1)\n-                                + (bytes[(y + 0) * w + (x + 1)] & 1)\n-                                + (bytes[(y + 1) * w + (x + 1)] & 1);\n+                        (bytes[x - 1][y - 1] & 1)\n+                                + (bytes[x - 1][y + 0] & 1)\n+                                + (bytes[x - 1][y + 1] & 1)\n+                                + (bytes[x + 0][y - 1] & 1)\n+                                + (bytes[x + 0][y + 1] & 1)\n+                                + (bytes[x + 1][y - 1] & 1)\n+                                + (bytes[x + 1][y + 0] & 1)\n+                                + (bytes[x + 1][y + 1] & 1);\n@@ -293,2 +289,2 @@\n-            byte[] res = cellGridRes.arrayView();\n-            res[idx] = cell;\n+            byte[][] res = cellGridRes.arrayView();\n+            res[x][y] = cell;\n@@ -298,1 +294,1 @@\n-        public static void life(@RO KernelContext kc, @RO Control control, @RO CellGrid cellGrid, @WO CellGrid cellGridRes) {\n+        public static void life(@RO KernelContext kc, @RO Control control, @RO CellGrid cellGrid, @RW CellGrid cellGridRes) {\n@@ -305,1 +301,1 @@\n-        static public void compute(final @RO ComputeContext cc, @RO Control ctrl, @RO CellGrid grid, @WO CellGrid gridRes) {\n+        static public void compute(final @RO ComputeContext cc, @RO Control ctrl, @RO CellGrid grid, @RW CellGrid gridRes) {\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.test;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.NDRange;\n+import hat.ifacemapper.Buffer;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.Schema;\n+import hat.test.annotation.HatTest;\n+import hat.test.exceptions.HATAsserts;\n+import jdk.incubator.code.Reflect;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class TestWriteOnly {\n+\n+    public interface CellGrid extends Buffer {\n+        int width();\n+        int height();\n+        byte array(long idx);\n+        void array(long idx, byte b);\n+\n+        Schema<CellGrid> schema = Schema.of(CellGrid.class, lifeData -> lifeData\n+                .arrayLen(\"width\", \"height\").stride(2).array(\"array\")\n+        );\n+\n+        static CellGrid create(Accelerator accelerator, int width, int height) {\n+            return schema.allocate(accelerator, width, height);\n+        }\n+\n+        default byte[][] arrayView() {\n+            return null;\n+        }\n+    }\n+\n+    @Reflect\n+    public static void life(@RO KernelContext kc, @RO CellGrid cellGrid, @MappableIface.WO CellGrid cellGridRes) {\n+    }\n+\n+    @Reflect\n+    static public void compute(final @RO ComputeContext cc, @RO CellGrid grid, @MappableIface.WO CellGrid gridRes) {\n+        int range = grid.width() * grid.height();\n+        cc.dispatchKernel(NDRange.of1D(range), kc -> life(kc, grid, gridRes));\n+    }\n+\n+    @HatTest\n+    @Reflect\n+    public static void testWriteOnly() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup());\n+\n+        int size = 1028;\n+        CellGrid cellGridRes = CellGrid.create(accelerator, size, size);\n+        CellGrid cellGrid = CellGrid.create(accelerator, size, size);\n+\n+        accelerator.compute( cc -> compute(cc, cellGrid, cellGridRes));\n+\n+        \/\/ System.out.println(\"cellGrid width, height are \" + cellGrid.width() + \", \" + cellGrid.height());\n+        \/\/ System.out.println(\"cellGridRes width, height are \" + cellGridRes.width() + \", \" + cellGridRes.height());\n+\n+        HATAsserts.assertEquals(cellGridRes.width(), size, 0.01f);\n+        HATAsserts.assertEquals(cellGridRes.height(), size, 0.01f);\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestWriteOnly.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}