{"files":[{"patch":"@@ -358,1 +358,1 @@\n-        boolean brokenBytecodeGen = true;\n+        boolean brokenBytecodeGen = false;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-\n@@ -41,0 +40,1 @@\n+import java.util.List;\n@@ -44,17 +44,0 @@\n-    static String hexRegexStr = \"((?:-?&[0-9a-fA-F][0-9a-fA-F])|0)\";\n-    static String commaRegexStr = \" *, *\";\n-    static String hexOrColorCommaRegexStr = \"(\" + hexRegexStr + \"|(?:(?:[a-zA-Z][a-zA-Z0-9]*)))\" + commaRegexStr;\n-    static String hexCommaRegexStr = hexRegexStr + commaRegexStr;\n-    static String decRegexStr = \"([0-9]+)\";\n-    static String decCommaRegexStr = decRegexStr + commaRegexStr;\n-\n-    static Regex face6Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"6\", commaRegexStr, decCommaRegexStr.repeat(5), decRegexStr, \" *$\");\n-    static Regex face5Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"5\", commaRegexStr, decCommaRegexStr.repeat(4), decRegexStr, \" *$\");\n-    static Regex face4Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"4\", commaRegexStr, decCommaRegexStr.repeat(3), decRegexStr, \" *$\");\n-    static Regex face3Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"3\", commaRegexStr, decCommaRegexStr.repeat(2), decRegexStr, \" *$\");\n-\n-    static Regex vertexRegex = Regex.of(\"^ *\" + hexCommaRegexStr + hexCommaRegexStr + hexRegexStr + \" *$\");\n-    static Regex emptyRegex = Regex.of(\"^ *$\");\n-    static Regex remRegex = Regex.of(\"^ *REM(.*)$\");\n-    static Regex colonRegex = Regex.of(\"^ *(:) *$\");\n-    static Regex facesRegex = Regex.of(\"^ *(faces) *$\");\n@@ -63,1 +46,20 @@\n-        default String name(){\n+\n+        String hexRegexStr = \"((?:-?&[0-9a-fA-F][0-9a-fA-F])|0)\";\n+        String commaRegexStr = \" *, *\";\n+        String hexOrColorCommaRegexStr = \"(\" + hexRegexStr + \"|(?:(?:[a-zA-Z][a-zA-Z0-9]*)))\" + commaRegexStr;\n+        String hexCommaRegexStr = hexRegexStr + commaRegexStr;\n+        String decRegexStr = \"([0-9]+)\";\n+        String decCommaRegexStr = decRegexStr + commaRegexStr;\n+\n+        Regex face6Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"6\", commaRegexStr, decCommaRegexStr.repeat(5), decRegexStr, \" *$\");\n+        Regex face5Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"5\", commaRegexStr, decCommaRegexStr.repeat(4), decRegexStr, \" *$\");\n+        Regex face4Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"4\", commaRegexStr, decCommaRegexStr.repeat(3), decRegexStr, \" *$\");\n+        Regex face3Regex = Regex.of(\"^ *\", hexOrColorCommaRegexStr, hexCommaRegexStr.repeat(3), \"3\", commaRegexStr, decCommaRegexStr.repeat(2), decRegexStr, \" *$\");\n+\n+        Regex vertexRegex = Regex.of(\"^ *\" + hexCommaRegexStr + hexCommaRegexStr + hexRegexStr + \" *$\");\n+        Regex emptyRegex = Regex.of(\"^ *$\");\n+        Regex remRegex = Regex.of(\"^ *REM(.*)$\");\n+        Regex colonRegex = Regex.of(\"^ *(:) *$\");\n+        Regex facesRegex = Regex.of(\"^ *(faces) *$\");\n+\n+        default String name() {\n@@ -66,8 +68,35 @@\n-        record awaiting_name(Regex r) implements State {}\n-        record awaiting_lazer(Regex r) implements State {}\n-        record awaiting_counts(Regex r) implements State {}\n-        record awaiting_vertices(Regex r) implements State {}\n-        record awaiting_hue_lig_sat(Regex r) implements State {}\n-        record awaiting_faces() implements State { }\n-        record done() implements State {}\n-        awaiting_name awaiting_name = new awaiting_name( Regex.of(\"^ *([A-Za-z][0-9A-Za-z]+) *$\"));\n+\n+        record awaiting_name(Regex r) implements State {\n+        }\n+\n+        record awaiting_lazer(Regex r) implements State {\n+        }\n+\n+        record awaiting_counts(Regex r) implements State {\n+        }\n+\n+        record awaiting_vertices(Regex r) implements State {\n+        }\n+\n+        record awaiting_hue_lig_sat(Regex r) implements State {\n+        }\n+\n+        record awaiting_faces() implements State {\n+            public Regex r() {\n+                return null;\n+            }\n+        }\n+\n+        record done() implements State {\n+            public Regex r() {\n+                return null;\n+            }\n+        }\n+\n+        record none() implements State {\n+            public Regex r() {\n+                return null;\n+            }\n+        }\n+\n+        awaiting_name awaiting_name = new awaiting_name(Regex.of(\"^ *([A-Za-z][0-9A-Za-z]+) *$\"));\n@@ -79,2 +108,44 @@\n-        done done  = new done();\n-        \/\/St[] all = new St[]{awaiting_name, awaiting_lazer, awaiting_counts, awaiting_vertices, awaiting_hue_lig_sat, awaiting_faces};\n+        done done = new done();\n+        none none = new none();\n+\n+        class Machine {\n+            State state = none;\n+\n+            private Machine state(State state) {\n+                \/\/  System.out.println(\"from \" + this.state.name() + \" to \" + state.name());\n+                this.state = state;\n+                return this;\n+            }\n+\n+            Machine() {\n+                state(none);\n+            }\n+\n+            Machine awaiting_name() {\n+                return state(awaiting_name);\n+            }\n+\n+            Machine awaiting_lazer() {\n+                return state(awaiting_lazer);\n+            }\n+\n+            Machine awaiting_counts() {\n+                return state(awaiting_counts);\n+            }\n+\n+            Machine awaiting_vertices() {\n+                return state(awaiting_vertices);\n+            }\n+\n+            Machine awaiting_faces() {\n+                return state(awaiting_faces);\n+            }\n+\n+            Machine awaiting_hue_lig_sat() {\n+                return state(awaiting_hue_lig_sat);\n+            }\n+\n+            Machine done() {\n+                return state(done);\n+            }\n+        }\n@@ -82,0 +153,1 @@\n+\n@@ -94,1 +166,75 @@\n-    static void load(String name) {\n+    record S32xN (Regex regex, Matcher matcher, boolean matched) implements Regex.OK {\n+        S32xN(Regex r, Matcher m) {\n+            this(r, m, true);\n+        }\n+        int count(){\n+            return matcher.groupCount();\n+        }\n+    }\n+\n+    record hex(F32.Vec3 v0,F32.Vec3 v1,F32.Vec3 v2,F32.Vec3 v3,F32.Vec3 v4,F32.Vec3 v5){\n+        static hex of(List<F32.Vec3> vecEntries, S32xN s32xN){\n+            int i6 = s32xN.asInt(6);\n+            int i7 = s32xN.asInt(7);\n+            int i8 = s32xN.asInt(8);\n+            int i9 = s32xN.asInt(9);\n+            int i10 = s32xN.asInt(10);\n+            int i11 = s32xN.asInt(11);\n+            return new hex(\n+                    vecEntries.get(i6),\n+                    vecEntries.get(i7),\n+                    vecEntries.get(i8),\n+                    vecEntries.get(i9),\n+                    vecEntries.get(i10),\n+                    vecEntries.get(i11)\n+            );\n+\n+        }\n+    }\n+    record pent(F32.Vec3 v0,F32.Vec3 v1,F32.Vec3 v2,F32.Vec3 v3,F32.Vec3 v4){\n+        static pent of(List<F32.Vec3> vecEntries, S32xN s32xN){\n+            int i6 = s32xN.asInt(6);\n+            int i7 = s32xN.asInt(7);\n+            int i8 = s32xN.asInt(8);\n+            int i9 = s32xN.asInt(9);\n+            int i10 = s32xN.asInt(10);\n+            return new pent(\n+                    vecEntries.get(i6),\n+                    vecEntries.get(i7),\n+                    vecEntries.get(i8),\n+                    vecEntries.get(i9),\n+                    vecEntries.get(i10)\n+            );\n+\n+        }\n+    }\n+    record quad(F32.Vec3 v0,F32.Vec3 v1,F32.Vec3 v2,F32.Vec3 v3){\n+        static quad of(List<F32.Vec3> vecEntries, S32xN s32xN){\n+            int i6 = s32xN.asInt(6);\n+            int i7 = s32xN.asInt(7);\n+            int i8 = s32xN.asInt(8);\n+            int i9 = s32xN.asInt(9);\n+            return new quad(\n+                    vecEntries.get(i6),\n+                    vecEntries.get(i7),\n+                    vecEntries.get(i8),\n+                    vecEntries.get(i9)\n+            );\n+\n+        }\n+    }\n+    record tri(F32.Vec3 v0,F32.Vec3 v1,F32.Vec3 v2){\n+        static tri of(List<F32.Vec3> vecEntries, S32xN s32xN){\n+            int i6 = s32xN.asInt(6);\n+            int i7 = s32xN.asInt(7);\n+            int i8 = s32xN.asInt(8);\n+            return new tri(\n+                    vecEntries.get(i6),\n+                    vecEntries.get(i7),\n+                    vecEntries.get(i8)\n+            );\n+\n+        }\n+    }\n+\n+    public  void loadOld(String name) {\n@@ -96,1 +242,1 @@\n-        final var st = StreamMutable.of((State) State.awaiting_name);\n+    final var sm = new State.Machine().awaiting_name();\n@@ -102,1 +248,1 @@\n-                    switch(st.get()){\n+                    switch(sm.state){\n@@ -104,1 +250,1 @@\n-                            st.set(State.awaiting_lazer);\n+                            sm.awaiting_lazer();\n@@ -107,10 +253,7 @@\n-                        case State.awaiting_lazer s-> st.setIf(s.r.matches(line), State.awaiting_counts);\n-                        case State.awaiting_counts s-> st.setIf(s.r.matches(line), State.awaiting_vertices);\n-                        case State.awaiting_vertices s-> st.setIf(s.r.matches(line), State.awaiting_faces);\n-                        case State.awaiting_faces _-> {\n-                            if (vertexRegex.is(line,F32x3::new) instanceof F32x3 ok) {\n-                                mesh.get().vec3(ok.f(1), ok.f(2), ok.f(3));\n-                            } else if (facesRegex.matchesOrThrow(line)) {\n-                                st.set(State.awaiting_hue_lig_sat);\n-                            }\n-                        }\n+                        case State.awaiting_lazer s when s.r().matches(line) -> sm.awaiting_counts();\n+                        case State.awaiting_counts s when s.r().matches(line) -> sm.awaiting_vertices();\n+                        case State.awaiting_vertices s when s.r().matches(line) -> sm.awaiting_faces();\n+                        case State.awaiting_faces _ when State.vertexRegex.is(line, F32x3::new) instanceof F32x3 f32x3 ->\n+                                mesh.get().vec3(f32x3.f(1), f32x3.f(2), f32x3.f(3));\n+                        case State.awaiting_faces _ when State.facesRegex.matchesOrThrow(line) ->\n+                                sm.awaiting_hue_lig_sat();\n@@ -118,1 +261,1 @@\n-                            if (Regex.any(line, face6Regex, face5Regex, face4Regex, face3Regex) instanceof Regex.OK ok) {\n+                            if (Regex.any(line, State.face6Regex, State.face5Regex, State.face4Regex, State.face3Regex) instanceof Regex.OK ok) {\n@@ -122,1 +265,1 @@\n-                                if (ok.regex() == face3Regex) {\n+                                if (ok.regex() == State.face3Regex) {\n@@ -124,1 +267,1 @@\n-                                } else if (ok.regex() == face4Regex) {\n+                                } else if (ok.regex() == State.face4Regex) {\n@@ -126,1 +269,1 @@\n-                                } else if (ok.regex() == face5Regex) {\n+                                } else if (ok.regex() == State.face5Regex) {\n@@ -133,2 +276,2 @@\n-                                st.set(State.done);\n-                            }else if (!remRegex.matches(line)){\n+                                sm.done();\n+                            }else if (!State.remRegex.matches(line)){\n@@ -139,1 +282,1 @@\n-                        case State _ when Regex.any(line, remRegex, emptyRegex, colonRegex).matched()->{}\n+                        case State _ when Regex.any(line, State.remRegex, State.emptyRegex, State.colonRegex).matched()->{}\n@@ -144,0 +287,51 @@\n+    public void loadNew(String name) {\n+        final var mesh = StreamMutable.of((F32.Mesh) null);\n+        final var sm = new State.Machine().awaiting_name();\n+        new BufferedReader(\n+                new InputStreamReader(EliteMeshReader.class.getResourceAsStream(\"\/meshes\/Elite.txt\"), StandardCharsets.UTF_8))\n+                .lines()\n+                .map(String::trim)\n+                .forEach(line -> {\n+                    switch (sm.state) {\n+                        case State.awaiting_name s when s.r().matches(line, whoseMatcher ->\n+                                whoseMatcher.group(1).equals(name)) -> {\n+                            sm.awaiting_lazer();\n+                            mesh.set(F32.Mesh.of(name));\n+                        }\n+                        case State.awaiting_lazer s when s.r().matches(line) -> sm.awaiting_counts();\n+                        case State.awaiting_counts s when s.r().matches(line) -> sm.awaiting_vertices();\n+                        case State.awaiting_vertices s when s.r().matches(line) -> sm.awaiting_faces();\n+                        case State.awaiting_faces _ when State.vertexRegex.is(line, F32x3::new) instanceof F32x3 f32x3 ->\n+                                mesh.get().vec3(f32x3.f(1), f32x3.f(2), f32x3.f(3));\n+                        case State.awaiting_faces _ when State.facesRegex.matchesOrThrow(line) ->\n+                                sm.awaiting_hue_lig_sat();\n+                        case State.awaiting_hue_lig_sat _ when State.face6Regex.is(line, S32xN::new) instanceof S32xN s32xN ->{\n+                            var h = hex.of(mesh.get().vecEntries,s32xN);\n+                            mesh.get().hex(h.v0(),h.v1(),h.v2(),h.v3(),h.v4(),h.v5(), 0xfff000);\n+                        }\n+                        case State.awaiting_hue_lig_sat _ when State.face5Regex.is(line, S32xN::new) instanceof S32xN s32xN -> {\n+                            var h = hex.of(mesh.get().vecEntries,s32xN);\n+                            mesh.get().pent(h.v0(),h.v1(),h.v2(),h.v3(),h.v4(), 0xfff000);\n+                        }\n+                        case State.awaiting_hue_lig_sat _ when State.face4Regex.is(line,S32xN::new) instanceof S32xN s32xN ->{\n+                            var h = quad.of(mesh.get().vecEntries,s32xN);\n+                            mesh.get().quad(h.v0(),h.v1(),h.v2(),h.v3(), 0xfff000);\n+                        }\n+                        case State.awaiting_hue_lig_sat _ when State.face3Regex.is(line, S32xN::new) instanceof S32xN s32xN -> {\n+                            var h = tri.of(mesh.get().vecEntries,s32xN);\n+                            mesh.get().tri(h.v0(),h.v1(),h.v2(), 0xfff000);\n+                        }\n+                        case State.awaiting_hue_lig_sat s when s.r().matches(line) -> {\n+                            mesh.get().fin();\n+                            sm.done();\n+                        }\n+                        case State.awaiting_hue_lig_sat _ when !State.remRegex.matches(line) ->\n+                                System.out.println(\"UNHANDLED \" + line);\n+                        case State.done _ -> {\n+                        }\n+                        case State _ when Regex.any(line, State.remRegex, State.emptyRegex, State.colonRegex).matched() -> {\n+                        }\n+                        case State _ -> {\/*no state change*\/ }\n+                    }\n+                });\n+    }\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/EliteMeshReader.java","additions":244,"deletions":50,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -0,0 +1,1135 @@\n+package view;\n+\n+import java.awt.Image;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public interface F32 {\n+    static Vec3 mulMat4(Vec3 vec3, Mat4x4 m4) {\n+        var o = Vec3.of(\n+                vec3.x() * m4.x0y0() + vec3.y() * m4.x0y1() + vec3.z() * m4.x0y2() + m4.x0y3(),\n+                vec3.x() * m4.x1y0() + vec3.y() * m4.x1y1() + vec3.z() * m4.x1y2() + m4.x1y3(),\n+                vec3.x() * m4.x2y0() + vec3.y() * m4.x2y1() + vec3.z() * m4.x2y2() + m4.x2y3()\n+        );\n+\n+        float w = vec3.x() * m4.x3y0() + vec3.y() * m4.x3y1() + vec3.z() * m4.x3y2() + m4.x3y3();\n+        if (w != 0.0) {\n+            o = divScaler(o, w);\n+        }\n+        return o;\n+    }\n+\n+    static Vec3 divScaler(Vec3 vec3, float s) {\n+        return Vec3.of(vec3.x() \/ s, vec3.y() \/ s, vec3.z() \/ s);\n+    }\n+\n+    static Vec3 add(Vec3 lhs, Vec3 rhs) {\n+        return Vec3.of(lhs.x() + rhs.x(), lhs.y() + rhs.y(), lhs.z() + rhs.z());\n+    }\n+\n+    static Vec3 sub(Vec3 lhs, Vec3 rhs) {\n+        return Vec3.of(lhs.x() - rhs.x(), lhs.y() - rhs.y(), lhs.z() - rhs.z());\n+    }\n+\n+    static float sumOfSquares(Vec3 vec3) {\n+        return vec3.x() * vec3.x() + vec3.y() * vec3.y() + vec3.z() * vec3.z();\n+    }\n+\n+    static Vec3 xprod(Vec3 lhs, Vec3 rhs) {\n+        return Vec3.of(\n+                lhs.y() * rhs.z() - lhs.z() * rhs.x(),\n+                lhs.z() * rhs.x() - lhs.x() * rhs.z(),\n+                lhs.x() * rhs.y() - lhs.y() * rhs.x());\n+\n+    }\n+\n+    static float dotprod(Vec3 lhs, Vec3 rhs) {\n+        return lhs.x() * rhs.x() + lhs.y() * rhs.y() + lhs.z() * rhs.z();\n+    }\n+\n+    static TriangleVec3 mul(TriangleVec3 triangleVec3, Mat4x4 m4) {\n+\n+        return TriangleVec3.of(mulMat4(triangleVec3.v0(), m4), mulMat4(triangleVec3.v1(), m4), mulMat4(triangleVec3.v2(), m4), triangleVec3.rgb());\n+    }\n+\n+    static TriangleVec3 add(TriangleVec3 triangleVec3, Vec3 v3) {\n+        return TriangleVec3.of(add(triangleVec3.v0(), v3), add(triangleVec3.v1(), v3), add(triangleVec3.v2(), v3), triangleVec3.rgb());\n+    }\n+\n+    static Vec3 center(TriangleVec3 triangleVec3) {\n+        return divScaler(vectorSum(triangleVec3), 3);\n+    }\n+\n+    static Vec3 vectorSum(TriangleVec3 triangleVec3) {\n+        return add(add(triangleVec3.v0(), triangleVec3.v1()), triangleVec3.v2());\n+    }\n+\n+    static Vec3 normal(TriangleVec3 triangleVec3) {\n+        return xprod(sub(triangleVec3.v1(), triangleVec3.v0()), sub(triangleVec3.v2(), triangleVec3.v0()));\n+    }\n+\n+    interface Mat4x4 {\n+        float x0y0();\n+\n+        float x1y0();\n+\n+        float x2y0();\n+\n+        float x3y0();\n+\n+        float x0y1();\n+\n+        float x1y1();\n+\n+        float x2y1();\n+\n+        float x3y1();\n+\n+        float x0y2();\n+\n+        float x1y2();\n+\n+        float x2y2();\n+\n+        float x3y2();\n+\n+        float x0y3();\n+\n+        float x1y3();\n+\n+        float x2y3();\n+\n+        float x3y3();\n+\n+        interface Mutable extends Mat4x4 {\n+            void x0y0(float x0y0);\n+\n+            void x1y0(float x1y0);\n+\n+            void x2y0(float x2y0);\n+\n+            void x3y0(float x3y0);\n+\n+            void x0y1(float x0y1);\n+\n+            void x1y1(float x1y1);\n+\n+            void x2y1(float x2y1);\n+\n+            void x3y1(float x3y1);\n+\n+            void x0y2(float x0y2);\n+\n+            void x1y2(float x1y2);\n+\n+            void x2y2(float x2y2);\n+\n+            void x3y2(float x3y2);\n+\n+            void x0y3(float x0y3);\n+\n+            void x1y3(float x1y3);\n+\n+            void x2y3(float x2y3);\n+\n+            void x3y3(float x3y3);\n+        }\n+\n+\n+\n+        \/\/  https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380\n+        static Impl mul(Mat4x4 lhs, Mat4x4 rhs) {\n+            return new Impl(\n+                    lhs.x0y0() * rhs.x0y0() + lhs.x1y0() * rhs.x0y1() + lhs.x2y0() * rhs.x0y2() + lhs.x3y0() * rhs.x0y3(),\n+                    lhs.x0y0() * rhs.x1y0() + lhs.x1y0() * rhs.x1y1() + lhs.x2y0() * rhs.x1y2() + lhs.x3y0() * rhs.x1y3(),\n+                    lhs.x0y0() * rhs.x2y0() + lhs.x1y0() * rhs.x2y1() + lhs.x2y0() * rhs.x2y2() + lhs.x3y0() * rhs.x2y3(),\n+                    lhs.x0y0() * rhs.x3y0() + lhs.x1y0() * rhs.x3y1() + lhs.x2y0() * rhs.x3y2() + lhs.x3y0() * rhs.x3y3(),\n+\n+                    lhs.x0y1() * rhs.x0y0() + lhs.x1y1() * rhs.x0y1() + lhs.x2y1() * rhs.x0y2() + lhs.x3y1() * rhs.x0y3(),\n+                    lhs.x0y1() * rhs.x1y0() + lhs.x1y1() * rhs.x1y1() + lhs.x2y1() * rhs.x1y2() + lhs.x3y1() * rhs.x1y3(),\n+                    lhs.x0y1() * rhs.x2y0() + lhs.x1y1() * rhs.x2y1() + lhs.x2y1() * rhs.x2y2() + lhs.x3y1() * rhs.x2y3(),\n+                    lhs.x0y1() * rhs.x3y0() + lhs.x1y1() * rhs.x3y1() + lhs.x2y1() * rhs.x3y2() + lhs.x3y1() * rhs.x3y3(),\n+\n+                    lhs.x0y2() * rhs.x0y0() + lhs.x1y2() * rhs.x0y1() + lhs.x2y2() * rhs.x0y2() + lhs.x3y2() * rhs.x0y3(),\n+                    lhs.x0y2() * rhs.x1y0() + lhs.x1y2() * rhs.x1y1() + lhs.x2y2() * rhs.x1y2() + lhs.x3y2() * rhs.x1y3(),\n+                    lhs.x0y2() * rhs.x2y0() + lhs.x1y2() * rhs.x2y1() + lhs.x2y2() * rhs.x2y2() + lhs.x3y2() * rhs.x2y3(),\n+                    lhs.x0y2() * rhs.x3y0() + lhs.x1y2() * rhs.x3y1() + lhs.x2y2() * rhs.x3y2() + lhs.x3y2() * rhs.x3y3(),\n+\n+                    lhs.x0y3() * rhs.x0y0() + lhs.x1y3() * rhs.x0y1() + lhs.x2y3() * rhs.x0y2() + lhs.x3y3() * rhs.x0y3(),\n+                    lhs.x0y3() * rhs.x1y0() + lhs.x1y3() * rhs.x1y1() + lhs.x2y3() * rhs.x1y2() + lhs.x3y3() * rhs.x1y3(),\n+                    lhs.x0y3() * rhs.x2y0() + lhs.x1y3() * rhs.x2y1() + lhs.x2y3() * rhs.x2y2() + lhs.x3y3() * rhs.x2y3(),\n+                    lhs.x0y3() * rhs.x3y0() + lhs.x1y3() * rhs.x3y1() + lhs.x2y3() * rhs.x3y2() + lhs.x3y3() * rhs.x3y3()\n+\n+            );\n+        }\n+\n+\n+        static String asString(Mat4x4 mat4X4) {\n+\n+            return String.format(\"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n+                            \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n+                            \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\" +\n+                            \"|%5.2f, %5.2f, %5.2f, %5.2f|\\n\",\n+                    mat4X4.x0y0(), mat4X4.x1y0(), mat4X4.x2y0(), mat4X4.x3y0(),\n+                    mat4X4.x0y1(), mat4X4.x1y1(), mat4X4.x2y1(), mat4X4.x3y1(),\n+                    mat4X4.x0y2(), mat4X4.x1y2(), mat4X4.x2y2(), mat4X4.x3y2(),\n+                    mat4X4.x0y3(), mat4X4.x1y3(), mat4X4.x2y3(), mat4X4.x3y3());\n+        }\n+\n+\n+        class Impl implements Mat4x4 {\n+\n+            float x0y0;\n+\n+            @Override\n+            public float x0y0() {\n+                return x0y0;\n+            }\n+\n+            float x0y1;\n+\n+            @Override\n+            public float x0y1() {\n+                return x0y1;\n+            }\n+\n+            float x0y2;\n+\n+            @Override\n+            public float x0y2() {\n+                return x0y2;\n+            }\n+\n+            float x0y3;\n+\n+            @Override\n+            public float x0y3() {\n+                return x0y3;\n+            }\n+\n+            float x1y0;\n+\n+            @Override\n+            public float x1y0() {\n+                return x1y0;\n+            }\n+\n+            float x1y1;\n+\n+            @Override\n+            public float x1y1() {\n+                return x1y1;\n+            }\n+\n+            float x1y2;\n+\n+            @Override\n+            public float x1y2() {\n+                return x1y2;\n+            }\n+\n+            float x1y3;\n+\n+            @Override\n+            public float x1y3() {\n+                return x1y3;\n+            }\n+\n+            float x2y0;\n+\n+            @Override\n+            public float x2y0() {\n+                return x2y0;\n+            }\n+\n+            float x2y1;\n+\n+            @Override\n+            public float x2y1() {\n+                return x2y1;\n+            }\n+\n+            float x2y2;\n+\n+            @Override\n+            public float x2y2() {\n+                return x2y2;\n+            }\n+\n+            float x2y3;\n+\n+            @Override\n+            public float x2y3() {\n+                return x2y3;\n+            }\n+\n+            float x3y0;\n+\n+            @Override\n+            public float x3y0() {\n+                return x3y0;\n+            }\n+\n+            float x3y1;\n+\n+            @Override\n+            public float x3y1() {\n+                return x3y1;\n+            }\n+\n+            float x3y2;\n+\n+            @Override\n+            public float x3y2() {\n+                return x3y2;\n+            }\n+\n+            float x3y3;\n+\n+            @Override\n+            public float x3y3() {\n+                return x3y3;\n+            }\n+\n+            Impl(float x0y0, float x1y0, float x2y0, float x3y0,\n+                 float x0y1, float x1y1, float x2y1, float x3y1,\n+                 float x0y2, float x1y2, float x2y2, float x3y2,\n+                 float x0y3, float x1y3, float x2y3, float x3y3) {\n+                this.x0y0 = x0y0;\n+                this.x1y0 = x1y0;\n+                this.x2y0 = x2y0;\n+                this.x3y0 = x3y0;\n+                this.x0y1 = x0y1;\n+                this.x1y1 = x1y1;\n+                this.x2y1 = x2y1;\n+                this.x3y1 = x3y1;\n+                this.x0y2 = x0y2;\n+                this.x1y2 = x1y2;\n+                this.x2y2 = x2y2;\n+                this.x3y2 = x3y2;\n+                this.x0y3 = x0y3;\n+                this.x1y3 = x1y3;\n+                this.x2y3 = x2y3;\n+                this.x3y3 = x3y3;\n+            }\n+        }\n+\n+        class MutableImpl extends Impl implements Mutable {\n+\n+            @Override\n+            public void x0y0(float x0y0) {\n+                this.x0y0 = x0y0;\n+            }\n+\n+            @Override\n+            public void x0y1(float x0y1) {\n+                this.x0y1 = x0y1;\n+            }\n+\n+            @Override\n+            public void x0y2(float x0y2) {\n+                this.x0y2 = x0y2;\n+            }\n+\n+            @Override\n+            public void x0y3(float x0y3) {\n+                this.x0y3 = x0y3;\n+            }\n+\n+            @Override\n+            public void x1y0(float x1y0) {\n+                this.x1y0 = x1y0;\n+            }\n+\n+            @Override\n+            public void x1y1(float x1y1) {\n+                this.x1y1 = x1y1;\n+            }\n+\n+            @Override\n+            public void x1y2(float x1y2) {\n+                this.x1y2 = x1y2;\n+            }\n+\n+            @Override\n+            public void x1y3(float x1y3) {\n+                this.x1y3 = x1y3;\n+            }\n+\n+            @Override\n+            public void x2y0(float x2y0) {\n+                this.x2y0 = x2y0;\n+            }\n+\n+            @Override\n+            public void x2y1(float x2y1) {\n+                this.x2y1 = x2y1;\n+            }\n+\n+            @Override\n+            public void x2y2(float x2y2) {\n+                this.x2y2 = x2y2;\n+            }\n+\n+            @Override\n+            public void x2y3(float x2y3) {\n+                this.x2y3 = x2y3;\n+            }\n+\n+            @Override\n+            public void x3y0(float x3y0) {\n+                this.x3y0 = x3y0;\n+            }\n+\n+            @Override\n+            public void x3y1(float x3y1) {\n+                this.x3y1 = x3y1;\n+            }\n+\n+            @Override\n+            public void x3y2(float x3y2) {\n+                this.x3y2 = x3y2;\n+            }\n+\n+            @Override\n+            public void x3y3(float x3y3) {\n+                this.x3y3 = x3y3;\n+            }\n+\n+            MutableImpl(float x0y0, float x1y0, float x2y0, float x3y0,\n+                        float x0y1, float x1y1, float x2y1, float x3y1,\n+                        float x0y2, float x1y2, float x2y2, float x3y2,\n+                        float x0y3, float x1y3, float x2y3, float x3y3) {\n+                super(x0y0, x1y0, x2y0, x3y0,\n+                        x0y1, x1y1, x2y1, x3y1,\n+                        x0y2, x1y2, x2y2, x3y2,\n+                        x0y3, x1y3, x2y3, x3y3);\n+            }\n+        }\n+\n+\n+        \/\/https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n+        record Transformation(float x0y0, float x1y0, float x2y0, float x3y0,\n+                              float x0y1, float x1y1, float x2y1, float x3y1,\n+                              float x0y2, float x1y2, float x2y2, float x3y2,\n+                              float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n+            public Transformation(float x, float y, float z) {\n+                this(1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, x, y, z, 1f);\n+            }\n+\n+            public static Transformation of(float v) {\n+                return new Transformation(v, v, v);\n+            }\n+        }\n+\n+        \/\/ https:\/\/medium.com\/swlh\/understanding-3d-matrix-transforms-with-pixijs-c76da3f8bd8\n+\n+        record Scale(float x0y0, float x1y0, float x2y0, float x3y0,\n+                     float x0y1, float x1y1, float x2y1, float x3y1,\n+                     float x0y2, float x1y2, float x2y2, float x3y2,\n+                     float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n+            Scale(float x, float y, float z) {\n+                this(x, 0f, 0f, 0f, 0f, y, 0f, 0f, 0f, 0f, z, 0f, 0f, 0f, 0f, 1f);\n+            }\n+\n+            public static Scale of(float v) {\n+                return new Scale(v, v, v);\n+            }\n+        }\n+\n+        record Rotation(float x0y0, float x1y0, float x2y0, float x3y0,\n+                        float x0y1, float x1y1, float x2y1, float x3y1,\n+                        float x0y2, float x1y2, float x2y2, float x3y2,\n+                        float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n+\n+            static Rotation ofX(float thetaRadians) {\n+                float sinTheta = (float) Math.sin(thetaRadians);\n+                float cosTheta = (float) Math.cos(thetaRadians);\n+                return new Rotation(1, 0, 0, 0, 0, cosTheta, -sinTheta, 0, 0, sinTheta, cosTheta, 0, 0, 0, 0, 1);\n+            }\n+\n+            static Rotation ofZ(float thetaRadians) {\n+                float sinTheta = (float) Math.sin(thetaRadians);\n+                float cosTheta = (float) Math.cos(thetaRadians);\n+                return new Rotation(cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n+            }\n+\n+            static Rotation ofY(float thetaRadians) {\n+                float sinTheta = (float) Math.sin(thetaRadians);\n+                float cosTheta = (float) Math.cos(thetaRadians);\n+                return new Rotation(cosTheta, 0, sinTheta, 0, 0, 1, 0, 0, -sinTheta, 0, cosTheta, 0, 0, 0, 0, 1);\n+            }\n+\n+            public static Rotation of(float thetaX, float thetaY, float thetaZ) {\n+                var m4 = Mat4x4.mul(Mat4x4.mul(ofX(thetaX), ofY(thetaY)), ofZ(thetaZ));\n+                return new Rotation(m4.x0y0(), m4.x1y0(), m4.x2y0(), m4.x3y0(), m4.x0y1(), m4.x1y1(), m4.x2y1(), m4.x3y1(), m4.x0y2(), m4.x1y2(), m4.x2y2(), m4.x3y2(), m4.x0y3(), m4.x1y3(), m4.x2y3(), m4.x3y3());\n+            }\n+        }\n+\n+        \/*\n+                     https:\/\/youtu.be\/ih20l3pJoeU?t=973\n+                     https:\/\/stackoverflow.com\/questions\/28075743\/how-do-i-compose-a-rotation-matrix-with-human-readable-angles-from-scratch\/28084380#28084380^\n+                    --------------------            far\n+                     \\                \/              ^    ^\n+                      \\              \/               |    |   far-near\n+                       \\            \/                |    |\n+                        \\__________\/         near    |    v\n+                                              ^      |\n+                                              v      v\n+                            \\^\/\n+                          [x,y,z]\n+\n+                   *\/\n+        record Projection(float x0y0, float x1y0, float x2y0, float x3y0,\n+                          float x0y1, float x1y1, float x2y1, float x3y1,\n+                          float x0y2, float x1y2, float x2y2, float x3y2,\n+                          float x0y3, float x1y3, float x2y3, float x3y3) implements Mat4x4 {\n+\n+            static Projection of(float width, float height, float near, float far, float fieldOfViewDeg) {\n+                float aspectRatio = height \/ width;\n+                float fieldOfViewRadians = (float) (1.0f \/ Math.tan((fieldOfViewDeg * 0.5f) \/ 180.0 * Math.PI));\n+                return new Projection(\n+                        aspectRatio * fieldOfViewRadians, 0f, 0f, 0f,\n+                        0f, fieldOfViewRadians, 0f, 0f,\n+                        0f, 0f, far \/ (far - near), (-far * near) \/ (far - near),\n+                        0f, 0f, (-far * near) \/ (far - near), 0f);\n+\n+            }\n+\n+            public static Projection of(Image image, float nearZ, float farZ, float fieldOfViewDeg) {\n+                return of(image.getWidth(null), image.getHeight(null), nearZ, farZ, fieldOfViewDeg);\n+            }\n+        }\n+\n+    }\n+\n+    interface TriangleVec2 {\n+        List<TriangleVec2> arr = new ArrayList<>();\n+\n+        Vec2 v0();\n+\n+        void v0(Vec2 v0);\n+\n+        Vec2 v1();\n+\n+        void v1(Vec2 v1);\n+\n+        Vec2 v2();\n+\n+        void v2(Vec2 v2);\n+\n+        int rgb();\n+\n+        void rgb(int rgb);\n+\n+        class Impl implements TriangleVec2 {\n+            Vec2 v0, v1, v2;\n+            int rgb;\n+\n+            @Override\n+            public Vec2 v0() {\n+                return v0;\n+            }\n+\n+            @Override\n+            public void v0(Vec2 v0) {\n+                this.v0 = v0;\n+            }\n+\n+            @Override\n+            public Vec2 v1() {\n+                return v1;\n+            }\n+\n+            @Override\n+            public void v1(Vec2 v1) {\n+                this.v1 = v1;\n+            }\n+\n+            @Override\n+            public Vec2 v2() {\n+                return v2;\n+            }\n+\n+            @Override\n+            public void v2(Vec2 v2) {\n+                this.v2 = v2;\n+            }\n+\n+            @Override\n+            public int rgb() {\n+                return rgb;\n+            }\n+\n+            @Override\n+            public void rgb(int rgb) {\n+                this.rgb = rgb;\n+            }\n+\n+            Impl(Vec2 v0, Vec2 v1, Vec2 v2, int rgb) {\n+                v0(v0);\n+                v1(v1);\n+                v2(v2);\n+                rgb(rgb);\n+            }\n+        }\n+\n+        static float side(float x, float y, float x0, float y0, float x1, float y1) {\n+            return (y1 - y0) * (x - x0) + (-x1 + x0) * (y - y0);\n+        }\n+\n+        static float side(Vec2 v, Vec2 v0, Vec2 v1) {\n+\n+            return (v1.y() - v0.y() * (v.x() - v0.x()) + (-v1.x() + v0.x()) * (v.y() - v0.y()));\n+        }\n+\n+        static boolean intriangle(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {\n+            return side(x, y, x0, y0, x1, y1) >= 0 && side(x, y, x1, y1, x2, y2) >= 0 && side(x, y, x2, y2, x0, y0) >= 0;\n+        }\n+\n+        static boolean intriangle(Vec2 v, Vec2 v0, Vec2 v1, Vec2 v2) {\n+            return side(v, v0, v1) >= 0 && side(v, v1, v2) >= 0 && side(v, v2, v0) >= 0;\n+        }\n+\n+        static boolean online(float x, float y, float x0, float y0, float x1, float y1, float deltaSquare) {\n+            float dxl = x1 - x0;\n+            float dyl = y1 - y0;\n+            float cross = (x - x0) * dyl - (y - y0) * dxl;\n+            if ((cross * cross) < deltaSquare) {\n+                if (dxl * dxl >= dyl * dyl)\n+                    return dxl > 0 ? x0 <= x && x <= x1 : x1 <= x && x <= x0;\n+                else\n+                    return dyl > 0 ? y0 <= y && y <= y1 : y1 <= y && y <= y0;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        float deltaSquare = 10000f;\n+\n+        static boolean onedge(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2) {\n+            return online(x, y, x0, y0, x1, y1, deltaSquare) || TriangleVec2.online(x, y, x1, y1, x2, y2, deltaSquare) || TriangleVec2.online(x, y, x2, y2, x0, y0, deltaSquare);\n+        }\n+\n+\n+        static Impl of(int x0, int y0, int x1, int y1, int x2, int y2, int col) {\n+            var impl = side(x0, y0, x1, y1, x2, y2) > 0 \/\/ We need the triangle to be clock wound\n+                    ? new Impl(Vec2.of(x0, y0), Vec2.of(x1, y1), Vec2.of(x2, y2), col)\n+                    : new Impl(Vec2.of(x0, y0), Vec2.of(x2, y2), Vec2.of(x1, y1), col);\n+            arr.add(impl);\n+            return impl;\n+        }\n+\n+    }\n+\n+    interface TriangleVec3 {\n+\n+        List<TriangleVec3> arr = new ArrayList<>();\n+\n+        Vec3 v0();\n+\n+        void v0(Vec3 v0);\n+\n+        Vec3 v1();\n+\n+        void v1(Vec3 v1);\n+\n+        Vec3 v2();\n+\n+        void v2(Vec3 v2);\n+\n+        int rgb();\n+\n+        void rgb(int rgb);\n+\n+\n+\n+         \/*\n+           v0----v1         v0----v2\n+            \\    |           \\    |\n+             \\   |            \\   |\n+              \\  |    --->     \\  |\n+               \\ |              \\ |\n+                \\|               \\|\n+                 v2               v1\n+       *\/\n+\n+        static void rewind(TriangleVec3 triangleVec3) {\n+            Vec3 temp = triangleVec3.v1();\n+            triangleVec3.v1(triangleVec3.v2());\n+            triangleVec3.v2(temp);\n+        }\n+\n+        static TriangleVec3 of(Vec3 v0, Vec3 v1, Vec3 v2, int rgb) {\n+            var impl = new Impl(v0, v1, v2, rgb);\n+            arr.add(impl);\n+            return impl;\n+        }\n+\n+        static String asString(TriangleVec3 triangleVec3) {\n+            return Vec3.asString(triangleVec3.v0()) + \" -> \" + Vec3.asString(triangleVec3.v1()) + \" -> \" + Vec3.asString(triangleVec3.v2()) + \" =\" + String.format(\"0x%8x\", triangleVec3.rgb());\n+        }\n+\n+\n+        class Impl implements TriangleVec3 {\n+            Vec3 v0, v1, v2;\n+            int rgb;\n+\n+            @Override\n+            public Vec3 v0() {\n+                return v0;\n+            }\n+\n+            @Override\n+            public void v0(Vec3 v0) {\n+                this.v0 = v0;\n+            }\n+\n+            @Override\n+            public Vec3 v1() {\n+                return v1;\n+            }\n+\n+            @Override\n+            public void v1(Vec3 v1) {\n+                this.v1 = v1;\n+            }\n+\n+            @Override\n+            public Vec3 v2() {\n+                return v2;\n+            }\n+\n+            @Override\n+            public void v2(Vec3 v2) {\n+                this.v2 = v2;\n+            }\n+\n+            @Override\n+            public int rgb() {\n+                return rgb;\n+            }\n+\n+            @Override\n+            public void rgb(int rgb) {\n+                this.rgb = rgb;\n+            }\n+\n+            Impl(Vec3 v0, Vec3 v1, Vec3 v2, int rgb) {\n+                v0(v0);\n+                v1(v1);\n+                v2(v2);\n+                rgb(rgb);\n+            }\n+\n+        }\n+    }\n+\n+    interface Vec2 {\n+        float x();\n+\n+        void x(float x);\n+\n+        float y();\n+\n+        void y(float y);\n+\n+        class Impl implements Vec2 {\n+            float x, y;\n+\n+            @Override\n+            public float x() {\n+                return x;\n+            }\n+\n+            @Override\n+            public void x(float x) {\n+                this.x = x;\n+            }\n+\n+            @Override\n+            public float y() {\n+                return y;\n+            }\n+\n+            @Override\n+            public void y(float y) {\n+                this.y = y;\n+            }\n+\n+            Impl(float x, float y) {\n+                x(x);\n+                y(y);\n+            }\n+        }\n+\n+        static Impl of(float x, float y) {\n+            return new Impl(x, y);\n+        }\n+\n+    }\n+\n+    interface Vec3 {\n+\n+        float x();\n+\n+        void x(float x);\n+\n+        float y();\n+\n+        void y(float y);\n+\n+        float z();\n+\n+        void z(float z);\n+\n+        static Vec3 of(float x, float y, float z) {\n+            return new Impl(z, y, z);\n+        }\n+\n+\n+        \/*\n+            lhs= | 1|   rhs= | 2|\n+                 | 3|        | 7|\n+                 | 4|        |-5|\n+\n+            lhs xprod rhs = | x  y  z| =  | 3  4|x - | 1  4|y  | 1  3|\n+                            | 1  3  4|    | 7 -5|    | 2 -5|   | 2  7|\n+                            | 2  7 -5|\n+\n+                          = (-15-28)x - (-5 -8)y + (7 - 6)z\n+\n+                          = -43x - (-13)y +1z\n+                          = -43x + 14y +z\n+\n+         *\/\n+\n+        \/*\n+            lhs= | 1|   rhs= | 2|\n+                 | 3|        | 7|\n+                 | 4|        |-5|\n+\n+            lhs0*rhs0 + lhs1*rhs1 + lhs2*rhs2\n+             1  * 2   +  3  * 7   +  4  *-5\n+\n+                3     +    21     +   -20\n+\n+                           4\n+\n+         *\/\n+\n+        static String asString(Vec3 vec3) {\n+            return vec3.x() + \",\" + vec3.y() + \",\" + vec3.z();\n+        }\n+\n+\n+        class Impl implements Vec3 {\n+            float x, y, z;\n+\n+            @Override\n+            public float x() {\n+                return x;\n+            }\n+\n+            @Override\n+            public void x(float x) {\n+                this.x = x;\n+            }\n+\n+            @Override\n+            public float y() {\n+                return y;\n+            }\n+\n+            @Override\n+            public void y(float y) {\n+                this.y = y;\n+            }\n+\n+            @Override\n+            public float z() {\n+                return z;\n+            }\n+\n+            @Override\n+            public void z(float z) {\n+                this.z = z;\n+            }\n+\n+            Impl(float x, float y, float z) {\n+                x(x);\n+                y(y);\n+                z(z);\n+            }\n+        }\n+    }\n+\n+    class Mesh {\n+        String name;\n+\n+        Vec3 triSum;\n+\n+        private Mesh(String name) {\n+            this.name = name;\n+        }\n+\n+        public static Mesh of(String name) {\n+            return new Mesh(name);\n+        }\n+\n+\n+        public record triInfo(TriangleVec3 tri, Vec3 centre, Vec3 normal, Vec3 v0) {\n+            static triInfo of(TriangleVec3 tri) {\n+                return new triInfo(tri, F32.center(tri), F32.normal(tri), tri.v0());\n+            }\n+        }\n+\n+        public List<triInfo> triInfos = new ArrayList<>();\n+        public List<Vec3> vecEntries = new ArrayList<>();\n+\n+        public void tri(Vec3 v0, Vec3 v1, Vec3 v2, int rgb) {\n+            var trii = triInfo.of(TriangleVec3.of(v0, v1, v2, rgb));\n+            triSum = (triInfos.isEmpty()) ? trii.centre() : add(triSum, trii.centre());\n+            triInfos.add(trii);\n+\n+        }\n+\n+        public void fin() {\n+            Vec3 meshCenterVec3 = divScaler(triSum, triInfos.size());\n+            for (int t = 0; t < triInfos.size(); t++) {\n+                var trii = triInfos.get(t);\n+                var v0CenterDiff = sub(meshCenterVec3, trii.centre);\n+                float normDotProd = dotprod(v0CenterDiff, trii.normal);\n+                if (normDotProd > 0f) { \/\/ the normal from the center from the triangle was pointing out, so re wind it\n+                    TriangleVec3.rewind(trii.tri);\n+                }\n+            }\n+            cube(meshCenterVec3.x(), meshCenterVec3.y(), meshCenterVec3.z(), .1f);\n+        }\n+\n+        public Mesh quad(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, int rgb) {\n+      \/*\n+           v0-----v1\n+            |\\    |\n+            | \\   |\n+            |  \\  |\n+            |   \\ |\n+            |    \\|\n+           v3-----v2\n+       *\/\n+\n+            tri(v0, v1, v2, rgb);\n+            tri(v0, v2, v3, rgb);\n+            return this;\n+        }\n+\n+        public Mesh pent(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, Vec3 v4, int rgb) {\n+      \/*\n+           v0-----v1\n+           |\\    | \\\n+           | \\   |  \\\n+           |  \\  |   v2\n+           |   \\ |  \/\n+           |    \\| \/\n+           v4-----v3\n+       *\/\n+\n+            tri(v0, v1, v3, rgb);\n+            tri(v1, v2, v3, rgb);\n+            tri(v0, v3, v4, rgb);\n+            return this;\n+        }\n+\n+        public Mesh hex(Vec3 v0, Vec3 v1, Vec3 v2, Vec3 v3, Vec3 v4, Vec3 v5, int rgb) {\n+      \/*\n+           v0-----v1\n+          \/ |\\    | \\\n+         \/  | \\   |  \\\n+        v5  |  \\  |   v2\n+         \\  |   \\ |  \/\n+          \\ |    \\| \/\n+           v4-----v3\n+       *\/\n+\n+            tri(v0, v1, v3, rgb);\n+            tri(v1, v2, v3, rgb);\n+            tri(v0, v3, v4, rgb);\n+            tri(v0, v4, v5, rgb);\n+            return this;\n+        }\n+\n+\n+        \/*\n+                   a-----------d\n+                  \/|          \/|\n+                 \/ |         \/ |\n+               h------------g  |\n+               |   |        |  |\n+               |   b--------|--c\n+               |  \/         | \/\n+               | \/          |\/\n+               e------------f\n+\n+         *\/\n+\n+\n+        public Mesh cube(\n+                float x,\n+                float y,\n+                float z,\n+                float s) {\n+            var a = vec3(x - (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/000  000 111 111\n+            var b = vec3(x - (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/010  010 101 101\n+            var c = vec3(x + (s * .5f), y + (s * .5f), z - (s * .5f));  \/\/110  011 001 100\n+            var d = vec3(x + (s * .5f), y - (s * .5f), z - (s * .5f));  \/\/100  001 011 110\n+            var e = vec3(x - (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/011  110 100 001\n+            var f = vec3(x + (s * .5f), y + (s * .5f), z + (s * .5f));  \/\/111  111 000 000\n+            var g = vec3(x + (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/101  101 010 010\n+            var h = vec3(x - (s * .5f), y - (s * .5f), z + (s * .5f));  \/\/001  100 110 011\n+            quad(a, b, c, d, 0xff0000); \/\/front\n+            quad(b, e, f, c, 0x0000ff); \/\/top\n+            quad(d, c, f, g, 0xffff00); \/\/right\n+            quad(h, e, b, a, 0xffffff); \/\/left\n+            quad(g, f, e, h, 0x00ff00);\/\/back\n+            quad(g, h, a, d, 0xffa500);\/\/bottom\n+            return this;\n+        }\n+\n+\n+        \/*\n+        http:\/\/paulbourke.net\/dataformats\/obj\/\n+         *\/\n+        public Mesh cubeoctahedron(\n+                float x,\n+                float y,\n+                float z,\n+                float s) {\n+\n+            var v1 = vec3(x + (s * .30631559f), y + (s * .20791225f), z + (s * .12760004f));\n+            var v2 = vec3(x + (s * .12671047f), y + (s * .20791227f), z + (s * .30720518f));\n+            var v3 = vec3(x + (s * .12671045f), y + (s * .38751736f), z + (s * .12760002f));\n+            var v4 = vec3(x + (s * .30631556f), y + (s * .20791227f), z + (s * .48681026f));\n+            var v5 = vec3(x + (s * .48592068f), y + (s * .20791225f), z + (s * .30720514f));\n+            var v6 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .48681026f));\n+            var v7 = vec3(x + (s * .12671047f), y + (s * .56712254f), z + (s * .30720512f));\n+            var v8 = vec3(x + (s * .12671042f), y + (s * .3875174f), z + (s * .48681026f));\n+            var v9 = vec3(x + (s * .48592068f), y + (s * .38751736f), z + (s * .1276f));\n+            var v10 = vec3(x + (s * .30631556f), y + (s * .56712254f), z + (s * .1276f));\n+            var v11 = vec3(x + (s * .48592068f), y + (s * .56712254f), z + (s * .30720512f));\n+            var v12 = vec3(x + (s * .48592068f), y + (s * .38751743f), z + (s * .4868103f));\n+\n+            tri(v1, v2, v3, 0xff0000);\n+            tri(v4, v2, v5, 0x7f8000);\n+            tri(v5, v2, v1, 0x3fc000);\n+            tri(v6, v7, v8, 0x1fe000);\n+            tri(v9, v10, v11, 0x0ff000);\n+            tri(v8, v2, v4, 0x07f800);\n+            tri(v5, v1, v9, 0x03fc00);\n+            tri(v3, v7, v10, 0x01fe00);\n+            tri(v8, v7, v2, 0x00ff00);\n+            tri(v2, v7, v3, 0x007f80);\n+            tri(v8, v4, v6, 0x003fc0);\n+            tri(v6, v4, v12, 0x001fe0);\n+            tri(v11, v12, v9, 0x000ff0);\n+            tri(v9, v12, v5, 0x0007f8);\n+            tri(v7, v6, v10, 0x0003fc);\n+            tri(v6, v11, v10, 0x0001fe);\n+            tri(v1, v3, v9, 0x0000ff);\n+            tri(v9, v3, v10, 0x00007f);\n+            tri(v12, v4, v5, 0x00003f);\n+            tri(v6, v12, v11, 0x00001f);\n+            return this;\n+        }\n+\n+\n+        public Mesh rubric(float s) {\n+            for (int x = -1; x < 2; x++) {\n+                for (int y = -1; y < 2; y++) {\n+                    for (int z = -1; z < 2; z++) {\n+                        cube(x * .5f, y * .5f, z * .5f, s);\n+                    }\n+                }\n+            }\n+            return this;\n+        }\n+\n+        public Vec3 vec3(float x, float y, float z) {\n+            vecEntries.add(Vec3.of(x, y, z));\n+            return vecEntries.getLast();\n+        }\n+    }\n+\n+    class ZPos implements Comparable<ZPos> {\n+        public enum ColourMode {NORMALIZED_COLOUR, NORMALIZED_INV_COLOUR, COLOUR, NORMALIZED_WHITE, NORMALIZED_INV_WHITE, WHITE}\n+        public static final ColourMode colourMode = ColourMode.COLOUR;\n+\n+        int x0, y0, x1, y1, x2, y2;\n+        float z0, z1, z2;\n+        float z;\n+        float howVisible;\n+        int rgb;\n+\n+        @Override\n+        public int compareTo(ZPos zPos) {\n+            return Float.compare(z, zPos.z);\n+        }\n+\n+        ZPos(TriangleVec3 t, float howVisible) {\n+            Vec3 v0 = t.v0();\n+            Vec3 v1 = t.v1();\n+            Vec3 v2 = t.v2();\n+            x0 = (int) v0.x();\n+            y0 = (int) v0.y();\n+            z0 = v0.z();\n+            x1 = (int) v1.x();\n+            y1 = (int) v1.y();\n+            z1 = v1.z();\n+            x2 = (int) v2.x();\n+            y2 = (int) v2.y();\n+            z2 = v2.z();\n+            this.rgb = t.rgb();\n+            this.howVisible = howVisible;\n+            z = Math.min(z0, Math.min(z1, z2));\n+        }\n+\n+\n+        TriangleVec2 create() {\n+            int r = ((rgb & 0xff0000) >> 16);\n+            int g = ((rgb & 0x00ff00) >> 8);\n+            int b = ((rgb & 0x0000ff) >> 0);\n+\n+            if (colourMode == ColourMode.NORMALIZED_COLOUR) {\n+                r = r - (int) (20 * howVisible);\n+                g = g - (int) (20 * howVisible);\n+                b = b - (int) (20 * howVisible);\n+            } else if (colourMode == ColourMode.NORMALIZED_INV_COLOUR) {\n+                r = r + (int) (20 * howVisible);\n+                g = g + (int) (20 * howVisible);\n+                b = b + (int) (20 * howVisible);\n+            } else if (colourMode == ColourMode.NORMALIZED_WHITE) {\n+                r = g = b = (int) (0x7f - (20 * howVisible));\n+            } else if (colourMode == ColourMode.NORMALIZED_INV_WHITE) {\n+                r = g = b = (int) (0x7f + (20 * howVisible));\n+            } else if (colourMode == ColourMode.WHITE) {\n+                r = g = b = 0xff;\n+            }\n+            return TriangleVec2.of(x0, y0, x1, y1, x2, y2, (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff));\n+        }\n+    }\n+\n+    record ModelHighWaterMark(\n+            int markedTriangles3D,\n+            int markedTriangles2D,\n+            int markedVec2,\n+            int markedVec3,\n+            int markedMat4) {\n+\n+        ModelHighWaterMark() {\n+            this(TriangleVec3.arr.size(), 0, 0,0,0);\n+        }\n+\n+        void resetAll() {\n+            TriangleVec3.arr.clear();\n+        }\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/F32.java","additions":1135,"deletions":0,"binary":false,"changes":1135,"status":"added"},{"patch":"@@ -47,15 +47,23 @@\n-       \/\/ args.add(\"COBRA\");\n-        var viewFrame = (args.size() > 0 )\n-                ? ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Renderer.DisplayMode.WIRE), () ->\n-                    EliteMeshReader.load(args.getFirst())\n-                )\n-                : ViewFrame.of(\"view\", Rasterizer.of(View.of(1024, 1024), Renderer.DisplayMode.FILL), () -> {\n-                     for (int x = -2; x < 6; x += 2) {\n-                         for (int y = -2; y < 6; y += 2) {\n-                             for (int z = -2; z < 6; z += 2) {\n-                                 F32Mesh3D.of(\"cubeoctahedron\").cubeoctahedron(x, y, z, 2).fin();\n-                             }\n-                         }\n-                     }\n-                });\n-\n+        \/\/ args.add(\"COBRA\");\n+        var eliteReader = new EliteMeshReader();\n+        boolean old =true;\/\/ Boolean.getBoolean(\"old\");\n+        var v = View.of(1024, 1024);\n+        var wire = Rasterizer.of(v, Renderer.DisplayMode.WIRE);\n+        var fill = Rasterizer.of(v, Renderer.DisplayMode.FILL);\n+        Runnable cubeoctahedron =  () -> {\n+            for (int x = -2; x < 6; x += 2) {\n+                for (int y = -2; y < 6; y += 2) {\n+                    for (int z = -2; z < 6; z += 2) {\n+                        if (old) {\n+                            F32Mesh3D.of(\"cubeoctahedron\").cubeoctahedron(x, y, z, 2).fin();\n+                        }else{\n+                            F32.Mesh.of(\"cubeoctahedron\").cubeoctahedron(x, y, z, 2).fin();\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+        Runnable elite = old?()->eliteReader.loadOld(args.getFirst()): ()->eliteReader.loadNew(args.getFirst());\n+        var viewFrame = old ?\n+                (args.size() > 0 ? ViewFrameOld.of(\"view\", wire, elite): ViewFrameOld.of(\"view\", fill,cubeoctahedron))\n+                : ((args.size() > 0) ? ViewFrameNew.of(\"view\", wire,elite) : ViewFrameNew.of(\"view\",fill, cubeoctahedron));\n@@ -66,1 +74,0 @@\n-\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Main.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package view;\n-\n-public interface  Physics {\n-    float thetaDelta = 0.0002f;\n-\n-\n-}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Physics.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -44,1 +44,1 @@\n-    private void accept(int gid) {\n+    private void accept(int gid, boolean old) {\n@@ -48,14 +48,27 @@\n-        for (int t = 0; t < F32Triangle2D.pool.count; t++) {\n-            int v0 =  F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V0];\n-            int v1 = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V1];\n-            int v2 = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V2];\n-            float x0 = F32Vec2.pool.entries[v0 * F32Vec2.pool.stride + F32Vec2.X];\n-            float y0 = F32Vec2.pool.entries[v0 * F32Vec2.pool.stride + F32Vec2.Y];\n-            float x1 = F32Vec2.pool.entries[v1 * F32Vec2.pool.stride + F32Vec2.X];\n-            float y1 = F32Vec2.pool.entries[v1 * F32Vec2.pool.stride + F32Vec2.Y];\n-            float x2 = F32Vec2.pool.entries[v2 * F32Vec2.pool.stride + F32Vec2.X];\n-            float y2 = F32Vec2.pool.entries[v2 * F32Vec2.pool.stride + F32Vec2.Y];\n-            if (displayMode.filled && F32Triangle2D.intriangle(x, y, x0, y0, x1, y1, x2, y2)) {\n-                col = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.RGB];\n-            } else if (displayMode.wire && F32Triangle2D.onedge(x, y, x0, y0, x1, y1, x2, y2)) {\n-                col = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.RGB];\n+        if (old){\n+            for (int t = 0; t < F32Triangle2D.pool.count; t++) {\n+                int v0 =  F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V0];\n+                int v1 = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V1];\n+                int v2 = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.V2];\n+                float x0 = F32Vec2.pool.entries[v0 * F32Vec2.pool.stride + F32Vec2.X];\n+                float y0 = F32Vec2.pool.entries[v0 * F32Vec2.pool.stride + F32Vec2.Y];\n+                float x1 = F32Vec2.pool.entries[v1 * F32Vec2.pool.stride + F32Vec2.X];\n+                float y1 = F32Vec2.pool.entries[v1 * F32Vec2.pool.stride + F32Vec2.Y];\n+                float x2 = F32Vec2.pool.entries[v2 * F32Vec2.pool.stride + F32Vec2.X];\n+                float y2 = F32Vec2.pool.entries[v2 * F32Vec2.pool.stride + F32Vec2.Y];\n+                if (displayMode.filled && F32Triangle2D.intriangle(x, y, x0, y0, x1, y1, x2, y2)) {\n+                    col = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.RGB];\n+                } else if (displayMode.wire && F32Triangle2D.onedge(x, y, x0, y0, x1, y1, x2, y2)) {\n+                    col = F32Triangle2D.pool.entries[F32Triangle2D.pool.stride * t + F32Triangle2D.RGB];\n+                }\n+            }\n+        }else {\n+            for (F32.TriangleVec2 t : F32.TriangleVec2.arr) {\n+                var v0 = t.v0();\n+                var v1 = t.v1();\n+                var v2 = t.v2();\n+                if (displayMode.filled && F32.TriangleVec2.intriangle(x, y, v0.x(), v0.y(), v1.x(), v1.y(), v2.x(), v2.y())) {\n+                    col = t.rgb();\n+                } else if (displayMode.wire && F32.TriangleVec2.onedge(x, y, v0.x(), v0.y(), v1.x(), v1.y(), v2.x(), v2.y())) {\n+                    col = t.rgb();\n+                }\n@@ -67,2 +80,2 @@\n-    public void render() {\n-        IntStream.range(0, view.image.getHeight()*view.image.getWidth()).parallel().forEach(this::accept);\n+    public void render(boolean old) {\n+        IntStream.range(0, view.image.getHeight() * view.image.getWidth()).parallel().forEach(id->accept(id,old));\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Rasterizer.java","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    void render();\n+    void render(boolean old);\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/Renderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import view.f32.F32Matrix4x4;\n-import view.f32.F32Triangle3D;\n-import view.f32.F32Vec3;\n-import view.f32.Pool;\n-import view.f32.F32Vec2;\n-\n@@ -48,2 +42,6 @@\n-public class ViewFrame extends JFrame {\n-    private final Renderer renderer;\n+import static view.F32.dotprod;\n+import static view.F32.normal;\n+import static view.F32.sub;\n+\n+public abstract class ViewFrame extends JFrame {\n+    final Renderer renderer;\n@@ -52,1 +50,1 @@\n-    private final JComponent viewer;\n+    final JComponent viewer;\n@@ -55,9 +53,7 @@\n-    final F32Vec3.vec3 cameraVec3;\n-    final F32Vec3.vec3 lookDirVec3;\n-    final F32Matrix4x4.Projection projF32Mat4x4;\n-    final F32Vec3.vec3 centerVec3;\n-    final F32Vec3.vec3 moveAwayVec3;\n-\n-    ModelHighWaterMark mark;\n-\n-    private ViewFrame(String name, Renderer renderer, Runnable sceneBuilder) {\n+    void ringDoorBell(Point point) {\n+        this.point = point;\n+        synchronized (doorBell) {\n+            doorBell.notify();\n+        }\n+    }\n+    ViewFrame(String name, Renderer renderer, Runnable sceneBuilder) {\n@@ -95,0 +91,1 @@\n+          }\n@@ -96,9 +93,0 @@\n-        cameraVec3 = F32Vec3.vec3.of(0f, 0f, .0f);\n-        lookDirVec3 = F32Vec3.vec3.of(0f, 0f, 0f);\n-        F32Matrix4x4.Projection projF32Mat4x4_1 = F32Matrix4x4.Projection.of(renderer.view().image, 0.1f, 1000f, 60f);\n-        Pool.Idx projF32Mat4x4_2 = F32Matrix4x4.mulMat4(projF32Mat4x4_1.id(), F32Matrix4x4.Scale.of(renderer.view().image.getHeight() \/ 4f).id());\n-        projF32Mat4x4 = F32Matrix4x4.Projection.of(F32Matrix4x4.mulMat4(projF32Mat4x4_2, F32Matrix4x4.Transformation.of(renderer.view().image.getHeight() \/ 2f).id()));\n-        centerVec3 = F32Vec3.vec3.of(renderer.view().image.getWidth() \/ 2f,  renderer.view().image.getHeight() \/ 2f, 0);\n-        moveAwayVec3 = F32Vec3.vec3.of(0f, 0f, 30f);\n-        mark = new ModelHighWaterMark(); \/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n-    }\n@@ -106,3 +94,1 @@\n-    public static ViewFrame of(String name, Renderer renderer, Runnable sceneBuilder){\n-        return new ViewFrame(name, renderer,sceneBuilder);\n-    }\n+    static final float thetaDelta = 0.0002f;\n@@ -110,32 +96,1 @@\n-    Point waitForPoint(long timeout) {\n-        while (point == null) {\n-            synchronized (doorBell) {\n-                try {\n-                    if (timeout > 0) {\n-                        doorBell.wait(timeout);\n-                    }\n-                    update();\n-                } catch (final InterruptedException ie) {\n-                    ie.getStackTrace();\n-                }\n-            }\n-        }\n-        Point returnPoint = point;\n-        point = null;\n-        return returnPoint;\n-    }\n-\n-    void ringDoorBell(Point point) {\n-        this.point = point;\n-        synchronized (doorBell) {\n-            doorBell.notify();\n-        }\n-    }\n-\n-    void update() {\n-        final long elapsedMillis = System.currentTimeMillis() - startMillis;\n-        float theta = elapsedMillis * Physics.thetaDelta;\n-\n-        if ((frames++ % 50) == 0) {\n-            System.out.println(\"Frames \" + frames + \" Theta = \" + theta + \" FPS = \" + ((frames * 1000) \/ elapsedMillis) + \" Vertices \" + F32Vec2.pool.count);\n-        }\n+    abstract void  update();\n@@ -143,62 +98,0 @@\n-        mark.resetAll();\n-\n-        var xyzRot4x4 = new F32Matrix4x4.Rotation(theta * 2, theta \/ 2, theta);\n-\n-        ModelHighWaterMark resetMark = new ModelHighWaterMark();\n-\n-        List<ZPos> zpos = new ArrayList<>();\n-        \/\/ Loop through the triangles\n-        boolean showHidden = renderer.displayMode() == Renderer.DisplayMode.WIRE_SHOW_HIDDEN;\n-\n-        for (F32Triangle3D.tri t : F32Triangle3D.tri.all()) {\n-            \/\/ here we rotate and then move into the Z plane.\n-            t = t.mul(xyzRot4x4).add(moveAwayVec3);\n-            float howVisible = 1f;\n-            boolean isVisible = showHidden;\n-\n-            if (!showHidden) {\n-                \/\/ here we determine whether the camera can see the plane that the translated triangle is on.\n-                \/\/ so we need the normal to the triangle in the coordinate system\n-\n-                \/\/ Now we work out where the camera is relative to a line projected from the plane to the camera\n-                \/\/ if camera is at 0,0,0 clearly this is a no-op\n-\n-                \/\/ We need a point on the triangle it looks like assume we can use any, I choose the center of the triangle\n-                \/\/ intuition suggests the one with the minimal Z is best no?\n-\n-                \/\/ We subtract the camera from our point on the triangle so we can compare\n-\n-                F32Vec3.vec3 cameraDeltaVec3 = t.center().sub(cameraVec3); \/\/ clearly our default camera is 0,0,0\n-\n-                \/\/  howVisible = cameraDeltaVec3.mul( t.normalSumOfSquares()).sumOf();\n-                howVisible = cameraDeltaVec3.dotProd(t.normal());\n-                \/\/ howVisible is a 'scalar'\n-                \/\/ it's magnitude indicating how much it is 'facing away from' the camera.\n-                \/\/ it's sign indicates if the camera can indeed see the location.\n-                isVisible = howVisible < 0.0;\n-            }\n-\n-            if (isVisible) {\n-                \/\/ Projected triangle is still in unit 1 space!!\n-                \/\/ now project the 3d triangle to 2d plane.\n-                \/\/ Scale up to quarter screen height then add half height of screen\n-\n-                t = t.mul(projF32Mat4x4);\/\/  projection matrix also scales to screen and translate half a screen\n-\n-                zpos.add(new ZPos(t, howVisible));\n-            }\n-\n-            resetMark.reset3D(); \/\/ do not move this up.\n-        }\n-\n-\n-        Collections.sort(zpos);\n-\n-        for (ZPos z : zpos) {\n-            z.create();\n-        }\n-\n-        renderer.render();\n-\n-        viewer.repaint();\n-    }\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ViewFrame.java","additions":17,"deletions":124,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package view;\n+\n+import view.f32.F32Matrix4x4;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static view.F32.normal;\n+import static view.F32.dotprod;\n+import static view.F32.sub;\n+\n+public class ViewFrameNew extends ViewFrame {\n+\n+    final F32.Vec3 cameraVec3;\n+    final F32.Vec3 lookDirVec3;\n+    final F32.Mat4x4 projF32Mat4x4;\n+    final F32.Vec3 centerVec3;\n+    final F32.Vec3 moveAwayVec3;\n+\n+    F32.ModelHighWaterMark mark;\n+\n+    private ViewFrameNew(String name, Renderer renderer, Runnable sceneBuilder) {\n+        super(name,  renderer, sceneBuilder);\n+\n+\n+        cameraVec3 = F32.Vec3.of(0f, 0f, .0f);\n+        lookDirVec3 = F32.Vec3.of(0f, 0f, 0f);\n+        var projF32Mat4x4_1 = F32.Mat4x4.Projection.of(renderer.view().image, 0.1f, 1000f, 60f);\n+        var projF32Mat4x4_2 = F32.Mat4x4.mul(projF32Mat4x4_1, F32.Mat4x4.Scale.of(renderer.view().image.getHeight() \/ 4f));\n+        projF32Mat4x4 = F32.Mat4x4.mul(projF32Mat4x4_2, F32.Mat4x4.Transformation.of(renderer.view().image.getHeight() \/ 2f));\n+        centerVec3 = F32.Vec3.of(renderer.view().image.getWidth() \/ 2f,  renderer.view().image.getHeight() \/ 2f, 0);\n+        moveAwayVec3 = F32.Vec3.of(0f, 0f, 30f);\n+        mark = new F32.ModelHighWaterMark(); \/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n+    }\n+\n+    public static ViewFrameNew of(String name, Renderer renderer, Runnable sceneBuilder){\n+        return new ViewFrameNew(name, renderer,sceneBuilder);\n+    }\n+\n+ @Override\n+    void update() {\n+        final long elapsedMillis = System.currentTimeMillis() - startMillis;\n+        float theta = elapsedMillis * thetaDelta;\n+\n+        if ((frames++ % 50) == 0) {\n+            System.out.println(\"Frames \" + frames + \" Theta = \" + theta + \" FPS = \" + ((frames * 1000) \/ elapsedMillis) );\n+        }\n+\n+    \/\/    mark.resetAll();\n+\n+        var xyzRot4x4 =  F32.Mat4x4.Rotation.of(theta * 2, theta \/ 2, theta);\n+     var xyzRot4x4Old = new F32Matrix4x4.Rotation(theta * 2, theta \/ 2, theta);\n+\n+      \/\/  F32.ModelHighWaterMark resetMark = new F32.ModelHighWaterMark();\n+\n+        List<F32.ZPos> zpos = new ArrayList<>();\n+        \/\/ Loop through the triangles\n+        boolean showHidden = renderer.displayMode() == Renderer.DisplayMode.WIRE_SHOW_HIDDEN;\n+\n+        int end= F32.TriangleVec3.arr.size();\n+        for (int i=0; i< end; i++) {\n+            var t = F32.TriangleVec3.arr.get(i);\n+            \/\/ here we rotate and then move into the Z plane.\n+            t = F32.mul(t,xyzRot4x4);\n+            t = F32.add(t,moveAwayVec3);\n+            float howVisible = 1f;\n+            boolean isVisible = showHidden;\n+\n+            if (!showHidden) {\n+                \/\/ here we determine whether the camera can see the plane that the translated triangle is on.\n+                \/\/ so we need the normal to the triangle in the coordinate system\n+\n+                \/\/ Now we work out where the camera is relative to a line projected from the plane to the camera\n+                \/\/ if camera is at 0,0,0 clearly this is a no-op\n+\n+                \/\/ We need a point on the triangle it looks like assume we can use any, I choose the center of the triangle\n+                \/\/ intuition suggests the one with the minimal Z is best no?\n+\n+                \/\/ We subtract the camera from our point on the triangle so we can compare\n+\n+                F32.Vec3 cameraDeltaVec3 = sub(F32.center(t),cameraVec3); \/\/ clearly our default camera is 0,0,0\n+\n+                \/\/  howVisible = cameraDeltaVec3.mul( t.normalSumOfSquares()).sumOf();\n+                howVisible = dotprod(cameraDeltaVec3,normal(t));\n+                \/\/ howVisible is a 'scalar'\n+                \/\/ it's magnitude indicating how much it is 'facing away from' the camera.\n+                \/\/ it's sign indicates if the camera can indeed see the location.\n+                isVisible = howVisible < 0.0;\n+            }\n+\n+            if (isVisible) {\n+                \/\/ Projected triangle is still in unit 1 space!!\n+                \/\/ now project the 3d triangle to 2d plane.\n+                \/\/ Scale up to quarter screen height then add half height of screen\n+\n+                t = F32.mul(t,projF32Mat4x4);\/\/  projection matrix also scales to screen and translate half a screen\n+\n+                zpos.add(new F32.ZPos(t, howVisible));\n+            }\n+\n+           \/\/ resetMark.reset3D(); \/\/ do not move this up.\n+        }\n+\n+\n+        Collections.sort(zpos);\n+List<F32.TriangleVec2> ztri= new ArrayList<>();\n+        for (F32.ZPos z : zpos) {\n+            ztri.add(z.create());\n+        }\n+\n+        renderer.render(false);\n+\n+        viewer.repaint();\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ViewFrameNew.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package view;\n+\n+import view.f32.F32Matrix4x4;\n+import view.f32.F32Triangle3D;\n+import view.f32.F32Vec3;\n+import view.f32.Pool;\n+import view.f32.F32Vec2;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class ViewFrameOld extends ViewFrame {\n+\n+    final F32Vec3.vec3 cameraVec3;\n+    final F32Vec3.vec3 lookDirVec3;\n+    final F32Matrix4x4.Projection projF32Mat4x4;\n+    final F32Vec3.vec3 centerVec3;\n+    final F32Vec3.vec3 moveAwayVec3;\n+\n+    ModelHighWaterMark mark;\n+\n+    private ViewFrameOld(String name, Renderer renderer, Runnable sceneBuilder) {\n+        super(name,renderer,sceneBuilder);\n+\n+\n+        cameraVec3 = F32Vec3.vec3.of(0f, 0f, .0f);\n+        lookDirVec3 = F32Vec3.vec3.of(0f, 0f, 0f);\n+        F32Matrix4x4.Projection projF32Mat4x4_1 = F32Matrix4x4.Projection.of(renderer.view().image, 0.1f, 1000f, 60f);\n+        Pool.Idx projF32Mat4x4_2 = F32Matrix4x4.mulMat4(projF32Mat4x4_1.id(), F32Matrix4x4.Scale.of(renderer.view().image.getHeight() \/ 4f).id());\n+        projF32Mat4x4 = F32Matrix4x4.Projection.of(F32Matrix4x4.mulMat4(projF32Mat4x4_2, F32Matrix4x4.Transformation.of(renderer.view().image.getHeight() \/ 2f).id()));\n+        centerVec3 = F32Vec3.vec3.of(renderer.view().image.getWidth() \/ 2f,  renderer.view().image.getHeight() \/ 2f, 0);\n+        moveAwayVec3 = F32Vec3.vec3.of(0f, 0f, 30f);\n+        mark = new ModelHighWaterMark(); \/\/ mark all buffers.  transforms create new points so this allows us to garbage colect\n+    }\n+\n+    public static ViewFrameOld of(String name, Renderer renderer, Runnable sceneBuilder){\n+        return new ViewFrameOld(name, renderer,sceneBuilder);\n+    }\n+@Override\n+    void update() {\n+        final long elapsedMillis = System.currentTimeMillis() - startMillis;\n+        float theta = elapsedMillis * thetaDelta;\n+\n+        if ((frames++ % 50) == 0) {\n+            System.out.println(\"Frames \" + frames + \" Theta = \" + theta + \" FPS = \" + ((frames * 1000) \/ elapsedMillis) + \" Vertices \" + F32Vec2.pool.count);\n+        }\n+\n+        mark.resetAll();\n+\n+        var xyzRot4x4 = new F32Matrix4x4.Rotation(theta * 2, theta \/ 2, theta);\n+\n+        ModelHighWaterMark resetMark = new ModelHighWaterMark();\n+\n+        List<ZPos> zpos = new ArrayList<>();\n+        \/\/ Loop through the triangles\n+        boolean showHidden = renderer.displayMode() == Renderer.DisplayMode.WIRE_SHOW_HIDDEN;\n+\n+        for (F32Triangle3D.tri t : F32Triangle3D.tri.all()) {\n+            \/\/ here we rotate and then move into the Z plane.\n+            t = t.mul(xyzRot4x4).add(moveAwayVec3);\n+            float howVisible = 1f;\n+            boolean isVisible = showHidden;\n+\n+            if (!showHidden) {\n+                \/\/ here we determine whether the camera can see the plane that the translated triangle is on.\n+                \/\/ so we need the normal to the triangle in the coordinate system\n+\n+                \/\/ Now we work out where the camera is relative to a line projected from the plane to the camera\n+                \/\/ if camera is at 0,0,0 clearly this is a no-op\n+\n+                \/\/ We need a point on the triangle it looks like assume we can use any, I choose the center of the triangle\n+                \/\/ intuition suggests the one with the minimal Z is best no?\n+\n+                \/\/ We subtract the camera from our point on the triangle so we can compare\n+\n+                F32Vec3.vec3 cameraDeltaVec3 = t.center().sub(cameraVec3); \/\/ clearly our default camera is 0,0,0\n+\n+                \/\/  howVisible = cameraDeltaVec3.mul( t.normalSumOfSquares()).sumOf();\n+                howVisible = cameraDeltaVec3.dotProd(t.normal());\n+                \/\/ howVisible is a 'scalar'\n+                \/\/ it's magnitude indicating how much it is 'facing away from' the camera.\n+                \/\/ it's sign indicates if the camera can indeed see the location.\n+                isVisible = howVisible < 0.0;\n+            }\n+\n+            if (isVisible) {\n+                \/\/ Projected triangle is still in unit 1 space!!\n+                \/\/ now project the 3d triangle to 2d plane.\n+                \/\/ Scale up to quarter screen height then add half height of screen\n+\n+                t = t.mul(projF32Mat4x4);\/\/  projection matrix also scales to screen and translate half a screen\n+\n+                zpos.add(new ZPos(t, howVisible));\n+            }\n+\n+            resetMark.reset3D(); \/\/ do not move this up.\n+        }\n+\n+\n+        Collections.sort(zpos);\n+\n+        for (ZPos z : zpos) {\n+            z.create();\n+        }\n+\n+        renderer.render(true);\n+\n+        viewer.repaint();\n+    }\n+}\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/ViewFrameOld.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}