{"files":[{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.OpHelper;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Stream;\n-\n-public class HATPhaseUtils {\n-\n-    public record VectorMetaData(TypeElement vectorTypeElement, int lanes) {\n-    }\n-\n-    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, int param) {\n-        Value varValue = invokeOp.operands().get(param);\n-        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return getVectorTypeInfoWithCodeReflection(lookup,varLoadOp.resultType());\n-        }\n-        return null;\n-    }\n-\n-    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp) {\n-        return getVectorTypeInfoWithCodeReflection(lookup,invokeOp.resultType());\n-    }\n-    public static TypeElement getVectorElementType(String primitive) {\n-        return switch (primitive) {\n-            case \"float\" -> JavaType.FLOAT;\n-            case \"double\" -> JavaType.DOUBLE;\n-            case \"int\" -> JavaType.INT;\n-            case \"long\" -> JavaType.LONG;\n-            case \"short\" -> JavaType.SHORT;\n-            case \"byte\" -> JavaType.BYTE;\n-            case \"char\" -> JavaType.CHAR;\n-            case \"boolean\" -> JavaType.BOOLEAN;\n-            default -> null;\n-        };\n-    }\n-\n-    \/**\n-     * This method inspects the Vector Type Methods to obtain two methods for code-model:\n-     * 1) Method `type` to obtain the primitive base type of the vector type.\n-     * 2) Method `width` to obtain the number of lanes.\n-     *\n-     * @param typeElement\n-     *  {@link TypeElement}\n-     * @return\n-     * {@link VectorMetaData}\n-     *\/\n-    public static VectorMetaData getVectorTypeInfoWithCodeReflection(MethodHandles.Lookup lookup,TypeElement typeElement) {\n-        Class<?> clazz = (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n-        CoreOp.FuncOp codeModelType = buildCodeModelFor(clazz, \"type\");\n-        AtomicReference<TypeElement> vectorElement = new AtomicReference<>();\n-        codeModelType.elements().forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n-                Value v = returnOp.operands().getFirst();\n-                if (v instanceof Op.Result r && r.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                    String primitiveTypeName = fieldLoadOp.fieldDescriptor().name();\n-                    vectorElement.set(getVectorElementType(primitiveTypeName.toLowerCase()));\n-                }\n-            }\n-        });\n-\n-        AtomicInteger lanes = new AtomicInteger(1);\n-        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(clazz, \"width\");\n-        codeModelWidth.elements().forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n-                Value v = returnOp.operands().getFirst();\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp constantOp) {\n-                    lanes.set((Integer) constantOp.value());\n-                }\n-            }\n-        });\n-        return new VectorMetaData(vectorElement.get(), lanes.get());\n-    }\n-\n-\n-    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n-        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n-                .filter(m -> m.getName().equals(methodName))\n-                .findFirst();\n-        return Op.ofMethod(methodFunction.get()).get();\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -105,1 +105,0 @@\n-            \/\/this.elementType = typeElement;\n@@ -112,1 +111,0 @@\n-           \/\/ this.elementType = op.elementType;\n@@ -116,5 +114,0 @@\n-      \/\/  @Override\n-        \/\/public TypeElement resultType() {\n-          \/\/  return this.elementType;\n-       \/\/ }\n-\n@@ -126,1 +119,0 @@\n-\n@@ -196,1 +188,0 @@\n-            \/\/this.typeElement = typeElement;\n@@ -198,1 +189,0 @@\n-           \/\/ this.vectorType = vectorType;\n@@ -204,1 +194,0 @@\n-            \/\/this.typeElement = op.typeElement;\n@@ -206,1 +195,0 @@\n-           \/\/ this.vectorType = op.vectorType;\n@@ -215,5 +203,0 @@\n-       \/\/ @Override\n-      \/\/  public TypeElement resultType() {\n-        \/\/    return typeElement;\n-       \/\/ }\n-\n@@ -231,2 +214,0 @@\n-\n-       \/\/ private final TypeElement typeElement;\n@@ -237,1 +218,0 @@\n-           \/\/ this.typeElement = typeElement;\n@@ -243,1 +223,0 @@\n-           \/\/ this.typeElement = op.typeElement;\n@@ -252,5 +231,0 @@\n-       \/\/ @Override\n-       \/\/ public TypeElement resultType() {\n-         \/\/   return typeElement;\n-       \/\/ }\n-\n@@ -262,1 +236,0 @@\n-\n@@ -266,2 +239,0 @@\n-\n-      \/\/  private final TypeElement typeElement;\n@@ -272,1 +243,0 @@\n-        \/\/    this.typeElement = typeElement;\n@@ -278,1 +248,0 @@\n-          \/\/  this.typeElement = op.typeElement;\n@@ -286,6 +255,0 @@\n-\n-       \/\/ @Override\n-       \/\/ public TypeElement resultType() {\n-         \/\/   return typeElement;\n-       \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import hat.types._V;\n@@ -35,1 +34,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -66,1 +64,2 @@\n-                            var hatVectorBinaryOp = invoke.copyLocationTo(buildVectorBinaryOp(\n+                            var hatVectorBinaryOp = invoke.copyLocationTo(HATPhaseUtils.buildVectorBinaryOp(\n+                                    lookup(),\n@@ -77,1 +76,1 @@\n-                        } else if (isBufferArray(invoke.op()) && invoke.resultFromFirstOperandOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n+                        } else if (HATPhaseUtils.isBufferArray(invoke.op()) && invoke.resultFromFirstOperandOrNull() instanceof Op.Result result) { \/\/ ensures we can use iop as key for replaced vvv\n@@ -87,1 +86,1 @@\n-                        if (isBufferInitialize(varOp) && OpHelper.resultFromFirstOperandOrThrow(varOp) instanceof Op.Result result) {\n+                        if (HATPhaseUtils.isBufferInitialize(varOp) && OpHelper.resultFromFirstOperandOrThrow(varOp) instanceof Op.Result result) {\n@@ -92,1 +91,1 @@\n-                        } else if (isVectorOp(varOp)) {\n+                        } else if (HATPhaseUtils.isVectorOp(lookup(),varOp)) {\n@@ -108,1 +107,1 @@\n-                        if ((isBufferInitialize(varLoadOp)) && OpHelper.resultFromFirstOperandOrThrow(varLoadOp) instanceof Op.Result r) {\n+                        if ((HATPhaseUtils.isBufferInitialize(varLoadOp)) && OpHelper.resultFromFirstOperandOrThrow(varLoadOp) instanceof Op.Result r) {\n@@ -110,1 +109,1 @@\n-                                Op.Result replacement = (isLocalSharedOrPrivate(varLoadOp)) ?\n+                                Op.Result replacement = (HATPhaseUtils.isLocalSharedOrPrivate(varLoadOp)) ?\n@@ -131,1 +130,1 @@\n-                        if (isBufferArray(arrayLoadOp) && resultFromFirstOperandOrNull(arrayLoadOp) instanceof Op.Result r) {\n+                        if (HATPhaseUtils.isBufferArray(arrayLoadOp) && resultFromFirstOperandOrNull(arrayLoadOp) instanceof Op.Result r) {\n@@ -133,1 +132,1 @@\n-                            if (isVectorOp(arrayLoadOp)) {\n+                            if (HATPhaseUtils.isVectorOp(lookup(),arrayLoadOp)) {\n@@ -146,1 +145,1 @@\n-                                        isLocalSharedOrPrivate(arrayLoadOp),\n+                                        HATPhaseUtils.isLocalSharedOrPrivate(arrayLoadOp),\n@@ -151,1 +150,1 @@\n-                                var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                                var arrayAccessInfo = HATPhaseUtils.arrayAccessInfo(op.result(), replaced);\n@@ -168,1 +167,1 @@\n-                        if (isBufferArray(arrayStoreOp) && OpHelper.resultFromFirstOperandOrThrow(arrayStoreOp) instanceof Op.Result r) {\n+                        if (HATPhaseUtils.isBufferArray(arrayStoreOp) && OpHelper.resultFromFirstOperandOrThrow(arrayStoreOp) instanceof Op.Result r) {\n@@ -170,1 +169,1 @@\n-                            if (isVectorOp(arrayStoreOp)) {\n+                            if (HATPhaseUtils.isVectorOp(lookup(),arrayStoreOp)) {\n@@ -172,1 +171,1 @@\n-                                        findOpInResultFromFirstOperandsOrThrow(((Op.Result) arrayStoreOp.operands().getLast()).op(), CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class);\n+                                        HATPhaseUtils.findOpInResultFromFirstOperandsOrThrow(((Op.Result) arrayStoreOp.operands().getLast()).op(), CoreOp.VarOp.class, HATVectorOp.HATVectorVarOp.class);\n@@ -187,1 +186,1 @@\n-                                        isLocalSharedOrPrivate(arrayStoreOp),\n+                                        HATPhaseUtils.isLocalSharedOrPrivate(arrayStoreOp),\n@@ -192,1 +191,1 @@\n-                                var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                                var arrayAccessInfo = HATPhaseUtils.arrayAccessInfo(op.result(), replaced);\n@@ -210,2 +209,2 @@\n-                        isBufferArray(arrayLengthOp) && OpHelper.resultFromFirstOperandOrThrow(arrayLengthOp) instanceof Op.Result ->{\n-                            var arrayAccessInfo = arrayAccessInfo(op.result(), replaced);\n+                        HATPhaseUtils.isBufferArray(arrayLengthOp) && OpHelper.resultFromFirstOperandOrThrow(arrayLengthOp) instanceof Op.Result ->{\n+                            var arrayAccessInfo = HATPhaseUtils.arrayAccessInfo(op.result(), replaced);\n@@ -267,61 +266,0 @@\n-    static ArrayAccessInfo arrayAccessInfo(Value value, Map<Op.Result, Op.Result> replaced) {\n-        return expressionGraph(value).getInfo(replaced);\n-    }\n-\n-    static Node<Value> expressionGraph(Value value) {\n-        return expressionGraph(new HashMap<>(), value);\n-    }\n-\n-    static Node<Value> expressionGraph(Map<Value, Node<Value>> visited, Value value) {\n-        \/\/ If value has already been visited return its node\n-        if (visited.containsKey(value)) {\n-            return visited.get(value);\n-        }\n-\n-        \/\/ Find the expression graphs for each operand\n-        List<Node<Value>> edges = new ArrayList<>();\n-\n-        \/\/ looks like\n-        for (Value operand : value.dependsOn()) {\n-            if (operand instanceof Op.Result res &&\n-                    res.op() instanceof JavaOp.InvokeOp iop\n-                    && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")){\n-                continue;\n-            }\n-            edges.add(expressionGraph(operand));\n-        }\n-        Node<Value> node = new Node<>(value, edges);\n-        visited.put(value, node);\n-        return node;\n-    }\n-\n-    \/*\n-     * Helper functions:\n-     *\/\n-\n-    private HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(String opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n-        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),resultType);\n-        return switch (opType) {\n-            case \"add\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"sub\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"mul\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            case \"div\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n-            default -> throw new IllegalStateException(\"Unexpected value: \" + opType);\n-        };\n-    }\n-    public boolean isVectorOp(Op op) {\n-        if (!op.operands().isEmpty()) {\n-           TypeElement type = OpHelper.firstOperandOrThrow(op).type();\n-           if (type instanceof ArrayType at) {\n-               type = at.componentType();\n-           }\n-           if (type instanceof ClassType ct) {\n-               try {\n-                   return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup()));\n-               } catch (ReflectiveOperationException e) {\n-                   throw new RuntimeException(e);\n-              }\n-           }\n-        }\n-        return false;\n-    }\n@@ -329,45 +267,0 @@\n-\n-    public boolean isBufferArray(Op op) {\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) findOpInResultFromFirstOperandsOrThrow(op, JavaOp.InvokeOp.class);\n-        return iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\");\n-    }\n-\n-    public boolean isLocalSharedOrPrivate(Op op) {\n-        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) findOpInResultFromFirstOperandsOrThrow(op, JavaOp.InvokeOp.class);\n-        return iop.invokeDescriptor().name().toLowerCase().contains(\"local\") ||\n-                iop.invokeDescriptor().name().toLowerCase().contains(\"shared\") ||\n-                iop.invokeDescriptor().name().toLowerCase().contains(\"private\");\n-    }\n-\n-    public Op findOpInResultFromFirstOperandsOrNull(Op op, Class<?> ...classes) {\n-        Set<Class<?>> set =Set.of(classes);\n-        while (!(set.contains(op.getClass()))) {\n-            if (resultFromFirstOperandOrNull(op) instanceof Op.Result result) {\n-                op = result.op();\n-            } else {\n-                return null;\n-            }\n-        }\n-        return op;\n-    }\n-    public Op findOpInResultFromFirstOperandsOrThrow(Op op, Class<?> ...classes) {\n-          if (findOpInResultFromFirstOperandsOrNull(op,classes) instanceof Op found){\n-              return found;\n-          }else{\n-              throw new RuntimeException(\"Expecting to find one of \"+List.of(classes));\n-          }\n-    }\n-\n-    public boolean isBufferInitialize(Op op) {\n-        \/\/ first check if the return is an array type\n-        if (op instanceof CoreOp.VarOp vop) {\n-            if (!(vop.varValueType() instanceof ArrayType)){\n-                return false;\n-            }\n-        } else if (!(op instanceof JavaOp.ArrayAccessOp)) {\n-            if (!(op.resultType() instanceof ArrayType)) {\n-                return false;\n-            }\n-        }\n-        return isBufferArray(op);\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":18,"deletions":125,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import optkl.InvokeQuery;\n+import optkl.InvokeQuery.Match;\n@@ -35,2 +37,0 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n@@ -42,0 +42,1 @@\n+         var invokeQuery = InvokeQuery.create(lookup());\n@@ -43,3 +44,4 @@\n-                         if (invoke(lookup(),c.op()) instanceof Invoke invoke\n-                                 && invoke.isInstanceAccessedViaVarAccess()\n-                                 && invoke.named(HATBarrierOp.NAME)\n+                         if (invokeQuery.matches(c.op(), $->\/\/\n+                                 $.isInstanceAccessedViaVarAccess()                  \/\/ we are called via var kc such as kc->XX()\n+                              && $.named(HATBarrierOp.NAME)) instanceof Match match  \/\/ and the method name is `barrier`\n+                              && match.helper().instanceVarAccess().op() instanceof CoreOp.VarAccessOp varAccess\n@@ -47,1 +49,1 @@\n-                             removeMe.add(invoke.instanceVarAccess().op());\n+                             removeMe.add(varAccess);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -56,28 +55,0 @@\n-    \/\/recursive\n-    public static boolean findF16IsLocal(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findF16IsLocal(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/recursive\n-    public static boolean findF16IsLocal(Value v) {\n-        return v instanceof Op.Result r && switch (r.op()) {\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findF16IsLocal(varLoadOp); \/\/recurse\n-            case HATF16Op.HATF16VarOp hatf16VarOp -> true;\n-            default -> false;\n-        };\n-    }\n-\n-\/\/recursive\n-    private static boolean findReference(MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findReference(lookup,varLoadOp.operands().getFirst());\n-    }\n-\/\/recursive\n-    private static boolean findReference(MethodHandles.Lookup lookup,Value v) {\n-        return v instanceof Op.Result result && switch (result.op()) {\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findReference(lookup,varLoadOp); \/\/ recurse\n-            case CoreOp.VarOp varOp ->\n-                    varOp.operands().getFirst() instanceof Op.Result varOpResult\n-                            && invoke(lookup,varOpResult.op()) instanceof Invoke invoke && invoke.named(\"array\");\n-            default -> false;\n-        };\n-    }\n@@ -85,21 +56,1 @@\n-    private static boolean isOperandF32(Value v) {\n-        return v instanceof Op.Result r && switch (r.op()) {\n-            case CoreOp.VarAccessOp varLoadOp -> varLoadOp.varType().valueType() ==JavaType.FLOAT; \/\/recurse\n-            case CoreOp.VarOp varOp -> varOp.resultType().valueType() == JavaType.FLOAT;\n-            default -> false;\n-        };\n-    }\n-    \/\/ recursive\n-    private static String findNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameOrNull(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/ recursive\n-    private static String findNameOrNull(Value v) {\n-        return  (v instanceof Op.Result r) ? switch (r.op()){\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp->findNameOrNull(varLoadOp); \/\/recurse\n-            case HATF16Op.HATF16VarOp hatf16VarOp -> hatf16VarOp.varName();\n-            default -> null;\n-        }:null;\n-    }\n-    private static ReducedFloatType categorizeReducedFloat(JavaOp.InvokeOp invokeOp) {\n+    static public ReducedFloatType categorizeReducedFloat(JavaOp.InvokeOp invokeOp) {\n@@ -116,11 +67,1 @@\n-    private boolean is16BitFloat(Invoke invoke, Regex methodName) {\n-        String invokeClassName = invoke.refType().toString();\n-        invokeClassName = invokeClassName.replace(\"$\", \".\"); \/\/ lets not compare strings here\n-        boolean is16BitFloatOperation = invokeClassName.startsWith(F16.class.getCanonicalName()) || invokeClassName.startsWith(BF16.class.getCanonicalName());\n-        return is16BitFloatOperation\n-                \/\/ No need because F16 element is not a Buffer type at the moment\n-                \/\/ && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n-                && invoke.named(methodName);\/\/ lets not compare strings here\n-    }\n-\n-    private void createF16VarOp(CoreOp.VarOp varOp, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n+    static public  void createF16VarOp(CoreOp.VarOp varOp, Block.Builder blockBuilder, ReducedFloatType reducedFloatType) {\n@@ -152,1 +93,1 @@\n-                                        findNameOrNull(varLoadOp),\n+                                        HATPhaseUtils.findVarNameOrNull(varLoadOp),\n@@ -168,1 +109,1 @@\n-                                findF16IsLocal(invoke.op().operands().getFirst()),\n+                                HATPhaseUtils.isF16Local(invoke.op().operands().getFirst()),\n@@ -182,2 +123,2 @@\n-        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().get(0));\n-        boolean isSecondOperandReference = findReference(lookup(),invokeOp.operands().get(1));\n+        boolean isFirstOperandReference = HATPhaseUtils.isArrayReference(lookup(),invokeOp.operands().get(0));\n+        boolean isSecondOperandReference = HATPhaseUtils.isArrayReference(lookup(),invokeOp.operands().get(1));\n@@ -186,1 +127,1 @@\n-        if (!isFirstOperandReference && isOperandF32(invokeOp.operands().get(0))) {\n+        if (!isFirstOperandReference && HATPhaseUtils.isOperandF32(invokeOp.operands().get(0))) {\n@@ -188,1 +129,1 @@\n-        } else if (!isSecondOperandReference && isOperandF32(invokeOp.operands().get(1))) {\n+        } else if (!isSecondOperandReference && HATPhaseUtils.isOperandF32(invokeOp.operands().get(1))) {\n@@ -211,1 +152,1 @@\n-                .filter(invoke -> is16BitFloat(invoke, Regex.of(binaryOpEnum.name().toLowerCase())) && !invoke.returnsVoid())\n+                .filter(invoke -> HATPhaseUtils.is16BitFloat(invoke, Regex.of(binaryOpEnum.name().toLowerCase())) && !invoke.returnsVoid())\n@@ -235,1 +176,1 @@\n-                .filter(invoke-> is16BitFloat(invoke,Regex.of(\"value\")) && invoke.returns16BitValue())\n+                .filter(invoke-> HATPhaseUtils.is16BitFloat(invoke,Regex.of(\"value\")) && invoke.returns16BitValue())\n@@ -259,1 +200,1 @@\n-                .filter(invoke -> !invoke.returnsVoid() && is16BitFloat(invoke, Regex.of(\"(of|floatToF16|float2bfloat16)\")))\n+                .filter(invoke -> !invoke.returnsVoid() && HATPhaseUtils.is16BitFloat(invoke, Regex.of(\"(of|floatToF16|float2bfloat16)\")))\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":11,"deletions":70,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,368 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HATF16Op;\n+import hat.dialect.HATMemoryVarOp;\n+import hat.dialect.HATVectorOp;\n+import hat.types.BF16;\n+import hat.types.F16;\n+import hat.types._V;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.OpHelper;\n+import optkl.util.Regex;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Invoke.invoke;\n+import static optkl.OpHelper.resultFromFirstOperandOrNull;\n+\n+public class HATPhaseUtils {\n+\n+    static HATArrayViewPhase.ArrayAccessInfo arrayAccessInfo(Value value, Map<Op.Result, Op.Result> replaced) {\n+        return expressionGraph(value).getInfo(replaced);\n+    }\n+\n+    static HATArrayViewPhase.Node<Value> expressionGraph(Value value) {\n+        return expressionGraph(new HashMap<>(), value);\n+    }\n+\n+    static HATArrayViewPhase.Node<Value> expressionGraph(Map<Value, HATArrayViewPhase.Node<Value>> visited, Value value) {\n+        \/\/ If value has already been visited return its node\n+        if (visited.containsKey(value)) {\n+            return visited.get(value);\n+        }\n+\n+        \/\/ Find the expression graphs for each operand\n+        List<HATArrayViewPhase.Node<Value>> edges = new ArrayList<>();\n+\n+        \/\/ looks like\n+        for (Value operand : value.dependsOn()) {\n+            if (operand instanceof Op.Result res &&\n+                    res.op() instanceof JavaOp.InvokeOp iop\n+                    && iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\")){\n+                continue;\n+            }\n+            edges.add(expressionGraph(operand));\n+        }\n+        HATArrayViewPhase.Node<Value> node = new HATArrayViewPhase.Node<>(value, edges);\n+        visited.put(value, node);\n+        return node;\n+    }\n+\n+    static HATVectorOp.HATVectorBinaryOp buildVectorBinaryOp(MethodHandles.Lookup lookup, String opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n+        VectorMetaData md = getVectorTypeInfoWithCodeReflection(lookup,resultType);\n+        return switch (opType) {\n+            case \"add\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorAddOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"sub\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorSubOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"mul\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorMulOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"div\" -> new HATVectorOp.HATVectorBinaryOp.HATVectorDivOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + opType);\n+        };\n+    }\n+\n+    static public boolean isVectorOp(MethodHandles.Lookup lookup, Op op) {\n+        if (!op.operands().isEmpty()) {\n+           TypeElement type = OpHelper.firstOperandOrThrow(op).type();\n+           if (type instanceof ArrayType at) {\n+               type = at.componentType();\n+           }\n+           if (type instanceof ClassType ct) {\n+               try {\n+                   return _V.class.isAssignableFrom((Class<?>) ct.resolve(lookup));\n+               } catch (ReflectiveOperationException e) {\n+                   throw new RuntimeException(e);\n+              }\n+           }\n+        }\n+        return false;\n+    }\n+\n+    static public boolean isBufferArray(Op op) {\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) findOpInResultFromFirstOperandsOrThrow(op, JavaOp.InvokeOp.class);\n+        return iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\");\n+    }\n+\n+    static public boolean isLocalSharedOrPrivate(Op op) {\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) findOpInResultFromFirstOperandsOrThrow(op, JavaOp.InvokeOp.class);\n+        return iop.invokeDescriptor().name().toLowerCase().contains(\"local\") ||\n+                iop.invokeDescriptor().name().toLowerCase().contains(\"shared\") ||\n+                iop.invokeDescriptor().name().toLowerCase().contains(\"private\");\n+    }\n+\n+    static  public Op findOpInResultFromFirstOperandsOrNull(Op op, Class<?> ...classes) {\n+        Set<Class<?>> set =Set.of(classes);\n+        while (!(set.contains(op.getClass()))) {\n+            if (resultFromFirstOperandOrNull(op) instanceof Op.Result result) {\n+                op = result.op();\n+            } else {\n+                return null;\n+            }\n+        }\n+        return op;\n+    }\n+\n+    static public Op findOpInResultFromFirstOperandsOrThrow(Op op, Class<?> ...classes) {\n+          if (findOpInResultFromFirstOperandsOrNull(op,classes) instanceof Op found){\n+              return found;\n+          }else{\n+              throw new RuntimeException(\"Expecting to find one of \"+List.of(classes));\n+          }\n+    }\n+\n+    static public boolean isBufferInitialize(Op op) {\n+        \/\/ first check if the return is an array type\n+        if (op instanceof CoreOp.VarOp vop) {\n+            if (!(vop.varValueType() instanceof ArrayType)){\n+                return false;\n+            }\n+        } else if (!(op instanceof JavaOp.ArrayAccessOp)) {\n+            if (!(op.resultType() instanceof ArrayType)) {\n+                return false;\n+            }\n+        }\n+        return isBufferArray(op);\n+    }\n+\n+    \/\/recursive\n+    public static boolean isF16Local(Value v) {\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isF16Local(varLoadOp); \/\/recurse\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/recursive\n+    public static boolean isF16Local(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return isF16Local(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    static boolean isArrayReference(MethodHandles.Lookup lookup, Value v) {\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isArrayReference(lookup,varLoadOp); \/\/ recurse\n+            case CoreOp.VarOp varOp ->\n+                    varOp.operands().getFirst() instanceof Op.Result varOpResult\n+                            && invoke(lookup,varOpResult.op()) instanceof OpHelper.Named.NamedStaticOrInstance.Invoke invoke && invoke.named(\"array\");\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/recursive\n+    private static boolean isArrayReference(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return isArrayReference(lookup,varLoadOp.operands().getFirst());\n+    }\n+\n+    static boolean isOperandF32(Value v) {\n+        return v instanceof Op.Result r && switch (r.op()) {\n+            case CoreOp.VarAccessOp varLoadOp -> varLoadOp.varType().valueType() == JavaType.FLOAT; \/\/recurse\n+            case CoreOp.VarOp varOp -> varOp.resultType().valueType() == JavaType.FLOAT;\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ recursive\n+    private static String findVarNameOrNull(Value v) {\n+        return  (v instanceof Op.Result r) ? switch (r.op()){\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp-> findVarNameOrNull(varLoadOp); \/\/recurse\n+            case HATF16Op.HATF16VarOp hatf16VarOp -> hatf16VarOp.varName();\n+            default -> null;\n+        }:null;\n+    }\n+\n+    \/\/ recursive\n+    static String findVarNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVarNameOrNull(varLoadOp.operands().getFirst());\n+    }\n+\n+    static public boolean is16BitFloat(OpHelper.Named.NamedStaticOrInstance.Invoke invoke, Regex methodName) {\n+        String invokeClassName = invoke.refType().toString();\n+        invokeClassName = invokeClassName.replace(\"$\", \".\"); \/\/ lets not compare strings here\n+        boolean is16BitFloatOperation = invokeClassName.startsWith(F16.class.getCanonicalName()) || invokeClassName.startsWith(BF16.class.getCanonicalName());\n+        \/\/ No need because F16 element is not a Buffer type at the moment\n+        \/\/ && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n+        return is16BitFloatOperation && invoke.named(methodName);\/\/ lets not compare strings here\n+    }\n+\n+    \/\/ recursive\n+    public static TypeElement findVectorTypeElement(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVectorTypeElement(varLoadOp); \/\/ recurse\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorElementType();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/\/ recursive\n+    public static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVectorTypeElement(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    public static int getVectorWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return getVectorWidth(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    private static int getVectorWidth(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getVectorWidth(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.vectorN();\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    \/\/recursive\n+    public static boolean isSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return isSharedOrPrivate(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/recursive\n+    public static boolean isSharedOrPrivate(Value v) {\n+        return v instanceof Op.Result result && switch (result.op()) {\n+            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isSharedOrPrivate(varLoadOp); \/\/recurse\n+            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ recursive\n+    public static String findVectorVarNameOrNull(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVectorVarNameOrNull(varLoadOp.operands().getFirst());\n+    }\n+\n+    \/\/ recursive\n+    public static String findVectorVarNameOrNull(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVectorVarNameOrNull(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n+                return hatVectorOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public record VectorMetaData(TypeElement vectorTypeElement, int lanes) {\n+    }\n+\n+    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, int param) {\n+        Value varValue = invokeOp.operands().get(param);\n+        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return getVectorTypeInfoWithCodeReflection(lookup,varLoadOp.resultType());\n+        }\n+        return null;\n+    }\n+\n+    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp) {\n+        return getVectorTypeInfoWithCodeReflection(lookup,invokeOp.resultType());\n+    }\n+    public static TypeElement getVectorElementType(String primitive) {\n+        return switch (primitive) {\n+            case \"float\" -> JavaType.FLOAT;\n+            case \"double\" -> JavaType.DOUBLE;\n+            case \"int\" -> JavaType.INT;\n+            case \"long\" -> JavaType.LONG;\n+            case \"short\" -> JavaType.SHORT;\n+            case \"byte\" -> JavaType.BYTE;\n+            case \"char\" -> JavaType.CHAR;\n+            case \"boolean\" -> JavaType.BOOLEAN;\n+            default -> null;\n+        };\n+    }\n+\n+    \/**\n+     * This method inspects the Vector Type Methods to obtain two methods for code-model:\n+     * 1) Method `type` to obtain the primitive base type of the vector type.\n+     * 2) Method `width` to obtain the number of lanes.\n+     *\n+     * @param typeElement\n+     *  {@link TypeElement}\n+     * @return\n+     * {@link VectorMetaData}\n+     *\/\n+    public static VectorMetaData getVectorTypeInfoWithCodeReflection(MethodHandles.Lookup lookup,TypeElement typeElement) {\n+        Class<?> clazz = (Class<?>) OpHelper.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n+        CoreOp.FuncOp codeModelType = buildCodeModelFor(clazz, \"type\");\n+        AtomicReference<TypeElement> vectorElement = new AtomicReference<>();\n+        codeModelType.elements().forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n+                Value v = returnOp.operands().getFirst();\n+                if (v instanceof Op.Result r && r.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                    String primitiveTypeName = fieldLoadOp.fieldDescriptor().name();\n+                    vectorElement.set(getVectorElementType(primitiveTypeName.toLowerCase()));\n+                }\n+            }\n+        });\n+\n+        AtomicInteger lanes = new AtomicInteger(1);\n+        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(clazz, \"width\");\n+        codeModelWidth.elements().forEach(codeElement -> {\n+            if (codeElement instanceof CoreOp.ReturnOp returnOp) {\n+                Value v = returnOp.operands().getFirst();\n+                if (v instanceof Op.Result r && r.op() instanceof CoreOp.ConstantOp constantOp) {\n+                    lanes.set((Integer) constantOp.value());\n+                }\n+            }\n+        });\n+        return new VectorMetaData(vectorElement.get(), lanes.get());\n+    }\n+\n+\n+    private static CoreOp.FuncOp buildCodeModelFor(Class<?> klass, String methodName) {\n+        Optional<Method> methodFunction = Stream.of(klass.getMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+        return Op.ofMethod(methodFunction.get()).get();\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhaseUtils.java","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.KernelContext;\n+\n@@ -32,0 +32,1 @@\n+import optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n@@ -35,2 +36,1 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.util.Regex;\n+import hat.phases.KernelContextThreadIdFieldAccessQuery.Match;\n@@ -41,4 +41,0 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess.fieldAccess;\n-import static optkl.OpHelper.Named.VarAccess;\n-\n@@ -46,3 +42,0 @@\n-\n-    private static final Regex allfieldNameRegex = Regex.of(\"[glb][si]([xyz])\");\n-\n@@ -51,1 +44,2 @@\n-        Set<CodeElement<?, ?>> removeMe = new HashSet<>();\n+        Set<CodeElement<?, ?>> varAccessesToBeRemoved = new HashSet<>();\n+        var query = KernelContextThreadIdFieldAccessQuery.create(lookup()); \/\/ This Query matches kc->[glb][is][xyz] calls\n@@ -53,8 +47,21 @@\n-                .transform(ce -> ce instanceof JavaOp.FieldAccessOp, c -> { \/\/ We care about field accesses\n-                    if (fieldAccess(lookup(), c.op()) instanceof FieldAccess fieldAccess \/\/ get a FieldAccessHelper\n-                            && fieldAccess.refType(KernelContext.class)\n-                            && fieldAccess.isLoad()\n-                            && fieldAccess.named(allfieldNameRegex)\n-                            && fieldAccess.instanceVarAccess() instanceof VarAccess varAccess) {\n-                        removeMe.add(varAccess.op());\/\/ We will remove in the next transform (see removeme)\n-                        c.replace(HATThreadOp.create(fieldAccess.name()));\n+                .transform( c -> {\n+                    if (query.matches(c) instanceof Match match && match.helper() instanceof FieldAccess fieldAccess){\n+                        varAccessesToBeRemoved.add(fieldAccess.instanceVarAccess().op());  \/\/ the var access will be removed the next transform\n+                        c.replace(switch (fieldAccess.name()){\n+                            case \"gix\"->  new HATThreadOp.HAT_GI.HAT_GIX();\n+                            case \"giy\"->  new HATThreadOp.HAT_GI.HAT_GIY();\n+                            case \"giz\"->  new HATThreadOp.HAT_GI.HAT_GIZ();\n+                            case \"gsx\"->  new HATThreadOp.HAT_GS.HAT_GSX();\n+                            case \"gsy\"->  new HATThreadOp.HAT_GS.HAT_GSY();\n+                            case \"gsz\"->  new HATThreadOp.HAT_GS.HAT_GSZ();\n+                            case \"lix\"->  new HATThreadOp.HAT_LI.HAT_LIX();\n+                            case \"liy\"->  new HATThreadOp.HAT_LI.HAT_LIY();\n+                            case \"liz\"->  new HATThreadOp.HAT_LI.HAT_LIZ();\n+                            case \"lsx\"->  new HATThreadOp.HAT_LS.HAT_LSX();\n+                            case \"lsy\"->  new HATThreadOp.HAT_LS.HAT_LSY();\n+                            case \"lsz\"->  new HATThreadOp.HAT_LS.HAT_LSZ();\n+                            case \"bix\"->  new HATThreadOp.HAT_BI.HAT_BIX();\n+                            case \"biy\"->  new HATThreadOp.HAT_BI.HAT_BIY();\n+                            case \"biz\"->  new HATThreadOp.HAT_BI.HAT_BIZ();\n+                            default -> throw  new RuntimeException(\"what is this ?\");\n+                        });\n@@ -63,2 +70,2 @@\n-                .remap(removeMe)\n-                .remove(removeMe::contains)\n+                .remap(varAccessesToBeRemoved)                \/\/ after this transform this set needs to be replaced with new op references\n+                .remove(varAccessesToBeRemoved::contains)     \/\/ now we can transform again and remove everything in the remove me set\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -60,15 +60,0 @@\n-      \/*  hatPhases.add(new HATThreadsPhase.GI_Phase.HAT_GIX(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.GI_Phase.HAT_GIY(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.GI_Phase.HAT_GIZ(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.GS_Phase.HAT_GSX(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.GS_Phase.HAT_GSY(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.GS_Phase.HAT_GSZ(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LI_Phase.HAT_LIX(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LI_Phase.HAT_LIY(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LI_Phase.HAT_LIZ(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LS_Phase.HAT_LSX(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LS_Phase.HAT_LSY(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LS_Phase.HAT_LSZ(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.BI_Phase.HAT_BIY(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.BI_Phase.HAT_BIZ(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.BI_Phase.HAT_BIX(kernelCallGraph)); *\/\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATTier.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.dialect.HATMemoryVarOp;\n@@ -50,2 +49,2 @@\n-import static hat.dialect.HATPhaseUtils.VectorMetaData;\n-import static hat.dialect.HATPhaseUtils.getVectorTypeInfo;\n+import static hat.phases.HATPhaseUtils.VectorMetaData;\n+import static hat.phases.HATPhaseUtils.getVectorTypeInfo;\n@@ -60,41 +59,2 @@\n-@Override public KernelCallGraph kernelCallGraph(){\n-    return kernelCallGraph;\n-}\n-\n-\n-    \/\/ recursive\n-    private static TypeElement findVectorTypeElement(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVectorTypeElement(varLoadOp.operands().getFirst());\n-    }\n-    \/\/ recursive\n-    private static TypeElement findVectorTypeElement(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVectorTypeElement(varLoadOp); \/\/ recurse\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorElementType();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    \/\/recursive\n-    public static int getWidth(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return getWidth(varLoadOp.operands().getFirst());\n-    }\n-    \/\/recursive\n-    private static int getWidth(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return getWidth(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.vectorN();\n-            }\n-            return -1;\n-        }\n-    }\n-    \/\/recursive\n-    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findIsSharedOrPrivate(varLoadOp.operands().getFirst());\n+    @Override public KernelCallGraph kernelCallGraph(){\n+        return kernelCallGraph;\n@@ -103,8 +63,0 @@\n-    \/\/recursive\n-    private boolean findIsSharedOrPrivate(Value v) {\n-        return v instanceof Op.Result result && switch (result.op()) {\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> findIsSharedOrPrivate(varLoadOp); \/\/recurse\n-            case HATMemoryVarOp.HATLocalVarOp _, HATMemoryVarOp.HATPrivateVarOp _ -> true;\n-            default -> false;\n-        };\n-    }\n@@ -112,17 +64,0 @@\n-    \/\/ recursive\n-    public static String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/ recursive\n-    public static String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp hatVectorOp) {\n-                return hatVectorOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n@@ -198,3 +133,3 @@\n-        String varLoadName = findNameVector(varLoadOp);\n-        int lanes = getWidth(varLoadOp);\n-        TypeElement vectorElementType = findVectorTypeElement(varLoadOp);\n+        String varLoadName = HATPhaseUtils.findVectorVarNameOrNull(varLoadOp);\n+        int lanes = HATPhaseUtils.getVectorWidth(varLoadOp);\n+        TypeElement vectorElementType = HATPhaseUtils.findVectorTypeElement(varLoadOp);\n@@ -233,1 +168,1 @@\n-        String varName = findNameVector(invokeOp.operands().getFirst());\n+        String varName = HATPhaseUtils.findVectorVarNameOrNull(invokeOp.operands().getFirst());\n@@ -257,3 +192,3 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                boolean isShared = findIsSharedOrPrivate(invokeOp.operands().getFirst());\n-                List<Op.Result> collect = invokeOp.result().uses().stream().toList();\n+            if (Invoke.invoke(lookup(),op) instanceof Invoke invoke) {\n+                boolean isShared = HATPhaseUtils.isSharedOrPrivate(invoke.resultFromFirstOperandOrNull()\/*invokeOp.operands().getFirst()*\/);\n+                List<Op.Result> collect = invoke.op().result().uses().stream().toList();\n@@ -262,1 +197,1 @@\n-                        insertVectorLoadOp(blockBuilder, invokeOp, varOp, isShared);\n+                        insertVectorLoadOp(blockBuilder, invoke.op(), varOp, isShared);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":12,"deletions":77,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.dialect.HATPhaseUtils;\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.KernelContext;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.FieldAccess;\n+import optkl.Query;\n+import optkl.util.BiMap;\n+import optkl.util.Regex;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.Predicate;\n+\n+public interface KernelContextThreadIdFieldAccessQuery extends Query<JavaOp.FieldAccessOp, FieldAccess, KernelContextThreadIdFieldAccessQuery> {\n+    Regex threadIdRegex = Regex.of(\"[glb][is][xyz]\");\n+    interface Match extends SimpleMatch<JavaOp.FieldAccessOp, FieldAccess, KernelContextThreadIdFieldAccessQuery> {\n+         String id();\n+    }\n+    record Impl(MethodHandles.Lookup lookup) implements KernelContextThreadIdFieldAccessQuery {\n+        @Override\n+        public Res<JavaOp.FieldAccessOp,FieldAccess, KernelContextThreadIdFieldAccessQuery> matches(CodeElement<?, ?> ce, Predicate<FieldAccess> predicate) {\n+            if (FieldAccess.fieldAccess(lookup, ce) instanceof FieldAccess fieldAccess && predicate.test(fieldAccess)\n+                && fieldAccess.isInstance() && fieldAccess.refType(KernelContext.class) && fieldAccess.named(threadIdRegex)){\n+                    record MatchImpl(KernelContextThreadIdFieldAccessQuery query, FieldAccess helper, String id) implements Match{\n+                        @Override\n+                        public SimpleMatch<JavaOp.FieldAccessOp, FieldAccess, KernelContextThreadIdFieldAccessQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n+                            return new MatchImpl(MatchImpl.this.query, FieldAccess.fieldAccess(query().lookup(), biMap.getTo(MatchImpl.this.helper.op())),MatchImpl.this.id);\n+                        }\n+                    }\n+                    return new MatchImpl(this, fieldAccess, fieldAccess.name() );\n+                }\n+            return Query.FAILED;\n+        }\n+    }\n+    static KernelContextThreadIdFieldAccessQuery create(MethodHandles.Lookup lookup) {\n+         return new Impl(lookup);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/KernelContextThreadIdFieldAccessQuery.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import optkl.MappedIfaceBufferInvokeQuery.Match;\n@@ -51,1 +52,0 @@\n-\n@@ -105,1 +105,1 @@\n-                    if (mappedIfaceBufferInvokeQuery.test(c.op()) instanceof MappedIfaceBufferInvokeQuery.OK match) {\n+                    if (mappedIfaceBufferInvokeQuery.matches(c.op()) instanceof Match match) {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            if (query.test(invoke.op()) instanceof Query.Match<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> match){\n+            if (query.matches(invoke.op()) instanceof Query.SimpleMatch<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> match){\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Queries.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.util.function.Predicate;\n+\n@@ -35,0 +37,3 @@\n+    interface Match extends SimpleMatch<JavaOp.InvokeOp, Invoke, InvokeQuery> {\n+\n+    }\n@@ -37,3 +42,3 @@\n-        public Res<JavaOp.InvokeOp,Invoke,InvokeQuery> test(CodeElement<?, ?> ce) {\n-            if (Invoke.invoke(lookup,ce) instanceof Invoke invoke) {\n-                record  MatchImpl (InvokeQuery query, Invoke helper) implements Match<JavaOp.InvokeOp,Invoke,InvokeQuery>{\n+        public Res<JavaOp.InvokeOp,Invoke,InvokeQuery> matches(CodeElement<?, ?> ce, Predicate<Invoke> predicate) {\n+            if (Invoke.invoke(lookup,ce) instanceof Invoke invoke && predicate.test(invoke)) {\n+                record  MatchImpl (InvokeQuery query, Invoke helper) implements Match {\n@@ -41,1 +46,1 @@\n-                    public Match<JavaOp.InvokeOp,Invoke,InvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n+                    public SimpleMatch<JavaOp.InvokeOp,Invoke,InvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/InvokeQuery.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Predicate;\n@@ -35,1 +36,1 @@\n-    interface OK extends Match<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery>{\n+    interface Match extends SimpleMatch<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery> {\n@@ -40,4 +41,4 @@\n-        public Res<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> test(CodeElement<?, ?> ce) {\n-            if (Invoke.invoke(lookup, ce) instanceof Invoke invoke) {\n-                if (invoke.isInstance() && invoke.returns(MappedIfaceBufferInvokeQuery.class) || invoke.returnsPrimitive()){\n-                    record MatchImpl(MappedIfaceBufferInvokeQuery query, Invoke helper, boolean mutatesBuffer) implements OK{\n+        public Res<JavaOp.InvokeOp,Invoke, MappedIfaceBufferInvokeQuery> matches(CodeElement<?, ?> ce, Predicate<Invoke> predicate) {\n+            if (Invoke.invoke(lookup, ce) instanceof Invoke invoke && predicate.test(invoke)\n+                    && invoke.isInstance() && (invoke.returns(MappedIfaceBufferInvokeQuery.class) || invoke.returnsPrimitive())){\n+                    record MatchImpl(MappedIfaceBufferInvokeQuery query, Invoke helper, boolean mutatesBuffer) implements Match{\n@@ -45,1 +46,1 @@\n-                        public Match<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n+                        public SimpleMatch<JavaOp.InvokeOp, Invoke, MappedIfaceBufferInvokeQuery> remap(BiMap<CodeElement<?, ?>, CodeElement<?, ?>> biMap) {\n@@ -51,1 +52,1 @@\n-            }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/MappedIfaceBufferInvokeQuery.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -33,0 +32,2 @@\n+import java.util.function.Predicate;\n+\n@@ -37,1 +38,7 @@\n-    Res<O,OH,Q> test(CodeElement<?,?> ce);\n+    default Res<O,OH,Q> matches(CodeElement<?,?> ce){\n+        return matches(ce, _->true);\n+    }\n+    default Res<O,OH,Q> matches(Trxfmr.Cursor cursor){\n+        return matches(cursor.op(), _->true);\n+    }\n+    Res<O,OH,Q> matches(CodeElement<?,?> ce, Predicate<OH> predicate);\n@@ -39,1 +46,1 @@\n-    interface Fail extends Res{\n+    interface Fail<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends Res<O,OH,Q>{\n@@ -45,1 +52,1 @@\n-    interface Match<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends Res<O,OH,Q>{\n+    interface SimpleMatch<O extends Op, OH extends OpHelper<O>, Q extends Query<O,OH,Q>> extends Res<O,OH,Q>{\n@@ -48,1 +55,1 @@\n-        Match<O,OH,Q> remap(BiMap<CodeElement<?,?>, CodeElement<?,?>> biMap);\n+        SimpleMatch<O,OH,Q> remap(BiMap<CodeElement<?,?>, CodeElement<?,?>> biMap);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Query.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"}]}