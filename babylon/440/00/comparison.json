{"files":[{"patch":"@@ -96,1 +96,1 @@\n-                import jdk.incubator.code.op.OpFactory;\n+                import jdk.incubator.code.dialect.OpFactory;\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/OpGen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,3 +41,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.TupleType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.TupleType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -50,1 +51,0 @@\n-import oracle.code.onnx.proto.OnnxModel;\n@@ -279,1 +279,1 @@\n-                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(JavaType.type(List.class)) -> {\n+                case JavaOp.InvokeOp io when io.invokeDescriptor().refType().equals(JavaType.type(List.class)) -> {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,4 +46,5 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -184,1 +185,1 @@\n-        ClassType retType = ((ClassType)((CoreOp.LambdaOp)q.op()).invokableType().returnType()).rawType();\n+        ClassType retType = ((ClassType)((JavaOp.LambdaOp)q.op()).invokableType().returnType()).rawType();\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,2 +29,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -48,1 +49,1 @@\n-    final Map<CoreOp.InvokeOp, List<Object>> evaluatedAttributes;\n+    final Map<JavaOp.InvokeOp, List<Object>> evaluatedAttributes;\n@@ -299,1 +300,1 @@\n-        if (o instanceof CoreOp.InvokeOp io && io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS)) {\n+        if (o instanceof JavaOp.InvokeOp io && io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS)) {\n@@ -332,1 +333,1 @@\n-        } else if (o instanceof CoreOp.InvokeOp io && io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\")) {\n+        } else if (o instanceof JavaOp.InvokeOp io && io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\")) {\n@@ -350,1 +351,1 @@\n-            case CoreOp.InvokeOp co -> {\n+            case JavaOp.InvokeOp co -> {\n@@ -362,1 +363,1 @@\n-            case CoreOp.NewOp no -> {\n+            case JavaOp.NewOp no -> {\n@@ -412,1 +413,1 @@\n-            case CoreOp.FieldAccessOp.FieldLoadOp fo -> {\n+            case JavaOp.FieldAccessOp.FieldLoadOp fo -> {\n@@ -422,1 +423,1 @@\n-            case CoreOp.FieldAccessOp.FieldStoreOp fo -> {\n+            case JavaOp.FieldAccessOp.FieldStoreOp fo -> {\n@@ -435,1 +436,1 @@\n-            case CoreOp.InstanceOfOp io -> {\n+            case JavaOp.InstanceOfOp io -> {\n@@ -439,1 +440,1 @@\n-            case CoreOp.CastOp co -> {\n+            case JavaOp.CastOp co -> {\n@@ -443,1 +444,1 @@\n-            case CoreOp.ArrayLengthOp arrayLengthOp -> {\n+            case JavaOp.ArrayLengthOp arrayLengthOp -> {\n@@ -447,1 +448,1 @@\n-            case CoreOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+            case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n@@ -452,1 +453,1 @@\n-            case CoreOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+            case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n@@ -459,1 +460,1 @@\n-            case CoreOp.ArithmeticOperation arithmeticOperation -> {\n+            case JavaOp.ArithmeticOperation arithmeticOperation -> {\n@@ -464,1 +465,1 @@\n-            case CoreOp.TestOperation testOperation -> {\n+            case JavaOp.TestOperation testOperation -> {\n@@ -469,1 +470,1 @@\n-            case CoreOp.ConvOp convOp -> {\n+            case JavaOp.ConvOp convOp -> {\n@@ -474,1 +475,1 @@\n-            case CoreOp.ConcatOp concatOp -> {\n+            case JavaOp.ConcatOp concatOp -> {\n@@ -480,1 +481,1 @@\n-            case CoreOp.LambdaOp lambdaOp -> {\n+            case JavaOp.LambdaOp lambdaOp -> {\n@@ -539,1 +540,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, JavaOp.InvokeOp.InvokeKind kind) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -11,2 +11,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -55,1 +57,1 @@\n-        CoreOp.LambdaOp lambda = (CoreOp.LambdaOp) quotedLambda.op();\n+        JavaOp.LambdaOp lambda = (JavaOp.LambdaOp) quotedLambda.op();\n@@ -97,1 +99,1 @@\n-            if(op instanceof CoreOp.InvokeOp io && resolve(l, io) instanceof CoreOp.FuncOp f) {\n+            if(op instanceof JavaOp.InvokeOp io && resolve(l, io) instanceof CoreOp.FuncOp f) {\n@@ -126,1 +128,1 @@\n-            if (op instanceof CoreOp.InvokeOp io && funcs.get(io.invokeDescriptor()) instanceof CoreOp.FuncOp fo) {\n+            if (op instanceof JavaOp.InvokeOp io && funcs.get(io.invokeDescriptor()) instanceof CoreOp.FuncOp fo) {\n@@ -144,1 +146,1 @@\n-            if (op instanceof CoreOp.FieldAccessOp.FieldLoadOp flo\n+            if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp flo\n@@ -166,1 +168,1 @@\n-                            case CoreOp.FieldAccessOp.FieldLoadOp flo when initializers.get(flo.fieldDescriptor()) instanceof TI ti -> {\n+                            case JavaOp.FieldAccessOp.FieldLoadOp flo when initializers.get(flo.fieldDescriptor()) instanceof TI ti -> {\n@@ -186,1 +188,1 @@\n-    static CoreOp.FuncOp resolve(MethodHandles.Lookup l, CoreOp.InvokeOp io) {\n+    static CoreOp.FuncOp resolve(MethodHandles.Lookup l, JavaOp.InvokeOp io) {\n@@ -316,1 +318,1 @@\n-                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS) -> {\n+                case JavaOp.InvokeOp io when io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS) -> {\n@@ -350,1 +352,1 @@\n-                                if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp optionalInvoke\n+                                if (v instanceof Op.Result r && r.op() instanceof JavaOp.InvokeOp optionalInvoke\n@@ -367,1 +369,1 @@\n-                                if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp listInvoke\n+                                if (v instanceof Op.Result r && r.op() instanceof JavaOp.InvokeOp listInvoke\n@@ -386,1 +388,1 @@\n-                            var lambda = (CoreOp.LambdaOp)(((Op.Result)op.operands().get(i)).op());\n+                            var lambda = (JavaOp.LambdaOp)(((Op.Result)op.operands().get(i)).op());\n@@ -391,1 +393,1 @@\n-                        var lambda = (CoreOp.LambdaOp)(((Op.Result)op.operands().get(3)).op());\n+                        var lambda = (JavaOp.LambdaOp)(((Op.Result)op.operands().get(3)).op());\n@@ -404,1 +406,1 @@\n-                case CoreOp.InvokeOp io when\n+                case JavaOp.InvokeOp io when\n@@ -410,1 +412,1 @@\n-                case CoreOp.NewOp no when isRecord(l, no.type()) -> {\n+                case JavaOp.NewOp no when isRecord(l, no.type()) -> {\n@@ -416,2 +418,2 @@\n-                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\") -> {\n-                    Op.Result result = bb.op(CoreOp.invoke(\n+                case JavaOp.InvokeOp io when io.invokeDescriptor().refType().equals(LIST_CLASS) && io.invokeDescriptor().name().equals(\"get\") -> {\n+                    Op.Result result = bb.op(JavaOp.invoke(\n@@ -424,1 +426,1 @@\n-                case CoreOp.LambdaOp _ -> {\n+                case JavaOp.LambdaOp _ -> {\n@@ -430,2 +432,2 @@\n-                case CoreOp.FieldAccessOp.FieldLoadOp flo when flo.operands().isEmpty() -> {\n-                    Op.Result result = bb.op(CoreOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor())));\n+                case JavaOp.FieldAccessOp.FieldLoadOp flo when flo.operands().isEmpty() -> {\n+                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor())));\n@@ -434,2 +436,2 @@\n-                case CoreOp.FieldAccessOp.FieldLoadOp flo -> {\n-                    Op.Result result = bb.op(CoreOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor()), bb.context().getValue(flo.operands().getFirst())));\n+                case JavaOp.FieldAccessOp.FieldLoadOp flo -> {\n+                    Op.Result result = bb.op(JavaOp.fieldLoad(convertType(l, flo.resultType()), convertType(l, flo.fieldDescriptor()), bb.context().getValue(flo.operands().getFirst())));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/genai\/OnnxGenRuntimeSession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.dialect.OpFactory;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.type.TypeElementFactory;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.TupleType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,5 +46,5 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.op.OpFactory;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.TupleType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/proto\/OnnxModelTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,5 @@\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -56,1 +61,0 @@\n-import jdk.incubator.code.op.CoreOp;\n@@ -58,3 +62,0 @@\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,4 +36,4 @@\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.code.op.CoreOp;\n@@ -38,1 +37,3 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -133,1 +134,1 @@\n-                    case CoreOp.ArrayAccessOp.ArrayLoadOp alo -> {\n+                    case JavaOp.ArrayAccessOp.ArrayLoadOp alo -> {\n@@ -146,1 +147,1 @@\n-                    case CoreOp.ArrayAccessOp.ArrayStoreOp aso -> {\n+                    case JavaOp.ArrayAccessOp.ArrayStoreOp aso -> {\n@@ -154,1 +155,1 @@\n-                    case CoreOp.ArrayLengthOp alo -> {\n+                    case JavaOp.ArrayLengthOp alo -> {\n@@ -159,1 +160,1 @@\n-                    case CoreOp.AddOp aop -> {\n+                    case JavaOp.AddOp aop -> {\n@@ -169,1 +170,1 @@\n-                    case CoreOp.SubOp sop -> {\n+                    case JavaOp.SubOp sop -> {\n@@ -179,1 +180,1 @@\n-                    case CoreOp.MulOp mop -> {\n+                    case JavaOp.MulOp mop -> {\n@@ -189,1 +190,1 @@\n-                    case CoreOp.DivOp dop -> {\n+                    case JavaOp.DivOp dop -> {\n@@ -199,1 +200,1 @@\n-                    case CoreOp.ModOp mop -> {\n+                    case JavaOp.ModOp mop -> {\n@@ -206,1 +207,1 @@\n-                    case CoreOp.EqOp eqop -> {\n+                    case JavaOp.EqOp eqop -> {\n@@ -216,1 +217,1 @@\n-                    case CoreOp.NeqOp neqop -> {\n+                    case JavaOp.NeqOp neqop -> {\n@@ -226,1 +227,1 @@\n-                    case CoreOp.LtOp ltop -> {\n+                    case JavaOp.LtOp ltop -> {\n@@ -233,1 +234,1 @@\n-                    case CoreOp.InvokeOp inv -> {\n+                    case JavaOp.InvokeOp inv -> {\n@@ -244,1 +245,1 @@\n-                    case CoreOp.ConvOp cop -> {\n+                    case JavaOp.ConvOp cop -> {\n@@ -250,1 +251,1 @@\n-                    case CoreOp.FieldAccessOp.FieldLoadOp flo -> {\n+                    case JavaOp.FieldAccessOp.FieldLoadOp flo -> {\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"cr-examples\/spirv\/src\/test\/java\/intel\/code\/spirv\/ExampleUseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,4 @@\n-import jdk.incubator.code.op.*;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Float16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.op.CoreOp;\n@@ -32,0 +31,2 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Functions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9,2 +9,3 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/MLIRGenerator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,4 +29,6 @@\n-import jdk.incubator.code.op.*;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.TupleType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,5 +31,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.CoreOp.VarAccessOp.VarLoadOp;\n-import jdk.incubator.code.op.CoreOp.VarAccessOp.VarStoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n@@ -44,1 +43,1 @@\n-    final ExtendedOp.JavaForOp fop;\n+    final JavaOp.JavaForOp fop;\n@@ -46,1 +45,1 @@\n-    SimpleCountedForLoopInfo(ExtendedOp.JavaForOp fop) {\n+    SimpleCountedForLoopInfo(JavaOp.JavaForOp fop) {\n@@ -94,2 +93,2 @@\n-                opP(CoreOp.LtOp.class,\n-                        opP(VarLoadOp.class,\n+                opP(JavaOp.LtOp.class,\n+                        opP(CoreOp.VarAccessOp.VarLoadOp.class,\n@@ -123,1 +122,1 @@\n-        Patterns.OpPattern p = opP(VarStoreOp.class,\n+        Patterns.OpPattern p = opP(CoreOp.VarAccessOp.VarStoreOp.class,\n@@ -125,2 +124,2 @@\n-                opP(CoreOp.AddOp.class,\n-                        opP(VarLoadOp.class, blockParameterP()),\n+                opP(JavaOp.AddOp.class,\n+                        opP(CoreOp.VarAccessOp.VarLoadOp.class, blockParameterP()),\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SimpleCountedForLoopInfo.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,2 +29,8 @@\n-import jdk.incubator.code.op.*;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreTypeFactory;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,3 +32,4 @@\n-import jdk.incubator.code.op.OpFactory;\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,4 +35,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.VarType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.core.VarType;\n@@ -43,2 +43,3 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n@@ -192,1 +193,1 @@\n-                case ExtendedOp.JavaForOp fop -> {\n+                case JavaOp.JavaForOp fop -> {\n@@ -207,1 +208,1 @@\n-                case ExtendedOp.JavaContinueOp _ -> {\n+                case JavaOp.JavaContinueOp _ -> {\n@@ -660,1 +661,1 @@\n-            case ExtendedOp.JavaForOp fop -> {\n+            case JavaOp.JavaForOp fop -> {\n@@ -676,1 +677,1 @@\n-    static void transformToSCFFor(CopyContext cc, Block.Builder kblock, ExtendedOp.JavaForOp fop,\n+    static void transformToSCFFor(CopyContext cc, Block.Builder kblock, JavaOp.JavaForOp fop,\n@@ -747,1 +748,1 @@\n-                        if (op instanceof ExtendedOp.JavaContinueOp) {\n+                        if (op instanceof JavaOp.JavaContinueOp) {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestAddKernel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestBroadcast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCdiv.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCountedLoop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.code.type.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestMatrix.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestMatrixFp16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestSoftMax.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestVariables.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestZeros.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -46,1 +49,0 @@\n-import jdk.incubator.code.op.CoreOp;\n@@ -48,1 +50,0 @@\n-import jdk.incubator.code.type.JavaType;\n@@ -106,1 +107,1 @@\n-                            .andThen(CoreOp.FACTORY),\n+                            .andThen(JavaOp.FACTORY),\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -138,1 +139,1 @@\n-            if (op instanceof CoreOp.InvokeOp invokeOp\n+            if (op instanceof JavaOp.InvokeOp invokeOp\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaC99HATKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHatKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -184,1 +185,1 @@\n-                    case CoreOp.NegOp op -> neg(op);\n+                    case JavaOp.NegOp op -> neg(op);\n@@ -247,16 +248,16 @@\n-            case CoreOp.ModOp _ -> rem();\n-            case CoreOp.MulOp _ -> mul();\n-            case CoreOp.DivOp _ -> div();\n-            case CoreOp.AddOp _ -> add();\n-            case CoreOp.SubOp _ -> sub();\n-            case CoreOp.LtOp _ -> lt();\n-            case CoreOp.GtOp _ -> gt();\n-            case CoreOp.LeOp _ -> le();\n-            case CoreOp.GeOp _ -> ge();\n-            case CoreOp.NeqOp _ -> ne();\n-            case CoreOp.EqOp _ -> eq();\n-            case CoreOp.OrOp _ -> or();\n-            case CoreOp.AndOp _ -> and();\n-            case CoreOp.XorOp _ -> xor();\n-            case CoreOp.LshlOp _ -> shl();\n-            case CoreOp.AshrOp _, CoreOp.LshrOp _ -> shr();\n+            case JavaOp.ModOp _ -> rem();\n+            case JavaOp.MulOp _ -> mul();\n+            case JavaOp.DivOp _ -> div();\n+            case JavaOp.AddOp _ -> add();\n+            case JavaOp.SubOp _ -> sub();\n+            case JavaOp.LtOp _ -> lt();\n+            case JavaOp.GtOp _ -> gt();\n+            case JavaOp.LeOp _ -> le();\n+            case JavaOp.GeOp _ -> ge();\n+            case JavaOp.NeqOp _ -> ne();\n+            case JavaOp.EqOp _ -> eq();\n+            case JavaOp.OrOp _ -> or();\n+            case JavaOp.AndOp _ -> and();\n+            case JavaOp.XorOp _ -> xor();\n+            case JavaOp.LshlOp _ -> shl();\n+            case JavaOp.AshrOp _, JavaOp.LshrOp _ -> shr();\n@@ -270,1 +271,1 @@\n-                && (op.op() instanceof CoreOp.DivOp || op.op() instanceof CoreOp.MulOp)) {\n+                && (op.op() instanceof JavaOp.DivOp || op.op() instanceof JavaOp.MulOp)) {\n@@ -273,1 +274,1 @@\n-                && op.op() instanceof CoreOp.MulOp) {\n+                && op.op() instanceof JavaOp.MulOp) {\n@@ -441,1 +442,1 @@\n-    public void neg(CoreOp.NegOp op) {\n+    public void neg(JavaOp.NegOp op) {\n@@ -510,1 +511,1 @@\n-        if (varToRegMap.get(val) == null && val instanceof Op.Result result && result.op() instanceof CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (varToRegMap.get(val) == null && val instanceof Op.Result result && result.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXPtrOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.dialect.java.JavaType;\n","filename":"hat\/backends\/ffi\/hip\/src\/main\/java\/hat\/backend\/HIPHatKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/TestIt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHatKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -41,3 +44,0 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n@@ -96,1 +96,1 @@\n-        bldr.op(CoreOp.invoke(wrapper.pre, cc, iface));\n+        bldr.op(JavaOp.invoke(wrapper.pre, cc, iface));\n@@ -98,1 +98,1 @@\n-        bldr.op(CoreOp.invoke(wrapper.post, cc, iface));\n+        bldr.op(JavaOp.invoke(wrapper.post, cc, iface));\n@@ -138,1 +138,1 @@\n-        record PrePost(MethodRef pre,MethodRef post) {\n+        record PrePost(MethodRef pre, MethodRef post) {\n@@ -154,1 +154,1 @@\n-                    bldr.op(CoreOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n+                    bldr.op(JavaOp.invoke(MUTATE.pre, computeContext, iface));  \/\/ cc->preMutate(iface);\n@@ -156,1 +156,1 @@\n-                    bldr.op(CoreOp.invoke(MUTATE.post, computeContext, iface));\n+                    bldr.op(JavaOp.invoke(MUTATE.post, computeContext, iface));\n@@ -175,1 +175,1 @@\n-                    bldr.op(CoreOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n+                    bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n@@ -177,1 +177,1 @@\n-                    bldr.op(CoreOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n+                    bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n@@ -180,1 +180,1 @@\n-                    bldr.op(CoreOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n+                    bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n@@ -182,1 +182,1 @@\n-                    bldr.op(CoreOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n+                    bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n@@ -205,1 +205,1 @@\n-                                         bldr.op(CoreOp.invoke(ACCESS.pre, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n+                                         bldr.op(JavaOp.invoke(ACCESS.pre, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n@@ -209,1 +209,1 @@\n-                                         bldr.op(CoreOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                         bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(typeAndAccess.value)));\n@@ -222,1 +222,1 @@\n-                                        bldr.op(CoreOp.invoke(ACCESS.post, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n+                                        bldr.op(JavaOp.invoke(ACCESS.post, cc,  bldrCntxt.getValue(typeAndAccess.value)));\n@@ -226,1 +226,1 @@\n-                                        bldr.op(CoreOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n+                                        bldr.op(JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(typeAndAccess.value)));\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/hat\/backend\/TestIt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import jdk.incubator.code.op.CoreOp;\n@@ -59,2 +58,3 @@\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.CoreOp;\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,4 +39,4 @@\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.code.op.CoreOp;\n@@ -41,1 +40,3 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -192,1 +193,1 @@\n-                    case CoreOp.ArrayAccessOp.ArrayLoadOp alo -> {\n+                    case JavaOp.ArrayAccessOp.ArrayLoadOp alo -> {\n@@ -204,1 +205,1 @@\n-                    case CoreOp.ArrayAccessOp.ArrayStoreOp aso -> {\n+                    case JavaOp.ArrayAccessOp.ArrayStoreOp aso -> {\n@@ -213,1 +214,1 @@\n-                    case CoreOp.ArrayLengthOp alo -> {\n+                    case JavaOp.ArrayLengthOp alo -> {\n@@ -218,1 +219,1 @@\n-                    case CoreOp.AndOp andop -> {\n+                    case JavaOp.AndOp andop -> {\n@@ -225,1 +226,1 @@\n-                    case CoreOp.AddOp aop -> {\n+                    case JavaOp.AddOp aop -> {\n@@ -235,1 +236,1 @@\n-                    case CoreOp.SubOp sop -> {\n+                    case JavaOp.SubOp sop -> {\n@@ -245,1 +246,1 @@\n-                    case CoreOp.MulOp mop -> {\n+                    case JavaOp.MulOp mop -> {\n@@ -255,1 +256,1 @@\n-                    case CoreOp.DivOp dop -> {\n+                    case JavaOp.DivOp dop -> {\n@@ -265,1 +266,1 @@\n-                    case CoreOp.ModOp mop -> {\n+                    case JavaOp.ModOp mop -> {\n@@ -272,1 +273,1 @@\n-                    case CoreOp.NegOp negop -> {\n+                    case JavaOp.NegOp negop -> {\n@@ -282,1 +283,1 @@\n-                    case CoreOp.EqOp eqop -> {\n+                    case JavaOp.EqOp eqop -> {\n@@ -292,1 +293,1 @@\n-                    case CoreOp.NeqOp neqop -> {\n+                    case JavaOp.NeqOp neqop -> {\n@@ -303,1 +304,1 @@\n-                    case CoreOp.LtOp ltop -> {\n+                    case JavaOp.LtOp ltop -> {\n@@ -310,1 +311,1 @@\n-                    case CoreOp.GtOp gtop -> {\n+                    case JavaOp.GtOp gtop -> {\n@@ -317,1 +318,1 @@\n-                    case CoreOp.GeOp geop -> {\n+                    case JavaOp.GeOp geop -> {\n@@ -324,1 +325,1 @@\n-                    case CoreOp.InvokeOp inv -> {\n+                    case JavaOp.InvokeOp inv -> {\n@@ -330,1 +331,1 @@\n-                    case CoreOp.ConstantOp cop -> {\n+                    case JavaOp.ConstantOp cop -> {\n@@ -335,1 +336,1 @@\n-                    case CoreOp.ConvOp cop -> {\n+                    case JavaOp.ConvOp cop -> {\n@@ -341,1 +342,1 @@\n-                    case CoreOp.FieldAccessOp.FieldLoadOp flo -> {\n+                    case JavaOp.FieldAccessOp.FieldLoadOp flo -> {\n@@ -346,1 +347,1 @@\n-                    case CoreOp.BranchOp bop -> {\n+                    case JavaOp.BranchOp bop -> {\n@@ -355,1 +356,1 @@\n-                    case CoreOp.ConditionalBranchOp cbop -> {\n+                    case JavaOp.ConditionalBranchOp cbop -> {\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -86,1 +86,1 @@\n-        bldr.op(CoreOp.invoke(wrapper.pre, cc, iface));\n+        bldr.op(JavaOp.invoke(wrapper.pre, cc, iface));\n@@ -88,1 +88,1 @@\n-        bldr.op(CoreOp.invoke(wrapper.post, cc, iface));\n+        bldr.op(JavaOp.invoke(wrapper.post, cc, iface));\n@@ -104,1 +104,1 @@\n-                    bldr.op(CoreOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n+                    bldr.op(JavaOp.invoke(MUTATE.pre, cc, iface));  \/\/ cc->preMutate(iface);\n@@ -106,1 +106,1 @@\n-                    bldr.op(CoreOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n+                    bldr.op(JavaOp.invoke(MUTATE.post, cc, iface)); \/\/ cc->postMutate(iface)\n@@ -109,1 +109,1 @@\n-                    bldr.op(CoreOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n+                    bldr.op(JavaOp.invoke(ACCESS.pre, cc, iface));  \/\/ cc->preAccess(iface);\n@@ -111,1 +111,1 @@\n-                    bldr.op(CoreOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n+                    bldr.op(JavaOp.invoke(ACCESS.post, cc, iface)); \/\/ cc->postAccess(iface) } else {\n@@ -118,1 +118,1 @@\n-                                    bldr.op(CoreOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(value)))\n+                                    bldr.op(JavaOp.invoke(MUTATE.pre, cc, bldrCntxt.getValue(value)))\n@@ -124,1 +124,1 @@\n-                                    CoreOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(value)))\n+                                    JavaOp.invoke(MUTATE.post, cc, bldrCntxt.getValue(value)))\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-                panel.add(new SevenSegmentDisplay(3,30,panel.getForeground(),panel.getBackground()));\n+                panel.add(new SevenSegmentDisplay(4,30,panel.getForeground(),panel.getBackground()));\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Viewer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n@@ -200,1 +202,1 @@\n-        LambdaOpWrapper lambda = OpWrapper.wrap(lookup,(CoreOp.LambdaOp) quoted.op());\n+        LambdaOpWrapper lambda = OpWrapper.wrap(lookup,(JavaOp.LambdaOp) quoted.op());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/Accelerator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -130,1 +130,1 @@\n-        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap(computeCallGraph.computeContext.accelerator.lookup,(CoreOp.LambdaOp) quoted.op());\n+        LambdaOpWrapper lambdaOpWrapper = OpWrapper.wrap(computeCallGraph.computeContext.accelerator.lookup,(JavaOp.LambdaOp) quoted.op());\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/ComputeContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,6 +48,8 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.op.OpFactory;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n@@ -128,1 +130,1 @@\n-                if (op instanceof CoreOp.InvokeOp invokeOp\n+                if (op instanceof JavaOp.InvokeOp invokeOp\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n@@ -39,2 +41,0 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FunctionType;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATComputeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -37,2 +39,0 @@\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/C99HATKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,5 +64,5 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -91,1 +91,1 @@\n-            case CoreOp.InvokeOp o -> 0;\n+            case JavaOp.InvokeOp o -> 0;\n@@ -95,1 +95,1 @@\n-            case CoreOp.FieldAccessOp o -> 0;\n+            case JavaOp.FieldAccessOp o -> 0;\n@@ -98,1 +98,1 @@\n-            case CoreOp.LambdaOp o -> 0;\n+            case JavaOp.LambdaOp o -> 0;\n@@ -100,25 +100,25 @@\n-            case ExtendedOp.JavaWhileOp o -> 0;\n-            case CoreOp.ConvOp o -> 1;\n-            case CoreOp.NegOp  o-> 1;\n-            case CoreOp.ModOp o -> 2;\n-            case CoreOp.MulOp o -> 2;\n-            case CoreOp.DivOp o -> 2;\n-            case CoreOp.NotOp o -> 2;\n-            case CoreOp.AddOp o -> 3;\n-            case CoreOp.SubOp o -> 3;\n-            case CoreOp.AshrOp o -> 4;\n-            case CoreOp.LshlOp o -> 4;\n-            case CoreOp.LshrOp o -> 4;\n-            case CoreOp.LtOp o -> 5;\n-            case CoreOp.GtOp o -> 5;\n-            case CoreOp.LeOp o -> 5;\n-            case CoreOp.GeOp o -> 5;\n-            case CoreOp.EqOp o -> 6;\n-            case CoreOp.NeqOp o -> 6;\n-\n-            case CoreOp.AndOp o -> 11;\n-            case CoreOp.XorOp o -> 12;\n-            case CoreOp.OrOp o -> 13;\n-            case ExtendedOp.JavaConditionalAndOp o -> 14;\n-            case ExtendedOp.JavaConditionalOrOp o -> 15;\n-            case ExtendedOp.JavaConditionalExpressionOp o -> 18;\n+            case JavaOp.JavaWhileOp o -> 0;\n+            case JavaOp.ConvOp o -> 1;\n+            case JavaOp.NegOp  o-> 1;\n+            case JavaOp.ModOp o -> 2;\n+            case JavaOp.MulOp o -> 2;\n+            case JavaOp.DivOp o -> 2;\n+            case JavaOp.NotOp o -> 2;\n+            case JavaOp.AddOp o -> 3;\n+            case JavaOp.SubOp o -> 3;\n+            case JavaOp.AshrOp o -> 4;\n+            case JavaOp.LshlOp o -> 4;\n+            case JavaOp.LshrOp o -> 4;\n+            case JavaOp.LtOp o -> 5;\n+            case JavaOp.GtOp o -> 5;\n+            case JavaOp.LeOp o -> 5;\n+            case JavaOp.GeOp o -> 5;\n+            case JavaOp.EqOp o -> 6;\n+            case JavaOp.NeqOp o -> 6;\n+\n+            case JavaOp.AndOp o -> 11;\n+            case JavaOp.XorOp o -> 12;\n+            case JavaOp.OrOp o -> 13;\n+            case JavaOp.JavaConditionalAndOp o -> 14;\n+            case JavaOp.JavaConditionalOrOp o -> 15;\n+            case JavaOp.JavaConditionalExpressionOp o -> 18;\n@@ -216,21 +216,21 @@\n-            case CoreOp.ModOp o -> percent();\n-            case CoreOp.MulOp o -> mul();\n-            case CoreOp.DivOp o -> div();\n-            case CoreOp.AddOp o -> plus();\n-            case CoreOp.SubOp o -> minus();\n-            case CoreOp.LtOp o -> lt();\n-            case CoreOp.GtOp o -> gt();\n-            case CoreOp.LeOp o -> lte();\n-            case CoreOp.GeOp o -> gte();\n-            case CoreOp.AshrOp o -> cchevron().cchevron();\n-            case CoreOp.LshlOp o -> ochevron().ochevron();\n-            case CoreOp.LshrOp o -> cchevron().cchevron();\n-            case CoreOp.NeqOp o -> pling().equals();\n-            case CoreOp.NegOp o -> minus();\n-            case CoreOp.EqOp o -> equals().equals();\n-            case CoreOp.NotOp o -> pling();\n-            case CoreOp.AndOp o -> ampersand();\n-            case CoreOp.OrOp o -> bar();\n-            case CoreOp.XorOp o -> hat();\n-            case ExtendedOp.JavaConditionalAndOp o -> condAnd();\n-            case ExtendedOp.JavaConditionalOrOp o -> condOr();\n+            case JavaOp.ModOp o -> percent();\n+            case JavaOp.MulOp o -> mul();\n+            case JavaOp.DivOp o -> div();\n+            case JavaOp.AddOp o -> plus();\n+            case JavaOp.SubOp o -> minus();\n+            case JavaOp.LtOp o -> lt();\n+            case JavaOp.GtOp o -> gt();\n+            case JavaOp.LeOp o -> lte();\n+            case JavaOp.GeOp o -> gte();\n+            case JavaOp.AshrOp o -> cchevron().cchevron();\n+            case JavaOp.LshlOp o -> ochevron().ochevron();\n+            case JavaOp.LshrOp o -> cchevron().cchevron();\n+            case JavaOp.NeqOp o -> pling().equals();\n+            case JavaOp.NegOp o -> minus();\n+            case JavaOp.EqOp o -> equals().equals();\n+            case JavaOp.NotOp o -> pling();\n+            case JavaOp.AndOp o -> ampersand();\n+            case JavaOp.OrOp o -> bar();\n+            case JavaOp.XorOp o -> hat();\n+            case JavaOp.JavaConditionalAndOp o -> condAnd();\n+            case JavaOp.JavaConditionalOrOp o -> condOr();\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/backend\/codebuilders\/HATCodeBuilderWithContext.java","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -32,1 +33,0 @@\n-import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,3 +38,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.code.type.MethodRef;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/opcodebuilders\/OpCodeBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +31,2 @@\n-public class BinaryArithmeticOrLogicOperation extends BinaryOpWrapper<CoreOp.BinaryOp> {\n-    BinaryArithmeticOrLogicOperation( MethodHandles.Lookup lookup, CoreOp.BinaryOp op) {\n+public class BinaryArithmeticOrLogicOperation extends BinaryOpWrapper<JavaOp.BinaryOp> {\n+    BinaryArithmeticOrLogicOperation( MethodHandles.Lookup lookup, JavaOp.BinaryOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryArithmeticOrLogicOperation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +31,2 @@\n-public class BinaryLogicalOpWrapper extends BinaryOpWrapper<CoreOp.BinaryOp> {\n-    BinaryLogicalOpWrapper( MethodHandles.Lookup lookup,CoreOp.BinaryOp op) {\n+public class BinaryLogicalOpWrapper extends BinaryOpWrapper<JavaOp.BinaryOp> {\n+    BinaryLogicalOpWrapper(MethodHandles.Lookup lookup, JavaOp.BinaryOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryLogicalOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +31,2 @@\n-public class BinaryTestOpWrapper extends BinaryOpWrapper<CoreOp.BinaryTestOp> {\n-    BinaryTestOpWrapper( MethodHandles.Lookup lookup,CoreOp.BinaryTestOp op) {\n+public class BinaryTestOpWrapper extends BinaryOpWrapper<JavaOp.BinaryTestOp> {\n+    BinaryTestOpWrapper( MethodHandles.Lookup lookup,JavaOp.BinaryTestOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/BinaryTestOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConstantOpWrapper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -32,2 +32,2 @@\n-public class ConvOpWrapper extends UnaryOpWrapper<CoreOp.ConvOp> {\n-    public ConvOpWrapper( MethodHandles.Lookup lookup,CoreOp.ConvOp op) {\n+public class ConvOpWrapper extends UnaryOpWrapper<JavaOp.ConvOp> {\n+    public ConvOpWrapper( MethodHandles.Lookup lookup,JavaOp.ConvOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.Type;\n@@ -30,5 +29,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -36,1 +34,1 @@\n-public abstract class FieldAccessOpWrapper<T extends CoreOp.FieldAccessOp> extends OpWrapper<T> {\n+public abstract class FieldAccessOpWrapper<T extends JavaOp.FieldAccessOp> extends OpWrapper<T> {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -34,2 +33,2 @@\n-public class FieldLoadOpWrapper extends FieldAccessOpWrapper<CoreOp.FieldAccessOp.FieldLoadOp> implements LoadOpWrapper {\n-    FieldLoadOpWrapper( MethodHandles.Lookup lookup,CoreOp.FieldAccessOp.FieldLoadOp op) {\n+public class FieldLoadOpWrapper extends FieldAccessOpWrapper<JavaOp.FieldAccessOp.FieldLoadOp> implements LoadOpWrapper {\n+    FieldLoadOpWrapper( MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldLoadOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldLoadOpWrapper.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,1 +32,1 @@\n-public class FieldStoreOpWrapper extends FieldAccessOpWrapper<CoreOp.FieldAccessOp.FieldStoreOp> implements StoreOpWrapper {\n+public class FieldStoreOpWrapper extends FieldAccessOpWrapper<JavaOp.FieldAccessOp.FieldStoreOp> implements StoreOpWrapper {\n@@ -35,1 +35,1 @@\n-    FieldStoreOpWrapper( MethodHandles.Lookup lookup,CoreOp.FieldAccessOp.FieldStoreOp op) {\n+    FieldStoreOpWrapper( MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldStoreOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FieldStoreOpWrapper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,2 +32,2 @@\n-public class ForOpWrapper extends LoopOpWrapper<ExtendedOp.JavaForOp> {\n-    ForOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaForOp op) {\n+public class ForOpWrapper extends LoopOpWrapper<JavaOp.JavaForOp> {\n+    ForOpWrapper( MethodHandles.Lookup lookup,JavaOp.JavaForOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,3 +38,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -166,1 +167,1 @@\n-    public BiMap<Block.Parameter, CoreOp.InvokeOp> parameterInvokeOpMap = new BiMap<>();\n+    public BiMap<Block.Parameter, JavaOp.InvokeOp> parameterInvokeOpMap = new BiMap<>();\n@@ -178,1 +179,1 @@\n-                }else if (resultOp instanceof CoreOp.InvokeOp invokeOp) {\n+                }else if (resultOp instanceof JavaOp.InvokeOp invokeOp) {\n@@ -231,1 +232,1 @@\n-            if (op instanceof CoreOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -242,1 +243,1 @@\n-            if (op instanceof CoreOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,2 +32,2 @@\n-public class IfOpWrapper extends StructuralOpWrapper<ExtendedOp.JavaIfOp> {\n-    public IfOpWrapper(MethodHandles.Lookup lookup,ExtendedOp.JavaIfOp op) {\n+public class IfOpWrapper extends StructuralOpWrapper<JavaOp.JavaIfOp> {\n+    public IfOpWrapper(MethodHandles.Lookup lookup,JavaOp.JavaIfOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,4 +34,5 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+\n@@ -40,1 +41,1 @@\n-public class InvokeOpWrapper extends OpWrapper<CoreOp.InvokeOp> {\n+public class InvokeOpWrapper extends OpWrapper<JavaOp.InvokeOp> {\n@@ -43,1 +44,1 @@\n-    public InvokeOpWrapper( MethodHandles.Lookup lookup,CoreOp.InvokeOp op) {\n+    public InvokeOpWrapper( MethodHandles.Lookup lookup,JavaOp.InvokeOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +31,2 @@\n-public class JavaBreakOpWrapper extends OpWrapper<ExtendedOp.JavaBreakOp> {\n-    public JavaBreakOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaBreakOp op) {\n+public class JavaBreakOpWrapper extends OpWrapper<JavaOp.JavaBreakOp> {\n+    public JavaBreakOpWrapper(MethodHandles.Lookup lookup, JavaOp.JavaBreakOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaBreakOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +32,2 @@\n-public class JavaContinueOpWrapper extends OpWrapper<ExtendedOp.JavaContinueOp> {\n-    public JavaContinueOpWrapper(MethodHandles.Lookup lookup,ExtendedOp.JavaContinueOp op) {\n+public class JavaContinueOpWrapper extends OpWrapper<JavaOp.JavaContinueOp> {\n+    public JavaContinueOpWrapper(MethodHandles.Lookup lookup, JavaOp.JavaContinueOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaContinueOpWrapper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +31,2 @@\n-public class JavaLabeledOpWrapper extends StructuralOpWrapper<ExtendedOp.JavaLabeledOp> {\n-    public JavaLabeledOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaLabeledOp op) {\n+public class JavaLabeledOpWrapper extends StructuralOpWrapper<JavaOp.JavaLabeledOp> {\n+    public JavaLabeledOpWrapper( MethodHandles.Lookup lookup,JavaOp.JavaLabeledOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/JavaLabeledOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,2 +34,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+\n@@ -40,2 +42,2 @@\n-public class LambdaOpWrapper extends OpWrapper<CoreOp.LambdaOp> {\n-    public LambdaOpWrapper( MethodHandles.Lookup lookup, CoreOp.LambdaOp op) {\n+public class LambdaOpWrapper extends OpWrapper<JavaOp.LambdaOp> {\n+    public LambdaOpWrapper( MethodHandles.Lookup lookup, JavaOp.LambdaOp op) {\n@@ -46,1 +48,1 @@\n-        var result = new Result<CoreOp.InvokeOp>();\n+        var result = new Result<JavaOp.InvokeOp>();\n@@ -63,2 +65,2 @@\n-                .filter(op -> op instanceof CoreOp.InvokeOp)\n-                .map(op -> (CoreOp.InvokeOp) op)\n+                .filter(op -> op instanceof JavaOp.InvokeOp)\n+                .map(op -> (JavaOp.InvokeOp) op)\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,2 +32,2 @@\n-public class LogicalOpWrapper extends BinaryOpWrapper<ExtendedOp.JavaConditionalOp> {\n-    LogicalOpWrapper(MethodHandles.Lookup lookup,ExtendedOp.JavaConditionalOp op) {\n+public class LogicalOpWrapper extends BinaryOpWrapper<JavaOp.JavaConditionalOp> {\n+    LogicalOpWrapper(MethodHandles.Lookup lookup,JavaOp.JavaConditionalOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -42,1 +43,1 @@\n-    ModuleOpWrapper(MethodHandles.Lookup lookup,CoreOp.ModuleOp op) {\n+    ModuleOpWrapper(MethodHandles.Lookup lookup, CoreOp.ModuleOp op) {\n@@ -72,1 +73,1 @@\n-     CoreOp.ModuleOp createTransitiveInvokeModule(\n+    CoreOp.ModuleOp createTransitiveInvokeModule(\n@@ -81,1 +82,1 @@\n-                            if (op instanceof CoreOp.InvokeOp invokeOp && OpWrapper.wrap(lookup, invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                            if (op instanceof JavaOp.InvokeOp invokeOp && OpWrapper.wrap(lookup, invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,4 +35,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -66,7 +66,7 @@\n-            case ExtendedOp.JavaForOp $ -> (OW) new ForOpWrapper(lookup, $);\n-            case ExtendedOp.JavaWhileOp $ -> (OW) new WhileOpWrapper(lookup, $);\n-            case ExtendedOp.JavaIfOp $ -> (OW) new IfOpWrapper(lookup, $);\n-            case CoreOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n-            case CoreOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n-            case CoreOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation(lookup, $);\n-            case CoreOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper(lookup, $);\n+            case JavaOp.JavaForOp $ -> (OW) new ForOpWrapper(lookup, $);\n+            case JavaOp.JavaWhileOp $ -> (OW) new WhileOpWrapper(lookup, $);\n+            case JavaOp.JavaIfOp $ -> (OW) new IfOpWrapper(lookup, $);\n+            case JavaOp.NotOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n+            case JavaOp.NegOp $ -> (OW) new UnaryArithmeticOrLogicOpWrapper(lookup, $);\n+            case JavaOp.BinaryOp $ -> (OW) new BinaryArithmeticOrLogicOperation(lookup, $);\n+            case JavaOp.BinaryTestOp $ -> (OW) new BinaryTestOpWrapper(lookup, $);\n@@ -77,1 +77,1 @@\n-            case CoreOp.ConvOp $ -> (OW) new ConvOpWrapper(lookup, $);\n+            case JavaOp.ConvOp $ -> (OW) new ConvOpWrapper(lookup, $);\n@@ -82,3 +82,3 @@\n-            case CoreOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper(lookup, $);\n-            case CoreOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper(lookup, $);\n-            case CoreOp.InvokeOp $ -> (OW) new InvokeOpWrapper(lookup, $);\n+            case JavaOp.FieldAccessOp.FieldStoreOp $ -> (OW) new FieldStoreOpWrapper(lookup, $);\n+            case JavaOp.FieldAccessOp.FieldLoadOp $ -> (OW) new FieldLoadOpWrapper(lookup, $);\n+            case JavaOp.InvokeOp $ -> (OW) new InvokeOpWrapper(lookup, $);\n@@ -86,6 +86,6 @@\n-            case CoreOp.LambdaOp $ -> (OW) new LambdaOpWrapper(lookup, $);\n-            case ExtendedOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper(lookup, $);\n-            case ExtendedOp.JavaConditionalExpressionOp $ -> (OW) new TernaryOpWrapper(lookup, $);\n-            case ExtendedOp.JavaLabeledOp $ -> (OW) new JavaLabeledOpWrapper(lookup, $);\n-            case ExtendedOp.JavaBreakOp $ -> (OW) new JavaBreakOpWrapper(lookup, $);\n-            case ExtendedOp.JavaContinueOp $ -> (OW) new JavaContinueOpWrapper(lookup, $);\n+            case JavaOp.LambdaOp $ -> (OW) new LambdaOpWrapper(lookup, $);\n+            case JavaOp.JavaConditionalOp $ -> (OW) new LogicalOpWrapper(lookup, $);\n+            case JavaOp.JavaConditionalExpressionOp $ -> (OW) new TernaryOpWrapper(lookup, $);\n+            case JavaOp.JavaLabeledOp $ -> (OW) new JavaLabeledOpWrapper(lookup, $);\n+            case JavaOp.JavaBreakOp $ -> (OW) new JavaBreakOpWrapper(lookup, $);\n+            case JavaOp.JavaContinueOp $ -> (OW) new JavaContinueOpWrapper(lookup, $);\n@@ -138,1 +138,1 @@\n-            if (op instanceof CoreOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/ReturnOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -46,1 +46,1 @@\n-        if (dependencyOnValue instanceof Op.Result or && or.op() instanceof CoreOps.VarAccessOp.VarLoadOp) {\n+        if (dependencyOnValue instanceof Op.Result or && or.op() instanceof JavaOps.VarAccessOp.VarLoadOp) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/RootSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -33,2 +33,2 @@\n-public class TernaryOpWrapper extends OpWrapper<ExtendedOp.JavaConditionalExpressionOp> {\n-    public TernaryOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaConditionalExpressionOp op) {\n+public class TernaryOpWrapper extends OpWrapper<JavaOp.JavaConditionalExpressionOp> {\n+    public TernaryOpWrapper( MethodHandles.Lookup lookup,JavaOp.JavaConditionalExpressionOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,1 +33,1 @@\n-    public TupleOpWrapper( MethodHandles.Lookup lookup,CoreOp.TupleOp op) {\n+    public TupleOpWrapper(MethodHandles.Lookup lookup, CoreOp.TupleOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/TupleOpWrapper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,2 +31,2 @@\n-public class UnaryArithmeticOrLogicOpWrapper extends UnaryOpWrapper<CoreOp.UnaryOp> {\n-    UnaryArithmeticOrLogicOpWrapper( MethodHandles.Lookup lookup,CoreOp.UnaryOp op) {\n+public class UnaryArithmeticOrLogicOpWrapper extends UnaryOpWrapper<JavaOp.UnaryOp> {\n+    UnaryArithmeticOrLogicOpWrapper( MethodHandles.Lookup lookup,JavaOp.UnaryOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/UnaryArithmeticOrLogicOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -32,1 +32,1 @@\n-    public VarDeclarationOpWrapper( MethodHandles.Lookup lookup,CoreOp.VarOp op) {\n+    public VarDeclarationOpWrapper(MethodHandles.Lookup lookup, CoreOp.VarOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarDeclarationOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarFuncDeclarationOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarLoadOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/VarStoreOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -32,1 +32,1 @@\n-public class WhileOpWrapper extends LoopOpWrapper<ExtendedOp.JavaWhileOp> {\n+public class WhileOpWrapper extends LoopOpWrapper<JavaOp.JavaWhileOp> {\n@@ -34,1 +34,1 @@\n-    WhileOpWrapper( MethodHandles.Lookup lookup,ExtendedOp.JavaWhileOp op) {\n+    WhileOpWrapper( MethodHandles.Lookup lookup,JavaOp.JavaWhileOp op) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/optools\/YieldOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -36,1 +37,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -86,1 +87,1 @@\n-            if (op instanceof CoreOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n","filename":"hat\/hat-core\/src\/main\/test\/hat\/CustomOpTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.EXTENDED_OP_CLASS.describeConstable().get(),\n+                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.JAVA_OP_CLASS.describeConstable().get(),\n@@ -510,1 +510,1 @@\n-        static final Class<?> EXTENDED_OP_CLASS;\n+        static final Class<?> JAVA_OP_CLASS;\n@@ -523,1 +523,1 @@\n-                FUNC_OP_CLASS = cl.loadClass(\"jdk.incubator.code.op.CoreOp$FuncOp\");\n+                FUNC_OP_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n@@ -527,4 +527,4 @@\n-                EXTENDED_OP_CLASS = cl.loadClass(\"jdk.incubator.code.op.ExtendedOp\");\n-                OP_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.op.OpFactory\");\n-                CORE_TYPE_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.type.CoreTypeFactory\");\n-                TYPE_ELEMENT_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.type.TypeElementFactory\");\n+                JAVA_OP_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.java.JavaOp\");\n+                OP_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.OpFactory\");\n+                CORE_TYPE_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.core.CoreTypeFactory\");\n+                TYPE_ELEMENT_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.TypeElementFactory\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -35,2 +35,2 @@\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp.branch;\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.core.CoreOp.branch;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Body.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,7 +42,7 @@\n-import jdk.incubator.code.op.CoreOp.FuncOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.op.OpFactory;\n-import jdk.incubator.code.type.CoreTypeFactory;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.TypeElementFactory;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.core.CoreTypeFactory;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -549,1 +549,1 @@\n-            FuncOp funcOp = (FuncOp) opMethod.invoke(null, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+            FuncOp funcOp = (FuncOp) opMethod.invoke(null, JavaOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import jdk.incubator.code.type.TypeElementFactory;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/TypeElement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n-import jdk.incubator.code.op.AnfDialect;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.dialect.anf.AnfDialect;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/AnfTransformer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n@@ -78,1 +80,1 @@\n-        } else if (op instanceof CoreOp.ExceptionRegionEnter ere) {\n+        } else if (op instanceof JavaOp.ExceptionRegionEnter ere) {\n@@ -81,1 +83,1 @@\n-        } else if (op instanceof CoreOp.ExceptionRegionExit ere) {\n+        } else if (op instanceof JavaOp.ExceptionRegionExit ere) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/NormalizeBlocksTransformer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Patterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSA.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSAConstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.java.*;\n@@ -35,1 +34,1 @@\n- * StringConcatTransformer is an {@link java.lang.reflect.code.OpTransformer} that removes concatenation operations\n+ * StringConcatTransformer is an {@link jdk.incubator.code.OpTransformer} that removes concatenation operations\n@@ -37,1 +36,1 @@\n- * to remove {@link java.lang.reflect.code.op.CoreOp.ConcatOp} for easier lowering to Bytecode.\n+ * to remove {@link jdk.incubator.code.dialect.java.JavaOp.ConcatOp} for easier lowering to Bytecode.\n@@ -50,1 +49,1 @@\n-            case CoreOp.ConcatOp cz when isRootConcat(cz) -> {\n+            case JavaOp.ConcatOp cz when isRootConcat(cz) -> {\n@@ -52,1 +51,1 @@\n-                Op.Result builder = block.apply(CoreOp._new(ConstructorRef.constructor(J_L_STRING_BUILDER)));\n+                Op.Result builder = block.apply(JavaOp._new(ConstructorRef.constructor(J_L_STRING_BUILDER)));\n@@ -55,1 +54,1 @@\n-                Value s = block.op(CoreOp.invoke(SB_TO_STRING_REF, builder));\n+                Value s = block.op(JavaOp.invoke(SB_TO_STRING_REF, builder));\n@@ -58,1 +57,1 @@\n-            case CoreOp.ConcatOp _ -> {\n+            case JavaOp.ConcatOp _ -> {\n@@ -66,1 +65,1 @@\n-    static boolean isRootConcat(CoreOp.ConcatOp cz) {\n+    static boolean isRootConcat(JavaOp.ConcatOp cz) {\n@@ -70,1 +69,1 @@\n-        return uses.size() != 1 || !(uses.iterator().next().op() instanceof CoreOp.ConcatOp);\n+        return uses.size() != 1 || !(uses.iterator().next().op() instanceof JavaOp.ConcatOp);\n@@ -73,1 +72,1 @@\n-    static void buildFromTree(Block.Builder block, Op.Result builder, CoreOp.ConcatOp cz) {\n+    static void buildFromTree(Block.Builder block, Op.Result builder, JavaOp.ConcatOp cz) {\n@@ -81,1 +80,1 @@\n-                r.op() instanceof CoreOp.ConcatOp cz &&\n+                r.op() instanceof JavaOp.ConcatOp cz &&\n@@ -99,1 +98,1 @@\n-                arg = block.op(CoreOp.conv(JavaType.INT, arg));\n+                arg = block.op(JavaOp.conv(JavaType.INT, arg));\n@@ -107,1 +106,1 @@\n-        return CoreOp.invoke(methodDesc, builder, arg);\n+        return JavaOp.invoke(methodDesc, builder, arg);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/StringConcatTransformer.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.classfile.attribute.ConstantValueAttribute;\n@@ -55,3 +54,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.CoreOp.*;\n-import jdk.incubator.code.op.OpFactory;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp.*;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.java.*;\n@@ -59,8 +59,3 @@\n-import jdk.incubator.code.type.ArrayType;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.PrimitiveType;\n-import jdk.incubator.code.type.TypeElementFactory;\n-import jdk.incubator.code.type.VarType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.core.VarType;\n@@ -77,0 +72,1 @@\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -55,1 +57,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -258,16 +260,16 @@\n-                        case IFNE -> CoreOp.eq(operand, liftConstant(0));\n-                        case IFEQ -> CoreOp.neq(operand, liftConstant(0));\n-                        case IFGE -> CoreOp.lt(operand, liftConstant(0));\n-                        case IFLE -> CoreOp.gt(operand, liftConstant(0));\n-                        case IFGT -> CoreOp.le(operand, liftConstant(0));\n-                        case IFLT -> CoreOp.ge(operand, liftConstant(0));\n-                        case IFNULL -> CoreOp.neq(operand, liftConstant(null));\n-                        case IFNONNULL -> CoreOp.eq(operand, liftConstant(null));\n-                        case IF_ICMPNE -> CoreOp.eq(stack.pop(), operand);\n-                        case IF_ICMPEQ -> CoreOp.neq(stack.pop(), operand);\n-                        case IF_ICMPGE -> CoreOp.lt(stack.pop(), operand);\n-                        case IF_ICMPLE -> CoreOp.gt(stack.pop(), operand);\n-                        case IF_ICMPGT -> CoreOp.le(stack.pop(), operand);\n-                        case IF_ICMPLT -> CoreOp.ge(stack.pop(), operand);\n-                        case IF_ACMPEQ -> CoreOp.neq(stack.pop(), operand);\n-                        case IF_ACMPNE -> CoreOp.eq(stack.pop(), operand);\n+                        case IFNE -> JavaOp.eq(operand, liftConstant(0));\n+                        case IFEQ -> JavaOp.neq(operand, liftConstant(0));\n+                        case IFGE -> JavaOp.lt(operand, liftConstant(0));\n+                        case IFLE -> JavaOp.gt(operand, liftConstant(0));\n+                        case IFGT -> JavaOp.le(operand, liftConstant(0));\n+                        case IFLT -> JavaOp.ge(operand, liftConstant(0));\n+                        case IFNULL -> JavaOp.neq(operand, liftConstant(null));\n+                        case IFNONNULL -> JavaOp.eq(operand, liftConstant(null));\n+                        case IF_ICMPNE -> JavaOp.eq(stack.pop(), operand);\n+                        case IF_ICMPEQ -> JavaOp.neq(stack.pop(), operand);\n+                        case IF_ICMPGE -> JavaOp.lt(stack.pop(), operand);\n+                        case IF_ICMPLE -> JavaOp.gt(stack.pop(), operand);\n+                        case IF_ICMPGT -> JavaOp.le(stack.pop(), operand);\n+                        case IF_ICMPLT -> JavaOp.ge(stack.pop(), operand);\n+                        case IF_ACMPEQ -> JavaOp.neq(stack.pop(), operand);\n+                        case IF_ACMPNE -> JavaOp.eq(stack.pop(), operand);\n@@ -298,1 +300,1 @@\n-                    op(CoreOp._throw(stack.pop()));\n+                    op(JavaOp._throw(stack.pop()));\n@@ -308,1 +310,1 @@\n-                    op(SlotOp.store(inst.slot(), op(CoreOp.add(op(SlotOp.load(inst.slot(), TypeKind.INT)), liftConstant(inst.constant())))));\n+                    op(SlotOp.store(inst.slot(), op(JavaOp.add(op(SlotOp.load(inst.slot(), TypeKind.INT)), liftConstant(inst.constant())))));\n@@ -314,1 +316,1 @@\n-                    stack.push(op(CoreOp.conv(switch (inst.toType()) {\n+                    stack.push(op(JavaOp.conv(switch (inst.toType()) {\n@@ -332,1 +334,1 @@\n-                                CoreOp.add(stack.pop(), operand);\n+                                JavaOp.add(stack.pop(), operand);\n@@ -334,1 +336,1 @@\n-                                CoreOp.sub(stack.pop(), operand);\n+                                JavaOp.sub(stack.pop(), operand);\n@@ -336,1 +338,1 @@\n-                                CoreOp.mul(stack.pop(), operand);\n+                                JavaOp.mul(stack.pop(), operand);\n@@ -338,1 +340,1 @@\n-                                CoreOp.div(stack.pop(), operand);\n+                                JavaOp.div(stack.pop(), operand);\n@@ -340,1 +342,1 @@\n-                                CoreOp.mod(stack.pop(), operand);\n+                                JavaOp.mod(stack.pop(), operand);\n@@ -342,1 +344,1 @@\n-                                CoreOp.neg(operand);\n+                                JavaOp.neg(operand);\n@@ -344,1 +346,1 @@\n-                                CoreOp.arrayLength(operand);\n+                                JavaOp.arrayLength(operand);\n@@ -346,1 +348,1 @@\n-                                CoreOp.and(stack.pop(), operand);\n+                                JavaOp.and(stack.pop(), operand);\n@@ -348,1 +350,1 @@\n-                                CoreOp.or(stack.pop(), operand);\n+                                JavaOp.or(stack.pop(), operand);\n@@ -350,1 +352,1 @@\n-                                CoreOp.xor(stack.pop(), operand);\n+                                JavaOp.xor(stack.pop(), operand);\n@@ -352,1 +354,1 @@\n-                                CoreOp.lshl(stack.pop(), operand);\n+                                JavaOp.lshl(stack.pop(), operand);\n@@ -354,1 +356,1 @@\n-                                CoreOp.ashr(stack.pop(), operand);\n+                                JavaOp.ashr(stack.pop(), operand);\n@@ -356,1 +358,1 @@\n-                                CoreOp.lshr(stack.pop(), operand);\n+                                JavaOp.lshr(stack.pop(), operand);\n@@ -358,1 +360,1 @@\n-                                CoreOp.invoke(LCMP, stack.pop(), operand);\n+                                JavaOp.invoke(LCMP, stack.pop(), operand);\n@@ -360,1 +362,1 @@\n-                                CoreOp.invoke(FCMP, stack.pop(), operand);\n+                                JavaOp.invoke(FCMP, stack.pop(), operand);\n@@ -362,1 +364,1 @@\n-                                CoreOp.invoke(DCMP, stack.pop(), operand);\n+                                JavaOp.invoke(DCMP, stack.pop(), operand);\n@@ -374,1 +376,1 @@\n-                                stack.push(op(CoreOp.fieldLoad(fd, stack.pop())));\n+                                stack.push(op(JavaOp.fieldLoad(fd, stack.pop())));\n@@ -376,1 +378,1 @@\n-                                stack.push(op(CoreOp.fieldLoad(fd)));\n+                                stack.push(op(JavaOp.fieldLoad(fd)));\n@@ -379,1 +381,1 @@\n-                                op(CoreOp.fieldStore(fd, stack.pop(), value));\n+                                op(JavaOp.fieldStore(fd, stack.pop(), value));\n@@ -382,1 +384,1 @@\n-                                op(CoreOp.fieldStore(fd, stack.pop()));\n+                                op(JavaOp.fieldStore(fd, stack.pop()));\n@@ -390,1 +392,1 @@\n-                    op(CoreOp.arrayStoreOp(stack.pop(), index, value));\n+                    op(JavaOp.arrayStoreOp(stack.pop(), index, value));\n@@ -396,1 +398,1 @@\n-                        stack.push(op(CoreOp.arrayLoadOp(array, index, switch (ali.typeKind()) {\n+                        stack.push(op(JavaOp.arrayLoadOp(array, index, switch (ali.typeKind()) {\n@@ -408,1 +410,1 @@\n-                        stack.push(op(CoreOp.arrayLoadOp(array, index)));\n+                        stack.push(op(JavaOp.arrayLoadOp(array, index)));\n@@ -424,1 +426,1 @@\n-                            yield op(CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.INSTANCE, false,\n+                            yield op(JavaOp.invoke(JavaOp.InvokeOp.InvokeKind.INSTANCE, false,\n@@ -428,1 +430,1 @@\n-                                op(CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.STATIC, false,\n+                                op(JavaOp.invoke(JavaOp.InvokeOp.InvokeKind.STATIC, false,\n@@ -433,1 +435,1 @@\n-                                yield op(CoreOp._new(\n+                                yield op(JavaOp._new(\n@@ -440,1 +442,1 @@\n-                                yield op(CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.SUPER, false,\n+                                yield op(JavaOp.invoke(JavaOp.InvokeOp.InvokeKind.SUPER, false,\n@@ -471,1 +473,1 @@\n-                        CoreOp.LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                        JavaOp.LambdaOp.Builder lambda = JavaOp.lambda(currentBlock.parentBody(),\n@@ -484,1 +486,1 @@\n-                                Op.Result ret = eb.op(CoreOp.invoke(\n+                                Op.Result ret = eb.op(JavaOp.invoke(\n@@ -502,1 +504,1 @@\n-                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                                res = res == null ? argVal : op(JavaOp.concat(res, argVal));\n@@ -520,1 +522,1 @@\n-                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                                res = res == null ? argVal : op(JavaOp.concat(res, argVal));\n@@ -535,2 +537,2 @@\n-                        Value methodHandle = op(CoreOp.invoke(MethodRef.method(CallSite.class, \"dynamicInvoker\", MethodHandle.class),\n-                                                    op(CoreOp.invoke(JavaType.type(ConstantDescs.CD_CallSite), bsmRef, bootstrapArgs))));\n+                        Value methodHandle = op(JavaOp.invoke(MethodRef.method(CallSite.class, \"dynamicInvoker\", MethodHandle.class),\n+                                                    op(JavaOp.invoke(JavaType.type(ConstantDescs.CD_CallSite), bsmRef, bootstrapArgs))));\n@@ -547,1 +549,1 @@\n-                        Op.Result result = op(CoreOp.invoke(mDesc, operands.reversed()));\n+                        Op.Result result = op(JavaOp.invoke(mDesc, operands.reversed()));\n@@ -565,1 +567,1 @@\n-                    stack.push(op(CoreOp.newArray(\n+                    stack.push(op(JavaOp.newArray(\n@@ -581,1 +583,1 @@\n-                    stack.push(op(CoreOp.newArray(\n+                    stack.push(op(JavaOp.newArray(\n@@ -586,1 +588,1 @@\n-                    stack.push(op(CoreOp._new(\n+                    stack.push(op(JavaOp._new(\n@@ -593,1 +595,1 @@\n-                    stack.push(op(CoreOp.cast(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                    stack.push(op(JavaOp.cast(JavaType.type(inst.type().asSymbol()), stack.pop())));\n@@ -596,1 +598,1 @@\n-                    stack.push(op(CoreOp.instanceOf(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                    stack.push(op(JavaOp.instanceOf(JavaType.type(inst.type().asSymbol()), stack.pop())));\n@@ -695,2 +697,2 @@\n-                        case MONITORENTER -> op(CoreOp.monitorEnter(monitor));\n-                        case MONITOREXIT -> op(CoreOp.monitorExit(monitor));\n+                        case MONITORENTER -> op(JavaOp.monitorEnter(monitor));\n+                        case MONITOREXIT -> op(JavaOp.monitorExit(monitor));\n@@ -713,1 +715,1 @@\n-        Op.Result array = op(CoreOp.newArray(arrayType, liftConstant(constants.length)));\n+        Op.Result array = op(JavaOp.newArray(arrayType, liftConstant(constants.length)));\n@@ -715,1 +717,1 @@\n-            op(CoreOp.arrayStoreOp(array, liftConstant(i), liftConstant(constants[i])));\n+            op(JavaOp.arrayStoreOp(array, liftConstant(i), liftConstant(constants[i])));\n@@ -745,1 +747,1 @@\n-                Op.Result lookup = op(CoreOp.invoke(LOOKUP));\n+                Op.Result lookup = op(JavaOp.invoke(LOOKUP));\n@@ -751,1 +753,1 @@\n-                        CoreOp.invoke(FIND_STATIC, lookup, owner, name, liftConstant(invDesc));\n+                        JavaOp.invoke(FIND_STATIC, lookup, owner, name, liftConstant(invDesc));\n@@ -753,1 +755,1 @@\n-                        CoreOp.invoke(FIND_VIRTUAL, lookup, owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)));\n+                        JavaOp.invoke(FIND_VIRTUAL, lookup, owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)));\n@@ -758,1 +760,1 @@\n-                        CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n+                        JavaOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n@@ -760,1 +762,1 @@\n-                        CoreOp.invoke(FIND_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                        JavaOp.invoke(FIND_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n@@ -762,1 +764,1 @@\n-                        CoreOp.invoke(FIND_STATIC_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                        JavaOp.invoke(FIND_STATIC_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n@@ -764,1 +766,1 @@\n-                        CoreOp.invoke(FIND_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(1)));\n+                        JavaOp.invoke(FIND_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(1)));\n@@ -766,1 +768,1 @@\n-                        CoreOp.invoke(FIND_STATIC_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(0)));\n+                        JavaOp.invoke(FIND_STATIC_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(0)));\n@@ -770,3 +772,3 @@\n-                case 0 -> CoreOp.invoke(METHOD_TYPE_0, liftConstant(mt.returnType()));\n-                case 1 -> CoreOp.invoke(METHOD_TYPE_1, liftConstant(mt.returnType()), liftConstant(mt.parameterType(0)));\n-                default -> CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), liftConstantsIntoArray(CLASS_ARRAY, (Object[])mt.parameterArray()));\n+                case 0 -> JavaOp.invoke(METHOD_TYPE_0, liftConstant(mt.returnType()));\n+                case 1 -> JavaOp.invoke(METHOD_TYPE_1, liftConstant(mt.returnType()), liftConstant(mt.parameterType(0)));\n+                default -> JavaOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), liftConstantsIntoArray(CLASS_ARRAY, (Object[])mt.parameterArray()));\n@@ -788,1 +790,1 @@\n-                yield op(CoreOp.invoke(bsmRef, bootstrapArgs));\n+                yield op(JavaOp.invoke(bsmRef, bootstrapArgs));\n@@ -800,1 +802,1 @@\n-        bootstrapArgs[0] = op(CoreOp.invoke(LOOKUP));\n+        bootstrapArgs[0] = op(JavaOp.invoke(LOOKUP));\n@@ -823,1 +825,1 @@\n-            v = op(CoreOp.conv(PrimitiveType.INT, v));\n+            v = op(JavaOp.conv(PrimitiveType.INT, v));\n@@ -830,1 +832,1 @@\n-                        op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                        op(JavaOp.eq(v, liftConstant(sc.caseValue()))),\n@@ -836,1 +838,1 @@\n-                        op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                        op(JavaOp.eq(v, liftConstant(sc.caseValue()))),\n@@ -917,1 +919,1 @@\n-        currentBlock.op(enter ? CoreOp.exceptionRegionEnter(ref, catcher) : CoreOp.exceptionRegionExit(ref, catcher));\n+        currentBlock.op(enter ? JavaOp.exceptionRegionEnter(ref, catcher) : JavaOp.exceptionRegionExit(ref, catcher));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeLift.java","additions":83,"deletions":81,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.op.OpFactory;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.PrimitiveType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,2 +36,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -69,1 +70,1 @@\n-                case CoreOp.ExceptionRegionEnter ere -> {\n+                case JavaOp.ExceptionRegionEnter ere -> {\n@@ -84,1 +85,1 @@\n-                case CoreOp.ExceptionRegionExit ere -> {\n+                case JavaOp.ExceptionRegionExit ere -> {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotToVarTransformer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,6 +33,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.ArrayType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.PrimitiveType;\n-import jdk.incubator.code.type.VarType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.*;\n+import jdk.incubator.code.dialect.core.VarType;\n@@ -130,1 +127,1 @@\n-                    case CoreOp.LshlOp _, CoreOp.LshrOp _, CoreOp.AshrOp _ ->\n+                    case JavaOp.LshlOp _, JavaOp.LshrOp _, JavaOp.AshrOp _ ->\n@@ -132,1 +129,1 @@\n-                    case CoreOp.BinaryOp bo ->\n+                    case JavaOp.BinaryOp bo ->\n@@ -134,1 +131,1 @@\n-                    case CoreOp.InvokeOp io -> {\n+                    case JavaOp.InvokeOp io -> {\n@@ -142,1 +139,1 @@\n-                    case CoreOp.FieldAccessOp fao ->\n+                    case JavaOp.FieldAccessOp fao ->\n@@ -150,1 +147,1 @@\n-                    case CoreOp.NewOp no ->\n+                    case JavaOp.NewOp no ->\n@@ -152,1 +149,1 @@\n-                    case CoreOp.ArrayAccessOp.ArrayLoadOp alo ->\n+                    case JavaOp.ArrayAccessOp.ArrayLoadOp alo ->\n@@ -154,1 +151,1 @@\n-                    case CoreOp.ArrayAccessOp.ArrayStoreOp aso ->\n+                    case JavaOp.ArrayAccessOp.ArrayStoreOp aso ->\n@@ -186,1 +183,1 @@\n-                case CoreOp.UnaryOp uo ->\n+                case JavaOp.UnaryOp uo ->\n@@ -188,1 +185,1 @@\n-                case CoreOp.BinaryOp bo ->\n+                case JavaOp.BinaryOp bo ->\n@@ -195,1 +192,1 @@\n-                case CoreOp.ArrayAccessOp.ArrayLoadOp alo ->\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alo ->\n@@ -316,1 +313,1 @@\n-                case CoreOp.ArrayAccessOp.ArrayLoadOp alop when op.resultType() instanceof UnresolvedType -> {\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alop when op.resultType() instanceof UnresolvedType -> {\n@@ -320,1 +317,1 @@\n-                    cc.mapValue(op.result(), block.op(CoreOp.arrayLoadOp(cc.getValueOrDefault(array, array), cc.getValueOrDefault(index, index))));\n+                    cc.mapValue(op.result(), block.op(JavaOp.arrayLoadOp(cc.getValueOrDefault(array, array), cc.getValueOrDefault(index, index))));\n@@ -332,1 +329,1 @@\n-                case CoreOp.BinaryTestOp _ ->\n+                case JavaOp.BinaryTestOp _ ->\n@@ -334,1 +331,1 @@\n-                case CoreOp.LshlOp _, CoreOp.LshrOp _, CoreOp.AshrOp _ ->\n+                case JavaOp.LshlOp _, JavaOp.LshrOp _, JavaOp.AshrOp _ ->\n@@ -336,1 +333,1 @@\n-                case CoreOp.BinaryOp _ ->\n+                case JavaOp.BinaryOp _ ->\n@@ -351,1 +348,1 @@\n-            cc.mapValue(first, block.op(CoreOp.conv(firstType, cc.getValueOrDefault(first, first))));\n+            cc.mapValue(first, block.op(JavaOp.conv(firstType, cc.getValueOrDefault(first, first))));\n@@ -356,1 +353,1 @@\n-            cc.mapValue(second, block.op(CoreOp.conv(secondType, cc.getValueOrDefault(second, second))));\n+            cc.mapValue(second, block.op(JavaOp.conv(secondType, cc.getValueOrDefault(second, second))));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.op;\n+package jdk.incubator.code.dialect;\n@@ -29,1 +29,1 @@\n-import java.util.HashMap;\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/ExternalizableOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExternalizableOp.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.op;\n+package jdk.incubator.code.dialect;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/OpFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/OpFactory.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/TypeElementFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TypeElementFactory.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.op;\n+package jdk.incubator.code.dialect.anf;\n@@ -28,3 +28,0 @@\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.io.Writer;\n@@ -32,1 +29,3 @@\n-import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n@@ -36,1 +35,1 @@\n-import static jdk.incubator.code.op.OpFactory.*;\n+import static jdk.incubator.code.dialect.OpFactory.*;\n@@ -265,1 +264,1 @@\n-    @OpFactory.OpDeclaration(AnfFuncOp.NAME)\n+    @OpDeclaration(AnfFuncOp.NAME)\n@@ -366,1 +365,1 @@\n-    @OpFactory.OpDeclaration(AnfApply.NAME)\n+    @OpDeclaration(AnfApply.NAME)\n@@ -402,1 +401,1 @@\n-    @OpFactory.OpDeclaration(AnfApplyStub.NAME)\n+    @OpDeclaration(AnfApplyStub.NAME)\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/anf\/AnfDialect.java","additions":8,"deletions":9,"binary":false,"changes":17,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/AnfDialect.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n- * Types and symbolic references for code models.\n+ * The ANF dialect.\n@@ -29,1 +29,1 @@\n-package jdk.incubator.code.type;\n\\ No newline at end of file\n+package jdk.incubator.code.dialect.anf;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/anf\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/package-info.java","status":"copied"},{"patch":"@@ -0,0 +1,1726 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.dialect.core;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.java.*;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * The top-level operation class for the set of enclosed core operations.\n+ * <p>\n+ * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n+ * operations. Such a model represents the same Java program and preserves the program meaning as defined by the\n+ * Java Language Specification\n+ *\/\n+public sealed abstract class CoreOp extends ExternalizableOp {\n+\n+    static final String PACKAGE_NAME = CodeReflection.class.getPackageName();\n+\n+    protected CoreOp(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+\n+    protected CoreOp(String name, List<? extends Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    protected CoreOp(ExternalizedOp def) {\n+        super(def);\n+    }\n+\n+    \/**\n+     * The function operation, that can model a Java method declaration.\n+     *\/\n+    @OpFactory.OpDeclaration(FuncOp.NAME)\n+    public static final class FuncOp extends CoreOp\n+            implements Op.Invokable, Op.Isolated, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final String funcName;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcName = funcName;\n+                this.funcType = funcType;\n+            }\n+\n+            public FuncOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new FuncOp(funcName, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"func\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final Body body;\n+\n+        public static FuncOp create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new FuncOp(def, funcName);\n+        }\n+\n+        FuncOp(ExternalizedOp def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        FuncOp(FuncOp that, CopyContext cc, OpTransformer oa) {\n+            this(that, that.funcName, cc, oa);\n+        }\n+\n+        FuncOp(FuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.funcName = funcName;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, cc, ot);\n+        }\n+\n+        public FuncOp transform(OpTransformer ot) {\n+            return new FuncOp(this, CopyContext.create(), ot);\n+        }\n+\n+        public FuncOp transform(String funcName, OpTransformer ot) {\n+            return new FuncOp(this, funcName, CopyContext.create(), ot);\n+        }\n+\n+        FuncOp(String funcName, Body.Builder bodyBuilder) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.funcName = funcName;\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The function call operation, that models a call to a function, by name, declared in the module op that is also an\n+     * ancestor of this operation.\n+     *\/\n+    \/\/ @@@ stack effects equivalent to the call operation as if the function were a Java method?\n+    @OpFactory.OpDeclaration(FuncCallOp.NAME)\n+    public static final class FuncCallOp extends CoreOp {\n+        public static final String NAME = \"func.call\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final TypeElement resultType;\n+\n+        public static FuncCallOp create(ExternalizedOp def) {\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+\n+            return new FuncCallOp(def, funcName);\n+        }\n+\n+        FuncCallOp(ExternalizedOp def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.resultType = def.resultType();\n+        }\n+\n+        FuncCallOp(FuncCallOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.funcName = that.funcName;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public FuncCallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncCallOp(this, cc);\n+        }\n+\n+        FuncCallOp(String funcName, TypeElement resultType, List<Value> args) {\n+            super(NAME, args);\n+\n+            this.funcName = funcName;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The module operation, modeling a collection of functions,\n+     * and creating a symbol table of function name to function\n+     *\/\n+    @OpFactory.OpDeclaration(ModuleOp.NAME)\n+    public static final class ModuleOp extends CoreOp\n+            implements Op.Isolated, Op.Lowerable {\n+\n+        public static final String NAME = \"module\";\n+\n+        final SequencedMap<String, FuncOp> table;\n+        final Body body;\n+\n+        public static ModuleOp create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            return new ModuleOp(def);\n+        }\n+\n+        ModuleOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        ModuleOp(ModuleOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        static SequencedMap<String, FuncOp> createTable(Body body) {\n+            SequencedMap<String, FuncOp> table = new LinkedHashMap<>();\n+            for (var op : body.entryBlock().ops()) {\n+                if (op instanceof FuncOp fop) {\n+                    table.put(fop.funcName(), fop);\n+                } else if (!(op instanceof Op.Terminating)) {\n+                    throw new IllegalArgumentException(\"Bad operation in module: \" + op);\n+                }\n+            }\n+            return Collections.unmodifiableSequencedMap(table);\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc, ot);\n+        }\n+\n+        public ModuleOp transform(OpTransformer ot) {\n+            return new ModuleOp(this, CopyContext.create(), ot);\n+        }\n+\n+        ModuleOp(List<FuncOp> functions) {\n+            super(NAME,\n+                    List.of());\n+\n+            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n+            Block.Builder entryBlock = bodyC.entryBlock();\n+            SequencedMap<String, FuncOp> table = new LinkedHashMap<>();\n+            for (FuncOp f : functions) {\n+                entryBlock.op(f);\n+                table.put(f.funcName(), f);\n+            }\n+            entryBlock.op(CoreOp.unreachable());\n+            this.table = Collections.unmodifiableSequencedMap(table);\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public SequencedMap<String, FuncOp> functionTable() {\n+            return table;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The quoted operation, that models the quoting of an operation.\n+     *\/\n+    @OpFactory.OpDeclaration(QuotedOp.NAME)\n+    public static final class QuotedOp extends CoreOp\n+            implements Op.Nested, Op.Lowerable, Op.Pure {\n+        public static final String NAME = \"quoted\";\n+\n+        \/\/ Type name must be the same in the java.base and jdk.compiler module\n+        static final String Quoted_CLASS_NAME = PACKAGE_NAME +\n+                \".\" + Quoted.class.getSimpleName();\n+        public static final JavaType QUOTED_TYPE = JavaType.type(ClassDesc.of(Quoted_CLASS_NAME));\n+\n+        final Body quotedBody;\n+\n+        final Op quotedOp;\n+\n+        public QuotedOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.quotedBody = def.bodyDefinitions().get(0).build(this);\n+\n+            if (quotedBody.entryBlock().terminatingOp() instanceof YieldOp brk &&\n+                    brk.yieldValue() instanceof Result quotedOpResult) {\n+                this.quotedOp = quotedOpResult.op();\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        QuotedOp(QuotedOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.quotedBody = that.quotedBody.transform(cc, ot).build(this);\n+            this.quotedOp = that.quotedOp;\n+        }\n+\n+        @Override\n+        public QuotedOp transform(CopyContext cc, OpTransformer ot) {\n+            return new QuotedOp(this, cc, ot);\n+        }\n+\n+        QuotedOp(Body.Builder bodyC) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.quotedBody = bodyC.build(this);\n+            if (quotedBody.blocks().size() > 1) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!(quotedBody.entryBlock().terminatingOp() instanceof YieldOp yop)) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!(yop.yieldValue() instanceof Result r)) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.quotedOp = r.op();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(quotedBody);\n+        }\n+\n+        public Op quotedOp() {\n+            return quotedOp;\n+        }\n+\n+        @Override\n+        public List<Value> capturedValues() {\n+            return quotedBody.capturedValues();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            \/\/ and copy directly without lowering descendant operations\n+            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return QUOTED_TYPE;\n+        }\n+    }\n+\n+    \/**\n+     * The closure operation, that can model a structured Java lambda expression\n+     * that has no target type (a functional interface).\n+     *\/\n+    @OpFactory.OpDeclaration(ClosureOp.NAME)\n+    public static final class ClosureOp extends CoreOp\n+            implements Op.Invokable, Op.Lowerable, JavaOp.JavaExpression {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcType = funcType;\n+            }\n+\n+            public ClosureOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new ClosureOp(body);\n+            }\n+        }\n+\n+        public static final String NAME = \"closure\";\n+\n+        final Body body;\n+\n+        public ClosureOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        ClosureOp(ClosureOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public ClosureOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ClosureOp(this, cc, ot);\n+        }\n+\n+        ClosureOp(Body.Builder bodyC) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public List<Value> capturedValues() {\n+            return body.capturedValues();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return body.bodyType();\n+        }\n+    }\n+\n+    \/**\n+     * The closure call operation, that models a call to a closure, by reference\n+     *\/\n+\/\/  @@@ stack effects equivalent to the invocation of an SAM of on an instance of an anonymous functional interface\n+\/\/  that is the target of the closures lambda expression.\n+    @OpFactory.OpDeclaration(ClosureCallOp.NAME)\n+    public static final class ClosureCallOp extends CoreOp {\n+        public static final String NAME = \"closure.call\";\n+\n+        public ClosureCallOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        ClosureCallOp(ClosureCallOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ClosureCallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ClosureCallOp(this, cc);\n+        }\n+\n+        ClosureCallOp(List<Value> args) {\n+            super(NAME, args);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            FunctionType ft = (FunctionType) operands().getFirst().type();\n+            return ft.returnType();\n+        }\n+    }\n+\n+    \/**\n+     * The terminating return operation, that can model the Java language return statement.\n+     * <p>\n+     * This operation exits an isolated body.\n+     *\/\n+    @OpFactory.OpDeclaration(ReturnOp.NAME)\n+    public static final class ReturnOp extends CoreOp\n+            implements Op.BodyTerminating, JavaOp.JavaStatement {\n+        public static final String NAME = \"return\";\n+\n+        public ReturnOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+\n+        ReturnOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        ReturnOp(Value operand) {\n+            super(NAME, List.of(operand));\n+        }\n+\n+        public Value returnValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating unreachable operation.\n+     * <p>\n+     * This operation models termination that is unreachable.\n+     *\/\n+    @OpFactory.OpDeclaration(UnreachableOp.NAME)\n+    public static final class UnreachableOp extends CoreOp\n+            implements Op.BodyTerminating {\n+        public static final String NAME = \"unreachable\";\n+\n+        public UnreachableOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must zero operands \" + def.name());\n+            }\n+        }\n+\n+        UnreachableOp(UnreachableOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public UnreachableOp transform(CopyContext cc, OpTransformer ot) {\n+            return new UnreachableOp(this, cc);\n+        }\n+\n+        UnreachableOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating yield operation.\n+     * <p>\n+     * This operation models exits from its parent body, yielding at most one value (zero value for yielding unit\n+     * or void)\n+     *\/\n+    @OpFactory.OpDeclaration(YieldOp.NAME)\n+    public static final class YieldOp extends CoreOp\n+            implements Op.BodyTerminating {\n+        public static final String NAME = \"yield\";\n+\n+        public YieldOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        YieldOp(YieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public YieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new YieldOp(this, cc);\n+        }\n+\n+        YieldOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        YieldOp(List<Value> operands) {\n+            super(NAME, operands);\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating unconditional branch operation.\n+     * <p>\n+     * This operation accepts a successor to the next block to branch to.\n+     *\/\n+    @OpFactory.OpDeclaration(BranchOp.NAME)\n+    public static final class BranchOp extends CoreOp\n+            implements Op.BlockTerminating {\n+        public static final String NAME = \"branch\";\n+\n+        final Block.Reference b;\n+\n+        public BranchOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty() || def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero arguments and one successor\" + def.name());\n+            }\n+\n+            this.b = def.successors().get(0);\n+        }\n+\n+        BranchOp(BranchOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.b = cc.getSuccessorOrCreate(that.b);\n+        }\n+\n+        @Override\n+        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BranchOp(this, cc);\n+        }\n+\n+        BranchOp(Block.Reference successor) {\n+            super(NAME, List.of());\n+\n+            this.b = successor;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(b);\n+        }\n+\n+        public Block.Reference branch() {\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating conditional branch operation.\n+     * <p>\n+     * This operation accepts a boolean operand and two successors, the true successor and false successor.\n+     * When the operand is true the  true successor is selected, otherwise the false successor is selected.\n+     * The selected successor refers to the next block to branch to.\n+     *\/\n+    @OpFactory.OpDeclaration(ConditionalBranchOp.NAME)\n+    public static final class ConditionalBranchOp extends CoreOp\n+            implements Op.BlockTerminating {\n+        public static final String NAME = \"cbranch\";\n+\n+        final Block.Reference t;\n+        final Block.Reference f;\n+\n+        public ConditionalBranchOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1 || def.successors().size() != 2) {\n+                throw new IllegalArgumentException(\"Operation must one operand and two successors\" + def.name());\n+            }\n+\n+            this.t = def.successors().get(0);\n+            this.f = def.successors().get(1);\n+        }\n+\n+        ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.t = cc.getSuccessorOrCreate(that.t);\n+            this.f = cc.getSuccessorOrCreate(that.f);\n+        }\n+\n+        @Override\n+        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConditionalBranchOp(this, cc);\n+        }\n+\n+        ConditionalBranchOp(Value p, Block.Reference t, Block.Reference f) {\n+            super(NAME, List.of(p));\n+\n+            this.t = t;\n+            this.f = f;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(t, f);\n+        }\n+\n+        public Value predicate() {\n+            return operands().get(0);\n+        }\n+\n+        public Block.Reference trueBranch() {\n+            return t;\n+        }\n+\n+        public Block.Reference falseBranch() {\n+            return f;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The constant operation, that can model Java language literal and constant expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(ConstantOp.NAME)\n+    public static final class ConstantOp extends CoreOp\n+            implements Op.Pure, JavaOp.JavaExpression {\n+        public static final String NAME = \"constant\";\n+\n+        public static final String ATTRIBUTE_CONSTANT_VALUE = NAME + \".value\";\n+\n+        final Object value;\n+        final TypeElement type;\n+\n+        public static ConstantOp create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have zero operands\");\n+            }\n+\n+            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE, true,\n+                    v -> processConstantValue(def.resultType(), v));\n+            return new ConstantOp(def, value);\n+        }\n+\n+        static Object processConstantValue(TypeElement t, Object value) {\n+            if (t.equals(JavaType.BOOLEAN) && value instanceof Boolean) {\n+                return value;\n+            } else if (t.equals(JavaType.BYTE) && value instanceof Number n) {\n+                return n.byteValue();\n+            } else if (t.equals(JavaType.SHORT) && value instanceof Number n) {\n+                return n.shortValue();\n+            } else if (t.equals(JavaType.CHAR) && value instanceof Character) {\n+                return value;\n+            } else if (t.equals(JavaType.INT) && value instanceof Number n) {\n+                return n.intValue();\n+            } else if (t.equals(JavaType.LONG) && value instanceof Number n) {\n+                return n.longValue();\n+            } else if (t.equals(JavaType.FLOAT) && value instanceof Number n) {\n+                return n.floatValue();\n+            } else if (t.equals(JavaType.DOUBLE) && value instanceof Number n) {\n+                return n.doubleValue();\n+            } else if (t.equals(JavaType.J_L_STRING)) {\n+                return value == NULL_ATTRIBUTE_VALUE ?\n+                        null : (String)value;\n+            } else if (t.equals(JavaType.J_L_CLASS)) {\n+                return value == NULL_ATTRIBUTE_VALUE ?\n+                        null : (TypeElement)value;\n+            } else if (value == NULL_ATTRIBUTE_VALUE) {\n+                return null; \/\/ null constant\n+            }\n+\n+            throw new UnsupportedOperationException(\"Unsupported constant type and value: \" + t + \" \" + value);\n+        }\n+\n+        ConstantOp(ExternalizedOp def, Object value) {\n+            super(def);\n+\n+            this.type = def.resultType();\n+            this.value = value;\n+        }\n+\n+        ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        ConstantOp(TypeElement type, Object value) {\n+            super(NAME, List.of());\n+\n+            this.type = type;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", value == null ? NULL_ATTRIBUTE_VALUE : value);\n+            return attrs;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n+\n+    \/**\n+     * A runtime representation of a variable.\n+     *\n+     * @param <T> the type of the var's value.\n+     * @@@ Ideally should never be exposed\n+     * @@@ Move to interpreter?\n+     *\/\n+    public interface Var<T> {\n+        \/**\n+         * {@return the value of a var}\n+         *\/\n+        T value();\n+\n+        \/**\n+         * Constructs an instance of a var.\n+         *\n+         * @param value the initial value of the var.\n+         * @param <T>   the type of the var's value.\n+         * @return the var\n+         *\/\n+        static <T> Var<T> of(T value) {\n+            return () -> value;\n+        }\n+    }\n+\n+    \/**\n+     * The variable operation, that can model declarations of Java language local variables, method parameters, or\n+     * lambda parameters.\n+     *\/\n+    @OpFactory.OpDeclaration(VarOp.NAME)\n+    public static final class VarOp extends CoreOp\n+            implements JavaOp.JavaStatement {\n+        public static final String NAME = \"var\";\n+        public static final String ATTRIBUTE_NAME = NAME + \".name\";\n+\n+        final String varName;\n+        final VarType resultType;\n+\n+        public static VarOp create(ExternalizedOp def) {\n+            if (def.operands().size() > 1) {\n+                throw new IllegalStateException(\"Operation must have zero or one operand\");\n+            }\n+\n+            String name = def.extractAttributeValue(ATTRIBUTE_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null -> \"\";\n+                        default -> throw new UnsupportedOperationException(\"Unsupported var name value:\" + v);\n+                    });\n+            return new VarOp(def, name);\n+        }\n+\n+        VarOp(ExternalizedOp def, String varName) {\n+            super(def);\n+\n+            this.varName = varName;\n+            this.resultType = (VarType) def.resultType();\n+        }\n+\n+        VarOp(VarOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.varName = that.varName;\n+            this.resultType = that.isResultTypeOverridable()\n+                    ? VarType.varType(initOperand().type()) : that.resultType;\n+        }\n+\n+        boolean isResultTypeOverridable() {\n+            return !isUninitialized() && resultType().valueType().equals(initOperand().type());\n+        }\n+\n+        @Override\n+        public VarOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VarOp(this, cc);\n+        }\n+\n+        VarOp(String varName, Value init) {\n+            this(varName, init.type(), init);\n+        }\n+\n+        VarOp(String varName, TypeElement type, Value init) {\n+            super(NAME, List.of(init));\n+\n+            this.varName =  varName == null ? \"\" : varName;\n+            this.resultType = VarType.varType(type);\n+        }\n+\n+        \/\/ @@@ This and the above constructor can be merged when\n+        \/\/ statements before super can be used in the jdk.compiler module\n+        VarOp(String varName, TypeElement type) {\n+            super(NAME, List.of());\n+\n+            this.varName =  varName == null ? \"\" : varName;\n+            this.resultType = VarType.varType(type);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            if (isUnnamedVariable()) {\n+                return super.attributes();\n+            }\n+\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", varName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public Value initOperand() {\n+            if (operands().isEmpty()) {\n+                throw new IllegalStateException(\"Uninitialized variable\");\n+            }\n+            return operands().getFirst();\n+        }\n+\n+        public String varName() {\n+            return varName;\n+        }\n+\n+        public TypeElement varValueType() {\n+            return resultType.valueType();\n+        }\n+\n+        @Override\n+        public VarType resultType() {\n+            return resultType;\n+        }\n+\n+        public boolean isUnnamedVariable() {\n+            return varName.isEmpty();\n+        }\n+\n+        public boolean isUninitialized() {\n+            return operands().isEmpty();\n+        }\n+    }\n+\n+    \/**\n+     * The var access operation, that can model access to Java language local variables, method parameters, or\n+     * lambda parameters.\n+     *\/\n+    public sealed abstract static class VarAccessOp extends CoreOp\n+            implements JavaOp.AccessOp {\n+        VarAccessOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        VarAccessOp(VarAccessOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        VarAccessOp(String name, List<Value> operands) {\n+            super(name, operands);\n+        }\n+\n+        public Value varOperand() {\n+            return operands().getFirst();\n+        }\n+\n+        public VarType varType() {\n+            return (VarType) varOperand().type();\n+        }\n+\n+        public VarOp varOp() {\n+            if (!(varOperand() instanceof Result varValue)) {\n+                throw new IllegalStateException(\"Variable access to block parameter: \" + varOperand());\n+            }\n+\n+            \/\/ At a high-level a variable value can be a BlockArgument.\n+            \/\/ Lowering should remove such cases and the var declaration should emerge\n+            \/\/ This method is primarily used when transforming to pure SSA\n+            return (VarOp) varValue.op();\n+        }\n+\n+        static void checkIsVarOp(Value varValue) {\n+            if (!(varValue.type() instanceof VarType)) {\n+                throw new IllegalArgumentException(\"Value's type is not a variable type: \" + varValue);\n+            }\n+        }\n+\n+        \/**\n+         * The variable load operation, that models a reading variable.\n+         *\/\n+        @OpFactory.OpDeclaration(VarLoadOp.NAME)\n+        public static final class VarLoadOp extends VarAccessOp\n+                implements JavaOp.JavaExpression {\n+            public static final String NAME = \"var.load\";\n+\n+            public VarLoadOp(ExternalizedOp opdef) {\n+                super(opdef);\n+\n+                if (opdef.operands().size() != 1) {\n+                    throw new IllegalArgumentException(\"Operation must have one operand\");\n+                }\n+                checkIsVarOp(opdef.operands().get(0));\n+            }\n+\n+            VarLoadOp(VarLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            VarLoadOp(List<Value> varValue) {\n+                super(NAME, varValue);\n+            }\n+\n+            @Override\n+            public VarLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new VarLoadOp(this, cc);\n+            }\n+\n+            \/\/ (Variable)VarType\n+            VarLoadOp(Value varValue) {\n+                super(NAME, List.of(varValue));\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return varType().valueType();\n+            }\n+        }\n+\n+        \/**\n+         * The variable store operation, that can model a variable assignment.\n+         *\/\n+        @OpFactory.OpDeclaration(VarStoreOp.NAME)\n+        public static final class VarStoreOp extends VarAccessOp\n+                implements JavaOp.JavaExpression, JavaOp.JavaStatement {\n+            public static final String NAME = \"var.store\";\n+\n+            public VarStoreOp(ExternalizedOp opdef) {\n+                super(opdef);\n+\n+                if (opdef.operands().size() != 2) {\n+                    throw new IllegalArgumentException(\"Operation must have two operands\");\n+                }\n+                checkIsVarOp(opdef.operands().get(0));\n+            }\n+\n+            VarStoreOp(VarStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            VarStoreOp(List<Value> values) {\n+                super(NAME,\n+                        values);\n+            }\n+\n+            @Override\n+            public VarStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new VarStoreOp(this, cc);\n+            }\n+\n+            \/\/ (Variable, VarType)void\n+            VarStoreOp(Value varValue, Value v) {\n+                super(NAME,\n+                        List.of(varValue, v));\n+            }\n+\n+            public Value storeOperand() {\n+                return operands().get(1);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return JavaType.VOID;\n+            }\n+        }\n+    }\n+\n+    \/\/ Tuple operations, for modelling return with multiple values\n+\n+    \/**\n+     * The tuple operation. A tuple contain a fixed set of values accessible by their component index.\n+     *\/\n+    @OpFactory.OpDeclaration(TupleOp.NAME)\n+    public static final class TupleOp extends CoreOp {\n+        public static final String NAME = \"tuple\";\n+\n+        public TupleOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        TupleOp(TupleOp that, CopyContext cc) {\n+            this(cc.getValues(that.operands()));\n+        }\n+\n+        @Override\n+        public TupleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleOp(this, cc);\n+        }\n+\n+        TupleOp(List<? extends Value> componentValues) {\n+            super(NAME, componentValues);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return TupleType.tupleTypeFromValues(operands());\n+        }\n+    }\n+\n+    \/**\n+     * The tuple component load operation, that access the component of a tuple at a given, constant, component index.\n+     *\/\n+    @OpFactory.OpDeclaration(TupleLoadOp.NAME)\n+    public static final class TupleLoadOp extends CoreOp {\n+        public static final String NAME = \"tuple.load\";\n+        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n+\n+        final int index;\n+\n+        public static TupleLoadOp create(ExternalizedOp def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n+                    v -> switch (v) {\n+                        case Integer i -> i;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n+                    });\n+            return new TupleLoadOp(def, index);\n+        }\n+\n+        TupleLoadOp(ExternalizedOp def, int index) {\n+            super(def);\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        TupleLoadOp(TupleLoadOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        TupleLoadOp(TupleLoadOp that, List<Value> values) {\n+            super(NAME, values);\n+\n+            this.index = that.index;\n+        }\n+\n+        @Override\n+        public TupleLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleLoadOp(this, cc);\n+        }\n+\n+        TupleLoadOp(Value tupleValue, int index) {\n+            super(NAME, List.of(tupleValue));\n+\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", index);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int index() {\n+            return index;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            Value tupleValue = operands().get(0);\n+            TupleType t = (TupleType) tupleValue.type();\n+            return t.componentTypes().get(index);\n+        }\n+    }\n+\n+    \/**\n+     * The tuple component set operation, that access the component of a tuple at a given, constant, component index.\n+     *\/\n+    @OpFactory.OpDeclaration(TupleWithOp.NAME)\n+    public static final class TupleWithOp extends CoreOp {\n+        public static final String NAME = \"tuple.with\";\n+        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n+\n+        final int index;\n+\n+        public static TupleWithOp create(ExternalizedOp def) {\n+            if (def.operands().size() != 2) {\n+                throw new IllegalStateException(\"Operation must have two operands\");\n+            }\n+\n+            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n+                    v -> switch (v) {\n+                        case Integer i -> i;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n+                    });\n+            return new TupleWithOp(def, index);\n+        }\n+\n+        TupleWithOp(ExternalizedOp def, int index) {\n+            super(def);\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        TupleWithOp(TupleWithOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        TupleWithOp(TupleWithOp that, List<Value> values) {\n+            super(NAME, values);\n+\n+            this.index = that.index;\n+        }\n+\n+        @Override\n+        public TupleWithOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleWithOp(this, cc);\n+        }\n+\n+        TupleWithOp(Value tupleValue, int index, Value value) {\n+            super(NAME, List.of(tupleValue, value));\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", index);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int index() {\n+            return index;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            Value tupleValue = operands().get(0);\n+            TupleType tupleType = (TupleType) tupleValue.type();\n+            Value value = operands().get(2);\n+\n+            List<TypeElement> tupleComponentTypes = new ArrayList<>(tupleType.componentTypes());\n+            tupleComponentTypes.set(index, value.type());\n+            return TupleType.tupleType(tupleComponentTypes);\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Arithmetic ops\n+\n+\n+    \/**\n+     * A factory for core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(CoreOp.class);\n+\n+    \/**\n+     * Creates a function operation builder\n+     *\n+     * @param funcName the function name\n+     * @param funcType the function type\n+     * @return the function operation builder\n+     *\/\n+    public static FuncOp.Builder func(String funcName, FunctionType funcType) {\n+        return new FuncOp.Builder(null, funcName, funcType);\n+    }\n+\n+    \/**\n+     * Creates a function operation\n+     *\n+     * @param funcName the function name\n+     * @param body     the function body\n+     * @return the function operation\n+     *\/\n+    public static FuncOp func(String funcName, Body.Builder body) {\n+        return new FuncOp(funcName, body);\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param funcName the name of the function operation\n+     * @param funcType the function type\n+     * @param args     the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, FunctionType funcType, Value... args) {\n+        return funcCall(funcName, funcType, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param funcName the name of the function operation\n+     * @param funcType the function type\n+     * @param args     the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, FunctionType funcType, List<Value> args) {\n+        return new FuncCallOp(funcName, funcType.returnType(), args);\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param func the target function\n+     * @param args the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(FuncOp func, Value... args) {\n+        return funcCall(func, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param func the target function\n+     * @param args the function argments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(FuncOp func, List<Value> args) {\n+        return new FuncCallOp(func.funcName(), func.invokableType().returnType(), args);\n+    }\n+\n+    \/**\n+     * Creates a module operation.\n+     *\n+     * @param functions the functions of the module operation\n+     * @return the module operation\n+     *\/\n+    public static ModuleOp module(FuncOp... functions) {\n+        return module(List.of(functions));\n+    }\n+\n+    \/**\n+     * Creates a module operation.\n+     *\n+     * @param functions the functions of the module operation\n+     * @return the module operation\n+     *\/\n+    public static ModuleOp module(List<FuncOp> functions) {\n+        return new ModuleOp(List.copyOf(functions));\n+    }\n+\n+    \/**\n+     * Creates a quoted operation.\n+     *\n+     * @param ancestorBody the ancestor of the body of the quoted operation\n+     * @param opFunc       a function that accepts the body of the quoted operation and returns the operation to be quoted\n+     * @return the quoted operation\n+     *\/\n+    public static QuotedOp quoted(Body.Builder ancestorBody,\n+                                  Function<Block.Builder, Op> opFunc) {\n+        Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        Block.Builder block = body.entryBlock();\n+        block.op(_yield(\n+                block.op(opFunc.apply(block))));\n+        return new QuotedOp(body);\n+    }\n+\n+    \/**\n+     * Creates a quoted operation.\n+     *\n+     * @param body quoted operation body\n+     * @return the quoted operation\n+     *\/\n+    public static QuotedOp quoted(Body.Builder body) {\n+        return new QuotedOp(body);\n+    }\n+\n+    \/**\n+     * Creates a closure operation.\n+     *\n+     * @param ancestorBody the ancestor of the body of the closure operation\n+     * @param funcType     the closure operation's function type\n+     * @return the closure operation\n+     *\/\n+    public static ClosureOp.Builder closure(Body.Builder ancestorBody,\n+                                            FunctionType funcType) {\n+        return new ClosureOp.Builder(ancestorBody, funcType);\n+    }\n+\n+    \/**\n+     * Creates a closure operation.\n+     *\n+     * @param body the body of the closure operation\n+     * @return the closure operation\n+     *\/\n+    public static ClosureOp closure(Body.Builder body) {\n+        return new ClosureOp(body);\n+    }\n+\n+    \/**\n+     * Creates a closure call operation.\n+     *\n+     * @param args the closure arguments. The first argument is the closure operation to be called\n+     * @return the closure call operation\n+     *\/\n+    \/\/ @@@: Is this the right signature?\n+    public static ClosureCallOp closureCall(Value... args) {\n+        return closureCall(List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a closure call operation.\n+     *\n+     * @param args the closure arguments. The first argument is the closure operation to be called\n+     * @return the closure call operation\n+     *\/\n+    \/\/ @@@: Is this the right signature?\n+    public static ClosureCallOp closureCall(List<Value> args) {\n+        return new ClosureCallOp(args);\n+    }\n+\n+    \/**\n+     * Creates a return operation.\n+     *\n+     * @return the return operation\n+     *\/\n+    public static ReturnOp _return() {\n+        return new ReturnOp();\n+    }\n+\n+    \/**\n+     * Creates a return operation.\n+     *\n+     * @param returnValue the return value\n+     * @return the return operation\n+     *\/\n+    public static ReturnOp _return(Value returnValue) {\n+        return new ReturnOp(returnValue);\n+    }\n+\n+    \/**\n+     * Creates an unreachable operation.\n+     *\n+     * @return the unreachable operation\n+     *\/\n+    public static UnreachableOp unreachable() {\n+        return new UnreachableOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     *\n+     * @return the yield operation\n+     *\/\n+    public static YieldOp _yield() {\n+        return new YieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     *\n+     * @param yieldValue the yielded value\n+     * @return the yield operation\n+     *\/\n+    public static YieldOp _yield(Value yieldValue) {\n+        return new YieldOp(List.of(yieldValue));\n+    }\n+\n+    \/**\n+     * Creates an unconditional break operation.\n+     *\n+     * @param target the jump target\n+     * @return the unconditional break operation\n+     *\/\n+    public static BranchOp branch(Block.Reference target) {\n+        return new BranchOp(target);\n+    }\n+\n+    \/**\n+     * Creates a conditional break operation.\n+     *\n+     * @param condValue   the test value of the conditional break operation\n+     * @param trueTarget  the jump target when the test value evaluates to true\n+     * @param falseTarget the jump target when the test value evaluates to false\n+     * @return the conditional break operation\n+     *\/\n+    public static ConditionalBranchOp conditionalBranch(Value condValue,\n+                                                        Block.Reference trueTarget, Block.Reference falseTarget) {\n+        return new ConditionalBranchOp(condValue, trueTarget, falseTarget);\n+    }\n+\n+    \/**\n+     * Creates a constant operation.\n+     *\n+     * @param type  the constant type\n+     * @param value the constant value\n+     * @return the constant operation\n+     *\/\n+    public static ConstantOp constant(TypeElement type, Object value) {\n+        return new ConstantOp(type, value);\n+    }\n+\n+    \/\/ @@@ Add field load\/store overload with explicit fieldType\n+\n+    \/**\n+     * Creates a var operation modeling an unnamed and uninitialized variable,\n+     * either an unnamed local variable or an unnamed parameter.\n+     *\n+     * @param type the type of the var's value\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(TypeElement type) {\n+        return var(null, type);\n+    }\n+\n+    \/**\n+     * Creates a var operation modeling an uninitialized variable, either a local variable or a parameter.\n+     *\n+     * @param name the name of the var\n+     * @param type the type of the var's value\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type) {\n+        return new VarOp(name, type);\n+    }\n+\n+    \/**\n+     * Creates a var operation modeling an unnamed variable, either an unnamed local variable or an unnamed parameter.\n+     *\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(Value init) {\n+        return var(null, init);\n+    }\n+\n+    \/**\n+     * Creates a var operation modeling a variable, either a local variable or a parameter.\n+     * <p>\n+     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n+     *\n+     * @param name the name of the var\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, Value init) {\n+        return new VarOp(name, init);\n+    }\n+\n+    \/**\n+     * Creates a var operation modeling a variable, either a local variable or a parameter.\n+     * <p>\n+     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n+     *\n+     * @param name the name of the var\n+     * @param type the type of the var's value\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type, Value init) {\n+        return new VarOp(name, type, init);\n+    }\n+\n+    \/**\n+     * Creates a var load operation.\n+     *\n+     * @param varValue the var value\n+     * @return the var load operation\n+     *\/\n+    public static VarAccessOp.VarLoadOp varLoad(Value varValue) {\n+        return new VarAccessOp.VarLoadOp(varValue);\n+    }\n+\n+    \/**\n+     * Creates a var store operation.\n+     *\n+     * @param varValue the var value\n+     * @param v        the value to store in the var\n+     * @return the var store operation\n+     *\/\n+    public static VarAccessOp.VarStoreOp varStore(Value varValue, Value v) {\n+        return new VarAccessOp.VarStoreOp(varValue, v);\n+    }\n+\n+    \/**\n+     * Creates a tuple operation.\n+     *\n+     * @param componentValues the values of tuple (in order)\n+     * @return the tuple operation\n+     *\/\n+    public static TupleOp tuple(Value... componentValues) {\n+        return tuple(List.of(componentValues));\n+    }\n+\n+    \/**\n+     * Creates a tuple operation.\n+     *\n+     * @param componentValues the values of tuple (in order)\n+     * @return the tuple operation\n+     *\/\n+    public static TupleOp tuple(List<? extends Value> componentValues) {\n+        return new TupleOp(componentValues);\n+    }\n+\n+    \/**\n+     * Creates a tuple load operation.\n+     *\n+     * @param tuple the tuple value\n+     * @param index the component index value\n+     * @return the tuple load operation\n+     *\/\n+    public static TupleLoadOp tupleLoad(Value tuple, int index) {\n+        return new TupleLoadOp(tuple, index);\n+    }\n+\n+    \/**\n+     * Creates a tuple with operation.\n+     *\n+     * @param tuple the tuple value\n+     * @param index the component index value\n+     * @param value the component value\n+     * @return the tuple with operation\n+     *\/\n+    public static TupleWithOp tupleWith(Value tuple, int index, Value value) {\n+        return new TupleWithOp(tuple, index, value);\n+    }\n+\n+    \/\/\n+    \/\/ Arithmetic ops\n+\n+\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":1726,"deletions":0,"binary":false,"changes":1726,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.core;\n@@ -3,1 +3,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -5,4 +4,3 @@\n-import jdk.incubator.code.TypeElement.ExternalizedTypeElement;\n-import jdk.incubator.code.parser.impl.DescParser;\n-import jdk.incubator.code.type.WildcardType.BoundKind;\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -12,1 +10,0 @@\n-import java.util.function.Predicate;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreTypeFactory.java","additions":4,"deletions":7,"binary":false,"changes":11,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/CoreTypeFactory.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.core;\n@@ -4,0 +4,2 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/FunctionType.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/FunctionType.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.core;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/TupleType.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TupleType.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.core;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/VarType.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/VarType.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n- * Functionality for operations declared in code models that can represent Java programs.\n+ * The core dialect.\n@@ -29,1 +29,1 @@\n-package jdk.incubator.code.op;\n\\ No newline at end of file\n+package jdk.incubator.code.dialect.core;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/package-info.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -33,1 +33,1 @@\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ArrayType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ArrayType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ClassType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ClassType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -29,1 +29,2 @@\n-import jdk.incubator.code.type.impl.ConstructorRefImpl;\n+import jdk.incubator.code.dialect.java.impl.ConstructorRefImpl;\n+import jdk.incubator.code.dialect.core.FunctionType;\n@@ -37,1 +38,1 @@\n-import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ConstructorRef.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ConstructorRef.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.impl.FieldRefImpl;\n+import jdk.incubator.code.dialect.java.impl.FieldRefImpl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/FieldRef.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/FieldRef.java","status":"renamed"},{"patch":"@@ -0,0 +1,6427 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.code.dialect.java;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n+import jdk.incubator.code.dialect.core.VarType;\n+\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n+\n+\/**\n+ * The top-level operation class for the enclosed set of extended operations.\n+ * <p>\n+ * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n+ * operations. Such a model represents the same Java program and preserves the program meaning as defined by the\n+ * Java Language Specification\n+ * <p>\n+ * Extended operations model specific Java language constructs, often those with structured control flow and nested\n+ * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n+ * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n+ * that are not explicitly lowerable.\n+ * <p>\n+ * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n+ * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n+ * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n+ *\/\n+public sealed abstract class JavaOp extends ExternalizableOp {\n+\n+    static final String PACKAGE_NAME = JavaOp.class.getPackageName();\n+\n+    static final String JavaOp_CLASS_NAME = PACKAGE_NAME + \".\" + JavaOp.class.getSimpleName();\n+\n+    protected JavaOp(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+\n+    protected JavaOp(String name, List<? extends Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    protected JavaOp(ExternalizableOp.ExternalizedOp def) {\n+        super(def);\n+    }\n+\n+    \/**\n+     * An operation that models a Java expression\n+     *\/\n+    public sealed interface JavaExpression permits\n+            ArithmeticOperation,\n+            ArrayAccessOp.ArrayLoadOp,\n+            ArrayAccessOp.ArrayStoreOp,\n+            ArrayLengthOp,\n+            CastOp,\n+            ConvOp,\n+            ClosureOp,\n+            ConcatOp,\n+            ConstantOp,\n+            FieldAccessOp.FieldLoadOp,\n+            FieldAccessOp.FieldStoreOp,\n+            InstanceOfOp,\n+            InvokeOp,\n+            LambdaOp,\n+            NewOp,\n+            TestOperation,\n+            VarAccessOp.VarLoadOp,\n+            VarAccessOp.VarStoreOp,\n+            JavaConditionalExpressionOp,\n+            JavaConditionalOp,\n+            JavaSwitchExpressionOp {\n+    }\n+\n+    \/**\n+     * An operation that models a Java statement\n+     *\/\n+    public sealed interface JavaStatement permits\n+            ArrayAccessOp.ArrayStoreOp,\n+            AssertOp,\n+            FieldAccessOp.FieldStoreOp,\n+            InvokeOp,\n+            NewOp,\n+            ReturnOp,\n+            ThrowOp,\n+            VarAccessOp.VarStoreOp,\n+            VarOp,\n+            JavaBlockOp,\n+            JavaDoWhileOp,\n+            JavaEnhancedForOp,\n+            JavaForOp,\n+            JavaIfOp,\n+            JavaLabelOp,\n+            JavaLabeledOp,\n+            JavaSynchronizedOp,\n+            JavaTryOp,\n+            JavaWhileOp,\n+            JavaYieldOp,\n+            JavaSwitchStatementOp {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation's behavior may be emulated using Java reflection.\n+     * A descriptor is derived from or declared by the operation that can be resolved at runtime to\n+     * an instance of a reflective handle or member. That handle or member can be operated on to\n+     * emulate the operation's behavior, specifically as bytecode behavior.\n+     *\/\n+    public sealed interface ReflectiveOp {\n+    }\n+\n+    \/**\n+     * An operation that performs access.\n+     *\/\n+    public sealed interface AccessOp permits\n+        CoreOp.VarAccessOp,\n+        FieldAccessOp,\n+        ArrayAccessOp {\n+    }\n+\n+\n+\n+    \/**\n+     * The lambda operation, that can model a Java lambda expression.\n+     *\/\n+    @OpFactory.OpDeclaration(LambdaOp.NAME)\n+    public static final class LambdaOp extends JavaOp\n+            implements Invokable, Lowerable, JavaExpression {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final FunctionType funcType;\n+            final TypeElement functionalInterface;\n+\n+            Builder(Body.Builder ancestorBody, FunctionType funcType, TypeElement functionalInterface) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcType = funcType;\n+                this.functionalInterface = functionalInterface;\n+            }\n+\n+            public LambdaOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new LambdaOp(functionalInterface, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"lambda\";\n+\n+        final TypeElement functionalInterface;\n+        final Body body;\n+\n+        public LambdaOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.functionalInterface = def.resultType();\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        LambdaOp(LambdaOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.functionalInterface = that.functionalInterface;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public LambdaOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LambdaOp(this, cc, ot);\n+        }\n+\n+        LambdaOp(TypeElement functionalInterface, Body.Builder bodyC) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.functionalInterface = functionalInterface;\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public TypeElement functionalInterface() {\n+            return functionalInterface;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public List<Value> capturedValues() {\n+            return body.capturedValues();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return functionalInterface();\n+        }\n+\n+        \/**\n+         * Determines if this lambda operation could have originated from a\n+         * method reference declared in Java source code.\n+         * <p>\n+         * Such a lambda operation is one with the following constraints:\n+         * <ol>\n+         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n+         *     <li>A body with only one (entry) block that contains only variable declaration\n+         *     operations, variable load operations, invoke operations to box or unbox\n+         *     primitive values, a single invoke operation to the method that is\n+         *     referenced, and a return operation.\n+         *     <li>if the return operation returns a non-void result then that result is,\n+         *     or uniquely depends on, the result of the referencing invoke operation.\n+         *     <li>If the lambda operation captures one value then the first operand corresponds\n+         *     to captured the value, and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         *     Otherwise, the first and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         * <\/ol>\n+         * A value, V2, uniquely depends on another value, V1, if the graph of what V2 depends on\n+         * contains only nodes with single edges terminating in V1, and the graph of what depends on V1\n+         * is bidirectionally equal to the graph of what V2 depends on.\n+         *\n+         * @return the invocation operation to the method referenced by the lambda\n+         * operation, otherwise empty.\n+         *\/\n+        public Optional<InvokeOp> methodReference() {\n+            \/\/ Single block\n+            if (body().blocks().size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Zero or one (this) capture\n+            List<Value> cvs = capturedValues();\n+            if (cvs.size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            Map<Value, Value> valueMapping = new HashMap<>();\n+            InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, body().entryBlock().ops());\n+            if (methodRefInvokeOp == null) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Lambda's parameters map in encounter order with the invocation's operands\n+            List<Value> lambdaParameters = new ArrayList<>();\n+            if (cvs.size() == 1) {\n+                lambdaParameters.add(cvs.getFirst());\n+            }\n+            lambdaParameters.addAll(parameters());\n+            List<Value> methodRefOperands = methodRefInvokeOp.operands().stream().map(valueMapping::get).toList();\n+            if (!lambdaParameters.equals(methodRefOperands)) {\n+                return Optional.empty();\n+            }\n+\n+            return Optional.of(methodRefInvokeOp);\n+        }\n+\n+        static InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n+            InvokeOp methodRefInvokeOp = null;\n+            for (Op op : ops) {\n+                switch (op) {\n+                    case VarOp varOp -> {\n+                        if (isValueUsedWithOp(varOp.result(), o -> o instanceof VarAccessOp.VarStoreOp)) {\n+                            return null;\n+                        }\n+                    }\n+                    case VarAccessOp.VarLoadOp varLoadOp -> {\n+                        Value v = varLoadOp.varOp().operands().getFirst();\n+                        valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n+                        Value v = iop.operands().getFirst();\n+                        valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case InvokeOp iop -> {\n+                        if (methodRefInvokeOp != null) {\n+                            return null;\n+                        }\n+\n+                        for (Value o : iop.operands()) {\n+                            valueMapping.put(o, valueMapping.getOrDefault(o, o));\n+                        }\n+                        methodRefInvokeOp = iop;\n+                    }\n+                    case ReturnOp rop -> {\n+                        if (methodRefInvokeOp == null) {\n+                            return null;\n+                        }\n+                        Value r = rop.returnValue();\n+                        if (!(valueMapping.getOrDefault(r, r) instanceof Result invokeResult)) {\n+                            return null;\n+                        }\n+                        if (invokeResult.op() != methodRefInvokeOp) {\n+                            return null;\n+                        }\n+                        assert methodRefInvokeOp.result().uses().size() == 1;\n+                    }\n+                    default -> {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            return methodRefInvokeOp;\n+        }\n+\n+        private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+            for (Result user : value.uses()) {\n+                if (opPredicate.test(user.op())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ @@@ Move to functionality on JavaType(s)\n+        static final Set<String> UNBOX_NAMES = Set.of(\n+                \"byteValue\",\n+                \"shortValue\",\n+                \"charValue\",\n+                \"intValue\",\n+                \"longValue\",\n+                \"floatValue\",\n+                \"doubleValue\",\n+                \"booleanValue\");\n+\n+        private static boolean isBoxOrUnboxInvocation(InvokeOp iop) {\n+            MethodRef mr = iop.invokeDescriptor();\n+            return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n+                    (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n+        }\n+    }\n+\n+    \/**\n+     * The terminating throw operation, that can model the Java language throw statement.\n+     *\/\n+    @OpFactory.OpDeclaration(ThrowOp.NAME)\n+    public static final class ThrowOp extends JavaOp\n+            implements BodyTerminating, JavaStatement {\n+        public static final String NAME = \"throw\";\n+\n+        public ThrowOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+        }\n+\n+        ThrowOp(ThrowOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ThrowOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ThrowOp(this, cc);\n+        }\n+\n+        ThrowOp(Value e) {\n+            super(NAME, List.of(e));\n+        }\n+\n+        public Value argument() {\n+            return operands().get(0);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The assertion operation. Supporting assertions in statement form.\n+     *\/\n+    @OpFactory.OpDeclaration(AssertOp.NAME)\n+    public static final class AssertOp extends JavaOp\n+            implements Nested, JavaStatement {\n+        public static final String NAME = \"assert\";\n+        public final List<Body> bodies;\n+\n+        public AssertOp(ExternalizedOp def) {\n+            super(def);\n+            var bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n+            checkBodies(bodies);\n+            this.bodies = bodies;\n+        }\n+\n+        public AssertOp(List<Body.Builder> bodies) {\n+            super(NAME, List.of());\n+            checkBodies(bodies);\n+            this.bodies = bodies.stream().map(b -> b.build(this)).toList();\n+        }\n+\n+        AssertOp(AssertOp that, CopyContext cc, OpTransformer ot) {\n+\n+            super(that, cc);\n+            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        private void checkBodies(List<?> bodies) {\n+            if (bodies.size() != 1 && bodies.size() != 2) {\n+                throw new IllegalArgumentException(\"Assert must have one or two bodies.\");\n+            }\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AssertOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return this.bodies;\n+        }\n+    }\n+\n+    \/**\n+     * A monitor operation.\n+     *\/\n+    public sealed abstract static class MonitorOp extends JavaOp {\n+        public MonitorOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+        }\n+\n+        MonitorOp(MonitorOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        MonitorOp(String name, Value monitor) {\n+            super(name, List.of(monitor));\n+        }\n+\n+        public Value monitorValue() {\n+            return operands().getFirst();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+\n+        \/**\n+         * The monitor enter operation.\n+         *\/\n+        @OpFactory.OpDeclaration(MonitorEnterOp.NAME)\n+        public static final class MonitorEnterOp extends MonitorOp {\n+            public static final String NAME = \"monitor.enter\";\n+\n+            public MonitorEnterOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            MonitorEnterOp(MonitorEnterOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public MonitorEnterOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MonitorEnterOp(this, cc);\n+            }\n+\n+            MonitorEnterOp(Value monitor) {\n+                super(NAME, monitor);\n+            }\n+        }\n+\n+        \/**\n+         * The monitor exit operation.\n+         *\/\n+        @OpFactory.OpDeclaration(MonitorExitOp.NAME)\n+        public static final class MonitorExitOp extends MonitorOp {\n+            public static final String NAME = \"monitor.exit\";\n+\n+            public MonitorExitOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            MonitorExitOp(MonitorExitOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public MonitorExitOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MonitorExitOp(this, cc);\n+            }\n+\n+            MonitorExitOp(Value monitor) {\n+                super(NAME, monitor);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The invoke operation, that can model Java language method invocation expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(InvokeOp.NAME)\n+    public static final class InvokeOp extends JavaOp\n+            implements ReflectiveOp, JavaExpression, JavaStatement {\n+\n+        \/**\n+         * The kind of invocation.\n+         *\/\n+        public enum InvokeKind {\n+            \/**\n+             * An invocation on a class (static) method.\n+             *\/\n+            STATIC,\n+            \/**\n+             * An invocation on an instance method.\n+             *\/\n+            INSTANCE,\n+            \/**\n+             * A super invocation on an instance method.\n+             *\/\n+            SUPER\n+        }\n+\n+        public static final String NAME = \"invoke\";\n+        public static final String ATTRIBUTE_INVOKE_DESCRIPTOR = NAME + \".descriptor\";\n+        public static final String ATTRIBUTE_INVOKE_KIND = NAME + \".kind\";\n+        public static final String ATTRIBUTE_INVOKE_VARARGS = NAME + \".varargs\";\n+\n+        final InvokeKind invokeKind;\n+        final boolean isVarArgs;\n+        final MethodRef invokeDescriptor;\n+        final TypeElement resultType;\n+\n+        public static InvokeOp create(ExternalizedOp def) {\n+            \/\/ Required attribute\n+            MethodRef invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n+                    true, v -> switch (v) {\n+                        case MethodRef md -> md;\n+                        case null, default ->\n+                                throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n+                    });\n+\n+            \/\/ If not present defaults to false\n+            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_INVOKE_VARARGS,\n+                    false, v -> switch (v) {\n+                        case Boolean b -> b;\n+                        case null, default -> false;\n+                    });\n+\n+            \/\/ If not present and is not varargs defaults to class or instance invocation\n+            \/\/ based on number of operands and parameters\n+            InvokeKind ik = def.extractAttributeValue(ATTRIBUTE_INVOKE_KIND,\n+                    false, v -> switch (v) {\n+                        case String s -> InvokeKind.valueOf(s);\n+                        case InvokeKind k -> k;\n+                        case null, default -> {\n+                            if (isVarArgs) {\n+                                \/\/ If varargs then we cannot infer invoke kind\n+                                throw new UnsupportedOperationException(\"Unsupported invoke kind value:\" + v);\n+                            }\n+                            int paramCount = invokeDescriptor.type().parameterTypes().size();\n+                            int argCount = def.operands().size();\n+                            yield (argCount == paramCount + 1)\n+                                    ? InvokeKind.INSTANCE\n+                                    : InvokeKind.STATIC;\n+                        }\n+                    });\n+\n+\n+            return new InvokeOp(def, ik, isVarArgs, invokeDescriptor);\n+        }\n+\n+        InvokeOp(ExternalizedOp def, InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor) {\n+            super(def);\n+\n+            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, def.operands());\n+\n+            this.invokeKind = invokeKind;\n+            this.isVarArgs = isVarArgs;\n+            this.invokeDescriptor = invokeDescriptor;\n+            this.resultType = def.resultType();\n+        }\n+\n+        InvokeOp(InvokeOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.invokeKind = that.invokeKind;\n+            this.isVarArgs = that.isVarArgs;\n+            this.invokeDescriptor = that.invokeDescriptor;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public InvokeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InvokeOp(this, cc);\n+        }\n+\n+        InvokeOp(InvokeKind invokeKind, boolean isVarArgs, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+            super(NAME, args);\n+\n+            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, args);\n+\n+            this.invokeKind = invokeKind;\n+            this.isVarArgs = isVarArgs;\n+            this.invokeDescriptor = invokeDescriptor;\n+            this.resultType = resultType;\n+        }\n+\n+        static void validateArgCount(InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor, List<Value> operands) {\n+            int paramCount = invokeDescriptor.type().parameterTypes().size();\n+            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n+            if ((!isVarArgs && argCount != paramCount)\n+                    || argCount < paramCount - 1) {\n+                throw new IllegalArgumentException(invokeKind + \" \" + isVarArgs + \" \" + invokeDescriptor);\n+            }\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", invokeDescriptor);\n+            if (isVarArgs) {\n+                \/\/ If varargs then we need to declare the invoke.kind attribute\n+                \/\/ Given a method `A::m(A... more)` and an invocation with one\n+                \/\/ operand, we don't know if that operand corresponds to the\n+                \/\/ receiver or a method argument\n+                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n+                m.put(ATTRIBUTE_INVOKE_VARARGS, isVarArgs);\n+            } else if (invokeKind == InvokeKind.SUPER) {\n+                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n+            }\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public InvokeKind invokeKind() {\n+            return invokeKind;\n+        }\n+\n+        public boolean isVarArgs() {\n+            return isVarArgs;\n+        }\n+\n+        public MethodRef invokeDescriptor() {\n+            return invokeDescriptor;\n+        }\n+\n+        \/\/ @@@ remove?\n+        public boolean hasReceiver() {\n+            return invokeKind != InvokeKind.STATIC;\n+        }\n+\n+        public List<Value> varArgOperands() {\n+            if (!isVarArgs) {\n+                return null;\n+            }\n+\n+            int operandCount = operands().size();\n+            int argCount = operandCount - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n+            int paramCount = invokeDescriptor.type().parameterTypes().size();\n+            int varArgCount = argCount - (paramCount - 1);\n+            return operands().subList(operandCount - varArgCount, operandCount);\n+        }\n+\n+        public List<Value> argOperands() {\n+            if (!isVarArgs) {\n+                return operands();\n+            }\n+            int paramCount = invokeDescriptor().type().parameterTypes().size();\n+            int argOperandsCount = paramCount - (invokeKind() == InvokeKind.STATIC ? 1 : 0);\n+            return operands().subList(0, argOperandsCount);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The conversion operation, that can model Java language cast expressions\n+     * for numerical conversion, or such implicit conversion.\n+     *\/\n+    @OpFactory.OpDeclaration(ConvOp.NAME)\n+    public static final class ConvOp extends JavaOp\n+            implements Pure, JavaExpression {\n+        public static final String NAME = \"conv\";\n+\n+        final TypeElement resultType;\n+\n+        public ConvOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+        }\n+\n+        ConvOp(ConvOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvOp(this, cc);\n+        }\n+\n+        ConvOp(TypeElement resultType, Value arg) {\n+            super(NAME, List.of(arg));\n+\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The new operation, that can models Java language instance creation expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(NewOp.NAME)\n+    public static final class NewOp extends JavaOp\n+            implements ReflectiveOp, JavaExpression, JavaStatement {\n+\n+        public static final String NAME = \"new\";\n+        public static final String ATTRIBUTE_NEW_DESCRIPTOR = NAME + \".descriptor\";\n+        public static final String ATTRIBUTE_NEW_VARARGS = NAME + \".varargs\";\n+\n+        final boolean isVarArgs;\n+        final ConstructorRef constructorDescriptor;\n+        final TypeElement resultType;\n+\n+        public static NewOp create(ExternalizedOp def) {\n+            \/\/ Required attribute\n+            ConstructorRef constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,\n+                    true, v -> switch (v) {\n+                        case ConstructorRef cd -> cd;\n+                        case null, default ->\n+                                throw new UnsupportedOperationException(\"Unsupported constructor descriptor value:\" + v);\n+                    });\n+\n+            \/\/ If not present defaults to false\n+            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_NEW_VARARGS,\n+                    false, v -> switch (v) {\n+                        case Boolean b -> b;\n+                        case null, default -> false;\n+                    });\n+\n+            return new NewOp(def, isVarArgs, constructorDescriptor);\n+        }\n+\n+        NewOp(ExternalizedOp def, boolean isVarArgs, ConstructorRef constructorDescriptor) {\n+            super(def);\n+\n+            validateArgCount(isVarArgs, constructorDescriptor, def.operands());\n+\n+            this.isVarArgs = isVarArgs;\n+            this.constructorDescriptor = constructorDescriptor;\n+            this.resultType = def.resultType();\n+        }\n+\n+        NewOp(NewOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.isVarArgs = that.isVarArgs;\n+            this.constructorDescriptor = that.constructorDescriptor;\n+            this.resultType = that.resultType;\n+        }\n+\n+        static void validateArgCount(boolean isVarArgs, ConstructorRef constructorDescriptor, List<Value> operands) {\n+            int paramCount = constructorDescriptor.type().parameterTypes().size();\n+            int argCount = operands.size();\n+            if ((!isVarArgs && argCount != paramCount)\n+                    || argCount < paramCount - 1) {\n+                throw new IllegalArgumentException(isVarArgs + \" \" + constructorDescriptor);\n+            }\n+        }\n+\n+        @Override\n+        public NewOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NewOp(this, cc);\n+        }\n+\n+        NewOp(boolean isVarargs, TypeElement resultType, ConstructorRef constructorDescriptor, List<Value> args) {\n+            super(NAME, args);\n+\n+            this.isVarArgs = isVarargs;\n+            this.constructorDescriptor = constructorDescriptor;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", constructorDescriptor);\n+            if (isVarArgs) {\n+                m.put(ATTRIBUTE_NEW_VARARGS, isVarArgs);\n+            }\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public boolean isVarargs() {\n+            return isVarArgs;\n+        }\n+\n+        public TypeElement type() {\n+            return opType().returnType();\n+        } \/\/ @@@ duplication, same as resultType()\n+\n+        public ConstructorRef constructorDescriptor() {\n+            return constructorDescriptor;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * A field access operation, that can model Java langauge field access expressions.\n+     *\/\n+    public sealed abstract static class FieldAccessOp extends JavaOp\n+            implements AccessOp, ReflectiveOp {\n+        public static final String ATTRIBUTE_FIELD_DESCRIPTOR = \"field.descriptor\";\n+\n+        final FieldRef fieldDescriptor;\n+\n+        FieldAccessOp(ExternalizedOp def, FieldRef fieldDescriptor) {\n+            super(def);\n+\n+            this.fieldDescriptor = fieldDescriptor;\n+        }\n+\n+        FieldAccessOp(FieldAccessOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.fieldDescriptor = that.fieldDescriptor;\n+        }\n+\n+        FieldAccessOp(String name, List<Value> operands,\n+                      FieldRef fieldDescriptor) {\n+            super(name, operands);\n+\n+            this.fieldDescriptor = fieldDescriptor;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", fieldDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public final FieldRef fieldDescriptor() {\n+            return fieldDescriptor;\n+        }\n+\n+        \/**\n+         * The field load operation, that can model Java language field access expressions combined with load access to\n+         * field instance variables.\n+         *\/\n+        @OpFactory.OpDeclaration(FieldLoadOp.NAME)\n+        public static final class FieldLoadOp extends FieldAccessOp\n+                implements Pure, JavaExpression {\n+            public static final String NAME = \"field.load\";\n+\n+            final TypeElement resultType;\n+\n+            public static FieldLoadOp create(ExternalizedOp def) {\n+                if (def.operands().size() > 1) {\n+                    throw new IllegalArgumentException(\"Operation must accept zero or one operand\");\n+                }\n+\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n+                            case FieldRef fd -> fd;\n+                            case null, default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                        });\n+                return new FieldLoadOp(def, fieldDescriptor);\n+            }\n+\n+            FieldLoadOp(ExternalizedOp opdef, FieldRef fieldDescriptor) {\n+                super(opdef, fieldDescriptor);\n+\n+                resultType = opdef.resultType();\n+            }\n+\n+            FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                resultType = that.resultType();\n+            }\n+\n+            @Override\n+            public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new FieldLoadOp(this, cc);\n+            }\n+\n+            \/\/ instance\n+            FieldLoadOp(TypeElement resultType, FieldRef descriptor, Value receiver) {\n+                super(NAME, List.of(receiver), descriptor);\n+\n+                this.resultType = resultType;\n+            }\n+\n+            \/\/ static\n+            FieldLoadOp(TypeElement resultType, FieldRef descriptor) {\n+                super(NAME, List.of(), descriptor);\n+\n+                this.resultType = resultType;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return resultType;\n+            }\n+        }\n+\n+        \/**\n+         * The field store operation, that can model Java language field access expressions combined with store access\n+         * to field instance variables.\n+         *\/\n+        @OpFactory.OpDeclaration(FieldStoreOp.NAME)\n+        public static final class FieldStoreOp extends FieldAccessOp\n+                implements JavaExpression, JavaStatement {\n+            public static final String NAME = \"field.store\";\n+\n+            public static FieldStoreOp create(ExternalizedOp def) {\n+                if (def.operands().size() > 2) {\n+                    throw new IllegalArgumentException(\"Operation must accept one or two operands\");\n+                }\n+\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n+                            case FieldRef fd -> fd;\n+                            case null, default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                        });\n+                return new FieldStoreOp(def, fieldDescriptor);\n+            }\n+\n+            FieldStoreOp(ExternalizedOp opdef, FieldRef fieldDescriptor) {\n+                super(opdef, fieldDescriptor);\n+            }\n+\n+            FieldStoreOp(FieldStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public FieldStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new FieldStoreOp(this, cc);\n+            }\n+\n+            \/\/ instance\n+            FieldStoreOp(FieldRef descriptor, Value receiver, Value v) {\n+                super(NAME,\n+                        List.of(receiver, v), descriptor);\n+            }\n+\n+            \/\/ static\n+            FieldStoreOp(FieldRef descriptor, Value v) {\n+                super(NAME,\n+                        List.of(v), descriptor);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return VOID;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The array length operation, that can model Java language field access expressions to the length field of an\n+     * array.\n+     *\/\n+    @OpFactory.OpDeclaration(ArrayLengthOp.NAME)\n+    public static final class ArrayLengthOp extends JavaOp\n+            implements ReflectiveOp, JavaExpression {\n+        public static final String NAME = \"array.length\";\n+\n+        public ArrayLengthOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthOp(this, cc);\n+        }\n+\n+        ArrayLengthOp(Value array) {\n+            super(NAME, List.of(array));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return INT;\n+        }\n+    }\n+\n+    \/**\n+     * The array access operation, that can model Java language array access expressions.\n+     *\/\n+    public sealed abstract static class ArrayAccessOp extends JavaOp\n+            implements AccessOp, ReflectiveOp {\n+        ArrayAccessOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2 && def.operands().size() != 3) {\n+                throw new IllegalArgumentException(\"Operation must have 2 or 3 operands\");\n+            }\n+\n+            \/\/ @@@ validate first operand is an array\n+        }\n+\n+        ArrayAccessOp(ArrayAccessOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        ArrayAccessOp(ArrayAccessOp that, List<Value> operands) {\n+            super(that.opName(), operands);\n+        }\n+\n+        ArrayAccessOp(String name,\n+                      Value array, Value index, Value v) {\n+            super(name, operands(array, index, v));\n+        }\n+\n+        static List<Value> operands(Value array, Value index, Value v) {\n+            return v == null\n+                    ? List.of(array, index)\n+                    : List.of(array, index, v);\n+        }\n+\n+        \/**\n+         * The array load operation, that can model Java language array expressions combined with load access to the\n+         * components of an array.\n+         *\/\n+        @OpFactory.OpDeclaration(ArrayLoadOp.NAME)\n+        public static final class ArrayLoadOp extends ArrayAccessOp\n+                implements Pure, JavaExpression {\n+            public static final String NAME = \"array.load\";\n+            final TypeElement componentType;\n+\n+            public ArrayLoadOp(ExternalizedOp def) {\n+                super(def);\n+                this.componentType = def.resultType();\n+            }\n+\n+            ArrayLoadOp(ArrayLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+                this.componentType = that.componentType;\n+            }\n+\n+            @Override\n+            public ArrayLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new ArrayLoadOp(this, cc);\n+            }\n+\n+            ArrayLoadOp(Value array, Value index) {\n+                \/\/ @@@ revisit this when the component type is not explicitly given (see VarOp.resultType as an example)\n+                this(array, index, ((ArrayType)array.type()).componentType());\n+            }\n+\n+            ArrayLoadOp(Value array, Value index, TypeElement componentType) {\n+                super(NAME, array, index, null);\n+                this.componentType = componentType;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return componentType;\n+            }\n+        }\n+\n+        \/**\n+         * The array store operation, that can model Java language array expressions combined with store access to the\n+         * components of an array.\n+         *\/\n+        @OpFactory.OpDeclaration(ArrayStoreOp.NAME)\n+        public static final class ArrayStoreOp extends ArrayAccessOp\n+                implements JavaExpression, JavaStatement {\n+            public static final String NAME = \"array.store\";\n+\n+            public ArrayStoreOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            ArrayStoreOp(ArrayStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public ArrayStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new ArrayStoreOp(this, cc);\n+            }\n+\n+            ArrayStoreOp(Value array, Value index, Value v) {\n+                super(NAME, array, index, v);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return VOID;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The instanceof operation, that can model Java language instanceof expressions when the instanceof keyword is a\n+     * type comparison operator.\n+     *\/\n+    @OpFactory.OpDeclaration(InstanceOfOp.NAME)\n+    public static final class InstanceOfOp extends JavaOp\n+            implements Pure, ReflectiveOp, JavaExpression {\n+        public static final String NAME = \"instanceof\";\n+        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final TypeElement typeDescriptor;\n+\n+        public static InstanceOfOp create(ExternalizedOp def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+\n+            TypeElement typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+                    v -> switch (v) {\n+                        case JavaType td -> td;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n+                    });\n+            return new InstanceOfOp(def, typeDescriptor);\n+        }\n+\n+        InstanceOfOp(ExternalizedOp def, TypeElement typeDescriptor) {\n+            super(def);\n+\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        InstanceOfOp(InstanceOfOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.typeDescriptor = that.typeDescriptor;\n+        }\n+\n+        @Override\n+        public InstanceOfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InstanceOfOp(this, cc);\n+        }\n+\n+        InstanceOfOp(TypeElement t, Value v) {\n+            super(NAME,\n+                    List.of(v));\n+\n+            this.typeDescriptor = t;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", typeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeElement type() {\n+            return typeDescriptor;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The cast operation, that can model Java language cast expressions for reference types.\n+     *\/\n+    @OpFactory.OpDeclaration(CastOp.NAME)\n+    public static final class CastOp extends JavaOp\n+            implements Pure, ReflectiveOp, JavaExpression {\n+        public static final String NAME = \"cast\";\n+        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final TypeElement resultType;\n+        final TypeElement typeDescriptor;\n+\n+        public static CastOp create(ExternalizedOp def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+\n+            TypeElement type = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+                    v -> switch (v) {\n+                        case JavaType td -> td;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n+                    });\n+            return new CastOp(def, type);\n+        }\n+\n+        CastOp(ExternalizedOp def, TypeElement typeDescriptor) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        CastOp(CastOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.resultType = that.resultType;\n+            this.typeDescriptor = that.typeDescriptor;\n+        }\n+\n+        @Override\n+        public CastOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CastOp(this, cc);\n+        }\n+\n+        CastOp(TypeElement resultType, TypeElement t, Value v) {\n+            super(NAME, List.of(v));\n+\n+            this.resultType = resultType;\n+            this.typeDescriptor = t;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", typeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeElement type() {\n+            return typeDescriptor;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The exception region start operation.\n+     *\/\n+    @OpFactory.OpDeclaration(ExceptionRegionEnter.NAME)\n+    public static final class ExceptionRegionEnter extends JavaOp\n+            implements BlockTerminating {\n+        public static final String NAME = \"exception.region.enter\";\n+\n+        \/\/ First successor is the non-exceptional successor whose target indicates\n+        \/\/ the first block in the exception region.\n+        \/\/ One or more subsequent successors target the exception catching blocks\n+        \/\/ each of which have one block argument whose type is an exception type.\n+        final List<Block.Reference> s;\n+\n+        public ExceptionRegionEnter(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.successors().size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n+            }\n+\n+            this.s = List.copyOf(def.successors());\n+        }\n+\n+        ExceptionRegionEnter(ExceptionRegionEnter that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+        }\n+\n+        @Override\n+        public ExceptionRegionEnter transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionRegionEnter(this, cc);\n+        }\n+\n+        ExceptionRegionEnter(List<Block.Reference> s) {\n+            super(NAME, List.of());\n+\n+            if (s.size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            }\n+\n+            this.s = List.copyOf(s);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return s;\n+        }\n+\n+        public Block.Reference start() {\n+            return s.get(0);\n+        }\n+\n+        public List<Block.Reference> catchBlocks() {\n+            return s.subList(1, s.size());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The exception region end operation.\n+     *\/\n+    @OpFactory.OpDeclaration(ExceptionRegionExit.NAME)\n+    public static final class ExceptionRegionExit extends JavaOp\n+            implements BlockTerminating {\n+        public static final String NAME = \"exception.region.exit\";\n+\n+        \/\/ First successor is the non-exceptional successor whose target indicates\n+        \/\/ the first block following the exception region.\n+        final List<Block.Reference> s;\n+\n+        public ExceptionRegionExit(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.successors().size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n+            }\n+\n+            this.s = List.copyOf(def.successors());\n+        }\n+\n+        ExceptionRegionExit(ExceptionRegionExit that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+        }\n+\n+        @Override\n+        public ExceptionRegionExit transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionRegionExit(this, cc);\n+        }\n+\n+        ExceptionRegionExit(List<Block.Reference> s) {\n+            super(NAME, List.of());\n+\n+            if (s.size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            }\n+\n+            this.s = List.copyOf(s);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return s;\n+        }\n+\n+        public Block.Reference end() {\n+            return s.get(0);\n+        }\n+\n+        public List<Block.Reference> catchBlocks() {\n+            return s.subList(1, s.size());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The String Concatenation Operation\n+     *\/\n+\n+    @OpFactory.OpDeclaration(ConcatOp.NAME)\n+    public static final class ConcatOp extends JavaOp\n+            implements Pure, JavaExpression {\n+        public static final String NAME = \"concat\";\n+\n+        public ConcatOp(ConcatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        public ConcatOp(ExternalizedOp def) {\n+            super(def);\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Concatenation Operation must have two operands.\");\n+            }\n+        }\n+\n+        public ConcatOp(Value lhs, Value rhs) {\n+            super(ConcatOp.NAME, List.of(lhs, rhs));\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ConcatOp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return J_L_STRING;\n+        }\n+    }\n+\n+    \/**\n+     * The arithmetic operation.\n+     *\/\n+    public sealed static abstract class ArithmeticOperation extends JavaOp\n+            implements Pure, JavaExpression {\n+        protected ArithmeticOperation(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n+            }\n+        }\n+\n+        protected ArithmeticOperation(ArithmeticOperation that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected ArithmeticOperation(String name, List<Value> operands) {\n+            super(name, operands);\n+        }\n+    }\n+\n+    \/**\n+     * The test operation.\n+     *\/\n+    public sealed static abstract class TestOperation extends JavaOp\n+            implements Pure, JavaExpression {\n+        protected TestOperation(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n+            }\n+        }\n+\n+        protected TestOperation(TestOperation that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected TestOperation(String name, List<Value> operands) {\n+            super(name, operands);\n+        }\n+    }\n+\n+    \/**\n+     * The binary arithmetic operation.\n+     *\/\n+    public sealed static abstract class BinaryOp extends ArithmeticOperation {\n+        protected BinaryOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected BinaryOp(BinaryOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected BinaryOp(String name, Value lhs, Value rhs) {\n+            super(name, List.of(lhs, rhs));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return operands().get(0).type();\n+        }\n+    }\n+\n+    \/**\n+     * The unary arithmetic operation.\n+     *\/\n+    public sealed static abstract class UnaryOp extends ArithmeticOperation {\n+        protected UnaryOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected UnaryOp(UnaryOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected UnaryOp(String name, Value v) {\n+            super(name, List.of(v));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return operands().get(0).type();\n+        }\n+    }\n+\n+    \/**\n+     * The binary test operation.\n+     *\/\n+    public sealed static abstract class BinaryTestOp extends TestOperation {\n+        protected BinaryTestOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected BinaryTestOp(BinaryTestOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected BinaryTestOp(String name, Value lhs, Value rhs) {\n+            super(name, List.of(lhs, rhs));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The add operation, that can model the Java language binary {@code +} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(AddOp.NAME)\n+    public static final class AddOp extends BinaryOp {\n+        public static final String NAME = \"add\";\n+\n+        public AddOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        AddOp(AddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AddOp(this, cc);\n+        }\n+\n+        AddOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The sub operation, that can model the Java language binary {@code -} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(SubOp.NAME)\n+    public static final class SubOp extends BinaryOp {\n+        public static final String NAME = \"sub\";\n+\n+        public SubOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        SubOp(SubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SubOp(this, cc);\n+        }\n+\n+        SubOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The mul operation, that can model the Java language binary {@code *} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(MulOp.NAME)\n+    public static final class MulOp extends BinaryOp {\n+        public static final String NAME = \"mul\";\n+\n+        public MulOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        MulOp(MulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MulOp(this, cc);\n+        }\n+\n+        MulOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The div operation, that can model the Java language binary {@code \/} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(DivOp.NAME)\n+    public static final class DivOp extends BinaryOp {\n+        public static final String NAME = \"div\";\n+\n+        public DivOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        DivOp(DivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DivOp(this, cc);\n+        }\n+\n+        DivOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The mod operation, that can model the Java language binary {@code %} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(ModOp.NAME)\n+    public static final class ModOp extends BinaryOp {\n+        public static final String NAME = \"mod\";\n+\n+        public ModOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        ModOp(ModOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ModOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModOp(this, cc);\n+        }\n+\n+        ModOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The bitwise\/logical or operation, that can model the Java language binary {@code |} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpFactory.OpDeclaration(OrOp.NAME)\n+    public static final class OrOp extends BinaryOp {\n+        public static final String NAME = \"or\";\n+\n+        public OrOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        OrOp(OrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new OrOp(this, cc);\n+        }\n+\n+        OrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The bitwise\/logical and operation, that can model the Java language binary {@code &} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpFactory.OpDeclaration(AndOp.NAME)\n+    public static final class AndOp extends BinaryOp {\n+        public static final String NAME = \"and\";\n+\n+        public AndOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        AndOp(AndOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AndOp(this, cc);\n+        }\n+\n+        AndOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The xor operation, that can model the Java language binary {@code ^} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpFactory.OpDeclaration(XorOp.NAME)\n+    public static final class XorOp extends BinaryOp {\n+        public static final String NAME = \"xor\";\n+\n+        public XorOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        XorOp(XorOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public XorOp transform(CopyContext cc, OpTransformer ot) {\n+            return new XorOp(this, cc);\n+        }\n+\n+        XorOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The (logical) shift left operation, that can model the Java language binary {@code <<} operator for integral types\n+     *\/\n+    @OpFactory.OpDeclaration(LshlOp.NAME)\n+    public static final class LshlOp extends BinaryOp {\n+        public static final String NAME = \"lshl\";\n+\n+        public LshlOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        LshlOp(LshlOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LshlOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LshlOp(this, cc);\n+        }\n+\n+        LshlOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The (arithmetic) shift right operation, that can model the Java language binary {@code >>} operator for integral types\n+     *\/\n+    @OpFactory.OpDeclaration(AshrOp.NAME)\n+    public static final class AshrOp extends JavaOp.BinaryOp {\n+        public static final String NAME = \"ashr\";\n+\n+        public AshrOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        AshrOp(AshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AshrOp(this, cc);\n+        }\n+\n+        AshrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The unsigned (logical) shift right operation, that can model the Java language binary {@code >>>} operator for integral types\n+     *\/\n+    @OpFactory.OpDeclaration(LshrOp.NAME)\n+    public static final class LshrOp extends JavaOp.BinaryOp {\n+        public static final String NAME = \"lshr\";\n+\n+        public LshrOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        LshrOp(LshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LshrOp(this, cc);\n+        }\n+\n+        LshrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The neg operation, that can model the Java language unary {@code -} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(NegOp.NAME)\n+    public static final class NegOp extends UnaryOp {\n+        public static final String NAME = \"neg\";\n+\n+        public NegOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        NegOp(NegOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NegOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NegOp(this, cc);\n+        }\n+\n+        NegOp(Value v) {\n+            super(NAME, v);\n+        }\n+    }\n+\n+    \/**\n+     * The bitwise complement operation, that can model the Java language unary {@code ~} operator for integral types\n+     *\/\n+    @OpFactory.OpDeclaration(ComplOp.NAME)\n+    public static final class ComplOp extends UnaryOp {\n+        public static final String NAME = \"compl\";\n+\n+        public ComplOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        ComplOp(ComplOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ComplOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ComplOp(this, cc);\n+        }\n+\n+        ComplOp(Value v) {\n+            super(NAME, v);\n+        }\n+    }\n+\n+    \/**\n+     * The not operation, that can model the Java language unary {@code !} operator for boolean types\n+     *\/\n+    @OpFactory.OpDeclaration(NotOp.NAME)\n+    public static final class NotOp extends UnaryOp {\n+        public static final String NAME = \"not\";\n+\n+        public NotOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        NotOp(NotOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NotOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NotOp(this, cc);\n+        }\n+\n+        NotOp(Value v) {\n+            super(NAME, v);\n+        }\n+    }\n+\n+    \/**\n+     * The equals operation, that can model the Java language equality {@code ==} operator for numeric, boolean\n+     * and reference types\n+     *\/\n+    @OpFactory.OpDeclaration(EqOp.NAME)\n+    public static final class EqOp extends BinaryTestOp {\n+        public static final String NAME = \"eq\";\n+\n+        public EqOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        EqOp(EqOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public EqOp transform(CopyContext cc, OpTransformer ot) {\n+            return new EqOp(this, cc);\n+        }\n+\n+        EqOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The not equals operation, that can model the Java language equality {@code !=} operator for numeric, boolean\n+     * and reference types\n+     *\/\n+    @OpFactory.OpDeclaration(NeqOp.NAME)\n+    public static final class NeqOp extends BinaryTestOp {\n+        public static final String NAME = \"neq\";\n+\n+        public NeqOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        NeqOp(NeqOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NeqOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NeqOp(this, cc);\n+        }\n+\n+        NeqOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The greater than operation, that can model the Java language relational {@code >} operator for numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(GtOp.NAME)\n+    public static final class GtOp extends BinaryTestOp {\n+        public static final String NAME = \"gt\";\n+\n+        public GtOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        GtOp(GtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GtOp(this, cc);\n+        }\n+\n+        GtOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The greater than or equal to operation, that can model the Java language relational {@code >=} operator for\n+     * numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(GeOp.NAME)\n+    public static final class GeOp extends BinaryTestOp {\n+        public static final String NAME = \"ge\";\n+\n+        public GeOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        GeOp(GeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GeOp(this, cc);\n+        }\n+\n+        GeOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The less than operation, that can model the Java language relational {@code <} operator for\n+     * numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(LtOp.NAME)\n+    public static final class LtOp extends BinaryTestOp {\n+        public static final String NAME = \"lt\";\n+\n+        public LtOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        LtOp(LtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LtOp(this, cc);\n+        }\n+\n+        LtOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The less than or equal to operation, that can model the Java language relational {@code <=} operator for\n+     * numeric types\n+     *\/\n+    @OpFactory.OpDeclaration(LeOp.NAME)\n+    public static final class LeOp extends BinaryTestOp {\n+        public static final String NAME = \"le\";\n+\n+        public LeOp(ExternalizedOp opdef) {\n+            super(opdef);\n+        }\n+\n+        LeOp(LeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LeOp(this, cc);\n+        }\n+\n+        LeOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The label operation, that can model Java language statements with label identifiers.\n+     *\/\n+    public sealed static abstract class JavaLabelOp extends JavaOp\n+            implements Op.Lowerable, Op.BodyTerminating, JavaStatement {\n+        JavaLabelOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        JavaLabelOp(JavaLabelOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        JavaLabelOp(String name, Value label) {\n+            super(name, checkLabel(label));\n+        }\n+\n+        static List<Value> checkLabel(Value label) {\n+            return label == null ? List.of() : List.of(label);\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            \/*\n+                A break statement with no label attempts to transfer control to the\n+                innermost enclosing switch, while, do, or for statement; this enclosing statement,\n+                which is called the break target, then immediately completes normally.\n+\n+                A break statement with label Identifier attempts to transfer control to the\n+                enclosing labeled statement (14.7) that has the same Identifier as its label;\n+                this enclosing statement, which is called the break target, then immediately completes normally.\n+                In this case, the break target need not be a switch, while, do, or for statement.\n+             *\/\n+\n+            \/\/ No label\n+            \/\/ Get innermost enclosing loop operation\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing loop\");\n+                }\n+            } while (!(op instanceof Op.Loop || op instanceof JavaSwitchStatementOp));\n+\n+            return switch (op) {\n+                case Op.Loop lop -> lop.loopBody() == b ? op : null;\n+                case JavaSwitchStatementOp swStat -> swStat.bodies().contains(b) ? op : null;\n+                default -> throw new IllegalStateException();\n+            };\n+        }\n+\n+        boolean isUnlabeled() {\n+            return operands().isEmpty();\n+        }\n+\n+        Op target() {\n+            \/\/ If unlabeled then find the nearest enclosing op\n+            \/\/ Otherwise obtain the label target\n+            if (isUnlabeled()) {\n+                return innerMostEnclosingTarget();\n+            }\n+\n+            Value value = operands().get(0);\n+            if (value instanceof Result r && r.op().ancestorBody().parentOp() instanceof JavaLabeledOp lop) {\n+                return lop.target();\n+            } else {\n+                throw new IllegalStateException(\"Bad label value: \" + value + \" \" + ((Result) value).op());\n+            }\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language break statements with label identifiers.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaBreakOp.NAME)\n+    public static final class JavaBreakOp extends JavaLabelOp {\n+        public static final String NAME = \"java.break\";\n+\n+        public JavaBreakOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaBreakOp(JavaBreakOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaBreakOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBreakOp(this, cc);\n+        }\n+\n+        JavaBreakOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+    }\n+\n+    \/**\n+     * The continue operation, that can model Java language continue statements with label identifiers.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaContinueOp.NAME)\n+    public static final class JavaContinueOp extends JavaLabelOp {\n+        public static final String NAME = \"java.continue\";\n+\n+        public JavaContinueOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaContinueOp(JavaContinueOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaContinueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaContinueOp(this, cc);\n+        }\n+\n+        JavaContinueOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+    }\n+\n+    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+    }\n+\n+    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n+\n+    static BranchTarget getBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(codeElement);\n+        }\n+        return null;\n+    }\n+\n+    static void setBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(codeElement, t);\n+    }\n+\n+    \/**\n+     * The yield operation, that can model Java language yield statements.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaYieldOp.NAME)\n+    public static final class JavaYieldOp extends JavaOp\n+            implements Op.BodyTerminating, JavaStatement, Op.Lowerable {\n+        public static final String NAME = \"java.yield\";\n+\n+        public JavaYieldOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaYieldOp(JavaYieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaYieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaYieldOp(this, cc);\n+        }\n+\n+        JavaYieldOp() {\n+            super(NAME,\n+                    List.of());\n+        }\n+\n+        JavaYieldOp(Value operand) {\n+            super(NAME, List.of(operand));\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ for now, we will use breakBlock field to indicate java.yield target block\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor(b.context().getValue(yieldValue()))));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        Op target() {\n+            return innerMostEnclosingTarget();\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing switch\");\n+                }\n+            } while (!(op instanceof JavaSwitchExpressionOp));\n+            return op;\n+        }\n+    }\n+\n+    \/**\n+     * The block operation, that can model Java language blocks.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaBlockOp.NAME)\n+    public static final class JavaBlockOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaStatement {\n+        public static final String NAME = \"java.block\";\n+\n+        final Body body;\n+\n+        public JavaBlockOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaBlockOp(JavaBlockOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaBlockOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBlockOp(this, cc, ot);\n+        }\n+\n+        JavaBlockOp(Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The synchronized operation, that can model Java synchronized statements.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSynchronizedOp.NAME)\n+    public static final class JavaSynchronizedOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaStatement {\n+        public static final String NAME = \"java.synchronized\";\n+\n+        final Body expr;\n+        final Body blockBody;\n+\n+        public JavaSynchronizedOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.expr = def.bodyDefinitions().get(0).build(this);\n+            this.blockBody = def.bodyDefinitions().get(1).build(this);\n+        }\n+\n+        JavaSynchronizedOp(JavaSynchronizedOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy bodies\n+            this.expr = that.expr.transform(cc, ot).build(this);\n+            this.blockBody = that.blockBody.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaSynchronizedOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSynchronizedOp(this, cc, ot);\n+        }\n+\n+        JavaSynchronizedOp(Body.Builder exprC, Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.expr = exprC.build(this);\n+            if (expr.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Expression body should return non-void value: \" + expr.bodyType());\n+            }\n+            if (!expr.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression body should have zero parameters: \" + expr.bodyType());\n+            }\n+\n+            this.blockBody = bodyC.build(this);\n+            if (!blockBody.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Block body should return void: \" + blockBody.bodyType());\n+            }\n+            if (!blockBody.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Block body should have zero parameters: \" + blockBody.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(expr, blockBody);\n+        }\n+\n+        public Body expr() {\n+            return expr;\n+        }\n+\n+        public Body blockBody() {\n+            return blockBody;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            \/\/ Lower the expression body, yielding a monitor target\n+            b = lowerExpr(b, opT);\n+            Value monitorTarget = b.parameters().get(0);\n+\n+            \/\/ Monitor enter\n+            b.op(monitorEnter(monitorTarget));\n+\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Exception region for the body\n+            Block.Builder syncRegionEnter = b.block();\n+            Block.Builder catcherFinally = b.block();\n+            b.op(exceptionRegionEnter(\n+                    syncRegionEnter.successor(), catcherFinally.successor()));\n+\n+            OpTransformer syncExitTransformer = opT.compose((block, op) -> {\n+                if (op instanceof CoreOp.ReturnOp ||\n+                    (op instanceof JavaOp.JavaLabelOp lop && ifExitFromSynchronized(lop))) {\n+                    \/\/ Monitor exit\n+                    block.op(monitorExit(monitorTarget));\n+                    \/\/ Exit the exception region\n+                    Block.Builder exitRegion = block.block();\n+                    block.op(exceptionRegionExit(exitRegion.successor(), catcherFinally.successor()));\n+                    return exitRegion;\n+                } else {\n+                    return block;\n+                }\n+            });\n+\n+            syncRegionEnter.transformBody(blockBody, List.of(), syncExitTransformer.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    \/\/ Monitor exit\n+                    block.op(monitorExit(monitorTarget));\n+                    \/\/ Exit the exception region\n+                    block.op(exceptionRegionExit(exit.successor(), catcherFinally.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, syncExitTransformer);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            \/\/ The catcher, with an exception region back branching to itself\n+            Block.Builder catcherFinallyRegionEnter = b.block();\n+            catcherFinally.op(exceptionRegionEnter(\n+                    catcherFinallyRegionEnter.successor(), catcherFinally.successor()));\n+\n+            \/\/ Monitor exit\n+            catcherFinallyRegionEnter.op(monitorExit(monitorTarget));\n+            Block.Builder catcherFinallyRegionExit = b.block();\n+            \/\/ Exit the exception region\n+            catcherFinallyRegionEnter.op(exceptionRegionExit(\n+                    catcherFinallyRegionExit.successor(), catcherFinally.successor()));\n+            \/\/ Rethrow outside of region\n+            Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n+            catcherFinallyRegionExit.op(_throw(t));\n+\n+            return exit;\n+        }\n+\n+        Block.Builder lowerExpr(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exprExit = b.block(expr.bodyType().returnType());\n+            b.transformBody(expr, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yop) {\n+                    Value monitorTarget = block.context().getValue(yop.yieldValue());\n+                    block.op(branch(exprExit.successor(monitorTarget)));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+            return exprExit;\n+        }\n+\n+        boolean ifExitFromSynchronized(JavaLabelOp lop) {\n+            Op target = lop.target();\n+            return target == this || ifAncestorOp(target, this);\n+        }\n+\n+        static boolean ifAncestorOp(Op ancestor, Op op) {\n+            while (op.ancestorBody() != null) {\n+                op = op.ancestorBody().parentOp();\n+                if (op == ancestor) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The labeled operation, that can model Java language labeled statements.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaLabeledOp.NAME)\n+    public static final class JavaLabeledOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaStatement {\n+        public static final String NAME = \"java.labeled\";\n+\n+        final Body body;\n+\n+        public JavaLabeledOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaLabeledOp(JavaLabeledOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaLabeledOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaLabeledOp(this, cc, ot);\n+        }\n+\n+        JavaLabeledOp(Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Op label() {\n+            return body.entryBlock().firstOp();\n+        }\n+\n+        public Op target() {\n+            return body.entryBlock().nextOp(label());\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            AtomicBoolean first = new AtomicBoolean();\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                \/\/ Drop first operation that corresponds to the label\n+                if (!first.get()) {\n+                    first.set(true);\n+                    return block;\n+                }\n+\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The if operation, that can model Java language if, if-then, and if-then-else statements.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaIfOp.NAME)\n+    public static final class JavaIfOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaStatement {\n+\n+        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n+\n+        static final FunctionType ACTION_TYPE = FunctionType.VOID;\n+\n+        public static class IfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            IfBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+            }\n+\n+            public ThenBuilder _if(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ThenBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ThenBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ElseIfBuilder then(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+\n+            public ElseIfBuilder then() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ElseIfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ElseIfBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ThenBuilder elseif(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+\n+            public JavaIfOp _else(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+\n+            public JavaIfOp _else() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.if\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaIfOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaIfOp(JavaIfOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaIfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaIfOp(this, cc, ot);\n+        }\n+\n+        JavaIfOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            \/\/ Normalize by adding an empty else action\n+            \/\/ @@@ Is this needed?\n+            if (bodyCs.size() % 2 == 0) {\n+                bodyCs = new ArrayList<>(bodyCs);\n+                Body.Builder end = Body.Builder.of(bodyCs.get(0).ancestorBody(),\n+                        FunctionType.VOID);\n+                end.entryBlock().op(_yield());\n+                bodyCs.add(end);\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+\n+            if (bodies.size() < 2) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body action;\n+                if (i == bodies.size() - 1) {\n+                    action = bodies.get(i);\n+                } else {\n+                    action = bodies.get(i + 1);\n+                    Body fromPred = bodies.get(i);\n+                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.bodyType());\n+                    }\n+                }\n+                if (!action.bodyType().equals(FunctionType.VOID)) {\n+                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.bodyType());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Create predicate and action blocks\n+            List<Block.Builder> builders = new ArrayList<>();\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                if (i == bodies.size() - 1) {\n+                    builders.add(b.block());\n+                } else {\n+                    builders.add(i == 0 ? b : b.block());\n+                    builders.add(b.block());\n+                }\n+            }\n+\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body actionBody;\n+                Block.Builder action;\n+                if (i == bodies.size() - 1) {\n+                    actionBody = bodies.get(i);\n+                    action = builders.get(i);\n+                } else {\n+                    Body predBody = bodies.get(i);\n+                    actionBody = bodies.get(i + 1);\n+\n+                    Block.Builder pred = builders.get(i);\n+                    action = builders.get(i + 1);\n+                    Block.Builder next = builders.get(i + 2);\n+\n+                    pred.transformBody(predBody, List.of(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yo) {\n+                            block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                                    action.successor(), next.successor()));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+\n+                action.transformBody(actionBody, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    public abstract static sealed class JavaSwitchOp extends JavaOp implements Op.Nested, Op.Lowerable\n+            permits JavaSwitchStatementOp, JavaSwitchExpressionOp {\n+\n+        final List<Body> bodies;\n+\n+        public JavaSwitchOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaSwitchOp(JavaSwitchOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        JavaSwitchOp(String name, Value target, List<Body.Builder> bodyCs) {\n+            super(name, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements body has no parameters and returns void\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+\n+            Value selectorExpression = b.context().getValue(operands().get(0));\n+\n+            \/\/ @@@ we can add this during model generation\n+            \/\/ if no case null, add one that throws NPE\n+            if (!(selectorExpression.type() instanceof PrimitiveType) && !haveNullCase()) {\n+                Block.Builder throwBlock = b.block();\n+                throwBlock.op(_throw(\n+                        throwBlock.op(_new(ConstructorRef.constructor(NullPointerException.class)))\n+                ));\n+\n+                Block.Builder continueBlock = b.block();\n+\n+                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n+                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n+\n+                b = continueBlock;\n+            }\n+\n+            List<Block.Builder> blocks = new ArrayList<>();\n+            for (int i = 0; i < bodies().size(); i++) {\n+                Block.Builder bb = b.block();\n+                if (i == 0) {\n+                    bb = b;\n+                }\n+                blocks.add(bb);\n+            }\n+\n+            Block.Builder exit;\n+            if (bodies().isEmpty()) {\n+                exit = b;\n+            } else {\n+                exit = b.block(resultType());\n+                if (this instanceof JavaSwitchExpressionOp) {\n+                    exit.context().mapValue(result(), exit.parameters().get(0));\n+                }\n+            }\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+            \/\/ map statement body to nextExprBlock\n+            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n+            for (int i = 1; i < bodies().size() - 2; i+=2) {\n+                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n+            }\n+\n+            for (int i = 0; i < bodies().size(); i++) {\n+                boolean isLabelBody = i % 2 == 0;\n+                Block.Builder curr = blocks.get(i);\n+                if (isLabelBody) {\n+                    Block.Builder statement = blocks.get(i + 1);\n+                    boolean isLastLabel = i == blocks.size() - 2;\n+                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n+                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop when isLastLabel && this instanceof JavaSwitchExpressionOp -> {\n+                                block.op(branch(statement.successor()));\n+                            }\n+                            case YieldOp yop -> block.op(conditionalBranch(\n+                                    block.context().getValue(yop.yieldValue()),\n+                                    statement.successor(),\n+                                    isLastLabel ? exit.successor() : nextLabel.successor()\n+                            ));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                } else { \/\/ statement body\n+                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n+                        switch (op) {\n+                            case YieldOp yop when this instanceof JavaSwitchStatementOp -> block.op(branch(exit.successor()));\n+                            case YieldOp yop when this instanceof JavaSwitchExpressionOp -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                            case Lowerable lop -> block = lop.lower(block);\n+                            default -> block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+\n+        boolean haveNullCase() {\n+            \/*\n+            case null is modeled like this:\n+            (%4 : T)boolean -> {\n+                %5 : java.lang.Object = constant @null;\n+                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                yield %6;\n+            }\n+            * *\/\n+            for (int i = 0; i < bodies().size() - 2; i+=2) {\n+                Body labelBody = bodies().get(i);\n+                if (labelBody.blocks().size() != 1) {\n+                    continue; \/\/ we skip, for now\n+                }\n+                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n+                \/\/@@@ when op pattern matching is ready, we can use it\n+                if (terminatingOp instanceof YieldOp yieldOp &&\n+                        yieldOp.yieldValue() instanceof Op.Result opr &&\n+                        opr.op() instanceof InvokeOp invokeOp &&\n+                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n+                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * The switch expression operation, that can model Java language switch expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchExpressionOp.NAME)\n+    public static final class JavaSwitchExpressionOp extends JavaSwitchOp\n+            implements JavaExpression {\n+        public static final String NAME = \"java.switch.expression\";\n+\n+        final TypeElement resultType;\n+\n+        public JavaSwitchExpressionOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, target, bodyCs);\n+\n+            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The switch statement operation, that can model Java language switch statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n+    public static final class JavaSwitchStatementOp extends JavaSwitchOp\n+            implements JavaStatement {\n+        public static final String NAME = \"java.switch.statement\";\n+\n+        public JavaSwitchStatementOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchStatementOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, target, bodyCs);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The switch fall-through operation, that can model fall-through to the next statement in the switch block after\n+     * the last statement of the current switch label.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaSwitchFallthroughOp.NAME)\n+    public static final class JavaSwitchFallthroughOp extends JavaOp\n+            implements Op.BodyTerminating, Op.Lowerable {\n+        public static final String NAME = \"java.switch.fallthrough\";\n+\n+        public JavaSwitchFallthroughOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaSwitchFallthroughOp(JavaSwitchFallthroughOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaSwitchFallthroughOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchFallthroughOp(this, cc);\n+        }\n+\n+        JavaSwitchFallthroughOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            BranchTarget t = getBranchTarget(b.context(), parentBlock().parentBody());\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + this);\n+            }\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The for operation, that can model a Java language for statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaForOp.NAME)\n+    public static final class JavaForOp extends JavaOp\n+            implements Op.Loop, Op.Lowerable, JavaStatement {\n+\n+        public static final class InitBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+\n+            InitBuilder(Body.Builder ancestorBody,\n+                        List<? extends TypeElement> initTypes) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes.stream().map(VarType::varType).toList();\n+            }\n+\n+            public JavaForOp.CondBuilder init(Consumer<Block.Builder> c) {\n+                Body.Builder init = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(TupleType.tupleType(initTypes)));\n+                c.accept(init.entryBlock());\n+\n+                return new CondBuilder(ancestorBody, initTypes, init);\n+            }\n+        }\n+\n+        public static final class CondBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+\n+            public CondBuilder(Body.Builder ancestorBody,\n+                               List<? extends TypeElement> initTypes,\n+                               Body.Builder init) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+            }\n+\n+            public JavaForOp.UpdateBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder cond = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(BOOLEAN, initTypes));\n+                c.accept(cond.entryBlock());\n+\n+                return new UpdateBuilder(ancestorBody, initTypes, init, cond);\n+            }\n+        }\n+\n+        public static final class UpdateBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+\n+            public UpdateBuilder(Body.Builder ancestorBody,\n+                                 List<? extends TypeElement> initTypes,\n+                                 Body.Builder init, Body.Builder cond) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+            }\n+\n+            public JavaForOp.BodyBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder update = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, initTypes));\n+                c.accept(update.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, initTypes, init, cond, update);\n+            }\n+\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+            final Body.Builder update;\n+\n+            public BodyBuilder(Body.Builder ancestorBody,\n+                               List<? extends TypeElement> initTypes,\n+                               Body.Builder init, Body.Builder cond, Body.Builder update) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+                this.update = update;\n+            }\n+\n+            public JavaForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, initTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaForOp(init, cond, update, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.for\";\n+\n+        final Body init;\n+        final Body cond;\n+        final Body update;\n+        final Body body;\n+\n+        public static JavaForOp create(ExternalizedOp def) {\n+            return new JavaForOp(def);\n+        }\n+\n+        public JavaForOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.init = def.bodyDefinitions().get(0).build(this);\n+            this.cond = def.bodyDefinitions().get(1).build(this);\n+            this.update = def.bodyDefinitions().get(2).build(this);\n+            this.body = def.bodyDefinitions().get(3).build(this);\n+        }\n+\n+        JavaForOp(JavaForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.cond = that.cond.transform(cc, ot).build(this);\n+            this.update = that.update.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaForOp(this, cc, ot);\n+        }\n+\n+        JavaForOp(Body.Builder initC,\n+                  Body.Builder condC,\n+                  Body.Builder updateC,\n+                  Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.init = initC.build(this);\n+\n+            this.cond = condC.build(this);\n+\n+            this.update = updateC.build(this);\n+            if (!update.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Update should return void: \" + update.bodyType());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(init, cond, update, body);\n+        }\n+\n+        public Body init() {\n+            return init;\n+        }\n+\n+        public Body cond() {\n+            return cond;\n+        }\n+\n+        public Body update() {\n+            return update;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder update = b.block();\n+            Block.Builder exit = b.block();\n+\n+            List<Value> initValues = new ArrayList<>();\n+            \/\/ @@@ Init body has one yield operation yielding\n+            \/\/  void, a single variable, or a tuple of one or more variables\n+            b.transformBody(init, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOp.TupleOp) {\n+                    \/\/ Drop Tuple if a yielded\n+                    boolean isResult = op.result().uses().size() == 1 &&\n+                            op.result().uses().stream().allMatch(r -> r.op() instanceof YieldOp);\n+                    if (!isResult) {\n+                        block.op(op);\n+                    }\n+                } else if (op instanceof YieldOp yop) {\n+                    if (yop.yieldValue() == null) {\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    } else if (yop.yieldValue() instanceof Result or) {\n+                        if (or.op() instanceof CoreOp.TupleOp top) {\n+                            initValues.addAll(block.context().getValues(top.operands()));\n+                        } else {\n+                            initValues.addAll(block.context().getValues(yop.operands()));\n+                        }\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    }\n+\n+                    throw new IllegalStateException(\"Bad yield operation\");\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(cond, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+            body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            update.transformBody(this.update, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(header.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The enhanced for operation, that can model a Java language enhanced for statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaEnhancedForOp.NAME)\n+    public static final class JavaEnhancedForOp extends JavaOp\n+            implements Op.Loop, Op.Lowerable, JavaStatement {\n+\n+        public static final class ExpressionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement iterableType;\n+            final TypeElement elementType;\n+\n+            ExpressionBuilder(Body.Builder ancestorBody,\n+                              TypeElement iterableType, TypeElement elementType) {\n+                this.ancestorBody = ancestorBody;\n+                this.iterableType = iterableType;\n+                this.elementType = elementType;\n+            }\n+\n+            public DefinitionBuilder expression(Consumer<Block.Builder> c) {\n+                Body.Builder expression = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(iterableType));\n+                c.accept(expression.entryBlock());\n+\n+                return new DefinitionBuilder(ancestorBody, elementType, expression);\n+            }\n+        }\n+\n+        public static final class DefinitionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement elementType;\n+            final Body.Builder expression;\n+\n+            DefinitionBuilder(Body.Builder ancestorBody,\n+                              TypeElement elementType, Body.Builder expression) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+            }\n+\n+            public BodyBuilder definition(Consumer<Block.Builder> c) {\n+                return definition(elementType, c);\n+            }\n+\n+            public BodyBuilder definition(TypeElement bodyElementType, Consumer<Block.Builder> c) {\n+                Body.Builder definition = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(bodyElementType, elementType));\n+                c.accept(definition.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, elementType, expression, definition);\n+            }\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement elementType;\n+            final Body.Builder expression;\n+            final Body.Builder definition;\n+\n+            BodyBuilder(Body.Builder ancestorBody,\n+                        TypeElement elementType, Body.Builder expression, Body.Builder definition) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+                this.definition = definition;\n+            }\n+\n+            public JavaEnhancedForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, elementType));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaEnhancedForOp(expression, definition, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.enhancedFor\";\n+\n+        final Body expression;\n+        final Body init;\n+        final Body body;\n+\n+        public static JavaEnhancedForOp create(ExternalizedOp def) {\n+            return new JavaEnhancedForOp(def);\n+        }\n+\n+        public JavaEnhancedForOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.expression = def.bodyDefinitions().get(0).build(this);\n+            this.init = def.bodyDefinitions().get(1).build(this);\n+            this.body = def.bodyDefinitions().get(2).build(this);\n+        }\n+\n+        JavaEnhancedForOp(JavaEnhancedForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expression = that.expression.transform(cc, ot).build(this);\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaEnhancedForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaEnhancedForOp(this, cc, ot);\n+        }\n+\n+        JavaEnhancedForOp(Body.Builder expressionC, Body.Builder initC, Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.expression = expressionC.build(this);\n+            if (expression.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.bodyType());\n+            }\n+            if (!expression.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.bodyType());\n+            }\n+\n+            this.init = initC.build(this);\n+            if (init.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.bodyType());\n+            }\n+            if (init.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.bodyType());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (body.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(expression, init, body);\n+        }\n+\n+        public Body expression() {\n+            return expression;\n+        }\n+\n+        public Body initialization() {\n+            return init;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        static final MethodRef ITERABLE_ITERATOR = MethodRef.method(Iterable.class, \"iterator\", Iterator.class);\n+        static final MethodRef ITERATOR_HAS_NEXT = MethodRef.method(Iterator.class, \"hasNext\", boolean.class);\n+        static final MethodRef ITERATOR_NEXT = MethodRef.method(Iterator.class, \"next\", Object.class);\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            JavaType elementType = (JavaType) init.entryBlock().parameters().get(0).type();\n+            boolean isArray = expression.bodyType().returnType() instanceof ArrayType;\n+\n+            Block.Builder preHeader = b.block(expression.bodyType().returnType());\n+            Block.Builder header = b.block(isArray ? List.of(INT) : List.of());\n+            Block.Builder init = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yop) {\n+                    Value loopSource = block.context().getValue(yop.yieldValue());\n+                    block.op(branch(preHeader.successor(loopSource)));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            if (isArray) {\n+                Value array = preHeader.parameters().get(0);\n+                Value arrayLength = preHeader.op(arrayLength(array));\n+                Value i = preHeader.op(constant(INT, 0));\n+                preHeader.op(branch(header.successor(i)));\n+\n+                i = header.parameters().get(0);\n+                Value p = header.op(lt(i, arrayLength));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(arrayLoadOp(array, i));\n+                List<Value> initValues = new ArrayList<>();\n+                \/\/ @@@ Init body has one yield operation yielding a single variable\n+                init.transformBody(this.init, List.of(e), (block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                });\n+\n+                Block.Builder update = b.block();\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                i = update.op(add(i, update.op(constant(INT, 1))));\n+                update.op(branch(header.successor(i)));\n+            } else {\n+                JavaType iterable = parameterized(type(Iterator.class), elementType);\n+                Value iterator = preHeader.op(invoke(iterable, ITERABLE_ITERATOR, preHeader.parameters().get(0)));\n+                preHeader.op(branch(header.successor()));\n+\n+                Value p = header.op(invoke(ITERATOR_HAS_NEXT, iterator));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(invoke(elementType, ITERATOR_NEXT, iterator));\n+                List<Value> initValues = new ArrayList<>();\n+                init.transformBody(this.init, List.of(e), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The while operation, that can model a Java language while statement.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaWhileOp.NAME)\n+    public static final class JavaWhileOp extends JavaOp\n+            implements Op.Loop, Op.Lowerable, JavaStatement {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            PredicateBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaWhileOp.BodyBuilder predicate(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp.BodyBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder predicate;\n+\n+            BodyBuilder(Body.Builder ancestorBody, Body.Builder predicate) {\n+                this.ancestorBody = ancestorBody;\n+                this.predicate = predicate;\n+            }\n+\n+            public JavaWhileOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp(List.of(predicate, body));\n+            }\n+        }\n+\n+        private static final String NAME = \"java.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaWhileOp(ExternalizedOp def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(Body.Builder predicate, Body.Builder body) {\n+            super(NAME, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(predicate, body).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            \/\/ @@@ This will change with pattern bindings\n+            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n+            }\n+            if (!bodies.get(1).bodyType().equals(FunctionType.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n+            }\n+        }\n+\n+        JavaWhileOp(JavaWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(header.successor()));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOp.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The do-while operation, that can model a Java language do statement.\n+     *\/\n+    \/\/ @@@ Unify JavaDoWhileOp and JavaWhileOp with common abstract superclass\n+    @OpFactory.OpDeclaration(JavaDoWhileOp.NAME)\n+    public static final class JavaDoWhileOp extends JavaOp\n+            implements Op.Loop, Op.Lowerable, JavaStatement {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder body;\n+\n+            PredicateBuilder(Body.Builder ancestorBody, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.body = body;\n+            }\n+\n+            public JavaDoWhileOp predicate(Consumer<Block.Builder> c) {\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(predicate.entryBlock());\n+\n+                return new JavaDoWhileOp(List.of(body, predicate));\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            BodyBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaDoWhileOp.PredicateBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaDoWhileOp.PredicateBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        private static final String NAME = \"java.do.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaDoWhileOp(ExternalizedOp def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(Body.Builder body, Body.Builder predicate) {\n+            super(NAME, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(body, predicate).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            if (!bodies.get(0).bodyType().equals(FunctionType.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n+            }\n+            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n+            }\n+        }\n+\n+        JavaDoWhileOp(JavaDoWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaDoWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaDoWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder body = b.block();\n+            Block.Builder header = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(body.successor()));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOp.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and-or operation, that can model Java language condition-or or conditional-and expressions.\n+     *\/\n+    public sealed static abstract class JavaConditionalOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaExpression {\n+        final List<Body> bodies;\n+\n+        public JavaConditionalOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(JavaConditionalOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(String name, List<Body.Builder> bodyCs) {\n+            super(name, List.of());\n+\n+            if (bodyCs.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            for (Body b : bodies) {\n+                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.bodyType());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        static Block.Builder lower(Block.Builder startBlock, OpTransformer opT, JavaConditionalOp cop) {\n+            List<Body> bodies = cop.bodies();\n+\n+            Block.Builder exit = startBlock.block();\n+            TypeElement oprType = cop.result().type();\n+            Block.Parameter arg = exit.parameter(oprType);\n+            startBlock.context().mapValue(cop.result(), arg);\n+\n+            \/\/ Transform bodies in reverse order\n+            \/\/ This makes available the blocks to be referenced as successors in prior blocks\n+\n+            Block.Builder pred = null;\n+            for (int i = bodies.size() - 1; i >= 0; i--) {\n+                OpTransformer opt;\n+                if (i == bodies.size() - 1) {\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOp.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            block.op(branch(exit.successor(p)));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                } else {\n+                    Block.Builder nextPred = pred;\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOp.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            if (cop instanceof JavaConditionalAndOp) {\n+                                block.op(conditionalBranch(p, nextPred.successor(), exit.successor(p)));\n+                            } else {\n+                                block.op(conditionalBranch(p, exit.successor(p), nextPred.successor()));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                }\n+\n+                Body fromPred = bodies.get(i);\n+                if (i == 0) {\n+                    startBlock.transformBody(fromPred, List.of(), opt);\n+                } else {\n+                    pred = startBlock.block(fromPred.bodyType().parameterTypes());\n+                    pred.transformBody(fromPred, pred.parameters(), opT.andThen(opt));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and operation, that can model Java language conditional-and expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaConditionalAndOp.NAME)\n+    public static final class JavaConditionalAndOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                and(lhs);\n+                and(rhs);\n+            }\n+\n+            public Builder and(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalAndOp build() {\n+                return new JavaConditionalAndOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cand\";\n+\n+        public JavaConditionalAndOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalAndOp(JavaConditionalAndOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalAndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalAndOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalAndOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-or operation, that can model Java language conditional-or expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaConditionalOrOp.NAME)\n+    public static final class JavaConditionalOrOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                or(lhs);\n+                or(rhs);\n+            }\n+\n+            public Builder or(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalOrOp build() {\n+                return new JavaConditionalOrOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cor\";\n+\n+        public JavaConditionalOrOp(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalOrOp(JavaConditionalOrOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalOrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalOrOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalOrOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional operation, that can model Java language conditional operator {@code ?} expressions.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaConditionalExpressionOp.NAME)\n+    public static final class JavaConditionalExpressionOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaExpression {\n+\n+        public static final String NAME = \"java.cexpression\";\n+\n+        final TypeElement resultType;\n+        \/\/ {cond, truepart, falsepart}\n+        final List<Body> bodies;\n+\n+        public JavaConditionalExpressionOp(ExternalizedOp def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaConditionalExpressionOp(JavaConditionalExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaConditionalExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalExpressionOp(TypeElement expressionType, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            \/\/ @@@ when expressionType is null, we assume truepart and falsepart have the same yieldType\n+            this.resultType = expressionType == null ? bodies.get(1).yieldType() : expressionType;\n+\n+            if (bodies.size() < 3) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+\n+            Body cond = bodies.get(0);\n+            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block(resultType());\n+            exit.context().mapValue(result(), exit.parameters().get(0));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            List<Block.Builder> builders = List.of(b.block(), b.block());\n+            b.transformBody(bodies.get(0), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            builders.get(0).successor(), builders.get(1).successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            for (int i = 0; i < 2; i++) {\n+                builders.get(i).transformBody(bodies.get(i + 1), List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The try operation, that can model Java language try statements.\n+     *\/\n+    @OpFactory.OpDeclaration(JavaTryOp.NAME)\n+    public static final class JavaTryOp extends JavaOp\n+            implements Op.Nested, Op.Lowerable, JavaStatement {\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> resourceTypes;\n+            final Body.Builder resources;\n+\n+            BodyBuilder(Body.Builder ancestorBody, List<? extends TypeElement> resourceTypes, Body.Builder resources) {\n+                this.ancestorBody = ancestorBody;\n+                this.resourceTypes = resourceTypes;\n+                this.resources = resources;\n+            }\n+\n+            public CatchBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, resourceTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new CatchBuilder(ancestorBody, resources, body);\n+            }\n+        }\n+\n+        public static final class CatchBuilder {\n+            final Body.Builder ancestorBody;\n+            final Body.Builder resources;\n+            final Body.Builder body;\n+            final List<Body.Builder> catchers;\n+\n+            CatchBuilder(Body.Builder ancestorBody, Body.Builder resources, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.resources = resources;\n+                this.body = body;\n+                this.catchers = new ArrayList<>();\n+            }\n+\n+            \/\/ @@@ multi-catch\n+            public CatchBuilder _catch(TypeElement exceptionType, Consumer<Block.Builder> c) {\n+                Body.Builder _catch = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, exceptionType));\n+                c.accept(_catch.entryBlock());\n+                catchers.add(_catch);\n+\n+                return this;\n+            }\n+\n+            public JavaTryOp _finally(Consumer<Block.Builder> c) {\n+                Body.Builder _finally = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(_finally.entryBlock());\n+\n+                return new JavaTryOp(resources, body, catchers, _finally);\n+            }\n+\n+            public JavaTryOp noFinalizer() {\n+                return new JavaTryOp(resources, body, catchers, null);\n+            }\n+        }\n+\n+        static final String NAME = \"java.try\";\n+\n+        final Body resources;\n+        final Body body;\n+        final List<Body> catchers;\n+        final Body finalizer;\n+\n+        public static JavaTryOp create(ExternalizedOp def) {\n+            return new JavaTryOp(def);\n+        }\n+\n+        public JavaTryOp(ExternalizedOp def) {\n+            super(def);\n+\n+            List<Body> bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n+            Body first = bodies.get(0);\n+            if (first.bodyType().returnType().equals(VOID)) {\n+                this.resources = null;\n+                this.body = first;\n+            } else {\n+                this.resources = first;\n+                this.body = bodies.get(1);\n+            }\n+\n+            Body last = bodies.get(bodies.size() - 1);\n+            if (last.bodyType().parameterTypes().isEmpty()) {\n+                this.finalizer = last;\n+            } else {\n+                this.finalizer = null;\n+            }\n+            this.catchers = bodies.subList(\n+                    resources == null ? 1 : 2,\n+                    bodies.size() - (finalizer == null ? 0 : 1));\n+        }\n+\n+        JavaTryOp(JavaTryOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            if (that.resources != null) {\n+                this.resources = that.resources.transform(cc, ot).build(this);\n+            } else {\n+                this.resources = null;\n+            }\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.catchers = that.catchers.stream()\n+                    .map(b -> b.transform(cc, ot).build(this))\n+                    .toList();\n+            if (that.finalizer != null) {\n+                this.finalizer = that.finalizer.transform(cc, ot).build(this);\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public JavaTryOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaTryOp(this, cc, ot);\n+        }\n+\n+        JavaTryOp(Body.Builder resourcesC,\n+                  Body.Builder bodyC,\n+                  List<Body.Builder> catchersC,\n+                  Body.Builder finalizerC) {\n+            super(NAME, List.of());\n+\n+            if (resourcesC != null) {\n+                this.resources = resourcesC.build(this);\n+                if (resources.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.bodyType());\n+                }\n+                if (!resources.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.bodyType());\n+                }\n+            } else {\n+                this.resources = null;\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Try should return void: \" + body.bodyType());\n+            }\n+\n+            this.catchers = catchersC.stream().map(c -> c.build(this)).toList();\n+            for (Body _catch : catchers) {\n+                if (!_catch.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.bodyType());\n+                }\n+                if (_catch.bodyType().parameterTypes().size() != 1) {\n+                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.bodyType());\n+                }\n+            }\n+\n+            if (finalizerC != null) {\n+                this.finalizer = finalizerC.build(this);\n+                if (!finalizer.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.bodyType());\n+                }\n+                if (!finalizer.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.bodyType());\n+                }\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            ArrayList<Body> bodies = new ArrayList<>();\n+            if (resources != null) {\n+                bodies.add(resources);\n+            }\n+            bodies.add(body);\n+            bodies.addAll(catchers);\n+            if (finalizer != null) {\n+                bodies.add(finalizer);\n+            }\n+            return bodies;\n+        }\n+\n+        public Body resources() {\n+            return resources;\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public List<Body> catchers() {\n+            return catchers;\n+        }\n+\n+        public Body finalizer() {\n+            return finalizer;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            if (resources != null) {\n+                throw new UnsupportedOperationException(\"Lowering of try-with-resources is unsupported\");\n+            }\n+\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Simple case with no catch and finally bodies\n+            if (catchers.isEmpty() && finalizer == null) {\n+                b.transformBody(body, List.of(), (block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                });\n+                return exit;\n+            }\n+\n+            Block.Builder tryRegionEnter = b.block();\n+            Block.Builder tryRegionExit = b.block();\n+\n+            \/\/ Construct the catcher block builders\n+            List<Block.Builder> catchers = catchers().stream()\n+                    .map(catcher -> b.block())\n+                    .toList();\n+            Block.Builder catcherFinally;\n+            if (finalizer == null) {\n+                catcherFinally = null;\n+            } else {\n+                catcherFinally = b.block();\n+                catchers = new ArrayList<>(catchers);\n+                catchers.add(catcherFinally);\n+            }\n+\n+            \/\/ Enter the try exception region\n+            List<Block.Reference> exitHandlers = catchers.stream()\n+                    .map(Block.Builder::successor)\n+                    .toList();\n+            b.op(exceptionRegionEnter(tryRegionEnter.successor(), exitHandlers.reversed()));\n+\n+            OpTransformer tryExitTransformer;\n+            if (finalizer != null) {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    if (op instanceof CoreOp.ReturnOp ||\n+                            (op instanceof JavaOp.JavaLabelOp lop && ifExitFromTry(lop))) {\n+                        return inlineFinalizer(block, exitHandlers, opT);\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            } else {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    if (op instanceof CoreOp.ReturnOp ||\n+                            (op instanceof JavaOp.JavaLabelOp lop && ifExitFromTry(lop))) {\n+                        Block.Builder tryRegionReturnExit = block.block();\n+                        block.op(exceptionRegionExit(tryRegionReturnExit.successor(), exitHandlers));\n+                        return tryRegionReturnExit;\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            }\n+            \/\/ Inline the try body\n+            AtomicBoolean hasTryRegionExit = new AtomicBoolean();\n+            tryRegionEnter.transformBody(body, List.of(), tryExitTransformer.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    hasTryRegionExit.set(true);\n+                    block.op(branch(tryRegionExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, tryExitTransformer);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            Block.Builder finallyEnter = null;\n+            if (finalizer != null) {\n+                finallyEnter = b.block();\n+                if (hasTryRegionExit.get()) {\n+                    \/\/ Exit the try exception region\n+                    tryRegionExit.op(exceptionRegionExit(finallyEnter.successor(), exitHandlers));\n+                }\n+            } else if (hasTryRegionExit.get()) {\n+                \/\/ Exit the try exception region\n+                tryRegionExit.op(exceptionRegionExit(exit.successor(), exitHandlers));\n+            }\n+\n+            \/\/ Inline the catch bodies\n+            for (int i = 0; i < this.catchers.size(); i++) {\n+                Block.Builder catcher = catchers.get(i);\n+                Body catcherBody = this.catchers.get(i);\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcher.parameter(catcherBody.bodyType().parameterTypes().get(0));\n+\n+                if (finalizer != null) {\n+                    Block.Builder catchRegionEnter = b.block();\n+                    Block.Builder catchRegionExit = b.block();\n+\n+                    \/\/ Enter the catch exception region\n+                    Result catchExceptionRegion = catcher.op(\n+                            exceptionRegionEnter(catchRegionEnter.successor(), catcherFinally.successor()));\n+\n+                    OpTransformer catchExitTransformer = opT.compose((block, op) -> {\n+                        if (op instanceof CoreOp.ReturnOp) {\n+                            return inlineFinalizer(block, List.of(catcherFinally.successor()), opT);\n+                        } else if (op instanceof JavaOp.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                            return inlineFinalizer(block, List.of(catcherFinally.successor()), opT);\n+                        } else {\n+                            return block;\n+                        }\n+                    });\n+                    \/\/ Inline the catch body\n+                    AtomicBoolean hasCatchRegionExit = new AtomicBoolean();\n+                    catchRegionEnter.transformBody(catcherBody, List.of(t), catchExitTransformer.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            hasCatchRegionExit.set(true);\n+                            block.op(branch(catchRegionExit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, catchExitTransformer);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+\n+                    \/\/ Exit the catch exception region\n+                    if (hasCatchRegionExit.get()) {\n+                        hasTryRegionExit.set(true);\n+                        catchRegionExit.op(exceptionRegionExit(finallyEnter.successor(), catcherFinally.successor()));\n+                    }\n+                } else {\n+                    \/\/ Inline the catch body\n+                    catcher.transformBody(catcherBody, List.of(t), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            block.op(branch(exit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, opT);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            if (finalizer != null && hasTryRegionExit.get()) {\n+                \/\/ Inline the finally body\n+                finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            \/\/ Inline the finally body as a catcher of Throwable and adjusting to throw\n+            if (finalizer != null) {\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n+\n+                catcherFinally.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(_throw(t));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+            return exit;\n+        }\n+\n+        boolean ifExitFromTry(JavaLabelOp lop) {\n+            Op target = lop.target();\n+            return target == this || ifAncestorOp(target, this);\n+        }\n+\n+        static boolean ifAncestorOp(Op ancestor, Op op) {\n+            while (op.ancestorBody() != null) {\n+                op = op.ancestorBody().parentOp();\n+                if (op == ancestor) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        Block.Builder inlineFinalizer(Block.Builder block1, List<Block.Reference> tryHandlers, OpTransformer opT) {\n+            Block.Builder finallyEnter = block1.block();\n+            Block.Builder finallyExit = block1.block();\n+\n+            block1.op(exceptionRegionExit(finallyEnter.successor(), tryHandlers));\n+\n+            \/\/ Inline the finally body\n+            finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block2, op2) -> {\n+                if (op2 instanceof YieldOp) {\n+                    block2.op(branch(finallyExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op2 instanceof Lowerable lop2) {\n+                        block2 = lop2.lower(block2, opT);\n+                    } else {\n+                        block2.op(op2);\n+                    }\n+                }\n+                return block2;\n+            }));\n+\n+            return finallyExit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    static final String Pattern_CLASS_NAME = JavaOp_CLASS_NAME + \"$\" + Pattern.class.getSimpleName();\n+\n+    \/\/ Reified pattern nodes\n+\n+    \/**\n+     * Synthetic pattern types\n+     * \/\/ @@@ Replace with types extending from TypeElement\n+     *\/\n+    public sealed interface Pattern {\n+\n+        \/**\n+         * Synthetic type pattern type.\n+         *\n+         * @param <T> the type of values that are bound\n+         *\/\n+        final class Type<T> implements Pattern {\n+            Type() {\n+            }\n+        }\n+\n+        \/**\n+         * Synthetic record pattern type.\n+         *\n+         * @param <T> the type of records that are bound\n+         *\/\n+        final class Record<T> implements Pattern {\n+            Record() {\n+            }\n+        }\n+\n+        final class MatchAll implements Pattern {\n+            MatchAll() {\n+            }\n+        }\n+\n+        \/\/ @@@ Pattern types\n+\n+        JavaType PATTERN_BINDING_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Type.class.getSimpleName()));\n+        JavaType PATTERN_RECORD_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Pattern.Record.class.getSimpleName()));\n+\n+        JavaType PATTERN_MATCH_ALL_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Pattern.MatchAll.class.getSimpleName()));\n+\n+        static JavaType bindingType(TypeElement t) {\n+            return parameterized(PATTERN_BINDING_TYPE, (JavaType) t);\n+        }\n+\n+        static JavaType recordType(TypeElement t) {\n+            return parameterized(PATTERN_RECORD_TYPE, (JavaType) t);\n+        }\n+\n+        static JavaType matchAllType() {\n+            return PATTERN_MATCH_ALL_TYPE;\n+        }\n+\n+        static TypeElement targetType(TypeElement t) {\n+            return ((ClassType) t).typeArguments().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * Pattern operations.\n+     *\/\n+    public static final class PatternOps {\n+        PatternOps() {\n+        }\n+\n+        \/**\n+         * The pattern operation.\n+         *\/\n+        public sealed static abstract class PatternOp extends JavaOp implements Op.Pure {\n+            PatternOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            PatternOp(PatternOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            PatternOp(String name, List<Value> operands) {\n+                super(name, operands);\n+            }\n+        }\n+\n+        \/**\n+         * The binding pattern operation, that can model Java language type patterns.\n+         *\/\n+        @OpFactory.OpDeclaration(TypePatternOp.NAME)\n+        public static final class TypePatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.type\";\n+\n+            public static final String ATTRIBUTE_BINDING_NAME = NAME + \".binding.name\";\n+\n+            final TypeElement resultType;\n+            final String bindingName;\n+\n+            public static TypePatternOp create(ExternalizedOp def) {\n+                String name = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n+                        v -> switch (v) {\n+                            case String s -> s;\n+                            case null -> null;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported pattern binding name value:\" + v);\n+                        });\n+                return new TypePatternOp(def, name);\n+            }\n+\n+            TypePatternOp(ExternalizedOp def, String bindingName) {\n+                super(def);\n+\n+                this.bindingName = bindingName;\n+                this.resultType = def.resultType();\n+            }\n+\n+            TypePatternOp(TypePatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.bindingName = that.bindingName;\n+                this.resultType = that.resultType;\n+            }\n+\n+            @Override\n+            public TypePatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new TypePatternOp(this, cc);\n+            }\n+\n+            TypePatternOp(TypeElement targetType, String bindingName) {\n+                super(NAME, List.of());\n+\n+                this.bindingName = bindingName;\n+                this.resultType = Pattern.bindingType(targetType);\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+                if (bindingName != null) {\n+                    attrs.put(\"\", bindingName);\n+                }\n+                return attrs;\n+            }\n+\n+            public String bindingName() {\n+                return bindingName;\n+            }\n+\n+            public TypeElement targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return resultType;\n+            }\n+        }\n+\n+        \/**\n+         * The record pattern operation, that can model Java language record patterns.\n+         *\/\n+        @OpFactory.OpDeclaration(RecordPatternOp.NAME)\n+        public static final class RecordPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.record\";\n+\n+            public static final String ATTRIBUTE_RECORD_DESCRIPTOR = NAME + \".descriptor\";\n+\n+            final RecordTypeRef recordDescriptor;\n+\n+            public static RecordPatternOp create(ExternalizedOp def) {\n+                RecordTypeRef recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n+                            case RecordTypeRef rtd -> rtd;\n+                            case null, default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported record type descriptor value:\" + v);\n+                        });\n+\n+                return new RecordPatternOp(def, recordDescriptor);\n+            }\n+\n+            RecordPatternOp(ExternalizedOp def, RecordTypeRef recordDescriptor) {\n+                super(def);\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            RecordPatternOp(RecordPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.recordDescriptor = that.recordDescriptor;\n+            }\n+\n+            @Override\n+            public RecordPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new RecordPatternOp(this, cc);\n+            }\n+\n+            RecordPatternOp(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n+                \/\/ The type of each value is a subtype of Pattern\n+                \/\/ The number of values corresponds to the number of components of the record\n+                super(NAME, List.copyOf(nestedPatterns));\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> m = new HashMap<>(super.attributes());\n+                m.put(\"\", recordDescriptor);\n+                return Collections.unmodifiableMap(m);\n+            }\n+\n+            public RecordTypeRef recordDescriptor() {\n+                return recordDescriptor;\n+            }\n+\n+            public TypeElement targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return Pattern.recordType(recordDescriptor.recordType());\n+            }\n+        }\n+\n+        @OpFactory.OpDeclaration(MatchAllPatternOp.NAME)\n+        public static final class MatchAllPatternOp extends PatternOp {\n+\n+            \/\/ @@@ we may need to add info about the type of the record component\n+            \/\/ this info can be used when lowering\n+\n+            public static final String NAME = \"pattern.match.all\";\n+\n+            public MatchAllPatternOp(ExternalizedOp def) {\n+                super(def);\n+            }\n+\n+            MatchAllPatternOp(MatchAllPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            MatchAllPatternOp() {\n+                super(NAME, List.of());\n+            }\n+\n+            @Override\n+            public Op transform(CopyContext cc, OpTransformer ot) {\n+                return new MatchAllPatternOp(this, cc);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return Pattern.matchAllType();\n+            }\n+        }\n+\n+        \/**\n+         * The match operation, that can model Java language pattern matching.\n+         *\/\n+        @OpFactory.OpDeclaration(MatchOp.NAME)\n+        public static final class MatchOp extends JavaOp implements Op.Isolated, Op.Lowerable {\n+            public static final String NAME = \"pattern.match\";\n+\n+            final Body pattern;\n+            final Body match;\n+\n+            public MatchOp(ExternalizedOp def) {\n+                super(def);\n+\n+                this.pattern = def.bodyDefinitions().get(0).build(this);\n+                this.match = def.bodyDefinitions().get(1).build(this);\n+            }\n+\n+            MatchOp(MatchOp that, CopyContext cc, OpTransformer ot) {\n+                super(that, cc);\n+\n+                this.pattern = that.pattern.transform(cc, ot).build(this);\n+                this.match = that.match.transform(cc, ot).build(this);\n+            }\n+\n+            @Override\n+            public MatchOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MatchOp(this, cc, ot);\n+            }\n+\n+            MatchOp(Value target, Body.Builder patternC, Body.Builder matchC) {\n+                super(NAME,\n+                        List.of(target));\n+\n+                this.pattern = patternC.build(this);\n+                this.match = matchC.build(this);\n+            }\n+\n+            @Override\n+            public List<Body> bodies() {\n+                return List.of(pattern, match);\n+            }\n+\n+            public Body pattern() {\n+                return pattern;\n+            }\n+\n+            public Body match() {\n+                return match;\n+            }\n+\n+            public Value target() {\n+                return operands().get(0);\n+            }\n+\n+            @Override\n+            public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+                \/\/ No match block\n+                Block.Builder endNoMatchBlock = b.block();\n+                \/\/ Match block\n+                Block.Builder endMatchBlock = b.block();\n+                \/\/ End block\n+                Block.Builder endBlock = b.block();\n+                Block.Parameter matchResult = endBlock.parameter(resultType());\n+                \/\/ Map match operation result\n+                b.context().mapValue(result(), matchResult);\n+\n+                List<Value> patternValues = new ArrayList<>();\n+                Op patternYieldOp = pattern.entryBlock().terminatingOp();\n+                Op.Result rootPatternValue = (Op.Result) patternYieldOp.operands().get(0);\n+                Block.Builder currentBlock = lower(endNoMatchBlock, b,\n+                        patternValues,\n+                        rootPatternValue.op(),\n+                        b.context().getValue(target()));\n+                currentBlock.op(branch(endMatchBlock.successor()));\n+\n+                \/\/ No match block\n+                \/\/ Pass false\n+                endNoMatchBlock.op(branch(endBlock.successor(\n+                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n+\n+                \/\/ Match block\n+                \/\/ Lower match body and pass true\n+                endMatchBlock.transformBody(match, patternValues, opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(endBlock.successor(\n+                                block.op(constant(BOOLEAN, true)))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                return endBlock;\n+            }\n+\n+            static Block.Builder lower(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       Op pattern, Value target) {\n+                return switch (pattern) {\n+                    case RecordPatternOp rp -> lowerRecordPattern(endNoMatchBlock, currentBlock, bindings, rp, target);\n+                    case TypePatternOp tp -> lowerTypePattern(endNoMatchBlock, currentBlock, bindings, tp, target);\n+                    case MatchAllPatternOp map -> lowerMatchAllPattern(currentBlock);\n+                    case null, default -> throw new UnsupportedOperationException(\"Unknown pattern op: \" + pattern);\n+                };\n+            }\n+\n+            static Block.Builder lowerRecordPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                                    List<Value> bindings,\n+                                                    JavaOp.PatternOps.RecordPatternOp rpOp, Value target) {\n+                TypeElement targetType = rpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                Op.Result isInstance = currentBlock.op(instanceOf(targetType, target));\n+                currentBlock.op(conditionalBranch(isInstance, nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(cast(targetType, target));\n+\n+                \/\/ Access component values of record and match on each as nested target\n+                List<Value> dArgs = rpOp.operands();\n+                for (int i = 0; i < dArgs.size(); i++) {\n+                    Op.Result nestedPattern = (Op.Result) dArgs.get(i);\n+                    \/\/ @@@ Handle exceptions?\n+                    Value nestedTarget = currentBlock.op(invoke(rpOp.recordDescriptor().methodForComponent(i), target));\n+\n+                    currentBlock = lower(endNoMatchBlock, currentBlock, bindings, nestedPattern.op(), nestedTarget);\n+                }\n+\n+                return currentBlock;\n+            }\n+\n+            static Block.Builder lowerTypePattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                                  List<Value> bindings,\n+                                                  TypePatternOp tpOp, Value target) {\n+                TypeElement targetType = tpOp.targetType();\n+\n+                \/\/ Check if instance of target type\n+                Op p; \/\/ op that perform type check\n+                Op c; \/\/ op that perform conversion\n+                TypeElement s = target.type();\n+                TypeElement t = targetType;\n+                if (t instanceof PrimitiveType pt) {\n+                    if (s instanceof ClassType cs) {\n+                        \/\/ unboxing conversions\n+                        ClassType box;\n+                        if (cs.unbox().isEmpty()) { \/\/ s not a boxed type\n+                            \/\/ e.g. Number -> int, narrowing + unboxing\n+                            box = pt.box().orElseThrow();\n+                            p = instanceOf(box, target);\n+                        } else {\n+                            \/\/ e.g. Float -> float, unboxing\n+                            \/\/ e.g. Integer -> long, unboxing + widening\n+                            box = cs;\n+                            p = null;\n+                        }\n+                        c = invoke(MethodRef.method(box, t + \"Value\", t), target);\n+                    } else {\n+                        \/\/ primitive to primitive conversion\n+                        PrimitiveType ps = ((PrimitiveType) s);\n+                        if (isNarrowingPrimitiveConv(ps, pt) || isWideningPrimitiveConvWithCheck(ps, pt)\n+                                || isWideningAndNarrowingPrimitiveConv(ps, pt)) {\n+                            \/\/ e.g. int -> byte, narrowing\n+                            \/\/ e,g. int -> float, widening with check\n+                            \/\/ e.g. byte -> char, widening and narrowing\n+                            MethodRef mref = convMethodRef(s, t);\n+                            p = invoke(mref, target);\n+                        } else {\n+                            p = null;\n+                        }\n+                        c = conv(targetType, target);\n+                    }\n+                } else if (s instanceof PrimitiveType ps) {\n+                    \/\/ boxing conversions\n+                    \/\/ e.g. int -> Number, boxing + widening\n+                    \/\/ e.g. byte -> Byte, boxing\n+                    p = null;\n+                    ClassType box = ps.box().orElseThrow();\n+                    c = invoke(MethodRef.method(box, \"valueOf\", box, ps), target);\n+                } else if (!s.equals(t)) {\n+                    \/\/ reference to reference, but not identity\n+                    \/\/ e.g. Number -> Double, narrowing\n+                    \/\/ e.g. Short -> Object, widening\n+                    p = instanceOf(targetType, target);\n+                    c = cast(targetType, target);\n+                } else {\n+                    \/\/ identity reference\n+                    \/\/ e.g. Character -> Character\n+                    p = null;\n+                    c = null;\n+                }\n+\n+                if (c != null) {\n+                    if (p != null) {\n+                        \/\/ p != null, we need to perform type check at runtime\n+                        Block.Builder nextBlock = currentBlock.block();\n+                        currentBlock.op(conditionalBranch(currentBlock.op(p), nextBlock.successor(), endNoMatchBlock.successor()));\n+                        currentBlock = nextBlock;\n+                    }\n+                    target = currentBlock.op(c);\n+                }\n+\n+                bindings.add(target);\n+\n+                return currentBlock;\n+            }\n+\n+            private static boolean isWideningAndNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n+                return BYTE.equals(s) && CHAR.equals(t);\n+            }\n+\n+            private static boolean isWideningPrimitiveConvWithCheck(PrimitiveType s, PrimitiveType t) {\n+                return (INT.equals(s) && FLOAT.equals(t))\n+                        || (LONG.equals(s) && FLOAT.equals(t))\n+                        || (LONG.equals(s) && DOUBLE.equals(t));\n+            }\n+\n+            \/\/ s -> t is narrowing if order(t) <= order(s)\n+            private final static Map<PrimitiveType, Integer> narrowingOrder = Map.of(\n+                    BYTE, 1,\n+                    SHORT, 2,\n+                    CHAR, 2,\n+                    INT, 3,\n+                    LONG, 4,\n+                    FLOAT, 5,\n+                    DOUBLE, 6\n+            );\n+            private static boolean isNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n+                return narrowingOrder.get(t) <= narrowingOrder.get(s);\n+            }\n+\n+            private static MethodRef convMethodRef(TypeElement s, TypeElement t) {\n+                if (BYTE.equals(s) || SHORT.equals(s) || CHAR.equals(s)) {\n+                    s = INT;\n+                }\n+                String sn = capitalize(s.toString());\n+                String tn = capitalize(t.toString());\n+                String mn = \"is%sTo%sExact\".formatted(sn, tn);\n+                JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                return MethodRef.method(exactConversionSupport, mn, BOOLEAN, s);\n+            }\n+\n+            private static String capitalize(String s) {\n+                return s.substring(0, 1).toUpperCase() + s.substring(1);\n+            }\n+\n+            static Block.Builder lowerMatchAllPattern(Block.Builder currentBlock) {\n+                return currentBlock;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return BOOLEAN;\n+            }\n+        }\n+    }\n+\n+\n+    \/**\n+     * A factory for extended and core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = CoreOp.FACTORY.andThen(OpFactory.OP_FACTORY.get(JavaOp.class));\n+\n+\n+    \/**\n+     * Creates a lambda operation.\n+     *\n+     * @param ancestorBody        the ancestor of the body of the lambda operation\n+     * @param funcType            the lambda operation's function type\n+     * @param functionalInterface the lambda operation's functional interface type\n+     * @return the lambda operation\n+     *\/\n+    public static LambdaOp.Builder lambda(Body.Builder ancestorBody,\n+                                          FunctionType funcType, TypeElement functionalInterface) {\n+        return new LambdaOp.Builder(ancestorBody, funcType, functionalInterface);\n+    }\n+\n+    \/**\n+     * Creates a lambda operation.\n+     *\n+     * @param functionalInterface the lambda operation's functional interface type\n+     * @param body                the body of the lambda operation\n+     * @return the lambda operation\n+     *\/\n+    public static LambdaOp lambda(TypeElement functionalInterface, Body.Builder body) {\n+        return new LambdaOp(functionalInterface, body);\n+    }\n+\n+    \/**\n+     * Creates an exception region enter operation\n+     *\n+     * @param start    the exception region block\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region enter operation\n+     *\/\n+    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, Block.Reference... catchers) {\n+        return exceptionRegionEnter(start, List.of(catchers));\n+    }\n+\n+    \/**\n+     * Creates an exception region enter operation\n+     *\n+     * @param start    the exception region block\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region enter operation\n+     *\/\n+    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, List<Block.Reference> catchers) {\n+        List<Block.Reference> s = new ArrayList<>();\n+        s.add(start);\n+        s.addAll(catchers);\n+        return new ExceptionRegionEnter(s);\n+    }\n+\n+    \/**\n+     * Creates an exception region exit operation\n+     *\n+     * @param end             the block to which control is transferred after the exception region is exited\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region exit operation\n+     *\/\n+    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, Block.Reference... catchers) {\n+        return exceptionRegionExit(end, List.of(catchers));\n+    }\n+\n+    \/**\n+     * Creates an exception region exit operation\n+     *\n+     * @param end             the block to which control is transferred after the exception region is exited\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region exit operation\n+     *\/\n+    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, List<Block.Reference> catchers) {\n+        List<Block.Reference> s = new ArrayList<>();\n+        s.add(end);\n+        s.addAll(catchers);\n+        return new ExceptionRegionExit(s);\n+    }\n+\n+    \/**\n+     * Creates a throw operation.\n+     *\n+     * @param exceptionValue the thrown value\n+     * @return the throw operation\n+     *\/\n+    public static ThrowOp _throw(Value exceptionValue) {\n+        return new ThrowOp(exceptionValue);\n+    }\n+\n+    \/**\n+     * Creates an assert operation.\n+     *\n+     * @param bodies the nested bodies\n+     * @return the assert operation\n+     *\/\n+    public static AssertOp _assert(List<Body.Builder> bodies) {\n+        return new AssertOp(bodies);\n+    }\n+\n+    public static MonitorOp.MonitorEnterOp monitorEnter(Value monitor) {\n+        return new MonitorOp.MonitorEnterOp(monitor);\n+    }\n+\n+    public static MonitorOp.MonitorExitOp monitorExit(Value monitor) {\n+        return new MonitorOp.MonitorExitOp(monitor);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * <p>\n+     * The invoke return type is the invoke descriptors return type.\n+     *\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(MethodRef invokeDescriptor, Value... args) {\n+        return invoke(invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * <p>\n+     * The invoke return type is the invoke descriptors return type.\n+     *\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(MethodRef invokeDescriptor, List<Value> args) {\n+        return invoke(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     *\n+     * @param returnType       the invoke return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, Value... args) {\n+        return invoke(returnType, invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     *\n+     * @param returnType       the invoke return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n+     * @return the invoke super operation\n+     *\/\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        int paramCount = invokeDescriptor.type().parameterTypes().size();\n+        int argCount = args.size();\n+        InvokeOp.InvokeKind ik = (argCount == paramCount + 1)\n+                ? InvokeOp.InvokeKind.INSTANCE\n+                : InvokeOp.InvokeKind.STATIC;\n+        return new InvokeOp(ik, false, returnType, invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation modelling an invocation to a method.\n+     *\n+     * @param invokeKind       the invoke kind\n+     * @param isVarArgs        true if an invocation to a variable argument method\n+     * @param returnType       the return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n+     * @return the invoke operation\n+     * @throws IllegalArgumentException if there is a mismatch between the argument count\n+     *                                  and the invoke descriptors parameter count.\n+     *\/\n+    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n+                                  TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates a conversion operation.\n+     *\n+     * @param to   the conversion target type\n+     * @param from the value to be converted\n+     * @return the conversion operation\n+     *\/\n+    public static ConvOp conv(TypeElement to, Value from) {\n+        return new ConvOp(to, from);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(ConstructorRef constructorDescriptor, Value... args) {\n+        return _new(constructorDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(ConstructorRef constructorDescriptor, List<Value> args) {\n+        return new NewOp(false, constructorDescriptor.refType(), constructorDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n+                             Value... args) {\n+        return _new(returnType, constructorDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n+                             List<Value> args) {\n+        return new NewOp(false, returnType, constructorDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(boolean isVarargs, TypeElement returnType, ConstructorRef constructorDescriptor,\n+                             List<Value> args) {\n+        return new NewOp(isVarargs, returnType, constructorDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an array creation operation.\n+     *\n+     * @param arrayType the array type\n+     * @param length    the array size\n+     * @return the array creation operation\n+     *\/\n+    public static NewOp newArray(TypeElement arrayType, Value length) {\n+        ConstructorRef constructorDescriptor = ConstructorRef.constructor(arrayType, INT);\n+        return _new(constructorDescriptor, length);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a non-static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param receiver   the receiver value\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor, Value receiver) {\n+        return new FieldAccessOp.FieldLoadOp(descriptor.type(), descriptor, receiver);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a non-static field.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param descriptor the field descriptor\n+     * @param receiver   the receiver value\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor, Value receiver) {\n+        return new FieldAccessOp.FieldLoadOp(resultType, descriptor, receiver);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor) {\n+        return new FieldAccessOp.FieldLoadOp(descriptor.type(), descriptor);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param descriptor the field descriptor\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor) {\n+        return new FieldAccessOp.FieldLoadOp(resultType, descriptor);\n+    }\n+\n+    \/**\n+     * Creates a field store operation to a non-static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param receiver   the receiver value\n+     * @param v          the value to store\n+     * @return the field store operation\n+     *\/\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value receiver, Value v) {\n+        return new FieldAccessOp.FieldStoreOp(descriptor, receiver, v);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param v          the value to store\n+     * @return the field store operation\n+     *\/\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value v) {\n+        return new FieldAccessOp.FieldStoreOp(descriptor, v);\n+    }\n+\n+    \/**\n+     * Creates an array length operation.\n+     *\n+     * @param array the array value\n+     * @return the array length operation\n+     *\/\n+    public static ArrayLengthOp arrayLength(Value array) {\n+        return new ArrayLengthOp(array);\n+    }\n+\n+    \/**\n+     * Creates an array load operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @return the array load operation\n+     *\/\n+    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index) {\n+        return new ArrayAccessOp.ArrayLoadOp(array, index);\n+    }\n+\n+    \/**\n+     * Creates an array load operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @param componentType type of the array component\n+     * @return the array load operation\n+     *\/\n+    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index, TypeElement componentType) {\n+        return new ArrayAccessOp.ArrayLoadOp(array, index, componentType);\n+    }\n+\n+    \/**\n+     * Creates an array store operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @param v     the value to store\n+     * @return the array store operation\n+     *\/\n+    public static ArrayAccessOp.ArrayStoreOp arrayStoreOp(Value array, Value index, Value v) {\n+        return new ArrayAccessOp.ArrayStoreOp(array, index, v);\n+    }\n+\n+    \/**\n+     * Creates an instanceof operation.\n+     *\n+     * @param t the type to test against\n+     * @param v the value to test\n+     * @return the instanceof operation\n+     *\/\n+    public static InstanceOfOp instanceOf(TypeElement t, Value v) {\n+        return new InstanceOfOp(t, v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param v          the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeElement resultType, Value v) {\n+        return new CastOp(resultType, resultType, v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param t          the type to cast to\n+     * @param v          the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeElement resultType, JavaType t, Value v) {\n+        return new CastOp(resultType, t, v);\n+    }\n+\n+    \/**\n+     * Creates an add operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the add operation\n+     *\/\n+    public static BinaryOp add(Value lhs, Value rhs) {\n+        return new AddOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a sub operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the sub operation\n+     *\/\n+    public static BinaryOp sub(Value lhs, Value rhs) {\n+        return new SubOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mul operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mul operation\n+     *\/\n+    public static BinaryOp mul(Value lhs, Value rhs) {\n+        return new MulOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a div operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the div operation\n+     *\/\n+    public static BinaryOp div(Value lhs, Value rhs) {\n+        return new DivOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mod operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mod operation\n+     *\/\n+    public static BinaryOp mod(Value lhs, Value rhs) {\n+        return new ModOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical or operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the or operation\n+     *\/\n+    public static BinaryOp or(Value lhs, Value rhs) {\n+        return new OrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical and operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the and operation\n+     *\/\n+    public static BinaryOp and(Value lhs, Value rhs) {\n+        return new AndOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical xor operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp xor(Value lhs, Value rhs) {\n+        return new XorOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a left shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp lshl(Value lhs, Value rhs) {\n+        return new LshlOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a right shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp ashr(Value lhs, Value rhs) {\n+        return new AshrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates an unsigned right shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp lshr(Value lhs, Value rhs) {\n+        return new LshrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a neg operation.\n+     *\n+     * @param v the operand\n+     * @return the neg operation\n+     *\/\n+    public static UnaryOp neg(Value v) {\n+        return new NegOp(v);\n+    }\n+\n+    \/**\n+     * Creates a bitwise complement operation.\n+     *\n+     * @param v the operand\n+     * @return the bitwise complement operation\n+     *\/\n+    public static UnaryOp compl(Value v) {\n+        return new ComplOp(v);\n+    }\n+\n+    \/**\n+     * Creates a not operation.\n+     *\n+     * @param v the operand\n+     * @return the not operation\n+     *\/\n+    public static UnaryOp not(Value v) {\n+        return new NotOp(v);\n+    }\n+\n+    \/**\n+     * Creates an equals comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the equals comparison operation\n+     *\/\n+    public static BinaryTestOp eq(Value lhs, Value rhs) {\n+        return new EqOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a not equals comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the not equals comparison operation\n+     *\/\n+    public static BinaryTestOp neq(Value lhs, Value rhs) {\n+        return new NeqOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a greater than comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the greater than comparison operation\n+     *\/\n+    public static BinaryTestOp gt(Value lhs, Value rhs) {\n+        return new GtOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a greater than or equals to comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the greater than or equals to comparison operation\n+     *\/\n+    public static BinaryTestOp ge(Value lhs, Value rhs) {\n+        return new GeOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a less than comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the less than comparison operation\n+     *\/\n+    public static BinaryTestOp lt(Value lhs, Value rhs) {\n+        return new LtOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a less than or equals to comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the less than or equals to comparison operation\n+     *\/\n+    public static BinaryTestOp le(Value lhs, Value rhs) {\n+        return new LeOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a string concatenation operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the string concatenation operation\n+     *\/\n+    public static ConcatOp concat(Value lhs, Value rhs) {\n+        return new ConcatOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a continue operation.\n+     *\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue() {\n+        return _continue(null);\n+    }\n+\n+    \/**\n+     * Creates a continue operation.\n+     *\n+     * @param label the value associated with where to continue from\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue(Value label) {\n+        return new JavaContinueOp(label);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     *\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break() {\n+        return _break(null);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     *\n+     * @param label the value associated with where to continue from\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break(Value label) {\n+        return new JavaBreakOp(label);\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     *\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield() {\n+        return new JavaYieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     *\n+     * @param operand the value to yield\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield(Value operand) {\n+        return new JavaYieldOp(operand);\n+    }\n+\n+    \/**\n+     * Creates a block operation.\n+     *\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaBlockOp block(Body.Builder body) {\n+        return new JavaBlockOp(body);\n+    }\n+\n+    \/**\n+     * Creates a synchronized operation.\n+     *\n+     * @param expr the expression body builder of the operation to be built and become its child\n+     * @param blockBody the block body builder of the operation to be built and become its child\n+     * @return the synchronized operation\n+     *\/\n+    public static JavaSynchronizedOp synchronized_(Body.Builder expr, Body.Builder blockBody) {\n+        return new JavaSynchronizedOp(expr, blockBody);\n+    }\n+\n+    \/**\n+     * Creates a labeled operation.\n+     *\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaLabeledOp labeled(Body.Builder body) {\n+        return new JavaLabeledOp(body);\n+    }\n+\n+    \/**\n+     * Creates an if operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @return the if operation builder\n+     *\/\n+    public static JavaIfOp.IfBuilder _if(Body.Builder ancestorBody) {\n+        return new JavaIfOp.IfBuilder(ancestorBody);\n+    }\n+\n+    \/\/ Pairs of\n+    \/\/   predicate ()boolean, body ()void\n+    \/\/ And one optional body ()void at the end\n+\n+    \/**\n+     * Creates an if operation.\n+     *\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the if operation\n+     *\/\n+    public static JavaIfOp _if(List<Body.Builder> bodies) {\n+        return new JavaIfOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     * <p>\n+     * The result type of the operation will be derived from the yield type of the second body\n+     *\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchExpressionOp(null, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     *\n+     * @param resultType the result type of the expression\n+     * @param target     the switch target value\n+     * @param bodies     the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(TypeElement resultType, Value target,\n+                                                          List<Body.Builder> bodies) {\n+        Objects.requireNonNull(resultType);\n+        return new JavaSwitchExpressionOp(resultType, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch statement operation.\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch statement operation\n+     *\/\n+    public static JavaSwitchStatementOp switchStatement(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchStatementOp(target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch fallthrough operation.\n+     *\n+     * @return the switch fallthrough operation\n+     *\/\n+    public static JavaSwitchFallthroughOp switchFallthroughOp() {\n+        return new JavaSwitchFallthroughOp();\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param initTypes    the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeElement... initTypes) {\n+        return _for(ancestorBody, List.of(initTypes));\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param initTypes    the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<? extends TypeElement> initTypes) {\n+        return new JavaForOp.InitBuilder(ancestorBody, initTypes);\n+    }\n+\n+\n+    \/**\n+     * Creates a for operation.\n+     *\n+     * @param init   the init body builder of the operation to be built and become its child\n+     * @param cond   the cond body builder of the operation to be built and become its child\n+     * @param update the update body builder of the operation to be built and become its child\n+     * @param body   the main body builder of the operation to be built and become its child\n+     * @return the for operation\n+     *\/\n+    \/\/ init ()Tuple<Var<T1>, Var<T2>, ..., Var<TN>>, or init ()void\n+    \/\/ cond (Var<T1>, Var<T2>, ..., Var<TN>)boolean\n+    \/\/ update (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    \/\/ body (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    public static JavaForOp _for(Body.Builder init,\n+                                 Body.Builder cond,\n+                                 Body.Builder update,\n+                                 Body.Builder body) {\n+        return new JavaForOp(init, cond, update, body);\n+    }\n+\n+    \/**\n+     * Creates an enhanced for operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param iterableType the iterable type\n+     * @param elementType  the element type\n+     * @return the enhanced for operation builder\n+     *\/\n+    public static JavaEnhancedForOp.ExpressionBuilder enhancedFor(Body.Builder ancestorBody,\n+                                                                  TypeElement iterableType, TypeElement elementType) {\n+        return new JavaEnhancedForOp.ExpressionBuilder(ancestorBody, iterableType, elementType);\n+    }\n+\n+    \/\/ expression ()I<E>\n+    \/\/ init (E )Var<T>\n+    \/\/ body (Var<T> )void\n+\n+    \/**\n+     * Creates an enhanced for operation.\n+     *\n+     * @param expression the expression body builder of the operation to be built and become its child\n+     * @param init       the init body builder of the operation to be built and become its child\n+     * @param body       the main body builder of the operation to be built and become its child\n+     * @return the enhanced for operation\n+     *\/\n+    public static JavaEnhancedForOp enhancedFor(Body.Builder expression,\n+                                                Body.Builder init,\n+                                                Body.Builder body) {\n+        return new JavaEnhancedForOp(expression, init, body);\n+    }\n+\n+    \/**\n+     * Creates a while operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @return the while operation builder\n+     *\/\n+    public static JavaWhileOp.PredicateBuilder _while(Body.Builder ancestorBody) {\n+        return new JavaWhileOp.PredicateBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a while operation.\n+     *\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body      the main body builder of the operation to be built and become its child\n+     * @return the while operation\n+     *\/\n+    \/\/ predicate, ()boolean, may be null for predicate returning true\n+    \/\/ body, ()void\n+    public static JavaWhileOp _while(Body.Builder predicate, Body.Builder body) {\n+        return new JavaWhileOp(predicate, body);\n+    }\n+\n+    \/**\n+     * Creates a do operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @return the do operation builder\n+     *\/\n+    public static JavaDoWhileOp.BodyBuilder doWhile(Body.Builder ancestorBody) {\n+        return new JavaDoWhileOp.BodyBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a do operation.\n+     *\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body      the main body builder of the operation to be built and become its child\n+     * @return the do operation\n+     *\/\n+    public static JavaDoWhileOp doWhile(Body.Builder body, Body.Builder predicate) {\n+        return new JavaDoWhileOp(body, predicate);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param lhs          a consumer that builds the left-hand side body\n+     * @param rhs          a consumer that builds the right-hand side body\n+     * @return the conditional-and operation builder\n+     *\/\n+    public static JavaConditionalAndOp.Builder conditionalAnd(Body.Builder ancestorBody,\n+                                                              Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalAndOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param lhs          a consumer that builds the left-hand side body\n+     * @param rhs          a consumer that builds the right-hand side body\n+     * @return the conditional-or operation builder\n+     *\/\n+    public static JavaConditionalOrOp.Builder conditionalOr(Body.Builder ancestorBody,\n+                                                            Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalOrOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation\n+     *\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-and operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalAndOp conditionalAnd(List<Body.Builder> bodies) {\n+        return new JavaConditionalAndOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation\n+     *\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-or operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalOrOp conditionalOr(List<Body.Builder> bodies) {\n+        return new JavaConditionalOrOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     *\n+     * @param expressionType the result type of the expression\n+     * @param bodies         the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(TypeElement expressionType,\n+                                                                    List<Body.Builder> bodies) {\n+        Objects.requireNonNull(expressionType);\n+        return new JavaConditionalExpressionOp(expressionType, bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     * <p>\n+     * The result type of the operation will be derived from the yield type of the second body\n+     *\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(List<Body.Builder> bodies) {\n+        return new JavaConditionalExpressionOp(null, bodies);\n+    }\n+\n+    \/**\n+     * Creates try operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param c            a consumer that builds the try body\n+     * @return the try operation builder\n+     *\/\n+    public static JavaTryOp.CatchBuilder _try(Body.Builder ancestorBody, Consumer<Block.Builder> c) {\n+        Body.Builder _try = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        c.accept(_try.entryBlock());\n+        return new JavaTryOp.CatchBuilder(ancestorBody, null, _try);\n+    }\n+\n+    \/**\n+     * Creates try-with-resources operation builder.\n+     *\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                     body builders for this operation\n+     * @param c            a consumer that builds the resources body\n+     * @return the try-with-resources operation builder\n+     *\/\n+    public static JavaTryOp.BodyBuilder tryWithResources(Body.Builder ancestorBody,\n+                                                         List<? extends TypeElement> resourceTypes,\n+                                                         Consumer<Block.Builder> c) {\n+        resourceTypes = resourceTypes.stream().map(VarType::varType).toList();\n+        Body.Builder resources = Body.Builder.of(ancestorBody,\n+                FunctionType.functionType(TupleType.tupleType(resourceTypes)));\n+        c.accept(resources.entryBlock());\n+        return new JavaTryOp.BodyBuilder(ancestorBody, resourceTypes, resources);\n+    }\n+\n+    \/\/ resources ()Tuple<Var<R1>, Var<R2>, ..., Var<RN>>, or null\n+    \/\/ try (Var<R1>, Var<R2>, ..., Var<RN>)void, or try ()void\n+    \/\/ catch (E )void, where E <: Throwable\n+    \/\/ finally ()void, or null\n+\n+    \/**\n+     * Creates a try or try-with-resources operation.\n+     *\n+     * @param resources the try body builder of the operation to be built and become its child,\n+     *                  may be null\n+     * @param body      the try body builder of the operation to be built and become its child\n+     * @param catchers  the catch body builders of the operation to be built and become its children\n+     * @param finalizer the finalizer body builder of the operation to be built and become its child\n+     * @return the try or try-with-resources operation\n+     *\/\n+    public static JavaTryOp _try(Body.Builder resources,\n+                                 Body.Builder body,\n+                                 List<Body.Builder> catchers,\n+                                 Body.Builder finalizer) {\n+        return new JavaTryOp(resources, body, catchers, finalizer);\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    \/**\n+     * Creates a pattern match operation.\n+     *\n+     * @param target  the target value\n+     * @param pattern the pattern body builder of the operation to be built and become its child\n+     * @param match   the match body builder of the operation to be built and become its child\n+     * @return the pattern match operation\n+     *\/\n+    public static PatternOps.MatchOp match(Value target,\n+                                           Body.Builder pattern, Body.Builder match) {\n+        return new PatternOps.MatchOp(target, pattern, match);\n+    }\n+\n+    \/**\n+     * Creates a pattern binding operation.\n+     *\n+     * @param type        the type of value to be bound\n+     * @param bindingName the binding name\n+     * @return the pattern binding operation\n+     *\/\n+    public static PatternOps.TypePatternOp typePattern(TypeElement type, String bindingName) {\n+        return new PatternOps.TypePatternOp(type, bindingName);\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     *\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns   the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, Value... nestedPatterns) {\n+        return recordPattern(recordDescriptor, List.of(nestedPatterns));\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     *\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns   the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n+        return new PatternOps.RecordPatternOp(recordDescriptor, nestedPatterns);\n+    }\n+\n+    public static PatternOps.MatchAllPatternOp matchAllPattern() {\n+        return new PatternOps.MatchAllPatternOp();\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":6427,"deletions":0,"binary":false,"changes":6427,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -5,2 +5,0 @@\n-import java.util.List;\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaRef.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/JavaRef.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -35,1 +35,1 @@\n-import jdk.incubator.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.dialect.java.WildcardType.BoundKind;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/JavaType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -30,2 +30,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.impl.MethodRefImpl;\n+\n+import jdk.incubator.code.dialect.java.impl.MethodRefImpl;\n@@ -37,0 +37,2 @@\n+import jdk.incubator.code.dialect.core.FunctionType;\n+\n@@ -39,1 +41,1 @@\n-import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n@@ -61,1 +63,1 @@\n-    Method resolveToMethod(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n+    Method resolveToMethod(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n@@ -64,1 +66,1 @@\n-    MethodHandle resolveToHandle(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/MethodRef.java","additions":8,"deletions":6,"binary":false,"changes":14,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/MethodRef.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/PrimitiveType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/PrimitiveType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.impl.RecordTypeRefImpl;\n+import jdk.incubator.code.dialect.java.impl.RecordTypeRefImpl;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/RecordTypeRef.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/RecordTypeRef.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -29,1 +29,1 @@\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/TypeVariableType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TypeVariableType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type;\n+package jdk.incubator.code.dialect.java;\n@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/WildcardType.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/WildcardType.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type.impl;\n+package jdk.incubator.code.dialect.java.impl;\n@@ -29,5 +29,5 @@\n-import jdk.incubator.code.type.ArrayType;\n-import jdk.incubator.code.type.ConstructorRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ConstructorRef;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/ConstructorRefImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/ConstructorRefImpl.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type.impl;\n+package jdk.incubator.code.dialect.java.impl;\n@@ -28,1 +28,1 @@\n-import jdk.incubator.code.type.FieldRef;\n+import jdk.incubator.code.dialect.java.FieldRef;\n@@ -33,1 +33,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/FieldRefImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/FieldRefImpl.java","status":"renamed"},{"patch":"@@ -1,1 +1,1 @@\n-package jdk.incubator.code.type.impl;\n+package jdk.incubator.code.dialect.java.impl;\n@@ -5,0 +5,1 @@\n+import jdk.incubator.code.dialect.java.*;\n@@ -8,3 +9,2 @@\n-import jdk.incubator.code.type.*;\n-import jdk.incubator.code.type.RecordTypeRef.ComponentRef;\n-import jdk.incubator.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.dialect.java.RecordTypeRef.ComponentRef;\n+import jdk.incubator.code.dialect.java.WildcardType.BoundKind;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/JavaTypeUtils.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/JavaTypeUtils.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type.impl;\n+package jdk.incubator.code.dialect.java.impl;\n@@ -28,2 +28,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -35,2 +35,2 @@\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -80,2 +80,2 @@\n-        for (CoreOp.InvokeOp.InvokeKind ik :\n-                List.of(CoreOp.InvokeOp.InvokeKind.STATIC, CoreOp.InvokeOp.InvokeKind.INSTANCE)) {\n+        for (JavaOp.InvokeOp.InvokeKind ik :\n+                List.of(JavaOp.InvokeOp.InvokeKind.STATIC, JavaOp.InvokeOp.InvokeKind.INSTANCE)) {\n@@ -98,1 +98,1 @@\n-    public Method resolveToMethod(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n+    public Method resolveToMethod(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n@@ -104,1 +104,1 @@\n-    public MethodHandle resolveToHandle(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n+    public MethodHandle resolveToHandle(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n@@ -120,1 +120,1 @@\n-    HandleResult resolveToHandleResult(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n+    HandleResult resolveToHandleResult(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/MethodRefImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/MethodRefImpl.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.incubator.code.type.impl;\n+package jdk.incubator.code.dialect.java.impl;\n@@ -28,2 +28,2 @@\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.RecordTypeRef;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.RecordTypeRef;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/RecordTypeRefImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/RecordTypeRefImpl.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n- * Types and symbolic references for code models.\n+ * The java dialect.\n@@ -29,1 +29,1 @@\n-package jdk.incubator.code.type;\n\\ No newline at end of file\n+package jdk.incubator.code.dialect.java;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/package-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for dialects, operations and types, declared in code models that can represent program functionality.\n+ *\/\n+package jdk.incubator.code.dialect;\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -16,2 +16,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -81,2 +82,2 @@\n-    private JCTree invokeOpToJCMethodInvocation(CoreOp.InvokeOp invokeOp) {\n-        Value receiver = (invokeOp.invokeKind() == CoreOp.InvokeOp.InvokeKind.INSTANCE) ?\n+    private JCTree invokeOpToJCMethodInvocation(JavaOp.InvokeOp invokeOp) {\n+        Value receiver = (invokeOp.invokeKind() == JavaOp.InvokeOp.InvokeKind.INSTANCE) ?\n@@ -125,1 +126,1 @@\n-                case CoreOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n+                case JavaOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n@@ -127,1 +128,1 @@\n-                case CoreOp.ReturnOp _, CoreOp.ArrayAccessOp.ArrayStoreOp _ -> true;\n+                case CoreOp.ReturnOp _, JavaOp.ArrayAccessOp.ArrayStoreOp _ -> true;\n@@ -165,2 +166,2 @@\n-            case CoreOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n-            case CoreOp.NewOp newOp when newOp.resultType() instanceof ArrayType at -> {\n+            case JavaOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n+            case JavaOp.NewOp newOp when newOp.resultType() instanceof ArrayType at -> {\n@@ -176,1 +177,1 @@\n-            case CoreOp.NewOp newOp -> {\n+            case JavaOp.NewOp newOp -> {\n@@ -194,1 +195,1 @@\n-            case CoreOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n+            case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n@@ -199,1 +200,1 @@\n-            case CoreOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+            case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    public final Type extendedOpType;\n+    public final Type javaOpType;\n@@ -56,1 +56,1 @@\n-    public final Symbol.VarSymbol extendedOpFactorySym;\n+    public final Symbol.VarSymbol javaOpFactorySym;\n@@ -68,1 +68,1 @@\n-        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.op.CoreOp$FuncOp\");\n+        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n@@ -87,6 +87,6 @@\n-        opFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.op.OpFactory\");\n-        typeElementFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.type.TypeElementFactory\");\n-        extendedOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.op.ExtendedOp\");\n-        coreTypeFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.type.CoreTypeFactory\");\n-        extendedOpFactorySym = new Symbol.VarSymbol(PUBLIC | STATIC, names.fromString(\"FACTORY\"), opFactoryType,\n-                extendedOpType.tsym);\n+        opFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.OpFactory\");\n+        typeElementFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.TypeElementFactory\");\n+        javaOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.java.JavaOp\");\n+        coreTypeFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreTypeFactory\");\n+        javaOpFactorySym = new Symbol.VarSymbol(PUBLIC | STATIC, names.fromString(\"FACTORY\"), opFactoryType,\n+                javaOpType.tsym);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import jdk.incubator.code.op.CoreOp.FuncOp;\n-import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Flags;\n@@ -91,4 +90,6 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.*;\n-import jdk.incubator.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.TupleType;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.*;\n+import jdk.incubator.code.dialect.java.WildcardType.BoundKind;\n@@ -277,2 +278,2 @@\n-                        JCFieldAccess opFactory = make.Select(make.Ident(crSyms.extendedOpType.tsym),\n-                                crSyms.extendedOpFactorySym);\n+                        JCFieldAccess opFactory = make.Select(make.Ident(crSyms.javaOpType.tsym),\n+                                crSyms.javaOpFactorySym);\n@@ -816,1 +817,1 @@\n-                return append(CoreOp.cast(typeToTypeElement(targetType), sourceValue));\n+                return append(JavaOp.cast(typeToTypeElement(targetType), sourceValue));\n@@ -845,1 +846,1 @@\n-                    return append(CoreOp.conv(typeToTypeElement(target), exprVal));\n+                    return append(JavaOp.conv(typeToTypeElement(target), exprVal));\n@@ -870,1 +871,1 @@\n-            return append(CoreOp.invoke(boxMethod, valueExpr));\n+            return append(JavaOp.invoke(boxMethod, valueExpr));\n@@ -878,1 +879,1 @@\n-                valueExpr = append(CoreOp.cast(typeToTypeElement(box), valueExpr));\n+                valueExpr = append(JavaOp.cast(typeToTypeElement(box), valueExpr));\n@@ -884,1 +885,1 @@\n-            return append(CoreOp.invoke(unboxMethod, valueExpr));\n+            return append(JavaOp.invoke(unboxMethod, valueExpr));\n@@ -927,1 +928,1 @@\n-                                append(CoreOp.fieldStore(fd, result));\n+                                append(JavaOp.fieldStore(fd, result));\n@@ -929,1 +930,1 @@\n-                                append(CoreOp.fieldStore(fd, thisValue(), result));\n+                                append(JavaOp.fieldStore(fd, thisValue(), result));\n@@ -950,1 +951,1 @@\n-                        append(CoreOp.fieldStore(fr, result));\n+                        append(JavaOp.fieldStore(fr, result));\n@@ -952,1 +953,1 @@\n-                        append(CoreOp.fieldStore(fr, receiver, result));\n+                        append(JavaOp.fieldStore(fr, receiver, result));\n@@ -965,1 +966,1 @@\n-                    append(CoreOp.arrayStoreOp(array, index, result));\n+                    append(JavaOp.arrayStoreOp(array, index, result));\n@@ -991,1 +992,1 @@\n-                            yield append(CoreOp.concat(lhs, rhs));\n+                            yield append(JavaOp.concat(lhs, rhs));\n@@ -993,1 +994,1 @@\n-                            yield append(CoreOp.add(lhs, rhs));\n+                            yield append(JavaOp.add(lhs, rhs));\n@@ -996,4 +997,4 @@\n-                    case MINUS_ASG -> append(CoreOp.sub(lhs, rhs));\n-                    case MUL_ASG -> append(CoreOp.mul(lhs, rhs));\n-                    case DIV_ASG -> append(CoreOp.div(lhs, rhs));\n-                    case MOD_ASG -> append(CoreOp.mod(lhs, rhs));\n+                    case MINUS_ASG -> append(JavaOp.sub(lhs, rhs));\n+                    case MUL_ASG -> append(JavaOp.mul(lhs, rhs));\n+                    case DIV_ASG -> append(JavaOp.div(lhs, rhs));\n+                    case MOD_ASG -> append(JavaOp.mod(lhs, rhs));\n@@ -1002,3 +1003,3 @@\n-                    case BITOR_ASG -> append(CoreOp.or(lhs, rhs));\n-                    case BITAND_ASG -> append(CoreOp.and(lhs, rhs));\n-                    case BITXOR_ASG -> append(CoreOp.xor(lhs, rhs));\n+                    case BITOR_ASG -> append(JavaOp.or(lhs, rhs));\n+                    case BITAND_ASG -> append(JavaOp.and(lhs, rhs));\n+                    case BITXOR_ASG -> append(JavaOp.xor(lhs, rhs));\n@@ -1007,3 +1008,3 @@\n-                    case SL_ASG -> append(CoreOp.lshl(lhs, rhs));\n-                    case SR_ASG -> append(CoreOp.ashr(lhs, rhs));\n-                    case USR_ASG -> append(CoreOp.lshr(lhs, rhs));\n+                    case SL_ASG -> append(JavaOp.lshl(lhs, rhs));\n+                    case SR_ASG -> append(JavaOp.ashr(lhs, rhs));\n+                    case USR_ASG -> append(JavaOp.lshr(lhs, rhs));\n@@ -1044,1 +1045,1 @@\n-                                lhsOpValue = append(CoreOp.fieldLoad(resultType, fr));\n+                                lhsOpValue = append(JavaOp.fieldLoad(resultType, fr));\n@@ -1046,1 +1047,1 @@\n-                                lhsOpValue = append(CoreOp.fieldLoad(resultType, fr, thisValue()));\n+                                lhsOpValue = append(JavaOp.fieldLoad(resultType, fr, thisValue()));\n@@ -1052,1 +1053,1 @@\n-                                append(CoreOp.fieldStore(fr, r));\n+                                append(JavaOp.fieldStore(fr, r));\n@@ -1054,1 +1055,1 @@\n-                                append(CoreOp.fieldStore(fr, thisValue(), r));\n+                                append(JavaOp.fieldStore(fr, thisValue(), r));\n@@ -1074,1 +1075,1 @@\n-                        lhsOpValue = append(CoreOp.fieldLoad(resultType, fr));\n+                        lhsOpValue = append(JavaOp.fieldLoad(resultType, fr));\n@@ -1076,1 +1077,1 @@\n-                        lhsOpValue = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                        lhsOpValue = append(JavaOp.fieldLoad(resultType, fr, receiver));\n@@ -1082,1 +1083,1 @@\n-                        append(CoreOp.fieldStore(fr, r));\n+                        append(JavaOp.fieldStore(fr, r));\n@@ -1084,1 +1085,1 @@\n-                        append(CoreOp.fieldStore(fr, receiver, r));\n+                        append(JavaOp.fieldStore(fr, receiver, r));\n@@ -1093,1 +1094,1 @@\n-                    Op.Result lhsOpValue = append(CoreOp.arrayLoadOp(array, index));\n+                    Op.Result lhsOpValue = append(JavaOp.arrayLoadOp(array, index));\n@@ -1097,1 +1098,1 @@\n-                    append(CoreOp.arrayStoreOp(array, index, r));\n+                    append(JavaOp.arrayStoreOp(array, index, r));\n@@ -1118,1 +1119,1 @@\n-                            result = append(CoreOp.fieldLoad(resultType, fr));\n+                            result = append(JavaOp.fieldLoad(resultType, fr));\n@@ -1120,1 +1121,1 @@\n-                            result = append(CoreOp.fieldLoad(resultType, fr, thisValue()));\n+                            result = append(JavaOp.fieldLoad(resultType, fr, thisValue()));\n@@ -1163,1 +1164,1 @@\n-                    result = append(CoreOp.arrayLength(receiver));\n+                    result = append(JavaOp.arrayLength(receiver));\n@@ -1179,1 +1180,1 @@\n-                                result = append(CoreOp.fieldLoad(resultType, fr));\n+                                result = append(JavaOp.fieldLoad(resultType, fr));\n@@ -1181,1 +1182,1 @@\n-                                result = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                                result = append(JavaOp.fieldLoad(resultType, fr, receiver));\n@@ -1204,1 +1205,1 @@\n-            result = append(CoreOp.arrayLoadOp(array, index));\n+            result = append(JavaOp.arrayLoadOp(array, index));\n@@ -1220,1 +1221,1 @@\n-                    CoreOp.InvokeOp.InvokeKind ik;\n+                    JavaOp.InvokeOp.InvokeKind ik;\n@@ -1222,1 +1223,1 @@\n-                        ik = CoreOp.InvokeOp.InvokeKind.INSTANCE;\n+                        ik = JavaOp.InvokeOp.InvokeKind.INSTANCE;\n@@ -1225,1 +1226,1 @@\n-                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n+                        ik = JavaOp.InvokeOp.InvokeKind.STATIC;\n@@ -1231,1 +1232,1 @@\n-                    Value res = append(CoreOp.invoke(ik, tree.varargsElement != null,\n+                    Value res = append(JavaOp.invoke(ik, tree.varargsElement != null,\n@@ -1246,1 +1247,1 @@\n-                    CoreOp.InvokeOp.InvokeKind ik;\n+                    JavaOp.InvokeOp.InvokeKind ik;\n@@ -1251,3 +1252,3 @@\n-                            case JCIdent i when i.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n-                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n-                            default -> CoreOp.InvokeOp.InvokeKind.INSTANCE;\n+                            case JCIdent i when i.sym.name.equals(names._super) -> JavaOp.InvokeOp.InvokeKind.SUPER;\n+                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> JavaOp.InvokeOp.InvokeKind.SUPER;\n+                            default -> JavaOp.InvokeOp.InvokeKind.INSTANCE;\n@@ -1256,1 +1257,1 @@\n-                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n+                        ik = JavaOp.InvokeOp.InvokeKind.STATIC;\n@@ -1264,1 +1265,1 @@\n-                    CoreOp.InvokeOp iop = CoreOp.invoke(ik, tree.varargsElement != null,\n+                    JavaOp.InvokeOp iop = JavaOp.invoke(ik, tree.varargsElement != null,\n@@ -1323,1 +1324,1 @@\n-                    result = append(CoreOp.conv(typeToTypeElement(type), v));\n+                    result = append(JavaOp.conv(typeToTypeElement(type), v));\n@@ -1334,1 +1335,1 @@\n-                result = append(CoreOp.cast(typeToTypeElement(type), jt, v));\n+                result = append(JavaOp.cast(typeToTypeElement(type), jt, v));\n@@ -1345,1 +1346,1 @@\n-                result = append(CoreOp.instanceOf(typeToTypeElement(tree.pattern.type), target));\n+                result = append(JavaOp.instanceOf(typeToTypeElement(tree.pattern.type), target));\n@@ -1353,1 +1354,1 @@\n-                patternType = ExtendedOp.Pattern.bindingType(typeToTypeElement(p.type));\n+                patternType = JavaOp.Pattern.bindingType(typeToTypeElement(p.type));\n@@ -1355,1 +1356,1 @@\n-                patternType = ExtendedOp.Pattern.recordType(typeToTypeElement(p.record.type));\n+                patternType = JavaOp.Pattern.recordType(typeToTypeElement(p.record.type));\n@@ -1380,1 +1381,1 @@\n-                    result = append(ExtendedOp.typePattern(typeToTypeElement(var.type), bindingName));\n+                    result = append(JavaOp.typePattern(typeToTypeElement(var.type), bindingName));\n@@ -1395,1 +1396,1 @@\n-                    result = append(ExtendedOp.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n+                    result = append(JavaOp.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n@@ -1400,1 +1401,1 @@\n-                    result = append(ExtendedOp.matchAllPattern());\n+                    result = append(JavaOp.matchAllPattern());\n@@ -1450,1 +1451,1 @@\n-            return append(ExtendedOp.match(target, patternBody, matchBody));\n+            return append(JavaOp.match(target, patternBody, matchBody));\n@@ -1501,1 +1502,1 @@\n-            result = append(CoreOp._new(tree.varargsElement != null, typeToTypeElement(type), constructorRef, args));\n+            result = append(JavaOp._new(tree.varargsElement != null, typeToTypeElement(type), constructorRef, args));\n@@ -1508,1 +1509,1 @@\n-                Op.Result a = append(CoreOp.newArray(\n+                Op.Result a = append(JavaOp.newArray(\n@@ -1514,1 +1515,1 @@\n-                    append(CoreOp.arrayStoreOp(\n+                    append(JavaOp.arrayStoreOp(\n@@ -1531,1 +1532,1 @@\n-                result = append(CoreOp._new(constructorRef, indexes));\n+                result = append(JavaOp._new(constructorRef, indexes));\n@@ -1589,1 +1590,1 @@\n-                    yield CoreOp.lambda(fiType, stack.body);\n+                    yield JavaOp.lambda(fiType, stack.body);\n@@ -1665,1 +1666,1 @@\n-            append(ExtendedOp._if(bodies));\n+            append(JavaOp._if(bodies));\n@@ -1679,1 +1680,1 @@\n-            result = append(ExtendedOp.switchExpression(caseBodyType.returnType(), target, bodies));\n+            result = append(JavaOp.switchExpression(caseBodyType.returnType(), target, bodies));\n@@ -1691,1 +1692,1 @@\n-            result = append(ExtendedOp.switchStatement(target, bodies));\n+            result = append(JavaOp.switchStatement(target, bodies));\n@@ -1726,2 +1727,2 @@\n-                append(CoreOp._throw(\n-                        append(CoreOp._new(ConstructorRef.constructor(MatchException.class)))\n+                append(JavaOp._throw(\n+                        append(JavaOp._new(ConstructorRef.constructor(MatchException.class)))\n@@ -1764,1 +1765,1 @@\n-                    localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                    localResult = append(JavaOp.conditionalAnd(clBodies));\n@@ -1785,1 +1786,1 @@\n-                        localResult = append(CoreOp.eq(localTarget, expr));\n+                        localResult = append(JavaOp.eq(localTarget, expr));\n@@ -1787,1 +1788,1 @@\n-                        localResult = append(CoreOp.invoke(\n+                        localResult = append(JavaOp.invoke(\n@@ -1801,1 +1802,1 @@\n-                            labelResult = append(CoreOp.eq(localTarget, expr));\n+                            labelResult = append(JavaOp.eq(localTarget, expr));\n@@ -1803,1 +1804,1 @@\n-                            labelResult = append(CoreOp.invoke(\n+                            labelResult = append(JavaOp.invoke(\n@@ -1815,1 +1816,1 @@\n-                    localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                    localResult = append(JavaOp.conditionalOr(clBodies));\n@@ -1875,1 +1876,1 @@\n-                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : JavaOp::switchFallthroughOp\n@@ -1891,1 +1892,1 @@\n-                result = append(ExtendedOp.java_yield());\n+                result = append(JavaOp.java_yield());\n@@ -1893,1 +1894,1 @@\n-                result = append(ExtendedOp.java_yield(retVal));\n+                result = append(JavaOp.java_yield(retVal));\n@@ -1916,1 +1917,1 @@\n-            appendTerminating(ExtendedOp::_continue);\n+            appendTerminating(JavaOp::_continue);\n@@ -1922,1 +1923,1 @@\n-            append(ExtendedOp._while(condition, body));\n+            append(JavaOp._while(condition, body));\n@@ -1934,1 +1935,1 @@\n-            appendTerminating(ExtendedOp::_continue);\n+            appendTerminating(JavaOp::_continue);\n@@ -1951,1 +1952,1 @@\n-            append(ExtendedOp.doWhile(body, condition));\n+            append(JavaOp.doWhile(body, condition));\n@@ -1986,1 +1987,1 @@\n-            appendTerminating(ExtendedOp::_continue);\n+            appendTerminating(JavaOp::_continue);\n@@ -1991,1 +1992,1 @@\n-            append(ExtendedOp.enhancedFor(expression, init, body));\n+            append(JavaOp.enhancedFor(expression, init, body));\n@@ -2094,1 +2095,1 @@\n-            appendTerminating(ExtendedOp::_continue);\n+            appendTerminating(JavaOp::_continue);\n@@ -2100,1 +2101,1 @@\n-            append(ExtendedOp._for(init, cond, update, body));\n+            append(JavaOp._for(init, cond, update, body));\n@@ -2151,1 +2152,1 @@\n-            result = append(ExtendedOp.conditionalExpression(typeToTypeElement(condType), bodies));\n+            result = append(JavaOp.conditionalExpression(typeToTypeElement(condType), bodies));\n@@ -2201,1 +2202,1 @@\n-            result = append(CoreOp._assert(bodies));\n+            result = append(JavaOp._assert(bodies));\n@@ -2221,1 +2222,1 @@\n-                append(ExtendedOp.block(body));\n+                append(JavaOp.block(body));\n@@ -2247,1 +2248,1 @@\n-            append(ExtendedOp.synchronized_(expr, blockBody));\n+            append(JavaOp.synchronized_(expr, blockBody));\n@@ -2266,1 +2267,1 @@\n-            result = append(ExtendedOp.labeled(body));\n+            result = append(JavaOp.labeled(body));\n@@ -2356,1 +2357,1 @@\n-            result = append(ExtendedOp._try(resources, body, catchers, finalizer));\n+            result = append(JavaOp._try(resources, body, catchers, finalizer));\n@@ -2372,2 +2373,2 @@\n-                            case POSTINC, PREINC -> append(CoreOp.add(unboxedLhs, one));\n-                            case POSTDEC, PREDEC -> append(CoreOp.sub(unboxedLhs, one));\n+                            case POSTINC, PREINC -> append(JavaOp.add(unboxedLhs, one));\n+                            case POSTDEC, PREDEC -> append(JavaOp.sub(unboxedLhs, one));\n@@ -2393,1 +2394,1 @@\n-                    result = append(CoreOp.neg(rhs));\n+                    result = append(JavaOp.neg(rhs));\n@@ -2397,1 +2398,1 @@\n-                    result = append(CoreOp.not(rhs));\n+                    result = append(JavaOp.not(rhs));\n@@ -2401,1 +2402,1 @@\n-                    result = append(CoreOp.compl(rhs));\n+                    result = append(JavaOp.compl(rhs));\n@@ -2440,2 +2441,2 @@\n-                        ? ExtendedOp.conditionalAnd(bodies)\n-                        : ExtendedOp.conditionalOr(bodies));\n+                        ? JavaOp.conditionalAnd(bodies)\n+                        : JavaOp.conditionalOr(bodies));\n@@ -2450,1 +2451,1 @@\n-                result = append(CoreOp.concat(lhs, rhs));\n+                result = append(JavaOp.concat(lhs, rhs));\n@@ -2461,5 +2462,5 @@\n-                    case PLUS -> append(CoreOp.add(lhs, rhs));\n-                    case MINUS -> append(CoreOp.sub(lhs, rhs));\n-                    case MUL -> append(CoreOp.mul(lhs, rhs));\n-                    case DIV -> append(CoreOp.div(lhs, rhs));\n-                    case MOD -> append(CoreOp.mod(lhs, rhs));\n+                    case PLUS -> append(JavaOp.add(lhs, rhs));\n+                    case MINUS -> append(JavaOp.sub(lhs, rhs));\n+                    case MUL -> append(JavaOp.mul(lhs, rhs));\n+                    case DIV -> append(JavaOp.div(lhs, rhs));\n+                    case MOD -> append(JavaOp.mod(lhs, rhs));\n@@ -2468,2 +2469,2 @@\n-                    case EQ -> append(CoreOp.eq(lhs, rhs));\n-                    case NE -> append(CoreOp.neq(lhs, rhs));\n+                    case EQ -> append(JavaOp.eq(lhs, rhs));\n+                    case NE -> append(JavaOp.neq(lhs, rhs));\n@@ -2471,4 +2472,4 @@\n-                    case LT -> append(CoreOp.lt(lhs, rhs));\n-                    case LE -> append(CoreOp.le(lhs, rhs));\n-                    case GT -> append(CoreOp.gt(lhs, rhs));\n-                    case GE -> append(CoreOp.ge(lhs, rhs));\n+                    case LT -> append(JavaOp.lt(lhs, rhs));\n+                    case LE -> append(JavaOp.le(lhs, rhs));\n+                    case GT -> append(JavaOp.gt(lhs, rhs));\n+                    case GE -> append(JavaOp.ge(lhs, rhs));\n@@ -2477,3 +2478,3 @@\n-                    case BITOR -> append(CoreOp.or(lhs, rhs));\n-                    case BITAND -> append(CoreOp.and(lhs, rhs));\n-                    case BITXOR -> append(CoreOp.xor(lhs, rhs));\n+                    case BITOR -> append(JavaOp.or(lhs, rhs));\n+                    case BITAND -> append(JavaOp.and(lhs, rhs));\n+                    case BITXOR -> append(JavaOp.xor(lhs, rhs));\n@@ -2482,3 +2483,3 @@\n-                    case SL -> append(CoreOp.lshl(lhs, rhs));\n-                    case SR -> append(CoreOp.ashr(lhs, rhs));\n-                    case USR -> append(CoreOp.lshr(lhs, rhs));\n+                    case SL -> append(JavaOp.lshl(lhs, rhs));\n+                    case SR -> append(JavaOp.ashr(lhs, rhs));\n+                    case USR -> append(JavaOp.lshr(lhs, rhs));\n@@ -2515,1 +2516,1 @@\n-            result = append(CoreOp._throw(throwVal));\n+            result = append(JavaOp._throw(throwVal));\n@@ -2523,1 +2524,1 @@\n-            result = append(ExtendedOp._break(label));\n+            result = append(JavaOp._break(label));\n@@ -2531,1 +2532,1 @@\n-            result = append(ExtendedOp._continue(label));\n+            result = append(JavaOp._continue(label));\n@@ -2603,1 +2604,1 @@\n-                                (jdk.incubator.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                                (jdk.incubator.code.dialect.java.ClassType)symbolToErasedDesc(t.tsym.owner),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":127,"deletions":126,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -34,2 +34,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -198,1 +200,1 @@\n-        void popExceptionRegion(CoreOp.ExceptionRegionExit ere) {\n+        void popExceptionRegion(JavaOp.ExceptionRegionExit ere) {\n@@ -352,1 +354,1 @@\n-            } else if (to instanceof CoreOp.ThrowOp _throw) {\n+            } else if (to instanceof JavaOp.ThrowOp _throw) {\n@@ -367,1 +369,1 @@\n-            } else if (to instanceof CoreOp.ExceptionRegionEnter ers) {\n+            } else if (to instanceof JavaOp.ExceptionRegionEnter ers) {\n@@ -375,1 +377,1 @@\n-            } else if (to instanceof CoreOp.ExceptionRegionExit ere) {\n+            } else if (to instanceof JavaOp.ExceptionRegionExit ere) {\n@@ -446,1 +448,1 @@\n-        } else if (o instanceof CoreOp.InvokeOp co) {\n+        } else if (o instanceof JavaOp.InvokeOp co) {\n@@ -457,1 +459,1 @@\n-        } else if (o instanceof CoreOp.NewOp no) {\n+        } else if (o instanceof JavaOp.NewOp no) {\n@@ -465,1 +467,1 @@\n-        } else if (o instanceof CoreOp.LambdaOp lo) {\n+        } else if (o instanceof JavaOp.LambdaOp lo) {\n@@ -535,1 +537,1 @@\n-        } else if (o instanceof CoreOp.FieldAccessOp.FieldLoadOp fo) {\n+        } else if (o instanceof JavaOp.FieldAccessOp.FieldLoadOp fo) {\n@@ -544,1 +546,1 @@\n-        } else if (o instanceof CoreOp.FieldAccessOp.FieldStoreOp fo) {\n+        } else if (o instanceof JavaOp.FieldAccessOp.FieldStoreOp fo) {\n@@ -556,1 +558,1 @@\n-        } else if (o instanceof CoreOp.InstanceOfOp io) {\n+        } else if (o instanceof JavaOp.InstanceOfOp io) {\n@@ -559,1 +561,1 @@\n-        } else if (o instanceof CoreOp.CastOp co) {\n+        } else if (o instanceof JavaOp.CastOp co) {\n@@ -562,1 +564,1 @@\n-        } else if (o instanceof CoreOp.ArrayLengthOp) {\n+        } else if (o instanceof JavaOp.ArrayLengthOp) {\n@@ -565,1 +567,1 @@\n-        } else if (o instanceof CoreOp.ArrayAccessOp.ArrayLoadOp) {\n+        } else if (o instanceof JavaOp.ArrayAccessOp.ArrayLoadOp) {\n@@ -569,1 +571,1 @@\n-        } else if (o instanceof CoreOp.ArrayAccessOp.ArrayStoreOp) {\n+        } else if (o instanceof JavaOp.ArrayAccessOp.ArrayStoreOp) {\n@@ -575,1 +577,1 @@\n-        } else if (o instanceof CoreOp.ArithmeticOperation || o instanceof CoreOp.TestOperation) {\n+        } else if (o instanceof JavaOp.ArithmeticOperation || o instanceof JavaOp.TestOperation) {\n@@ -579,1 +581,1 @@\n-        } else if (o instanceof CoreOp.ConvOp) {\n+        } else if (o instanceof JavaOp.ConvOp) {\n@@ -583,1 +585,1 @@\n-        } else if (o instanceof CoreOp.AssertOp _assert) {\n+        } else if (o instanceof JavaOp.AssertOp _assert) {\n@@ -596,1 +598,1 @@\n-        } else if (o instanceof CoreOp.ConcatOp) {\n+        } else if (o instanceof JavaOp.ConcatOp) {\n@@ -601,1 +603,1 @@\n-        } else if (o instanceof CoreOp.MonitorOp.MonitorEnterOp) {\n+        } else if (o instanceof JavaOp.MonitorOp.MonitorEnterOp) {\n@@ -609,1 +611,1 @@\n-        } else if (o instanceof CoreOp.MonitorOp.MonitorExitOp) {\n+        } else if (o instanceof JavaOp.MonitorOp.MonitorExitOp) {\n@@ -631,1 +633,1 @@\n-                            CoreOp.LambdaOp.class, Object[].class, Object[].class));\n+                            JavaOp.LambdaOp.class, Object[].class, Object[].class));\n@@ -637,1 +639,1 @@\n-    static Object invokeLambda(MethodHandles.Lookup l, CoreOp.LambdaOp op, Object[] capturedArgs, Object[] args) {\n+    static Object invokeLambda(MethodHandles.Lookup l, JavaOp.LambdaOp op, Object[] capturedArgs, Object[] args) {\n@@ -670,1 +672,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, JavaOp.InvokeOp.InvokeKind kind) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -30,2 +30,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -135,1 +136,1 @@\n-                case CoreOp.ArithmeticOperation _, CoreOp.TestOperation _ ->\n+                case JavaOp.ArithmeticOperation _, JavaOp.TestOperation _ ->\n@@ -137,1 +138,1 @@\n-                case CoreOp.ConvOp _ -> {\n+                case JavaOp.ConvOp _ -> {\n@@ -212,1 +213,1 @@\n-                case CoreOp.ExceptionRegionEnter ere -> {\n+                case JavaOp.ExceptionRegionEnter ere -> {\n@@ -221,1 +222,1 @@\n-                case CoreOp.ExceptionRegionExit ere -> {\n+                case JavaOp.ExceptionRegionExit ere -> {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Verifier.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,4397 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.op;\n-\n-import java.lang.constant.ClassDesc;\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.op.CoreOp.InvokeOp.InvokeKind;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.*;\n-import java.util.*;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-\n-\/**\n- * The top-level operation class for the set of enclosed core operations.\n- * <p>\n- * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n- * operations. Such a model represents the same Java program and preserves the program meaning as defined by the\n- * Java Language Specification\n- *\/\n-public sealed abstract class CoreOp extends ExternalizableOp {\n-    \/**\n-     * An operation that models a Java expression\n-     *\/\n-    sealed interface JavaExpression permits\n-            ArithmeticOperation,\n-            ArrayAccessOp.ArrayLoadOp,\n-            ArrayAccessOp.ArrayStoreOp,\n-            ArrayLengthOp,\n-            CastOp,\n-            ConvOp,\n-            ClosureOp,\n-            ConcatOp,\n-            ConstantOp,\n-            FieldAccessOp.FieldLoadOp,\n-            FieldAccessOp.FieldStoreOp,\n-            InstanceOfOp,\n-            InvokeOp,\n-            LambdaOp,\n-            NewOp,\n-            TestOperation,\n-            VarAccessOp.VarLoadOp,\n-            VarAccessOp.VarStoreOp,\n-            ExtendedOp.JavaConditionalExpressionOp,\n-            ExtendedOp.JavaConditionalOp,\n-            ExtendedOp.JavaSwitchExpressionOp {\n-    }\n-\n-    \/**\n-     * An operation that models a Java statement\n-     *\/\n-    sealed interface JavaStatement permits\n-            ArrayAccessOp.ArrayStoreOp,\n-            AssertOp,\n-            FieldAccessOp.FieldStoreOp,\n-            InvokeOp,\n-            NewOp,\n-            ReturnOp,\n-            ThrowOp,\n-            VarAccessOp.VarStoreOp,\n-            VarOp,\n-            ExtendedOp.JavaBlockOp,\n-            ExtendedOp.JavaDoWhileOp,\n-            ExtendedOp.JavaEnhancedForOp,\n-            ExtendedOp.JavaForOp,\n-            ExtendedOp.JavaIfOp,\n-            ExtendedOp.JavaLabelOp,\n-            ExtendedOp.JavaLabeledOp,\n-            ExtendedOp.JavaSynchronizedOp,\n-            ExtendedOp.JavaTryOp,\n-            ExtendedOp.JavaWhileOp,\n-            ExtendedOp.JavaYieldOp,\n-            ExtendedOp.JavaSwitchStatementOp {\n-    }\n-\n-    static final String PACKAGE_NAME = CodeReflection.class.getPackageName();\n-\n-    protected CoreOp(Op that, CopyContext cc) {\n-        super(that, cc);\n-    }\n-\n-    protected CoreOp(String name, List<? extends Value> operands) {\n-        super(name, operands);\n-    }\n-\n-    protected CoreOp(ExternalizedOp def) {\n-        super(def);\n-    }\n-\n-    \/**\n-     * The function operation, that can model a Java method declaration.\n-     *\/\n-    @OpFactory.OpDeclaration(FuncOp.NAME)\n-    public static final class FuncOp extends CoreOp\n-            implements Op.Invokable, Op.Isolated, Op.Lowerable {\n-\n-        public static class Builder {\n-            final Body.Builder ancestorBody;\n-            final String funcName;\n-            final FunctionType funcType;\n-\n-            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n-                this.ancestorBody = ancestorBody;\n-                this.funcName = funcName;\n-                this.funcType = funcType;\n-            }\n-\n-            public FuncOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n-                c.accept(body.entryBlock());\n-                return new FuncOp(funcName, body);\n-            }\n-        }\n-\n-        public static final String NAME = \"func\";\n-        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n-\n-        final String funcName;\n-        final Body body;\n-\n-        public static FuncOp create(ExternalizedOp def) {\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Bad op \" + def.name());\n-            }\n-\n-            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n-                    v -> switch (v) {\n-                        case String s -> s;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n-                    });\n-            return new FuncOp(def, funcName);\n-        }\n-\n-        FuncOp(ExternalizedOp def, String funcName) {\n-            super(def);\n-\n-            this.funcName = funcName;\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-        }\n-\n-        FuncOp(FuncOp that, CopyContext cc, OpTransformer oa) {\n-            this(that, that.funcName, cc, oa);\n-        }\n-\n-        FuncOp(FuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.funcName = funcName;\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n-            return new FuncOp(this, cc, ot);\n-        }\n-\n-        public FuncOp transform(OpTransformer ot) {\n-            return new FuncOp(this, CopyContext.create(), ot);\n-        }\n-\n-        public FuncOp transform(String funcName, OpTransformer ot) {\n-            return new FuncOp(this, funcName, CopyContext.create(), ot);\n-        }\n-\n-        FuncOp(String funcName, Body.Builder bodyBuilder) {\n-            super(NAME,\n-                    List.of());\n-\n-            this.funcName = funcName;\n-            this.body = bodyBuilder.build(this);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", funcName);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        @Override\n-        public FunctionType invokableType() {\n-            return body.bodyType();\n-        }\n-\n-        public String funcName() {\n-            return funcName;\n-        }\n-\n-        @Override\n-        public Body body() {\n-            return body;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n-            \/\/ Isolate body with respect to ancestor transformations\n-            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The function call operation, that models a call to a function, by name, declared in the module op that is also an\n-     * ancestor of this operation.\n-     *\/\n-    \/\/ @@@ stack effects equivalent to the call operation as if the function were a Java method?\n-    @OpFactory.OpDeclaration(FuncCallOp.NAME)\n-    public static final class FuncCallOp extends CoreOp {\n-        public static final String NAME = \"func.call\";\n-        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n-\n-        final String funcName;\n-        final TypeElement resultType;\n-\n-        public static FuncCallOp create(ExternalizedOp def) {\n-            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n-                    v -> switch (v) {\n-                        case String s -> s;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n-                    });\n-\n-            return new FuncCallOp(def, funcName);\n-        }\n-\n-        FuncCallOp(ExternalizedOp def, String funcName) {\n-            super(def);\n-\n-            this.funcName = funcName;\n-            this.resultType = def.resultType();\n-        }\n-\n-        FuncCallOp(FuncCallOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.funcName = that.funcName;\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public FuncCallOp transform(CopyContext cc, OpTransformer ot) {\n-            return new FuncCallOp(this, cc);\n-        }\n-\n-        FuncCallOp(String funcName, TypeElement resultType, List<Value> args) {\n-            super(NAME, args);\n-\n-            this.funcName = funcName;\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", funcName);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public String funcName() {\n-            return funcName;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * The module operation, modeling a collection of functions,\n-     * and creating a symbol table of function name to function\n-     *\/\n-    @OpFactory.OpDeclaration(ModuleOp.NAME)\n-    public static final class ModuleOp extends CoreOp\n-            implements Op.Isolated, Op.Lowerable {\n-\n-        public static final String NAME = \"module\";\n-\n-        final SequencedMap<String, FuncOp> table;\n-        final Body body;\n-\n-        public static ModuleOp create(ExternalizedOp def) {\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Bad op \" + def.name());\n-            }\n-\n-            return new ModuleOp(def);\n-        }\n-\n-        ModuleOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-            this.table = createTable(body);\n-        }\n-\n-        ModuleOp(ModuleOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.body = that.body.transform(cc, ot).build(this);\n-            this.table = createTable(body);\n-        }\n-\n-        static SequencedMap<String, FuncOp> createTable(Body body) {\n-            SequencedMap<String, FuncOp> table = new LinkedHashMap<>();\n-            for (var op : body.entryBlock().ops()) {\n-                if (op instanceof FuncOp fop) {\n-                    table.put(fop.funcName(), fop);\n-                } else if (!(op instanceof Op.Terminating)) {\n-                    throw new IllegalArgumentException(\"Bad operation in module: \" + op);\n-                }\n-            }\n-            return Collections.unmodifiableSequencedMap(table);\n-        }\n-\n-        @Override\n-        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ModuleOp(this, cc, ot);\n-        }\n-\n-        public ModuleOp transform(OpTransformer ot) {\n-            return new ModuleOp(this, CopyContext.create(), ot);\n-        }\n-\n-        ModuleOp(List<FuncOp> functions) {\n-            super(NAME,\n-                    List.of());\n-\n-            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n-            Block.Builder entryBlock = bodyC.entryBlock();\n-            SequencedMap<String, FuncOp> table = new LinkedHashMap<>();\n-            for (FuncOp f : functions) {\n-                entryBlock.op(f);\n-                table.put(f.funcName(), f);\n-            }\n-            entryBlock.op(CoreOp.unreachable());\n-            this.table = Collections.unmodifiableSequencedMap(table);\n-            this.body = bodyC.build(this);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        public SequencedMap<String, FuncOp> functionTable() {\n-            return table;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n-            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n-            return b;\n-        }\n-    }\n-\n-    \/**\n-     * The quoted operation, that models the quoting of an operation.\n-     *\/\n-    @OpFactory.OpDeclaration(QuotedOp.NAME)\n-    public static final class QuotedOp extends CoreOp\n-            implements Op.Nested, Op.Lowerable, Op.Pure {\n-        public static final String NAME = \"quoted\";\n-\n-        \/\/ Type name must be the same in the java.base and jdk.compiler module\n-        static final String Quoted_CLASS_NAME = PACKAGE_NAME +\n-                \".\" + Quoted.class.getSimpleName();\n-        public static final JavaType QUOTED_TYPE = JavaType.type(ClassDesc.of(Quoted_CLASS_NAME));\n-\n-        final Body quotedBody;\n-\n-        final Op quotedOp;\n-\n-        public QuotedOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.quotedBody = def.bodyDefinitions().get(0).build(this);\n-\n-            if (quotedBody.entryBlock().terminatingOp() instanceof YieldOp brk &&\n-                    brk.yieldValue() instanceof Result quotedOpResult) {\n-                this.quotedOp = quotedOpResult.op();\n-            } else {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        QuotedOp(QuotedOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.quotedBody = that.quotedBody.transform(cc, ot).build(this);\n-            this.quotedOp = that.quotedOp;\n-        }\n-\n-        @Override\n-        public QuotedOp transform(CopyContext cc, OpTransformer ot) {\n-            return new QuotedOp(this, cc, ot);\n-        }\n-\n-        QuotedOp(Body.Builder bodyC) {\n-            super(NAME,\n-                    List.of());\n-\n-            this.quotedBody = bodyC.build(this);\n-            if (quotedBody.blocks().size() > 1) {\n-                throw new IllegalArgumentException();\n-            }\n-            if (!(quotedBody.entryBlock().terminatingOp() instanceof YieldOp yop)) {\n-                throw new IllegalArgumentException();\n-            }\n-            if (!(yop.yieldValue() instanceof Result r)) {\n-                throw new IllegalArgumentException();\n-            }\n-            this.quotedOp = r.op();\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(quotedBody);\n-        }\n-\n-        public Op quotedOp() {\n-            return quotedOp;\n-        }\n-\n-        @Override\n-        public List<Value> capturedValues() {\n-            return quotedBody.capturedValues();\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n-            \/\/ Isolate body with respect to ancestor transformations\n-            \/\/ and copy directly without lowering descendant operations\n-            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return QUOTED_TYPE;\n-        }\n-    }\n-\n-    \/**\n-     * The lambda operation, that can model a Java lambda expression.\n-     *\/\n-    @OpFactory.OpDeclaration(LambdaOp.NAME)\n-    public static final class LambdaOp extends CoreOp\n-            implements Op.Invokable, Op.Lowerable, JavaExpression {\n-\n-        public static class Builder {\n-            final Body.Builder ancestorBody;\n-            final FunctionType funcType;\n-            final TypeElement functionalInterface;\n-\n-            Builder(Body.Builder ancestorBody, FunctionType funcType, TypeElement functionalInterface) {\n-                this.ancestorBody = ancestorBody;\n-                this.funcType = funcType;\n-                this.functionalInterface = functionalInterface;\n-            }\n-\n-            public LambdaOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n-                c.accept(body.entryBlock());\n-                return new LambdaOp(functionalInterface, body);\n-            }\n-        }\n-\n-        public static final String NAME = \"lambda\";\n-\n-        final TypeElement functionalInterface;\n-        final Body body;\n-\n-        public LambdaOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.functionalInterface = def.resultType();\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-        }\n-\n-        LambdaOp(LambdaOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.functionalInterface = that.functionalInterface;\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public LambdaOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LambdaOp(this, cc, ot);\n-        }\n-\n-        LambdaOp(TypeElement functionalInterface, Body.Builder bodyC) {\n-            super(NAME,\n-                    List.of());\n-\n-            this.functionalInterface = functionalInterface;\n-            this.body = bodyC.build(this);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        @Override\n-        public FunctionType invokableType() {\n-            return body.bodyType();\n-        }\n-\n-        public TypeElement functionalInterface() {\n-            return functionalInterface;\n-        }\n-\n-        @Override\n-        public Body body() {\n-            return body;\n-        }\n-\n-        @Override\n-        public List<Value> capturedValues() {\n-            return body.capturedValues();\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n-            \/\/ Isolate body with respect to ancestor transformations\n-            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return functionalInterface();\n-        }\n-\n-        \/**\n-         * Determines if this lambda operation could have originated from a\n-         * method reference declared in Java source code.\n-         * <p>\n-         * Such a lambda operation is one with the following constraints:\n-         * <ol>\n-         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n-         *     <li>A body with only one (entry) block that contains only variable declaration\n-         *     operations, variable load operations, invoke operations to box or unbox\n-         *     primitive values, a single invoke operation to the method that is\n-         *     referenced, and a return operation.\n-         *     <li>if the return operation returns a non-void result then that result is,\n-         *     or uniquely depends on, the result of the referencing invoke operation.\n-         *     <li>If the lambda operation captures one value then the first operand corresponds\n-         *     to captured the value, and subsequent operands of the referencing invocation\n-         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n-         *     Otherwise, the first and subsequent operands of the referencing invocation\n-         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n-         * <\/ol>\n-         * A value, V2, uniquely depends on another value, V1, if the graph of what V2 depends on\n-         * contains only nodes with single edges terminating in V1, and the graph of what depends on V1\n-         * is bidirectionally equal to the graph of what V2 depends on.\n-         *\n-         * @return the invocation operation to the method referenced by the lambda\n-         * operation, otherwise empty.\n-         *\/\n-        public Optional<InvokeOp> methodReference() {\n-            \/\/ Single block\n-            if (body().blocks().size() > 1) {\n-                return Optional.empty();\n-            }\n-\n-            \/\/ Zero or one (this) capture\n-            List<Value> cvs = capturedValues();\n-            if (cvs.size() > 1) {\n-                return Optional.empty();\n-            }\n-\n-            Map<Value, Value> valueMapping = new HashMap<>();\n-            CoreOp.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, body().entryBlock().ops());\n-            if (methodRefInvokeOp == null) {\n-                return Optional.empty();\n-            }\n-\n-            \/\/ Lambda's parameters map in encounter order with the invocation's operands\n-            List<Value> lambdaParameters = new ArrayList<>();\n-            if (cvs.size() == 1) {\n-                lambdaParameters.add(cvs.getFirst());\n-            }\n-            lambdaParameters.addAll(parameters());\n-            List<Value> methodRefOperands = methodRefInvokeOp.operands().stream().map(valueMapping::get).toList();\n-            if (!lambdaParameters.equals(methodRefOperands)) {\n-                return Optional.empty();\n-            }\n-\n-            return Optional.of(methodRefInvokeOp);\n-        }\n-\n-        static CoreOp.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n-            CoreOp.InvokeOp methodRefInvokeOp = null;\n-            for (Op op : ops) {\n-                switch (op) {\n-                    case CoreOp.VarOp varOp -> {\n-                        if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOp.VarAccessOp.VarStoreOp)) {\n-                            return null;\n-                        }\n-                    }\n-                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n-                        Value v = varLoadOp.varOp().operands().getFirst();\n-                        valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n-                    }\n-                    case CoreOp.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n-                        Value v = iop.operands().getFirst();\n-                        valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n-                    }\n-                    case CoreOp.InvokeOp iop -> {\n-                        if (methodRefInvokeOp != null) {\n-                            return null;\n-                        }\n-\n-                        for (Value o : iop.operands()) {\n-                            valueMapping.put(o, valueMapping.getOrDefault(o, o));\n-                        }\n-                        methodRefInvokeOp = iop;\n-                    }\n-                    case CoreOp.ReturnOp rop -> {\n-                        if (methodRefInvokeOp == null) {\n-                            return null;\n-                        }\n-                        Value r = rop.returnValue();\n-                        if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n-                            return null;\n-                        }\n-                        if (invokeResult.op() != methodRefInvokeOp) {\n-                            return null;\n-                        }\n-                        assert methodRefInvokeOp.result().uses().size() == 1;\n-                    }\n-                    default -> {\n-                        return null;\n-                    }\n-                }\n-            }\n-\n-            return methodRefInvokeOp;\n-        }\n-\n-        private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n-            for (Op.Result user : value.uses()) {\n-                if (opPredicate.test(user.op())) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        \/\/ @@@ Move to functionality on JavaType(s)\n-        static final Set<String> UNBOX_NAMES = Set.of(\n-                \"byteValue\",\n-                \"shortValue\",\n-                \"charValue\",\n-                \"intValue\",\n-                \"longValue\",\n-                \"floatValue\",\n-                \"doubleValue\",\n-                \"booleanValue\");\n-\n-        private static boolean isBoxOrUnboxInvocation(CoreOp.InvokeOp iop) {\n-            MethodRef mr = iop.invokeDescriptor();\n-            return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n-                    (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n-        }\n-    }\n-\n-    \/**\n-     * The closure operation, that can model a structured Java lambda expression\n-     * that has no target type (a functional interface).\n-     *\/\n-    @OpFactory.OpDeclaration(ClosureOp.NAME)\n-    public static final class ClosureOp extends CoreOp\n-            implements Op.Invokable, Op.Lowerable, JavaExpression {\n-\n-        public static class Builder {\n-            final Body.Builder ancestorBody;\n-            final FunctionType funcType;\n-\n-            Builder(Body.Builder ancestorBody, FunctionType funcType) {\n-                this.ancestorBody = ancestorBody;\n-                this.funcType = funcType;\n-            }\n-\n-            public ClosureOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n-                c.accept(body.entryBlock());\n-                return new ClosureOp(body);\n-            }\n-        }\n-\n-        public static final String NAME = \"closure\";\n-\n-        final Body body;\n-\n-        public ClosureOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-        }\n-\n-        ClosureOp(ClosureOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public ClosureOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ClosureOp(this, cc, ot);\n-        }\n-\n-        ClosureOp(Body.Builder bodyC) {\n-            super(NAME,\n-                    List.of());\n-\n-            this.body = bodyC.build(this);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        @Override\n-        public FunctionType invokableType() {\n-            return body.bodyType();\n-        }\n-\n-        @Override\n-        public Body body() {\n-            return body;\n-        }\n-\n-        @Override\n-        public List<Value> capturedValues() {\n-            return body.capturedValues();\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n-            \/\/ Isolate body with respect to ancestor transformations\n-            b.op(this, OpTransformer.LOWERING_TRANSFORMER);\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return body.bodyType();\n-        }\n-    }\n-\n-    \/**\n-     * The closure call operation, that models a call to a closure, by reference\n-     *\/\n-\/\/  @@@ stack effects equivalent to the invocation of an SAM of on an instance of an anonymous functional interface\n-\/\/  that is the target of the closures lambda expression.\n-    @OpFactory.OpDeclaration(ClosureCallOp.NAME)\n-    public static final class ClosureCallOp extends CoreOp {\n-        public static final String NAME = \"closure.call\";\n-\n-        public ClosureCallOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        ClosureCallOp(ClosureCallOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ClosureCallOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ClosureCallOp(this, cc);\n-        }\n-\n-        ClosureCallOp(List<Value> args) {\n-            super(NAME, args);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            FunctionType ft = (FunctionType) operands().getFirst().type();\n-            return ft.returnType();\n-        }\n-    }\n-\n-    \/**\n-     * The terminating return operation, that can model the Java language return statement.\n-     * <p>\n-     * This operation exits an isolated body.\n-     *\/\n-    @OpFactory.OpDeclaration(ReturnOp.NAME)\n-    public static final class ReturnOp extends CoreOp\n-            implements Op.BodyTerminating, JavaStatement {\n-        public static final String NAME = \"return\";\n-\n-        public ReturnOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() > 1) {\n-                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n-            }\n-        }\n-\n-        ReturnOp(ReturnOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ReturnOp(this, cc);\n-        }\n-\n-        ReturnOp() {\n-            super(NAME, List.of());\n-        }\n-\n-        ReturnOp(Value operand) {\n-            super(NAME, List.of(operand));\n-        }\n-\n-        public Value returnValue() {\n-            if (operands().size() == 1) {\n-                return operands().get(0);\n-            } else {\n-                \/\/ @@@\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The terminating throw operation, that can model the Java language throw statement.\n-     *\/\n-    @OpFactory.OpDeclaration(ThrowOp.NAME)\n-    public static final class ThrowOp extends CoreOp\n-            implements Op.BodyTerminating, JavaStatement {\n-        public static final String NAME = \"throw\";\n-\n-        public ThrowOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n-            }\n-        }\n-\n-        ThrowOp(ThrowOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ThrowOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ThrowOp(this, cc);\n-        }\n-\n-        ThrowOp(Value e) {\n-            super(NAME, List.of(e));\n-        }\n-\n-        public Value argument() {\n-            return operands().get(0);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The assertion operation. Supporting assertions in statement form.\n-     *\/\n-    @OpFactory.OpDeclaration(AssertOp.NAME)\n-    public static final class AssertOp extends CoreOp\n-            implements Op.Nested, JavaStatement {\n-        public static final String NAME = \"assert\";\n-        public final List<Body> bodies;\n-\n-        public AssertOp(ExternalizedOp def) {\n-            super(def);\n-            var bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n-            checkBodies(bodies);\n-            this.bodies = bodies;\n-        }\n-\n-        public AssertOp(List<Body.Builder> bodies) {\n-            super(NAME, List.of());\n-            checkBodies(bodies);\n-            this.bodies = bodies.stream().map(b -> b.build(this)).toList();\n-        }\n-\n-        AssertOp(AssertOp that, CopyContext cc, OpTransformer ot) {\n-\n-            super(that, cc);\n-            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        private void checkBodies(List<?> bodies) {\n-            if (bodies.size() != 1 && bodies.size() != 2) {\n-                throw new IllegalArgumentException(\"Assert must have one or two bodies.\");\n-            }\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new AssertOp(this, cc, ot);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return this.bodies;\n-        }\n-    }\n-\n-    \/**\n-     * A monitor operation.\n-     *\/\n-    public sealed abstract static class MonitorOp extends CoreOp {\n-        public MonitorOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n-            }\n-        }\n-\n-        MonitorOp(MonitorOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        MonitorOp(String name, Value monitor) {\n-            super(name, List.of(monitor));\n-        }\n-\n-        public Value monitorValue() {\n-            return operands().getFirst();\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-\n-        \/**\n-         * The monitor enter operation.\n-         *\/\n-        @OpFactory.OpDeclaration(MonitorEnterOp.NAME)\n-        public static final class MonitorEnterOp extends MonitorOp {\n-            public static final String NAME = \"monitor.enter\";\n-\n-            public MonitorEnterOp(ExternalizedOp def) {\n-                super(def);\n-            }\n-\n-            MonitorEnterOp(MonitorEnterOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public MonitorEnterOp transform(CopyContext cc, OpTransformer ot) {\n-                return new MonitorEnterOp(this, cc);\n-            }\n-\n-            MonitorEnterOp(Value monitor) {\n-                super(NAME, monitor);\n-            }\n-        }\n-\n-        \/**\n-         * The monitor exit operation.\n-         *\/\n-        @OpFactory.OpDeclaration(MonitorExitOp.NAME)\n-        public static final class MonitorExitOp extends MonitorOp {\n-            public static final String NAME = \"monitor.exit\";\n-\n-            public MonitorExitOp(ExternalizedOp def) {\n-                super(def);\n-            }\n-\n-            MonitorExitOp(MonitorExitOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public MonitorExitOp transform(CopyContext cc, OpTransformer ot) {\n-                return new MonitorExitOp(this, cc);\n-            }\n-\n-            MonitorExitOp(Value monitor) {\n-                super(NAME, monitor);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The terminating unreachable operation.\n-     * <p>\n-     * This operation models termination that is unreachable.\n-     *\/\n-    @OpFactory.OpDeclaration(UnreachableOp.NAME)\n-    public static final class UnreachableOp extends CoreOp\n-            implements Op.BodyTerminating {\n-        public static final String NAME = \"unreachable\";\n-\n-        public UnreachableOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalArgumentException(\"Operation must zero operands \" + def.name());\n-            }\n-        }\n-\n-        UnreachableOp(UnreachableOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public UnreachableOp transform(CopyContext cc, OpTransformer ot) {\n-            return new UnreachableOp(this, cc);\n-        }\n-\n-        UnreachableOp() {\n-            super(NAME, List.of());\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The terminating yield operation.\n-     * <p>\n-     * This operation models exits from its parent body, yielding at most one value (zero value for yielding unit\n-     * or void)\n-     *\/\n-    @OpFactory.OpDeclaration(YieldOp.NAME)\n-    public static final class YieldOp extends CoreOp\n-            implements Op.BodyTerminating {\n-        public static final String NAME = \"yield\";\n-\n-        public YieldOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() > 1) {\n-                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n-            }\n-        }\n-\n-        YieldOp(YieldOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public YieldOp transform(CopyContext cc, OpTransformer ot) {\n-            return new YieldOp(this, cc);\n-        }\n-\n-        YieldOp() {\n-            super(NAME, List.of());\n-        }\n-\n-        YieldOp(List<Value> operands) {\n-            super(NAME, operands);\n-        }\n-\n-        public Value yieldValue() {\n-            if (operands().size() == 1) {\n-                return operands().get(0);\n-            } else {\n-                \/\/ @@@\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The terminating unconditional branch operation.\n-     * <p>\n-     * This operation accepts a successor to the next block to branch to.\n-     *\/\n-    @OpFactory.OpDeclaration(BranchOp.NAME)\n-    public static final class BranchOp extends CoreOp\n-            implements Op.BlockTerminating {\n-        public static final String NAME = \"branch\";\n-\n-        final Block.Reference b;\n-\n-        public BranchOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty() || def.successors().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have zero arguments and one successor\" + def.name());\n-            }\n-\n-            this.b = def.successors().get(0);\n-        }\n-\n-        BranchOp(BranchOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.b = cc.getSuccessorOrCreate(that.b);\n-        }\n-\n-        @Override\n-        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n-            return new BranchOp(this, cc);\n-        }\n-\n-        BranchOp(Block.Reference successor) {\n-            super(NAME, List.of());\n-\n-            this.b = successor;\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return List.of(b);\n-        }\n-\n-        public Block.Reference branch() {\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The terminating conditional branch operation.\n-     * <p>\n-     * This operation accepts a boolean operand and two successors, the true successor and false successor.\n-     * When the operand is true the  true successor is selected, otherwise the false successor is selected.\n-     * The selected successor refers to the next block to branch to.\n-     *\/\n-    @OpFactory.OpDeclaration(ConditionalBranchOp.NAME)\n-    public static final class ConditionalBranchOp extends CoreOp\n-            implements Op.BlockTerminating {\n-        public static final String NAME = \"cbranch\";\n-\n-        final Block.Reference t;\n-        final Block.Reference f;\n-\n-        public ConditionalBranchOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1 || def.successors().size() != 2) {\n-                throw new IllegalArgumentException(\"Operation must one operand and two successors\" + def.name());\n-            }\n-\n-            this.t = def.successors().get(0);\n-            this.f = def.successors().get(1);\n-        }\n-\n-        ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.t = cc.getSuccessorOrCreate(that.t);\n-            this.f = cc.getSuccessorOrCreate(that.f);\n-        }\n-\n-        @Override\n-        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ConditionalBranchOp(this, cc);\n-        }\n-\n-        ConditionalBranchOp(Value p, Block.Reference t, Block.Reference f) {\n-            super(NAME, List.of(p));\n-\n-            this.t = t;\n-            this.f = f;\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return List.of(t, f);\n-        }\n-\n-        public Value predicate() {\n-            return operands().get(0);\n-        }\n-\n-        public Block.Reference trueBranch() {\n-            return t;\n-        }\n-\n-        public Block.Reference falseBranch() {\n-            return f;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The constant operation, that can model Java language literal and constant expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(ConstantOp.NAME)\n-    public static final class ConstantOp extends CoreOp\n-            implements Op.Pure, JavaExpression {\n-        public static final String NAME = \"constant\";\n-\n-        public static final String ATTRIBUTE_CONSTANT_VALUE = NAME + \".value\";\n-\n-        final Object value;\n-        final TypeElement type;\n-\n-        public static ConstantOp create(ExternalizedOp def) {\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalArgumentException(\"Operation must have zero operands\");\n-            }\n-\n-            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE, true,\n-                    v -> processConstantValue(def.resultType(), v));\n-            return new ConstantOp(def, value);\n-        }\n-\n-        static Object processConstantValue(TypeElement t, Object value) {\n-            if (t.equals(JavaType.BOOLEAN) && value instanceof Boolean) {\n-                return value;\n-            } else if (t.equals(JavaType.BYTE) && value instanceof Number n) {\n-                return n.byteValue();\n-            } else if (t.equals(JavaType.SHORT) && value instanceof Number n) {\n-                return n.shortValue();\n-            } else if (t.equals(JavaType.CHAR) && value instanceof Character) {\n-                return value;\n-            } else if (t.equals(JavaType.INT) && value instanceof Number n) {\n-                return n.intValue();\n-            } else if (t.equals(JavaType.LONG) && value instanceof Number n) {\n-                return n.longValue();\n-            } else if (t.equals(JavaType.FLOAT) && value instanceof Number n) {\n-                return n.floatValue();\n-            } else if (t.equals(JavaType.DOUBLE) && value instanceof Number n) {\n-                return n.doubleValue();\n-            } else if (t.equals(JavaType.J_L_STRING)) {\n-                return value == NULL_ATTRIBUTE_VALUE ?\n-                        null : (String)value;\n-            } else if (t.equals(JavaType.J_L_CLASS)) {\n-                return value == NULL_ATTRIBUTE_VALUE ?\n-                        null : (TypeElement)value;\n-            } else if (value == NULL_ATTRIBUTE_VALUE) {\n-                return null; \/\/ null constant\n-            }\n-\n-            throw new UnsupportedOperationException(\"Unsupported constant type and value: \" + t + \" \" + value);\n-        }\n-\n-        ConstantOp(ExternalizedOp def, Object value) {\n-            super(def);\n-\n-            this.type = def.resultType();\n-            this.value = value;\n-        }\n-\n-        ConstantOp(ConstantOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.type = that.type;\n-            this.value = that.value;\n-        }\n-\n-        @Override\n-        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ConstantOp(this, cc);\n-        }\n-\n-        ConstantOp(TypeElement type, Object value) {\n-            super(NAME, List.of());\n-\n-            this.type = type;\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", value == null ? NULL_ATTRIBUTE_VALUE : value);\n-            return attrs;\n-        }\n-\n-        public Object value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return type;\n-        }\n-    }\n-\n-    \/**\n-     * An operation characteristic indicating the operation's behavior may be emulated using Java reflection.\n-     * A descriptor is derived from or declared by the operation that can be resolved at runtime to\n-     * an instance of a reflective handle or member. That handle or member can be operated on to\n-     * emulate the operation's behavior, specifically as bytecode behavior.\n-     *\/\n-    public sealed interface ReflectiveOp {\n-    }\n-\n-    \/**\n-     * The invoke operation, that can model Java language method invocation expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(InvokeOp.NAME)\n-    public static final class InvokeOp extends CoreOp\n-            implements ReflectiveOp, JavaExpression, JavaStatement {\n-\n-        \/**\n-         * The kind of invocation.\n-         *\/\n-        public enum InvokeKind {\n-            \/**\n-             * An invocation on a class (static) method.\n-             *\/\n-            STATIC,\n-            \/**\n-             * An invocation on an instance method.\n-             *\/\n-            INSTANCE,\n-            \/**\n-             * A super invocation on an instance method.\n-             *\/\n-            SUPER\n-        }\n-\n-        public static final String NAME = \"invoke\";\n-        public static final String ATTRIBUTE_INVOKE_DESCRIPTOR = NAME + \".descriptor\";\n-        public static final String ATTRIBUTE_INVOKE_KIND = NAME + \".kind\";\n-        public static final String ATTRIBUTE_INVOKE_VARARGS = NAME + \".varargs\";\n-\n-        final InvokeKind invokeKind;\n-        final boolean isVarArgs;\n-        final MethodRef invokeDescriptor;\n-        final TypeElement resultType;\n-\n-        public static InvokeOp create(ExternalizedOp def) {\n-            \/\/ Required attribute\n-            MethodRef invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n-                    true, v -> switch (v) {\n-                        case MethodRef md -> md;\n-                        case null, default ->\n-                                throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n-                    });\n-\n-            \/\/ If not present defaults to false\n-            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_INVOKE_VARARGS,\n-                    false, v -> switch (v) {\n-                        case Boolean b -> b;\n-                        case null, default -> false;\n-                    });\n-\n-            \/\/ If not present and is not varargs defaults to class or instance invocation\n-            \/\/ based on number of operands and parameters\n-            InvokeKind ik = def.extractAttributeValue(ATTRIBUTE_INVOKE_KIND,\n-                    false, v -> switch (v) {\n-                        case String s -> InvokeKind.valueOf(s);\n-                        case InvokeKind k -> k;\n-                        case null, default -> {\n-                            if (isVarArgs) {\n-                                \/\/ If varargs then we cannot infer invoke kind\n-                                throw new UnsupportedOperationException(\"Unsupported invoke kind value:\" + v);\n-                            }\n-                            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-                            int argCount = def.operands().size();\n-                            yield (argCount == paramCount + 1)\n-                                    ? InvokeKind.INSTANCE\n-                                    : InvokeKind.STATIC;\n-                        }\n-                    });\n-\n-\n-            return new InvokeOp(def, ik, isVarArgs, invokeDescriptor);\n-        }\n-\n-        InvokeOp(ExternalizedOp def, InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor) {\n-            super(def);\n-\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, def.operands());\n-\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n-            this.invokeDescriptor = invokeDescriptor;\n-            this.resultType = def.resultType();\n-        }\n-\n-        InvokeOp(InvokeOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.invokeKind = that.invokeKind;\n-            this.isVarArgs = that.isVarArgs;\n-            this.invokeDescriptor = that.invokeDescriptor;\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public InvokeOp transform(CopyContext cc, OpTransformer ot) {\n-            return new InvokeOp(this, cc);\n-        }\n-\n-        InvokeOp(InvokeKind invokeKind, boolean isVarArgs, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-            super(NAME, args);\n-\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, args);\n-\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n-            this.invokeDescriptor = invokeDescriptor;\n-            this.resultType = resultType;\n-        }\n-\n-        static void validateArgCount(InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor, List<Value> operands) {\n-            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n-            if ((!isVarArgs && argCount != paramCount)\n-                    || argCount < paramCount - 1) {\n-                throw new IllegalArgumentException(invokeKind + \" \" + isVarArgs + \" \" + invokeDescriptor);\n-            }\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", invokeDescriptor);\n-            if (isVarArgs) {\n-                \/\/ If varargs then we need to declare the invoke.kind attribute\n-                \/\/ Given a method `A::m(A... more)` and an invocation with one\n-                \/\/ operand, we don't know if that operand corresponds to the\n-                \/\/ receiver or a method argument\n-                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n-                m.put(ATTRIBUTE_INVOKE_VARARGS, isVarArgs);\n-            } else if (invokeKind == InvokeKind.SUPER) {\n-                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n-            }\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public InvokeKind invokeKind() {\n-            return invokeKind;\n-        }\n-\n-        public boolean isVarArgs() {\n-            return isVarArgs;\n-        }\n-\n-        public MethodRef invokeDescriptor() {\n-            return invokeDescriptor;\n-        }\n-\n-        \/\/ @@@ remove?\n-        public boolean hasReceiver() {\n-            return invokeKind != InvokeKind.STATIC;\n-        }\n-\n-        public List<Value> varArgOperands() {\n-            if (!isVarArgs) {\n-                return null;\n-            }\n-\n-            int operandCount = operands().size();\n-            int argCount = operandCount - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n-            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-            int varArgCount = argCount - (paramCount - 1);\n-            return operands().subList(operandCount - varArgCount, operandCount);\n-        }\n-\n-        public List<Value> argOperands() {\n-            if (!isVarArgs) {\n-                return operands();\n-            }\n-            int paramCount = invokeDescriptor().type().parameterTypes().size();\n-            int argOperandsCount = paramCount - (invokeKind() == InvokeKind.STATIC ? 1 : 0);\n-            return operands().subList(0, argOperandsCount);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * The conversion operation, that can model Java language cast expressions\n-     * for numerical conversion, or such implicit conversion.\n-     *\/\n-    @OpFactory.OpDeclaration(ConvOp.NAME)\n-    public static final class ConvOp extends CoreOp\n-            implements Op.Pure, JavaExpression {\n-        public static final String NAME = \"conv\";\n-\n-        final TypeElement resultType;\n-\n-        public ConvOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.resultType = def.resultType();\n-        }\n-\n-        ConvOp(ConvOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new ConvOp(this, cc);\n-        }\n-\n-        ConvOp(TypeElement resultType, Value arg) {\n-            super(NAME, List.of(arg));\n-\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * The new operation, that can models Java language instance creation expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(NewOp.NAME)\n-    public static final class NewOp extends CoreOp\n-            implements ReflectiveOp, JavaExpression, JavaStatement {\n-\n-        public static final String NAME = \"new\";\n-        public static final String ATTRIBUTE_NEW_DESCRIPTOR = NAME + \".descriptor\";\n-        public static final String ATTRIBUTE_NEW_VARARGS = NAME + \".varargs\";\n-\n-        final boolean isVarArgs;\n-        final ConstructorRef constructorDescriptor;\n-        final TypeElement resultType;\n-\n-        public static NewOp create(ExternalizedOp def) {\n-            \/\/ Required attribute\n-            ConstructorRef constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,\n-                    true, v -> switch (v) {\n-                        case ConstructorRef cd -> cd;\n-                        case null, default ->\n-                                throw new UnsupportedOperationException(\"Unsupported constructor descriptor value:\" + v);\n-                    });\n-\n-            \/\/ If not present defaults to false\n-            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_NEW_VARARGS,\n-                    false, v -> switch (v) {\n-                        case Boolean b -> b;\n-                        case null, default -> false;\n-                    });\n-\n-            return new NewOp(def, isVarArgs, constructorDescriptor);\n-        }\n-\n-        NewOp(ExternalizedOp def, boolean isVarArgs, ConstructorRef constructorDescriptor) {\n-            super(def);\n-\n-            validateArgCount(isVarArgs, constructorDescriptor, def.operands());\n-\n-            this.isVarArgs = isVarArgs;\n-            this.constructorDescriptor = constructorDescriptor;\n-            this.resultType = def.resultType();\n-        }\n-\n-        NewOp(NewOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.isVarArgs = that.isVarArgs;\n-            this.constructorDescriptor = that.constructorDescriptor;\n-            this.resultType = that.resultType;\n-        }\n-\n-        static void validateArgCount(boolean isVarArgs, ConstructorRef constructorDescriptor, List<Value> operands) {\n-            int paramCount = constructorDescriptor.type().parameterTypes().size();\n-            int argCount = operands.size();\n-            if ((!isVarArgs && argCount != paramCount)\n-                    || argCount < paramCount - 1) {\n-                throw new IllegalArgumentException(isVarArgs + \" \" + constructorDescriptor);\n-            }\n-        }\n-\n-        @Override\n-        public NewOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NewOp(this, cc);\n-        }\n-\n-        NewOp(boolean isVarargs, TypeElement resultType, ConstructorRef constructorDescriptor, List<Value> args) {\n-            super(NAME, args);\n-\n-            this.isVarArgs = isVarargs;\n-            this.constructorDescriptor = constructorDescriptor;\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", constructorDescriptor);\n-            if (isVarArgs) {\n-                m.put(ATTRIBUTE_NEW_VARARGS, isVarArgs);\n-            }\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public boolean isVarargs() {\n-            return isVarArgs;\n-        }\n-\n-        public TypeElement type() {\n-            return opType().returnType();\n-        } \/\/ @@@ duplication, same as resultType()\n-\n-        public ConstructorRef constructorDescriptor() {\n-            return constructorDescriptor;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * An operation that performs access.\n-     *\/\n-    public sealed interface AccessOp {\n-    }\n-\n-    \/**\n-     * A field access operation, that can model Java langauge field access expressions.\n-     *\/\n-    public sealed abstract static class FieldAccessOp extends CoreOp\n-            implements AccessOp, ReflectiveOp {\n-        public static final String ATTRIBUTE_FIELD_DESCRIPTOR = \"field.descriptor\";\n-\n-        final FieldRef fieldDescriptor;\n-\n-        FieldAccessOp(ExternalizedOp def, FieldRef fieldDescriptor) {\n-            super(def);\n-\n-            this.fieldDescriptor = fieldDescriptor;\n-        }\n-\n-        FieldAccessOp(FieldAccessOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.fieldDescriptor = that.fieldDescriptor;\n-        }\n-\n-        FieldAccessOp(String name, List<Value> operands,\n-                      FieldRef fieldDescriptor) {\n-            super(name, operands);\n-\n-            this.fieldDescriptor = fieldDescriptor;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", fieldDescriptor);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public final FieldRef fieldDescriptor() {\n-            return fieldDescriptor;\n-        }\n-\n-        \/**\n-         * The field load operation, that can model Java language field access expressions combined with load access to\n-         * field instance variables.\n-         *\/\n-        @OpFactory.OpDeclaration(FieldLoadOp.NAME)\n-        public static final class FieldLoadOp extends FieldAccessOp\n-                implements Op.Pure, JavaExpression {\n-            public static final String NAME = \"field.load\";\n-\n-            final TypeElement resultType;\n-\n-            public static FieldLoadOp create(ExternalizedOp def) {\n-                if (def.operands().size() > 1) {\n-                    throw new IllegalArgumentException(\"Operation must accept zero or one operand\");\n-                }\n-\n-                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n-                        v -> switch (v) {\n-                            case FieldRef fd -> fd;\n-                            case null, default ->\n-                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n-                        });\n-                return new FieldLoadOp(def, fieldDescriptor);\n-            }\n-\n-            FieldLoadOp(ExternalizedOp opdef, FieldRef fieldDescriptor) {\n-                super(opdef, fieldDescriptor);\n-\n-                resultType = opdef.resultType();\n-            }\n-\n-            FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n-                super(that, cc);\n-\n-                resultType = that.resultType();\n-            }\n-\n-            @Override\n-            public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n-                return new FieldLoadOp(this, cc);\n-            }\n-\n-            \/\/ instance\n-            FieldLoadOp(TypeElement resultType, FieldRef descriptor, Value receiver) {\n-                super(NAME, List.of(receiver), descriptor);\n-\n-                this.resultType = resultType;\n-            }\n-\n-            \/\/ static\n-            FieldLoadOp(TypeElement resultType, FieldRef descriptor) {\n-                super(NAME, List.of(), descriptor);\n-\n-                this.resultType = resultType;\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return resultType;\n-            }\n-        }\n-\n-        \/**\n-         * The field store operation, that can model Java language field access expressions combined with store access\n-         * to field instance variables.\n-         *\/\n-        @OpFactory.OpDeclaration(FieldStoreOp.NAME)\n-        public static final class FieldStoreOp extends FieldAccessOp\n-                implements JavaExpression, JavaStatement {\n-            public static final String NAME = \"field.store\";\n-\n-            public static FieldStoreOp create(ExternalizedOp def) {\n-                if (def.operands().size() > 2) {\n-                    throw new IllegalArgumentException(\"Operation must accept one or two operands\");\n-                }\n-\n-                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n-                        v -> switch (v) {\n-                            case FieldRef fd -> fd;\n-                            case null, default ->\n-                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n-                        });\n-                return new FieldStoreOp(def, fieldDescriptor);\n-            }\n-\n-            FieldStoreOp(ExternalizedOp opdef, FieldRef fieldDescriptor) {\n-                super(opdef, fieldDescriptor);\n-            }\n-\n-            FieldStoreOp(FieldStoreOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public FieldStoreOp transform(CopyContext cc, OpTransformer ot) {\n-                return new FieldStoreOp(this, cc);\n-            }\n-\n-            \/\/ instance\n-            FieldStoreOp(FieldRef descriptor, Value receiver, Value v) {\n-                super(NAME,\n-                        List.of(receiver, v), descriptor);\n-            }\n-\n-            \/\/ static\n-            FieldStoreOp(FieldRef descriptor, Value v) {\n-                super(NAME,\n-                        List.of(v), descriptor);\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return JavaType.VOID;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The array length operation, that can model Java language field access expressions to the length field of an\n-     * array.\n-     *\/\n-    @OpFactory.OpDeclaration(ArrayLengthOp.NAME)\n-    public static final class ArrayLengthOp extends CoreOp\n-            implements ReflectiveOp, JavaExpression {\n-        public static final String NAME = \"array.length\";\n-\n-        public ArrayLengthOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ArrayLengthOp(this, cc);\n-        }\n-\n-        ArrayLengthOp(Value array) {\n-            super(NAME, List.of(array));\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.INT;\n-        }\n-    }\n-\n-    \/**\n-     * The array access operation, that can model Java language array access expressions.\n-     *\/\n-    public sealed abstract static class ArrayAccessOp extends CoreOp\n-            implements AccessOp, ReflectiveOp {\n-        ArrayAccessOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 2 && def.operands().size() != 3) {\n-                throw new IllegalArgumentException(\"Operation must have 2 or 3 operands\");\n-            }\n-\n-            \/\/ @@@ validate first operand is an array\n-        }\n-\n-        ArrayAccessOp(ArrayAccessOp that, CopyContext cc) {\n-            this(that, cc.getValues(that.operands()));\n-        }\n-\n-        ArrayAccessOp(ArrayAccessOp that, List<Value> operands) {\n-            super(that.opName(), operands);\n-        }\n-\n-        ArrayAccessOp(String name,\n-                      Value array, Value index, Value v) {\n-            super(name, operands(array, index, v));\n-        }\n-\n-        static List<Value> operands(Value array, Value index, Value v) {\n-            return v == null\n-                    ? List.of(array, index)\n-                    : List.of(array, index, v);\n-        }\n-\n-        \/**\n-         * The array load operation, that can model Java language array expressions combined with load access to the\n-         * components of an array.\n-         *\/\n-        @OpFactory.OpDeclaration(ArrayLoadOp.NAME)\n-        public static final class ArrayLoadOp extends ArrayAccessOp\n-                implements Op.Pure, JavaExpression {\n-            public static final String NAME = \"array.load\";\n-            final TypeElement componentType;\n-\n-            public ArrayLoadOp(ExternalizedOp def) {\n-                super(def);\n-                this.componentType = def.resultType();\n-            }\n-\n-            ArrayLoadOp(ArrayLoadOp that, CopyContext cc) {\n-                super(that, cc);\n-                this.componentType = that.componentType;\n-            }\n-\n-            @Override\n-            public ArrayLoadOp transform(CopyContext cc, OpTransformer ot) {\n-                return new ArrayLoadOp(this, cc);\n-            }\n-\n-            ArrayLoadOp(Value array, Value index) {\n-                \/\/ @@@ revisit this when the component type is not explicitly given (see VarOp.resultType as an example)\n-                this(array, index, ((ArrayType)array.type()).componentType());\n-            }\n-\n-            ArrayLoadOp(Value array, Value index, TypeElement componentType) {\n-                super(NAME, array, index, null);\n-                this.componentType = componentType;\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return componentType;\n-            }\n-        }\n-\n-        \/**\n-         * The array store operation, that can model Java language array expressions combined with store access to the\n-         * components of an array.\n-         *\/\n-        @OpFactory.OpDeclaration(ArrayStoreOp.NAME)\n-        public static final class ArrayStoreOp extends ArrayAccessOp\n-                implements JavaExpression, JavaStatement {\n-            public static final String NAME = \"array.store\";\n-\n-            public ArrayStoreOp(ExternalizedOp def) {\n-                super(def);\n-            }\n-\n-            ArrayStoreOp(ArrayStoreOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public ArrayStoreOp transform(CopyContext cc, OpTransformer ot) {\n-                return new ArrayStoreOp(this, cc);\n-            }\n-\n-            ArrayStoreOp(Value array, Value index, Value v) {\n-                super(NAME, array, index, v);\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return JavaType.VOID;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The instanceof operation, that can model Java language instanceof expressions when the instanceof keyword is a\n-     * type comparison operator.\n-     *\/\n-    @OpFactory.OpDeclaration(InstanceOfOp.NAME)\n-    public static final class InstanceOfOp extends CoreOp\n-            implements Op.Pure, ReflectiveOp, JavaExpression {\n-        public static final String NAME = \"instanceof\";\n-        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n-\n-        final TypeElement typeDescriptor;\n-\n-        public static InstanceOfOp create(ExternalizedOp def) {\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n-            }\n-\n-            TypeElement typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n-                    v -> switch (v) {\n-                        case JavaType td -> td;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n-                    });\n-            return new InstanceOfOp(def, typeDescriptor);\n-        }\n-\n-        InstanceOfOp(ExternalizedOp def, TypeElement typeDescriptor) {\n-            super(def);\n-\n-            this.typeDescriptor = typeDescriptor;\n-        }\n-\n-        InstanceOfOp(InstanceOfOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.typeDescriptor = that.typeDescriptor;\n-        }\n-\n-        @Override\n-        public InstanceOfOp transform(CopyContext cc, OpTransformer ot) {\n-            return new InstanceOfOp(this, cc);\n-        }\n-\n-        InstanceOfOp(TypeElement t, Value v) {\n-            super(NAME,\n-                    List.of(v));\n-\n-            this.typeDescriptor = t;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", typeDescriptor);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public TypeElement type() {\n-            return typeDescriptor;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.BOOLEAN;\n-        }\n-    }\n-\n-    \/**\n-     * The cast operation, that can model Java language cast expressions for reference types.\n-     *\/\n-    @OpFactory.OpDeclaration(CastOp.NAME)\n-    public static final class CastOp extends CoreOp\n-            implements Op.Pure, ReflectiveOp, JavaExpression {\n-        public static final String NAME = \"cast\";\n-        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n-\n-        final TypeElement resultType;\n-        final TypeElement typeDescriptor;\n-\n-        public static CastOp create(ExternalizedOp def) {\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n-            }\n-\n-            TypeElement type = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n-                    v -> switch (v) {\n-                        case JavaType td -> td;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n-                    });\n-            return new CastOp(def, type);\n-        }\n-\n-        CastOp(ExternalizedOp def, TypeElement typeDescriptor) {\n-            super(def);\n-\n-            this.resultType = def.resultType();\n-            this.typeDescriptor = typeDescriptor;\n-        }\n-\n-        CastOp(CastOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.resultType = that.resultType;\n-            this.typeDescriptor = that.typeDescriptor;\n-        }\n-\n-        @Override\n-        public CastOp transform(CopyContext cc, OpTransformer ot) {\n-            return new CastOp(this, cc);\n-        }\n-\n-        CastOp(TypeElement resultType, TypeElement t, Value v) {\n-            super(NAME, List.of(v));\n-\n-            this.resultType = resultType;\n-            this.typeDescriptor = t;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", typeDescriptor);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public TypeElement type() {\n-            return typeDescriptor;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * A runtime representation of a variable.\n-     *\n-     * @param <T> the type of the var's value.\n-     * @@@ Ideally should never be exposed\n-     * @@@ Move to interpreter?\n-     *\/\n-    public interface Var<T> {\n-        \/**\n-         * {@return the value of a var}\n-         *\/\n-        T value();\n-\n-        \/**\n-         * Constructs an instance of a var.\n-         *\n-         * @param value the initial value of the var.\n-         * @param <T>   the type of the var's value.\n-         * @return the var\n-         *\/\n-        static <T> Var<T> of(T value) {\n-            return () -> value;\n-        }\n-    }\n-\n-    \/**\n-     * The variable operation, that can model declarations of Java language local variables, method parameters, or\n-     * lambda parameters.\n-     *\/\n-    @OpFactory.OpDeclaration(VarOp.NAME)\n-    public static final class VarOp extends CoreOp\n-            implements JavaStatement {\n-        public static final String NAME = \"var\";\n-        public static final String ATTRIBUTE_NAME = NAME + \".name\";\n-\n-        final String varName;\n-        final VarType resultType;\n-\n-        public static VarOp create(ExternalizedOp def) {\n-            if (def.operands().size() > 1) {\n-                throw new IllegalStateException(\"Operation must have zero or one operand\");\n-            }\n-\n-            String name = def.extractAttributeValue(ATTRIBUTE_NAME, true,\n-                    v -> switch (v) {\n-                        case String s -> s;\n-                        case null -> \"\";\n-                        default -> throw new UnsupportedOperationException(\"Unsupported var name value:\" + v);\n-                    });\n-            return new VarOp(def, name);\n-        }\n-\n-        VarOp(ExternalizedOp def, String varName) {\n-            super(def);\n-\n-            this.varName = varName;\n-            this.resultType = (VarType) def.resultType();\n-        }\n-\n-        VarOp(VarOp that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.varName = that.varName;\n-            this.resultType = that.isResultTypeOverridable()\n-                    ? VarType.varType(initOperand().type()) : that.resultType;\n-        }\n-\n-        boolean isResultTypeOverridable() {\n-            return !isUninitialized() && resultType().valueType().equals(initOperand().type());\n-        }\n-\n-        @Override\n-        public VarOp transform(CopyContext cc, OpTransformer ot) {\n-            return new VarOp(this, cc);\n-        }\n-\n-        VarOp(String varName, Value init) {\n-            this(varName, init.type(), init);\n-        }\n-\n-        VarOp(String varName, TypeElement type, Value init) {\n-            super(NAME, List.of(init));\n-\n-            this.varName =  varName == null ? \"\" : varName;\n-            this.resultType = VarType.varType(type);\n-        }\n-\n-        \/\/ @@@ This and the above constructor can be merged when\n-        \/\/ statements before super can be used in the jdk.compiler module\n-        VarOp(String varName, TypeElement type) {\n-            super(NAME, List.of());\n-\n-            this.varName =  varName == null ? \"\" : varName;\n-            this.resultType = VarType.varType(type);\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            if (isUnnamedVariable()) {\n-                return super.attributes();\n-            }\n-\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", varName);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public Value initOperand() {\n-            if (operands().isEmpty()) {\n-                throw new IllegalStateException(\"Uninitialized variable\");\n-            }\n-            return operands().getFirst();\n-        }\n-\n-        public String varName() {\n-            return varName;\n-        }\n-\n-        public TypeElement varValueType() {\n-            return resultType.valueType();\n-        }\n-\n-        @Override\n-        public VarType resultType() {\n-            return resultType;\n-        }\n-\n-        public boolean isUnnamedVariable() {\n-            return varName.isEmpty();\n-        }\n-\n-        public boolean isUninitialized() {\n-            return operands().isEmpty();\n-        }\n-    }\n-\n-    \/**\n-     * The var access operation, that can model access to Java language local variables, method parameters, or\n-     * lambda parameters.\n-     *\/\n-    public sealed abstract static class VarAccessOp extends CoreOp\n-            implements AccessOp {\n-        VarAccessOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        VarAccessOp(VarAccessOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        VarAccessOp(String name, List<Value> operands) {\n-            super(name, operands);\n-        }\n-\n-        public Value varOperand() {\n-            return operands().getFirst();\n-        }\n-\n-        public VarType varType() {\n-            return (VarType) varOperand().type();\n-        }\n-\n-        public VarOp varOp() {\n-            if (!(varOperand() instanceof Result varValue)) {\n-                throw new IllegalStateException(\"Variable access to block parameter: \" + varOperand());\n-            }\n-\n-            \/\/ At a high-level a variable value can be a BlockArgument.\n-            \/\/ Lowering should remove such cases and the var declaration should emerge\n-            \/\/ This method is primarily used when transforming to pure SSA\n-            return (VarOp) varValue.op();\n-        }\n-\n-        static void checkIsVarOp(Value varValue) {\n-            if (!(varValue.type() instanceof VarType)) {\n-                throw new IllegalArgumentException(\"Value's type is not a variable type: \" + varValue);\n-            }\n-        }\n-\n-        \/**\n-         * The variable load operation, that models a reading variable.\n-         *\/\n-        @OpFactory.OpDeclaration(VarLoadOp.NAME)\n-        public static final class VarLoadOp extends VarAccessOp\n-                implements JavaExpression {\n-            public static final String NAME = \"var.load\";\n-\n-            public VarLoadOp(ExternalizedOp opdef) {\n-                super(opdef);\n-\n-                if (opdef.operands().size() != 1) {\n-                    throw new IllegalArgumentException(\"Operation must have one operand\");\n-                }\n-                checkIsVarOp(opdef.operands().get(0));\n-            }\n-\n-            VarLoadOp(VarLoadOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            VarLoadOp(List<Value> varValue) {\n-                super(NAME, varValue);\n-            }\n-\n-            @Override\n-            public VarLoadOp transform(CopyContext cc, OpTransformer ot) {\n-                return new VarLoadOp(this, cc);\n-            }\n-\n-            \/\/ (Variable)VarType\n-            VarLoadOp(Value varValue) {\n-                super(NAME, List.of(varValue));\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return varType().valueType();\n-            }\n-        }\n-\n-        \/**\n-         * The variable store operation, that can model a variable assignment.\n-         *\/\n-        @OpFactory.OpDeclaration(VarStoreOp.NAME)\n-        public static final class VarStoreOp extends VarAccessOp\n-                implements JavaExpression, JavaStatement {\n-            public static final String NAME = \"var.store\";\n-\n-            public VarStoreOp(ExternalizedOp opdef) {\n-                super(opdef);\n-\n-                if (opdef.operands().size() != 2) {\n-                    throw new IllegalArgumentException(\"Operation must have two operands\");\n-                }\n-                checkIsVarOp(opdef.operands().get(0));\n-            }\n-\n-            VarStoreOp(VarStoreOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            VarStoreOp(List<Value> values) {\n-                super(NAME,\n-                        values);\n-            }\n-\n-            @Override\n-            public VarStoreOp transform(CopyContext cc, OpTransformer ot) {\n-                return new VarStoreOp(this, cc);\n-            }\n-\n-            \/\/ (Variable, VarType)void\n-            VarStoreOp(Value varValue, Value v) {\n-                super(NAME,\n-                        List.of(varValue, v));\n-            }\n-\n-            public Value storeOperand() {\n-                return operands().get(1);\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return JavaType.VOID;\n-            }\n-        }\n-    }\n-\n-    \/\/ Tuple operations, for modelling return with multiple values\n-\n-    \/**\n-     * The tuple operation. A tuple contain a fixed set of values accessible by their component index.\n-     *\/\n-    @OpFactory.OpDeclaration(TupleOp.NAME)\n-    public static final class TupleOp extends CoreOp {\n-        public static final String NAME = \"tuple\";\n-\n-        public TupleOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        TupleOp(TupleOp that, CopyContext cc) {\n-            this(cc.getValues(that.operands()));\n-        }\n-\n-        @Override\n-        public TupleOp transform(CopyContext cc, OpTransformer ot) {\n-            return new TupleOp(this, cc);\n-        }\n-\n-        TupleOp(List<? extends Value> componentValues) {\n-            super(NAME, componentValues);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return TupleType.tupleTypeFromValues(operands());\n-        }\n-    }\n-\n-    \/**\n-     * The tuple component load operation, that access the component of a tuple at a given, constant, component index.\n-     *\/\n-    @OpFactory.OpDeclaration(TupleLoadOp.NAME)\n-    public static final class TupleLoadOp extends CoreOp {\n-        public static final String NAME = \"tuple.load\";\n-        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n-\n-        final int index;\n-\n-        public static TupleLoadOp create(ExternalizedOp def) {\n-            if (def.operands().size() != 1) {\n-                throw new IllegalStateException(\"Operation must have one operand\");\n-            }\n-\n-            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n-                    v -> switch (v) {\n-                        case Integer i -> i;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n-                    });\n-            return new TupleLoadOp(def, index);\n-        }\n-\n-        TupleLoadOp(ExternalizedOp def, int index) {\n-            super(def);\n-\n-            \/\/ @@@ Validate tuple type and index\n-            this.index = index;\n-        }\n-\n-        TupleLoadOp(TupleLoadOp that, CopyContext cc) {\n-            this(that, cc.getValues(that.operands()));\n-        }\n-\n-        TupleLoadOp(TupleLoadOp that, List<Value> values) {\n-            super(NAME, values);\n-\n-            this.index = that.index;\n-        }\n-\n-        @Override\n-        public TupleLoadOp transform(CopyContext cc, OpTransformer ot) {\n-            return new TupleLoadOp(this, cc);\n-        }\n-\n-        TupleLoadOp(Value tupleValue, int index) {\n-            super(NAME, List.of(tupleValue));\n-\n-            this.index = index;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", index);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public int index() {\n-            return index;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            Value tupleValue = operands().get(0);\n-            TupleType t = (TupleType) tupleValue.type();\n-            return t.componentTypes().get(index);\n-        }\n-    }\n-\n-    \/**\n-     * The tuple component set operation, that access the component of a tuple at a given, constant, component index.\n-     *\/\n-    @OpFactory.OpDeclaration(TupleWithOp.NAME)\n-    public static final class TupleWithOp extends CoreOp {\n-        public static final String NAME = \"tuple.with\";\n-        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n-\n-        final int index;\n-\n-        public static TupleWithOp create(ExternalizedOp def) {\n-            if (def.operands().size() != 2) {\n-                throw new IllegalStateException(\"Operation must have two operands\");\n-            }\n-\n-            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n-                    v -> switch (v) {\n-                        case Integer i -> i;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n-                    });\n-            return new TupleWithOp(def, index);\n-        }\n-\n-        TupleWithOp(ExternalizedOp def, int index) {\n-            super(def);\n-\n-            \/\/ @@@ Validate tuple type and index\n-            this.index = index;\n-        }\n-\n-        TupleWithOp(TupleWithOp that, CopyContext cc) {\n-            this(that, cc.getValues(that.operands()));\n-        }\n-\n-        TupleWithOp(TupleWithOp that, List<Value> values) {\n-            super(NAME, values);\n-\n-            this.index = that.index;\n-        }\n-\n-        @Override\n-        public TupleWithOp transform(CopyContext cc, OpTransformer ot) {\n-            return new TupleWithOp(this, cc);\n-        }\n-\n-        TupleWithOp(Value tupleValue, int index, Value value) {\n-            super(NAME, List.of(tupleValue, value));\n-\n-            \/\/ @@@ Validate tuple type and index\n-            this.index = index;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", index);\n-            return Collections.unmodifiableMap(m);\n-        }\n-\n-        public int index() {\n-            return index;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            Value tupleValue = operands().get(0);\n-            TupleType tupleType = (TupleType) tupleValue.type();\n-            Value value = operands().get(2);\n-\n-            List<TypeElement> tupleComponentTypes = new ArrayList<>(tupleType.componentTypes());\n-            tupleComponentTypes.set(index, value.type());\n-            return TupleType.tupleType(tupleComponentTypes);\n-        }\n-    }\n-\n-    \/**\n-     * The exception region start operation.\n-     *\/\n-    @OpFactory.OpDeclaration(ExceptionRegionEnter.NAME)\n-    public static final class ExceptionRegionEnter extends CoreOp\n-            implements Op.BlockTerminating {\n-        public static final String NAME = \"exception.region.enter\";\n-\n-        \/\/ First successor is the non-exceptional successor whose target indicates\n-        \/\/ the first block in the exception region.\n-        \/\/ One or more subsequent successors target the exception catching blocks\n-        \/\/ each of which have one block argument whose type is an exception type.\n-        final List<Block.Reference> s;\n-\n-        public ExceptionRegionEnter(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.successors().size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n-            }\n-\n-            this.s = List.copyOf(def.successors());\n-        }\n-\n-        ExceptionRegionEnter(ExceptionRegionEnter that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n-        }\n-\n-        @Override\n-        public ExceptionRegionEnter transform(CopyContext cc, OpTransformer ot) {\n-            return new ExceptionRegionEnter(this, cc);\n-        }\n-\n-        ExceptionRegionEnter(List<Block.Reference> s) {\n-            super(NAME, List.of());\n-\n-            if (s.size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n-            }\n-\n-            this.s = List.copyOf(s);\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return s;\n-        }\n-\n-        public Block.Reference start() {\n-            return s.get(0);\n-        }\n-\n-        public List<Block.Reference> catchBlocks() {\n-            return s.subList(1, s.size());\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The exception region end operation.\n-     *\/\n-    @OpFactory.OpDeclaration(ExceptionRegionExit.NAME)\n-    public static final class ExceptionRegionExit extends CoreOp\n-            implements Op.BlockTerminating {\n-        public static final String NAME = \"exception.region.exit\";\n-\n-        \/\/ First successor is the non-exceptional successor whose target indicates\n-        \/\/ the first block following the exception region.\n-        final List<Block.Reference> s;\n-\n-        public ExceptionRegionExit(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.successors().size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n-            }\n-\n-            this.s = List.copyOf(def.successors());\n-        }\n-\n-        ExceptionRegionExit(ExceptionRegionExit that, CopyContext cc) {\n-            super(that, cc);\n-\n-            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n-        }\n-\n-        @Override\n-        public ExceptionRegionExit transform(CopyContext cc, OpTransformer ot) {\n-            return new ExceptionRegionExit(this, cc);\n-        }\n-\n-        ExceptionRegionExit(List<Block.Reference> s) {\n-            super(NAME, List.of());\n-\n-            if (s.size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n-            }\n-\n-            this.s = List.copyOf(s);\n-        }\n-\n-        @Override\n-        public List<Block.Reference> successors() {\n-            return s;\n-        }\n-\n-        public Block.Reference end() {\n-            return s.get(0);\n-        }\n-\n-        public List<Block.Reference> catchBlocks() {\n-            return s.subList(1, s.size());\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The String Concatenation Operation\n-     *\/\n-\n-    @OpFactory.OpDeclaration(ConcatOp.NAME)\n-    public static final class ConcatOp extends CoreOp\n-            implements Op.Pure, JavaExpression {\n-        public static final String NAME = \"concat\";\n-\n-        public ConcatOp(ConcatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        public ConcatOp(ExternalizedOp def) {\n-            super(def);\n-            if (def.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Concatenation Operation must have two operands.\");\n-            }\n-        }\n-\n-        public ConcatOp(Value lhs, Value rhs) {\n-            super(ConcatOp.NAME, List.of(lhs, rhs));\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new ConcatOp(this, cc);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.J_L_STRING;\n-        }\n-    }\n-\n-    \/\/\n-    \/\/ Arithmetic ops\n-\n-    \/**\n-     * The arithmetic operation.\n-     *\/\n-    public sealed static abstract class ArithmeticOperation extends CoreOp\n-            implements Op.Pure, JavaExpression {\n-        protected ArithmeticOperation(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().isEmpty()) {\n-                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n-            }\n-        }\n-\n-        protected ArithmeticOperation(ArithmeticOperation that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        protected ArithmeticOperation(String name, List<Value> operands) {\n-            super(name, operands);\n-        }\n-    }\n-\n-    \/**\n-     * The test operation.\n-     *\/\n-    public sealed static abstract class TestOperation extends CoreOp\n-            implements Op.Pure, JavaExpression {\n-        protected TestOperation(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().isEmpty()) {\n-                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n-            }\n-        }\n-\n-        protected TestOperation(TestOperation that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        protected TestOperation(String name, List<Value> operands) {\n-            super(name, operands);\n-        }\n-    }\n-\n-    \/**\n-     * The binary arithmetic operation.\n-     *\/\n-    public sealed static abstract class BinaryOp extends ArithmeticOperation {\n-        protected BinaryOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n-            }\n-        }\n-\n-        protected BinaryOp(BinaryOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        protected BinaryOp(String name, Value lhs, Value rhs) {\n-            super(name, List.of(lhs, rhs));\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return operands().get(0).type();\n-        }\n-    }\n-\n-    \/**\n-     * The unary arithmetic operation.\n-     *\/\n-    public sealed static abstract class UnaryOp extends ArithmeticOperation {\n-        protected UnaryOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n-            }\n-        }\n-\n-        protected UnaryOp(UnaryOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        protected UnaryOp(String name, Value v) {\n-            super(name, List.of(v));\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return operands().get(0).type();\n-        }\n-    }\n-\n-    \/**\n-     * The binary test operation.\n-     *\/\n-    public sealed static abstract class BinaryTestOp extends TestOperation {\n-        protected BinaryTestOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n-            }\n-        }\n-\n-        protected BinaryTestOp(BinaryTestOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        protected BinaryTestOp(String name, Value lhs, Value rhs) {\n-            super(name, List.of(lhs, rhs));\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return JavaType.BOOLEAN;\n-        }\n-    }\n-\n-    \/**\n-     * The add operation, that can model the Java language binary {@code +} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(AddOp.NAME)\n-    public static final class AddOp extends BinaryOp {\n-        public static final String NAME = \"add\";\n-\n-        public AddOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        AddOp(AddOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public AddOp transform(CopyContext cc, OpTransformer ot) {\n-            return new AddOp(this, cc);\n-        }\n-\n-        AddOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The sub operation, that can model the Java language binary {@code -} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(SubOp.NAME)\n-    public static final class SubOp extends BinaryOp {\n-        public static final String NAME = \"sub\";\n-\n-        public SubOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        SubOp(SubOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public SubOp transform(CopyContext cc, OpTransformer ot) {\n-            return new SubOp(this, cc);\n-        }\n-\n-        SubOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The mul operation, that can model the Java language binary {@code *} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(MulOp.NAME)\n-    public static final class MulOp extends BinaryOp {\n-        public static final String NAME = \"mul\";\n-\n-        public MulOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        MulOp(MulOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public MulOp transform(CopyContext cc, OpTransformer ot) {\n-            return new MulOp(this, cc);\n-        }\n-\n-        MulOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The div operation, that can model the Java language binary {@code \/} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(DivOp.NAME)\n-    public static final class DivOp extends BinaryOp {\n-        public static final String NAME = \"div\";\n-\n-        public DivOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        DivOp(DivOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public DivOp transform(CopyContext cc, OpTransformer ot) {\n-            return new DivOp(this, cc);\n-        }\n-\n-        DivOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The mod operation, that can model the Java language binary {@code %} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(ModOp.NAME)\n-    public static final class ModOp extends BinaryOp {\n-        public static final String NAME = \"mod\";\n-\n-        public ModOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        ModOp(ModOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ModOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ModOp(this, cc);\n-        }\n-\n-        ModOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The bitwise\/logical or operation, that can model the Java language binary {@code |} operator for integral types\n-     * and booleans\n-     *\/\n-    @OpFactory.OpDeclaration(OrOp.NAME)\n-    public static final class OrOp extends BinaryOp {\n-        public static final String NAME = \"or\";\n-\n-        public OrOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        OrOp(OrOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public OrOp transform(CopyContext cc, OpTransformer ot) {\n-            return new OrOp(this, cc);\n-        }\n-\n-        OrOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The bitwise\/logical and operation, that can model the Java language binary {@code &} operator for integral types\n-     * and booleans\n-     *\/\n-    @OpFactory.OpDeclaration(AndOp.NAME)\n-    public static final class AndOp extends BinaryOp {\n-        public static final String NAME = \"and\";\n-\n-        public AndOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        AndOp(AndOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public AndOp transform(CopyContext cc, OpTransformer ot) {\n-            return new AndOp(this, cc);\n-        }\n-\n-        AndOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The xor operation, that can model the Java language binary {@code ^} operator for integral types\n-     * and booleans\n-     *\/\n-    @OpFactory.OpDeclaration(XorOp.NAME)\n-    public static final class XorOp extends BinaryOp {\n-        public static final String NAME = \"xor\";\n-\n-        public XorOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        XorOp(XorOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public XorOp transform(CopyContext cc, OpTransformer ot) {\n-            return new XorOp(this, cc);\n-        }\n-\n-        XorOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The (logical) shift left operation, that can model the Java language binary {@code <<} operator for integral types\n-     *\/\n-    @OpFactory.OpDeclaration(LshlOp.NAME)\n-    public static final class LshlOp extends BinaryOp {\n-        public static final String NAME = \"lshl\";\n-\n-        public LshlOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        LshlOp(LshlOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public LshlOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LshlOp(this, cc);\n-        }\n-\n-        LshlOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The (arithmetic) shift right operation, that can model the Java language binary {@code >>} operator for integral types\n-     *\/\n-    @OpFactory.OpDeclaration(AshrOp.NAME)\n-    public static final class AshrOp extends CoreOp.BinaryOp {\n-        public static final String NAME = \"ashr\";\n-\n-        public AshrOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        AshrOp(AshrOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public AshrOp transform(CopyContext cc, OpTransformer ot) {\n-            return new AshrOp(this, cc);\n-        }\n-\n-        AshrOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The unsigned (logical) shift right operation, that can model the Java language binary {@code >>>} operator for integral types\n-     *\/\n-    @OpFactory.OpDeclaration(LshrOp.NAME)\n-    public static final class LshrOp extends CoreOp.BinaryOp {\n-        public static final String NAME = \"lshr\";\n-\n-        public LshrOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        LshrOp(LshrOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public LshrOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LshrOp(this, cc);\n-        }\n-\n-        LshrOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The neg operation, that can model the Java language unary {@code -} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(NegOp.NAME)\n-    public static final class NegOp extends UnaryOp {\n-        public static final String NAME = \"neg\";\n-\n-        public NegOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        NegOp(NegOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public NegOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NegOp(this, cc);\n-        }\n-\n-        NegOp(Value v) {\n-            super(NAME, v);\n-        }\n-    }\n-\n-    \/**\n-     * The bitwise complement operation, that can model the Java language unary {@code ~} operator for integral types\n-     *\/\n-    @OpFactory.OpDeclaration(ComplOp.NAME)\n-    public static final class ComplOp extends UnaryOp {\n-        public static final String NAME = \"compl\";\n-\n-        public ComplOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        ComplOp(ComplOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public ComplOp transform(CopyContext cc, OpTransformer ot) {\n-            return new ComplOp(this, cc);\n-        }\n-\n-        ComplOp(Value v) {\n-            super(NAME, v);\n-        }\n-    }\n-\n-    \/**\n-     * The not operation, that can model the Java language unary {@code !} operator for boolean types\n-     *\/\n-    @OpFactory.OpDeclaration(NotOp.NAME)\n-    public static final class NotOp extends UnaryOp {\n-        public static final String NAME = \"not\";\n-\n-        public NotOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        NotOp(NotOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public NotOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NotOp(this, cc);\n-        }\n-\n-        NotOp(Value v) {\n-            super(NAME, v);\n-        }\n-    }\n-\n-    \/**\n-     * The equals operation, that can model the Java language equality {@code ==} operator for numeric, boolean\n-     * and reference types\n-     *\/\n-    @OpFactory.OpDeclaration(EqOp.NAME)\n-    public static final class EqOp extends BinaryTestOp {\n-        public static final String NAME = \"eq\";\n-\n-        public EqOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        EqOp(EqOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public EqOp transform(CopyContext cc, OpTransformer ot) {\n-            return new EqOp(this, cc);\n-        }\n-\n-        EqOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The not equals operation, that can model the Java language equality {@code !=} operator for numeric, boolean\n-     * and reference types\n-     *\/\n-    @OpFactory.OpDeclaration(NeqOp.NAME)\n-    public static final class NeqOp extends BinaryTestOp {\n-        public static final String NAME = \"neq\";\n-\n-        public NeqOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        NeqOp(NeqOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public NeqOp transform(CopyContext cc, OpTransformer ot) {\n-            return new NeqOp(this, cc);\n-        }\n-\n-        NeqOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The greater than operation, that can model the Java language relational {@code >} operator for numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(GtOp.NAME)\n-    public static final class GtOp extends BinaryTestOp {\n-        public static final String NAME = \"gt\";\n-\n-        public GtOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        GtOp(GtOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public GtOp transform(CopyContext cc, OpTransformer ot) {\n-            return new GtOp(this, cc);\n-        }\n-\n-        GtOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The greater than or equal to operation, that can model the Java language relational {@code >=} operator for\n-     * numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(GeOp.NAME)\n-    public static final class GeOp extends BinaryTestOp {\n-        public static final String NAME = \"ge\";\n-\n-        public GeOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        GeOp(GeOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public GeOp transform(CopyContext cc, OpTransformer ot) {\n-            return new GeOp(this, cc);\n-        }\n-\n-        GeOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The less than operation, that can model the Java language relational {@code <} operator for\n-     * numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(LtOp.NAME)\n-    public static final class LtOp extends BinaryTestOp {\n-        public static final String NAME = \"lt\";\n-\n-        public LtOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        LtOp(LtOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public LtOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LtOp(this, cc);\n-        }\n-\n-        LtOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-    \/**\n-     * The less than or equal to operation, that can model the Java language relational {@code <=} operator for\n-     * numeric types\n-     *\/\n-    @OpFactory.OpDeclaration(LeOp.NAME)\n-    public static final class LeOp extends BinaryTestOp {\n-        public static final String NAME = \"le\";\n-\n-        public LeOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n-        LeOp(LeOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public LeOp transform(CopyContext cc, OpTransformer ot) {\n-            return new LeOp(this, cc);\n-        }\n-\n-        LeOp(Value lhs, Value rhs) {\n-            super(NAME, lhs, rhs);\n-        }\n-    }\n-\n-\n-    \/**\n-     * A factory for core operations.\n-     *\/\n-    \/\/ @@@ Compute lazily\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(CoreOp.class);\n-\n-    \/**\n-     * Creates a function operation builder\n-     *\n-     * @param funcName the function name\n-     * @param funcType the function type\n-     * @return the function operation builder\n-     *\/\n-    public static FuncOp.Builder func(String funcName, FunctionType funcType) {\n-        return new FuncOp.Builder(null, funcName, funcType);\n-    }\n-\n-    \/**\n-     * Creates a function operation\n-     *\n-     * @param funcName the function name\n-     * @param body     the function body\n-     * @return the function operation\n-     *\/\n-    public static FuncOp func(String funcName, Body.Builder body) {\n-        return new FuncOp(funcName, body);\n-    }\n-\n-    \/**\n-     * Creates a function call operation\n-     *\n-     * @param funcName the name of the function operation\n-     * @param funcType the function type\n-     * @param args     the function arguments\n-     * @return the function call operation\n-     *\/\n-    public static FuncCallOp funcCall(String funcName, FunctionType funcType, Value... args) {\n-        return funcCall(funcName, funcType, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates a function call operation\n-     *\n-     * @param funcName the name of the function operation\n-     * @param funcType the function type\n-     * @param args     the function arguments\n-     * @return the function call operation\n-     *\/\n-    public static FuncCallOp funcCall(String funcName, FunctionType funcType, List<Value> args) {\n-        return new FuncCallOp(funcName, funcType.returnType(), args);\n-    }\n-\n-    \/**\n-     * Creates a function call operation\n-     *\n-     * @param func the target function\n-     * @param args the function arguments\n-     * @return the function call operation\n-     *\/\n-    public static FuncCallOp funcCall(FuncOp func, Value... args) {\n-        return funcCall(func, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates a function call operation\n-     *\n-     * @param func the target function\n-     * @param args the function argments\n-     * @return the function call operation\n-     *\/\n-    public static FuncCallOp funcCall(FuncOp func, List<Value> args) {\n-        return new FuncCallOp(func.funcName(), func.invokableType().returnType(), args);\n-    }\n-\n-    \/**\n-     * Creates a module operation.\n-     *\n-     * @param functions the functions of the module operation\n-     * @return the module operation\n-     *\/\n-    public static ModuleOp module(FuncOp... functions) {\n-        return module(List.of(functions));\n-    }\n-\n-    \/**\n-     * Creates a module operation.\n-     *\n-     * @param functions the functions of the module operation\n-     * @return the module operation\n-     *\/\n-    public static ModuleOp module(List<FuncOp> functions) {\n-        return new ModuleOp(List.copyOf(functions));\n-    }\n-\n-    \/**\n-     * Creates a quoted operation.\n-     *\n-     * @param ancestorBody the ancestor of the body of the quoted operation\n-     * @param opFunc       a function that accepts the body of the quoted operation and returns the operation to be quoted\n-     * @return the quoted operation\n-     *\/\n-    public static QuotedOp quoted(Body.Builder ancestorBody,\n-                                  Function<Block.Builder, Op> opFunc) {\n-        Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n-        Block.Builder block = body.entryBlock();\n-        block.op(_yield(\n-                block.op(opFunc.apply(block))));\n-        return new QuotedOp(body);\n-    }\n-\n-    \/**\n-     * Creates a quoted operation.\n-     *\n-     * @param body quoted operation body\n-     * @return the quoted operation\n-     *\/\n-    public static QuotedOp quoted(Body.Builder body) {\n-        return new QuotedOp(body);\n-    }\n-\n-    \/**\n-     * Creates a lambda operation.\n-     *\n-     * @param ancestorBody        the ancestor of the body of the lambda operation\n-     * @param funcType            the lambda operation's function type\n-     * @param functionalInterface the lambda operation's functional interface type\n-     * @return the lambda operation\n-     *\/\n-    public static LambdaOp.Builder lambda(Body.Builder ancestorBody,\n-                                          FunctionType funcType, TypeElement functionalInterface) {\n-        return new LambdaOp.Builder(ancestorBody, funcType, functionalInterface);\n-    }\n-\n-    \/**\n-     * Creates a lambda operation.\n-     *\n-     * @param functionalInterface the lambda operation's functional interface type\n-     * @param body                the body of the lambda operation\n-     * @return the lambda operation\n-     *\/\n-    public static LambdaOp lambda(TypeElement functionalInterface, Body.Builder body) {\n-        return new LambdaOp(functionalInterface, body);\n-    }\n-\n-    \/**\n-     * Creates a closure operation.\n-     *\n-     * @param ancestorBody the ancestor of the body of the closure operation\n-     * @param funcType     the closure operation's function type\n-     * @return the closure operation\n-     *\/\n-    public static ClosureOp.Builder closure(Body.Builder ancestorBody,\n-                                            FunctionType funcType) {\n-        return new ClosureOp.Builder(ancestorBody, funcType);\n-    }\n-\n-    \/**\n-     * Creates a closure operation.\n-     *\n-     * @param body the body of the closure operation\n-     * @return the closure operation\n-     *\/\n-    public static ClosureOp closure(Body.Builder body) {\n-        return new ClosureOp(body);\n-    }\n-\n-    \/**\n-     * Creates a closure call operation.\n-     *\n-     * @param args the closure arguments. The first argument is the closure operation to be called\n-     * @return the closure call operation\n-     *\/\n-    \/\/ @@@: Is this the right signature?\n-    public static ClosureCallOp closureCall(Value... args) {\n-        return closureCall(List.of(args));\n-    }\n-\n-    \/**\n-     * Creates a closure call operation.\n-     *\n-     * @param args the closure arguments. The first argument is the closure operation to be called\n-     * @return the closure call operation\n-     *\/\n-    \/\/ @@@: Is this the right signature?\n-    public static ClosureCallOp closureCall(List<Value> args) {\n-        return new ClosureCallOp(args);\n-    }\n-\n-    \/**\n-     * Creates an exception region enter operation\n-     *\n-     * @param start    the exception region block\n-     * @param catchers the blocks handling exceptions thrown by the region block\n-     * @return the exception region enter operation\n-     *\/\n-    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, Block.Reference... catchers) {\n-        return exceptionRegionEnter(start, List.of(catchers));\n-    }\n-\n-    \/**\n-     * Creates an exception region enter operation\n-     *\n-     * @param start    the exception region block\n-     * @param catchers the blocks handling exceptions thrown by the region block\n-     * @return the exception region enter operation\n-     *\/\n-    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, List<Block.Reference> catchers) {\n-        List<Block.Reference> s = new ArrayList<>();\n-        s.add(start);\n-        s.addAll(catchers);\n-        return new ExceptionRegionEnter(s);\n-    }\n-\n-    \/**\n-     * Creates an exception region exit operation\n-     *\n-     * @param end             the block to which control is transferred after the exception region is exited\n-     * @param catchers the blocks handling exceptions thrown by the region block\n-     * @return the exception region exit operation\n-     *\/\n-    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, Block.Reference... catchers) {\n-        return exceptionRegionExit(end, List.of(catchers));\n-    }\n-\n-    \/**\n-     * Creates an exception region exit operation\n-     *\n-     * @param end             the block to which control is transferred after the exception region is exited\n-     * @param catchers the blocks handling exceptions thrown by the region block\n-     * @return the exception region exit operation\n-     *\/\n-    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, List<Block.Reference> catchers) {\n-        List<Block.Reference> s = new ArrayList<>();\n-        s.add(end);\n-        s.addAll(catchers);\n-        return new ExceptionRegionExit(s);\n-    }\n-\n-    \/**\n-     * Creates a return operation.\n-     *\n-     * @return the return operation\n-     *\/\n-    public static ReturnOp _return() {\n-        return new ReturnOp();\n-    }\n-\n-    \/**\n-     * Creates a return operation.\n-     *\n-     * @param returnValue the return value\n-     * @return the return operation\n-     *\/\n-    public static ReturnOp _return(Value returnValue) {\n-        return new ReturnOp(returnValue);\n-    }\n-\n-    \/**\n-     * Creates a throw operation.\n-     *\n-     * @param exceptionValue the thrown value\n-     * @return the throw operation\n-     *\/\n-    public static ThrowOp _throw(Value exceptionValue) {\n-        return new ThrowOp(exceptionValue);\n-    }\n-\n-    \/**\n-     * Creates an unreachable operation.\n-     *\n-     * @return the unreachable operation\n-     *\/\n-    public static UnreachableOp unreachable() {\n-        return new UnreachableOp();\n-    }\n-\n-    \/**\n-     * Creates a yield operation.\n-     *\n-     * @return the yield operation\n-     *\/\n-    public static YieldOp _yield() {\n-        return new YieldOp();\n-    }\n-\n-    \/**\n-     * Creates a yield operation.\n-     *\n-     * @param yieldValue the yielded value\n-     * @return the yield operation\n-     *\/\n-    public static YieldOp _yield(Value yieldValue) {\n-        return new YieldOp(List.of(yieldValue));\n-    }\n-\n-    \/**\n-     * Creates an assert operation.\n-     *\n-     * @param bodies the nested bodies\n-     * @return the assert operation\n-     *\/\n-    public static AssertOp _assert(List<Body.Builder> bodies) {\n-        return new AssertOp(bodies);\n-    }\n-\n-    public static MonitorOp.MonitorEnterOp monitorEnter(Value monitor) {\n-        return new MonitorOp.MonitorEnterOp(monitor);\n-    }\n-\n-    public static MonitorOp.MonitorExitOp monitorExit(Value monitor) {\n-        return new MonitorOp.MonitorExitOp(monitor);\n-    }\n-\n-    \/**\n-     * Creates an unconditional break operation.\n-     *\n-     * @param target the jump target\n-     * @return the unconditional break operation\n-     *\/\n-    public static BranchOp branch(Block.Reference target) {\n-        return new BranchOp(target);\n-    }\n-\n-    \/**\n-     * Creates a conditional break operation.\n-     *\n-     * @param condValue   the test value of the conditional break operation\n-     * @param trueTarget  the jump target when the test value evaluates to true\n-     * @param falseTarget the jump target when the test value evaluates to false\n-     * @return the conditional break operation\n-     *\/\n-    public static ConditionalBranchOp conditionalBranch(Value condValue,\n-                                                        Block.Reference trueTarget, Block.Reference falseTarget) {\n-        return new ConditionalBranchOp(condValue, trueTarget, falseTarget);\n-    }\n-\n-    \/**\n-     * Creates a constant operation.\n-     *\n-     * @param type  the constant type\n-     * @param value the constant value\n-     * @return the constant operation\n-     *\/\n-    public static ConstantOp constant(TypeElement type, Object value) {\n-        return new ConstantOp(type, value);\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     * <p>\n-     * The invoke return type is the invoke descriptors return type.\n-     *\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke parameters\n-     * @return the invoke operation\n-     *\/\n-    public static InvokeOp invoke(MethodRef invokeDescriptor, Value... args) {\n-        return invoke(invokeDescriptor, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     * <p>\n-     * The invoke return type is the invoke descriptors return type.\n-     *\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n-     * @return the invoke operation\n-     *\/\n-    public static InvokeOp invoke(MethodRef invokeDescriptor, List<Value> args) {\n-        return invoke(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     *\n-     * @param returnType       the invoke return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n-     * @return the invoke operation\n-     *\/\n-    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, Value... args) {\n-        return invoke(returnType, invokeDescriptor, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     *\n-     * @param returnType       the invoke return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n-     * @return the invoke super operation\n-     *\/\n-    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        int paramCount = invokeDescriptor.type().parameterTypes().size();\n-        int argCount = args.size();\n-        InvokeOp.InvokeKind ik = (argCount == paramCount + 1)\n-                ? InvokeOp.InvokeKind.INSTANCE\n-                : InvokeOp.InvokeKind.STATIC;\n-        return new InvokeOp(ik, false, returnType, invokeDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modelling an invocation to a method.\n-     *\n-     * @param invokeKind       the invoke kind\n-     * @param isVarArgs        true if an invocation to a variable argument method\n-     * @param returnType       the return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n-     * @return the invoke operation\n-     * @throws IllegalArgumentException if there is a mismatch between the argument count\n-     *                                  and the invoke descriptors parameter count.\n-     *\/\n-    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n-                                  TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates a conversion operation.\n-     *\n-     * @param to   the conversion target type\n-     * @param from the value to be converted\n-     * @return the conversion operation\n-     *\/\n-    public static ConvOp conv(TypeElement to, Value from) {\n-        return new ConvOp(to, from);\n-    }\n-\n-    \/**\n-     * Creates an instance creation operation.\n-     *\n-     * @param constructorDescriptor the constructor descriptor\n-     * @param args            the constructor arguments\n-     * @return the instance creation operation\n-     *\/\n-    public static NewOp _new(ConstructorRef constructorDescriptor, Value... args) {\n-        return _new(constructorDescriptor, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates an instance creation operation.\n-     *\n-     * @param constructorDescriptor the constructor descriptor\n-     * @param args            the constructor arguments\n-     * @return the instance creation operation\n-     *\/\n-    public static NewOp _new(ConstructorRef constructorDescriptor, List<Value> args) {\n-        return new NewOp(false, constructorDescriptor.refType(), constructorDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates an instance creation operation.\n-     *\n-     * @param returnType      the instance type\n-     * @param constructorDescriptor the constructor descriptor\n-     * @param args            the constructor arguments\n-     * @return the instance creation operation\n-     *\/\n-    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n-                             Value... args) {\n-        return _new(returnType, constructorDescriptor, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates an instance creation operation.\n-     *\n-     * @param returnType      the instance type\n-     * @param constructorDescriptor the constructor descriptor\n-     * @param args            the constructor arguments\n-     * @return the instance creation operation\n-     *\/\n-    public static NewOp _new(TypeElement returnType, ConstructorRef constructorDescriptor,\n-                             List<Value> args) {\n-        return new NewOp(false, returnType, constructorDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates an instance creation operation.\n-     *\n-     * @param returnType      the instance type\n-     * @param constructorDescriptor the constructor descriptor\n-     * @param args            the constructor arguments\n-     * @return the instance creation operation\n-     *\/\n-    public static NewOp _new(boolean isVarargs, TypeElement returnType, ConstructorRef constructorDescriptor,\n-                             List<Value> args) {\n-        return new NewOp(isVarargs, returnType, constructorDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates an array creation operation.\n-     *\n-     * @param arrayType the array type\n-     * @param length    the array size\n-     * @return the array creation operation\n-     *\/\n-    public static NewOp newArray(TypeElement arrayType, Value length) {\n-        ConstructorRef constructorDescriptor = ConstructorRef.constructor(arrayType, JavaType.INT);\n-        return _new(constructorDescriptor, length);\n-    }\n-\n-    \/\/ @@@ Add field load\/store overload with explicit fieldType\n-\n-    \/**\n-     * Creates a field load operation to a non-static field.\n-     *\n-     * @param descriptor the field descriptor\n-     * @param receiver   the receiver value\n-     * @return the field load operation\n-     *\/\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor, Value receiver) {\n-        return new FieldAccessOp.FieldLoadOp(descriptor.type(), descriptor, receiver);\n-    }\n-\n-    \/**\n-     * Creates a field load operation to a non-static field.\n-     *\n-     * @param resultType the result type of the operation\n-     * @param descriptor the field descriptor\n-     * @param receiver   the receiver value\n-     * @return the field load operation\n-     *\/\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor, Value receiver) {\n-        return new FieldAccessOp.FieldLoadOp(resultType, descriptor, receiver);\n-    }\n-\n-    \/**\n-     * Creates a field load operation to a static field.\n-     *\n-     * @param descriptor the field descriptor\n-     * @return the field load operation\n-     *\/\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor) {\n-        return new FieldAccessOp.FieldLoadOp(descriptor.type(), descriptor);\n-    }\n-\n-    \/**\n-     * Creates a field load operation to a static field.\n-     *\n-     * @param resultType the result type of the operation\n-     * @param descriptor the field descriptor\n-     * @return the field load operation\n-     *\/\n-    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor) {\n-        return new FieldAccessOp.FieldLoadOp(resultType, descriptor);\n-    }\n-\n-    \/**\n-     * Creates a field store operation to a non-static field.\n-     *\n-     * @param descriptor the field descriptor\n-     * @param receiver   the receiver value\n-     * @param v          the value to store\n-     * @return the field store operation\n-     *\/\n-    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value receiver, Value v) {\n-        return new FieldAccessOp.FieldStoreOp(descriptor, receiver, v);\n-    }\n-\n-    \/**\n-     * Creates a field load operation to a static field.\n-     *\n-     * @param descriptor the field descriptor\n-     * @param v          the value to store\n-     * @return the field store operation\n-     *\/\n-    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value v) {\n-        return new FieldAccessOp.FieldStoreOp(descriptor, v);\n-    }\n-\n-    \/**\n-     * Creates an array length operation.\n-     *\n-     * @param array the array value\n-     * @return the array length operation\n-     *\/\n-    public static ArrayLengthOp arrayLength(Value array) {\n-        return new ArrayLengthOp(array);\n-    }\n-\n-    \/**\n-     * Creates an array load operation.\n-     *\n-     * @param array the array value\n-     * @param index the index value\n-     * @return the array load operation\n-     *\/\n-    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index) {\n-        return new ArrayAccessOp.ArrayLoadOp(array, index);\n-    }\n-\n-    \/**\n-     * Creates an array load operation.\n-     *\n-     * @param array the array value\n-     * @param index the index value\n-     * @param componentType type of the array component\n-     * @return the array load operation\n-     *\/\n-    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index, TypeElement componentType) {\n-        return new ArrayAccessOp.ArrayLoadOp(array, index, componentType);\n-    }\n-\n-    \/**\n-     * Creates an array store operation.\n-     *\n-     * @param array the array value\n-     * @param index the index value\n-     * @param v     the value to store\n-     * @return the array store operation\n-     *\/\n-    public static ArrayAccessOp.ArrayStoreOp arrayStoreOp(Value array, Value index, Value v) {\n-        return new ArrayAccessOp.ArrayStoreOp(array, index, v);\n-    }\n-\n-    \/**\n-     * Creates an instanceof operation.\n-     *\n-     * @param t the type to test against\n-     * @param v the value to test\n-     * @return the instanceof operation\n-     *\/\n-    public static InstanceOfOp instanceOf(TypeElement t, Value v) {\n-        return new InstanceOfOp(t, v);\n-    }\n-\n-    \/**\n-     * Creates a cast operation.\n-     *\n-     * @param resultType the result type of the operation\n-     * @param v          the value to cast\n-     * @return the cast operation\n-     *\/\n-    public static CastOp cast(TypeElement resultType, Value v) {\n-        return new CastOp(resultType, resultType, v);\n-    }\n-\n-    \/**\n-     * Creates a cast operation.\n-     *\n-     * @param resultType the result type of the operation\n-     * @param t          the type to cast to\n-     * @param v          the value to cast\n-     * @return the cast operation\n-     *\/\n-    public static CastOp cast(TypeElement resultType, JavaType t, Value v) {\n-        return new CastOp(resultType, t, v);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an unnamed and uninitialized variable,\n-     * either an unnamed local variable or an unnamed parameter.\n-     *\n-     * @param type the type of the var's value\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(TypeElement type) {\n-        return var(null, type);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an uninitialized variable, either a local variable or a parameter.\n-     *\n-     * @param name the name of the var\n-     * @param type the type of the var's value\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(String name, TypeElement type) {\n-        return new VarOp(name, type);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an unnamed variable, either an unnamed local variable or an unnamed parameter.\n-     *\n-     * @param init the initial value of the var\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(Value init) {\n-        return var(null, init);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling a variable, either a local variable or a parameter.\n-     * <p>\n-     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n-     *\n-     * @param name the name of the var\n-     * @param init the initial value of the var\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(String name, Value init) {\n-        return new VarOp(name, init);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling a variable, either a local variable or a parameter.\n-     * <p>\n-     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n-     *\n-     * @param name the name of the var\n-     * @param type the type of the var's value\n-     * @param init the initial value of the var\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(String name, TypeElement type, Value init) {\n-        return new VarOp(name, type, init);\n-    }\n-\n-    \/**\n-     * Creates a var load operation.\n-     *\n-     * @param varValue the var value\n-     * @return the var load operation\n-     *\/\n-    public static VarAccessOp.VarLoadOp varLoad(Value varValue) {\n-        return new VarAccessOp.VarLoadOp(varValue);\n-    }\n-\n-    \/**\n-     * Creates a var store operation.\n-     *\n-     * @param varValue the var value\n-     * @param v        the value to store in the var\n-     * @return the var store operation\n-     *\/\n-    public static VarAccessOp.VarStoreOp varStore(Value varValue, Value v) {\n-        return new VarAccessOp.VarStoreOp(varValue, v);\n-    }\n-\n-    \/**\n-     * Creates a tuple operation.\n-     *\n-     * @param componentValues the values of tuple (in order)\n-     * @return the tuple operation\n-     *\/\n-    public static TupleOp tuple(Value... componentValues) {\n-        return tuple(List.of(componentValues));\n-    }\n-\n-    \/**\n-     * Creates a tuple operation.\n-     *\n-     * @param componentValues the values of tuple (in order)\n-     * @return the tuple operation\n-     *\/\n-    public static TupleOp tuple(List<? extends Value> componentValues) {\n-        return new TupleOp(componentValues);\n-    }\n-\n-    \/**\n-     * Creates a tuple load operation.\n-     *\n-     * @param tuple the tuple value\n-     * @param index the component index value\n-     * @return the tuple load operation\n-     *\/\n-    public static TupleLoadOp tupleLoad(Value tuple, int index) {\n-        return new TupleLoadOp(tuple, index);\n-    }\n-\n-    \/**\n-     * Creates a tuple with operation.\n-     *\n-     * @param tuple the tuple value\n-     * @param index the component index value\n-     * @param value the component value\n-     * @return the tuple with operation\n-     *\/\n-    public static TupleWithOp tupleWith(Value tuple, int index, Value value) {\n-        return new TupleWithOp(tuple, index, value);\n-    }\n-\n-    \/\/\n-    \/\/ Arithmetic ops\n-\n-    \/**\n-     * Creates an add operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the add operation\n-     *\/\n-    public static BinaryOp add(Value lhs, Value rhs) {\n-        return new AddOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a sub operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the sub operation\n-     *\/\n-    public static BinaryOp sub(Value lhs, Value rhs) {\n-        return new SubOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a mul operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the mul operation\n-     *\/\n-    public static BinaryOp mul(Value lhs, Value rhs) {\n-        return new MulOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a div operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the div operation\n-     *\/\n-    public static BinaryOp div(Value lhs, Value rhs) {\n-        return new DivOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a mod operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the mod operation\n-     *\/\n-    public static BinaryOp mod(Value lhs, Value rhs) {\n-        return new ModOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a bitwise\/logical or operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the or operation\n-     *\/\n-    public static BinaryOp or(Value lhs, Value rhs) {\n-        return new OrOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a bitwise\/logical and operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the and operation\n-     *\/\n-    public static BinaryOp and(Value lhs, Value rhs) {\n-        return new AndOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a bitwise\/logical xor operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the xor operation\n-     *\/\n-    public static BinaryOp xor(Value lhs, Value rhs) {\n-        return new XorOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a left shift operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the xor operation\n-     *\/\n-    public static BinaryOp lshl(Value lhs, Value rhs) {\n-        return new LshlOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a right shift operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the xor operation\n-     *\/\n-    public static BinaryOp ashr(Value lhs, Value rhs) {\n-        return new AshrOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates an unsigned right shift operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the xor operation\n-     *\/\n-    public static BinaryOp lshr(Value lhs, Value rhs) {\n-        return new LshrOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a neg operation.\n-     *\n-     * @param v the operand\n-     * @return the neg operation\n-     *\/\n-    public static UnaryOp neg(Value v) {\n-        return new NegOp(v);\n-    }\n-\n-    \/**\n-     * Creates a bitwise complement operation.\n-     *\n-     * @param v the operand\n-     * @return the bitwise complement operation\n-     *\/\n-    public static UnaryOp compl(Value v) {\n-        return new ComplOp(v);\n-    }\n-\n-    \/**\n-     * Creates a not operation.\n-     *\n-     * @param v the operand\n-     * @return the not operation\n-     *\/\n-    public static UnaryOp not(Value v) {\n-        return new NotOp(v);\n-    }\n-\n-\n-    \/**\n-     * Creates an equals comparison operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the equals comparison operation\n-     *\/\n-    public static BinaryTestOp eq(Value lhs, Value rhs) {\n-        return new EqOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a not equals comparison operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the not equals comparison operation\n-     *\/\n-    public static BinaryTestOp neq(Value lhs, Value rhs) {\n-        return new NeqOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a greater than comparison operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the greater than comparison operation\n-     *\/\n-    public static BinaryTestOp gt(Value lhs, Value rhs) {\n-        return new GtOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a greater than or equals to comparison operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the greater than or equals to comparison operation\n-     *\/\n-    public static BinaryTestOp ge(Value lhs, Value rhs) {\n-        return new GeOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a less than comparison operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the less than comparison operation\n-     *\/\n-    public static BinaryTestOp lt(Value lhs, Value rhs) {\n-        return new LtOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a less than or equals to comparison operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the less than or equals to comparison operation\n-     *\/\n-    public static BinaryTestOp le(Value lhs, Value rhs) {\n-        return new LeOp(lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a string concatenation operation.\n-     *\n-     * @param lhs the first operand\n-     * @param rhs the second operand\n-     * @return the string concatenation operation\n-     *\/\n-    public static ConcatOp concat(Value lhs, Value rhs) {\n-        return new ConcatOp(lhs, rhs);\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/CoreOp.java","additions":0,"deletions":4397,"binary":false,"changes":4397,"status":"deleted"},{"patch":"@@ -1,3745 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.op;\n-\n-import java.lang.constant.ClassDesc;\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.type.*;\n-import java.util.*;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.JavaType.*;\n-\n-\/**\n- * The top-level operation class for the enclosed set of extended operations.\n- * <p>\n- * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n- * operations. Such a model represents the same Java program and preserves the program meaning as defined by the\n- * Java Language Specification\n- * <p>\n- * Extended operations model specific Java language constructs, often those with structured control flow and nested\n- * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n- * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n- * that are not explicitly lowerable.\n- * <p>\n- * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n- * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n- * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n- *\/\n-public sealed abstract class ExtendedOp extends ExternalizableOp {\n-\n-    static final String PACKAGE_NAME = ExtendedOp.class.getPackageName();\n-\n-    static final String ExtendedOp_CLASS_NAME = PACKAGE_NAME + \".\" + ExtendedOp.class.getSimpleName();\n-\n-    protected ExtendedOp(Op that, CopyContext cc) {\n-        super(that, cc);\n-    }\n-\n-    protected ExtendedOp(String name, List<? extends Value> operands) {\n-        super(name, operands);\n-    }\n-\n-    protected ExtendedOp(ExternalizableOp.ExternalizedOp def) {\n-        super(def);\n-    }\n-\n-\n-    \/**\n-     * The label operation, that can model Java language statements with label identifiers.\n-     *\/\n-    public sealed static abstract class JavaLabelOp extends ExtendedOp\n-            implements Op.Lowerable, Op.BodyTerminating, JavaStatement {\n-        JavaLabelOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() > 1) {\n-                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n-            }\n-        }\n-\n-        JavaLabelOp(JavaLabelOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        JavaLabelOp(String name, Value label) {\n-            super(name, checkLabel(label));\n-        }\n-\n-        static List<Value> checkLabel(Value label) {\n-            return label == null ? List.of() : List.of(label);\n-        }\n-\n-        Op innerMostEnclosingTarget() {\n-            \/*\n-                A break statement with no label attempts to transfer control to the\n-                innermost enclosing switch, while, do, or for statement; this enclosing statement,\n-                which is called the break target, then immediately completes normally.\n-\n-                A break statement with label Identifier attempts to transfer control to the\n-                enclosing labeled statement (14.7) that has the same Identifier as its label;\n-                this enclosing statement, which is called the break target, then immediately completes normally.\n-                In this case, the break target need not be a switch, while, do, or for statement.\n-             *\/\n-\n-            \/\/ No label\n-            \/\/ Get innermost enclosing loop operation\n-            Op op = this;\n-            Body b;\n-            do {\n-                b = op.ancestorBody();\n-                op = b.parentOp();\n-                if (op == null) {\n-                    throw new IllegalStateException(\"No enclosing loop\");\n-                }\n-            } while (!(op instanceof Op.Loop || op instanceof JavaSwitchStatementOp));\n-\n-            return switch (op) {\n-                case Op.Loop lop -> lop.loopBody() == b ? op : null;\n-                case JavaSwitchStatementOp swStat -> swStat.bodies().contains(b) ? op : null;\n-                default -> throw new IllegalStateException();\n-            };\n-        }\n-\n-        boolean isUnlabeled() {\n-            return operands().isEmpty();\n-        }\n-\n-        Op target() {\n-            \/\/ If unlabeled then find the nearest enclosing op\n-            \/\/ Otherwise obtain the label target\n-            if (isUnlabeled()) {\n-                return innerMostEnclosingTarget();\n-            }\n-\n-            Value value = operands().get(0);\n-            if (value instanceof Result r && r.op().ancestorBody().parentOp() instanceof JavaLabeledOp lop) {\n-                return lop.target();\n-            } else {\n-                throw new IllegalStateException(\"Bad label value: \" + value + \" \" + ((Result) value).op());\n-            }\n-        }\n-\n-        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n-            Op opt = target();\n-            BranchTarget t = getBranchTarget(b.context(), opt);\n-            if (t != null) {\n-                b.op(branch(f.apply(t).successor()));\n-            } else {\n-                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The break operation, that can model Java language break statements with label identifiers.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaBreakOp.NAME)\n-    public static final class JavaBreakOp extends JavaLabelOp {\n-        public static final String NAME = \"java.break\";\n-\n-        public JavaBreakOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaBreakOp(JavaBreakOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public JavaBreakOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaBreakOp(this, cc);\n-        }\n-\n-        JavaBreakOp(Value label) {\n-            super(NAME, label);\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            return lower(b, BranchTarget::breakBlock);\n-        }\n-    }\n-\n-    \/**\n-     * The continue operation, that can model Java language continue statements with label identifiers.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaContinueOp.NAME)\n-    public static final class JavaContinueOp extends JavaLabelOp {\n-        public static final String NAME = \"java.continue\";\n-\n-        public JavaContinueOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaContinueOp(JavaContinueOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public JavaContinueOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaContinueOp(this, cc);\n-        }\n-\n-        JavaContinueOp(Value label) {\n-            super(NAME, label);\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            return lower(b, BranchTarget::continueBlock);\n-        }\n-    }\n-\n-    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n-    }\n-\n-    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n-\n-    static BranchTarget getBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<CodeElement<?, ?>, BranchTarget> m = (Map<CodeElement<?, ?>, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n-        if (m != null) {\n-            return m.get(codeElement);\n-        }\n-        return null;\n-    }\n-\n-    static void setBranchTarget(CopyContext cc, CodeElement<?, ?> codeElement, BranchTarget t) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<CodeElement<?, ?>, BranchTarget> x = (Map<CodeElement<?, ?>, BranchTarget>) cc.computePropertyIfAbsent(\n-                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n-        x.put(codeElement, t);\n-    }\n-\n-    \/**\n-     * The yield operation, that can model Java language yield statements.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaYieldOp.NAME)\n-    public static final class JavaYieldOp extends ExtendedOp\n-            implements Op.BodyTerminating, JavaStatement, Op.Lowerable {\n-        public static final String NAME = \"java.yield\";\n-\n-        public JavaYieldOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaYieldOp(JavaYieldOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public JavaYieldOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaYieldOp(this, cc);\n-        }\n-\n-        JavaYieldOp() {\n-            super(NAME,\n-                    List.of());\n-        }\n-\n-        JavaYieldOp(Value operand) {\n-            super(NAME, List.of(operand));\n-        }\n-\n-        public Value yieldValue() {\n-            if (operands().size() == 1) {\n-                return operands().get(0);\n-            } else {\n-                \/\/ @@@\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            \/\/ for now, we will use breakBlock field to indicate java.yield target block\n-            return lower(b, BranchTarget::breakBlock);\n-        }\n-\n-        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n-            Op opt = target();\n-            BranchTarget t = getBranchTarget(b.context(), opt);\n-            if (t != null) {\n-                b.op(branch(f.apply(t).successor(b.context().getValue(yieldValue()))));\n-            } else {\n-                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n-            }\n-            return b;\n-        }\n-\n-        Op target() {\n-            return innerMostEnclosingTarget();\n-        }\n-\n-        Op innerMostEnclosingTarget() {\n-            Op op = this;\n-            Body b;\n-            do {\n-                b = op.ancestorBody();\n-                op = b.parentOp();\n-                if (op == null) {\n-                    throw new IllegalStateException(\"No enclosing switch\");\n-                }\n-            } while (!(op instanceof JavaSwitchExpressionOp));\n-            return op;\n-        }\n-    }\n-\n-    \/**\n-     * The block operation, that can model Java language blocks.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaBlockOp.NAME)\n-    public static final class JavaBlockOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaStatement {\n-        public static final String NAME = \"java.block\";\n-\n-        final Body body;\n-\n-        public JavaBlockOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Operation must have no operands\");\n-            }\n-\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-        }\n-\n-        JavaBlockOp(JavaBlockOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public JavaBlockOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaBlockOp(this, cc, ot);\n-        }\n-\n-        JavaBlockOp(Body.Builder bodyC) {\n-            super(NAME, List.of());\n-\n-            this.body = bodyC.build(this);\n-            if (!body.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n-            }\n-            if (!body.bodyType().parameterTypes().isEmpty()) {\n-                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        public Body body() {\n-            return body;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder exit = b.block();\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-\n-            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof YieldOp) {\n-                    block.op(branch(exit.successor()));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                }\n-                return block;\n-            }));\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The synchronized operation, that can model Java synchronized statements.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaSynchronizedOp.NAME)\n-    public static final class JavaSynchronizedOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaStatement {\n-        public static final String NAME = \"java.synchronized\";\n-\n-        final Body expr;\n-        final Body blockBody;\n-\n-        public JavaSynchronizedOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.expr = def.bodyDefinitions().get(0).build(this);\n-            this.blockBody = def.bodyDefinitions().get(1).build(this);\n-        }\n-\n-        JavaSynchronizedOp(JavaSynchronizedOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy bodies\n-            this.expr = that.expr.transform(cc, ot).build(this);\n-            this.blockBody = that.blockBody.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public JavaSynchronizedOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaSynchronizedOp(this, cc, ot);\n-        }\n-\n-        JavaSynchronizedOp(Body.Builder exprC, Body.Builder bodyC) {\n-            super(NAME, List.of());\n-\n-            this.expr = exprC.build(this);\n-            if (expr.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Expression body should return non-void value: \" + expr.bodyType());\n-            }\n-            if (!expr.bodyType().parameterTypes().isEmpty()) {\n-                throw new IllegalArgumentException(\"Expression body should have zero parameters: \" + expr.bodyType());\n-            }\n-\n-            this.blockBody = bodyC.build(this);\n-            if (!blockBody.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Block body should return void: \" + blockBody.bodyType());\n-            }\n-            if (!blockBody.bodyType().parameterTypes().isEmpty()) {\n-                throw new IllegalArgumentException(\"Block body should have zero parameters: \" + blockBody.bodyType());\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(expr, blockBody);\n-        }\n-\n-        public Body expr() {\n-            return expr;\n-        }\n-\n-        public Body blockBody() {\n-            return blockBody;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            \/\/ Lower the expression body, yielding a monitor target\n-            b = lowerExpr(b, opT);\n-            Value monitorTarget = b.parameters().get(0);\n-\n-            \/\/ Monitor enter\n-            b.op(CoreOp.monitorEnter(monitorTarget));\n-\n-            Block.Builder exit = b.block();\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-\n-            \/\/ Exception region for the body\n-            Block.Builder syncRegionEnter = b.block();\n-            Block.Builder catcherFinally = b.block();\n-            b.op(exceptionRegionEnter(\n-                    syncRegionEnter.successor(), catcherFinally.successor()));\n-\n-            OpTransformer syncExitTransformer = opT.compose((block, op) -> {\n-                if (op instanceof CoreOp.ReturnOp ||\n-                    (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromSynchronized(lop))) {\n-                    \/\/ Monitor exit\n-                    block.op(CoreOp.monitorExit(monitorTarget));\n-                    \/\/ Exit the exception region\n-                    Block.Builder exitRegion = block.block();\n-                    block.op(exceptionRegionExit(exitRegion.successor(), catcherFinally.successor()));\n-                    return exitRegion;\n-                } else {\n-                    return block;\n-                }\n-            });\n-\n-            syncRegionEnter.transformBody(blockBody, List.of(), syncExitTransformer.andThen((block, op) -> {\n-                if (op instanceof YieldOp) {\n-                    \/\/ Monitor exit\n-                    block.op(CoreOp.monitorExit(monitorTarget));\n-                    \/\/ Exit the exception region\n-                    block.op(exceptionRegionExit(exit.successor(), catcherFinally.successor()));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, syncExitTransformer);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                }\n-                return block;\n-            }));\n-\n-            \/\/ The catcher, with an exception region back branching to itself\n-            Block.Builder catcherFinallyRegionEnter = b.block();\n-            catcherFinally.op(exceptionRegionEnter(\n-                    catcherFinallyRegionEnter.successor(), catcherFinally.successor()));\n-\n-            \/\/ Monitor exit\n-            catcherFinallyRegionEnter.op(CoreOp.monitorExit(monitorTarget));\n-            Block.Builder catcherFinallyRegionExit = b.block();\n-            \/\/ Exit the exception region\n-            catcherFinallyRegionEnter.op(exceptionRegionExit(\n-                    catcherFinallyRegionExit.successor(), catcherFinally.successor()));\n-            \/\/ Rethrow outside of region\n-            Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n-            catcherFinallyRegionExit.op(_throw(t));\n-\n-            return exit;\n-        }\n-\n-        Block.Builder lowerExpr(Block.Builder b, OpTransformer opT) {\n-            Block.Builder exprExit = b.block(expr.bodyType().returnType());\n-            b.transformBody(expr, List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof YieldOp yop) {\n-                    Value monitorTarget = block.context().getValue(yop.yieldValue());\n-                    block.op(branch(exprExit.successor(monitorTarget)));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                }\n-                return block;\n-            }));\n-            return exprExit;\n-        }\n-\n-        boolean ifExitFromSynchronized(JavaLabelOp lop) {\n-            Op target = lop.target();\n-            return target == this || ifAncestorOp(target, this);\n-        }\n-\n-        static boolean ifAncestorOp(Op ancestor, Op op) {\n-            while (op.ancestorBody() != null) {\n-                op = op.ancestorBody().parentOp();\n-                if (op == ancestor) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The labeled operation, that can model Java language labeled statements.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaLabeledOp.NAME)\n-    public static final class JavaLabeledOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaStatement {\n-        public static final String NAME = \"java.labeled\";\n-\n-        final Body body;\n-\n-        public JavaLabeledOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Operation must have no operands\");\n-            }\n-\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-        }\n-\n-        JavaLabeledOp(JavaLabeledOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public JavaLabeledOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaLabeledOp(this, cc, ot);\n-        }\n-\n-        JavaLabeledOp(Body.Builder bodyC) {\n-            super(NAME, List.of());\n-\n-            this.body = bodyC.build(this);\n-            if (!body.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n-            }\n-            if (!body.bodyType().parameterTypes().isEmpty()) {\n-                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(body);\n-        }\n-\n-        public Op label() {\n-            return body.entryBlock().firstOp();\n-        }\n-\n-        public Op target() {\n-            return body.entryBlock().nextOp(label());\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder exit = b.block();\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-\n-            AtomicBoolean first = new AtomicBoolean();\n-            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n-                \/\/ Drop first operation that corresponds to the label\n-                if (!first.get()) {\n-                    first.set(true);\n-                    return block;\n-                }\n-\n-                if (op instanceof YieldOp) {\n-                    block.op(branch(exit.successor()));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                }\n-                return block;\n-            }));\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The if operation, that can model Java language if, if-then, and if-then-else statements.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaIfOp.NAME)\n-    public static final class JavaIfOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaStatement {\n-\n-        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n-\n-        static final FunctionType ACTION_TYPE = FunctionType.VOID;\n-\n-        public static class IfBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<Body.Builder> bodies;\n-\n-            IfBuilder(Body.Builder ancestorBody) {\n-                this.ancestorBody = ancestorBody;\n-                this.bodies = new ArrayList<>();\n-            }\n-\n-            public ThenBuilder _if(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n-                c.accept(body.entryBlock());\n-                bodies.add(body);\n-\n-                return new ThenBuilder(ancestorBody, bodies);\n-            }\n-        }\n-\n-        public static class ThenBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<Body.Builder> bodies;\n-\n-            public ThenBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n-                this.ancestorBody = ancestorBody;\n-                this.bodies = bodies;\n-            }\n-\n-            public ElseIfBuilder then(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n-                c.accept(body.entryBlock());\n-                bodies.add(body);\n-\n-                return new ElseIfBuilder(ancestorBody, bodies);\n-            }\n-\n-            public ElseIfBuilder then() {\n-                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n-                body.entryBlock().op(_yield());\n-                bodies.add(body);\n-\n-                return new ElseIfBuilder(ancestorBody, bodies);\n-            }\n-        }\n-\n-        public static class ElseIfBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<Body.Builder> bodies;\n-\n-            public ElseIfBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n-                this.ancestorBody = ancestorBody;\n-                this.bodies = bodies;\n-            }\n-\n-            public ThenBuilder elseif(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n-                c.accept(body.entryBlock());\n-                bodies.add(body);\n-\n-                return new ThenBuilder(ancestorBody, bodies);\n-            }\n-\n-            public JavaIfOp _else(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n-                c.accept(body.entryBlock());\n-                bodies.add(body);\n-\n-                return new JavaIfOp(bodies);\n-            }\n-\n-            public JavaIfOp _else() {\n-                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n-                body.entryBlock().op(_yield());\n-                bodies.add(body);\n-\n-                return new JavaIfOp(bodies);\n-            }\n-        }\n-\n-        public static final String NAME = \"java.if\";\n-\n-        final List<Body> bodies;\n-\n-        public JavaIfOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Operation must have no operands\");\n-            }\n-\n-            \/\/ @@@ Validate\n-\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        JavaIfOp(JavaIfOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.bodies = that.bodies.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        @Override\n-        public JavaIfOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaIfOp(this, cc, ot);\n-        }\n-\n-        JavaIfOp(List<Body.Builder> bodyCs) {\n-            super(NAME, List.of());\n-\n-            \/\/ Normalize by adding an empty else action\n-            \/\/ @@@ Is this needed?\n-            if (bodyCs.size() % 2 == 0) {\n-                bodyCs = new ArrayList<>(bodyCs);\n-                Body.Builder end = Body.Builder.of(bodyCs.get(0).ancestorBody(),\n-                        FunctionType.VOID);\n-                end.entryBlock().op(_yield());\n-                bodyCs.add(end);\n-            }\n-\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-\n-            if (bodies.size() < 2) {\n-                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n-            }\n-            for (int i = 0; i < bodies.size(); i += 2) {\n-                Body action;\n-                if (i == bodies.size() - 1) {\n-                    action = bodies.get(i);\n-                } else {\n-                    action = bodies.get(i + 1);\n-                    Body fromPred = bodies.get(i);\n-                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n-                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.bodyType());\n-                    }\n-                }\n-                if (!action.bodyType().equals(FunctionType.VOID)) {\n-                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.bodyType());\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder exit = b.block();\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-\n-            \/\/ Create predicate and action blocks\n-            List<Block.Builder> builders = new ArrayList<>();\n-            for (int i = 0; i < bodies.size(); i += 2) {\n-                if (i == bodies.size() - 1) {\n-                    builders.add(b.block());\n-                } else {\n-                    builders.add(i == 0 ? b : b.block());\n-                    builders.add(b.block());\n-                }\n-            }\n-\n-            for (int i = 0; i < bodies.size(); i += 2) {\n-                Body actionBody;\n-                Block.Builder action;\n-                if (i == bodies.size() - 1) {\n-                    actionBody = bodies.get(i);\n-                    action = builders.get(i);\n-                } else {\n-                    Body predBody = bodies.get(i);\n-                    actionBody = bodies.get(i + 1);\n-\n-                    Block.Builder pred = builders.get(i);\n-                    action = builders.get(i + 1);\n-                    Block.Builder next = builders.get(i + 2);\n-\n-                    pred.transformBody(predBody, List.of(), opT.andThen((block, op) -> {\n-                        if (op instanceof YieldOp yo) {\n-                            block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n-                                    action.successor(), next.successor()));\n-                        } else if (op instanceof Lowerable lop) {\n-                            \/\/ @@@ Composition of lowerable ops\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            block.op(op);\n-                        }\n-                        return block;\n-                    }));\n-                }\n-\n-                action.transformBody(actionBody, List.of(), opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp) {\n-                        block.op(branch(exit.successor()));\n-                    } else {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        if (op instanceof Lowerable lop) {\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            block.op(op);\n-                        }\n-                    }\n-                    return block;\n-                }));\n-            }\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    public abstract static sealed class JavaSwitchOp extends ExtendedOp implements Op.Nested, Op.Lowerable\n-            permits JavaSwitchStatementOp, JavaSwitchExpressionOp {\n-\n-        final List<Body> bodies;\n-\n-        public JavaSwitchOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalStateException(\"Operation must have one operand\");\n-            }\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        JavaSwitchOp(JavaSwitchOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.bodies = that.bodies.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        JavaSwitchOp(String name, Value target, List<Body.Builder> bodyCs) {\n-            super(name, List.of(target));\n-\n-            \/\/ Each case is modelled as a contiguous pair of bodies\n-            \/\/ The first body models the case labels, and the second models the case statements\n-            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n-            \/\/ The statements body has no parameters and returns void\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-\n-            Value selectorExpression = b.context().getValue(operands().get(0));\n-\n-            \/\/ @@@ we can add this during model generation\n-            \/\/ if no case null, add one that throws NPE\n-            if (!(selectorExpression.type() instanceof PrimitiveType) && !haveNullCase()) {\n-                Block.Builder throwBlock = b.block();\n-                throwBlock.op(_throw(\n-                        throwBlock.op(_new(ConstructorRef.constructor(NullPointerException.class)))\n-                ));\n-\n-                Block.Builder continueBlock = b.block();\n-\n-                Result p = b.op(invoke(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n-                        selectorExpression, b.op(constant(J_L_OBJECT, null))));\n-                b.op(conditionalBranch(p, throwBlock.successor(), continueBlock.successor()));\n-\n-                b = continueBlock;\n-            }\n-\n-            List<Block.Builder> blocks = new ArrayList<>();\n-            for (int i = 0; i < bodies().size(); i++) {\n-                Block.Builder bb = b.block();\n-                if (i == 0) {\n-                    bb = b;\n-                }\n-                blocks.add(bb);\n-            }\n-\n-            Block.Builder exit;\n-            if (bodies().isEmpty()) {\n-                exit = b;\n-            } else {\n-                exit = b.block(resultType());\n-                if (this instanceof JavaSwitchExpressionOp) {\n-                    exit.context().mapValue(result(), exit.parameters().get(0));\n-                }\n-            }\n-\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-            \/\/ map statement body to nextExprBlock\n-            \/\/ this mapping will be used for lowering SwitchFallThroughOp\n-            for (int i = 1; i < bodies().size() - 2; i+=2) {\n-                setBranchTarget(b.context(), bodies().get(i), new BranchTarget(null, blocks.get(i + 2)));\n-            }\n-\n-            for (int i = 0; i < bodies().size(); i++) {\n-                boolean isLabelBody = i % 2 == 0;\n-                Block.Builder curr = blocks.get(i);\n-                if (isLabelBody) {\n-                    Block.Builder statement = blocks.get(i + 1);\n-                    boolean isLastLabel = i == blocks.size() - 2;\n-                    Block.Builder nextLabel = isLastLabel ? null : blocks.get(i + 2);\n-                    curr.transformBody(bodies().get(i), List.of(selectorExpression), opT.andThen((block, op) -> {\n-                        switch (op) {\n-                            case YieldOp yop when isLastLabel && this instanceof JavaSwitchExpressionOp -> {\n-                                block.op(branch(statement.successor()));\n-                            }\n-                            case YieldOp yop -> block.op(conditionalBranch(\n-                                    block.context().getValue(yop.yieldValue()),\n-                                    statement.successor(),\n-                                    isLastLabel ? exit.successor() : nextLabel.successor()\n-                            ));\n-                            case Lowerable lop -> block = lop.lower(block);\n-                            default -> block.op(op);\n-                        }\n-                        return block;\n-                    }));\n-                } else { \/\/ statement body\n-                    curr.transformBody(bodies().get(i), blocks.get(i).parameters(), opT.andThen((block, op) -> {\n-                        switch (op) {\n-                            case YieldOp yop when this instanceof JavaSwitchStatementOp -> block.op(branch(exit.successor()));\n-                            case YieldOp yop when this instanceof JavaSwitchExpressionOp -> block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n-                            case Lowerable lop -> block = lop.lower(block);\n-                            default -> block.op(op);\n-                        }\n-                        return block;\n-                    }));\n-                }\n-            }\n-\n-            return exit;\n-        }\n-\n-        boolean haveNullCase() {\n-            \/*\n-            case null is modeled like this:\n-            (%4 : T)boolean -> {\n-                %5 : java.lang.Object = constant @null;\n-                %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n-                yield %6;\n-            }\n-            * *\/\n-            for (int i = 0; i < bodies().size() - 2; i+=2) {\n-                Body labelBody = bodies().get(i);\n-                if (labelBody.blocks().size() != 1) {\n-                    continue; \/\/ we skip, for now\n-                }\n-                Op terminatingOp = bodies().get(i).entryBlock().terminatingOp();\n-                \/\/@@@ when op pattern matching is ready, we can use it\n-                if (terminatingOp instanceof YieldOp yieldOp &&\n-                        yieldOp.yieldValue() instanceof Op.Result opr &&\n-                        opr.op() instanceof InvokeOp invokeOp &&\n-                        invokeOp.invokeDescriptor().equals(MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class)) &&\n-                        invokeOp.operands().stream().anyMatch(o -> o instanceof Op.Result r && r.op() instanceof ConstantOp cop && cop.value() == null)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * The switch expression operation, that can model Java language switch expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaSwitchExpressionOp.NAME)\n-    public static final class JavaSwitchExpressionOp extends JavaSwitchOp\n-            implements JavaExpression {\n-        public static final String NAME = \"java.switch.expression\";\n-\n-        final TypeElement resultType;\n-\n-        public JavaSwitchExpressionOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.resultType = def.resultType();\n-        }\n-\n-        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc, ot);\n-\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaSwitchExpressionOp(this, cc, ot);\n-        }\n-\n-        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n-            super(NAME, target, bodyCs);\n-\n-            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * The switch statement operation, that can model Java language switch statement.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaSwitchStatementOp.NAME)\n-    public static final class JavaSwitchStatementOp extends JavaSwitchOp\n-            implements JavaStatement {\n-        public static final String NAME = \"java.switch.statement\";\n-\n-        public JavaSwitchStatementOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaSwitchStatementOp(JavaSwitchStatementOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc, ot);\n-        }\n-\n-        @Override\n-        public JavaSwitchStatementOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaSwitchStatementOp(this, cc, ot);\n-        }\n-\n-        JavaSwitchStatementOp(Value target, List<Body.Builder> bodyCs) {\n-            super(NAME, target, bodyCs);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The switch fall-through operation, that can model fall-through to the next statement in the switch block after\n-     * the last statement of the current switch label.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaSwitchFallthroughOp.NAME)\n-    public static final class JavaSwitchFallthroughOp extends ExtendedOp\n-            implements Op.BodyTerminating, Op.Lowerable {\n-        public static final String NAME = \"java.switch.fallthrough\";\n-\n-        public JavaSwitchFallthroughOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaSwitchFallthroughOp(JavaSwitchFallthroughOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public JavaSwitchFallthroughOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaSwitchFallthroughOp(this, cc);\n-        }\n-\n-        JavaSwitchFallthroughOp() {\n-            super(NAME, List.of());\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            return lower(b, BranchTarget::continueBlock);\n-        }\n-\n-        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n-            BranchTarget t = getBranchTarget(b.context(), parentBlock().parentBody());\n-            if (t != null) {\n-                b.op(branch(f.apply(t).successor()));\n-            } else {\n-                throw new IllegalStateException(\"No branch target for operation: \" + this);\n-            }\n-            return b;\n-        }\n-    }\n-\n-    \/**\n-     * The for operation, that can model a Java language for statement.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaForOp.NAME)\n-    public static final class JavaForOp extends ExtendedOp\n-            implements Op.Loop, Op.Lowerable, JavaStatement {\n-\n-        public static final class InitBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<? extends TypeElement> initTypes;\n-\n-            InitBuilder(Body.Builder ancestorBody,\n-                        List<? extends TypeElement> initTypes) {\n-                this.ancestorBody = ancestorBody;\n-                this.initTypes = initTypes.stream().map(VarType::varType).toList();\n-            }\n-\n-            public JavaForOp.CondBuilder init(Consumer<Block.Builder> c) {\n-                Body.Builder init = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(TupleType.tupleType(initTypes)));\n-                c.accept(init.entryBlock());\n-\n-                return new CondBuilder(ancestorBody, initTypes, init);\n-            }\n-        }\n-\n-        public static final class CondBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<? extends TypeElement> initTypes;\n-            final Body.Builder init;\n-\n-            public CondBuilder(Body.Builder ancestorBody,\n-                               List<? extends TypeElement> initTypes,\n-                               Body.Builder init) {\n-                this.ancestorBody = ancestorBody;\n-                this.initTypes = initTypes;\n-                this.init = init;\n-            }\n-\n-            public JavaForOp.UpdateBuilder cond(Consumer<Block.Builder> c) {\n-                Body.Builder cond = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(BOOLEAN, initTypes));\n-                c.accept(cond.entryBlock());\n-\n-                return new UpdateBuilder(ancestorBody, initTypes, init, cond);\n-            }\n-        }\n-\n-        public static final class UpdateBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<? extends TypeElement> initTypes;\n-            final Body.Builder init;\n-            final Body.Builder cond;\n-\n-            public UpdateBuilder(Body.Builder ancestorBody,\n-                                 List<? extends TypeElement> initTypes,\n-                                 Body.Builder init, Body.Builder cond) {\n-                this.ancestorBody = ancestorBody;\n-                this.initTypes = initTypes;\n-                this.init = init;\n-                this.cond = cond;\n-            }\n-\n-            public JavaForOp.BodyBuilder cond(Consumer<Block.Builder> c) {\n-                Body.Builder update = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(VOID, initTypes));\n-                c.accept(update.entryBlock());\n-\n-                return new BodyBuilder(ancestorBody, initTypes, init, cond, update);\n-            }\n-\n-        }\n-\n-        public static final class BodyBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<? extends TypeElement> initTypes;\n-            final Body.Builder init;\n-            final Body.Builder cond;\n-            final Body.Builder update;\n-\n-            public BodyBuilder(Body.Builder ancestorBody,\n-                               List<? extends TypeElement> initTypes,\n-                               Body.Builder init, Body.Builder cond, Body.Builder update) {\n-                this.ancestorBody = ancestorBody;\n-                this.initTypes = initTypes;\n-                this.init = init;\n-                this.cond = cond;\n-                this.update = update;\n-            }\n-\n-            public JavaForOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(VOID, initTypes));\n-                c.accept(body.entryBlock());\n-\n-                return new JavaForOp(init, cond, update, body);\n-            }\n-        }\n-\n-        static final String NAME = \"java.for\";\n-\n-        final Body init;\n-        final Body cond;\n-        final Body update;\n-        final Body body;\n-\n-        public static JavaForOp create(ExternalizedOp def) {\n-            return new JavaForOp(def);\n-        }\n-\n-        public JavaForOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.init = def.bodyDefinitions().get(0).build(this);\n-            this.cond = def.bodyDefinitions().get(1).build(this);\n-            this.update = def.bodyDefinitions().get(2).build(this);\n-            this.body = def.bodyDefinitions().get(3).build(this);\n-        }\n-\n-        JavaForOp(JavaForOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.init = that.init.transform(cc, ot).build(this);\n-            this.cond = that.cond.transform(cc, ot).build(this);\n-            this.update = that.update.transform(cc, ot).build(this);\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public JavaForOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaForOp(this, cc, ot);\n-        }\n-\n-        JavaForOp(Body.Builder initC,\n-                  Body.Builder condC,\n-                  Body.Builder updateC,\n-                  Body.Builder bodyC) {\n-            super(NAME, List.of());\n-\n-            this.init = initC.build(this);\n-\n-            this.cond = condC.build(this);\n-\n-            this.update = updateC.build(this);\n-            if (!update.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Update should return void: \" + update.bodyType());\n-            }\n-\n-            this.body = bodyC.build(this);\n-            if (!body.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(init, cond, update, body);\n-        }\n-\n-        public Body init() {\n-            return init;\n-        }\n-\n-        public Body cond() {\n-            return cond;\n-        }\n-\n-        public Body update() {\n-            return update;\n-        }\n-\n-        @Override\n-        public Body loopBody() {\n-            return body;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder header = b.block();\n-            Block.Builder body = b.block();\n-            Block.Builder update = b.block();\n-            Block.Builder exit = b.block();\n-\n-            List<Value> initValues = new ArrayList<>();\n-            \/\/ @@@ Init body has one yield operation yielding\n-            \/\/  void, a single variable, or a tuple of one or more variables\n-            b.transformBody(init, List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof CoreOp.TupleOp) {\n-                    \/\/ Drop Tuple if a yielded\n-                    boolean isResult = op.result().uses().size() == 1 &&\n-                            op.result().uses().stream().allMatch(r -> r.op() instanceof YieldOp);\n-                    if (!isResult) {\n-                        block.op(op);\n-                    }\n-                } else if (op instanceof YieldOp yop) {\n-                    if (yop.yieldValue() == null) {\n-                        block.op(branch(header.successor()));\n-                        return block;\n-                    } else if (yop.yieldValue() instanceof Result or) {\n-                        if (or.op() instanceof CoreOp.TupleOp top) {\n-                            initValues.addAll(block.context().getValues(top.operands()));\n-                        } else {\n-                            initValues.addAll(block.context().getValues(yop.operands()));\n-                        }\n-                        block.op(branch(header.successor()));\n-                        return block;\n-                    }\n-\n-                    throw new IllegalStateException(\"Bad yield operation\");\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            header.transformBody(cond, initValues, opT.andThen((block, op) -> {\n-                if (op instanceof YieldOp yo) {\n-                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n-                            body.successor(), exit.successor()));\n-                } else if (op instanceof Lowerable lop) {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n-\n-            body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n-                \/\/ @@@ Composition of lowerable ops\n-                if (op instanceof Lowerable lop) {\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            update.transformBody(this.update, initValues, opT.andThen((block, op) -> {\n-                if (op instanceof YieldOp) {\n-                    block.op(branch(header.successor()));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The enhanced for operation, that can model a Java language enhanced for statement.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaEnhancedForOp.NAME)\n-    public static final class JavaEnhancedForOp extends ExtendedOp\n-            implements Op.Loop, Op.Lowerable, JavaStatement {\n-\n-        public static final class ExpressionBuilder {\n-            final Body.Builder ancestorBody;\n-            final TypeElement iterableType;\n-            final TypeElement elementType;\n-\n-            ExpressionBuilder(Body.Builder ancestorBody,\n-                              TypeElement iterableType, TypeElement elementType) {\n-                this.ancestorBody = ancestorBody;\n-                this.iterableType = iterableType;\n-                this.elementType = elementType;\n-            }\n-\n-            public DefinitionBuilder expression(Consumer<Block.Builder> c) {\n-                Body.Builder expression = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(iterableType));\n-                c.accept(expression.entryBlock());\n-\n-                return new DefinitionBuilder(ancestorBody, elementType, expression);\n-            }\n-        }\n-\n-        public static final class DefinitionBuilder {\n-            final Body.Builder ancestorBody;\n-            final TypeElement elementType;\n-            final Body.Builder expression;\n-\n-            DefinitionBuilder(Body.Builder ancestorBody,\n-                              TypeElement elementType, Body.Builder expression) {\n-                this.ancestorBody = ancestorBody;\n-                this.elementType = elementType;\n-                this.expression = expression;\n-            }\n-\n-            public BodyBuilder definition(Consumer<Block.Builder> c) {\n-                return definition(elementType, c);\n-            }\n-\n-            public BodyBuilder definition(TypeElement bodyElementType, Consumer<Block.Builder> c) {\n-                Body.Builder definition = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(bodyElementType, elementType));\n-                c.accept(definition.entryBlock());\n-\n-                return new BodyBuilder(ancestorBody, elementType, expression, definition);\n-            }\n-        }\n-\n-        public static final class BodyBuilder {\n-            final Body.Builder ancestorBody;\n-            final TypeElement elementType;\n-            final Body.Builder expression;\n-            final Body.Builder definition;\n-\n-            BodyBuilder(Body.Builder ancestorBody,\n-                        TypeElement elementType, Body.Builder expression, Body.Builder definition) {\n-                this.ancestorBody = ancestorBody;\n-                this.elementType = elementType;\n-                this.expression = expression;\n-                this.definition = definition;\n-            }\n-\n-            public JavaEnhancedForOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(VOID, elementType));\n-                c.accept(body.entryBlock());\n-\n-                return new JavaEnhancedForOp(expression, definition, body);\n-            }\n-        }\n-\n-        static final String NAME = \"java.enhancedFor\";\n-\n-        final Body expression;\n-        final Body init;\n-        final Body body;\n-\n-        public static JavaEnhancedForOp create(ExternalizedOp def) {\n-            return new JavaEnhancedForOp(def);\n-        }\n-\n-        public JavaEnhancedForOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.expression = def.bodyDefinitions().get(0).build(this);\n-            this.init = def.bodyDefinitions().get(1).build(this);\n-            this.body = def.bodyDefinitions().get(2).build(this);\n-        }\n-\n-        JavaEnhancedForOp(JavaEnhancedForOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.expression = that.expression.transform(cc, ot).build(this);\n-            this.init = that.init.transform(cc, ot).build(this);\n-            this.body = that.body.transform(cc, ot).build(this);\n-        }\n-\n-        @Override\n-        public JavaEnhancedForOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaEnhancedForOp(this, cc, ot);\n-        }\n-\n-        JavaEnhancedForOp(Body.Builder expressionC, Body.Builder initC, Body.Builder bodyC) {\n-            super(NAME, List.of());\n-\n-            this.expression = expressionC.build(this);\n-            if (expression.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.bodyType());\n-            }\n-            if (!expression.bodyType().parameterTypes().isEmpty()) {\n-                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.bodyType());\n-            }\n-\n-            this.init = initC.build(this);\n-            if (init.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.bodyType());\n-            }\n-            if (init.bodyType().parameterTypes().size() != 1) {\n-                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.bodyType());\n-            }\n-\n-            this.body = bodyC.build(this);\n-            if (!body.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n-            }\n-            if (body.bodyType().parameterTypes().size() != 1) {\n-                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.bodyType());\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return List.of(expression, init, body);\n-        }\n-\n-        public Body expression() {\n-            return expression;\n-        }\n-\n-        public Body initialization() {\n-            return init;\n-        }\n-\n-        @Override\n-        public Body loopBody() {\n-            return body;\n-        }\n-\n-        static final MethodRef ITERABLE_ITERATOR = MethodRef.method(Iterable.class, \"iterator\", Iterator.class);\n-        static final MethodRef ITERATOR_HAS_NEXT = MethodRef.method(Iterator.class, \"hasNext\", boolean.class);\n-        static final MethodRef ITERATOR_NEXT = MethodRef.method(Iterator.class, \"next\", Object.class);\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            JavaType elementType = (JavaType) init.entryBlock().parameters().get(0).type();\n-            boolean isArray = expression.bodyType().returnType() instanceof ArrayType;\n-\n-            Block.Builder preHeader = b.block(expression.bodyType().returnType());\n-            Block.Builder header = b.block(isArray ? List.of(INT) : List.of());\n-            Block.Builder init = b.block();\n-            Block.Builder body = b.block();\n-            Block.Builder exit = b.block();\n-\n-            b.transformBody(expression, List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof YieldOp yop) {\n-                    Value loopSource = block.context().getValue(yop.yieldValue());\n-                    block.op(branch(preHeader.successor(loopSource)));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            if (isArray) {\n-                Value array = preHeader.parameters().get(0);\n-                Value arrayLength = preHeader.op(arrayLength(array));\n-                Value i = preHeader.op(constant(INT, 0));\n-                preHeader.op(branch(header.successor(i)));\n-\n-                i = header.parameters().get(0);\n-                Value p = header.op(lt(i, arrayLength));\n-                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n-\n-                Value e = init.op(arrayLoadOp(array, i));\n-                List<Value> initValues = new ArrayList<>();\n-                \/\/ @@@ Init body has one yield operation yielding a single variable\n-                init.transformBody(this.init, List.of(e), (block, op) -> {\n-                    if (op instanceof YieldOp yop) {\n-                        initValues.addAll(block.context().getValues(yop.operands()));\n-                        block.op(branch(body.successor()));\n-                    } else {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        block.op(op);\n-                    }\n-                    return block;\n-                });\n-\n-                Block.Builder update = b.block();\n-                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n-\n-                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                    return block;\n-                }));\n-\n-                i = update.op(add(i, update.op(constant(INT, 1))));\n-                update.op(branch(header.successor(i)));\n-            } else {\n-                JavaType iterable = parameterized(type(Iterator.class), elementType);\n-                Value iterator = preHeader.op(CoreOp.invoke(iterable, ITERABLE_ITERATOR, preHeader.parameters().get(0)));\n-                preHeader.op(branch(header.successor()));\n-\n-                Value p = header.op(CoreOp.invoke(ITERATOR_HAS_NEXT, iterator));\n-                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n-\n-                Value e = init.op(CoreOp.invoke(elementType, ITERATOR_NEXT, iterator));\n-                List<Value> initValues = new ArrayList<>();\n-                init.transformBody(this.init, List.of(e), opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp yop) {\n-                        initValues.addAll(block.context().getValues(yop.operands()));\n-                        block.op(branch(body.successor()));\n-                    } else {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        block.op(op);\n-                    }\n-                    return block;\n-                }));\n-\n-                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n-\n-                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                    return block;\n-                }));\n-            }\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The while operation, that can model a Java language while statement.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaWhileOp.NAME)\n-    public static final class JavaWhileOp extends ExtendedOp\n-            implements Op.Loop, Op.Lowerable, JavaStatement {\n-\n-        public static class PredicateBuilder {\n-            final Body.Builder ancestorBody;\n-\n-            PredicateBuilder(Body.Builder ancestorBody) {\n-                this.ancestorBody = ancestorBody;\n-            }\n-\n-            public JavaWhileOp.BodyBuilder predicate(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n-                c.accept(body.entryBlock());\n-\n-                return new JavaWhileOp.BodyBuilder(ancestorBody, body);\n-            }\n-        }\n-\n-        public static class BodyBuilder {\n-            final Body.Builder ancestorBody;\n-            private final Body.Builder predicate;\n-\n-            BodyBuilder(Body.Builder ancestorBody, Body.Builder predicate) {\n-                this.ancestorBody = ancestorBody;\n-                this.predicate = predicate;\n-            }\n-\n-            public JavaWhileOp body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n-                c.accept(body.entryBlock());\n-\n-                return new JavaWhileOp(List.of(predicate, body));\n-            }\n-        }\n-\n-        private static final String NAME = \"java.while\";\n-\n-        private final List<Body> bodies;\n-\n-        public JavaWhileOp(ExternalizedOp def) {\n-            super(def);\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        JavaWhileOp(List<Body.Builder> bodyCs) {\n-            super(NAME, List.of());\n-\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-        }\n-\n-        JavaWhileOp(Body.Builder predicate, Body.Builder body) {\n-            super(NAME, List.of());\n-\n-            Objects.requireNonNull(body);\n-\n-            this.bodies = Stream.of(predicate, body).filter(Objects::nonNull)\n-                    .map(bc -> bc.build(this)).toList();\n-\n-            \/\/ @@@ This will change with pattern bindings\n-            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n-                throw new IllegalArgumentException(\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n-                                \" but is \" + bodies.get(0).bodyType());\n-            }\n-            if (!bodies.get(1).bodyType().equals(FunctionType.VOID)) {\n-                throw new IllegalArgumentException(\n-                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n-                                \" but is \" + bodies.get(1).bodyType());\n-            }\n-        }\n-\n-        JavaWhileOp(JavaWhileOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.bodies = that.bodies.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        @Override\n-        public JavaWhileOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaWhileOp(this, cc, ot);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        public Body predicateBody() {\n-            return bodies.get(0);\n-        }\n-\n-        @Override\n-        public Body loopBody() {\n-            return bodies.get(1);\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder header = b.block();\n-            Block.Builder body = b.block();\n-            Block.Builder exit = b.block();\n-\n-            b.op(branch(header.successor()));\n-\n-            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof CoreOp.YieldOp yo) {\n-                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n-                            body.successor(), exit.successor()));\n-                } else if (op instanceof Lowerable lop) {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n-\n-            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n-                \/\/ @@@ Composition of lowerable ops\n-                if (op instanceof Lowerable lop) {\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The do-while operation, that can model a Java language do statement.\n-     *\/\n-    \/\/ @@@ Unify JavaDoWhileOp and JavaWhileOp with common abstract superclass\n-    @OpFactory.OpDeclaration(JavaDoWhileOp.NAME)\n-    public static final class JavaDoWhileOp extends ExtendedOp\n-            implements Op.Loop, Op.Lowerable, JavaStatement {\n-\n-        public static class PredicateBuilder {\n-            final Body.Builder ancestorBody;\n-            private final Body.Builder body;\n-\n-            PredicateBuilder(Body.Builder ancestorBody, Body.Builder body) {\n-                this.ancestorBody = ancestorBody;\n-                this.body = body;\n-            }\n-\n-            public JavaDoWhileOp predicate(Consumer<Block.Builder> c) {\n-                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n-                c.accept(predicate.entryBlock());\n-\n-                return new JavaDoWhileOp(List.of(body, predicate));\n-            }\n-        }\n-\n-        public static class BodyBuilder {\n-            final Body.Builder ancestorBody;\n-\n-            BodyBuilder(Body.Builder ancestorBody) {\n-                this.ancestorBody = ancestorBody;\n-            }\n-\n-            public JavaDoWhileOp.PredicateBuilder body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n-                c.accept(body.entryBlock());\n-\n-                return new JavaDoWhileOp.PredicateBuilder(ancestorBody, body);\n-            }\n-        }\n-\n-        private static final String NAME = \"java.do.while\";\n-\n-        private final List<Body> bodies;\n-\n-        public JavaDoWhileOp(ExternalizedOp def) {\n-            super(def);\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        JavaDoWhileOp(List<Body.Builder> bodyCs) {\n-            super(NAME, List.of());\n-\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-        }\n-\n-        JavaDoWhileOp(Body.Builder body, Body.Builder predicate) {\n-            super(NAME, List.of());\n-\n-            Objects.requireNonNull(body);\n-\n-            this.bodies = Stream.of(body, predicate).filter(Objects::nonNull)\n-                    .map(bc -> bc.build(this)).toList();\n-\n-            if (!bodies.get(0).bodyType().equals(FunctionType.VOID)) {\n-                throw new IllegalArgumentException(\n-                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n-                                \" but is \" + bodies.get(1).bodyType());\n-            }\n-            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n-                throw new IllegalArgumentException(\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n-                                \" but is \" + bodies.get(0).bodyType());\n-            }\n-        }\n-\n-        JavaDoWhileOp(JavaDoWhileOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.bodies = that.bodies.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        @Override\n-        public JavaDoWhileOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaDoWhileOp(this, cc, ot);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        public Body predicateBody() {\n-            return bodies.get(1);\n-        }\n-\n-        @Override\n-        public Body loopBody() {\n-            return bodies.get(0);\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder body = b.block();\n-            Block.Builder header = b.block();\n-            Block.Builder exit = b.block();\n-\n-            b.op(branch(body.successor()));\n-\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n-\n-            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n-                \/\/ @@@ Composition of lowerable ops\n-                if (op instanceof Lowerable lop) {\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof CoreOp.YieldOp yo) {\n-                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n-                            body.successor(), exit.successor()));\n-                } else if (op instanceof Lowerable lop) {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/**\n-     * The conditional-and-or operation, that can model Java language condition-or or conditional-and expressions.\n-     *\/\n-    public sealed static abstract class JavaConditionalOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaExpression {\n-        final List<Body> bodies;\n-\n-        public JavaConditionalOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Operation must have no operands\");\n-            }\n-\n-            \/\/ @@@ Validate\n-\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        JavaConditionalOp(JavaConditionalOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        JavaConditionalOp(String name, List<Body.Builder> bodyCs) {\n-            super(name, List.of());\n-\n-            if (bodyCs.isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-            for (Body b : bodies) {\n-                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n-                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.bodyType());\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        static Block.Builder lower(Block.Builder startBlock, OpTransformer opT, JavaConditionalOp cop) {\n-            List<Body> bodies = cop.bodies();\n-\n-            Block.Builder exit = startBlock.block();\n-            TypeElement oprType = cop.result().type();\n-            Block.Parameter arg = exit.parameter(oprType);\n-            startBlock.context().mapValue(cop.result(), arg);\n-\n-            \/\/ Transform bodies in reverse order\n-            \/\/ This makes available the blocks to be referenced as successors in prior blocks\n-\n-            Block.Builder pred = null;\n-            for (int i = bodies.size() - 1; i >= 0; i--) {\n-                OpTransformer opt;\n-                if (i == bodies.size() - 1) {\n-                    opt = (block, op) -> {\n-                        if (op instanceof CoreOp.YieldOp yop) {\n-                            Value p = block.context().getValue(yop.yieldValue());\n-                            block.op(branch(exit.successor(p)));\n-                        } else if (op instanceof Lowerable lop) {\n-                            \/\/ @@@ Composition of lowerable ops\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            \/\/ Copy\n-                            block.apply(op);\n-                        }\n-                        return block;\n-                    };\n-                } else {\n-                    Block.Builder nextPred = pred;\n-                    opt = (block, op) -> {\n-                        if (op instanceof CoreOp.YieldOp yop) {\n-                            Value p = block.context().getValue(yop.yieldValue());\n-                            if (cop instanceof JavaConditionalAndOp) {\n-                                block.op(conditionalBranch(p, nextPred.successor(), exit.successor(p)));\n-                            } else {\n-                                block.op(conditionalBranch(p, exit.successor(p), nextPred.successor()));\n-                            }\n-                        } else if (op instanceof Lowerable lop) {\n-                            \/\/ @@@ Composition of lowerable ops\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            \/\/ Copy\n-                            block.apply(op);\n-                        }\n-                        return block;\n-                    };\n-                }\n-\n-                Body fromPred = bodies.get(i);\n-                if (i == 0) {\n-                    startBlock.transformBody(fromPred, List.of(), opt);\n-                } else {\n-                    pred = startBlock.block(fromPred.bodyType().parameterTypes());\n-                    pred.transformBody(fromPred, pred.parameters(), opT.andThen(opt));\n-                }\n-            }\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return BOOLEAN;\n-        }\n-    }\n-\n-    \/**\n-     * The conditional-and operation, that can model Java language conditional-and expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaConditionalAndOp.NAME)\n-    public static final class JavaConditionalAndOp extends JavaConditionalOp {\n-\n-        public static class Builder {\n-            final Body.Builder ancestorBody;\n-            final List<Body.Builder> bodies;\n-\n-            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n-                this.ancestorBody = ancestorBody;\n-                this.bodies = new ArrayList<>();\n-                and(lhs);\n-                and(rhs);\n-            }\n-\n-            public Builder and(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n-                c.accept(body.entryBlock());\n-                bodies.add(body);\n-\n-                return this;\n-            }\n-\n-            public JavaConditionalAndOp build() {\n-                return new JavaConditionalAndOp(bodies);\n-            }\n-        }\n-\n-        public static final String NAME = \"java.cand\";\n-\n-        public JavaConditionalAndOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaConditionalAndOp(JavaConditionalAndOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc, ot);\n-        }\n-\n-        @Override\n-        public JavaConditionalAndOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaConditionalAndOp(this, cc, ot);\n-        }\n-\n-        JavaConditionalAndOp(List<Body.Builder> bodyCs) {\n-            super(NAME, bodyCs);\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            return lower(b, opT, this);\n-        }\n-    }\n-\n-    \/**\n-     * The conditional-or operation, that can model Java language conditional-or expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaConditionalOrOp.NAME)\n-    public static final class JavaConditionalOrOp extends JavaConditionalOp {\n-\n-        public static class Builder {\n-            final Body.Builder ancestorBody;\n-            final List<Body.Builder> bodies;\n-\n-            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n-                this.ancestorBody = ancestorBody;\n-                this.bodies = new ArrayList<>();\n-                or(lhs);\n-                or(rhs);\n-            }\n-\n-            public Builder or(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n-                c.accept(body.entryBlock());\n-                bodies.add(body);\n-\n-                return this;\n-            }\n-\n-            public JavaConditionalOrOp build() {\n-                return new JavaConditionalOrOp(bodies);\n-            }\n-        }\n-\n-        public static final String NAME = \"java.cor\";\n-\n-        public JavaConditionalOrOp(ExternalizedOp def) {\n-            super(def);\n-        }\n-\n-        JavaConditionalOrOp(JavaConditionalOrOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc, ot);\n-        }\n-\n-        @Override\n-        public JavaConditionalOrOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaConditionalOrOp(this, cc, ot);\n-        }\n-\n-        JavaConditionalOrOp(List<Body.Builder> bodyCs) {\n-            super(NAME, bodyCs);\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            return lower(b, opT, this);\n-        }\n-    }\n-\n-    \/**\n-     * The conditional operation, that can model Java language conditional operator {@code ?} expressions.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaConditionalExpressionOp.NAME)\n-    public static final class JavaConditionalExpressionOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaExpression {\n-\n-        public static final String NAME = \"java.cexpression\";\n-\n-        final TypeElement resultType;\n-        \/\/ {cond, truepart, falsepart}\n-        final List<Body> bodies;\n-\n-        public JavaConditionalExpressionOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Operation must have no operands\");\n-            }\n-\n-            \/\/ @@@ Validate\n-\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-            this.resultType = def.resultType();\n-        }\n-\n-        JavaConditionalExpressionOp(JavaConditionalExpressionOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            \/\/ Copy body\n-            this.bodies = that.bodies.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-            this.resultType = that.resultType;\n-        }\n-\n-        @Override\n-        public JavaConditionalExpressionOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaConditionalExpressionOp(this, cc, ot);\n-        }\n-\n-        JavaConditionalExpressionOp(TypeElement expressionType, List<Body.Builder> bodyCs) {\n-            super(NAME, List.of());\n-\n-            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n-            \/\/ @@@ when expressionType is null, we assume truepart and falsepart have the same yieldType\n-            this.resultType = expressionType == null ? bodies.get(1).yieldType() : expressionType;\n-\n-            if (bodies.size() < 3) {\n-                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n-            }\n-\n-            Body cond = bodies.get(0);\n-            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n-                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.bodyType());\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return bodies;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            Block.Builder exit = b.block(resultType());\n-            exit.context().mapValue(result(), exit.parameters().get(0));\n-\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-\n-            List<Block.Builder> builders = List.of(b.block(), b.block());\n-            b.transformBody(bodies.get(0), List.of(), opT.andThen((block, op) -> {\n-                if (op instanceof YieldOp yo) {\n-                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n-                            builders.get(0).successor(), builders.get(1).successor()));\n-                } else if (op instanceof Lowerable lop) {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    block = lop.lower(block, opT);\n-                } else {\n-                    block.op(op);\n-                }\n-                return block;\n-            }));\n-\n-            for (int i = 0; i < 2; i++) {\n-                builders.get(i).transformBody(bodies.get(i + 1), List.of(), opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp yop) {\n-                        block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n-                    } else if (op instanceof Lowerable lop) {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                    return block;\n-                }));\n-            }\n-\n-            return exit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    \/**\n-     * The try operation, that can model Java language try statements.\n-     *\/\n-    @OpFactory.OpDeclaration(JavaTryOp.NAME)\n-    public static final class JavaTryOp extends ExtendedOp\n-            implements Op.Nested, Op.Lowerable, JavaStatement {\n-\n-        public static final class BodyBuilder {\n-            final Body.Builder ancestorBody;\n-            final List<? extends TypeElement> resourceTypes;\n-            final Body.Builder resources;\n-\n-            BodyBuilder(Body.Builder ancestorBody, List<? extends TypeElement> resourceTypes, Body.Builder resources) {\n-                this.ancestorBody = ancestorBody;\n-                this.resourceTypes = resourceTypes;\n-                this.resources = resources;\n-            }\n-\n-            public CatchBuilder body(Consumer<Block.Builder> c) {\n-                Body.Builder body = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(VOID, resourceTypes));\n-                c.accept(body.entryBlock());\n-\n-                return new CatchBuilder(ancestorBody, resources, body);\n-            }\n-        }\n-\n-        public static final class CatchBuilder {\n-            final Body.Builder ancestorBody;\n-            final Body.Builder resources;\n-            final Body.Builder body;\n-            final List<Body.Builder> catchers;\n-\n-            CatchBuilder(Body.Builder ancestorBody, Body.Builder resources, Body.Builder body) {\n-                this.ancestorBody = ancestorBody;\n-                this.resources = resources;\n-                this.body = body;\n-                this.catchers = new ArrayList<>();\n-            }\n-\n-            \/\/ @@@ multi-catch\n-            public CatchBuilder _catch(TypeElement exceptionType, Consumer<Block.Builder> c) {\n-                Body.Builder _catch = Body.Builder.of(ancestorBody,\n-                        FunctionType.functionType(VOID, exceptionType));\n-                c.accept(_catch.entryBlock());\n-                catchers.add(_catch);\n-\n-                return this;\n-            }\n-\n-            public JavaTryOp _finally(Consumer<Block.Builder> c) {\n-                Body.Builder _finally = Body.Builder.of(ancestorBody, FunctionType.VOID);\n-                c.accept(_finally.entryBlock());\n-\n-                return new JavaTryOp(resources, body, catchers, _finally);\n-            }\n-\n-            public JavaTryOp noFinalizer() {\n-                return new JavaTryOp(resources, body, catchers, null);\n-            }\n-        }\n-\n-        static final String NAME = \"java.try\";\n-\n-        final Body resources;\n-        final Body body;\n-        final List<Body> catchers;\n-        final Body finalizer;\n-\n-        public static JavaTryOp create(ExternalizedOp def) {\n-            return new JavaTryOp(def);\n-        }\n-\n-        public JavaTryOp(ExternalizedOp def) {\n-            super(def);\n-\n-            List<Body> bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n-            Body first = bodies.get(0);\n-            if (first.bodyType().returnType().equals(VOID)) {\n-                this.resources = null;\n-                this.body = first;\n-            } else {\n-                this.resources = first;\n-                this.body = bodies.get(1);\n-            }\n-\n-            Body last = bodies.get(bodies.size() - 1);\n-            if (last.bodyType().parameterTypes().isEmpty()) {\n-                this.finalizer = last;\n-            } else {\n-                this.finalizer = null;\n-            }\n-            this.catchers = bodies.subList(\n-                    resources == null ? 1 : 2,\n-                    bodies.size() - (finalizer == null ? 0 : 1));\n-        }\n-\n-        JavaTryOp(JavaTryOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            if (that.resources != null) {\n-                this.resources = that.resources.transform(cc, ot).build(this);\n-            } else {\n-                this.resources = null;\n-            }\n-            this.body = that.body.transform(cc, ot).build(this);\n-            this.catchers = that.catchers.stream()\n-                    .map(b -> b.transform(cc, ot).build(this))\n-                    .toList();\n-            if (that.finalizer != null) {\n-                this.finalizer = that.finalizer.transform(cc, ot).build(this);\n-            } else {\n-                this.finalizer = null;\n-            }\n-        }\n-\n-        @Override\n-        public JavaTryOp transform(CopyContext cc, OpTransformer ot) {\n-            return new JavaTryOp(this, cc, ot);\n-        }\n-\n-        JavaTryOp(Body.Builder resourcesC,\n-                  Body.Builder bodyC,\n-                  List<Body.Builder> catchersC,\n-                  Body.Builder finalizerC) {\n-            super(NAME, List.of());\n-\n-            if (resourcesC != null) {\n-                this.resources = resourcesC.build(this);\n-                if (resources.bodyType().returnType().equals(VOID)) {\n-                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.bodyType());\n-                }\n-                if (!resources.bodyType().parameterTypes().isEmpty()) {\n-                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.bodyType());\n-                }\n-            } else {\n-                this.resources = null;\n-            }\n-\n-            this.body = bodyC.build(this);\n-            if (!body.bodyType().returnType().equals(VOID)) {\n-                throw new IllegalArgumentException(\"Try should return void: \" + body.bodyType());\n-            }\n-\n-            this.catchers = catchersC.stream().map(c -> c.build(this)).toList();\n-            for (Body _catch : catchers) {\n-                if (!_catch.bodyType().returnType().equals(VOID)) {\n-                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.bodyType());\n-                }\n-                if (_catch.bodyType().parameterTypes().size() != 1) {\n-                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.bodyType());\n-                }\n-            }\n-\n-            if (finalizerC != null) {\n-                this.finalizer = finalizerC.build(this);\n-                if (!finalizer.bodyType().returnType().equals(VOID)) {\n-                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.bodyType());\n-                }\n-                if (!finalizer.bodyType().parameterTypes().isEmpty()) {\n-                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.bodyType());\n-                }\n-            } else {\n-                this.finalizer = null;\n-            }\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            ArrayList<Body> bodies = new ArrayList<>();\n-            if (resources != null) {\n-                bodies.add(resources);\n-            }\n-            bodies.add(body);\n-            bodies.addAll(catchers);\n-            if (finalizer != null) {\n-                bodies.add(finalizer);\n-            }\n-            return bodies;\n-        }\n-\n-        public Body resources() {\n-            return resources;\n-        }\n-\n-        public Body body() {\n-            return body;\n-        }\n-\n-        public List<Body> catchers() {\n-            return catchers;\n-        }\n-\n-        public Body finalizer() {\n-            return finalizer;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            if (resources != null) {\n-                throw new UnsupportedOperationException(\"Lowering of try-with-resources is unsupported\");\n-            }\n-\n-            Block.Builder exit = b.block();\n-            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n-\n-            \/\/ Simple case with no catch and finally bodies\n-            if (catchers.isEmpty() && finalizer == null) {\n-                b.transformBody(body, List.of(), (block, op) -> {\n-                    if (op instanceof YieldOp) {\n-                        block.op(branch(exit.successor()));\n-                    } else {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        if (op instanceof Lowerable lop) {\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            block.op(op);\n-                        }\n-                    }\n-                    return block;\n-                });\n-                return exit;\n-            }\n-\n-            Block.Builder tryRegionEnter = b.block();\n-            Block.Builder tryRegionExit = b.block();\n-\n-            \/\/ Construct the catcher block builders\n-            List<Block.Builder> catchers = catchers().stream()\n-                    .map(catcher -> b.block())\n-                    .toList();\n-            Block.Builder catcherFinally;\n-            if (finalizer == null) {\n-                catcherFinally = null;\n-            } else {\n-                catcherFinally = b.block();\n-                catchers = new ArrayList<>(catchers);\n-                catchers.add(catcherFinally);\n-            }\n-\n-            \/\/ Enter the try exception region\n-            List<Block.Reference> exitHandlers = catchers.stream()\n-                    .map(Block.Builder::successor)\n-                    .toList();\n-            b.op(exceptionRegionEnter(tryRegionEnter.successor(), exitHandlers.reversed()));\n-\n-            OpTransformer tryExitTransformer;\n-            if (finalizer != null) {\n-                tryExitTransformer = opT.compose((block, op) -> {\n-                    if (op instanceof CoreOp.ReturnOp ||\n-                            (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromTry(lop))) {\n-                        return inlineFinalizer(block, exitHandlers, opT);\n-                    } else {\n-                        return block;\n-                    }\n-                });\n-            } else {\n-                tryExitTransformer = opT.compose((block, op) -> {\n-                    if (op instanceof CoreOp.ReturnOp ||\n-                            (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromTry(lop))) {\n-                        Block.Builder tryRegionReturnExit = block.block();\n-                        block.op(exceptionRegionExit(tryRegionReturnExit.successor(), exitHandlers));\n-                        return tryRegionReturnExit;\n-                    } else {\n-                        return block;\n-                    }\n-                });\n-            }\n-            \/\/ Inline the try body\n-            AtomicBoolean hasTryRegionExit = new AtomicBoolean();\n-            tryRegionEnter.transformBody(body, List.of(), tryExitTransformer.andThen((block, op) -> {\n-                if (op instanceof YieldOp) {\n-                    hasTryRegionExit.set(true);\n-                    block.op(branch(tryRegionExit.successor()));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, tryExitTransformer);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                }\n-                return block;\n-            }));\n-\n-            Block.Builder finallyEnter = null;\n-            if (finalizer != null) {\n-                finallyEnter = b.block();\n-                if (hasTryRegionExit.get()) {\n-                    \/\/ Exit the try exception region\n-                    tryRegionExit.op(exceptionRegionExit(finallyEnter.successor(), exitHandlers));\n-                }\n-            } else if (hasTryRegionExit.get()) {\n-                \/\/ Exit the try exception region\n-                tryRegionExit.op(exceptionRegionExit(exit.successor(), exitHandlers));\n-            }\n-\n-            \/\/ Inline the catch bodies\n-            for (int i = 0; i < this.catchers.size(); i++) {\n-                Block.Builder catcher = catchers.get(i);\n-                Body catcherBody = this.catchers.get(i);\n-                \/\/ Create the throwable argument\n-                Block.Parameter t = catcher.parameter(catcherBody.bodyType().parameterTypes().get(0));\n-\n-                if (finalizer != null) {\n-                    Block.Builder catchRegionEnter = b.block();\n-                    Block.Builder catchRegionExit = b.block();\n-\n-                    \/\/ Enter the catch exception region\n-                    Result catchExceptionRegion = catcher.op(\n-                            exceptionRegionEnter(catchRegionEnter.successor(), catcherFinally.successor()));\n-\n-                    OpTransformer catchExitTransformer = opT.compose((block, op) -> {\n-                        if (op instanceof CoreOp.ReturnOp) {\n-                            return inlineFinalizer(block, List.of(catcherFinally.successor()), opT);\n-                        } else if (op instanceof ExtendedOp.JavaLabelOp lop && ifExitFromTry(lop)) {\n-                            return inlineFinalizer(block, List.of(catcherFinally.successor()), opT);\n-                        } else {\n-                            return block;\n-                        }\n-                    });\n-                    \/\/ Inline the catch body\n-                    AtomicBoolean hasCatchRegionExit = new AtomicBoolean();\n-                    catchRegionEnter.transformBody(catcherBody, List.of(t), catchExitTransformer.andThen((block, op) -> {\n-                        if (op instanceof YieldOp) {\n-                            hasCatchRegionExit.set(true);\n-                            block.op(branch(catchRegionExit.successor()));\n-                        } else {\n-                            \/\/ @@@ Composition of lowerable ops\n-                            if (op instanceof Lowerable lop) {\n-                                block = lop.lower(block, catchExitTransformer);\n-                            } else {\n-                                block.op(op);\n-                            }\n-                        }\n-                        return block;\n-                    }));\n-\n-                    \/\/ Exit the catch exception region\n-                    if (hasCatchRegionExit.get()) {\n-                        hasTryRegionExit.set(true);\n-                        catchRegionExit.op(exceptionRegionExit(finallyEnter.successor(), catcherFinally.successor()));\n-                    }\n-                } else {\n-                    \/\/ Inline the catch body\n-                    catcher.transformBody(catcherBody, List.of(t), opT.andThen((block, op) -> {\n-                        if (op instanceof YieldOp) {\n-                            block.op(branch(exit.successor()));\n-                        } else {\n-                            \/\/ @@@ Composition of lowerable ops\n-                            if (op instanceof Lowerable lop) {\n-                                block = lop.lower(block, opT);\n-                            } else {\n-                                block.op(op);\n-                            }\n-                        }\n-                        return block;\n-                    }));\n-                }\n-            }\n-\n-            if (finalizer != null && hasTryRegionExit.get()) {\n-                \/\/ Inline the finally body\n-                finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp) {\n-                        block.op(branch(exit.successor()));\n-                    } else {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        if (op instanceof Lowerable lop) {\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            block.op(op);\n-                        }\n-                    }\n-                    return block;\n-                }));\n-            }\n-\n-            \/\/ Inline the finally body as a catcher of Throwable and adjusting to throw\n-            if (finalizer != null) {\n-                \/\/ Create the throwable argument\n-                Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n-\n-                catcherFinally.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp) {\n-                        block.op(_throw(t));\n-                    } else {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        if (op instanceof Lowerable lop) {\n-                            block = lop.lower(block, opT);\n-                        } else {\n-                            block.op(op);\n-                        }\n-                    }\n-                    return block;\n-                }));\n-            }\n-            return exit;\n-        }\n-\n-        boolean ifExitFromTry(JavaLabelOp lop) {\n-            Op target = lop.target();\n-            return target == this || ifAncestorOp(target, this);\n-        }\n-\n-        static boolean ifAncestorOp(Op ancestor, Op op) {\n-            while (op.ancestorBody() != null) {\n-                op = op.ancestorBody().parentOp();\n-                if (op == ancestor) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        Block.Builder inlineFinalizer(Block.Builder block1, List<Block.Reference> tryHandlers, OpTransformer opT) {\n-            Block.Builder finallyEnter = block1.block();\n-            Block.Builder finallyExit = block1.block();\n-\n-            block1.op(exceptionRegionExit(finallyEnter.successor(), tryHandlers));\n-\n-            \/\/ Inline the finally body\n-            finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block2, op2) -> {\n-                if (op2 instanceof YieldOp) {\n-                    block2.op(branch(finallyExit.successor()));\n-                } else {\n-                    \/\/ @@@ Composition of lowerable ops\n-                    if (op2 instanceof Lowerable lop2) {\n-                        block2 = lop2.lower(block2, opT);\n-                    } else {\n-                        block2.op(op2);\n-                    }\n-                }\n-                return block2;\n-            }));\n-\n-            return finallyExit;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return VOID;\n-        }\n-    }\n-\n-    \/\/\n-    \/\/ Patterns\n-\n-    static final String Pattern_CLASS_NAME = ExtendedOp_CLASS_NAME + \"$\" + Pattern.class.getSimpleName();\n-\n-    \/\/ Reified pattern nodes\n-\n-    \/**\n-     * Synthetic pattern types\n-     * \/\/ @@@ Replace with types extending from TypeElement\n-     *\/\n-    public sealed interface Pattern {\n-\n-        \/**\n-         * Synthetic type pattern type.\n-         *\n-         * @param <T> the type of values that are bound\n-         *\/\n-        final class Type<T> implements Pattern {\n-            Type() {\n-            }\n-        }\n-\n-        \/**\n-         * Synthetic record pattern type.\n-         *\n-         * @param <T> the type of records that are bound\n-         *\/\n-        final class Record<T> implements Pattern {\n-            Record() {\n-            }\n-        }\n-\n-        final class MatchAll implements Pattern {\n-            MatchAll() {\n-            }\n-        }\n-\n-        \/\/ @@@ Pattern types\n-\n-        JavaType PATTERN_BINDING_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n-                \"$\" + Type.class.getSimpleName()));\n-        JavaType PATTERN_RECORD_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n-                \"$\" + Pattern.Record.class.getSimpleName()));\n-\n-        JavaType PATTERN_MATCH_ALL_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n-                \"$\" + Pattern.MatchAll.class.getSimpleName()));\n-\n-        static JavaType bindingType(TypeElement t) {\n-            return parameterized(PATTERN_BINDING_TYPE, (JavaType) t);\n-        }\n-\n-        static JavaType recordType(TypeElement t) {\n-            return parameterized(PATTERN_RECORD_TYPE, (JavaType) t);\n-        }\n-\n-        static JavaType matchAllType() {\n-            return PATTERN_MATCH_ALL_TYPE;\n-        }\n-\n-        static TypeElement targetType(TypeElement t) {\n-            return ((ClassType) t).typeArguments().get(0);\n-        }\n-    }\n-\n-    \/**\n-     * Pattern operations.\n-     *\/\n-    public static final class PatternOps {\n-        PatternOps() {\n-        }\n-\n-        \/**\n-         * The pattern operation.\n-         *\/\n-        public sealed static abstract class PatternOp extends ExtendedOp implements Op.Pure {\n-            PatternOp(ExternalizedOp def) {\n-                super(def);\n-            }\n-\n-            PatternOp(PatternOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            PatternOp(String name, List<Value> operands) {\n-                super(name, operands);\n-            }\n-        }\n-\n-        \/**\n-         * The binding pattern operation, that can model Java language type patterns.\n-         *\/\n-        @OpFactory.OpDeclaration(TypePatternOp.NAME)\n-        public static final class TypePatternOp extends PatternOp {\n-            public static final String NAME = \"pattern.type\";\n-\n-            public static final String ATTRIBUTE_BINDING_NAME = NAME + \".binding.name\";\n-\n-            final TypeElement resultType;\n-            final String bindingName;\n-\n-            public static TypePatternOp create(ExternalizedOp def) {\n-                String name = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n-                        v -> switch (v) {\n-                            case String s -> s;\n-                            case null -> null;\n-                            default -> throw new UnsupportedOperationException(\"Unsupported pattern binding name value:\" + v);\n-                        });\n-                return new TypePatternOp(def, name);\n-            }\n-\n-            TypePatternOp(ExternalizedOp def, String bindingName) {\n-                super(def);\n-\n-                this.bindingName = bindingName;\n-                this.resultType = def.resultType();\n-            }\n-\n-            TypePatternOp(TypePatternOp that, CopyContext cc) {\n-                super(that, cc);\n-\n-                this.bindingName = that.bindingName;\n-                this.resultType = that.resultType;\n-            }\n-\n-            @Override\n-            public TypePatternOp transform(CopyContext cc, OpTransformer ot) {\n-                return new TypePatternOp(this, cc);\n-            }\n-\n-            TypePatternOp(TypeElement targetType, String bindingName) {\n-                super(NAME, List.of());\n-\n-                this.bindingName = bindingName;\n-                this.resultType = Pattern.bindingType(targetType);\n-            }\n-\n-            @Override\n-            public Map<String, Object> attributes() {\n-                HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-                if (bindingName != null) {\n-                    attrs.put(\"\", bindingName);\n-                }\n-                return attrs;\n-            }\n-\n-            public String bindingName() {\n-                return bindingName;\n-            }\n-\n-            public TypeElement targetType() {\n-                return Pattern.targetType(resultType());\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return resultType;\n-            }\n-        }\n-\n-        \/**\n-         * The record pattern operation, that can model Java language record patterns.\n-         *\/\n-        @OpFactory.OpDeclaration(RecordPatternOp.NAME)\n-        public static final class RecordPatternOp extends PatternOp {\n-            public static final String NAME = \"pattern.record\";\n-\n-            public static final String ATTRIBUTE_RECORD_DESCRIPTOR = NAME + \".descriptor\";\n-\n-            final RecordTypeRef recordDescriptor;\n-\n-            public static RecordPatternOp create(ExternalizedOp def) {\n-                RecordTypeRef recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR, true,\n-                        v -> switch (v) {\n-                            case RecordTypeRef rtd -> rtd;\n-                            case null, default ->\n-                                    throw new UnsupportedOperationException(\"Unsupported record type descriptor value:\" + v);\n-                        });\n-\n-                return new RecordPatternOp(def, recordDescriptor);\n-            }\n-\n-            RecordPatternOp(ExternalizedOp def, RecordTypeRef recordDescriptor) {\n-                super(def);\n-\n-                this.recordDescriptor = recordDescriptor;\n-            }\n-\n-            RecordPatternOp(RecordPatternOp that, CopyContext cc) {\n-                super(that, cc);\n-\n-                this.recordDescriptor = that.recordDescriptor;\n-            }\n-\n-            @Override\n-            public RecordPatternOp transform(CopyContext cc, OpTransformer ot) {\n-                return new RecordPatternOp(this, cc);\n-            }\n-\n-            RecordPatternOp(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n-                \/\/ The type of each value is a subtype of Pattern\n-                \/\/ The number of values corresponds to the number of components of the record\n-                super(NAME, List.copyOf(nestedPatterns));\n-\n-                this.recordDescriptor = recordDescriptor;\n-            }\n-\n-            @Override\n-            public Map<String, Object> attributes() {\n-                HashMap<String, Object> m = new HashMap<>(super.attributes());\n-                m.put(\"\", recordDescriptor);\n-                return Collections.unmodifiableMap(m);\n-            }\n-\n-            public RecordTypeRef recordDescriptor() {\n-                return recordDescriptor;\n-            }\n-\n-            public TypeElement targetType() {\n-                return Pattern.targetType(resultType());\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return Pattern.recordType(recordDescriptor.recordType());\n-            }\n-        }\n-\n-        @OpFactory.OpDeclaration(MatchAllPatternOp.NAME)\n-        public static final class MatchAllPatternOp extends PatternOp {\n-\n-            \/\/ @@@ we may need to add info about the type of the record component\n-            \/\/ this info can be used when lowering\n-\n-            public static final String NAME = \"pattern.match.all\";\n-\n-            public MatchAllPatternOp(ExternalizedOp def) {\n-                super(def);\n-            }\n-\n-            MatchAllPatternOp(MatchAllPatternOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            MatchAllPatternOp() {\n-                super(NAME, List.of());\n-            }\n-\n-            @Override\n-            public Op transform(CopyContext cc, OpTransformer ot) {\n-                return new MatchAllPatternOp(this, cc);\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return Pattern.matchAllType();\n-            }\n-        }\n-\n-        \/**\n-         * The match operation, that can model Java language pattern matching.\n-         *\/\n-        @OpFactory.OpDeclaration(MatchOp.NAME)\n-        public static final class MatchOp extends ExtendedOp implements Op.Isolated, Op.Lowerable {\n-            public static final String NAME = \"pattern.match\";\n-\n-            final Body pattern;\n-            final Body match;\n-\n-            public MatchOp(ExternalizedOp def) {\n-                super(def);\n-\n-                this.pattern = def.bodyDefinitions().get(0).build(this);\n-                this.match = def.bodyDefinitions().get(1).build(this);\n-            }\n-\n-            MatchOp(MatchOp that, CopyContext cc, OpTransformer ot) {\n-                super(that, cc);\n-\n-                this.pattern = that.pattern.transform(cc, ot).build(this);\n-                this.match = that.match.transform(cc, ot).build(this);\n-            }\n-\n-            @Override\n-            public MatchOp transform(CopyContext cc, OpTransformer ot) {\n-                return new MatchOp(this, cc, ot);\n-            }\n-\n-            MatchOp(Value target, Body.Builder patternC, Body.Builder matchC) {\n-                super(NAME,\n-                        List.of(target));\n-\n-                this.pattern = patternC.build(this);\n-                this.match = matchC.build(this);\n-            }\n-\n-            @Override\n-            public List<Body> bodies() {\n-                return List.of(pattern, match);\n-            }\n-\n-            public Body pattern() {\n-                return pattern;\n-            }\n-\n-            public Body match() {\n-                return match;\n-            }\n-\n-            public Value target() {\n-                return operands().get(0);\n-            }\n-\n-            @Override\n-            public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-                \/\/ No match block\n-                Block.Builder endNoMatchBlock = b.block();\n-                \/\/ Match block\n-                Block.Builder endMatchBlock = b.block();\n-                \/\/ End block\n-                Block.Builder endBlock = b.block();\n-                Block.Parameter matchResult = endBlock.parameter(resultType());\n-                \/\/ Map match operation result\n-                b.context().mapValue(result(), matchResult);\n-\n-                List<Value> patternValues = new ArrayList<>();\n-                Op patternYieldOp = pattern.entryBlock().terminatingOp();\n-                Op.Result rootPatternValue = (Op.Result) patternYieldOp.operands().get(0);\n-                Block.Builder currentBlock = lower(endNoMatchBlock, b,\n-                        patternValues,\n-                        rootPatternValue.op(),\n-                        b.context().getValue(target()));\n-                currentBlock.op(branch(endMatchBlock.successor()));\n-\n-                \/\/ No match block\n-                \/\/ Pass false\n-                endNoMatchBlock.op(branch(endBlock.successor(\n-                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n-\n-                \/\/ Match block\n-                \/\/ Lower match body and pass true\n-                endMatchBlock.transformBody(match, patternValues, opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp) {\n-                        block.op(branch(endBlock.successor(\n-                                block.op(constant(BOOLEAN, true)))));\n-                    } else if (op instanceof Lowerable lop) {\n-                        \/\/ @@@ Composition of lowerable ops\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                    return block;\n-                }));\n-\n-                return endBlock;\n-            }\n-\n-            static Block.Builder lower(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n-                                       List<Value> bindings,\n-                                       Op pattern, Value target) {\n-                return switch (pattern) {\n-                    case RecordPatternOp rp -> lowerRecordPattern(endNoMatchBlock, currentBlock, bindings, rp, target);\n-                    case TypePatternOp tp -> lowerTypePattern(endNoMatchBlock, currentBlock, bindings, tp, target);\n-                    case MatchAllPatternOp map -> lowerMatchAllPattern(currentBlock);\n-                    case null, default -> throw new UnsupportedOperationException(\"Unknown pattern op: \" + pattern);\n-                };\n-            }\n-\n-            static Block.Builder lowerRecordPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n-                                                    List<Value> bindings,\n-                                                    ExtendedOp.PatternOps.RecordPatternOp rpOp, Value target) {\n-                TypeElement targetType = rpOp.targetType();\n-\n-                Block.Builder nextBlock = currentBlock.block();\n-\n-                \/\/ Check if instance of target type\n-                Op.Result isInstance = currentBlock.op(CoreOp.instanceOf(targetType, target));\n-                currentBlock.op(conditionalBranch(isInstance, nextBlock.successor(), endNoMatchBlock.successor()));\n-\n-                currentBlock = nextBlock;\n-\n-                target = currentBlock.op(CoreOp.cast(targetType, target));\n-\n-                \/\/ Access component values of record and match on each as nested target\n-                List<Value> dArgs = rpOp.operands();\n-                for (int i = 0; i < dArgs.size(); i++) {\n-                    Op.Result nestedPattern = (Op.Result) dArgs.get(i);\n-                    \/\/ @@@ Handle exceptions?\n-                    Value nestedTarget = currentBlock.op(CoreOp.invoke(rpOp.recordDescriptor().methodForComponent(i), target));\n-\n-                    currentBlock = lower(endNoMatchBlock, currentBlock, bindings, nestedPattern.op(), nestedTarget);\n-                }\n-\n-                return currentBlock;\n-            }\n-\n-            static Block.Builder lowerTypePattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n-                                                  List<Value> bindings,\n-                                                  TypePatternOp tpOp, Value target) {\n-                TypeElement targetType = tpOp.targetType();\n-\n-                \/\/ Check if instance of target type\n-                Op p; \/\/ op that perform type check\n-                Op c; \/\/ op that perform conversion\n-                TypeElement s = target.type();\n-                TypeElement t = targetType;\n-                if (t instanceof PrimitiveType pt) {\n-                    if (s instanceof ClassType cs) {\n-                        \/\/ unboxing conversions\n-                        ClassType box;\n-                        if (cs.unbox().isEmpty()) { \/\/ s not a boxed type\n-                            \/\/ e.g. Number -> int, narrowing + unboxing\n-                            box = pt.box().orElseThrow();\n-                            p = CoreOp.instanceOf(box, target);\n-                        } else {\n-                            \/\/ e.g. Float -> float, unboxing\n-                            \/\/ e.g. Integer -> long, unboxing + widening\n-                            box = cs;\n-                            p = null;\n-                        }\n-                        c = invoke(MethodRef.method(box, t + \"Value\", t), target);\n-                    } else {\n-                        \/\/ primitive to primitive conversion\n-                        PrimitiveType ps = ((PrimitiveType) s);\n-                        if (isNarrowingPrimitiveConv(ps, pt) || isWideningPrimitiveConvWithCheck(ps, pt)\n-                                || isWideningAndNarrowingPrimitiveConv(ps, pt)) {\n-                            \/\/ e.g. int -> byte, narrowing\n-                            \/\/ e,g. int -> float, widening with check\n-                            \/\/ e.g. byte -> char, widening and narrowing\n-                            MethodRef mref = convMethodRef(s, t);\n-                            p = invoke(mref, target);\n-                        } else {\n-                            p = null;\n-                        }\n-                        c = CoreOp.conv(targetType, target);\n-                    }\n-                } else if (s instanceof PrimitiveType ps) {\n-                    \/\/ boxing conversions\n-                    \/\/ e.g. int -> Number, boxing + widening\n-                    \/\/ e.g. byte -> Byte, boxing\n-                    p = null;\n-                    ClassType box = ps.box().orElseThrow();\n-                    c = invoke(MethodRef.method(box, \"valueOf\", box, ps), target);\n-                } else if (!s.equals(t)) {\n-                    \/\/ reference to reference, but not identity\n-                    \/\/ e.g. Number -> Double, narrowing\n-                    \/\/ e.g. Short -> Object, widening\n-                    p = CoreOp.instanceOf(targetType, target);\n-                    c = CoreOp.cast(targetType, target);\n-                } else {\n-                    \/\/ identity reference\n-                    \/\/ e.g. Character -> Character\n-                    p = null;\n-                    c = null;\n-                }\n-\n-                if (c != null) {\n-                    if (p != null) {\n-                        \/\/ p != null, we need to perform type check at runtime\n-                        Block.Builder nextBlock = currentBlock.block();\n-                        currentBlock.op(conditionalBranch(currentBlock.op(p), nextBlock.successor(), endNoMatchBlock.successor()));\n-                        currentBlock = nextBlock;\n-                    }\n-                    target = currentBlock.op(c);\n-                }\n-\n-                bindings.add(target);\n-\n-                return currentBlock;\n-            }\n-\n-            private static boolean isWideningAndNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n-                return BYTE.equals(s) && CHAR.equals(t);\n-            }\n-\n-            private static boolean isWideningPrimitiveConvWithCheck(PrimitiveType s, PrimitiveType t) {\n-                return (INT.equals(s) && FLOAT.equals(t))\n-                        || (LONG.equals(s) && FLOAT.equals(t))\n-                        || (LONG.equals(s) && DOUBLE.equals(t));\n-            }\n-\n-            \/\/ s -> t is narrowing if order(t) <= order(s)\n-            private final static Map<PrimitiveType, Integer> narrowingOrder = Map.of(\n-                    BYTE, 1,\n-                    SHORT, 2,\n-                    CHAR, 2,\n-                    INT, 3,\n-                    LONG, 4,\n-                    FLOAT, 5,\n-                    DOUBLE, 6\n-            );\n-            private static boolean isNarrowingPrimitiveConv(PrimitiveType s, PrimitiveType t) {\n-                return narrowingOrder.get(t) <= narrowingOrder.get(s);\n-            }\n-\n-            private static MethodRef convMethodRef(TypeElement s, TypeElement t) {\n-                if (BYTE.equals(s) || SHORT.equals(s) || CHAR.equals(s)) {\n-                    s = INT;\n-                }\n-                String sn = capitalize(s.toString());\n-                String tn = capitalize(t.toString());\n-                String mn = \"is%sTo%sExact\".formatted(sn, tn);\n-                JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n-                return MethodRef.method(exactConversionSupport, mn, BOOLEAN, s);\n-            }\n-\n-            private static String capitalize(String s) {\n-                return s.substring(0, 1).toUpperCase() + s.substring(1);\n-            }\n-\n-            static Block.Builder lowerMatchAllPattern(Block.Builder currentBlock) {\n-                return currentBlock;\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return BOOLEAN;\n-            }\n-        }\n-    }\n-\n-\n-    \/**\n-     * A factory for extended and core operations.\n-     *\/\n-    \/\/ @@@ Compute lazily\n-    public static final OpFactory FACTORY = CoreOp.FACTORY.andThen(OpFactory.OP_FACTORY.get(ExtendedOp.class));\n-\n-\n-    \/**\n-     * Creates a continue operation.\n-     *\n-     * @return the continue operation\n-     *\/\n-    public static JavaContinueOp _continue() {\n-        return _continue(null);\n-    }\n-\n-    \/**\n-     * Creates a continue operation.\n-     *\n-     * @param label the value associated with where to continue from\n-     * @return the continue operation\n-     *\/\n-    public static JavaContinueOp _continue(Value label) {\n-        return new JavaContinueOp(label);\n-    }\n-\n-    \/**\n-     * Creates a break operation.\n-     *\n-     * @return the break operation\n-     *\/\n-    public static JavaBreakOp _break() {\n-        return _break(null);\n-    }\n-\n-    \/**\n-     * Creates a break operation.\n-     *\n-     * @param label the value associated with where to continue from\n-     * @return the break operation\n-     *\/\n-    public static JavaBreakOp _break(Value label) {\n-        return new JavaBreakOp(label);\n-    }\n-\n-    \/**\n-     * Creates a yield operation.\n-     *\n-     * @return the yield operation\n-     *\/\n-    public static JavaYieldOp java_yield() {\n-        return new JavaYieldOp();\n-    }\n-\n-    \/**\n-     * Creates a yield operation.\n-     *\n-     * @param operand the value to yield\n-     * @return the yield operation\n-     *\/\n-    public static JavaYieldOp java_yield(Value operand) {\n-        return new JavaYieldOp(operand);\n-    }\n-\n-    \/**\n-     * Creates a block operation.\n-     *\n-     * @param body the body builder of the operation to be built and become its child\n-     * @return the block operation\n-     *\/\n-    public static JavaBlockOp block(Body.Builder body) {\n-        return new JavaBlockOp(body);\n-    }\n-\n-    \/**\n-     * Creates a synchronized operation.\n-     *\n-     * @param expr the expression body builder of the operation to be built and become its child\n-     * @param blockBody the block body builder of the operation to be built and become its child\n-     * @return the synchronized operation\n-     *\/\n-    public static JavaSynchronizedOp synchronized_(Body.Builder expr, Body.Builder blockBody) {\n-        return new JavaSynchronizedOp(expr, blockBody);\n-    }\n-\n-    \/**\n-     * Creates a labeled operation.\n-     *\n-     * @param body the body builder of the operation to be built and become its child\n-     * @return the block operation\n-     *\/\n-    public static JavaLabeledOp labeled(Body.Builder body) {\n-        return new JavaLabeledOp(body);\n-    }\n-\n-    \/**\n-     * Creates an if operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @return the if operation builder\n-     *\/\n-    public static JavaIfOp.IfBuilder _if(Body.Builder ancestorBody) {\n-        return new JavaIfOp.IfBuilder(ancestorBody);\n-    }\n-\n-    \/\/ Pairs of\n-    \/\/   predicate ()boolean, body ()void\n-    \/\/ And one optional body ()void at the end\n-\n-    \/**\n-     * Creates an if operation.\n-     *\n-     * @param bodies the body builders of operation to be built and become its children\n-     * @return the if operation\n-     *\/\n-    public static JavaIfOp _if(List<Body.Builder> bodies) {\n-        return new JavaIfOp(bodies);\n-    }\n-\n-    \/**\n-     * Creates a switch expression operation.\n-     * <p>\n-     * The result type of the operation will be derived from the yield type of the second body\n-     *\n-     * @param target the switch target value\n-     * @param bodies the body builders of the operation to be built and become its children\n-     * @return the switch expression operation\n-     *\/\n-    public static JavaSwitchExpressionOp switchExpression(Value target, List<Body.Builder> bodies) {\n-        return new JavaSwitchExpressionOp(null, target, bodies);\n-    }\n-\n-    \/**\n-     * Creates a switch expression operation.\n-     *\n-     * @param resultType the result type of the expression\n-     * @param target     the switch target value\n-     * @param bodies     the body builders of the operation to be built and become its children\n-     * @return the switch expression operation\n-     *\/\n-    public static JavaSwitchExpressionOp switchExpression(TypeElement resultType, Value target,\n-                                                          List<Body.Builder> bodies) {\n-        Objects.requireNonNull(resultType);\n-        return new JavaSwitchExpressionOp(resultType, target, bodies);\n-    }\n-\n-    \/**\n-     * Creates a switch statement operation.\n-     * @param target the switch target value\n-     * @param bodies the body builders of the operation to be built and become its children\n-     * @return the switch statement operation\n-     *\/\n-    public static JavaSwitchStatementOp switchStatement(Value target, List<Body.Builder> bodies) {\n-        return new JavaSwitchStatementOp(target, bodies);\n-    }\n-\n-    \/**\n-     * Creates a switch fallthrough operation.\n-     *\n-     * @return the switch fallthrough operation\n-     *\/\n-    public static JavaSwitchFallthroughOp switchFallthroughOp() {\n-        return new JavaSwitchFallthroughOp();\n-    }\n-\n-    \/**\n-     * Creates a for operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param initTypes    the types of initialized variables\n-     * @return the for operation builder\n-     *\/\n-    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeElement... initTypes) {\n-        return _for(ancestorBody, List.of(initTypes));\n-    }\n-\n-    \/**\n-     * Creates a for operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param initTypes    the types of initialized variables\n-     * @return the for operation builder\n-     *\/\n-    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<? extends TypeElement> initTypes) {\n-        return new JavaForOp.InitBuilder(ancestorBody, initTypes);\n-    }\n-\n-\n-    \/**\n-     * Creates a for operation.\n-     *\n-     * @param init   the init body builder of the operation to be built and become its child\n-     * @param cond   the cond body builder of the operation to be built and become its child\n-     * @param update the update body builder of the operation to be built and become its child\n-     * @param body   the main body builder of the operation to be built and become its child\n-     * @return the for operation\n-     *\/\n-    \/\/ init ()Tuple<Var<T1>, Var<T2>, ..., Var<TN>>, or init ()void\n-    \/\/ cond (Var<T1>, Var<T2>, ..., Var<TN>)boolean\n-    \/\/ update (Var<T1>, Var<T2>, ..., Var<TN>)void\n-    \/\/ body (Var<T1>, Var<T2>, ..., Var<TN>)void\n-    public static JavaForOp _for(Body.Builder init,\n-                                 Body.Builder cond,\n-                                 Body.Builder update,\n-                                 Body.Builder body) {\n-        return new JavaForOp(init, cond, update, body);\n-    }\n-\n-    \/**\n-     * Creates an enhanced for operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param iterableType the iterable type\n-     * @param elementType  the element type\n-     * @return the enhanced for operation builder\n-     *\/\n-    public static JavaEnhancedForOp.ExpressionBuilder enhancedFor(Body.Builder ancestorBody,\n-                                                                  TypeElement iterableType, TypeElement elementType) {\n-        return new JavaEnhancedForOp.ExpressionBuilder(ancestorBody, iterableType, elementType);\n-    }\n-\n-    \/\/ expression ()I<E>\n-    \/\/ init (E )Var<T>\n-    \/\/ body (Var<T> )void\n-\n-    \/**\n-     * Creates an enhanced for operation.\n-     *\n-     * @param expression the expression body builder of the operation to be built and become its child\n-     * @param init       the init body builder of the operation to be built and become its child\n-     * @param body       the main body builder of the operation to be built and become its child\n-     * @return the enhanced for operation\n-     *\/\n-    public static JavaEnhancedForOp enhancedFor(Body.Builder expression,\n-                                                Body.Builder init,\n-                                                Body.Builder body) {\n-        return new JavaEnhancedForOp(expression, init, body);\n-    }\n-\n-    \/**\n-     * Creates a while operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @return the while operation builder\n-     *\/\n-    public static JavaWhileOp.PredicateBuilder _while(Body.Builder ancestorBody) {\n-        return new JavaWhileOp.PredicateBuilder(ancestorBody);\n-    }\n-\n-    \/**\n-     * Creates a while operation.\n-     *\n-     * @param predicate the predicate body builder of the operation to be built and become its child\n-     * @param body      the main body builder of the operation to be built and become its child\n-     * @return the while operation\n-     *\/\n-    \/\/ predicate, ()boolean, may be null for predicate returning true\n-    \/\/ body, ()void\n-    public static JavaWhileOp _while(Body.Builder predicate, Body.Builder body) {\n-        return new JavaWhileOp(predicate, body);\n-    }\n-\n-    \/**\n-     * Creates a do operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @return the do operation builder\n-     *\/\n-    public static JavaDoWhileOp.BodyBuilder doWhile(Body.Builder ancestorBody) {\n-        return new JavaDoWhileOp.BodyBuilder(ancestorBody);\n-    }\n-\n-    \/**\n-     * Creates a do operation.\n-     *\n-     * @param predicate the predicate body builder of the operation to be built and become its child\n-     * @param body      the main body builder of the operation to be built and become its child\n-     * @return the do operation\n-     *\/\n-    public static JavaDoWhileOp doWhile(Body.Builder body, Body.Builder predicate) {\n-        return new JavaDoWhileOp(body, predicate);\n-    }\n-\n-    \/**\n-     * Creates a conditional-and operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param lhs          a consumer that builds the left-hand side body\n-     * @param rhs          a consumer that builds the right-hand side body\n-     * @return the conditional-and operation builder\n-     *\/\n-    public static JavaConditionalAndOp.Builder conditionalAnd(Body.Builder ancestorBody,\n-                                                              Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n-        return new JavaConditionalAndOp.Builder(ancestorBody, lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a conditional-or operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param lhs          a consumer that builds the left-hand side body\n-     * @param rhs          a consumer that builds the right-hand side body\n-     * @return the conditional-or operation builder\n-     *\/\n-    public static JavaConditionalOrOp.Builder conditionalOr(Body.Builder ancestorBody,\n-                                                            Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n-        return new JavaConditionalOrOp.Builder(ancestorBody, lhs, rhs);\n-    }\n-\n-    \/**\n-     * Creates a conditional-and operation\n-     *\n-     * @param bodies the body builders of operation to be built and become its children\n-     * @return the conditional-and operation\n-     *\/\n-    \/\/ predicates, ()boolean\n-    public static JavaConditionalAndOp conditionalAnd(List<Body.Builder> bodies) {\n-        return new JavaConditionalAndOp(bodies);\n-    }\n-\n-    \/**\n-     * Creates a conditional-or operation\n-     *\n-     * @param bodies the body builders of operation to be built and become its children\n-     * @return the conditional-or operation\n-     *\/\n-    \/\/ predicates, ()boolean\n-    public static JavaConditionalOrOp conditionalOr(List<Body.Builder> bodies) {\n-        return new JavaConditionalOrOp(bodies);\n-    }\n-\n-    \/**\n-     * Creates a conditional operation\n-     *\n-     * @param expressionType the result type of the expression\n-     * @param bodies         the body builders of operation to be built and become its children\n-     * @return the conditional operation\n-     *\/\n-    public static JavaConditionalExpressionOp conditionalExpression(TypeElement expressionType,\n-                                                                    List<Body.Builder> bodies) {\n-        Objects.requireNonNull(expressionType);\n-        return new JavaConditionalExpressionOp(expressionType, bodies);\n-    }\n-\n-    \/**\n-     * Creates a conditional operation\n-     * <p>\n-     * The result type of the operation will be derived from the yield type of the second body\n-     *\n-     * @param bodies the body builders of operation to be built and become its children\n-     * @return the conditional operation\n-     *\/\n-    public static JavaConditionalExpressionOp conditionalExpression(List<Body.Builder> bodies) {\n-        return new JavaConditionalExpressionOp(null, bodies);\n-    }\n-\n-    \/**\n-     * Creates try operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param c            a consumer that builds the try body\n-     * @return the try operation builder\n-     *\/\n-    public static JavaTryOp.CatchBuilder _try(Body.Builder ancestorBody, Consumer<Block.Builder> c) {\n-        Body.Builder _try = Body.Builder.of(ancestorBody, FunctionType.VOID);\n-        c.accept(_try.entryBlock());\n-        return new JavaTryOp.CatchBuilder(ancestorBody, null, _try);\n-    }\n-\n-    \/**\n-     * Creates try-with-resources operation builder.\n-     *\n-     * @param ancestorBody the nearest ancestor body builder from which to construct\n-     *                     body builders for this operation\n-     * @param c            a consumer that builds the resources body\n-     * @return the try-with-resources operation builder\n-     *\/\n-    public static JavaTryOp.BodyBuilder tryWithResources(Body.Builder ancestorBody,\n-                                                         List<? extends TypeElement> resourceTypes,\n-                                                         Consumer<Block.Builder> c) {\n-        resourceTypes = resourceTypes.stream().map(VarType::varType).toList();\n-        Body.Builder resources = Body.Builder.of(ancestorBody,\n-                FunctionType.functionType(TupleType.tupleType(resourceTypes)));\n-        c.accept(resources.entryBlock());\n-        return new JavaTryOp.BodyBuilder(ancestorBody, resourceTypes, resources);\n-    }\n-\n-    \/\/ resources ()Tuple<Var<R1>, Var<R2>, ..., Var<RN>>, or null\n-    \/\/ try (Var<R1>, Var<R2>, ..., Var<RN>)void, or try ()void\n-    \/\/ catch (E )void, where E <: Throwable\n-    \/\/ finally ()void, or null\n-\n-    \/**\n-     * Creates a try or try-with-resources operation.\n-     *\n-     * @param resources the try body builder of the operation to be built and become its child,\n-     *                  may be null\n-     * @param body      the try body builder of the operation to be built and become its child\n-     * @param catchers  the catch body builders of the operation to be built and become its children\n-     * @param finalizer the finalizer body builder of the operation to be built and become its child\n-     * @return the try or try-with-resources operation\n-     *\/\n-    public static JavaTryOp _try(Body.Builder resources,\n-                                 Body.Builder body,\n-                                 List<Body.Builder> catchers,\n-                                 Body.Builder finalizer) {\n-        return new JavaTryOp(resources, body, catchers, finalizer);\n-    }\n-\n-    \/\/\n-    \/\/ Patterns\n-\n-    \/**\n-     * Creates a pattern match operation.\n-     *\n-     * @param target  the target value\n-     * @param pattern the pattern body builder of the operation to be built and become its child\n-     * @param match   the match body builder of the operation to be built and become its child\n-     * @return the pattern match operation\n-     *\/\n-    public static PatternOps.MatchOp match(Value target,\n-                                           Body.Builder pattern, Body.Builder match) {\n-        return new PatternOps.MatchOp(target, pattern, match);\n-    }\n-\n-    \/**\n-     * Creates a pattern binding operation.\n-     *\n-     * @param type        the type of value to be bound\n-     * @param bindingName the binding name\n-     * @return the pattern binding operation\n-     *\/\n-    public static PatternOps.TypePatternOp typePattern(TypeElement type, String bindingName) {\n-        return new PatternOps.TypePatternOp(type, bindingName);\n-    }\n-\n-    \/**\n-     * Creates a record pattern operation.\n-     *\n-     * @param recordDescriptor the record descriptor\n-     * @param nestedPatterns   the nested pattern values\n-     * @return the record pattern operation\n-     *\/\n-    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, Value... nestedPatterns) {\n-        return recordPattern(recordDescriptor, List.of(nestedPatterns));\n-    }\n-\n-    \/**\n-     * Creates a record pattern operation.\n-     *\n-     * @param recordDescriptor the record descriptor\n-     * @param nestedPatterns   the nested pattern values\n-     * @return the record pattern operation\n-     *\/\n-    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n-        return new PatternOps.RecordPatternOp(recordDescriptor, nestedPatterns);\n-    }\n-\n-    public static PatternOps.MatchAllPatternOp matchAllPattern() {\n-        return new PatternOps.MatchAllPatternOp();\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExtendedOp.java","additions":0,"deletions":3745,"binary":false,"changes":3745,"status":"deleted"},{"patch":"@@ -32,0 +32,4 @@\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -33,2 +37,1 @@\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.op.*;\n+import jdk.incubator.code.dialect.core.FunctionType;\n@@ -39,4 +42,4 @@\n-import jdk.incubator.code.type.CoreTypeFactory;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.TypeElementFactory;\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.core.CoreTypeFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -180,1 +183,1 @@\n-        Op op = fromString(ExtendedOp.FACTORY, in).get(0);\n+        Op op = fromString(JavaOp.FACTORY, in).get(0);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/OpParser.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -35,2 +35,2 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/tools\/renderer\/SRRenderer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,3 +29,6 @@\n-import jdk.incubator.code.op.OpFactory;\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.OpFactory;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.*;\n+\n@@ -35,3 +38,4 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.*;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaOp.*;\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -38,1 +38,0 @@\n-import java.util.Arrays;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpWriter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,2 +43,4 @@\n-    exports jdk.incubator.code.op;\n-    exports jdk.incubator.code.type;\n+    exports jdk.incubator.code.dialect;\n+    exports jdk.incubator.code.dialect.anf;\n+    exports jdk.incubator.code.dialect.core;\n+    exports jdk.incubator.code.dialect.java;\n","filename":"src\/jdk.incubator.code\/share\/classes\/module-info.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -28,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -74,1 +75,1 @@\n-        return CoreOp.ArrayLengthOp[][][][][][][].class;\n+        return JavaOp.ArrayLengthOp[][][][][][][].class;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockIndexes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -36,2 +37,2 @@\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -39,3 +40,3 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.INT;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.INT;\n@@ -47,1 +48,1 @@\n-                    LambdaOp lop = lambda(fe.parentBody(), functionType(INT, INT), JavaType.type(FunctionType.class))\n+                    JavaOp.LambdaOp lop = JavaOp.lambda(fe.parentBody(), functionType(INT, INT), JavaType.type(FunctionType.class))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockParameters.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -31,5 +32,5 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.FunctionType.VOID;\n-import static jdk.incubator.code.type.JavaType.INT;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.FunctionType.VOID;\n+import static jdk.incubator.code.dialect.java.JavaType.INT;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n@@ -46,1 +47,1 @@\n-    public LambdaOp f() {\n+    public JavaOp.LambdaOp f() {\n@@ -49,1 +50,1 @@\n-        return SSA.transform((LambdaOp) Op.ofQuotable(iboq).get().op());\n+        return SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(iboq).get().op());\n@@ -54,1 +55,1 @@\n-        LambdaOp f = f();\n+        JavaOp.LambdaOp f = f();\n@@ -62,1 +63,1 @@\n-        var addop = add(a, b);\n+        var addop = JavaOp.add(a, b);\n@@ -69,1 +70,1 @@\n-        LambdaOp f = f();\n+        JavaOp.LambdaOp f = f();\n@@ -86,1 +87,1 @@\n-        LambdaOp f = f();\n+        JavaOp.LambdaOp f = f();\n@@ -98,1 +99,1 @@\n-        LambdaOp f = f();\n+        JavaOp.LambdaOp f = f();\n@@ -110,1 +111,1 @@\n-        LambdaOp f = f();\n+        JavaOp.LambdaOp f = f();\n@@ -117,1 +118,1 @@\n-        var result = block.op(add(a, b));\n+        var result = block.op(JavaOp.add(a, b));\n@@ -134,1 +135,1 @@\n-        Op.Result result = block.op(add(a, b));\n+        Op.Result result = block.op(JavaOp.add(a, b));\n@@ -172,1 +173,1 @@\n-        var result = anotherBlock.op(add(a, b));\n+        var result = anotherBlock.op(JavaOp.add(a, b));\n@@ -191,1 +192,1 @@\n-        var addOp = add(aa, ab);\n+        var addOp = JavaOp.add(aa, ab);\n@@ -259,1 +260,1 @@\n-        var lambdaOp = lambda(type(Runnable.class), body2);\n+        var lambdaOp = JavaOp.lambda(type(Runnable.class), body2);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -34,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -37,1 +38,1 @@\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -40,1 +41,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -44,10 +45,10 @@\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp.add;\n-import static jdk.incubator.code.op.CoreOp.closure;\n-import static jdk.incubator.code.op.CoreOp.closureCall;\n-import static jdk.incubator.code.op.CoreOp.constant;\n-import static jdk.incubator.code.op.CoreOp.func;\n-import static jdk.incubator.code.op.CoreOp.quoted;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.INT;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.java.JavaOp.add;\n+import static jdk.incubator.code.dialect.core.CoreOp.closure;\n+import static jdk.incubator.code.dialect.core.CoreOp.closureCall;\n+import static jdk.incubator.code.dialect.core.CoreOp.constant;\n+import static jdk.incubator.code.dialect.core.CoreOp.func;\n+import static jdk.incubator.code.dialect.core.CoreOp.quoted;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.INT;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n@@ -96,1 +97,1 @@\n-                    Op.Result or = block.op(CoreOp.invoke(TestClosureOps.Builder.ACCEPT_METHOD, cquoted));\n+                    Op.Result or = block.op(JavaOp.invoke(TestClosureOps.Builder.ACCEPT_METHOD, cquoted));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExternalizableOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -32,2 +32,2 @@\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -41,5 +41,5 @@\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp.branch;\n-import static jdk.incubator.code.op.CoreOp.conditionalBranch;\n-import static jdk.incubator.code.op.CoreOp.constant;\n-import static jdk.incubator.code.op.CoreOp.func;\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.core.CoreOp.branch;\n+import static jdk.incubator.code.dialect.core.CoreOp.conditionalBranch;\n+import static jdk.incubator.code.dialect.core.CoreOp.constant;\n+import static jdk.incubator.code.dialect.core.CoreOp.func;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -33,2 +34,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -37,1 +38,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -43,10 +44,10 @@\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp._throw;\n-import static jdk.incubator.code.op.CoreOp.branch;\n-import static jdk.incubator.code.op.CoreOp.constant;\n-import static jdk.incubator.code.op.CoreOp.exceptionRegionEnter;\n-import static jdk.incubator.code.op.CoreOp.exceptionRegionExit;\n-import static jdk.incubator.code.op.CoreOp.func;\n-import static jdk.incubator.code.type.FunctionType.*;\n-import static jdk.incubator.code.type.JavaType.*;\n-import static jdk.incubator.code.type.JavaType.VOID;\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.java.JavaOp._throw;\n+import static jdk.incubator.code.dialect.core.CoreOp.branch;\n+import static jdk.incubator.code.dialect.core.CoreOp.constant;\n+import static jdk.incubator.code.dialect.java.JavaOp.exceptionRegionEnter;\n+import static jdk.incubator.code.dialect.java.JavaOp.exceptionRegionExit;\n+import static jdk.incubator.code.dialect.core.CoreOp.func;\n+import static jdk.incubator.code.dialect.core.FunctionType.*;\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n+import static jdk.incubator.code.dialect.java.JavaType.VOID;\n@@ -89,2 +90,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -98,2 +99,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -105,2 +106,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -112,2 +113,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -181,2 +182,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -191,2 +192,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -198,2 +199,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -205,2 +206,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -279,2 +280,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -288,2 +289,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -297,2 +298,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -303,2 +304,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -312,2 +313,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 4))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 4))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -319,2 +320,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 5))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 5))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -403,2 +404,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -411,2 +412,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -422,2 +423,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -430,2 +431,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -437,2 +438,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n@@ -444,2 +445,2 @@\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n-                        b.op(CoreOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(JavaOp.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":54,"deletions":53,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExpressionGraphs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -31,1 +31,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -34,3 +34,3 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.INT;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.INT;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -22,1 +23,1 @@\n-        var invokeOps = f.elements().filter(ce -> ce instanceof CoreOp.InvokeOp).map(ce -> ((CoreOp.InvokeOp) ce)).toList();\n+        var invokeOps = f.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> ((JavaOp.InvokeOp) ce)).toList();\n@@ -32,1 +33,1 @@\n-        for (CoreOp.InvokeOp invokeOp : invokeOps) {\n+        for (JavaOp.InvokeOp invokeOp : invokeOps) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeOp.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInvokeSuper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -35,4 +36,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.CoreOp.FuncOp;\n-import jdk.incubator.code.op.CoreOp.LambdaOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import jdk.incubator.code.dialect.java.JavaOp.LambdaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -50,5 +51,5 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.op.CoreOp.constant;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.INT;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.CoreOp.constant;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.INT;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n@@ -85,1 +86,1 @@\n-                        return lambda(qblock.parentBody(),\n+                        return JavaOp.lambda(qblock.parentBody(),\n@@ -92,1 +93,1 @@\n-                                            lblock.op(add(i, li))\n+                                            lblock.op(JavaOp.add(i, li))\n@@ -98,1 +99,1 @@\n-                    Op.Result or = block.op(invoke(Builder.ACCEPT_METHOD, lquoted));\n+                    Op.Result or = block.op(JavaOp.invoke(Builder.ACCEPT_METHOD, lquoted));\n@@ -122,1 +123,1 @@\n-                    LambdaOp lambda = lambda(block.parentBody(),\n+                    LambdaOp lambda = JavaOp.lambda(block.parentBody(),\n@@ -128,1 +129,1 @@\n-                                        lblock.op(add(i, li))));\n+                                        lblock.op(JavaOp.add(i, li))));\n@@ -133,1 +134,1 @@\n-                    Op.Result or = block.op(invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n+                    Op.Result or = block.op(JavaOp.invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n@@ -239,1 +240,1 @@\n-        CoreOp.LambdaOp lop = (CoreOp.LambdaOp) quoted.op();\n+        LambdaOp lop = (LambdaOp) quoted.op();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -30,1 +31,1 @@\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -33,1 +34,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -37,3 +38,3 @@\n-import static jdk.incubator.code.type.MethodRef.method;\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.MethodRef.method;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n@@ -87,1 +88,1 @@\n-                    Op.Result queryable = block.op(invoke(md, query, quotedLambda));\n+                    Op.Result queryable = block.op(JavaOp.invoke(md, query, quotedLambda));\n@@ -121,1 +122,1 @@\n-                        Op.Result queryResult = block.op(invoke(md, query));\n+                        Op.Result queryResult = block.op(JavaOp.invoke(md, query));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -38,2 +39,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -59,1 +60,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, F).getFirst();\n+        Op op = OpParser.fromString(JavaOp.FACTORY, F).getFirst();\n@@ -91,1 +92,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, IF_ELSE).getFirst();\n+        Op op = OpParser.fromString(JavaOp.FACTORY, IF_ELSE).getFirst();\n@@ -129,1 +130,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, LOOP).getFirst();\n+        Op op = OpParser.fromString(JavaOp.FACTORY, LOOP).getFirst();\n@@ -198,1 +199,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, IF_ELSE_NESTED).getFirst();\n+        Op op = OpParser.fromString(JavaOp.FACTORY, IF_ELSE_NESTED).getFirst();\n@@ -259,1 +260,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, LOOP_NESTED).getFirst();\n+        Op op = OpParser.fromString(JavaOp.FACTORY, LOOP_NESTED).getFirst();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -29,3 +30,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.FieldRef;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -45,6 +46,6 @@\n-import static jdk.incubator.code.op.CoreOp.arrayStoreOp;\n-import static jdk.incubator.code.op.CoreOp.constant;\n-import static jdk.incubator.code.op.CoreOp.fieldLoad;\n-import static jdk.incubator.code.op.CoreOp.newArray;\n-import static jdk.incubator.code.type.MethodRef.method;\n-import static jdk.incubator.code.type.JavaType.*;\n+import static jdk.incubator.code.dialect.java.JavaOp.arrayStoreOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.constant;\n+import static jdk.incubator.code.dialect.java.JavaOp.fieldLoad;\n+import static jdk.incubator.code.dialect.java.JavaOp.newArray;\n+import static jdk.incubator.code.dialect.java.MethodRef.method;\n+import static jdk.incubator.code.dialect.java.JavaType.*;\n@@ -128,1 +129,1 @@\n-                case CoreOp.ThrowOp throwOp: {\n+                case JavaOp.ThrowOp throwOp: {\n@@ -158,1 +159,1 @@\n-        opBuilder.apply(CoreOp.invoke(method(PrintStream.class, \"println\", void.class, String.class), System_out, c));\n+        opBuilder.apply(JavaOp.invoke(method(PrintStream.class, \"println\", void.class, String.class), System_out, c));\n@@ -176,1 +177,1 @@\n-                case CoreOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(ADD_METHOD): {\n+                case JavaOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(ADD_METHOD): {\n@@ -179,1 +180,1 @@\n-                    Op.Result adaptedResult = block.apply(CoreOp.invoke(ADD_WITH_PRINT_METHOD, adaptedOperands));\n+                    Op.Result adaptedResult = block.apply(JavaOp.invoke(ADD_WITH_PRINT_METHOD, adaptedOperands));\n@@ -208,1 +209,1 @@\n-                case CoreOp.InvokeOp invokeOp: {\n+                case JavaOp.InvokeOp invokeOp: {\n@@ -227,1 +228,1 @@\n-    static void printCall(CopyContext cc, CoreOp.InvokeOp invokeOp, Function<Op, Op.Result> opBuilder) {\n+    static void printCall(CopyContext cc, JavaOp.InvokeOp invokeOp, Function<Op, Op.Result> opBuilder) {\n@@ -249,1 +250,1 @@\n-                        CoreOp.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), operand));\n+                        JavaOp.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), operand));\n@@ -261,1 +262,1 @@\n-                CoreOp.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n+                JavaOp.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n@@ -274,1 +275,1 @@\n-                    CoreOp.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), adaptedInvokeResult));\n+                    JavaOp.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), adaptedInvokeResult));\n@@ -284,1 +285,1 @@\n-                CoreOp.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n+                JavaOp.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -267,1 +267,1 @@\n-        return Stream.of(models).map(s -> OpParser.fromString(ExtendedOp.FACTORY, s).getFirst())\n+        return Stream.of(models).map(s -> OpParser.fromString(JavaOp.FACTORY, s).getFirst())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestNormalizeBlocksTransformer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -36,1 +36,0 @@\n-import java.util.stream.Stream;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOverloads.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,4 +12,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -22,5 +22,5 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.op.ExtendedOp.match;\n-import static jdk.incubator.code.op.ExtendedOp.typePattern;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.PrimitiveType.*;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.java.JavaOp.match;\n+import static jdk.incubator.code.dialect.java.JavaOp.typePattern;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.PrimitiveType.*;\n@@ -156,1 +156,1 @@\n-                    if (ce instanceof InvokeOp op) {\n+                    if (ce instanceof JavaOp.InvokeOp op) {\n@@ -378,1 +378,1 @@\n-            var pattern = Body.Builder.of(fblock.parentBody(), functionType(ExtendedOp.Pattern.bindingType(targetType)));\n+            var pattern = Body.Builder.of(fblock.parentBody(), functionType(JavaOp.Pattern.bindingType(targetType)));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -14,4 +14,4 @@\n-import static jdk.incubator.code.op.CoreOp.FuncOp;\n-import static jdk.incubator.code.op.CoreOp.VarAccessOp.VarLoadOp;\n-import static jdk.incubator.code.op.CoreOp.VarAccessOp.VarStoreOp;\n-import static jdk.incubator.code.op.CoreOp.VarOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.VarAccessOp.VarLoadOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.VarAccessOp.VarStoreOp;\n+import static jdk.incubator.code.dialect.core.CoreOp.VarOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestStringConcatTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchStatementOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -40,2 +41,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -111,1 +112,1 @@\n-                if (op instanceof CoreOp.InvokeOp iop) {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTraverse.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryNested.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUninitializedVariable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -38,2 +39,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -194,1 +195,1 @@\n-    static Stream<CoreOp.InvokeOp> invokes(CoreOp.FuncOp f) {\n+    static Stream<JavaOp.InvokeOp> invokes(CoreOp.FuncOp f) {\n@@ -196,1 +197,1 @@\n-            if (ce instanceof CoreOp.InvokeOp iop &&\n+            if (ce instanceof JavaOp.InvokeOp iop &&\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarArgsInvoke.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -39,3 +39,3 @@\n-import jdk.incubator.code.type.CoreTypeFactory;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreTypeFactory;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ActiveSet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -32,1 +32,1 @@\n-import static jdk.incubator.code.op.CoreOp.sub;\n+import static jdk.incubator.code.dialect.java.JavaOp.sub;\n@@ -42,1 +42,1 @@\n-        return opP(CoreOp.NegOp.class, operand);\n+        return opP(JavaOp.NegOp.class, operand);\n@@ -46,1 +46,1 @@\n-        return opP(CoreOp.AddOp.class, lhs, rhs);\n+        return opP(JavaOp.AddOp.class, lhs, rhs);\n@@ -50,1 +50,1 @@\n-        return opP(CoreOp.MulOp.class, lhs, rhs);\n+        return opP(JavaOp.MulOp.class, lhs, rhs);\n@@ -103,1 +103,1 @@\n-                return op instanceof CoreOp.InvokeOp c && c.invokeDescriptor().refType().equals(J_L_MATH);\n+                return op instanceof JavaOp.InvokeOp c && c.invokeDescriptor().refType().equals(J_L_MATH);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ExpressionElimination.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,4 +28,5 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -38,2 +39,2 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.JavaType.DOUBLE;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.java.JavaType.DOUBLE;\n@@ -131,1 +132,1 @@\n-            case CoreOp.NegOp _ -> {\n+            case JavaOp.NegOp _ -> {\n@@ -138,1 +139,1 @@\n-                yield block.op(neg(da));\n+                yield block.op(JavaOp.neg(da));\n@@ -140,1 +141,1 @@\n-            case CoreOp.AddOp _ -> {\n+            case JavaOp.AddOp _ -> {\n@@ -149,1 +150,1 @@\n-                yield block.op(add(dlhs, drhs));\n+                yield block.op(JavaOp.add(dlhs, drhs));\n@@ -151,1 +152,1 @@\n-            case CoreOp.MulOp _ -> {\n+            case JavaOp.MulOp _ -> {\n@@ -163,3 +164,3 @@\n-                yield block.op(add(\n-                        block.op(mul(dlhs, outputRhs)),\n-                        block.op(mul(outputLhs, drhs))));\n+                yield block.op(JavaOp.add(\n+                        block.op(JavaOp.mul(dlhs, outputRhs)),\n+                        block.op(JavaOp.mul(outputLhs, drhs))));\n@@ -173,1 +174,1 @@\n-            case CoreOp.InvokeOp c -> {\n+            case JavaOp.InvokeOp c -> {\n@@ -189,2 +190,2 @@\n-                    Op.Result cosx = block.op(invoke(J_L_MATH_COS, outputA));\n-                    yield block.op(mul(cosx, da));\n+                    Op.Result cosx = block.op(JavaOp.invoke(J_L_MATH_COS, outputA));\n+                    yield block.op(JavaOp.mul(cosx, da));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfBasicFuns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -39,1 +41,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -44,1 +46,1 @@\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -392,1 +394,1 @@\n-        Assert.assertTrue(Op.ofQuotable(f).get().op() instanceof CoreOp.LambdaOp);\n+        Assert.assertTrue(Op.ofQuotable(f).get().op() instanceof JavaOp.LambdaOp);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestInvokeSuper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -39,1 +39,0 @@\n-import jdk.incubator.code.CodeReflection;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestQuoted.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -29,4 +30,4 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -75,1 +76,1 @@\n-                trueBlock.op(CoreOp.invoke(MethodRef.method(TestSlots.class, \"m\", void.class, int.class), loadValue));\n+                trueBlock.op(JavaOp.invoke(MethodRef.method(TestSlots.class, \"m\", void.class, int.class), loadValue));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlotOps.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSynchronizedOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n@@ -29,1 +30,1 @@\n-import static jdk.incubator.code.op.CoreOp.sub;\n+import static jdk.incubator.code.dialect.java.JavaOp.sub;\n@@ -37,1 +38,1 @@\n-        return opP(CoreOp.NegOp.class, operand);\n+        return opP(JavaOp.NegOp.class, operand);\n@@ -41,1 +42,1 @@\n-        return opP(CoreOp.AddOp.class, lhs, rhs);\n+        return opP(JavaOp.AddOp.class, lhs, rhs);\n@@ -45,1 +46,1 @@\n-        return opP(CoreOp.MulOp.class, lhs, rhs);\n+        return opP(JavaOp.MulOp.class, lhs, rhs);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/ExpressionElimination.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestAssert.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryResult.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,3 +25,4 @@\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -30,5 +31,5 @@\n-import static jdk.incubator.code.type.JavaType.parameterized;\n-import static jdk.incubator.code.type.MethodRef.method;\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.java.JavaType.parameterized;\n+import static jdk.incubator.code.dialect.java.MethodRef.method;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n@@ -49,1 +50,1 @@\n-        LambdaOp l = (LambdaOp) Op.ofQuotable(f).get().op();\n+        JavaOp.LambdaOp l = (JavaOp.LambdaOp) Op.ofQuotable(f).get().op();\n@@ -55,1 +56,1 @@\n-        LambdaOp l = (LambdaOp) Op.ofQuotable(f).get().op();\n+        JavaOp.LambdaOp l = (JavaOp.LambdaOp) Op.ofQuotable(f).get().op();\n@@ -59,1 +60,1 @@\n-    private Queryable<?> insertQuery(JavaType elementType, String methodName, LambdaOp lambdaOp) {\n+    private Queryable<?> insertQuery(JavaType elementType, String methodName, JavaOp.LambdaOp lambdaOp) {\n@@ -70,1 +71,1 @@\n-                    Op.Result queryable = block.op(invoke(queryableType, md, query, fi));\n+                    Op.Result queryable = block.op(JavaOp.invoke(queryableType, md, query, fi));\n@@ -99,1 +100,1 @@\n-                    Op.Result queryResult = block.op(invoke(queryResultType, md, query));\n+                    Op.Result queryResult = block.op(JavaOp.invoke(queryResultType, md, query));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -24,8 +24,8 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.JavaType;\n-\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp.func;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.parameterized;\n-import static jdk.incubator.code.type.JavaType.type;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.core.CoreOp.func;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.parameterized;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -94,1 +94,1 @@\n-        CoreOp.FuncOp tf = (CoreOp.FuncOp) OpParser.fromString(ExtendedOp.FACTORY, tfText).getFirst();\n+        CoreOp.FuncOp tf = (CoreOp.FuncOp) OpParser.fromString(JavaOp.FACTORY, tfText).getFirst();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/TestLocation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -91,1 +91,1 @@\n-            o = OpParser.fromString(ExtendedOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/CodeReflectionTester.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -34,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -36,1 +37,1 @@\n-import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.dialect.java.MethodRef;\n@@ -41,8 +42,8 @@\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp.add;\n-import static jdk.incubator.code.op.CoreOp.constant;\n-import static jdk.incubator.code.op.CoreOp.func;\n-import static jdk.incubator.code.op.CoreOp.lambda;\n-import static jdk.incubator.code.type.FunctionType.functionType;\n-import static jdk.incubator.code.type.JavaType.INT;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.java.JavaOp.add;\n+import static jdk.incubator.code.dialect.core.CoreOp.constant;\n+import static jdk.incubator.code.dialect.core.CoreOp.func;\n+import static jdk.incubator.code.dialect.java.JavaOp.lambda;\n+import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.java.JavaType.INT;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n@@ -66,1 +67,1 @@\n-                    CoreOp.LambdaOp lambda = lambda(block.parentBody(),\n+                    JavaOp.LambdaOp lambda = lambda(block.parentBody(),\n@@ -78,1 +79,1 @@\n-                    Op.Result or = block.op(CoreOp.invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n+                    Op.Result or = block.op(JavaOp.invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n@@ -82,1 +83,1 @@\n-        List<Op> ops = OpParser.fromString(CoreOp.FACTORY, f.toText());\n+        List<Op> ops = OpParser.fromString(JavaOp.FACTORY, f.toText());\n@@ -99,2 +100,2 @@\n-        Op opE = OpParser.fromString(CoreOp.FACTORY, NAMED_BODY).get(0);\n-        Op opA = OpParser.fromString(CoreOp.FACTORY, opE.toText()).get(0);\n+        Op opE = OpParser.fromString(JavaOp.FACTORY, NAMED_BODY).get(0);\n+        Op opA = OpParser.fromString(JavaOp.FACTORY, opE.toText()).get(0);\n@@ -113,2 +114,2 @@\n-        Op opE = OpParser.fromString(CoreOp.FACTORY, ESCAPED_STRING).get(0);\n-        Op opA = OpParser.fromString(CoreOp.FACTORY, opE.toText()).get(0);\n+        Op opE = OpParser.fromString(JavaOp.FACTORY, ESCAPED_STRING).get(0);\n+        Op opA = OpParser.fromString(JavaOp.FACTORY, opE.toText()).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -37,3 +37,0 @@\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n@@ -41,1 +38,0 @@\n-import java.util.stream.Collectors;\n@@ -136,1 +132,1 @@\n-            o = OpParser.fromString(ExtendedOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/CodeReflectionTester.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.type.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -342,1 +343,1 @@\n-            case CoreOp.InvokeOp co -> {\n+            case JavaOp.InvokeOp co -> {\n@@ -354,1 +355,1 @@\n-            case CoreOp.NewOp no -> {\n+            case JavaOp.NewOp no -> {\n@@ -409,1 +410,1 @@\n-            case CoreOp.FieldAccessOp.FieldLoadOp fo -> {\n+            case JavaOp.FieldAccessOp.FieldLoadOp fo -> {\n@@ -419,1 +420,1 @@\n-            case CoreOp.FieldAccessOp.FieldStoreOp fo -> {\n+            case JavaOp.FieldAccessOp.FieldStoreOp fo -> {\n@@ -432,1 +433,1 @@\n-            case CoreOp.InstanceOfOp io -> {\n+            case JavaOp.InstanceOfOp io -> {\n@@ -436,1 +437,1 @@\n-            case CoreOp.CastOp co -> {\n+            case JavaOp.CastOp co -> {\n@@ -440,1 +441,1 @@\n-            case CoreOp.ArrayLengthOp arrayLengthOp -> {\n+            case JavaOp.ArrayLengthOp arrayLengthOp -> {\n@@ -444,1 +445,1 @@\n-            case CoreOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+            case JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n@@ -449,1 +450,1 @@\n-            case CoreOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+            case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n@@ -456,1 +457,1 @@\n-            case CoreOp.ArithmeticOperation arithmeticOperation -> {\n+            case JavaOp.ArithmeticOperation arithmeticOperation -> {\n@@ -461,1 +462,1 @@\n-            case CoreOp.TestOperation testOperation -> {\n+            case JavaOp.TestOperation testOperation -> {\n@@ -466,1 +467,1 @@\n-            case CoreOp.ConvOp convOp -> {\n+            case JavaOp.ConvOp convOp -> {\n@@ -471,1 +472,1 @@\n-            case CoreOp.ConcatOp concatOp -> {\n+            case JavaOp.ConcatOp concatOp -> {\n@@ -538,1 +539,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, JavaOp.InvokeOp.InvokeKind kind) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/PartialEvaluator.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -28,1 +29,0 @@\n-import java.util.*;\n@@ -50,1 +50,1 @@\n-            case CoreOp.InvokeOp _ -> false;\n+            case JavaOp.InvokeOp _ -> false;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/TestPE.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,5 +25,5 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp.JavaEnhancedForOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp.JavaEnhancedForOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -37,5 +37,5 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.op.ExtendedOp._continue;\n-import static jdk.incubator.code.op.ExtendedOp.enhancedFor;\n-import static jdk.incubator.code.type.JavaType.parameterized;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.java.JavaOp._continue;\n+import static jdk.incubator.code.dialect.java.JavaOp.enhancedFor;\n+import static jdk.incubator.code.dialect.java.JavaType.parameterized;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,4 +25,5 @@\n-import jdk.incubator.code.op.ExtendedOp.JavaEnhancedForOp;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.FunctionType;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaOp.JavaEnhancedForOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -33,5 +34,5 @@\n-import static jdk.incubator.code.op.CoreOp.*;\n-import static jdk.incubator.code.op.ExtendedOp._continue;\n-import static jdk.incubator.code.op.ExtendedOp.enhancedFor;\n-import static jdk.incubator.code.type.JavaType.parameterized;\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.core.CoreOp.*;\n+import static jdk.incubator.code.dialect.java.JavaOp._continue;\n+import static jdk.incubator.code.dialect.java.JavaOp.enhancedFor;\n+import static jdk.incubator.code.dialect.java.JavaType.parameterized;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n@@ -71,1 +72,1 @@\n-            final LambdaOp lambdaOp;\n+            final JavaOp.LambdaOp lambdaOp;\n@@ -74,1 +75,1 @@\n-                if (!(Op.ofQuotable(quotedLambda).get().op() instanceof LambdaOp lambdaOp)) {\n+                if (!(Op.ofQuotable(quotedLambda).get().op() instanceof JavaOp.LambdaOp lambdaOp)) {\n@@ -83,1 +84,1 @@\n-            LambdaOp op() {\n+            JavaOp.LambdaOp op() {\n@@ -200,1 +201,1 @@\n-            if (!(Op.ofQuotable(quotableConsumer).get().op() instanceof LambdaOp consumer)) {\n+            if (!(Op.ofQuotable(quotableConsumer).get().op() instanceof JavaOp.LambdaOp consumer)) {\n@@ -227,1 +228,1 @@\n-            if (!(Op.ofQuotable(quotableSupplier).get().op() instanceof LambdaOp supplier)) {\n+            if (!(Op.ofQuotable(quotableSupplier).get().op() instanceof JavaOp.LambdaOp supplier)) {\n@@ -233,1 +234,1 @@\n-            if (!(Op.ofQuotable(quotableAccumulator).get().op() instanceof LambdaOp accumulator)) {\n+            if (!(Op.ofQuotable(quotableAccumulator).get().op() instanceof JavaOp.LambdaOp accumulator)) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -42,1 +41,1 @@\n-import static jdk.incubator.code.type.JavaType.type;\n+import static jdk.incubator.code.dialect.java.JavaType.type;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.Op;\n+\n@@ -37,1 +37,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStreamUsingQuotable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,6 +36,6 @@\n-import jdk.incubator.code.type.ArrayType;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n-import jdk.incubator.code.type.PrimitiveType;\n-import jdk.incubator.code.type.TypeVariableType;\n-import jdk.incubator.code.type.WildcardType.BoundKind;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import jdk.incubator.code.dialect.java.TypeVariableType;\n+import jdk.incubator.code.dialect.java.WildcardType.BoundKind;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestErasure.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,4 +24,4 @@\n-import jdk.incubator.code.type.PrimitiveType;\n-import jdk.incubator.code.type.TypeVariableType;\n-import jdk.incubator.code.type.WildcardType;\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+import jdk.incubator.code.dialect.java.TypeVariableType;\n+import jdk.incubator.code.dialect.java.WildcardType;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -37,4 +37,4 @@\n-import jdk.incubator.code.type.ArrayType;\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.CoreTypeFactory;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.java.ArrayType;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.core.CoreTypeFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -49,1 +49,1 @@\n- * @modules jdk.incubator.code\/jdk.incubator.code.type.impl\n+ * @modules jdk.incubator.code\/jdk.incubator.code.dialect.java.impl\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-import jdk.incubator.code.type.*;\n-import jdk.incubator.code.type.impl.JavaTypeUtils;\n+import jdk.incubator.code.dialect.java.*;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -31,8 +31,0 @@\n-import java.lang.invoke.MethodHandles;\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-\n@@ -41,1 +33,1 @@\n- * @modules jdk.incubator.code\/jdk.incubator.code.type.impl\n+ * @modules jdk.incubator.code\/jdk.incubator.code.dialect.java.impl\n@@ -47,0 +39,8 @@\n+    interface X {\n+        Object value();\n+    }\n+\n+    interface Y extends X {\n+        Boolean value();\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n-import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.dialect.ExternalizableOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestAttributeSerialization.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-import jdk.incubator.code.op.CoreOp;\n-import jdk.incubator.code.op.ExtendedOp;\n-import jdk.incubator.code.type.CoreTypeFactory;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -126,1 +126,1 @@\n-                fb, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+                fb, JavaOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.io.StringWriter;\n@@ -39,1 +38,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -42,1 +41,1 @@\n-import java.util.Map;\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestNaming.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -35,3 +35,3 @@\n-import static jdk.incubator.code.op.CoreOp._return;\n-import static jdk.incubator.code.op.CoreOp.func;\n-import static jdk.incubator.code.type.FunctionType.VOID;\n+import static jdk.incubator.code.dialect.core.CoreOp._return;\n+import static jdk.incubator.code.dialect.core.CoreOp.func;\n+import static jdk.incubator.code.dialect.core.FunctionType.VOID;\n@@ -133,1 +133,1 @@\n-            o = OpParser.fromString(ExtendedOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreOp;\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelUniquenessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,3 +20,3 @@\n-                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<PatternTest2$R::<T extends java.lang.Number>>>\" -> {\n-                        %6 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n-                        %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<PatternTest2$R::<T extends java.lang.Number>>>\" = pattern.record %6 @java.ref:\"(PatternTest2$R::<T extends java.lang.Number> n)PatternTest2$R<PatternTest2$R::<T extends java.lang.Number>>\";\n+                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternTest2$R<PatternTest2$R::<T extends java.lang.Number>>>\" -> {\n+                        %6 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n+                        %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternTest2$R<PatternTest2$R::<T extends java.lang.Number>>>\" = pattern.record %6 @java.ref:\"(PatternTest2$R::<T extends java.lang.Number> n)PatternTest2$R<PatternTest2$R::<T extends java.lang.Number>>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternTest2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                        %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                        %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -73,2 +73,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -112,2 +112,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -170,6 +170,6 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle>\" -> {\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$ConcretePoint>\" = pattern.type @\"p\";\n-                                %12 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$Color>\" = pattern.type @\"c\";\n-                                %13 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$ColoredPoint>\" = pattern.record %11 %12 @java.ref:\"(PatternsTest$ConcretePoint p, PatternsTest$Color c)PatternsTest$ColoredPoint\";\n-                                %14 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$ColoredPoint>\" = pattern.type @\"lr\";\n-                                %15 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle>\" = pattern.record %13 %14 @java.ref:\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternsTest$Rectangle>\" -> {\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<PatternsTest$ConcretePoint>\" = pattern.type @\"p\";\n+                                %12 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<PatternsTest$Color>\" = pattern.type @\"c\";\n+                                %13 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternsTest$ColoredPoint>\" = pattern.record %11 %12 @java.ref:\"(PatternsTest$ConcretePoint p, PatternsTest$Color c)PatternsTest$ColoredPoint\";\n+                                %14 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<PatternsTest$ColoredPoint>\" = pattern.type @\"lr\";\n+                                %15 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternsTest$Rectangle>\" = pattern.record %13 %14 @java.ref:\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n@@ -231,2 +231,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -269,2 +269,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -316,2 +316,2 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" -> {\n-                                        %14 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" -> {\n+                                        %14 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n@@ -359,2 +359,2 @@\n-                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                        %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type;\n+                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                        %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type;\n@@ -382,4 +382,4 @@\n-                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle>\" -> {\n-                        %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$MatchAll\" = pattern.match.all;\n-                        %8 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<PatternsTest$ConcretePoint>\" = pattern.type @\"cp\";\n-                        %9 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternsTest$Rectangle>\" = pattern.record %7 %8 @java.ref:\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n+                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternsTest$Rectangle>\" -> {\n+                        %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$MatchAll\" = pattern.match.all;\n+                        %8 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<PatternsTest$ConcretePoint>\" = pattern.type @\"cp\";\n+                        %9 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<PatternsTest$Rectangle>\" = pattern.record %7 %8 @java.ref:\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n@@ -408,2 +408,2 @@\n-                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<byte>\" -> {\n-                        %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<byte>\" = pattern.type @\"b\";\n+                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<byte>\" -> {\n+                        %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<byte>\" = pattern.type @\"b\";\n@@ -432,2 +432,2 @@\n-                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<short>\" -> {\n-                        %7 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<short>\" = pattern.type @\"s\";\n+                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<short>\" -> {\n+                        %7 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<short>\" = pattern.type @\"s\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternsTest.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -347,3 +347,3 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A>\" -> {\n-                                %10 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A>\" = pattern.record %10 @java.ref:\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchExpressionTest$A>\" -> {\n+                                %10 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchExpressionTest$A>\" = pattern.record %10 @java.ref:\"(java.lang.Number n)SwitchExpressionTest$A\";\n@@ -364,2 +364,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %16 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %16 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -417,3 +417,3 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A>\" -> {\n-                                %12 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n-                                %13 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchExpressionTest$A>\" = pattern.record %12 @java.ref:\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchExpressionTest$A>\" -> {\n+                                %12 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                                %13 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchExpressionTest$A>\" = pattern.record %12 @java.ref:\"(java.lang.Number n)SwitchExpressionTest$A\";\n@@ -436,2 +436,2 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                        %19 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                        %19 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -463,2 +463,2 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                        %29 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                        %29 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -828,2 +828,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object>\" -> {\n-                                %12 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object>\" = pattern.type @\"o\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Object>\" -> {\n+                                %12 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Object>\" = pattern.type @\"o\";\n@@ -867,2 +867,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchExpressionTest2$B>\" -> {\n-                                %10 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchExpressionTest2$B>\" = pattern.type @\"b\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchExpressionTest2$B>\" -> {\n+                                %10 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchExpressionTest2$B>\" = pattern.type @\"b\";\n@@ -883,2 +883,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchExpressionTest2::C>\" -> {\n-                                %15 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchExpressionTest2::C>\" = pattern.type @\"c\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchExpressionTest2::C>\" -> {\n+                                %15 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchExpressionTest2::C>\" = pattern.type @\"c\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1090,2 +1090,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$K>\" -> {\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$K>\" = pattern.type @\"k\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchStatementTest$K>\" -> {\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchStatementTest$K>\" = pattern.type @\"k\";\n@@ -1109,2 +1109,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$J>\" -> {\n-                                %18 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<SwitchStatementTest$J>\" = pattern.type @\"j\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchStatementTest$J>\" -> {\n+                                %18 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<SwitchStatementTest$J>\" = pattern.type @\"j\";\n@@ -1171,2 +1171,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object>\" -> {\n-                                %15 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Object>\" = pattern.type @\"o\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Object>\" -> {\n+                                %15 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Object>\" = pattern.type @\"o\";\n@@ -1215,2 +1215,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" -> {\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" -> {\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n@@ -1234,2 +1234,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %18 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %18 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -1290,2 +1290,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" -> {\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" -> {\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n@@ -1309,2 +1309,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %18 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %18 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -1371,2 +1371,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" -> {\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" -> {\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n@@ -1390,2 +1390,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %18 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %18 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -1451,2 +1451,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" -> {\n-                                %11 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" -> {\n+                                %11 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n@@ -1467,2 +1467,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %16 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %16 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -1551,2 +1551,2 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" -> {\n-                                        %19 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" -> {\n+                                        %19 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n@@ -1581,2 +1581,2 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" -> {\n-                                        %31 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" -> {\n+                                        %31 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Integer>\" = pattern.type @\"i\";\n@@ -1656,2 +1656,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                %19 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type;\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                %19 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type;\n@@ -1675,2 +1675,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.RandomAccess>\" -> {\n-                                %26 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.RandomAccess>\" = pattern.type;\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.util.RandomAccess>\" -> {\n+                                %26 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.util.RandomAccess>\" = pattern.type;\n@@ -1694,2 +1694,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<int[]>\" -> {\n-                                %33 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<int[]>\" = pattern.type;\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<int[]>\" -> {\n+                                %33 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<int[]>\" = pattern.type;\n@@ -1713,2 +1713,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Stack[][]>\" -> {\n-                                %40 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Stack[][]>\" = pattern.type;\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.util.Stack[][]>\" -> {\n+                                %40 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.util.Stack[][]>\" = pattern.type;\n@@ -1732,2 +1732,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Collection[][][]>\" -> {\n-                                %47 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.util.Collection[][][]>\" = pattern.type;\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.util.Collection[][][]>\" -> {\n+                                %47 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.util.Collection[][][]>\" = pattern.type;\n@@ -1751,2 +1751,2 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" -> {\n-                                %54 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" -> {\n+                                %54 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n@@ -1810,3 +1810,3 @@\n-                            ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R>\" -> {\n-                                %9 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n-                                %10 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R>\" = pattern.record %9 @java.ref:\"(java.lang.Number n)SwitchStatementTest$R\";\n+                            ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchStatementTest$R>\" -> {\n+                                %9 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                                %10 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchStatementTest$R>\" = pattern.record %9 @java.ref:\"(java.lang.Number n)SwitchStatementTest$R\";\n@@ -1868,2 +1868,2 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" -> {\n-                                        %12 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" -> {\n+                                        %12 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.String>\" = pattern.type @\"s\";\n@@ -1902,3 +1902,3 @@\n-                                    ()java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R>\" -> {\n-                                        %28 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n-                                        %29 : java.type:\"jdk.incubator.code.op.ExtendedOp$Pattern$Record<SwitchStatementTest$R>\" = pattern.record %28 @java.ref:\"(java.lang.Number n)SwitchStatementTest$R\";\n+                                    ()java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchStatementTest$R>\" -> {\n+                                        %28 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Type<java.lang.Number>\" = pattern.type @\"n\";\n+                                        %29 : java.type:\"jdk.incubator.code.dialect.java.JavaOp$Pattern$Record<SwitchStatementTest$R>\" = pattern.record %28 @java.ref:\"(java.lang.Number n)SwitchStatementTest$R\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-import jdk.incubator.code.op.CoreOp.FuncOp;\n-import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -182,1 +182,1 @@\n-        return serialize(OpParser.fromString(ExtendedOp.FACTORY, d).get(0));\n+        return serialize(OpParser.fromString(JavaOp.FACTORY, d).get(0));\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.incubator.code.op.CoreOp.FuncOp;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestLocalCapture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.incubator.code.op.CoreOp.Var;\n+import jdk.incubator.code.dialect.core.CoreOp.Var;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import jdk.incubator.code.Quotable;\n-import jdk.incubator.code.op.CoreOp.Var;\n+import jdk.incubator.code.dialect.core.CoreOp.Var;\n@@ -40,1 +39,0 @@\n-import java.util.function.ToIntFunction;\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}