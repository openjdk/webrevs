{"files":[{"patch":"@@ -138,1 +138,2 @@\n-    static final OpFactory ONNX_OP_FACTORY = OpFactory.OP_FACTORY.get(ExplicitOnnxOps.class).andThen(OpFactory.OP_FACTORY.get(OnnxOps.class));\n+    static final OpFactory ONNX_OP_FACTORY = OpFactoryHelper.OP_FACTORY.get(ExplicitOnnxOps.class)\n+            .andThen(OpFactoryHelper.OP_FACTORY.get(OnnxOps.class));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/proto\/OnnxModelTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+package oracle.code.onnx.proto;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.extern.ExternalizedOp;\n+import jdk.incubator.code.extern.OpFactory;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public final class OpFactoryHelper {\n+\n+    \/**\n+     * A class value for lazily computing an operation factory for {@link Op operation} classes\n+     * annotated with {@link OpFactory.OpDeclaration} and enclosed within a given class to compute over.\n+     * <p>\n+     * Each enclosed class annotated with {@code OpDeclaration} must declare a public static method named {@code create}\n+     * with one parameter type of {@link ExternalizedOp} and return type that is the concrete class type.\n+     * Alternatively, the concrete class must declare public constructor with one parameter type of\n+     * {@link ExternalizedOp}.\n+     *\/\n+    static final ClassValue<OpFactory> OP_FACTORY = new ClassValue<>() {\n+        @Override\n+        protected OpFactory computeValue(Class<?> c) {\n+            \/\/ @@@ See https:\/\/bugs.openjdk.org\/browse\/JDK-8321207\n+            final Map<String, Class<? extends Op>> opMapping = createOpMapping(c);\n+\n+            return def -> {\n+                var opClass = opMapping.get(def.name());\n+                if (opClass == null) {\n+                    return null;\n+                }\n+\n+                Op op = constructOp(opClass, def);\n+                \/\/ Set location if available\n+                if (op != null && def.location() != null) {\n+                    op.setLocation(def.location());\n+                }\n+                return op;\n+            };\n+        }\n+    };\n+\n+    private static Map<String, Class<? extends Op>> createOpMapping(Class<?> opClasses) {\n+        Map<String, Class<? extends Op>> mapping = new HashMap<>();\n+        for (Class<?> opClass : opClasses.getNestMembers()) {\n+            if (opClass.isAnnotationPresent(OpFactory.OpDeclaration.class)) {\n+                if (!Modifier.isPublic(opClass.getModifiers())) {\n+                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(opClass)) {\n+                    throw new InternalError(\"Operation class is not assignable to Op: \" + opClass);\n+                }\n+\n+                MethodHandle handle = getOpConstructorMethodHandle(opClass);\n+                if (handle == null) {\n+                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(handle.type().returnType())) {\n+                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n+                }\n+\n+                String opName = opClass.getAnnotation(OpFactory.OpDeclaration.class).value();\n+                @SuppressWarnings(\"unchecked\")\n+                var opClassCast = (Class<Op>) opClass;\n+                mapping.put(opName, opClassCast);\n+            }\n+        }\n+        return mapping;\n+    }\n+\n+    private static MethodHandle getOpConstructorMethodHandle(Class<?> opClass) {\n+        Method method = null;\n+        try {\n+            method = opClass.getMethod(\"create\", ExternalizedOp.class);\n+        } catch (NoSuchMethodException e) {\n+        }\n+\n+        if (method != null) {\n+            if (!Modifier.isStatic(method.getModifiers())) {\n+                throw new InternalError(\"Operation constructor is not a static method: \" + method);\n+            }\n+\n+            try {\n+                return MethodHandles.publicLookup().unreflect(method);\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                        method);\n+            }\n+        }\n+\n+        Constructor<?> constructor;\n+        try {\n+            constructor = opClass.getConstructor(ExternalizedOp.class);\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+\n+        try {\n+            return MethodHandles.publicLookup().unreflectConstructor(constructor);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                    constructor);\n+        }\n+    }\n+\n+    private static Op constructOp(Class<? extends Op> opClass, ExternalizedOp opDef) {\n+        class Enclosed {\n+            private static final ClassValue<Function<ExternalizedOp, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n+                @Override\n+                protected Function<ExternalizedOp, Op> computeValue(Class<?> opClass) {\n+                    final MethodHandle opConstructorMH = getOpConstructorMethodHandle(opClass);\n+                    assert opConstructorMH != null;\n+\n+                    return operationDefinition -> {\n+                        try {\n+                            return (Op) opConstructorMH.invoke(operationDefinition);\n+                        } catch (RuntimeException | Error e) {\n+                            throw e;\n+                        } catch (Throwable t) {\n+                            throw new RuntimeException(t);\n+                        }\n+                    };\n+                }\n+            };\n+        }\n+        return Enclosed.OP_CONSTRUCTOR.get(opClass).apply(opDef);\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/proto\/OpFactoryHelper.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+package oracle.code.triton;\n+\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.extern.ExternalizedOp;\n+import jdk.incubator.code.extern.OpFactory;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public final class OpFactoryHelper {\n+\n+    \/**\n+     * A class value for lazily computing an operation factory for {@link Op operation} classes\n+     * annotated with {@link OpFactory.OpDeclaration} and enclosed within a given class to compute over.\n+     * <p>\n+     * Each enclosed class annotated with {@code OpDeclaration} must declare a public static method named {@code create}\n+     * with one parameter type of {@link ExternalizedOp} and return type that is the concrete class type.\n+     * Alternatively, the concrete class must declare public constructor with one parameter type of\n+     * {@link ExternalizedOp}.\n+     *\/\n+    static final ClassValue<OpFactory> OP_FACTORY = new ClassValue<>() {\n+        @Override\n+        protected OpFactory computeValue(Class<?> c) {\n+            \/\/ @@@ See https:\/\/bugs.openjdk.org\/browse\/JDK-8321207\n+            final Map<String, Class<? extends Op>> opMapping = createOpMapping(c);\n+\n+            return def -> {\n+                var opClass = opMapping.get(def.name());\n+                if (opClass == null) {\n+                    return null;\n+                }\n+\n+                Op op = constructOp(opClass, def);\n+                \/\/ Set location if available\n+                if (op != null && def.location() != null) {\n+                    op.setLocation(def.location());\n+                }\n+                return op;\n+            };\n+        }\n+    };\n+\n+    private static Map<String, Class<? extends Op>> createOpMapping(Class<?> opClasses) {\n+        Map<String, Class<? extends Op>> mapping = new HashMap<>();\n+        for (Class<?> opClass : opClasses.getNestMembers()) {\n+            if (opClass.isAnnotationPresent(OpFactory.OpDeclaration.class)) {\n+                if (!Modifier.isPublic(opClass.getModifiers())) {\n+                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(opClass)) {\n+                    throw new InternalError(\"Operation class is not assignable to Op: \" + opClass);\n+                }\n+\n+                MethodHandle handle = getOpConstructorMethodHandle(opClass);\n+                if (handle == null) {\n+                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(handle.type().returnType())) {\n+                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n+                }\n+\n+                String opName = opClass.getAnnotation(OpFactory.OpDeclaration.class).value();\n+                @SuppressWarnings(\"unchecked\")\n+                var opClassCast = (Class<Op>) opClass;\n+                mapping.put(opName, opClassCast);\n+            }\n+        }\n+        return mapping;\n+    }\n+\n+    private static MethodHandle getOpConstructorMethodHandle(Class<?> opClass) {\n+        Method method = null;\n+        try {\n+            method = opClass.getMethod(\"create\", ExternalizedOp.class);\n+        } catch (NoSuchMethodException e) {\n+        }\n+\n+        if (method != null) {\n+            if (!Modifier.isStatic(method.getModifiers())) {\n+                throw new InternalError(\"Operation constructor is not a static method: \" + method);\n+            }\n+\n+            try {\n+                return MethodHandles.publicLookup().unreflect(method);\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                        method);\n+            }\n+        }\n+\n+        Constructor<?> constructor;\n+        try {\n+            constructor = opClass.getConstructor(ExternalizedOp.class);\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+\n+        try {\n+            return MethodHandles.publicLookup().unreflectConstructor(constructor);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                    constructor);\n+        }\n+    }\n+\n+    private static Op constructOp(Class<? extends Op> opClass, ExternalizedOp opDef) {\n+        class Enclosed {\n+            private static final ClassValue<Function<ExternalizedOp, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n+                @Override\n+                protected Function<ExternalizedOp, Op> computeValue(Class<?> opClass) {\n+                    final MethodHandle opConstructorMH = getOpConstructorMethodHandle(opClass);\n+                    assert opConstructorMH != null;\n+\n+                    return operationDefinition -> {\n+                        try {\n+                            return (Op) opConstructorMH.invoke(operationDefinition);\n+                        } catch (RuntimeException | Error e) {\n+                            throw e;\n+                        } catch (Throwable t) {\n+                            throw new RuntimeException(t);\n+                        }\n+                    };\n+                }\n+            };\n+        }\n+        return Enclosed.OP_CONSTRUCTOR.get(opClass).apply(opDef);\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/OpFactoryHelper.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -165,1 +165,1 @@\n-    public static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(SCFOps.class);\n+    public static final OpFactory OP_FACTORY = OpFactoryHelper.OP_FACTORY.get(SCFOps.class);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-    static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n+    static final OpFactory OP_FACTORY = OpFactoryHelper.OP_FACTORY.get(TritonOps.class);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonTestOps.class);\n+    public static final OpFactory FACTORY = OpFactoryHelper.OP_FACTORY.get(TritonTestOps.class);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -38,3 +33,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Function;\n@@ -66,31 +58,0 @@\n-    \/**\n-     * A class value for lazily computing an operation factory for {@link Op operation} classes\n-     * annotated with {@link OpDeclaration} and enclosed within a given class to compute over.\n-     * <p>\n-     * Each enclosed class annotated with {@code OpDeclaration} must declare a public static method named {@code create}\n-     * with one parameter type of {@link ExternalizedOp} and return type that is the concrete class type.\n-     * Alternatively, the concrete class must declare public constructor with one parameter type of\n-     * {@link ExternalizedOp}.\n-     *\/\n-    ClassValue<OpFactory> OP_FACTORY = new ClassValue<>() {\n-        @Override\n-        protected OpFactory computeValue(Class<?> c) {\n-            \/\/ @@@ See https:\/\/bugs.openjdk.org\/browse\/JDK-8321207\n-            final Map<String, Class<? extends Op>> opMapping = createOpMapping(c);\n-\n-            return def -> {\n-                var opClass = opMapping.get(def.name());\n-                if (opClass == null) {\n-                    return null;\n-                }\n-\n-                Op op = constructOp(opClass, def);\n-                \/\/ Set location if available\n-                if (op != null && def.location() != null) {\n-                    op.setLocation(def.location());\n-                }\n-                return op;\n-            };\n-        }\n-    };\n-\n@@ -115,1 +76,1 @@\n-     * @return the operation, otherwise null\n+     * @return the operation\n@@ -129,1 +90,1 @@\n-     * Compose this operation factory with another operation factory.\n+     * Composes this operation factory with another operation factory.\n@@ -144,88 +105,0 @@\n-    private static Map<String, Class<? extends Op>> createOpMapping(Class<?> opClasses) {\n-        Map<String, Class<? extends Op>> mapping = new HashMap<>();\n-        for (Class<?> opClass : opClasses.getNestMembers()) {\n-            if (opClass.isAnnotationPresent(OpDeclaration.class)) {\n-                if (!Modifier.isPublic(opClass.getModifiers())) {\n-                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n-                }\n-\n-                if (!Op.class.isAssignableFrom(opClass)) {\n-                    throw new InternalError(\"Operation class is not assignable to Op: \" + opClass);\n-                }\n-\n-                MethodHandle handle = getOpConstructorMethodHandle(opClass);\n-                if (handle == null) {\n-                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n-                }\n-\n-                if (!Op.class.isAssignableFrom(handle.type().returnType())) {\n-                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n-                }\n-\n-                String opName = opClass.getAnnotation(OpDeclaration.class).value();\n-                @SuppressWarnings(\"unchecked\")\n-                var opClassCast = (Class<Op>) opClass;\n-                mapping.put(opName, opClassCast);\n-            }\n-        }\n-        return mapping;\n-    }\n-\n-    private static MethodHandle getOpConstructorMethodHandle(Class<?> opClass) {\n-        Method method = null;\n-        try {\n-            method = opClass.getMethod(\"create\", ExternalizedOp.class);\n-        } catch (NoSuchMethodException e) {\n-        }\n-\n-        if (method != null) {\n-            if (!Modifier.isStatic(method.getModifiers())) {\n-                throw new InternalError(\"Operation constructor is not a static method: \" + method);\n-            }\n-\n-            try {\n-                return MethodHandles.publicLookup().unreflect(method);\n-            } catch (IllegalAccessException e) {\n-                throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n-                        method);\n-            }\n-        }\n-\n-        Constructor<?> constructor;\n-        try {\n-            constructor = opClass.getConstructor(ExternalizedOp.class);\n-        } catch (NoSuchMethodException e) {\n-            return null;\n-        }\n-\n-        try {\n-            return MethodHandles.publicLookup().unreflectConstructor(constructor);\n-        } catch (IllegalAccessException e) {\n-            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n-                    constructor);\n-        }\n-    }\n-\n-    private static Op constructOp(Class<? extends Op> opClass, ExternalizedOp opDef) {\n-        class Enclosed {\n-            private static final ClassValue<Function<ExternalizedOp, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n-                @Override\n-                protected Function<ExternalizedOp, Op> computeValue(Class<?> opClass) {\n-                    final MethodHandle opConstructorMH = getOpConstructorMethodHandle(opClass);\n-                    assert opConstructorMH != null;\n-\n-                    return operationDefinition -> {\n-                        try {\n-                            return (Op) opConstructorMH.invoke(operationDefinition);\n-                        } catch (RuntimeException | Error e) {\n-                            throw e;\n-                        } catch (Throwable t) {\n-                            throw new RuntimeException(t);\n-                        }\n-                    };\n-                }\n-            };\n-        }\n-        return Enclosed.OP_CONSTRUCTOR.get(opClass).apply(opDef);\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpFactory.java","additions":2,"deletions":129,"binary":false,"changes":131,"status":"modified"}]}