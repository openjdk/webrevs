{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,5 @@\n+    @Override\n+    public void checkAllowedToUnreflectFinalSetter(Class<?> caller, Field f) throws IllegalAccessException {\n+        f.checkAllowedToUnreflectFinalSetter(caller);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,6 @@\n+    \/**\n+     * Check that the caller is allowed to unreflect for mutation a final instance field\n+     * in a class that is not a record or hidden class.\n+     *\/\n+    void checkAllowedToUnreflectFinalSetter(Class<?> caller, Field f) throws IllegalAccessException;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-        java.net.http,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+        CAPTURE_MREF_RETURN_TYPE(JDK26),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -1425,1 +1426,1 @@\n-        TypeRelation isSameTypeVisitor = new TypeRelation() {\n+        abstract class TypeEqualityVisitor extends TypeRelation {\n@@ -1464,1 +1465,1 @@\n-                            isSameType(t.type, t2.type);\n+                            sameTypeComparator(t.type, t2.type);\n@@ -1468,0 +1469,2 @@\n+            abstract boolean sameTypeComparator(Type t, Type s);\n+\n@@ -1498,1 +1501,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                    && sameTypeArguments(t.getTypeArguments(), s.getTypeArguments());\n@@ -1501,0 +1504,2 @@\n+            abstract boolean sameTypeArguments(List<Type> ts, List<Type> ss);\n+\n@@ -1556,0 +1561,10 @@\n+        }\n+\n+        TypeEqualityVisitor isSameTypeVisitor = new TypeEqualityVisitor() {\n+            boolean sameTypeComparator(Type t, Type s) {\n+                return isSameType(t, s);\n+            }\n+\n+            boolean sameTypeArguments(List<Type> ts, List<Type> ss) {\n+                return containsTypeEquivalent(ts, ss);\n+            }\n@@ -3941,1 +3956,1 @@\n-            final Type t2;;\n+            final Type t2;\n@@ -3954,2 +3969,2 @@\n-                        && isSameType(t1, typePair.t1)\n-                        && isSameType(t2, typePair.t2);\n+                        && exactTypeVisitor.visit(t1, typePair.t1)\n+                        && exactTypeVisitor.visit(t2, typePair.t2);\n@@ -3958,0 +3973,18 @@\n+\n+        TypeEqualityVisitor exactTypeVisitor = new TypeEqualityVisitor() {\n+            @Override\n+            boolean sameTypeArguments(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()\n+                        && sameTypeComparator(ts.head, ss.head)) {\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n+            }\n+\n+            @Override\n+            boolean sameTypeComparator(Type t, Type s) {\n+                return exactTypeVisitor.visit(t, s);\n+            }\n+        };\n+\n@@ -4018,1 +4051,1 @@\n-    private List<Type> closureMin(List<Type> cl) {\n+    public List<Type> closureMin(List<Type> cl) {\n@@ -4169,9 +4202,8 @@\n-    \/\/ where\n-        List<Type> erasedSupertypes(Type t) {\n-            ListBuffer<Type> buf = new ListBuffer<>();\n-            for (Type sup : closure(t)) {\n-                if (sup.hasTag(TYPEVAR)) {\n-                    buf.append(sup);\n-                } else {\n-                    buf.append(erasure(sup));\n-                }\n+\n+    public List<Type> erasedSupertypes(Type t) {\n+        ListBuffer<Type> buf = new ListBuffer<>();\n+        for (Type sup : closure(t)) {\n+            if (sup.hasTag(TYPEVAR)) {\n+                buf.append(sup);\n+            } else {\n+                buf.append(erasure(sup));\n@@ -4179,1 +4211,2 @@\n-            return buf.toList();\n+        return buf.toList();\n+    }\n@@ -4182,0 +4215,1 @@\n+    \/\/ where\n@@ -5132,2 +5166,3 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n-    \/** Check unconditionality between any combination of reference or primitive types.\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditional Exactness\">\n+    \/** Check type-based unconditional exactness between any combination of\n+     *  reference or primitive types according to JLS 5.7.2.\n@@ -5135,6 +5170,8 @@\n-     *  Rules:\n-     *    an identity conversion\n-     *    a widening reference conversion\n-     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n-     *    a boxing conversion\n-     *    a boxing conversion followed by a widening reference conversion\n+     *  The following are unconditionally exact regardless of the input\n+     *  expression:\n+     *\n+     *    - an identity conversion\n+     *    - a widening reference conversion\n+     *    - an exact widening primitive conversion\n+     *    - a boxing conversion\n+     *    - a boxing conversion followed by a widening reference conversion\n@@ -5145,1 +5182,1 @@\n-    public boolean isUnconditionallyExact(Type source, Type target) {\n+    public boolean isUnconditionallyExactTypeBased(Type source, Type target) {\n@@ -5150,3 +5187,12 @@\n-        return target.isPrimitive()\n-                ? isUnconditionallyExactPrimitives(source, target)\n-                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+        if (target.isPrimitive()) {\n+            if (source.isPrimitive() &&\n+                ((source.getTag().isStrictSubRangeOf(target.getTag())) &&\n+                        !((source.hasTag(BYTE) && target.hasTag(CHAR)) ||\n+                          (source.hasTag(INT) && target.hasTag(FLOAT)) ||\n+                          (source.hasTag(LONG) && (target.hasTag(DOUBLE) || target.hasTag(FLOAT)))))) return true;\n+            else {\n+                return false;\n+            }\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n@@ -5155,1 +5201,7 @@\n-    \/** Check unconditionality between primitive types.\n+    \/** Check value-based unconditional exactness between any combination of\n+     *  reference or primitive types for the value of a constant expression\n+     *   according to JLS 5.7.2.\n+     *\n+     *  The following can be unconditionally exact if the source primitive is a\n+     *  constant expression and the conversions is exact for that constant\n+     *  expression:\n@@ -5157,4 +5209,3 @@\n-     *  - widening from one integral type to another,\n-     *  - widening from one floating point type to another,\n-     *  - widening from byte, short, or char to a floating point type,\n-     *  - widening from int to double.\n+     *    - a narrowing primitive conversion\n+     *    - a widening and narrowing primitive conversion\n+     *    - a widening primitive conversion that is not exact\n@@ -5162,2 +5213,71 @@\n-     *  @param selectorType     Type of selector\n-     *  @param targetType       Target type\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExactValueBased(Type source, Type target) {\n+        if (!(source.constValue() instanceof Number value) || !target.getTag().isNumeric()) return false;\n+\n+        switch (source.getTag()) {\n+            case BYTE:\n+                switch (target.getTag()) {\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case CHAR:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                }\n+                break;\n+            case SHORT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case INT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                    case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+                }\n+                break;\n+            case FLOAT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+                    case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+                    case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+                    case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+                    case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+                }\n+                break;\n+            case LONG:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+                    case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+                    case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+                    case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+                    case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+                    case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+                }\n+                break;\n+            case DOUBLE:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+                    case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+                    case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+                    case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+                    case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+                    case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+                }\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    \/** Check both type or value-based unconditional exactness between any\n+     *  combination of reference or primitive types for the value of a constant\n+     *  expression according to JLS 5.7.2.\n+     *\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n@@ -5165,7 +5285,3 @@\n-    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n-        return isSameType(selectorType, targetType) ||\n-                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n-                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n-                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n-                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n+    public boolean isUnconditionallyExactCombined(Type currentType, Type testType) {\n+        return isUnconditionallyExactTypeBased(currentType, testType) ||\n+                (currentType.constValue() instanceof Number && isUnconditionallyExactValueBased(currentType, testType));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":159,"deletions":43,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+    final boolean captureMRefReturnType;\n@@ -179,0 +180,1 @@\n+        captureMRefReturnType = Source.Feature.CAPTURE_MREF_RETURN_TYPE.allowedInSource(source);\n@@ -379,1 +381,1 @@\n-                if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)\n+                if (site == null || site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)\n@@ -1878,1 +1880,1 @@\n-                                types.isUnconditionallyExact(seltype, patternType);\n+                                types.isUnconditionallyExactTypeBased(seltype, patternType);\n@@ -2001,1 +2003,1 @@\n-                        checkAutoCloseable(resource.pos(), localEnv, resource.type);\n+                        checkAutoCloseable(localEnv, resource, true);\n@@ -2050,1 +2052,3 @@\n-    void checkAutoCloseable(DiagnosticPosition pos, Env<AttrContext> env, Type resource) {\n+    void checkAutoCloseable(Env<AttrContext> env, JCTree tree, boolean useSite) {\n+        DiagnosticPosition pos = tree.pos();\n+        Type resource = tree.type;\n@@ -2068,1 +2072,2 @@\n-                    close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &&\n+                    (useSite || close.owner != syms.autoCloseableType.tsym) &&\n+                    ((MethodSymbol)close).binaryOverrides(syms.autoCloseableClose, resource.tsym, types) &&\n@@ -2070,1 +2075,6 @@\n-                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                if (!useSite && close.owner == resource.tsym) {\n+                    log.warning(TreeInfo.diagnosticPositionFor(close, tree),\n+                        LintWarnings.TryResourceCanThrowInterruptedExc(resource));\n+                } else {\n+                    log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                }\n@@ -3843,0 +3853,1 @@\n+            Type capturedResType = captureMRefReturnType ? types.capture(resType) : resType;\n@@ -3844,2 +3855,2 @@\n-                    new FunctionalReturnContext(checkContext).compatible(resType, returnType,\n-                            checkContext.checkWarner(tree, resType, returnType))) {\n+                    new FunctionalReturnContext(checkContext).compatible(capturedResType, returnType,\n+                            checkContext.checkWarner(tree, capturedResType, returnType))) {\n@@ -4009,0 +4020,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, operand);\n@@ -4099,0 +4111,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, right);\n@@ -5668,1 +5681,1 @@\n-        checkAutoCloseable(tree.pos(), env, c.type);\n+        checkAutoCloseable(env, tree, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -2838,1 +2837,1 @@\n-            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+            if (types.isUnconditionallyExactTypeBased(tree.expr.type, tree.pattern.type)) {\n@@ -2847,1 +2846,1 @@\n-                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                if (types.isUnconditionallyExactTypeBased(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2261,0 +2261,6 @@\n+# 0: symbol, 1: file object\n+# lint: classfile\n+compiler.warn.inconsistent.inner.classes=\\\n+    InnerClasses attribute for {0} in {1} inconsistent with source code\\n\\\n+    ({1} may need to be recompiled with {0})\n+\n@@ -2371,0 +2377,5 @@\n+# 0: type\n+# lint: try\n+compiler.warn.try.resource.can.throw.interrupted.exc=\\\n+    close() method can throw InterruptedException in auto-closeable class {0}\n+\n@@ -2456,0 +2467,5 @@\n+# 0: type, 1: long, 2: number\n+# lint: lossy-conversions\n+compiler.warn.bit.shift.out.of.range=\\\n+    shifting {0} by {1} bits is equivalent to shifting by {2} bit(s)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -453,0 +453,13 @@\n+        return isTypeSelector(base, names, TreeInfo::isStaticSym);\n+    }\n+    \/\/where\n+        private static boolean isStaticSym(JCTree tree) {\n+            Symbol sym = symbol(tree);\n+            return (sym.kind == TYP || sym.kind == PCK);\n+        }\n+\n+    public static boolean isType(JCTree base, Names names) {\n+        return isTypeSelector(base, names, _ -> true);\n+    }\n+\n+    private static boolean isTypeSelector(JCTree base, Names names, Predicate<JCTree> checkStaticSym) {\n@@ -460,1 +473,1 @@\n-                        isStaticSym(base);\n+                        checkStaticSym.test(base);\n@@ -462,1 +475,1 @@\n-                return isStaticSym(base) &&\n+                return checkStaticSym.test(base) &&\n@@ -473,5 +486,0 @@\n-    \/\/where\n-        private static boolean isStaticSym(JCTree tree) {\n-            Symbol sym = symbol(tree);\n-            return (sym.kind == TYP || sym.kind == PCK);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,2 @@\n- * <tr><th scope=\"row\">{@code lossy-conversions}    <td>possible lossy conversions in compound assignment\n+ * <tr><th scope=\"row\">{@code lossy-conversions}    <td>possible lossy conversions in compound assignments or bit shifts\n+ *                                                      (more than \\u00B131 bits for integers or \\u00B163 bits for longs)\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}