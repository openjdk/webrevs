{"files":[{"patch":"@@ -31,0 +31,3 @@\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n@@ -86,0 +89,5 @@\n+\n+    @Override\n+    public Optional<?> setCodeModelIfNeeded(Method method, Function<Method, Optional<?>> modelFactory) {\n+        return method.setCodeModelIfNeeded(modelFactory);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n@@ -76,0 +79,3 @@\n+\n+    \/** Cache code model on the reflective method instance (if none is set already). *\/\n+    Optional<?> setCodeModelIfNeeded(Method method, Function<Method, Optional<?>> modelFactory);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,1 +157,2 @@\n-        jdk.compiler;\n+        jdk.compiler,\n+        jdk.incubator.code;\n@@ -170,1 +171,4 @@\n-        jdk.crypto.cryptoki;\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.code;\n+    exports jdk.internal.access.code to\n+        jdk.compiler;\n@@ -307,1 +311,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.code;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,0 +205,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -211,0 +221,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -214,0 +266,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -252,5 +306,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -311,0 +372,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -314,0 +376,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -328,1 +391,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -337,1 +400,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -355,1 +418,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -359,1 +422,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -369,1 +432,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -392,2 +455,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -421,1 +484,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":89,"deletions":13,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -449,0 +450,15 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            annotate.queueScanTreeAndTypeAnnotate(tree.body, env, tree.sym);\n+            annotate.flush();\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-    class FreeVarCollector extends CaptureScanner {\n+    public class FreeVarCollector extends CaptureScanner {\n@@ -276,1 +276,1 @@\n-        FreeVarCollector(JCTree ownerTree) {\n+        protected FreeVarCollector(JCTree ownerTree) {\n@@ -280,1 +280,1 @@\n-        void addFreeVars(ClassSymbol c) {\n+        protected void addFreeVars(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4318,0 +4318,29 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+# 0: symbol\n+compiler.err.quoted.method.inner.class=\\\n+    unsupported quoted method in inner class {0}\n+\n+# 0: symbol\n+compiler.err.quoted.lambda.inner.class=\\\n+    unsupported quoted lambda in inner class {0}\n+\n+# 0: symbol\n+compiler.err.quoted.mref.inner.class=\\\n+    unsupported quoted method reference in inner class {0}\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardLocation;\n+import com.sun.tools.javac.comp.CodeReflectionTransformer;\n@@ -258,1 +257,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -260,1 +260,1 @@\n-        jdk.jshell;\n+        jdk.jshell, jdk.incubator.code;\n@@ -263,1 +263,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -266,1 +267,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -271,1 +273,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -274,1 +277,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -276,1 +280,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -286,1 +291,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -291,1 +297,4 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n+    exports com.sun.tools.javac.processing to\n+        jdk.incubator.code;\n@@ -298,0 +307,1 @@\n+    uses CodeReflectionTransformer;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"}]}