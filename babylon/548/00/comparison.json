{"files":[{"patch":"@@ -415,8 +415,1 @@\n-        if (CallGraph.usingModuleOp) {\n-            System.out.println(\"Using ModuleOp for CudaBackend\");\n-            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n-                CoreOp.FuncOp loweredFunc = OpTk.lower(funcOp);\n-                loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n-                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n-            });\n-        } else {\n+        if (CallGraph.noModuleOp) {\n@@ -430,0 +423,7 @@\n+        } else {\n+            System.out.println(\"Using ModuleOp for CudaBackend\");\n+            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n+                CoreOp.FuncOp loweredFunc = OpTk.lower(funcOp);\n+                loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n+                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            });\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,5 +59,1 @@\n-        if (CallGraph.usingModuleOp) {\n-            System.out.println(\"Using ModuleOp for MockBackend\");\n-            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n-            });\n-        } else {\n+        if (CallGraph.noModuleOp) {\n@@ -67,0 +63,4 @@\n+            });\n+        } else {\n+            System.out.println(\"Using ModuleOp for MockBackend\");\n+            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -232,5 +232,1 @@\n-        if (CallGraph.usingModuleOp) {\n-            System.out.println(\"Using ModuleOp for C99FFIBackend\");\n-            kernelCallGraph.moduleOp.functionTable()\n-                    .forEach((_, funcOp) -> builder.nl().kernelMethod(kernelCallGraph.computeContext.accelerator.lookup, funcOp).nl());\n-        } else {\n+        if (CallGraph.noModuleOp) {\n@@ -240,0 +236,4 @@\n+        } else {\n+            System.out.println(\"Using ModuleOp for C99FFIBackend\");\n+            kernelCallGraph.moduleOp.functionTable()\n+                    .forEach((_, funcOp) -> builder.nl().kernelMethod(kernelCallGraph.computeContext.accelerator.lookup, funcOp).nl());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+package hat;\n+\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.MappableIface;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.Inliner;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class BufferTagger {\n+    static HashMap<Value, AccessType> accessMap = new HashMap<>();\n+    static HashMap<Value, Value> remappedVals = new HashMap<>(); \/\/ maps values to their \"root\" parameter\/value\n+    static HashMap<Block, List<Block.Parameter>> blockParams = new HashMap<>(); \/\/ holds block parameters for easy lookup\n+\n+    public enum AccessType {\n+        NA(1),\n+        RO(2),\n+        WO(4),\n+        RW(6),\n+        NOT_BUFFER(0);\n+\n+        public final int value;\n+        AccessType(int i) {\n+            value = i;\n+        }\n+    }\n+\n+    \/\/ generates a list of AccessTypes matching the given FuncOp's parameter order\n+    public static ArrayList<AccessType> getAccessList(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n+        CoreOp.FuncOp inlinedFunc = inlineLoop(l, f);\n+        buildAccessMap(l, inlinedFunc);\n+        ArrayList<AccessType> accessList = new ArrayList<>();\n+        for (Block.Parameter p : inlinedFunc.body().entryBlock().parameters()) {\n+            if (accessMap.containsKey(p)) {\n+                accessList.add(accessMap.get(p)); \/\/ is an accessed buffer\n+            } else if (getClass(l, p.type()) instanceof Class<?> c && MappableIface.class.isAssignableFrom(c)) {\n+                accessList.add(AccessType.NA); \/\/ is a buffer but not accessed\n+            } else {\n+                accessList.add(AccessType.NOT_BUFFER); \/\/ is not a buffer\n+            }\n+        }\n+        return accessList;\n+    }\n+\n+    \/\/ inlines functions found in FuncOp f until no more inline-able functions are present\n+    public static CoreOp.FuncOp inlineLoop(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n+        CoreOp.FuncOp ssaFunc = SSA.transform(f.transform(OpTransformer.LOWERING_TRANSFORMER));\n+        AtomicBoolean changed = new AtomicBoolean(true);\n+        while (changed.get()) { \/\/ loop until no more inline-able functions\n+            changed.set(false);\n+            ssaFunc = ssaFunc.transform((bb, op) -> {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n+                    MethodRef methodRef = iop.invokeDescriptor();\n+                    Method invokeOpCalledMethod;\n+                    try {\n+                        invokeOpCalledMethod = methodRef.resolveToMethod(l, iop.invokeKind());\n+                    } catch (ReflectiveOperationException _) {\n+                        throw new IllegalStateException(\"Could not resolve invokeOp to method\");\n+                    }\n+                    if (invokeOpCalledMethod instanceof Method method) { \/\/ if method isn't a buffer access (is code reflected)\n+                        if (Op.ofMethod(method).isPresent()) {\n+                            CoreOp.FuncOp inline = Op.ofMethod(method).get(); \/\/ method to be inlined\n+                            CoreOp.FuncOp ssaInline = SSA.transform(inline.transform(OpTransformer.LOWERING_TRANSFORMER));\n+\n+                            Block.Builder exit = Inliner.inline(bb, ssaInline, bb.context().getValues(iop.operands()), (_, v) -> {\n+                                if (v != null) bb.context().mapValue(iop.result(), v);\n+                            });\n+\n+                            if (!exit.parameters().isEmpty()) {\n+                                bb.context().mapValue(iop.result(), exit.parameters().getFirst());\n+                            }\n+                            changed.set(true);\n+                            return exit.rebind(bb.context(), bb.transformer()); \/\/ return exit in same context as block\n+                        }\n+                    }\n+                }\n+                bb.op(op);\n+                return bb;\n+            });\n+        }\n+        return ssaFunc;\n+    }\n+\n+    \/\/ creates the access map\n+    public static void buildAccessMap(MethodHandles.Lookup l, CoreOp.FuncOp f) {\n+        \/\/ build blockParams so that we can map params to \"root\" params later\n+        for (Body b : f.bodies()) {\n+            for (Block block : b.blocks()) {\n+                if (!block.parameters().isEmpty()) {\n+                    blockParams.put(block, block.parameters());\n+                }\n+            }\n+        }\n+\n+        f.traverse(null, (map, op) -> {\n+            if (op instanceof CoreOp.BranchOp b) {\n+                mapBranch(l, b.branch());\n+            } else if (op instanceof  CoreOp.ConditionalBranchOp cb) {\n+                mapBranch(l, cb.trueBranch()); \/\/ handle true branch\n+                mapBranch(l, cb.falseBranch()); \/\/ handle false branch\n+            } else if (op instanceof JavaOp.InvokeOp iop) { \/\/ (almost) all the buffer accesses happen here\n+                if (isAssignable(l, iop.invokeDescriptor().refType(), MappableIface.class)) {\n+                    updateAccessType(getRootValue(iop), getAccessType(iop)); \/\/ update buffer access\n+                    if (isAssignable(l, iop.invokeDescriptor().refType(), Buffer.class)\n+                            && iop.result() != null && !(iop.resultType() instanceof PrimitiveType)\n+                            && isAssignable(l, iop.resultType(), MappableIface.class)) {\n+                        \/\/ if we access a struct\/union from a buffer, we map the struct\/union to the buffer root\n+                        remappedVals.put(iop.result(), getRootValue(iop));\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp vop) { \/\/ map the new VarOp to the \"root\" param\n+                if (isAssignable(l, vop.resultType().valueType(), Buffer.class)) {\n+                    remappedVals.put(vop.initOperand(), getRootValue(vop));\n+                }\n+            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp flop) {\n+                if (isAssignable(l, flop.fieldDescriptor().refType(), KernelContext.class)) {\n+                    updateAccessType(getRootValue(flop), AccessType.RO); \/\/ handle kc access\n+                }\n+            }\n+            return map;\n+        });\n+    }\n+\n+    \/\/ maps the parameters of a block to the values passed to a branch\n+    public static void mapBranch(MethodHandles.Lookup l, Block.Reference b) {\n+        List<Value> args = b.arguments();\n+        for (int i = 0; i < args.size(); i++) {\n+            Value key = blockParams.get(b.targetBlock()).get(i);\n+            Value val = args.get(i);\n+\n+            if (val instanceof Op.Result) {\n+                \/\/ either find root param or it doesnt exist (is a constant for example)\n+                if (isAssignable(l, val.type(), MappableIface.class)) {\n+                    val = getRootValue(((Op.Result) val).op());\n+                    if (val instanceof Block.Parameter) {\n+                        val = remappedVals.getOrDefault(val, val);\n+                    }\n+                }\n+            }\n+            remappedVals.put(key, val);\n+        }\n+    }\n+\n+    \/\/ checks if a TypeElement is assignable to a certain class\n+    public static boolean isAssignable(MethodHandles.Lookup l, TypeElement type, Class<?> clazz) {\n+        Class<?> fopClass = getClass(l, type);\n+        return (fopClass != null && (clazz.isAssignableFrom(fopClass)));\n+    }\n+\n+    \/\/ retrieves the class of a TypeElement\n+    public static Class<?> getClass(MethodHandles.Lookup l, TypeElement type) {\n+        if (type instanceof ClassType classType) {\n+            try {\n+                return (Class<?>) classType.resolve(l);\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ retrieves \"root\" value of an op, the origin of the parameter (or value) used by the op\n+    public static Value getRootValue(Op op) {\n+        if (op.operands().isEmpty()) {\n+            return op.result();\n+        }\n+        if (op.operands().getFirst() instanceof Block.Parameter param) {\n+            return param;\n+        }\n+        Value val = op.operands().getFirst();\n+        while (!(val instanceof Block.Parameter)) {\n+            \/\/ or if the \"root VarOp\" is an invoke (not sure how to tell)\n+            \/\/ if (tempOp instanceof JavaOp.InvokeOp iop\n+            \/\/        && ((TypeElement) iop.resultType()) instanceof ClassType classType\n+            \/\/        && !hasOperandType(iop, classType)) return ((CoreOp.VarOp) op);\n+            val = ((Op.Result) val).op().operands().getFirst();\n+        }\n+        return val;\n+    }\n+\n+    \/\/ retrieves accessType based on return value of InvokeOp\n+    public static AccessType getAccessType(JavaOp.InvokeOp iop) {\n+        return iop.invokeDescriptor().type().returnType().equals(JavaType.VOID) ? AccessType.WO : AccessType.RO;\n+    }\n+\n+    \/\/ updates accessMap\n+    public static void updateAccessType(Value val, AccessType curAccess) {\n+        Value remappedVal = remappedVals.getOrDefault(val, val);\n+        AccessType storedAccess = accessMap.get(remappedVal);\n+        if (storedAccess == null) {\n+            accessMap.put(remappedVal, curAccess);\n+        } else if (curAccess != storedAccess && storedAccess != AccessType.RW) {\n+            accessMap.put(remappedVal, AccessType.RW);\n+        }\n+    }\n+\n+    public static void printAccessMap() {\n+        System.out.println(\"access map output:\");\n+        for (Value val : accessMap.keySet()) {\n+            if (val instanceof Block.Parameter param) {\n+                System.out.println(\"\\t\" + ((CoreOp.FuncOp) param.declaringBlock().parent().parent()).funcName()\n+                        + \" param w\/ idx \" + param.index() + \": \" + accessMap.get(val));\n+            } else {\n+                System.out.println(\"\\t\" + val.toString() + \": \" + accessMap.get(val));\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.BufferTagger;\n@@ -37,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -292,0 +294,2 @@\n+        ArrayList<BufferTagger.AccessType> bufferAccessList = kernelCallGraph.bufferAccessList;\n+\n@@ -327,0 +331,2 @@\n+\n+                    assert bufferAccessList.get(i).value == accessByte;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    public static boolean usingModuleOp = Boolean.getBoolean(\"moduleOp\");\n+    public static boolean noModuleOp = Boolean.getBoolean(\"noModuleOp\");\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,3 +219,1 @@\n-        if (CallGraph.usingModuleOp) {\n-            closeWithModuleOp(entrypoint);\n-        } else {\n+        if (CallGraph.noModuleOp) {\n@@ -223,0 +221,2 @@\n+        } else {\n+            closeWithModuleOp(entrypoint);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.BufferTagger;\n@@ -41,0 +42,1 @@\n+    public final ArrayList<BufferTagger.AccessType> bufferAccessList;\n@@ -80,0 +82,1 @@\n+        bufferAccessList = BufferTagger.getAccessList(computeContext.accelerator.lookup, entrypoint.funcOp());\n@@ -150,1 +153,0 @@\n-       \/\/ moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1287,1 +1287,1 @@\n-        public boolean moduleOp;\n+        public boolean noModuleOp;\n@@ -1347,2 +1347,2 @@\n-        public void moduleOp() {\n-            this.moduleOp = true;\n+        public void noModuleOp() {\n+            this.noModuleOp = true;\n@@ -1381,2 +1381,2 @@\n-        if (javaBuilder.moduleOp) {\n-            result.opts.add(\"-DmoduleOp=true\");\n+        if (javaBuilder.noModuleOp) {\n+            result.opts.add(\"-DnoModuleOp=true\");\n","filename":"hat\/hat\/Script.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-     boolean moduleOp = false;\n+     boolean noModuleOp = false;\n@@ -75,1 +75,1 @@\n-                   case \"moduleOp\" -> moduleOp = true;\n+                   case \"noModuleOp\" -> noModuleOp = true;\n@@ -175,1 +175,1 @@\n-          if (config.moduleOp) System.out.println(\"Using ModuleOp for CallGraphs\");\n+          if (config.noModuleOp) System.out.println(\"NOT using ModuleOp for CallGraphs\");\n@@ -183,1 +183,1 @@\n-              .when(config.moduleOp, Script.JavaBuilder::moduleOp)\n+              .when(config.noModuleOp, Script.JavaBuilder::noModuleOp)\n","filename":"hat\/hat\/run.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}