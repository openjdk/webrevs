{"files":[{"patch":"@@ -161,0 +161,1 @@\n+    private final Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n@@ -219,0 +220,1 @@\n+        computeCapturesIfNeeded(tree);\n@@ -242,0 +244,19 @@\n+    void computeCapturesIfNeeded(JCClassDecl tree) {\n+        if (tree.sym.isDirectlyOrIndirectlyLocal() && !localCaptures.containsKey(tree.sym)) {\n+            \/\/ we need to keep track of captured locals using same strategy as Lower\n+            class FreeVarScanner extends Lower.FreeVarCollector {\n+                FreeVarScanner() {\n+                    lower.super(tree);\n+                }\n+\n+                @Override\n+                protected void addFreeVars(ClassSymbol c) {\n+                    localCaptures.getOrDefault(c, List.of())\n+                            .forEach(s -> addFreeVar((VarSymbol)s));\n+                }\n+            }\n+            FreeVarScanner fvs = new FreeVarScanner();\n+            localCaptures.put(tree.sym, List.copyOf(fvs.analyzeCaptures()));\n+        }\n+    }\n+\n@@ -404,1 +425,0 @@\n-        private final Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n@@ -501,0 +521,1 @@\n+                computeCapturesIfNeeded(tree);\n@@ -535,3 +556,7 @@\n-                if (tree.type.tsym.owner.kind == MTH &&\n-                        !seenClasses.contains(tree.type.tsym)) {\n-                    throw unsupported(tree);\n+                if (tree.type.tsym.isDirectlyOrIndirectlyLocal()) {\n+                    for (Symbol c : localCaptures.get(tree.type.tsym)) {\n+                        addFreeVar((VarSymbol) c);\n+                    }\n+                }\n+                if (tree.encl == null && tree.type.tsym.hasOuterInstance()) {\n+                    capturesThis = true;\n@@ -1314,0 +1339,1 @@\n+            \/\/ this cannot happen, as constructors cannot be reflectable\n@@ -1320,1 +1346,0 @@\n-            Type outer = type.getEnclosingType();\n@@ -1322,1 +1347,1 @@\n-            if (!outer.hasTag(TypeTag.NONE)) {\n+            if (type.tsym.hasOuterInstance()) {\n@@ -2387,16 +2412,1 @@\n-            if (tree.sym.isDirectlyOrIndirectlyLocal()) {\n-                \/\/ we need to keep track of captured locals using same strategy as Lower\n-                class FreeVarScanner extends Lower.FreeVarCollector {\n-                    FreeVarScanner() {\n-                        lower.super(tree);\n-                    }\n-\n-                    @Override\n-                    protected void addFreeVars(ClassSymbol c) {\n-                        localCaptures.getOrDefault(c, List.of())\n-                                .forEach(s -> addFreeVar((VarSymbol)s));\n-                    }\n-                }\n-                FreeVarScanner fvs = new FreeVarScanner();\n-                localCaptures.put(tree.sym, List.copyOf(fvs.analyzeCaptures()));\n-            }\n+            computeCapturesIfNeeded(tree);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.function.Supplier;\n+\n@@ -185,0 +187,118 @@\n+\n+    class Inner { }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"testImplicitInner\" (%0 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::Inner\" -> {\n+                    %2 : java.type:\"LocalClassTest::Inner\" = new %0 @java.ref:\"LocalClassTest::Inner::(LocalClassTest)\";\n+                    return %2;\n+                };\n+                %3 : Var<java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\"> = var %1 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void testImplicitInner() {\n+        Supplier<Inner> aNew = (@Reflect Supplier<Inner>) () -> new Inner();\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"testExplicitInner\" (%0 : java.type:\"LocalClassTest\", %1 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                %2 : Var<java.type:\"LocalClassTest\"> = var %1 @\"test\";\n+                %3 : java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::Inner\" -> {\n+                    %4 : java.type:\"LocalClassTest\" = var.load %2;\n+                    %5 : java.type:\"LocalClassTest::Inner\" = new %4 @java.ref:\"LocalClassTest::Inner::(LocalClassTest)\";\n+                    return %5;\n+                };\n+                %6 : Var<java.type:\"java.util.function.Supplier<LocalClassTest::Inner>\"> = var %3 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void testExplicitInner(LocalClassTest test) {\n+        Supplier<Inner> aNew = (@Reflect Supplier<Inner>) () -> test.new Inner();\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"testLocalInMethod\" (%0 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<LocalClassTest::$1L>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::$1L\" -> {\n+                    %2 : java.type:\"LocalClassTest::$1L\" = new %0 @java.ref:\"LocalClassTest::$1L::(LocalClassTest)\";\n+                    return %2;\n+                };\n+                %3 : Var<java.type:\"java.util.function.Supplier<LocalClassTest::$1L>\"> = var %1 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void testLocalInMethod() {\n+        class L { }\n+        Supplier<L> aNew = (@Reflect Supplier<L>) () -> new L();\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"testLocalInLambda\" (%0 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Object>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Object\" -> {\n+                    %2 : java.type:\"LocalClassTest::$2L\" = new %0 @java.ref:\"LocalClassTest::$2L::(LocalClassTest)\";\n+                    return %2;\n+                };\n+                %3 : Var<java.type:\"java.util.function.Supplier<java.lang.Object>\"> = var %1 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void testLocalInLambda() {\n+        Supplier<Object> aNew = (@Reflect Supplier<Object>) () -> {\n+            class L { }\n+            return new L();\n+        };\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"testLocalInMethodWithCaptures\" (%0 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.lang.String\" = constant @\"Foo\";\n+                %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n+                %3 : java.type:\"java.util.function.Supplier<LocalClassTest::$3L>\" = lambda @lambda.isQuotable=true ()java.type:\"LocalClassTest::$3L\" -> {\n+                    %4 : java.type:\"java.lang.String\" = var.load %2;\n+                    %5 : java.type:\"LocalClassTest::$3L\" = new %0 %4 @java.ref:\"LocalClassTest::$3L::(LocalClassTest, java.lang.String)\";\n+                    return %5;\n+                };\n+                %6 : Var<java.type:\"java.util.function.Supplier<LocalClassTest::$3L>\"> = var %3 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void testLocalInMethodWithCaptures() {\n+        String s = \"Foo\";\n+        class L {\n+            String s() {\n+                return s;\n+            }\n+        }\n+        Supplier<L> aNew = (@Reflect Supplier<L>) () -> new L();\n+    }\n+\n+    @Reflect\n+    @IR(\"\"\"\n+            func @\"testLocalInLambdaWithCaptures\" (%0 : java.type:\"LocalClassTest\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.lang.String\" = constant @\"Foo\";\n+                %2 : Var<java.type:\"java.lang.String\"> = var %1 @\"s\";\n+                %3 : java.type:\"java.util.function.Supplier<java.lang.Object>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Object\" -> {\n+                    %4 : java.type:\"java.lang.String\" = var.load %2;\n+                    %5 : java.type:\"LocalClassTest::$4L\" = new %0 %4 @java.ref:\"LocalClassTest::$4L::(LocalClassTest, java.lang.String)\";\n+                    return %5;\n+                };\n+                %6 : Var<java.type:\"java.util.function.Supplier<java.lang.Object>\"> = var %3 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void testLocalInLambdaWithCaptures() {\n+        String s = \"Foo\";\n+        Supplier<Object> aNew = (@Reflect Supplier<Object>) () -> {\n+            class L {\n+                String s() {\n+                    return s;\n+                }\n+            }\n+            return new L();\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalClassTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"}]}