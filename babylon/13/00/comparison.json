{"files":[{"patch":"@@ -35,1 +35,0 @@\n-  $base\/writer\/impl \\\n","filename":"cr-util\/copy-to-compiler.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+        extends CodeItem\n@@ -68,2 +69,1 @@\n-     * @param v the body visitor\n-     * @return the visiting function for bodies\n+     * @param v   the body visitor\n@@ -71,0 +71,1 @@\n+     * @return the visiting function for bodies\n@@ -81,2 +82,1 @@\n-     * @param v the block visitor\n-     * @return the visiting function for blocks\n+     * @param v   the block visitor\n@@ -84,0 +84,1 @@\n+     * @return the visiting function for blocks\n@@ -87,2 +88,2 @@\n-            ? v.apply(t, f)\n-            : t;\n+                ? v.apply(t, f)\n+                : t;\n@@ -94,2 +95,1 @@\n-     * @param v the operation visitor\n-     * @return the visiting function for operations\n+     * @param v   the operation visitor\n@@ -97,0 +97,1 @@\n+     * @return the visiting function for operations\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeElement.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,9 @@\n+package java.lang.reflect.code;\n+\n+\/**\n+ * A code item, one of {@link CodeElement}, or {@link Value}.\n+ *\/\n+public sealed interface CodeItem\n+        permits CodeElement, Value {\n+    \/\/ @@@ Common functionality between elements and values?\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeItem.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-public abstract sealed class Value implements Comparable<Value>\n+public abstract sealed class Value implements Comparable<Value>, CodeItem\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Value.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.IOException;\n@@ -28,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -33,0 +35,2 @@\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n@@ -238,3 +242,1 @@\n-        GlobalValueBlockNaming gn = new GlobalValueBlockNaming();\n-\n-        OpWriter ow = new OpWriter(w, gn);\n+        OpWriter ow = new OpWriter(w);\n@@ -242,2 +244,6 @@\n-        ow.write(\"\\n\");\n-\n+        try {\n+            w.write(\"\\n\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        Function<CodeItem, String> namer = ow.namer();\n@@ -246,17 +252,17 @@\n-            ow.write(\"^\");\n-            ow.write(gn.getBlockName(b));\n-            ow.write(\"\\n\");\n-            ow.write(\"  Live-in values: \");\n-            ow.writeCommaSeparatedList(liveness.inValues, v -> {\n-                ow.write(\"%\");\n-                ow.write(gn.getValueName(v));\n-            });\n-            ow.write(\"\\n\");\n-            ow.write(\"  Live-out values: \");\n-            ow.writeCommaSeparatedList(liveness.outValues, v -> {\n-                ow.write(\"%\");\n-                ow.write(gn.getValueName(v));\n-            });\n-            ow.write(\"\\n\");\n-\n-            return null;\n+            try {\n+                w.write(\"^\" + namer.apply(b));\n+                w.write(\"\\n\");\n+                w.write(\"  Live-in values: \");\n+                w.write(liveness.inValues.stream()\n+                        .map(v -> \"%\" + namer.apply(v))\n+                        .collect(Collectors.joining(\",\")));\n+                w.write(\"\\n\");\n+                w.write(\"  Live-out values: \");\n+                w.write(liveness.outValues.stream()\n+                        .map(v -> \"%\" + namer.apply(v))\n+                        .collect(Collectors.joining(\",\")));\n+                w.write(\"\\n\");\n+                return null;\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,4 +31,1 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.*;\n@@ -36,1 +33,2 @@\n-import java.lang.reflect.code.writer.impl.GlobalValueBlockNaming;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -38,0 +36,1 @@\n+import java.util.function.Function;\n@@ -39,0 +38,6 @@\n+\/**\n+ * A writer of code models (operations) to the textual form.\n+ * <p>\n+ * A code model in textual form may be parsed back into the runtime form by parsing it.\n+ *\/\n+\/\/ @@@ We cannot link to OpParser since this code is copied into the jdk.compiler module\n@@ -41,1 +46,20 @@\n-    static class AttributeMapper {\n+    static final class GlobalValueBlockNaming implements Function<CodeItem, String> {\n+        final Map<CodeItem, String> gn;\n+        int valueOrdinal = 0;\n+        int blockOrdinal = 0;\n+\n+        GlobalValueBlockNaming() {\n+            this.gn = new HashMap<>();\n+        }\n+\n+        @Override\n+        public String apply(CodeItem codeItem) {\n+            return switch (codeItem) {\n+                case Block block -> gn.computeIfAbsent(block, _b -> \"block_\" + blockOrdinal++);\n+                case Value value -> gn.computeIfAbsent(value, _v -> String.valueOf(valueOrdinal++));\n+                default -> throw new IllegalStateException(\"Unexpected code item: \" + codeItem);\n+            };\n+        }\n+    }\n+\n+    static final class AttributeMapper {\n@@ -140,0 +164,55 @@\n+    final Function<CodeItem, String> namer;\n+    final IndentWriter w;\n+\n+    \/**\n+     * Computes global names for blocks and values in a code model.\n+     * <p>\n+     * The code model is traversed in the same order as if the model\n+     * was written. Therefore, the names in the returned map will the\n+     * same as the names that are written. This can be useful for debugging\n+     * and testing.\n+     *\n+     * @param root the code model\n+     * @return the map of computed names, modifiable\n+     *\/\n+    public static Map<CodeItem, String> computeGlobalNames(Op root) {\n+        GlobalValueBlockNaming gn = root.traverse(new GlobalValueBlockNaming(), (n, e) -> {\n+            switch (e) {\n+                case Op op -> {\n+                    for (Block.Reference r : op.successors()) {\n+                        n.apply(r.targetBlock());\n+                    }\n+\n+                    if (root != op) {\n+                        Op.Result opr = op.result();\n+                        if (!opr.type().equals(TypeDesc.VOID)) {\n+                            n.apply(opr);\n+                        }\n+                    }\n+                }\n+                case Block block -> {\n+                    if (!block.isEntryBlock()) {\n+                        n.apply(block);\n+                    }\n+                    for (Block.Parameter p : block.parameters()) {\n+                        n.apply(p);\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return n;\n+        });\n+\n+        return gn.gn;\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to the character stream.\n+     * <p>\n+     * A carriage return will be written after the model is writen, and\n+     * then character stream will be flushed.\n+     *\n+     * @param w the character stream\n+     * @param op the code modelz\n+     *\/\n@@ -151,3 +230,5 @@\n-    final GlobalValueBlockNaming gn;\n-    final IndentWriter w;\n-\n+    \/**\n+     * Creates a writer of code models (operations) to their textual form.\n+     *\n+     * @param w the character stream writer to write the textual form.\n+     *\/\n@@ -158,2 +239,8 @@\n-    public OpWriter(Writer w, GlobalValueBlockNaming gn) {\n-        this.gn = gn;\n+    \/**\n+     * Creates a writer of code models (operations) to their textual form.\n+     *\n+     * @param w     the character stream writer to write the textual form.\n+     * @param namer the function that computes names for blocks and values.\n+     *\/\n+    public OpWriter(Writer w, Function<CodeItem, String> namer) {\n+        this.namer = namer;\n@@ -163,0 +250,12 @@\n+    \/**\n+     * {@return the function that names blocks and values.}\n+     *\/\n+    public Function<CodeItem, String> namer() {\n+        return namer;\n+    }\n+\n+    \/**\n+     * Writes a code model, an operation, to the character stream.\n+     *\n+     * @param op the code model\n+     *\/\n@@ -233,1 +332,0 @@\n-        boolean isEntryBlock = true;\n@@ -235,1 +333,1 @@\n-            if (!isEntryBlock) {\n+            if (!b.isEntryBlock()) {\n@@ -238,2 +336,1 @@\n-            writeBlock(b, isEntryBlock);\n-            isEntryBlock = false;\n+            writeBlock(b);\n@@ -245,2 +342,2 @@\n-    void writeBlock(Block block, boolean isEntryBlock) {\n-        if (!isEntryBlock) {\n+    void writeBlock(Block block) {\n+        if (!block.isEntryBlock()) {\n@@ -269,1 +366,1 @@\n-        writeBlockName(gn.getBlockName(b));\n+        writeBlockName(namer.apply(b));\n@@ -279,1 +376,1 @@\n-        write(gn.getValueName(v));\n+        write(namer.apply(v));\n@@ -284,1 +381,1 @@\n-        write(gn.getValueName(v));\n+        write(namer.apply(v));\n@@ -293,1 +390,1 @@\n-    public <T> void writeCommaSeparatedList(Iterable<T> l, Consumer<T> c) {\n+    <T> void writeCommaSeparatedList(Iterable<T> l, Consumer<T> c) {\n@@ -308,1 +405,1 @@\n-    public void write(String s) {\n+    void write(String s) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":119,"deletions":22,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.writer.impl;\n-\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Value;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public final class GlobalValueBlockNaming {\n-    final Map<Value, String> gvn;\n-    final Map<Block, String> gbn;\n-    int valueOrdinal = 0;\n-    int blockOrdinal = 0;\n-\n-    public GlobalValueBlockNaming() {\n-        this.gvn = new HashMap<>();\n-        this.gbn = new HashMap<>();\n-    }\n-\n-    public String getValueName(Value _v) {\n-        return gvn.computeIfAbsent(_v, v -> String.valueOf(valueOrdinal++));\n-    }\n-\n-    public String getBlockName(Block _b) {\n-        return gbn.computeIfAbsent(_b, b -> \"block_\" + blockOrdinal++);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/impl\/GlobalValueBlockNaming.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -101,1 +101,0 @@\n-    exports java.lang.reflect.code.writer.impl;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestNaming\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CodeItem;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestNaming {\n+\n+    @CodeReflection\n+    static int f(int n, int m) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum += i;\n+                sum += j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testHigh() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        testModel(f);\n+    }\n+\n+    @Test\n+    public void testLow() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        f = SSA.transform(f);\n+\n+        testModel(f);\n+    }\n+\n+    static void testModel(Op op) {\n+        Map<CodeItem, String> cNamer = OpWriter.computeGlobalNames(op);\n+\n+        StringWriter w = new StringWriter();\n+        new OpWriter(w, cNamer::get).writeOp(op);\n+        w.write(\"\\n\");\n+        String actual = w.toString();\n+\n+        String expected = op.toText();\n+\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestNaming.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestNaming.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}