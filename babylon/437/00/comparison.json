{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.stream.Collectors;\n@@ -319,2 +320,2 @@\n-     * Returns the list of predecessors, namely each block in the parent body that refers\n-     * to this block as a successor.\n+     * Returns the set of predecessors, the set containing each block in the parent\n+     * body that refers to this block as a successor.\n@@ -322,1 +323,1 @@\n-     * @return the set of predecessors, as an unmodifiable list.\n+     * @return the set of predecessors, as an unmodifiable set.\n@@ -330,1 +331,20 @@\n-     * Returns the list of successors referring to other blocks in the parent body.\n+     * Returns the list of predecessor references to this block.\n+     * <p>\n+     * This method behaves is if it returns the result of the following expression:\n+     * {@snippet lang = java:\n+     * predecessors.stream().flatMap(p->successors().stream())\n+     *    .filter(r->r.targetBlock() == this)\n+     *    .toList();\n+     *}\n+     *\n+     * @return the list of predecessor references to this block, as an unmodifiable list.\n+     * @apiNote A predecessor block may reference it successor block one or more times.\n+     *\/\n+    public List<Block.Reference> predecessorReferences() {\n+        return predecessors.stream().flatMap(p -> successors().stream())\n+                .filter(r -> r.targetBlock() == this)\n+                .toList();\n+    }\n+\n+    \/**\n+     * Returns the list of successors referring to other blocks.\n@@ -335,0 +355,2 @@\n+     * @apiNote given a block, A say, whose successor targets a block, B say, we can\n+     * state that B is a successor block of A and A is a predecessor block of B.\n@@ -341,0 +363,16 @@\n+    \/**\n+     * Returns the set of target blocks referred to by the successors of this block.\n+     * <p>\n+     * This method behaves is if it returns the result of the following expression:\n+     * {@snippet lang = java:\n+     * successors().stream()\n+     *     .map(Block.Reference::targetBlock)\n+     *     .toList();\n+     *}\n+     *\n+     * @return the list of target blocks, as an unmodifiable set.\n+     *\/\n+    public SequencedSet<Block> successorTargets() {\n+        return successors().stream().map(Block.Reference::targetBlock).collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n@@ -422,0 +460,20 @@\n+    \/**\n+     * Returns the immediate post dominator of this block, otherwise {@link Body#IPDOM_EXIT} if this block is the\n+     * only block with no successors or if this block is one of many blocks that has no successors.\n+     * Both this block and the immediate post dominator (if defined) have the same parent body.\n+     * <p>\n+     * The post immediate dominator is the unique block that strictly post dominates this block, but does not strictly\n+     * post dominate any other block that strictly post dominates this block.\n+     *\n+     * @return the immediate dominator of this block, otherwise {@code null} if this block is the entry block.\n+     *\/\n+    public Block immediatePostDominator() {\n+        if (this == parentBody().entryBlock()) {\n+            return null;\n+        }\n+\n+        Map<Block, Block> ipdoms = parentBody().immediatePostDominators();\n+        Block ipdom = ipdoms.get(this);\n+        return ipdom == this ? Body.IPDOM_EXIT : ipdom;\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":62,"deletions":4,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -262,0 +262,132 @@\n+            }\n+        }\n+\n+        return df;\n+    }\n+\n+    \/**\n+     * A synthetic block representing the post dominator of all blocks\n+     * when two or more blocks have no successors.\n+     * <p>\n+     * Computing the immediate post dominators requires a single exit point,\n+     * one block that has no successors. When there are two or more blocks\n+     * with no successors then this block represents the immediate post\n+     * dominator of those blocks\n+     *\/\n+    public static final Block IPDOM_EXIT;\n+    static {\n+        IPDOM_EXIT = new Block(null);\n+        IPDOM_EXIT.index = Integer.MAX_VALUE;\n+    }\n+\n+    \/**\n+     * Returns a map of block to its immediate post dominator.\n+     * <p>\n+     * If there are two or more blocks with no successors then\n+     * a single exit point is synthesized using the {@link #IPDOM_EXIT}\n+     * block, which represents the immediate post dominator of those blocks.\n+     *\n+     * @return a map of block to its immediate post dominator, as an unmodifiable map\n+     *\/\n+    public Map<Block, Block> immediatePostDominators() {\n+        Map<Block, Block> pdoms = new HashMap<>();\n+\n+        \/\/ If there are multiple exit blocks (those with zero successors)\n+        \/\/ then use the block IPDOM_EXIT that is the synthetic successor of\n+        \/\/ the exit blocks\n+        boolean nSuccessors = blocks.stream().filter(b -> b.successors().isEmpty()).count() > 1;\n+\n+        if (nSuccessors) {\n+            pdoms.put(IPDOM_EXIT, IPDOM_EXIT);\n+        } else {\n+            Block exit = blocks.getLast();\n+            assert blocks.stream().filter(b -> b.successors().isEmpty()).findFirst().orElseThrow() == exit;\n+            pdoms.put(exit, exit);\n+        }\n+\n+        \/\/ Blocks are sorted in reverse postorder\n+        boolean changed;\n+        do {\n+            changed = false;\n+            \/\/ Iterate in reverse through blocks in reverse postorder, except for exit block\n+            for (int i = blocks.size() - (nSuccessors ? 1 : 2); i >= 0; i--) {\n+                Block b = blocks.get(i);\n+\n+                \/\/ Find first processed successor of b\n+                Block newIpdom = null;\n+                Collection<Block> targets = b.successorTargets();\n+                for (Block s : nSuccessors && targets.isEmpty() ? List.of(IPDOM_EXIT) : targets) {\n+                    if (pdoms.containsKey(s)) {\n+                        newIpdom = s;\n+                        break;\n+                    }\n+                }\n+\n+                if (newIpdom == null) {\n+                    \/\/ newIpdom can be null if all successors reference\n+                    \/\/ prior blocks (back branch) yet to be encountered\n+                    \/\/ in the dominator treee\n+                    continue;\n+                }\n+\n+                \/\/ For all other successors, s, of b\n+                for (Block s : b.successorTargets()) {\n+                    if (s == newIpdom) {\n+                        continue;\n+                    }\n+\n+                    if (pdoms.containsKey(s)) {\n+                        \/\/ If already calculated\n+                        newIpdom = postIntersect(pdoms, s, newIpdom, blocks.size());\n+                    }\n+                }\n+\n+                if (pdoms.get(b) != newIpdom) {\n+                    pdoms.put(b, newIpdom);\n+                    changed = true;\n+                }\n+            }\n+        } while (changed);\n+\n+        return Collections.unmodifiableMap(pdoms);\n+    }\n+\n+    static Block postIntersect(Map<Block, Block> doms, Block b1, Block b2, int exitIndex) {\n+        while (b1 != b2) {\n+            while (b1.index() < b2.index()) {\n+                b1 = doms.get(b1);\n+            }\n+\n+            while (b2.index() < b1.index()) {\n+                b2 = doms.get(b2);\n+            }\n+        }\n+\n+        return b1;\n+    }\n+\n+    \/**\n+     * Returns the post dominance frontier of each block in the body.\n+     * <p>\n+     * The post dominance frontier of block, {@code B} say, is the set of all blocks, {@code C} say,\n+     * such that {@code B} post dominates a successor of {@code C} but does not strictly post dominate\n+     * {@code C}.\n+     *\n+     * @return the post dominance frontier of each block in the body, as a modifiable map\n+     *\/\n+    public Map<Block, Set<Block>> postDominanceFrontier() {\n+        \/\/ @@@ cache result?\n+        Map<Block, Block> idoms = immediatePostDominators();\n+        Map<Block, Set<Block>> df = new HashMap<>();\n+\n+        for (Block b : blocks) {\n+            Set<Block> succs = b.successorTargets();\n+\n+            if (succs.size() > 1) {\n+                for (Block s : succs) {\n+                    Block runner = s;\n+                    while (runner != idoms.get(b)) {\n+                        df.computeIfAbsent(runner, _ -> new LinkedHashSet<>()).add(b);\n+                        runner = idoms.get(runner);\n+                    }\n+                }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Body.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import jdk.incubator.code.Body;\n+import jdk.incubator.code.parser.OpParser;\n@@ -53,0 +55,1 @@\n+    @Test\n@@ -74,0 +77,6 @@\n+\n+        Map<Block, Block> ipdoms = f.body().immediatePostDominators();\n+        Assert.assertThrows(UnsupportedOperationException.class,\n+                () -> ipdoms.put(f.body().entryBlock(), f.body().entryBlock()));\n+        Assert.assertThrows(UnsupportedOperationException.class,\n+                ipdoms::clear);\n@@ -313,0 +322,100 @@\n+    @Test\n+    public void testPostDominance() {\n+        String m = \"\"\"\n+                func @\"f\" (%0 : java.type:\"boolean\")java.type:\"void\" -> {\n+                    %5 : java.type:\"void\" = branch ^A;\n+\n+                  ^A:\n+                    %8 : java.type:\"void\" = cbranch %0 ^B ^C;\n+\n+                  ^B:\n+                    %11 : java.type:\"void\" = branch ^D;\n+\n+                  ^C:\n+                    %13 : java.type:\"void\" = branch ^D;\n+\n+                  ^D:\n+                    %15 : java.type:\"void\" = branch ^E;\n+\n+                  ^E:\n+                    %15 : java.type:\"void\" = branch ^F;\n+\n+                  ^F:\n+                    %16 : java.type:\"void\" = cbranch %0 ^E ^END;\n+\n+                  ^END:\n+                    %18 : java.type:\"void\" = return;\n+                };\n+                \"\"\";\n+        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfFuncOp(m);\n+\n+        Map<Block, Block> ipdoms = f.body().immediatePostDominators();\n+        Assert.assertFalse(ipdoms.containsKey(Body.IPDOM_EXIT));\n+\n+        Block exit = ipdoms.containsKey(Body.IPDOM_EXIT) ? Body.IPDOM_EXIT : f.body().blocks().getLast();\n+        Node<String> domTree = buildDomTree(exit, ipdoms).transform(b -> Integer.toString(b.index()));\n+        Node<String> domTreeExpected =\n+                node(\"7\",\n+                        node(\"6\",\n+                                node(\"5\",\n+                                        node(\"4\",\n+                                                node(\"2\"),\n+                                                node(\"3\"),\n+                                                node(\"1\",\n+                                                        node(\"0\"))))));\n+        Assert.assertEquals(domTree, domTreeExpected);\n+    }\n+\n+    @Test\n+    public void testPostDominanceFrontier() {\n+        String m = \"\"\"\n+                func @\"f\" (%0 : java.type:\"boolean\")java.type:\"void\" -> {\n+                    %5 : java.type:\"void\" = cbranch %0 ^B ^F;\n+\n+                  ^B:\n+                    %8 : java.type:\"void\" = cbranch %0 ^C ^D;\n+\n+                  ^C:\n+                    %11 : java.type:\"void\" = branch ^E;\n+\n+                  ^D:\n+                    %13 : java.type:\"void\" = branch ^E;\n+\n+                  ^E:\n+                    %15 : java.type:\"void\" = branch ^F;\n+\n+                  ^F:\n+                    %18 : java.type:\"void\" = return;\n+                };\n+                \"\"\";\n+        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfFuncOp(m);\n+\n+        Map<Block, Block> ipdoms = f.body().immediatePostDominators();\n+        Assert.assertFalse(ipdoms.containsKey(Body.IPDOM_EXIT));\n+\n+        Block exit = ipdoms.containsKey(Body.IPDOM_EXIT) ? Body.IPDOM_EXIT : f.body().blocks().getLast();\n+        Node<String> domTree = buildDomTree(exit, ipdoms).transform(b -> Integer.toString(b.index()));\n+        Node<String> domTreeExpected =\n+                node(\"5\",\n+                        node(\"4\",\n+                                node(\"1\"),\n+                                node(\"2\"),\n+                                node(\"3\")),\n+                        node(\"0\"));\n+        Assert.assertEquals(domTree, domTreeExpected);\n+\n+        Map<String, Set<String>> df = f.body().postDominanceFrontier().entrySet().stream()\n+                .map(e -> Map.entry(Integer.toString(e.getKey().index()),\n+                        e.getValue().stream().map(b -> Integer.toString(b.index())).collect(Collectors.toSet())))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        Map<String, Set<String>> dfExpected = Map.ofEntries(\n+                Map.entry(\"1\", Set.of(\"0\")),\n+                Map.entry(\"2\", Set.of(\"1\")),\n+                Map.entry(\"3\", Set.of(\"1\")),\n+                Map.entry(\"4\", Set.of(\"0\"))\n+        );\n+        Assert.assertEquals(df, dfExpected);\n+    }\n+\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"}]}