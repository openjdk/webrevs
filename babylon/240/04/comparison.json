{"files":[{"patch":"@@ -116,1 +116,1 @@\n-        return refType + \"::\" + name + \"()\" + type;\n+        return refType.externalize() + \"::\" + name + \"()\" + type.externalize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/FieldRefImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,3 +142,3 @@\n-        return refType + \"::\" + name +\n-            type.parameterTypes().stream().map(TypeElement::toString)\n-                    .collect(joining(\", \", \"(\", \")\")) + type.returnType();\n+        return refType.externalize() + \"::\" + name +\n+            type.parameterTypes().stream().map(t -> t.externalize().toString())\n+                    .collect(joining(\", \", \"(\", \")\")) + type.returnType().externalize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                .map(c -> c.type().toString() + \" \" + c.name())\n+                .map(c -> c.type().externalize() + \" \" + c.name())\n@@ -69,1 +69,1 @@\n-                recordType.toString();\n+                recordType.externalize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/RecordTypeRefImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestPatterns2\n+ * @enablePreview\n+ *\/\n+public class TestPatterns2 {\n+\n+    record R<T extends Number> (T n) {}\n+\n+    @CodeReflection\n+    static boolean f(Object o) {\n+        return o instanceof R(Integer i);\n+    }\n+\n+    @Test\n+    void test() {\n+\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        R[] args = {new R(1), new R(2d)};\n+        for (R arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, arg), f(arg));\n+        }\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestPatterns2.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns2.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -53,1 +53,2 @@\n-                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"}\n+                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"},\n+                {\"R<#R::T<java.lang.Number>>::n()#R::T<java.lang.Number>\", \"R<#R::T<java.lang.Number>>\", \"n\"}\n@@ -61,1 +62,1 @@\n-        Assert.assertEquals(mr.refType().toString(), refType);\n+        Assert.assertEquals(mr.refType().externalize().toString(), refType);\n@@ -72,0 +73,1 @@\n+                {\"R<#R::T<java.lang.Number>>::n()#R::T<java.lang.Number>\", \"R<#R::T<java.lang.Number>>\", \"n\", \"#R::T<java.lang.Number>\"}\n@@ -79,1 +81,1 @@\n-        Assert.assertEquals(fr.refType().toString(), refType);\n+        Assert.assertEquals(fr.refType().externalize().toString(), refType);\n@@ -81,1 +83,1 @@\n-        Assert.assertEquals(fr.type().toString(), type);\n+        Assert.assertEquals(fr.type().externalize().toString(), type);\n@@ -92,0 +94,1 @@\n+                {\"(#R::T<java.lang.Number> n)R<#R::T<java.lang.Number>>\"}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @build PatternTest2\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester PatternTest2\n+ *\/\n+public class PatternTest2 {\n+    record R<T extends Number> (T n) {}\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : java.lang.Object)boolean -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.Object = var.load %1;\n+                %3 : java.lang.Integer = constant @null;\n+                %4 : Var<java.lang.Integer> = var %3 @\"i\";\n+                %5 : boolean = pattern.match %2\n+                    ()java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> -> {\n+                        %6 : java.lang.reflect.code.ExtendedOp$Pattern$Type<java.lang.Integer> = pattern.type @\"i\";\n+                        %7 : java.lang.reflect.code.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> = pattern.record %6 @\"(#PatternTest2$R::T<java.lang.Number> n)PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>\";\n+                        yield %7;\n+                    }\n+                    (%8 : java.lang.Integer)void -> {\n+                        var.store %4 %8;\n+                        yield;\n+                    };\n+                return %5;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static boolean f(Object o) {\n+        return o instanceof R(Integer i);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternTest2.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}