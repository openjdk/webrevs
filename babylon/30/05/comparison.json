{"files":[{"patch":"@@ -1795,1 +1795,2 @@\n-        final String name;\n+        final String varName;\n+        final TypeElement resultType;\n@@ -1810,1 +1811,1 @@\n-        VarOp(OpDefinition def, String name) {\n+        VarOp(OpDefinition def, String varName) {\n@@ -1813,1 +1814,2 @@\n-            this.name = name;\n+            this.varName = varName;\n+            this.resultType = def.resultType();\n@@ -1819,1 +1821,2 @@\n-            this.name = that.name;\n+            this.varName = that.varName;\n+            this.resultType = that.resultType;\n@@ -1828,0 +1831,4 @@\n+            this(varName, init.type(), init);\n+        }\n+\n+        VarOp(String varName, TypeElement type, Value init) {\n@@ -1830,1 +1837,2 @@\n-            this.name = varName;\n+            this.varName = varName;\n+            this.resultType = VarType.varType(type);\n@@ -1835,1 +1843,1 @@\n-            if (name == null) {\n+            if (varName == null) {\n@@ -1840,1 +1848,1 @@\n-            m.put(\"\", name);\n+            m.put(\"\", varName);\n@@ -1845,1 +1853,1 @@\n-            return name;\n+            return varName;\n@@ -1849,1 +1857,1 @@\n-            return operands().get(0).type();\n+            return ((VarType) resultType).valueType();\n@@ -1854,1 +1862,1 @@\n-            return VarType.varType(varType());\n+            return resultType;\n@@ -3410,0 +3418,11 @@\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type, Value init) {\n+        return new VarOp(name, type, init);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,3 +31,1 @@\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.type.*;\n@@ -35,1 +33,0 @@\n-import java.lang.reflect.code.type.VarType;\n@@ -3146,0 +3143,70 @@\n+\n+    @OpDeclaration(StringTemplateOp.NAME)\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+\n+        public static final String NAME = \"java.stringTemplate\";\n+\n+        private final List<Body> expressions;\n+\n+        public StringTemplateOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expressions = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expressions = that.expressions.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        public StringTemplateOp(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressions) {\n+            \/\/ @@@ update to use statements before super when the compiler can depend on 22 features\n+            super(NAME, makeOperandsList(processorValue, literalsValues));\n+\n+            this.expressions = expressions.stream().map(b -> b.build(this)).toList();\n+        }\n+\n+        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n+            List<Value> operands = new ArrayList<>();\n+            operands.add(processorValue);\n+            operands.addAll(literalsValues);\n+            return operands;\n+        }\n+\n+        @Override\n+        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StringTemplateOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            TypeElement pt = processor().type();\n+            if (!(pt instanceof JavaType jt)) {\n+                throw new IllegalStateException(\"We expect processor type to be a java type\");\n+            }\n+            if (!jt.hasTypeArguments()) {\n+                throw new IllegalStateException(\"We expect processor type to have arguments, found \" + jt);\n+            }\n+            return jt.typeArguments().get(0);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return expressions;\n+        }\n+\n+        public Value processor() {\n+            return operands().get(0);\n+        }\n+\n+        public List<Value> fragments() {\n+            return operands().subList(1, operands().size());\n+        }\n+    }\n+\n+    public static StringTemplateOp stringTemplate(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressionsBodies) {\n+        return new StringTemplateOp(processorValue, literalsValues, expressionsBodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":71,"deletions":4,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+    JavaType J_L_STRING_TEMPLATE = new JavaTypeImpl(\"java.lang.StringTemplate\");\n+\n+    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new JavaTypeImpl(\"java.lang.StringTemplate$Processor\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -445,1 +445,2 @@\n-                        Tag.TYPEARRAY);\n+                        Tag.TYPEARRAY,\n+                        Tag.STRING_TEMPLATE);\n@@ -684,1 +685,1 @@\n-            result = append(CoreOps.var(tree.name.toString(), initOp));\n+            result = append(CoreOps.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -1166,1 +1167,1 @@\n-                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), init));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n@@ -2104,0 +2105,17 @@\n+\n+        @Override\n+        public void visitStringTemplate(JCTree.JCStringTemplate tree) {\n+            Value processor = toValue(tree.processor);\n+\n+            List<Value> fragments = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n+\n+            List<Body.Builder> expressions = new ArrayList<>();\n+            tree.expressions.forEach(e -> {\n+                pushBody(e, FunctionType.functionType(typeToTypeElement(e.type)));\n+                append(CoreOps._yield(toValue(e)));\n+                expressions.add(stack.body);\n+                popBody();\n+            });\n+            result = append(ExtendedOps.stringTemplate(processor, fragments, expressions));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.Op;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Arrays;\n-\n-import static java.lang.reflect.code.op.CoreOps.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.DOUBLE;\n-\n-\/*\n- * @test\n- * @run testng TestOpResultTypeNotCopiedBlindly\n- *\/\n-\n-public class TestOpResultTypeNotCopiedBlindly {\n-\n-    @CodeReflection\n-    static int f(int a, int b) {\n-        return a + b;\n-    }\n-\n-    @Test\n-    void test() {\n-        FuncOp f = getCodeModel(this.getClass(), \"f\");\n-\n-        FuncOp g = func(\"g\", functionType(DOUBLE, DOUBLE, DOUBLE))\n-                .body(b -> b.inline(f, b.parameters(), (block, v) -> {\n-                    block.op(_return(v));\n-                }));\n-\n-        g.writeTo(System.out);\n-\n-        \/\/ check that add has a result-type of double\n-        Assert.assertEquals(\n-                ((Op.Result) g.body().entryBlock().terminatingOp().operands().get(0)).op().result().type(),\n-                DOUBLE\n-        );\n-    }\n-\n-    private static FuncOp getCodeModel(Class<?> c, String methodName) {\n-        return Arrays.stream(c.getDeclaredMethods()).filter(m -> m.getName().equals(methodName))\n-                .findFirst().get().getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpResultTypeNotCopiedBlindly.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build StringTemplateTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester StringTemplateTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.StringTemplate.RAW;\n+import static java.lang.StringTemplate.STR;\n+\n+public class StringTemplateTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.String = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.String> = var %5 @\"s\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f(int y) {\n+        String s = STR. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f2\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.StringTemplate = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.StringTemplate> = var %5 @\"st\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f2(int y) {\n+        StringTemplate st = RAW. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f3\" (%0 : int, %1 : int, %2 : int)void -> {\n+                  %3 : Var<int> = var %0 @\"x\";\n+                  %4 : Var<int> = var %1 @\"y\";\n+                  %5 : Var<int> = var %2 @\"z\";\n+                  %6 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %7 : java.lang.String = constant @\"x = \";\n+                  %8 : java.lang.String = constant @\", z = \";\n+                  %9 : java.lang.String = constant @\", x + z = \";\n+                  %10 : java.lang.String = constant @\"\";\n+                  %11 : java.lang.String = java.stringTemplate %6 %7 %8 %9 %10\n+                      ()int -> {\n+                          %12 : int = var.load %3;\n+                          yield %12;\n+                      }\n+                      ()int -> {\n+                          %13 : int = var.load %5;\n+                          yield %13;\n+                      }\n+                      ()int -> {\n+                          %14 : int = var.load %3;\n+                          %15 : int = var.load %5;\n+                          %16 : int = add %14 %15;\n+                          yield %16;\n+                      };\n+                  %17 : Var<java.lang.String> = var %11 @\"s\";\n+                  %18 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %19 : java.lang.String = constant @\"y = \";\n+                  %20 : java.lang.String = constant @\", \";\n+                  %21 : java.lang.String = constant @\"\";\n+                  %22 : java.lang.String = java.stringTemplate %18 %19 %20 %21\n+                      ()int -> {\n+                          %23 : int = var.load %4;\n+                          yield %23;\n+                      }\n+                      ()java.lang.String -> {\n+                          %24 : java.lang.String = var.load %17;\n+                          yield %24;\n+                      };\n+                  %25 : Var<java.lang.String> = var %22 @\"s2\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f3(int x, int y, int z) {\n+        String s = STR.\"x = \\{x}, z = \\{z}, x + z = \\{x + z}\";\n+        String s2 = STR.\"y = \\{y}, \\{s}\";\n+    }\n+\n+    \/\/ this test will fail for now\n+    \/\/ the reason is wildcard types not modeled\n+    \/\/ the type of the processor X will be java.lang.StringTemplate$Processor\n+    \/\/ this will cause StringTemplateOp.resultType to fail (which is called during IR generation)\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f4\" ()void -> {\n+                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %1 : Var<java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>> = var %0 @\"X\";\n+                  %2 : java.lang.x<java.lang.Object, java.lang.RuntimeException> = var.load %1;\n+                  %3 : java.lang.String = constant @\"some template\";\n+                  %4 : java.lang.Object = java.stringTemplate %2 %3;\n+                  %5 : Var<java.lang.Object> = var %4 @\"o\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void f4() {\n+        StringTemplate.Processor<?, RuntimeException> X = STR;\n+        Object o = X.\"some template\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}