{"files":[{"patch":"@@ -3146,0 +3146,44 @@\n+\n+    @OpDeclaration(StringTemplateOp.NAME)\n+    public static final class StringTemplateOp extends OpWithDefinition {\n+\n+        public static final String NAME = \"java.stringTemplate\";\n+\n+        public StringTemplateOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StringTemplateOp(this, cc, ot);\n+        }\n+\n+        public StringTemplateOp(List<Value> literalsValues, List<Value> expressionValues) {\n+            super(NAME, getOperandsList(literalsValues, expressionValues));\n+        }\n+\n+        private static List<Value> getOperandsList(List<Value> literalsValues, List<Value> expressionValues) {\n+            List<Value> operands = new ArrayList<>();\n+            for (int i = 0; i < literalsValues.size(); i++) {\n+                operands.add(literalsValues.get(i));\n+                if (i < expressionValues.size()) {\n+                    operands.add(expressionValues.get(i));\n+                }\n+            }\n+            return operands;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.J_L_STRING_TEMPLATE;\n+        }\n+    }\n+\n+    public static StringTemplateOp stringTemplate(List<Value> literalsValues, List<Value> expressionsValues) {\n+        return new StringTemplateOp(literalsValues, expressionsValues);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+    JavaType J_L_STRING_TEMPLATE = new JavaTypeImpl(\"java.lang.StringTemplate\");\n+\n+    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new JavaTypeImpl(\"java.lang.StringTemplate$Processor\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -443,1 +443,2 @@\n-                        Tag.TYPEARRAY);\n+                        Tag.TYPEARRAY,\n+                        Tag.STRING_TEMPLATE);\n@@ -2096,0 +2097,20 @@\n+\n+        @Override\n+        public void visitStringTemplate(JCTree.JCStringTemplate tree) {\n+            \/*\n+            #1 = \"y= \"\n+            #2 = \"\"\n+            #3 = y\n+            #4 = StringTemplate(#1 #3 #2)\n+            #5 invoke StringTemplate.Processor.process #stp #4\n+            *\/\n+            List<Value> literalsValues = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n+            List<Value> expressionsValues = tree.expressions.map(e -> toValue(e));\n+            Op.Result stringTemplateValue = append(ExtendedOps.stringTemplate(literalsValues, expressionsValues));\n+            Value processorValue = toValue(tree.processor);\n+            TypeElement processorReturnType = typeToTypeElement(tree.processor.type.allparams().get(0));\n+            result = append(CoreOps.invoke(\n+                    MethodDesc.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\", processorReturnType, JavaType.J_L_STRING_TEMPLATE),\n+                    processorValue, stringTemplateValue));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build StringTemplateTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester StringTemplateTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.StringTemplate.RAW;\n+import static java.lang.StringTemplate.STR;\n+\n+public class StringTemplateTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.String = constant @\"y = \";\n+                  %3 : java.lang.String = constant @\"\";\n+                  %4 : int = var.load %1;\n+                  %5 : java.lang.StringTemplate = java.stringTemplate %2 %4 %3;\n+                  %6 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %7 : java.lang.String = invoke %6 %5 @\"java.lang.StringTemplate$Processor::process(java.lang.StringTemplate)java.lang.String\";\n+                  %8 : Var<java.lang.String> = var %7 @\"s\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void f(int y) {\n+        String s = STR. \"y = \\{y}\" ;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f2\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"y\";\n+                %2 : java.lang.String = constant @\"y = \";\n+                %3 : java.lang.String = constant @\"\";\n+                %4 : int = var.load %1;\n+                %5 : java.lang.StringTemplate = java.stringTemplate %2 %4 %3;\n+                %6 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException>\";\n+                %7 : java.lang.StringTemplate = invoke %6 %5 @\"java.lang.StringTemplate$Processor::process(java.lang.StringTemplate)java.lang.StringTemplate\";\n+                %8 : Var<java.lang.StringTemplate> = var %7 @\"st\";\n+                return;\n+            };\n+            \"\"\")\n+    static void f2(int y) {\n+        StringTemplate st = RAW. \"y = \\{y}\" ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}