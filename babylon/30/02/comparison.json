{"files":[{"patch":"@@ -31,3 +31,1 @@\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.type.*;\n@@ -35,1 +33,0 @@\n-import java.lang.reflect.code.type.VarType;\n@@ -3146,0 +3143,64 @@\n+\n+    @OpDeclaration(StringTemplateOp.NAME)\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+\n+        public static final String NAME = \"java.stringTemplate\";\n+\n+        private final Value processorValue;\n+        private final List<Value> literalsValues;\n+        private final List<Body> expressionsBodies;\n+\n+        public StringTemplateOp(OpDefinition def) {\n+            super(def);\n+\n+            this.processorValue = operands().get(0);\n+            this.literalsValues = operands().subList(1, operands().size());\n+            this.expressionsBodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.processorValue = operands().get(0);\n+            this.literalsValues = operands().subList(1, operands().size());\n+            this.expressionsBodies = that.expressionsBodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        public StringTemplateOp(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressionsBodies) {\n+            super(NAME, makeOperandsList(processorValue, literalsValues));\n+\n+            this.processorValue = processorValue;\n+            this.literalsValues = literalsValues;\n+            this.expressionsBodies = expressionsBodies.stream().map(b -> b.build(this)).toList();\n+        }\n+\n+        @Override\n+        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StringTemplateOp(this, cc, ot);\n+        }\n+\n+        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n+            List<Value> operands = new ArrayList<>();\n+            operands.add(processorValue);\n+            operands.addAll(literalsValues);\n+            return operands;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            \/\/ processor type: StringTemplate$Processor<R, ...>\n+            TypeDefinition processorReturnType = processorValue.type().toTypeDefinition().arguments().get(0);\n+            return CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(processorReturnType);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return expressionsBodies;\n+        }\n+    }\n+\n+    public static StringTemplateOp stringTemplate(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressionsBodies) {\n+        return new StringTemplateOp(processorValue, literalsValues, expressionsBodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+    JavaType J_L_STRING_TEMPLATE = new JavaTypeImpl(\"java.lang.StringTemplate\");\n+\n+    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new JavaTypeImpl(\"java.lang.StringTemplate$Processor\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -445,1 +445,2 @@\n-                        Tag.TYPEARRAY);\n+                        Tag.TYPEARRAY,\n+                        Tag.STRING_TEMPLATE);\n@@ -2104,0 +2105,23 @@\n+\n+        @Override\n+        public void visitStringTemplate(JCTree.JCStringTemplate tree) {\n+            Value processorValue = toValue(tree.processor);\n+\n+            List<Value> literalsValues = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n+\n+            List<Body.Builder> expressionsBodies = new ArrayList<>();\n+            tree.expressions.forEach(e -> {\n+                pushBody(e, FunctionType.functionType(typeToTypeElement(e.type)));\n+                append(CoreOps._yield(toValue(e)));\n+                expressionsBodies.add(stack.body);\n+                popBody();\n+            });\n+            result = append(ExtendedOps.stringTemplate(processorValue, literalsValues, expressionsBodies));\n+\/\/            List<Value> expressionsValues = tree.expressions.map(e -> toValue(e));\n+\/\/            Op.Result stringTemplateValue = append(ExtendedOps.stringTemplate(literalsValues, expressionsValues));\n+\/\/            TypeElement processorReturnType = typeToTypeElement(tree.processor.type.allparams().get(0));\n+\/\/            result = append(CoreOps.invoke(\n+\/\/                    MethodDesc.method(JavaType.J_L_STRING_TEMPLATE_PROCESSOR, \"process\", processorReturnType, JavaType.J_L_STRING_TEMPLATE),\n+\/\/                    processorValue, stringTemplateValue));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build StringTemplateTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester StringTemplateTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.StringTemplate.RAW;\n+import static java.lang.StringTemplate.STR;\n+\n+public class StringTemplateTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.String = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.String> = var %5 @\"s\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f(int y) {\n+        String s = STR. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f2\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.StringTemplate = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.StringTemplate> = var %5 @\"st\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f2(int y) {\n+        StringTemplate st = RAW. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f3\" (%0 : int, %1 : int)void -> {\n+                  %2 : Var<int> = var %0 @\"x\";\n+                  %3 : Var<int> = var %1 @\"y\";\n+                  %4 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %5 : java.lang.String = constant @\"x = \";\n+                  %6 : java.lang.String = constant @\"\";\n+                  %7 : java.lang.String = java.stringTemplate %4 %5 %6 ()int -> {\n+                      %8 : int = var.load %2;\n+                      yield %8;\n+                  };\n+                  %9 : Var<java.lang.String> = var %7 @\"s\";\n+                  %10 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %11 : java.lang.String = constant @\"y = \";\n+                  %12 : java.lang.String = constant @\", \";\n+                  %13 : java.lang.String = constant @\"\";\n+                  %14 : java.lang.String = java.stringTemplate %10 %11 %12 %13\n+                      ()int -> {\n+                          %15 : int = var.load %3;\n+                          yield %15;\n+                      }\n+                      ()java.lang.String -> {\n+                          %16 : java.lang.String = var.load %9;\n+                          yield %16;\n+                      };\n+                  %17 : Var<java.lang.String> = var %14 @\"s2\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f3(int x, int y) {\n+        String s = STR.\"x = \\{x}\";\n+        String s2 = STR.\"y = \\{y}, \\{s}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}