{"files":[{"patch":"@@ -1847,1 +1847,2 @@\n-        final String name;\n+        final String varName;\n+        final TypeElement resultType;\n@@ -1862,1 +1863,1 @@\n-        VarOp(OpDefinition def, String name) {\n+        VarOp(OpDefinition def, String varName) {\n@@ -1865,1 +1866,2 @@\n-            this.name = name;\n+            this.varName = varName;\n+            this.resultType = def.resultType();\n@@ -1871,1 +1873,2 @@\n-            this.name = that.name;\n+            this.varName = that.varName;\n+            this.resultType = that.resultType;\n@@ -1880,0 +1883,4 @@\n+            this(varName, init.type(), init);\n+        }\n+\n+        VarOp(String varName, TypeElement type, Value init) {\n@@ -1882,1 +1889,2 @@\n-            this.name = varName;\n+            this.varName = varName;\n+            this.resultType = VarType.varType(type);\n@@ -1887,1 +1895,1 @@\n-            if (name == null) {\n+            if (varName == null) {\n@@ -1892,1 +1900,1 @@\n-            m.put(\"\", name);\n+            m.put(\"\", varName);\n@@ -1897,1 +1905,1 @@\n-            return name;\n+            return varName;\n@@ -1901,1 +1909,1 @@\n-            return operands().get(0).type();\n+            return ((VarType) resultType).valueType();\n@@ -1906,1 +1914,1 @@\n-            return VarType.varType(varType());\n+            return resultType;\n@@ -3471,0 +3479,12 @@\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param type the type of the var's value\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type, Value init) {\n+        return new VarOp(name, type, init);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2734,0 +2734,62 @@\n+    @OpDeclaration(StringTemplateOp.NAME)\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+\n+        public static final String NAME = \"java.stringTemplate\";\n+\n+        private final TypeElement resultType;\n+        private final List<Body> expressions;\n+\n+        public StringTemplateOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expressions = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expressions = that.expressions.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        public StringTemplateOp(TypeElement resultType, Value processorValue, List<Value> literalsValues, List<Body.Builder> expressions) {\n+            \/\/ @@@ update to use statements before super when the compiler can depend on 22 features\n+            super(NAME, makeOperandsList(processorValue, literalsValues));\n+\n+            this.expressions = expressions.stream().map(b -> b.build(this)).toList();\n+            this.resultType = resultType;\n+        }\n+\n+        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n+            List<Value> operands = new ArrayList<>();\n+            operands.add(processorValue);\n+            operands.addAll(literalsValues);\n+            return operands;\n+        }\n+\n+        @Override\n+        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StringTemplateOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return expressions;\n+        }\n+\n+        public Value processor() {\n+            return operands().get(0);\n+        }\n+\n+        public List<Value> fragments() {\n+            return operands().subList(1, operands().size());\n+        }\n+    }\n+\n@@ -3146,0 +3208,15 @@\n+\n+    \/**\n+     * Creates a string template operation.\n+     * @param resultType the result type of the operation\n+     * @param processor the processor\n+     * @param fragments the fragments\n+     * @param expressions the expressions\n+     * @return the string template operation\n+     *\/\n+    public static StringTemplateOp stringTemplate(TypeElement resultType, Value processor,\n+                                                  List<Value> fragments,\n+                                                  List<Body.Builder> expressions) {\n+        return new StringTemplateOp(resultType, processor, fragments, expressions);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+    JavaType J_L_STRING_TEMPLATE = new JavaTypeImpl(\"java.lang.StringTemplate\");\n+\n+    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new JavaTypeImpl(\"java.lang.StringTemplate$Processor\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,1 +440,2 @@\n-                        Tag.TYPEARRAY);\n+                        Tag.TYPEARRAY,\n+                        Tag.STRING_TEMPLATE);\n@@ -679,1 +680,1 @@\n-            result = append(CoreOps.var(tree.name.toString(), initOp));\n+            result = append(CoreOps.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -1161,1 +1162,1 @@\n-                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), init));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n@@ -2136,0 +2137,16 @@\n+\n+        @Override\n+        public void visitStringTemplate(JCTree.JCStringTemplate tree) {\n+            Value processor = toValue(tree.processor);\n+            List<Value> fragments = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n+\n+            List<Body.Builder> expressions = new ArrayList<>();\n+            tree.expressions.forEach(e -> {\n+                pushBody(e, FunctionType.functionType(typeToTypeElement(e.type)));\n+                append(CoreOps._yield(toValue(e)));\n+                expressions.add(stack.body);\n+                popBody();\n+            });\n+            result = append(ExtendedOps.stringTemplate(typeToTypeElement(tree.type), processor, fragments, expressions));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.Op;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Arrays;\n-\n-import static java.lang.reflect.code.op.CoreOps.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.DOUBLE;\n-\n-\/*\n- * @test\n- * @run testng TestOpResultTypeNotCopiedBlindly\n- *\/\n-\n-public class TestOpResultTypeNotCopiedBlindly {\n-\n-    @CodeReflection\n-    static int f(int a, int b) {\n-        return a + b;\n-    }\n-\n-    @Test\n-    void test() {\n-        FuncOp f = getCodeModel(this.getClass(), \"f\");\n-\n-        FuncOp g = func(\"g\", functionType(DOUBLE, DOUBLE, DOUBLE))\n-                .body(b -> b.inline(f, b.parameters(), (block, v) -> {\n-                    block.op(_return(v));\n-                }));\n-\n-        g.writeTo(System.out);\n-\n-        \/\/ check that add has a result-type of double\n-        Assert.assertEquals(\n-                ((Op.Result) g.body().entryBlock().terminatingOp().operands().get(0)).op().result().type(),\n-                DOUBLE\n-        );\n-    }\n-\n-    private static FuncOp getCodeModel(Class<?> c, String methodName) {\n-        return Arrays.stream(c.getDeclaredMethods()).filter(m -> m.getName().equals(methodName))\n-                .findFirst().get().getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpResultTypeNotCopiedBlindly.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build StringTemplateTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester StringTemplateTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.StringTemplate.RAW;\n+import static java.lang.StringTemplate.STR;\n+import static java.util.FormatProcessor.FMT;\n+\n+public class StringTemplateTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.String = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.String> = var %5 @\"s\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f(int y) {\n+        String s = STR. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f2\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.StringTemplate = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.StringTemplate> = var %5 @\"st\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f2(int y) {\n+        StringTemplate st = RAW. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f3\" (%0 : int, %1 : int, %2 : int)void -> {\n+                  %3 : Var<int> = var %0 @\"x\";\n+                  %4 : Var<int> = var %1 @\"y\";\n+                  %5 : Var<int> = var %2 @\"z\";\n+                  %6 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %7 : java.lang.String = constant @\"x = \";\n+                  %8 : java.lang.String = constant @\", z = \";\n+                  %9 : java.lang.String = constant @\", x + z = \";\n+                  %10 : java.lang.String = constant @\"\";\n+                  %11 : java.lang.String = java.stringTemplate %6 %7 %8 %9 %10\n+                      ()int -> {\n+                          %12 : int = var.load %3;\n+                          yield %12;\n+                      }\n+                      ()int -> {\n+                          %13 : int = var.load %5;\n+                          yield %13;\n+                      }\n+                      ()int -> {\n+                          %14 : int = var.load %3;\n+                          %15 : int = var.load %5;\n+                          %16 : int = add %14 %15;\n+                          yield %16;\n+                      };\n+                  %17 : Var<java.lang.String> = var %11 @\"s\";\n+                  %18 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %19 : java.lang.String = constant @\"y = \";\n+                  %20 : java.lang.String = constant @\", \";\n+                  %21 : java.lang.String = constant @\"\";\n+                  %22 : java.lang.String = java.stringTemplate %18 %19 %20 %21\n+                      ()int -> {\n+                          %23 : int = var.load %4;\n+                          yield %23;\n+                      }\n+                      ()java.lang.String -> {\n+                          %24 : java.lang.String = var.load %17;\n+                          yield %24;\n+                      };\n+                  %25 : Var<java.lang.String> = var %22 @\"s2\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f3(int x, int y, int z) {\n+        String s = STR.\"x = \\{x}, z = \\{z}, x + z = \\{x + z}\";\n+        String s2 = STR.\"y = \\{y}, \\{s}\";\n+    }\n+\n+    \/\/ this test will fail for now\n+    \/\/ the reason is wildcard types not modeled\n+    \/\/ the type of the processor X will be java.lang.StringTemplate$Processor\n+    \/\/ but the expected type is java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>\n+\/\/    @CodeReflection\n+\/\/    @IR(\"\"\"\n+\/\/            func @\"f4\" ()void -> {\n+\/\/                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+\/\/                  %1 : Var<java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>> = var %0 @\"X\";\n+\/\/                  %2 : java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException> = var.load %1;\n+\/\/                  %3 : java.lang.String = constant @\"some template\";\n+\/\/                  %4 : java.lang.Object = java.stringTemplate %2 %3;\n+\/\/                  %5 : Var<java.lang.Object> = var %4 @\"o\";\n+\/\/                  return;\n+\/\/            };\n+\/\/            \"\"\")\n+\/\/    static void f4() {\n+\/\/        StringTemplate.Processor<?, RuntimeException> X = STR;\n+\/\/        Object o = X.\"some template\";\n+\/\/    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f5\" (%0 : int, %1 : int)void -> {\n+                  %2 : Var<int> = var %0 @\"x\";\n+                  %3 : Var<int> = var %1 @\"y\";\n+                  %4 : java.util.FormatProcessor = field.load @\"java.util.FormatProcessor::FMT()java.util.FormatProcessor\";\n+                  %5 : java.lang.String = constant @\"%05d\";\n+                  %6 : java.lang.String = constant @\" + %05d\";\n+                  %7 : java.lang.String = constant @\" = %05d\";\n+                  %8 : java.lang.String = constant @\";\";\n+                  %9 : java.lang.String = java.stringTemplate %4 %5 %6 %7 %8\n+                      ()int -> {\n+                          %10 : int = var.load %2;\n+                          yield %10;\n+                      }\n+                      ()int -> {\n+                          %11 : int = var.load %3;\n+                          yield %11;\n+                      }\n+                      ()int -> {\n+                          %12 : int = var.load %2;\n+                          %13 : int = var.load %3;\n+                          %14 : int = add %12 %13;\n+                          yield %14;\n+                      };\n+                  %15 : Var<java.lang.Object> = var %9 @\"s\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void f5(int x, int y) {\n+        Object s = FMT.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y};\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"}]}