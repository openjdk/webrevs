{"files":[{"patch":"@@ -31,3 +31,1 @@\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.type.*;\n@@ -35,1 +33,0 @@\n-import java.lang.reflect.code.type.VarType;\n@@ -3146,0 +3143,66 @@\n+\n+    @OpDeclaration(StringTemplateOp.NAME)\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+\n+        public static final String NAME = \"java.stringTemplate\";\n+\n+        private final List<Body> expressions;\n+\n+        public StringTemplateOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expressions = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expressions = that.expressions.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        public StringTemplateOp(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressions) {\n+            \/\/ @@@ update to use statements before super when the compiler can depend on 22 features\n+            super(NAME, makeOperandsList(processorValue, literalsValues));\n+\n+            this.expressions = expressions.stream().map(b -> b.build(this)).toList();\n+        }\n+\n+        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n+            List<Value> operands = new ArrayList<>();\n+            operands.add(processorValue);\n+            operands.addAll(literalsValues);\n+            return operands;\n+        }\n+\n+        @Override\n+        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StringTemplateOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            if (processor().type() instanceof JavaType t) {\n+                return t.typeArguments().get(0);\n+            }\n+            throw new IllegalStateException(\"processor type is not a java type\");\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return expressions;\n+        }\n+\n+        public Value processor() {\n+            return operands().get(0);\n+        }\n+\n+        public List<Value> fragments() {\n+            return operands().subList(1, operands().size());\n+        }\n+    }\n+\n+    public static StringTemplateOp stringTemplate(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressionsBodies) {\n+        return new StringTemplateOp(processorValue, literalsValues, expressionsBodies);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":67,"deletions":4,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+    JavaType J_L_STRING_TEMPLATE = new JavaTypeImpl(\"java.lang.StringTemplate\");\n+\n+    JavaType J_L_STRING_TEMPLATE_PROCESSOR = new JavaTypeImpl(\"java.lang.StringTemplate$Processor\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -445,1 +445,2 @@\n-                        Tag.TYPEARRAY);\n+                        Tag.TYPEARRAY,\n+                        Tag.STRING_TEMPLATE);\n@@ -2104,0 +2105,17 @@\n+\n+        @Override\n+        public void visitStringTemplate(JCTree.JCStringTemplate tree) {\n+            Value processorValue = toValue(tree.processor);\n+\n+            List<Value> literalsValues = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n+\n+            List<Body.Builder> expressionsBodies = new ArrayList<>();\n+            tree.expressions.forEach(e -> {\n+                pushBody(e, FunctionType.functionType(typeToTypeElement(e.type)));\n+                append(CoreOps._yield(toValue(e)));\n+                expressionsBodies.add(stack.body);\n+                popBody();\n+            });\n+            result = append(ExtendedOps.stringTemplate(processorValue, literalsValues, expressionsBodies));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build StringTemplateTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester StringTemplateTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.StringTemplate.RAW;\n+import static java.lang.StringTemplate.STR;\n+\n+public class StringTemplateTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.String = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.String> = var %5 @\"s\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f(int y) {\n+        String s = STR. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f2\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"y\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException>\";\n+                  %3 : java.lang.String = constant @\"y = \";\n+                  %4 : java.lang.String = constant @\"\";\n+                  %5 : java.lang.StringTemplate = java.stringTemplate %2 %3 %4 ()int -> {\n+                      %6 : int = var.load %1;\n+                      yield %6;\n+                  };\n+                  %7 : Var<java.lang.StringTemplate> = var %5 @\"st\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f2(int y) {\n+        StringTemplate st = RAW. \"y = \\{y}\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f3\" (%0 : int, %1 : int, %2 : int)void -> {\n+                  %3 : Var<int> = var %0 @\"x\";\n+                  %4 : Var<int> = var %1 @\"y\";\n+                  %5 : Var<int> = var %2 @\"z\";\n+                  %6 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %7 : java.lang.String = constant @\"x = \";\n+                  %8 : java.lang.String = constant @\", z = \";\n+                  %9 : java.lang.String = constant @\", x + z = \";\n+                  %10 : java.lang.String = constant @\"\";\n+                  %11 : java.lang.String = java.stringTemplate %6 %7 %8 %9 %10\n+                      ()int -> {\n+                          %12 : int = var.load %3;\n+                          yield %12;\n+                      }\n+                      ()int -> {\n+                          %13 : int = var.load %5;\n+                          yield %13;\n+                      }\n+                      ()int -> {\n+                          %14 : int = var.load %3;\n+                          %15 : int = var.load %5;\n+                          %16 : int = add %14 %15;\n+                          yield %16;\n+                      };\n+                  %17 : Var<java.lang.String> = var %11 @\"s\";\n+                  %18 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %19 : java.lang.String = constant @\"y = \";\n+                  %20 : java.lang.String = constant @\", \";\n+                  %21 : java.lang.String = constant @\"\";\n+                  %22 : java.lang.String = java.stringTemplate %18 %19 %20 %21\n+                      ()int -> {\n+                          %23 : int = var.load %4;\n+                          yield %23;\n+                      }\n+                      ()java.lang.String -> {\n+                          %24 : java.lang.String = var.load %17;\n+                          yield %24;\n+                      };\n+                  %25 : Var<java.lang.String> = var %22 @\"s2\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void f3(int x, int y, int z) {\n+        String s = STR.\"x = \\{x}, z = \\{z}, x + z = \\{x + z}\";\n+        String s2 = STR.\"y = \\{y}, \\{s}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}