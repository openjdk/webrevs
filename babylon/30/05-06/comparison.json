{"files":[{"patch":"@@ -3422,0 +3422,1 @@\n+     * @param type the type of the var's value\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2731,0 +2731,62 @@\n+    @OpDeclaration(StringTemplateOp.NAME)\n+    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n+\n+        public static final String NAME = \"java.stringTemplate\";\n+\n+        private final TypeElement resultType;\n+        private final List<Body> expressions;\n+\n+        public StringTemplateOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expressions = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expressions = that.expressions.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        public StringTemplateOp(TypeElement resultType, Value processorValue, List<Value> literalsValues, List<Body.Builder> expressions) {\n+            \/\/ @@@ update to use statements before super when the compiler can depend on 22 features\n+            super(NAME, makeOperandsList(processorValue, literalsValues));\n+\n+            this.expressions = expressions.stream().map(b -> b.build(this)).toList();\n+            this.resultType = resultType;\n+        }\n+\n+        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n+            List<Value> operands = new ArrayList<>();\n+            operands.add(processorValue);\n+            operands.addAll(literalsValues);\n+            return operands;\n+        }\n+\n+        @Override\n+        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StringTemplateOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return expressions;\n+        }\n+\n+        public Value processor() {\n+            return operands().get(0);\n+        }\n+\n+        public List<Value> fragments() {\n+            return operands().subList(1, operands().size());\n+        }\n+    }\n+\n@@ -3144,67 +3206,12 @@\n-    @OpDeclaration(StringTemplateOp.NAME)\n-    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested {\n-\n-        public static final String NAME = \"java.stringTemplate\";\n-\n-        private final List<Body> expressions;\n-\n-        public StringTemplateOp(OpDefinition def) {\n-            super(def);\n-\n-            this.expressions = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n-        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.expressions = that.expressions.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-        }\n-\n-        public StringTemplateOp(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressions) {\n-            \/\/ @@@ update to use statements before super when the compiler can depend on 22 features\n-            super(NAME, makeOperandsList(processorValue, literalsValues));\n-\n-            this.expressions = expressions.stream().map(b -> b.build(this)).toList();\n-        }\n-\n-        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n-            List<Value> operands = new ArrayList<>();\n-            operands.add(processorValue);\n-            operands.addAll(literalsValues);\n-            return operands;\n-        }\n-\n-        @Override\n-        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n-            return new StringTemplateOp(this, cc, ot);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            TypeElement pt = processor().type();\n-            if (!(pt instanceof JavaType jt)) {\n-                throw new IllegalStateException(\"We expect processor type to be a java type\");\n-            }\n-            if (!jt.hasTypeArguments()) {\n-                throw new IllegalStateException(\"We expect processor type to have arguments, found \" + jt);\n-            }\n-            return jt.typeArguments().get(0);\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return expressions;\n-        }\n-\n-        public Value processor() {\n-            return operands().get(0);\n-        }\n-\n-        public List<Value> fragments() {\n-            return operands().subList(1, operands().size());\n-        }\n-    }\n-\n-    public static StringTemplateOp stringTemplate(Value processorValue, List<Value> literalsValues, List<Body.Builder> expressionsBodies) {\n-        return new StringTemplateOp(processorValue, literalsValues, expressionsBodies);\n+    \/**\n+     * Creates a string template operation.\n+     * @param resultType the result type of the operation\n+     * @param processor the processor\n+     * @param fragments the fragments\n+     * @param expressions the expressions\n+     * @return the string template operation\n+     *\/\n+    public static StringTemplateOp stringTemplate(TypeElement resultType, Value processor,\n+                                                  List<Value> fragments,\n+                                                  List<Body.Builder> expressions) {\n+        return new StringTemplateOp(resultType, processor, fragments, expressions);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":74,"deletions":67,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2109,1 +2109,0 @@\n-\n@@ -2119,1 +2118,1 @@\n-            result = append(ExtendedOps.stringTemplate(processor, fragments, expressions));\n+            result = append(ExtendedOps.stringTemplate(typeToTypeElement(tree.type), processor, fragments, expressions));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static java.util.FormatProcessor.FMT;\n@@ -129,1 +130,18 @@\n-    \/\/ this will cause StringTemplateOp.resultType to fail (which is called during IR generation)\n+    \/\/ but the expected type is java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>\n+\/\/    @CodeReflection\n+\/\/    @IR(\"\"\"\n+\/\/            func @\"f4\" ()void -> {\n+\/\/                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+\/\/                  %1 : Var<java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>> = var %0 @\"X\";\n+\/\/                  %2 : java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException> = var.load %1;\n+\/\/                  %3 : java.lang.String = constant @\"some template\";\n+\/\/                  %4 : java.lang.Object = java.stringTemplate %2 %3;\n+\/\/                  %5 : Var<java.lang.Object> = var %4 @\"o\";\n+\/\/                  return;\n+\/\/            };\n+\/\/            \"\"\")\n+\/\/    static void f4() {\n+\/\/        StringTemplate.Processor<?, RuntimeException> X = STR;\n+\/\/        Object o = X.\"some template\";\n+\/\/    }\n+\n@@ -132,7 +150,24 @@\n-            func @\"f4\" ()void -> {\n-                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n-                  %1 : Var<java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>> = var %0 @\"X\";\n-                  %2 : java.lang.x<java.lang.Object, java.lang.RuntimeException> = var.load %1;\n-                  %3 : java.lang.String = constant @\"some template\";\n-                  %4 : java.lang.Object = java.stringTemplate %2 %3;\n-                  %5 : Var<java.lang.Object> = var %4 @\"o\";\n+            func @\"f5\" (%0 : int, %1 : int)void -> {\n+                  %2 : Var<int> = var %0 @\"x\";\n+                  %3 : Var<int> = var %1 @\"y\";\n+                  %4 : java.util.FormatProcessor = field.load @\"java.util.FormatProcessor::FMT()java.util.FormatProcessor\";\n+                  %5 : java.lang.String = constant @\"%05d\";\n+                  %6 : java.lang.String = constant @\" + %05d\";\n+                  %7 : java.lang.String = constant @\" = %05d\";\n+                  %8 : java.lang.String = constant @\";\";\n+                  %9 : java.lang.String = java.stringTemplate %4 %5 %6 %7 %8\n+                      ()int -> {\n+                          %10 : int = var.load %2;\n+                          yield %10;\n+                      }\n+                      ()int -> {\n+                          %11 : int = var.load %3;\n+                          yield %11;\n+                      }\n+                      ()int -> {\n+                          %12 : int = var.load %2;\n+                          %13 : int = var.load %3;\n+                          %14 : int = add %12 %13;\n+                          yield %14;\n+                      };\n+                  %15 : Var<java.lang.Object> = var %9 @\"s\";\n@@ -142,3 +177,2 @@\n-    static void f4() {\n-        StringTemplate.Processor<?, RuntimeException> X = STR;\n-        Object o = X.\"some template\";\n+    static void f5(int x, int y) {\n+        Object s = FMT.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y};\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"}]}