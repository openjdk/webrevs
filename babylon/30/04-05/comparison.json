{"files":[{"patch":"@@ -1795,1 +1795,2 @@\n-        final String name;\n+        final String varName;\n+        final TypeElement resultType;\n@@ -1810,1 +1811,1 @@\n-        VarOp(OpDefinition def, String name) {\n+        VarOp(OpDefinition def, String varName) {\n@@ -1813,1 +1814,2 @@\n-            this.name = name;\n+            this.varName = varName;\n+            this.resultType = def.resultType();\n@@ -1819,1 +1821,2 @@\n-            this.name = that.name;\n+            this.varName = that.varName;\n+            this.resultType = that.resultType;\n@@ -1828,0 +1831,4 @@\n+            this(varName, init.type(), init);\n+        }\n+\n+        VarOp(String varName, TypeElement type, Value init) {\n@@ -1830,1 +1837,2 @@\n-            this.name = varName;\n+            this.varName = varName;\n+            this.resultType = VarType.varType(type);\n@@ -1835,1 +1843,1 @@\n-            if (name == null) {\n+            if (varName == null) {\n@@ -1840,1 +1848,1 @@\n-            m.put(\"\", name);\n+            m.put(\"\", varName);\n@@ -1845,1 +1853,1 @@\n-            return name;\n+            return varName;\n@@ -1849,1 +1857,1 @@\n-            return operands().get(0).type();\n+            return ((VarType) resultType).valueType();\n@@ -1854,1 +1862,1 @@\n-            return VarType.varType(varType());\n+            return resultType;\n@@ -3410,0 +3418,11 @@\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type, Value init) {\n+        return new VarOp(name, type, init);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3185,2 +3185,3 @@\n-            if (processor().type() instanceof JavaType t) {\n-                return t.typeArguments().get(0);\n+            TypeElement pt = processor().type();\n+            if (!(pt instanceof JavaType jt)) {\n+                throw new IllegalStateException(\"We expect processor type to be a java type\");\n@@ -3188,1 +3189,4 @@\n-            throw new IllegalStateException(\"processor type is not a java type\");\n+            if (!jt.hasTypeArguments()) {\n+                throw new IllegalStateException(\"We expect processor type to have arguments, found \" + jt);\n+            }\n+            return jt.typeArguments().get(0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-            result = append(CoreOps.var(tree.name.toString(), initOp));\n+            result = append(CoreOps.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n@@ -1167,1 +1167,1 @@\n-                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), init));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n@@ -2108,1 +2108,1 @@\n-            Value processorValue = toValue(tree.processor);\n+            Value processor = toValue(tree.processor);\n@@ -2110,1 +2110,1 @@\n-            List<Value> literalsValues = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n+            List<Value> fragments = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n@@ -2112,1 +2112,1 @@\n-            List<Body.Builder> expressionsBodies = new ArrayList<>();\n+            List<Body.Builder> expressions = new ArrayList<>();\n@@ -2116,1 +2116,1 @@\n-                expressionsBodies.add(stack.body);\n+                expressions.add(stack.body);\n@@ -2119,1 +2119,1 @@\n-            result = append(ExtendedOps.stringTemplate(processorValue, literalsValues, expressionsBodies));\n+            result = append(ExtendedOps.stringTemplate(processor, fragments, expressions));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.Op;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Arrays;\n-\n-import static java.lang.reflect.code.op.CoreOps.*;\n-import static java.lang.reflect.code.type.FunctionType.functionType;\n-import static java.lang.reflect.code.type.JavaType.DOUBLE;\n-\n-\/*\n- * @test\n- * @run testng TestOpResultTypeNotCopiedBlindly\n- *\/\n-\n-public class TestOpResultTypeNotCopiedBlindly {\n-\n-    @CodeReflection\n-    static int f(int a, int b) {\n-        return a + b;\n-    }\n-\n-    @Test\n-    void test() {\n-        FuncOp f = getCodeModel(this.getClass(), \"f\");\n-\n-        FuncOp g = func(\"g\", functionType(DOUBLE, DOUBLE, DOUBLE))\n-                .body(b -> b.inline(f, b.parameters(), (block, v) -> {\n-                    block.op(_return(v));\n-                }));\n-\n-        g.writeTo(System.out);\n-\n-        \/\/ check that add has a result-type of double\n-        Assert.assertEquals(\n-                ((Op.Result) g.body().entryBlock().terminatingOp().operands().get(0)).op().result().type(),\n-                DOUBLE\n-        );\n-    }\n-\n-    private static FuncOp getCodeModel(Class<?> c, String methodName) {\n-        return Arrays.stream(c.getDeclaredMethods()).filter(m -> m.getName().equals(methodName))\n-                .findFirst().get().getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpResultTypeNotCopiedBlindly.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -125,0 +125,21 @@\n+\n+    \/\/ this test will fail for now\n+    \/\/ the reason is wildcard types not modeled\n+    \/\/ the type of the processor X will be java.lang.StringTemplate$Processor\n+    \/\/ this will cause StringTemplateOp.resultType to fail (which is called during IR generation)\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"f4\" ()void -> {\n+                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %1 : Var<java.lang.StringTemplate$Processor<java.lang.Object, java.lang.RuntimeException>> = var %0 @\"X\";\n+                  %2 : java.lang.x<java.lang.Object, java.lang.RuntimeException> = var.load %1;\n+                  %3 : java.lang.String = constant @\"some template\";\n+                  %4 : java.lang.Object = java.stringTemplate %2 %3;\n+                  %5 : Var<java.lang.Object> = var %4 @\"o\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void f4() {\n+        StringTemplate.Processor<?, RuntimeException> X = STR;\n+        Object o = X.\"some template\";\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}