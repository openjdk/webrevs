{"files":[{"patch":"@@ -404,1 +404,1 @@\n-        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op());\n+        FuncOpWrapper f = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,kernelCallGraph.entrypoint.funcOpWrapper().op);\n@@ -424,1 +424,1 @@\n-                FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n+                FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op);\n@@ -447,1 +447,1 @@\n-        return FuncOpWrapper.wrap(func.lookup,func.op().transform((block, op) -> {\n+        return FuncOpWrapper.wrap(func.lookup,func.op.transform((block, op) -> {\n@@ -464,3 +464,3 @@\n-                } else if (invokeOpWrapper.op().invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n-                        && mathFns.containsKey(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString())){\n-                    usedMathFns.add(invokeOpWrapper.op().invokeDescriptor().name() + \"_\" + invokeOpWrapper.resultType().toString());\n+                } else if (invokeOpWrapper.op.invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n+                        && mathFns.containsKey(invokeOpWrapper.op.invokeDescriptor().name() + \"_\" + invokeOpWrapper.op.resultType().toString())){\n+                    usedMathFns.add(invokeOpWrapper.op.invokeDescriptor().name() + \"_\" + invokeOpWrapper.op.resultType().toString());\n@@ -483,1 +483,1 @@\n-        builder.functionHeader(lowered.functionName(), entry, lowered.op().body().yieldType());\n+        builder.functionHeader(lowered.functionName(), entry, lowered.op.body().yieldType());\n@@ -492,1 +492,1 @@\n-        ssa.firstBody().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n+        ssa.op.bodies().getFirst().blocks().forEach(block -> builder.blockBody(block, block.ops().stream().map(o->OpWrapper.wrap(lowered.lookup,o))));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.codebuilders.HATCodeBuilderContext;\n@@ -108,1 +109,1 @@\n-    public CudaHATKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext, JavaType javaType, String name) {\n+    public CudaHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, String name) {\n@@ -119,1 +120,1 @@\n-    public CudaHATKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public CudaHATKernelBuilder atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n@@ -121,1 +122,1 @@\n-             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+             ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-                switch (wrappedOp.op()){\n+                switch (wrappedOp.op){\n@@ -243,2 +243,2 @@\n-    public void fieldLoad(FieldLoadOpWrapper op) {\n-        if (op.fieldName().equals(Field.KC_X.toString())) {\n+    public void fieldLoad(FieldLoadOpWrapper wop) {\n+        if (wop.fieldName().equals(Field.KC_X.toString())) {\n@@ -246,1 +246,1 @@\n-                loadKcX(op.result());\n+                loadKcX(wop.op.result());\n@@ -248,1 +248,1 @@\n-                mov().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n+                mov().u32().space().resultReg(wop, PTXRegister.Type.U32).commaSpace().fieldReg(Field.KC_X);\n@@ -250,1 +250,1 @@\n-        } else if (op.fieldName().equals(Field.KC_MAXX.toString())) {\n+        } else if (wop.fieldName().equals(Field.KC_MAXX.toString())) {\n@@ -252,1 +252,1 @@\n-                loadKcX(op.operandNAsValue(0));\n+                loadKcX(wop.op.operands().getFirst());\n@@ -254,1 +254,1 @@\n-            ld().global().u32().space().fieldReg(Field.KC_MAXX, op.result()).commaSpace()\n+            ld().global().u32().space().fieldReg(Field.KC_MAXX, wop.op.result()).commaSpace()\n@@ -257,1 +257,1 @@\n-            ld().global().u32().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n+            ld().global().u32().space().resultReg(wop, PTXRegister.Type.U64).commaSpace().reg(wop.op.operands().getFirst());\n@@ -274,1 +274,1 @@\n-        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0));\n+        st().global().u64().space().resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.op.operands().getFirst());\n@@ -300,3 +300,3 @@\n-        symbol(op.op());\n-        if (getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n-                && (op.op() instanceof JavaOp.DivOp || op.op() instanceof JavaOp.MulOp)) {\n+        symbol(op.op);\n+        if (getResultType(op.op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && (op.op instanceof JavaOp.DivOp || op.op instanceof JavaOp.MulOp)) {\n@@ -304,2 +304,2 @@\n-        } else if (!getResultType(op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n-                && op.op() instanceof JavaOp.MulOp) {\n+        } else if (!getResultType(op.op.resultType()).getBasicType().equals(PTXRegister.Type.BasicType.FLOATING)\n+                && op.op instanceof JavaOp.MulOp) {\n@@ -308,2 +308,2 @@\n-        resultType(op.resultType(), true).space();\n-        resultReg(op, getResultType(op.resultType()));\n+        resultType(op.op.resultType(), true).space();\n+        resultReg(op, getResultType(op.op.resultType()));\n@@ -311,1 +311,1 @@\n-        reg(op.operandNAsValue(0));\n+        reg(op.op.operands().getFirst());\n@@ -313,1 +313,1 @@\n-        reg(op.operandNAsValue(1));\n+        reg(op.op.operands().get(1));\n@@ -318,1 +318,1 @@\n-        symbol(op.op()).resultType(op.operandNAsValue(0).type(), true).space();\n+        symbol(op.op).resultType(op.op.operands().getFirst().type(), true).space();\n@@ -321,1 +321,1 @@\n-        reg(op.operandNAsValue(0));\n+        reg(op.op.operands().getFirst());\n@@ -323,1 +323,1 @@\n-        reg(op.operandNAsValue(1));\n+        reg(op.op.operands().get(1));\n@@ -330,1 +330,1 @@\n-                        .reg(op.operandNAsValue(0)).commaSpace().intVal(4);\n+                        .reg(op.op.operands().getFirst()).commaSpace().intVal(4);\n@@ -332,2 +332,2 @@\n-                cvt().u64().dot().regType(op.operandNAsValue(0)).space()\n-                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n+                cvt().u64().dot().regType(op.op.operands().getFirst()).space()\n+                        .resultReg(op, PTXRegister.Type.U64).commaSpace().reg(op.op.operands().getFirst()).ptxNl();\n@@ -336,2 +336,2 @@\n-            cvt().rn().f32().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.operandNAsValue(0));\n+            cvt().rn().f32().dot().regType(op.op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.F32).commaSpace().reg(op.op.operands().getFirst());\n@@ -340,1 +340,1 @@\n-            if (op.operandNAsValue(0).type().equals(JavaType.INT)) {\n+            if (op.op.operands().getFirst().type().equals(JavaType.INT)) {\n@@ -343,2 +343,2 @@\n-            f64().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0));\n+            f64().dot().regType(op.op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.op.operands().getFirst());\n@@ -347,1 +347,1 @@\n-            if (op.operandNAsValue(0).type().equals(JavaType.DOUBLE) || op.operandNAsValue(0).type().equals(JavaType.FLOAT)) {\n+            if (op.op.operands().getFirst().type().equals(JavaType.DOUBLE) || op.op.operands().getFirst().type().equals(JavaType.FLOAT)) {\n@@ -352,2 +352,2 @@\n-            s32().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n+            s32().dot().regType(op.op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.op.operands().getFirst());\n@@ -355,2 +355,2 @@\n-            cvt().rn().s32().dot().regType(op.operandNAsValue(0)).space()\n-                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.operandNAsValue(0));\n+            cvt().rn().s32().dot().regType(op.op.operands().getFirst()).space()\n+                    .resultReg(op, PTXRegister.Type.S32).commaSpace().reg(op.op.operands().getFirst());\n@@ -445,1 +445,1 @@\n-        for (Op.Result r : op.result().uses()) {\n+        for (Op.Result r : op.op.result().uses()) {\n@@ -452,3 +452,3 @@\n-        mov().resultType(op.resultType(), false).space().resultReg(op, getResultType(op.resultType())).commaSpace();\n-        if (op.resultType().toString().equals(\"float\")) {\n-            if (op.op().value().toString().equals(\"0.0\")) {\n+        mov().resultType(op.op.resultType(), false).space().resultReg(op, getResultType(op.op.resultType())).commaSpace();\n+        if (op.op.resultType().toString().equals(\"float\")) {\n+            if (op.op.value().toString().equals(\"0.0\")) {\n@@ -457,1 +457,1 @@\n-                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op().value().toString()))).toUpperCase());\n+                floatVal(Integer.toHexString(Float.floatToIntBits(Float.parseFloat(op.op.value().toString()))).toUpperCase());\n@@ -460,1 +460,1 @@\n-            append(op.op().value().toString());\n+            append(op.op.value().toString());\n@@ -474,1 +474,1 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n+                add().s64().space().regName(temp).commaSpace().reg(op.op.operands().getFirst()).commaSpace().reg(op.op.operands().get(1)).ptxNl();\n@@ -479,2 +479,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.operandNAsValue(2));\n+                add().s64().space().regName(temp).commaSpace().reg(op.op.operands().getFirst()).commaSpace().reg(op.op.operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 4).commaSpace().reg(op.op.operands().get(2));\n@@ -483,1 +483,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.op.operands().getFirst()).name());\n@@ -488,2 +488,2 @@\n-                add().s64().space().regName(temp).commaSpace().reg(op.operandNAsValue(0)).commaSpace().reg(op.operandNAsValue(1)).ptxNl();\n-                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.operandNAsValue(2));\n+                add().s64().space().regName(temp).commaSpace().reg(op.op.operands().getFirst()).commaSpace().reg(op.op.operands().get(1)).ptxNl();\n+                st().global().u32().space().address(temp.name(), 8).commaSpace().reg(op.op.operands().get(2));\n@@ -492,1 +492,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name());\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.op.operands().getFirst()).name());\n@@ -495,1 +495,1 @@\n-                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.operandNAsValue(0)).name(), 4);\n+                ld().global().u32().space().resultReg(op, PTXRegister.Type.U32).commaSpace().address(getReg(op.op.operands().getFirst()).name(), 4);\n@@ -499,1 +499,1 @@\n-                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.operandNAsValue(0)).semicolon();\n+                sqrt().rn().f64().space().resultReg(op, PTXRegister.Type.F64).commaSpace().reg(op.op.operands().getFirst()).semicolon();\n@@ -503,3 +503,3 @@\n-                for (int i = 0; i < op.operands().size(); i++) {\n-                    dot().param().space().paramType(op.operandNAsValue(i).type()).space().param().intVal(i).ptxNl();\n-                    st().dot().param().paramType(op.operandNAsValue(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.operandNAsValue(i)).ptxNl();\n+                for (int i = 0; i < op.op.operands().size(); i++) {\n+                    dot().param().space().paramType(op.op.operands().get(i).type()).space().param().intVal(i).ptxNl();\n+                    st().dot().param().paramType(op.op.operands().get(i).type()).space().osbrace().param().intVal(i).csbrace().commaSpace().reg(op.op.operands().get(i)).ptxNl();\n@@ -507,1 +507,1 @@\n-                dot().param().space().paramType(op.resultType()).space().retVal().ptxNl();\n+                dot().param().space().paramType(op.op.resultType()).space().retVal().ptxNl();\n@@ -510,2 +510,2 @@\n-                paren(_ -> commaSeparated(op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n-                ld().dot().param().paramType(op.resultType()).space().resultReg(op, getResultType(op.resultType())).commaSpace().osbrace().retVal().csbrace();\n+                paren(_ -> commaSeparated(op.op.operands(), _ -> param().intVal(counter[0]++))).ptxNl();\n+                ld().dot().param().paramType(op.op.resultType()).space().resultReg(op, getResultType(op.op.resultType())).commaSpace().osbrace().retVal().csbrace();\n@@ -518,1 +518,1 @@\n-        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n+        ld().dot().param().resultType(op.op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.op.operands().getFirst());\n@@ -522,1 +522,1 @@\n-        ld().dot().param().resultType(op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.operandNAsValue(0));\n+        ld().dot().param().resultType(op.op.resultType(), false).space().resultReg(op, addressType()).commaSpace().reg(op.op.operands().getFirst());\n@@ -526,1 +526,1 @@\n-        if (op.hasOperands()) {\n+        if (!op.op.operands().isEmpty()) {\n@@ -535,1 +535,1 @@\n-            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.operandNAsValue(0)).ptxNl();\n+            space().osbrace().regName(returnReg).csbrace().commaSpace().reg(op.op.operands().getFirst()).ptxNl();\n@@ -610,1 +610,1 @@\n-        return append(addReg(opWrapper.result(), type));\n+        return append(addReg(opWrapper.op.result(), type));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.codebuilders.HATCodeBuilderContext;\n@@ -88,1 +89,1 @@\n-    public OpenCLHATKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext, JavaType type, String name) {\n+    public OpenCLHATKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, String name) {\n@@ -98,1 +99,1 @@\n-    public OpenCLHATKernelBuilder atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name){\n+    public OpenCLHATKernelBuilder atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n@@ -100,1 +101,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n+            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op.toText());\n@@ -166,1 +166,1 @@\n-            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n+            System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op.toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op(), args);\n+            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op, args);\n@@ -82,1 +82,1 @@\n-                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op());\n+                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op);\n@@ -86,1 +86,1 @@\n-                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op().toText());\n+                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op.toText());\n@@ -96,1 +96,1 @@\n-        bldr.op(iow.op());\n+        bldr.op(iow.op);\n@@ -148,1 +148,1 @@\n-                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n@@ -150,1 +150,1 @@\n-                    bldr.op(invokeOW.op());                         \/\/ iface.v(newV);\n+                    bldr.op(invokeOW.op);                         \/\/ iface.v(newV);\n@@ -162,1 +162,1 @@\n-                System.out.println(returnFOW.op().toText());\n+                System.out.println(returnFOW.op.toText());\n@@ -169,1 +169,1 @@\n-                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n@@ -171,1 +171,1 @@\n-                    bldr.op(invokeOW.op());                         \/\/ iface.v(newV);\n+                    bldr.op(invokeOW.op);                         \/\/ iface.v(newV);\n@@ -174,1 +174,1 @@\n-                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n@@ -176,1 +176,1 @@\n-                    bldr.op(invokeOW.op());                         \/\/ iface.v();\n+                    bldr.op(invokeOW.op);                         \/\/ iface.v();\n@@ -179,1 +179,1 @@\n-                    bldr.op(invokeOW.op());\n+                    bldr.op(invokeOW.op);\n@@ -181,1 +181,1 @@\n-                    List<Value> list = invokeOW.op().operands();\n+                    List<Value> list = invokeOW.op.operands();\n@@ -212,1 +212,1 @@\n-                        bldr.op(invokeOW.op());\n+                        bldr.op(invokeOW.op);\n@@ -225,1 +225,1 @@\n-                        bldr.op(invokeOW.op());\n+                        bldr.op(invokeOW.op);\n@@ -232,1 +232,1 @@\n-                System.out.println(returnFOW.op().toText());\n+                System.out.println(returnFOW.op.toText());\n@@ -237,1 +237,1 @@\n-                System.out.println(returnFOW.op().toText());\n+                System.out.println(returnFOW.op.toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.codebuilders.HATCodeBuilderContext;\n@@ -86,1 +87,1 @@\n-    public OpenCLHatKernelBuilder functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType type, String name) {\n+    public OpenCLHatKernelBuilder functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType type, String name) {\n@@ -96,1 +97,1 @@\n-    public OpenCLHatKernelBuilder atomicInc(CodeBuilderContext buildContext,  Op.Result instanceResult, String name){\n+    public OpenCLHatKernelBuilder atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name){\n@@ -98,1 +99,1 @@\n-              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+              ampersand().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op().toText());\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().op.toText());\n@@ -101,1 +101,1 @@\n-        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op().toText());\n+        System.out.println(kernelCallGraph.entrypoint.funcOpWrapper().lower().op.toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op(), args);\n+            Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op, args);\n@@ -75,1 +75,1 @@\n-                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op());\n+                    computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op);\n@@ -79,1 +79,1 @@\n-                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op().toText());\n+                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op.toText());\n@@ -87,1 +87,1 @@\n-        bldr.op(iow.op());\n+        bldr.op(iow.op);\n@@ -97,1 +97,1 @@\n-            System.out.println(returnFOW.op().toText());\n+            System.out.println(returnFOW.op.toText());\n@@ -103,1 +103,1 @@\n-                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n@@ -105,1 +105,1 @@\n-                    bldr.op(invokeOW.op());                         \/\/ iface.v(newV);\n+                    bldr.op(invokeOW.op);                         \/\/ iface.v(newV);\n@@ -108,1 +108,1 @@\n-                    Value iface = bldrCntxt.getValue(invokeOW.operandNAsValue(0));\n+                    Value iface = bldrCntxt.getValue(invokeOW.op.operands().getFirst());\n@@ -110,1 +110,1 @@\n-                    bldr.op(invokeOW.op());                         \/\/ iface.v();\n+                    bldr.op(invokeOW.op);                         \/\/ iface.v();\n@@ -113,1 +113,1 @@\n-                    bldr.op(invokeOW.op());\n+                    bldr.op(invokeOW.op);\n@@ -115,1 +115,1 @@\n-                    invokeOW.op().operands().stream()\n+                    invokeOW.op.operands().stream()\n@@ -120,2 +120,2 @@\n-                    bldr.op(invokeOW.op());\n-                    invokeOW.op().operands().stream()\n+                    bldr.op(invokeOW.op);\n+                    invokeOW.op.operands().stream()\n@@ -131,1 +131,1 @@\n-            System.out.println(returnFOW.op().toText());\n+            System.out.println(returnFOW.op.toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-                        && invokeOpWrapper.hasOperands()\n+                        && !invokeOpWrapper.op.operands().isEmpty()\n@@ -139,1 +139,1 @@\n-                    if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n+                    if (invokeOpWrapper.op.operands().size() == 1) {                  \/\/ No args (operand(0)==containing iface))\n@@ -153,1 +153,1 @@\n-                    } else if (invokeOpWrapper.operandCount() == 2) {\n+                    } else if (invokeOpWrapper.op.operands().size() == 2) {\n@@ -161,1 +161,1 @@\n-                            Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n+                            Value valueToStore = builder.context().getValue(invokeOpWrapper.op.operands().get(1));\n","filename":"hat\/core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op(), args);\n+                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op, args);\n@@ -81,1 +81,1 @@\n-                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op());\n+                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op);\n@@ -85,1 +85,1 @@\n-                    System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op().toText());\n+                    System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op.toText());\n@@ -113,1 +113,1 @@\n-                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered.op(), args);\n+                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered.op, args);\n@@ -118,1 +118,1 @@\n-                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered.op());\n+                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered.op);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -150,0 +151,3 @@\n+        computeReachableResolvedMethodCall.funcOpWrapper().op.traverse(null, (map, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                var invokeWrapper = (InvokeOpWrapper) OpWrapper.wrap(computeReachableResolvedMethodCall.funcOpWrapper().lookup,invokeOp);\n@@ -151,0 +155,52 @@\n+                MethodRef methodRef = invokeWrapper.methodRef();\n+                Class<?> javaRefClass = invokeWrapper.javaRefClass().orElseThrow();\n+                Method invokeWrapperCalledMethod = invokeWrapper.method();\n+                if (Buffer.class.isAssignableFrom(javaRefClass)) {\n+                    \/\/ System.out.println(\"iface mapped buffer call  -> \" + methodRef);\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                            new ComputeReachableIfaceMappedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    ));\n+                } else if (Accelerator.class.isAssignableFrom(javaRefClass)) {\n+                    \/\/ System.out.println(\"call on the accelerator (must be through the computeContext) -> \" + methodRef);\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                            new ComputeReachableAcceleratorMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    ));\n+\n+                } else if (ComputeContext.class.isAssignableFrom(javaRefClass)) {\n+                    \/\/ System.out.println(\"call on the computecontext -> \" + methodRef);\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                            new ComputeContextMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    ));\n+                } else if (entrypoint.method.getDeclaringClass().equals(javaRefClass)) {\n+                    Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeWrapperCalledMethod);\n+                    if (optionalFuncOp.isPresent()) {\n+                        FuncOpWrapper fow = OpWrapper.wrap(computeContext.accelerator.lookup, optionalFuncOp.get());\n+                        if (isKernelDispatch(invokeWrapperCalledMethod, fow)) {\n+                            \/\/ System.out.println(\"A kernel reference (not a direct call) to a kernel \" + methodRef);\n+                            kernelCallGraphMap.computeIfAbsent(methodRef, _ ->\n+                                    new KernelCallGraph(this, methodRef, invokeWrapperCalledMethod, fow).close()\n+                            );\n+                        } else {\n+                            \/\/ System.out.println(\"A call to a method on the compute class which we have code model for \" + methodRef);\n+                            computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                                    new OtherComputeReachableResolvedMethodCall(this, methodRef, invokeWrapperCalledMethod, fow)\n+                            ));\n+                        }\n+                    } else {\n+                        \/\/  System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n+                        computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                                new ComputeReachableUnresolvedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                        ));\n+                    }\n+                } else {\n+                    \/\/TODO what about ifacenestings?\n+                    \/\/ System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n+                    computeReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                            new ComputeReachableUnresolvedMethodCall(this, methodRef, invokeWrapperCalledMethod)\n+                    ));\n+                }\n+              \/\/  consumer.accept(wrap(lookup,invokeOp));\n+            }\n+            return map;\n+        });\n+        \/*\n@@ -200,1 +256,1 @@\n-\n+*\/\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -95,20 +96,9 @@\n-     \/*   kernelReachableResolvedMethodCall.funcOpWrapper().selectAssignments(varOpWrapper -> {\n-            if (varOpWrapper.isIfaceAssignment()){\n-                \/\/ We might be aliasing a buffer which is 'frowned upon'\n-                System.out.println(\"Kernel appears to be aliasing a buffer  \" + varOpWrapper.javaType() + \" name \" + varOpWrapper.varName());\n-                System.out.println(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Yep\");\n-            }\n-        }); *\/\n-        kernelReachableResolvedMethodCall.funcOpWrapper().selectCalls(invokeOpWrapper -> {\n-            MethodRef methodRef = invokeOpWrapper.methodRef();\n-            Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n-            Method invokeOpCalledMethod = invokeOpWrapper.method();\n-            if (Buffer.class.isAssignableFrom(javaRefTypeClass)) {\n-                \/\/System.out.println(\"kernel reachable iface mapped buffer call  -> \" + methodRef);\n-                kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                        new KernelReachableUnresolvedIfaceMappedMethodCall(this, methodRef, invokeOpCalledMethod)\n-                ));\n-            } else if (entrypoint.method.getDeclaringClass().equals(javaRefTypeClass)) {\n-                Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeOpCalledMethod);\n-                if (optionalFuncOp.isPresent()) {\n-                    \/\/System.out.println(\"A call to a method on the kernel class which we have code model for \" + methodRef);\n+\n+        kernelReachableResolvedMethodCall.funcOpWrapper().op.traverse(null, (map, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                var invokeOpWrapper = (InvokeOpWrapper)OpWrapper.wrap(  kernelReachableResolvedMethodCall.funcOpWrapper().lookup,invokeOp);\n+                MethodRef methodRef = invokeOpWrapper.methodRef();\n+                Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n+                Method invokeOpCalledMethod = invokeOpWrapper.method();\n+                if (Buffer.class.isAssignableFrom(javaRefTypeClass)) {\n+                    \/\/System.out.println(\"kernel reachable iface mapped buffer call  -> \" + methodRef);\n@@ -116,2 +106,15 @@\n-                            new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(computeContext.accelerator.lookup,optionalFuncOp.get())\n-                            )));\n+                            new KernelReachableUnresolvedIfaceMappedMethodCall(this, methodRef, invokeOpCalledMethod)\n+                    ));\n+                } else if (entrypoint.method.getDeclaringClass().equals(javaRefTypeClass)) {\n+                    Optional<CoreOp.FuncOp> optionalFuncOp = Op.ofMethod(invokeOpCalledMethod);\n+                    if (optionalFuncOp.isPresent()) {\n+                        \/\/System.out.println(\"A call to a method on the kernel class which we have code model for \" + methodRef);\n+                        kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                                new KernelReachableResolvedMethodCall(this, methodRef, invokeOpCalledMethod, OpWrapper.wrap(computeContext.accelerator.lookup,optionalFuncOp.get())\n+                                )));\n+                    } else {\n+                        \/\/ System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n+                        kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                                new KernelReachableUnresolvedMethodCall(this, methodRef, invokeOpCalledMethod)\n+                        ));\n+                    }\n@@ -119,1 +122,1 @@\n-                    \/\/ System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n+                    \/\/  System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n@@ -123,0 +126,1 @@\n+                    \/\/ System.out.println(\"Were we expecting \" + methodRef + \" here \");\n@@ -124,6 +128,0 @@\n-            } else {\n-                \/\/  System.out.println(\"A call to a method on the compute class which we DO NOT have code model for \" + methodRef);\n-                kernelReachableResolvedMethodCall.addCall(methodRefToMethodCallMap.computeIfAbsent(methodRef, _ ->\n-                        new KernelReachableUnresolvedMethodCall(this, methodRef, invokeOpCalledMethod)\n-                ));\n-                \/\/ System.out.println(\"Were we expecting \" + methodRef + \" here \");\n@@ -131,1 +129,1 @@\n-\n+            return map;\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(funcOpWrapper.lookup,funcOpWrapper);\n@@ -49,1 +49,1 @@\n-                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.firstBlockOfFirstBody()).forEach(root ->\n+                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.op.bodies().getFirst().entryBlock()).forEach(root ->\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,2 +156,2 @@\n-    public T type(CodeBuilderContext buildContext, JavaType javaType) {\n-        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup(),javaType) && javaType instanceof ClassType classType) {\n+    public T type(HATCodeBuilderContext buildContext, JavaType javaType) {\n+        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n@@ -184,1 +184,1 @@\n-        CodeBuilderContext buildContext = new CodeBuilderContext(kernelReachableResolvedMethodCall.funcOpWrapper());\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelReachableResolvedMethodCall.funcOpWrapper().lookup,kernelReachableResolvedMethodCall.funcOpWrapper());\n@@ -205,1 +205,1 @@\n-        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(funcOpWrapper.lookup,funcOpWrapper);\n@@ -227,1 +227,1 @@\n-        CodeBuilderContext buildContext = new CodeBuilderContext(kernelEntrypoint.funcOpWrapper());\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(kernelEntrypoint.funcOpWrapper().lookup,kernelEntrypoint.funcOpWrapper());\n@@ -266,1 +266,1 @@\n-    public abstract T functionDeclaration(CodeBuilderContext codeBuilderContext,JavaType javaType, String name);\n+    public abstract T functionDeclaration(HATCodeBuilderContext codeBuilderContext, JavaType javaType, String name);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import hat.optools.FuncOpWrapper;\n@@ -55,1 +54,0 @@\n-import jdk.incubator.code.Block;\n@@ -57,1 +55,0 @@\n-import jdk.incubator.code.Value;\n@@ -60,1 +57,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -62,2 +58,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -284,1 +278,1 @@\n-    public static interface CodeBuilderInterface<T extends HATCodeBuilderWithContext<?>> {\n+    public  interface CodeBuilderInterface<T extends HATCodeBuilderWithContext<?>> {\n@@ -287,1 +281,1 @@\n-         T varLoad(CodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper);\n+         T varLoad(HATCodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper);\n@@ -289,1 +283,1 @@\n-         T varStore(CodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper);\n+         T varStore(HATCodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper);\n@@ -293,1 +287,1 @@\n-         T varDeclaration(CodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper);\n+         T varDeclaration(HATCodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper);\n@@ -295,1 +289,1 @@\n-         T varFuncDeclaration(CodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper);\n+         T varFuncDeclaration(HATCodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper);\n@@ -297,1 +291,1 @@\n-         T fieldLoad(CodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper);\n+         T fieldLoad(HATCodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper);\n@@ -299,1 +293,1 @@\n-         T fieldStore(CodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper);\n+         T fieldStore(HATCodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper);\n@@ -301,1 +295,1 @@\n-        T unaryOperation(CodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper);\n+        T unaryOperation(HATCodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper);\n@@ -304,1 +298,1 @@\n-        T binaryOperation(CodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper);\n+        T binaryOperation(HATCodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper);\n@@ -306,1 +300,1 @@\n-        T logical(CodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper);\n+        T logical(HATCodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper);\n@@ -308,1 +302,1 @@\n-        T binaryTest(CodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper);\n+        T binaryTest(HATCodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper);\n@@ -310,1 +304,1 @@\n-        T conv(CodeBuilderContext buildContext, ConvOpWrapper convOpWrapper);\n+        T conv(HATCodeBuilderContext buildContext, ConvOpWrapper convOpWrapper);\n@@ -313,1 +307,1 @@\n-        T constant(CodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper);\n+        T constant(HATCodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper);\n@@ -315,1 +309,1 @@\n-        T javaYield(CodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper);\n+        T javaYield(HATCodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper);\n@@ -317,1 +311,1 @@\n-        T lambda(CodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper);\n+        T lambda(HATCodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper);\n@@ -319,1 +313,1 @@\n-        T tuple(CodeBuilderContext buildContext, TupleOpWrapper lambdaOpWrapper);\n+        T tuple(HATCodeBuilderContext buildContext, TupleOpWrapper lambdaOpWrapper);\n@@ -321,1 +315,1 @@\n-        T funcCall(CodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper);\n+        T funcCall(HATCodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper);\n@@ -323,1 +317,1 @@\n-        T javaIf(CodeBuilderContext buildContext, IfOpWrapper ifOpWrapper);\n+        T javaIf(HATCodeBuilderContext buildContext, IfOpWrapper ifOpWrapper);\n@@ -325,1 +319,1 @@\n-        T javaWhile(CodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper);\n+        T javaWhile(HATCodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper);\n@@ -327,1 +321,1 @@\n-        T javaLabeled(CodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapperOp);\n+        T javaLabeled(HATCodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapperOp);\n@@ -329,1 +323,1 @@\n-        T javaContinue(CodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper);\n+        T javaContinue(HATCodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper);\n@@ -331,1 +325,1 @@\n-        T javaBreak(CodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper);\n+        T javaBreak(HATCodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper);\n@@ -333,1 +327,1 @@\n-        T javaFor(CodeBuilderContext buildContext, ForOpWrapper forOpWrapper);\n+        T javaFor(HATCodeBuilderContext buildContext, ForOpWrapper forOpWrapper);\n@@ -336,1 +330,1 @@\n-         T methodCall(CodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper);\n+         T methodCall(HATCodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper);\n@@ -338,1 +332,1 @@\n-         T ternary(CodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper);\n+         T ternary(HATCodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper);\n@@ -340,1 +334,1 @@\n-         T parencedence(CodeBuilderContext buildContext, Op parent, OpWrapper<?> child);\n+         T parencedence(HATCodeBuilderContext buildContext, Op parent, OpWrapper<?> child);\n@@ -342,1 +336,1 @@\n-         T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n+         T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child);\n@@ -344,1 +338,1 @@\n-         T parencedence(CodeBuilderContext buildContext,  Op parent, Op child);\n+         T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child);\n@@ -346,1 +340,1 @@\n-         T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, Op child);\n+         T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, Op child);\n@@ -348,1 +342,1 @@\n-         T ret(CodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper);\n+         T ret(HATCodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper);\n@@ -350,1 +344,1 @@\n-        default T recurse(CodeBuilderContext buildContext, OpWrapper<?> wrappedOp) {\n+        default T recurse(HATCodeBuilderContext buildContext, OpWrapper<?> wrappedOp) {\n@@ -373,1 +367,0 @@\n-\n@@ -378,1 +371,1 @@\n-                default -> throw new IllegalStateException(\"handle nesting of op \" + wrappedOp.op());\n+                default -> throw new IllegalStateException(\"handle nesting of op \" + wrappedOp.op);\n@@ -386,213 +379,0 @@\n-    public static class CodeBuilderContext {\n-        public MethodHandles.Lookup lookup(){\n-            return funcOpWrapper.lookup;\n-        }\n-        public static class Scope<OW extends OpWrapper<?>> {\n-            final Scope<?> parent;\n-            final OW opWrapper;\n-\n-            public Scope(Scope<?> parent, OW opWrapper) {\n-                this.parent = parent;\n-                this.opWrapper = opWrapper;\n-            }\n-\n-            public CoreOp.VarOp resolve(Value value) {\n-                if (value instanceof Op.Result result && result.op() instanceof CoreOp.VarOp varOp) {\n-                    return varOp;\n-                }\n-                if (parent != null) {\n-                    return parent.resolve(value);\n-                }\n-                throw new IllegalStateException(\"failed to resolve VarOp for value \" + value);\n-            }\n-        }\n-\n-        public static class FuncScope extends Scope<FuncOpWrapper> {\n-            FuncScope(Scope<?> parent, FuncOpWrapper funcOpWrapper) {\n-                super(parent, funcOpWrapper);\n-            }\n-\n-            @Override\n-            public CoreOp.VarOp resolve(Value value) {\n-                if (value instanceof Block.Parameter blockParameter) {\n-                    if (opWrapper.parameterVarOpMap.containsKey(blockParameter)) {\n-                        return opWrapper.parameterVarOpMap.get(blockParameter);\n-                    } else {\n-                        throw new IllegalStateException(\"what ?\");\n-                    }\n-                } else {\n-                    return super.resolve(value);\n-                }\n-            }\n-        }\n-\n-        public static abstract class LoopScope<T extends OpWrapper<?>> extends Scope<T> {\n-\n-            public LoopScope(Scope<?> parent, T opWrapper) {\n-                super(parent, opWrapper);\n-            }\n-        }\n-\n-\n-        public  static class ForScope extends LoopScope<ForOpWrapper> {\n-            Map<Block.Parameter, CoreOp.VarOp> blockParamToVarOpMap = new HashMap<>();\n-\n-            ForOpWrapper forOpWrapper() {\n-                return opWrapper;\n-            }\n-\n-            ForScope(Scope<?> parent, ForOpWrapper forOpWrapper) {\n-                super(parent, forOpWrapper);\n-                var loopParams = forOpWrapper().op().loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-                var updateParams = forOpWrapper().op().update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-                var condParams = forOpWrapper().op().cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n-                var lastInitOp = forOpWrapper().op().init().entryBlock().ops().getLast();\n-                var lastInitOpOperand0Result = (Op.Result) lastInitOp.operands().getFirst();\n-                var lastInitOpOperand0ResultOp = lastInitOpOperand0Result.op();\n-                CoreOp.VarOp varOps[];\n-                if (lastInitOpOperand0ResultOp instanceof CoreOp.TupleOp tupleOp) {\n-                     \/*\n-                     for (int j = 1, i=2, k=3; j < size; k+=1,i+=2,j+=3) {\n-                        float sum = k+i+j;\n-                     }\n-                     java.for\n-                     ()Tuple<Var<int>, Var<int>, Var<int>> -> {\n-                         %0 : int = constant @\"1\";\n-                         %1 : Var<int> = var %0 @\"j\";\n-                         %2 : int = constant @\"2\";\n-                         %3 : Var<int> = var %2 @\"i\";\n-                         %4 : int = constant @\"3\";\n-                         %5 : Var<int> = var %4 @\"k\";\n-                         %6 : Tuple<Var<int>, Var<int>, Var<int>> = tuple %1 %3 %5;\n-                         yield %6;\n-                     }\n-                     (%7 : Var<int>, %8 : Var<int>, %9 : Var<int>)boolean -> {\n-                         %10 : int = var.load %7;\n-                         %11 : int = var.load %12;\n-                         %13 : boolean = lt %10 %11;\n-                         yield %13;\n-                     }\n-                     (%14 : Var<int>, %15 : Var<int>, %16 : Var<int>)void -> {\n-                         %17 : int = var.load %16;\n-                         %18 : int = constant @\"1\";\n-                         %19 : int = add %17 %18;\n-                         var.store %16 %19;\n-                         %20 : int = var.load %15;\n-                         %21 : int = constant @\"2\";\n-                         %22 : int = add %20 %21;\n-                         var.store %15 %22;\n-                         %23 : int = var.load %14;\n-                         %24 : int = constant @\"3\";\n-                         %25 : int = add %23 %24;\n-                         var.store %14 %25;\n-                         yield;\n-                     }\n-                     (%26 : Var<int>, %27 : Var<int>, %28 : Var<int>)void -> {\n-                         %29 : int = var.load %28;\n-                         %30 : int = var.load %27;\n-                         %31 : int = add %29 %30;\n-                         %32 : int = var.load %26;\n-                         %33 : int = add %31 %32;\n-                         %34 : float = conv %33;\n-                         %35 : Var<float> = var %34 @\"sum\";\n-                         java.continue;\n-                     };\n-                     *\/\n-                    varOps = tupleOp.operands().stream().map(operand -> (CoreOp.VarOp) (((Op.Result) operand).op())).toList().toArray(new CoreOp.VarOp[0]);\n-                } else {\n-                     \/*\n-                     for (int j = 0; j < size; j+=1) {\n-                        float sum = j;\n-                     }\n-                     java.for\n-                        ()Var<int> -> {\n-                            %0 : int = constant @\"0\";\n-                            %1 : Var<int> = var %0 @\"j\";\n-                            yield %1;\n-                        }\n-                        (%2 : Var<int>)boolean -> {\n-                            %3 : int = var.load %2;\n-                            %4 : int = var.load %5;\n-                            %6 : boolean = lt %3 %4;\n-                            yield %6;\n-                        }\n-                        (%7 : Var<int>)void -> {\n-                            %8 : int = var.load %7;\n-                            %9 : int = constant @\"1\";\n-                            %10 : int = add %8 %9;\n-                            var.store %7 %10;\n-                            yield;\n-                        }\n-                        (%11 : Var<int>)void -> {\n-                            %12 : int = var.load %11;\n-                            %13 : float = conv %12;\n-                            %14 : Var<float> = var %13 @\"sum\";\n-                            java.continue;\n-                        };\n-\n-                     *\/\n-                    varOps = new CoreOp.VarOp[]{(CoreOp.VarOp) lastInitOpOperand0ResultOp};\n-                }\n-                for (int i = 0; i < varOps.length; i++) {\n-                    blockParamToVarOpMap.put(condParams[i], varOps[i]);\n-                    blockParamToVarOpMap.put(updateParams[i], varOps[i]);\n-                    blockParamToVarOpMap.put(loopParams[i], varOps[i]);\n-                }\n-            }\n-\n-\n-            @Override\n-            public CoreOp.VarOp resolve(Value value) {\n-                if (value instanceof Block.Parameter blockParameter) {\n-                    CoreOp.VarOp varOp = this.blockParamToVarOpMap.get(blockParameter);\n-                    if (varOp != null) {\n-                        return varOp;\n-                    }\n-                }\n-                return super.resolve(value);\n-            }\n-        }\n-\n-        public static class IfScope extends Scope<IfOpWrapper> {\n-            IfScope(Scope<?> parent, IfOpWrapper opWrapper) {\n-                super(parent, opWrapper);\n-            }\n-        }\n-\n-        public static class WhileScope extends LoopScope<WhileOpWrapper> {\n-            WhileScope(Scope<?> parent, WhileOpWrapper opWrapper) {\n-                super(parent, opWrapper);\n-            }\n-\n-        }\n-\n-        public Scope<?> scope = null;\n-\n-        private void popScope() {\n-            scope = scope.parent;\n-        }\n-\n-        private void pushScope(OpWrapper<?> opWrapper) {\n-            scope = switch (opWrapper) {\n-                case FuncOpWrapper $ -> new FuncScope(scope, $);\n-                case ForOpWrapper $ -> new ForScope(scope, $);\n-                case IfOpWrapper $ -> new IfScope(scope, $);\n-                case WhileOpWrapper $ -> new WhileScope(scope, $);\n-                default -> new Scope<>(scope, opWrapper);\n-            };\n-        }\n-\n-        public void scope(OpWrapper<?> opWrapper, Runnable r) {\n-            pushScope(opWrapper);\n-            r.run();\n-            popScope();\n-        }\n-\n-        public  FuncOpWrapper funcOpWrapper;\n-\n-        public CodeBuilderContext(FuncOpWrapper funcOpWrapper) {\n-            this.funcOpWrapper = funcOpWrapper;\n-        }\n-\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":32,"deletions":252,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.codebuilders;\n+\n+import hat.optools.ForOpWrapper;\n+import hat.optools.FuncOpWrapper;\n+import hat.optools.IfOpWrapper;\n+import hat.optools.OpWrapper;\n+import hat.optools.WhileOpWrapper;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class HATCodeBuilderContext {\n+  \/\/  public MethodHandles.Lookup lookup() {\n+    \/\/    return funcOpWrapper.lookup;\n+    \/\/}\n+\n+    public static class Scope<OW extends OpWrapper<?>> {\n+        final Scope<?> parent;\n+        final OW opWrapper;\n+\n+        public Scope(Scope<?> parent, OW opWrapper) {\n+            this.parent = parent;\n+            this.opWrapper = opWrapper;\n+        }\n+\n+        public CoreOp.VarOp resolve(Value value) {\n+            if (value instanceof Op.Result result && result.op() instanceof CoreOp.VarOp varOp) {\n+                return varOp;\n+            }\n+            if (parent != null) {\n+                return parent.resolve(value);\n+            }\n+            throw new IllegalStateException(\"failed to resolve VarOp for value \" + value);\n+        }\n+    }\n+\n+    public static class FuncScope extends Scope<FuncOpWrapper> {\n+        FuncScope(Scope<?> parent, FuncOpWrapper funcOpWrapper) {\n+            super(parent, funcOpWrapper);\n+        }\n+\n+        @Override\n+        public CoreOp.VarOp resolve(Value value) {\n+            if (value instanceof Block.Parameter blockParameter) {\n+                if (opWrapper.parameterVarOpMap.containsKey(blockParameter)) {\n+                    return opWrapper.parameterVarOpMap.get(blockParameter);\n+                } else {\n+                    throw new IllegalStateException(\"what ?\");\n+                }\n+            } else {\n+                return super.resolve(value);\n+            }\n+        }\n+    }\n+\n+    public static abstract class LoopScope<T extends OpWrapper<?>> extends Scope<T> {\n+\n+        public LoopScope(Scope<?> parent, T opWrapper) {\n+            super(parent, opWrapper);\n+        }\n+    }\n+\n+\n+    public static class ForScope extends LoopScope<ForOpWrapper> {\n+        Map<Block.Parameter, CoreOp.VarOp> blockParamToVarOpMap = new HashMap<>();\n+\n+        ForOpWrapper forOpWrapper() {\n+            return opWrapper;\n+        }\n+\n+        ForScope(Scope<?> parent, ForOpWrapper forOpWrapper) {\n+            super(parent, forOpWrapper);\n+            var loopParams = forOpWrapper.op.loopBody().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var updateParams = forOpWrapper.op.update().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var condParams = forOpWrapper.op.cond().entryBlock().parameters().toArray(new Block.Parameter[0]);\n+            var lastInitOp = forOpWrapper.op.init().entryBlock().ops().getLast();\n+            var lastInitOpOperand0Result = (Op.Result) lastInitOp.operands().getFirst();\n+            var lastInitOpOperand0ResultOp = lastInitOpOperand0Result.op();\n+            CoreOp.VarOp varOps[];\n+            if (lastInitOpOperand0ResultOp instanceof CoreOp.TupleOp tupleOp) {\n+                 \/*\n+                 for (int j = 1, i=2, k=3; j < size; k+=1,i+=2,j+=3) {\n+                    float sum = k+i+j;\n+                 }\n+                 java.for\n+                 ()Tuple<Var<int>, Var<int>, Var<int>> -> {\n+                     %0 : int = constant @\"1\";\n+                     %1 : Var<int> = var %0 @\"j\";\n+                     %2 : int = constant @\"2\";\n+                     %3 : Var<int> = var %2 @\"i\";\n+                     %4 : int = constant @\"3\";\n+                     %5 : Var<int> = var %4 @\"k\";\n+                     %6 : Tuple<Var<int>, Var<int>, Var<int>> = tuple %1 %3 %5;\n+                     yield %6;\n+                 }\n+                 (%7 : Var<int>, %8 : Var<int>, %9 : Var<int>)boolean -> {\n+                     %10 : int = var.load %7;\n+                     %11 : int = var.load %12;\n+                     %13 : boolean = lt %10 %11;\n+                     yield %13;\n+                 }\n+                 (%14 : Var<int>, %15 : Var<int>, %16 : Var<int>)void -> {\n+                     %17 : int = var.load %16;\n+                     %18 : int = constant @\"1\";\n+                     %19 : int = add %17 %18;\n+                     var.store %16 %19;\n+                     %20 : int = var.load %15;\n+                     %21 : int = constant @\"2\";\n+                     %22 : int = add %20 %21;\n+                     var.store %15 %22;\n+                     %23 : int = var.load %14;\n+                     %24 : int = constant @\"3\";\n+                     %25 : int = add %23 %24;\n+                     var.store %14 %25;\n+                     yield;\n+                 }\n+                 (%26 : Var<int>, %27 : Var<int>, %28 : Var<int>)void -> {\n+                     %29 : int = var.load %28;\n+                     %30 : int = var.load %27;\n+                     %31 : int = add %29 %30;\n+                     %32 : int = var.load %26;\n+                     %33 : int = add %31 %32;\n+                     %34 : float = conv %33;\n+                     %35 : Var<float> = var %34 @\"sum\";\n+                     java.continue;\n+                 };\n+                 *\/\n+                varOps = tupleOp.operands().stream().map(operand -> (CoreOp.VarOp) (((Op.Result) operand).op())).toList().toArray(new CoreOp.VarOp[0]);\n+            } else {\n+                 \/*\n+                 for (int j = 0; j < size; j+=1) {\n+                    float sum = j;\n+                 }\n+                 java.for\n+                    ()Var<int> -> {\n+                        %0 : int = constant @\"0\";\n+                        %1 : Var<int> = var %0 @\"j\";\n+                        yield %1;\n+                    }\n+                    (%2 : Var<int>)boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = var.load %5;\n+                        %6 : boolean = lt %3 %4;\n+                        yield %6;\n+                    }\n+                    (%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    (%11 : Var<int>)void -> {\n+                        %12 : int = var.load %11;\n+                        %13 : float = conv %12;\n+                        %14 : Var<float> = var %13 @\"sum\";\n+                        java.continue;\n+                    };\n+\n+                 *\/\n+                varOps = new CoreOp.VarOp[]{(CoreOp.VarOp) lastInitOpOperand0ResultOp};\n+            }\n+            for (int i = 0; i < varOps.length; i++) {\n+                blockParamToVarOpMap.put(condParams[i], varOps[i]);\n+                blockParamToVarOpMap.put(updateParams[i], varOps[i]);\n+                blockParamToVarOpMap.put(loopParams[i], varOps[i]);\n+            }\n+        }\n+\n+\n+        @Override\n+        public CoreOp.VarOp resolve(Value value) {\n+            if (value instanceof Block.Parameter blockParameter) {\n+                CoreOp.VarOp varOp = this.blockParamToVarOpMap.get(blockParameter);\n+                if (varOp != null) {\n+                    return varOp;\n+                }\n+            }\n+            return super.resolve(value);\n+        }\n+    }\n+\n+    public static class IfScope extends Scope<IfOpWrapper> {\n+        IfScope(Scope<?> parent, IfOpWrapper opWrapper) {\n+            super(parent, opWrapper);\n+        }\n+    }\n+\n+    public static class WhileScope extends LoopScope<WhileOpWrapper> {\n+        WhileScope(Scope<?> parent, WhileOpWrapper opWrapper) {\n+            super(parent, opWrapper);\n+        }\n+\n+    }\n+\n+    public Scope<?> scope = null;\n+\n+    private void popScope() {\n+        scope = scope.parent;\n+    }\n+\n+    private void pushScope(OpWrapper<?> opWrapper) {\n+        scope = switch (opWrapper) {\n+            case FuncOpWrapper $ -> new FuncScope(scope, $);\n+            case ForOpWrapper $ -> new ForScope(scope, $);\n+            case IfOpWrapper $ -> new IfScope(scope, $);\n+            case WhileOpWrapper $ -> new WhileScope(scope, $);\n+            default -> new Scope<>(scope, opWrapper);\n+        };\n+    }\n+\n+    public void scope(OpWrapper<?> opWrapper, Runnable r) {\n+        pushScope(opWrapper);\n+        r.run();\n+        popScope();\n+    }\n+    public MethodHandles.Lookup lookup;\n+    public FuncOpWrapper funcOpWrapper;\n+\n+    public HATCodeBuilderContext(MethodHandles.Lookup lookup,FuncOpWrapper funcOpWrapper) {\n+        this.lookup = lookup;\n+        this.funcOpWrapper = funcOpWrapper;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderContext.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -139,2 +139,2 @@\n-    public T type(CodeBuilderContext buildContext,JavaType javaType) {\n-        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup(),javaType) && javaType instanceof ClassType classType) {\n+    public T type(HATCodeBuilderContext buildContext, JavaType javaType) {\n+        if (InvokeOpWrapper.isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n@@ -158,2 +158,2 @@\n-    public T varLoad(CodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper) {\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varAccessOpWrapper.operandNAsValue(0));\n+    public T varLoad(HATCodeBuilderContext buildContext, VarLoadOpWrapper varAccessOpWrapper) {\n+        CoreOp.VarOp varOp = buildContext.scope.resolve(varAccessOpWrapper.op.operands().getFirst());\n@@ -165,2 +165,2 @@\n-    public T varStore(CodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper) {\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varAccessOpWrapper.operandNAsValue(0));\n+    public T varStore(HATCodeBuilderContext buildContext, VarStoreOpWrapper varAccessOpWrapper) {\n+        CoreOp.VarOp varOp = buildContext.scope.resolve(varAccessOpWrapper.op.operands().getFirst());\n@@ -168,1 +168,1 @@\n-        parencedence(buildContext, varAccessOpWrapper, varAccessOpWrapper.operandNAsResult(1).op());\n+        parencedence(buildContext, varAccessOpWrapper, ((Op.Result)varAccessOpWrapper.op.operands().get(1)).op());\n@@ -173,2 +173,2 @@\n-    public T varDeclaration(CodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) {\n-        if (varDeclarationOpWrapper.op().isUninitialized()) {\n+    public T varDeclaration(HATCodeBuilderContext buildContext, VarDeclarationOpWrapper varDeclarationOpWrapper) {\n+        if (varDeclarationOpWrapper.op.isUninitialized()) {\n@@ -179,1 +179,1 @@\n-            parencedence(buildContext, varDeclarationOpWrapper, varDeclarationOpWrapper.operandNAsResult(0).op());\n+            parencedence(buildContext, varDeclarationOpWrapper, ((Op.Result)varDeclarationOpWrapper.op.operands().getFirst()).op());\n@@ -185,1 +185,1 @@\n-    public T varFuncDeclaration(CodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper) {\n+    public T varFuncDeclaration(HATCodeBuilderContext buildContext, VarFuncDeclarationOpWrapper varFuncDeclarationOpWrapper) {\n@@ -191,1 +191,1 @@\n-    public T fieldLoad(CodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n+    public T fieldLoad(HATCodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n@@ -204,1 +204,1 @@\n-    public T fieldStore(CodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper) {\n+    public T fieldStore(HATCodeBuilderContext buildContext, FieldStoreOpWrapper fieldStoreOpWrapper) {\n@@ -238,1 +238,1 @@\n-    public T unaryOperation(CodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper) {\n+    public T unaryOperation(HATCodeBuilderContext buildContext, UnaryArithmeticOrLogicOpWrapper unaryOperatorOpWrapper) {\n@@ -240,2 +240,2 @@\n-        symbol(unaryOperatorOpWrapper.op());\n-        parencedence(buildContext, unaryOperatorOpWrapper.op(), unaryOperatorOpWrapper.operandNAsResult(0).op());\n+        symbol(unaryOperatorOpWrapper.op);\n+        parencedence(buildContext, unaryOperatorOpWrapper.op, ((Op.Result)unaryOperatorOpWrapper.op.operands().getFirst()).op());\n@@ -246,4 +246,4 @@\n-    public T binaryOperation(CodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper) {\n-        parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.lhsAsOp());\n-        symbol(binaryOperatorOpWrapper.op());\n-        parencedence(buildContext, binaryOperatorOpWrapper.op(), binaryOperatorOpWrapper.rhsAsOp());\n+    public T binaryOperation(HATCodeBuilderContext buildContext, BinaryArithmeticOrLogicOperation binaryOperatorOpWrapper) {\n+        parencedence(buildContext, binaryOperatorOpWrapper.op, binaryOperatorOpWrapper.lhsAsOp());\n+        symbol(binaryOperatorOpWrapper.op);\n+        parencedence(buildContext, binaryOperatorOpWrapper.op, binaryOperatorOpWrapper.rhsAsOp());\n@@ -254,1 +254,1 @@\n-    public T logical(CodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper) {\n+    public T logical(HATCodeBuilderContext buildContext, LogicalOpWrapper logicalOpWrapper) {\n@@ -258,1 +258,1 @@\n-        space().symbol(logicalOpWrapper.op()).space();\n+        space().symbol(logicalOpWrapper.op).space();\n@@ -266,4 +266,4 @@\n-    public T binaryTest(CodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper) {\n-        parencedence(buildContext, binaryTestOpWrapper.op(), binaryTestOpWrapper.lhsAsOp());\n-        symbol(binaryTestOpWrapper.op());\n-        parencedence(buildContext, binaryTestOpWrapper.op(), binaryTestOpWrapper.rhsAsOp());\n+    public T binaryTest(HATCodeBuilderContext buildContext, BinaryTestOpWrapper binaryTestOpWrapper) {\n+        parencedence(buildContext, binaryTestOpWrapper.op, binaryTestOpWrapper.lhsAsOp());\n+        symbol(binaryTestOpWrapper.op);\n+        parencedence(buildContext, binaryTestOpWrapper.op, binaryTestOpWrapper.rhsAsOp());\n@@ -275,1 +275,1 @@\n-    public T conv(CodeBuilderContext buildContext, ConvOpWrapper convOpWrapper) {\n+    public T conv(HATCodeBuilderContext buildContext, ConvOpWrapper convOpWrapper) {\n@@ -281,2 +281,1 @@\n-        \/\/paren(() -> type(convOpWrapper.resultJavaType()));\n-        parencedence(buildContext, convOpWrapper, convOpWrapper.operandNAsResult(0).op());\n+        parencedence(buildContext, convOpWrapper, ((Op.Result)convOpWrapper.op.operands().getFirst()).op());\n@@ -287,2 +286,2 @@\n-    public T constant(CodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper) {\n-        Object object = constantOpWrapper.op().value();\n+    public T constant(HATCodeBuilderContext buildContext, ConstantOpWrapper constantOpWrapper) {\n+        Object object = constantOpWrapper.op.value();\n@@ -292,1 +291,1 @@\n-            literal(constantOpWrapper.op().value().toString());\n+            literal(constantOpWrapper.op.value().toString());\n@@ -298,6 +297,3 @@\n-    public T javaYield(CodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper) {\n-        var operand0 = yieldOpWrapper.operandNAsValue(0);\n-        if (operand0 instanceof Op.Result result) {\n-            recurse(buildContext, OpWrapper.wrap(buildContext.lookup(), result.op()));\n-        } else {\n-            \/\/ append(\"\/*nothing to yield*\/\");\n+    public T javaYield(HATCodeBuilderContext buildContext, YieldOpWrapper yieldOpWrapper) {\n+        if (yieldOpWrapper.op.operands().getFirst() instanceof Op.Result result) {\n+            recurse(buildContext, OpWrapper.wrap(buildContext.lookup, result.op()));\n@@ -309,1 +305,1 @@\n-    public T lambda(CodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper) {\n+    public T lambda(HATCodeBuilderContext buildContext, LambdaOpWrapper lambdaOpWrapper) {\n@@ -314,2 +310,2 @@\n-    public T tuple(CodeBuilderContext buildContext, TupleOpWrapper tupleOpWrapper) {\n-        StreamCounter.of(tupleOpWrapper.operands(), (c, operand) -> {\n+    public T tuple(HATCodeBuilderContext buildContext, TupleOpWrapper tupleOpWrapper) {\n+        StreamCounter.of(tupleOpWrapper.op.operands(), (c, operand) -> {\n@@ -320,1 +316,1 @@\n-                recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result.op()));\n+                recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result.op()));\n@@ -329,1 +325,1 @@\n-    public T funcCall(CodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper) {\n+    public T funcCall(HATCodeBuilderContext buildContext, FuncCallOpWrapper funcCallOpWrapper) {\n@@ -332,3 +328,3 @@\n-            commaSeparated(funcCallOpWrapper.operands(), (e) -> {\n-                if (e instanceof Op.Result r) {\n-                    parencedence(buildContext, funcCallOpWrapper, r.op());\n+            commaSeparated(funcCallOpWrapper.op.operands(), (e) -> {\n+                if (e instanceof Op.Result result) {\n+                    parencedence(buildContext, funcCallOpWrapper, result.op());\n@@ -344,3 +340,3 @@\n-    public T javaLabeled(CodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapper) {\n-        var labelNameOp = OpWrapper.wrap(buildContext.lookup(),javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(0));\n-        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp.op();\n+    public T javaLabeled(HATCodeBuilderContext buildContext, JavaLabeledOpWrapper javaLabeledOpWrapper) {\n+        var labelNameOp = OpWrapper.wrap(buildContext.lookup,javaLabeledOpWrapper.op.bodies().getFirst().entryBlock().ops().getFirst());\n+        CoreOp.ConstantOp constantOp = (CoreOp.ConstantOp) labelNameOp.op;\n@@ -348,2 +344,2 @@\n-        var forLoopOp = javaLabeledOpWrapper.firstBlockOfFirstBody().ops().get(1);\n-        recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),forLoopOp));\n+        var forLoopOp = javaLabeledOpWrapper.op.bodies().getFirst().entryBlock().ops().get(1);\n+        recurse(buildContext, OpWrapper.wrap(buildContext.lookup,forLoopOp));\n@@ -354,1 +350,1 @@\n-    public T javaBreak(CodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper) {\n+    public T javaBreak(HATCodeBuilderContext buildContext, JavaBreakOpWrapper javaBreakOpWrapper) {\n@@ -356,1 +352,1 @@\n-        if (javaBreakOpWrapper.hasOperands() && javaBreakOpWrapper.operandNAsResult(0) instanceof Op.Result result) {\n+        if (!javaBreakOpWrapper.op.operands().isEmpty() && javaBreakOpWrapper.op.operands().getFirst() instanceof Op.Result result) {\n@@ -365,3 +361,3 @@\n-    public T javaContinue(CodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper) {\n-        if (javaContinueOpWrapper.hasOperands()\n-                && javaContinueOpWrapper.operandNAsResult(0) instanceof Op.Result result\n+    public T javaContinue(HATCodeBuilderContext buildContext, JavaContinueOpWrapper javaContinueOpWrapper) {\n+        if (!javaContinueOpWrapper.op.operands().isEmpty()\n+                && javaContinueOpWrapper.op.operands().getFirst() instanceof Op.Result result\n@@ -371,1 +367,1 @@\n-        } else if (buildContext.scope.parent instanceof CodeBuilderContext.LoopScope<?>) {\n+        } else if (buildContext.scope.parent instanceof HATCodeBuilderContext.LoopScope<?>) {\n@@ -381,1 +377,1 @@\n-    public T javaIf(CodeBuilderContext buildContext, IfOpWrapper ifOpWrapper) {\n+    public T javaIf(HATCodeBuilderContext buildContext, IfOpWrapper ifOpWrapper) {\n@@ -384,1 +380,1 @@\n-            StreamCounter.of(ifOpWrapper.bodies(), (c, b) -> {\n+            StreamCounter.of(ifOpWrapper.op.bodies(), (c, b) -> {\n@@ -391,1 +387,4 @@\n-                                StreamCounter.of(ifOpWrapper.wrappedRootOpStream(ifOpWrapper.firstBlockOfBodyN(c.value())), (innerc, root) ->\n+                                StreamCounter.of(ifOpWrapper.wrappedRootOpStream(\n+                                        ifOpWrapper.op.bodies().get(c.value()).entryBlock())\n+                                        \/\/ifOpWrapper.firstBlockOfBodyN(c.value()))\n+                                        , (innerc, root) ->\n@@ -403,1 +402,4 @@\n-                            ifOpWrapper.wrappedYieldOpStream(ifOpWrapper.firstBlockOfBodyN(c.value())).forEach((wrapped) ->\n+                            ifOpWrapper.wrappedYieldOpStream(\n+                                    ifOpWrapper.op.bodies().get(c.value()).entryBlock())\n+                            \/\/        ifOpWrapper.firstBlockOfBodyN(c.value()))\n+                            .forEach((wrapped) ->\n@@ -415,1 +417,1 @@\n-    public T javaWhile(CodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper) {\n+    public T javaWhile(HATCodeBuilderContext buildContext, WhileOpWrapper whileOpWrapper) {\n@@ -427,1 +429,1 @@\n-    public T javaFor(CodeBuilderContext buildContext, ForOpWrapper forOpWrapper) {\n+    public T javaFor(HATCodeBuilderContext buildContext, ForOpWrapper forOpWrapper) {\n@@ -526,1 +528,1 @@\n-    public T atomicInc(CodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n+    public T atomicInc(HATCodeBuilderContext buildContext, Op.Result instanceResult, String name) {\n@@ -531,1 +533,1 @@\n-    public T methodCall(CodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n+    public T methodCall(HATCodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n@@ -535,1 +537,1 @@\n-            var operandCount = invokeOpWrapper.operandCount();\n+            var operandCount = invokeOpWrapper.op.operands().size();\n@@ -541,1 +543,1 @@\n-                if (invokeOpWrapper.operandNAsResult(0) instanceof Op.Result instanceResult) {\n+                if (invokeOpWrapper.op.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -551,1 +553,1 @@\n-                if (invokeOpWrapper.operandNAsResult(0) instanceof Op.Result instanceResult) {\n+                if (invokeOpWrapper.op.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -598,1 +600,1 @@\n-                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),instanceResult.op()));\n+                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup,instanceResult.op()));\n@@ -607,2 +609,2 @@\n-                                if (invokeOpWrapper.operandNAsResult(1) instanceof Op.Result result1) {\n-                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result1.op()));\n+                                if (invokeOpWrapper.op.operands().get(1) instanceof Op.Result result1) {\n+                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result1.op()));\n@@ -615,4 +617,4 @@\n-                                if (invokeOpWrapper.operandNAsResult(1) instanceof Op.Result result1\n-                                        && invokeOpWrapper.operandNAsResult(2) instanceof Op.Result result2) {\n-                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result1.op())));\n-                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result2.op()));\n+                                if (invokeOpWrapper.op.operands().get(1) instanceof Op.Result result1\n+                                        && invokeOpWrapper.op.operands().get(2) instanceof Op.Result result2) {\n+                                    sbrace(_ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result1.op())));\n+                                    equals().recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result2.op()));\n@@ -629,2 +631,2 @@\n-                        if (invokeOpWrapper.operandNAsResult(1) instanceof Op.Result result1) {\n-                            var rhs = OpWrapper.wrap(buildContext.lookup(),result1.op());\n+                        if (invokeOpWrapper.op.operands().size()>1 && invokeOpWrapper.op.operands().get(1) instanceof Op.Result result1) {\n+                            var rhs = OpWrapper.wrap(buildContext.lookup,result1.op());\n@@ -643,1 +645,1 @@\n-                    commaSeparated(invokeOpWrapper.operands(), (op) -> {\n+                    commaSeparated(invokeOpWrapper.op.operands(), (op) -> {\n@@ -645,1 +647,1 @@\n-                            recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),result.op()));\n+                            recurse(buildContext, OpWrapper.wrap(buildContext.lookup,result.op()));\n@@ -656,1 +658,1 @@\n-    public T ternary(CodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper) {\n+    public T ternary(HATCodeBuilderContext buildContext, TernaryOpWrapper ternaryOpWrapper) {\n@@ -674,2 +676,2 @@\n-    public T parencedence(CodeBuilderContext buildContext, Op parent, OpWrapper<?> child) {\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child.op()), _ -> recurse(buildContext, child));\n+    public T parencedence(HATCodeBuilderContext buildContext, Op parent, OpWrapper<?> child) {\n+        return parenWhen(precedenceOf(parent) < precedenceOf(child.op), _ -> recurse(buildContext, child));\n@@ -678,2 +680,3 @@\n-    public T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child) {\n-        return parenWhen(precedenceOf(parent.op()) < precedenceOf(child.op()), _ -> recurse(buildContext, child));\n+    @Override\n+    public T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, OpWrapper<?> child) {\n+        return parenWhen(precedenceOf(parent.op) < precedenceOf(child.op), _ -> recurse(buildContext, child));\n@@ -681,3 +684,4 @@\n-@Override\n-    public T parencedence(CodeBuilderContext buildContext,  Op parent, Op child) {\n-        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),child)));\n+\n+    @Override\n+    public T parencedence(HATCodeBuilderContext buildContext, Op parent, Op child) {\n+        return parenWhen(precedenceOf(parent) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup,child)));\n@@ -686,2 +690,3 @@\n-    public T parencedence(CodeBuilderContext buildContext, OpWrapper<?> parent, Op child) {\n-        return parenWhen(precedenceOf(parent.op()) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup(),child)));\n+    @Override\n+    public T parencedence(HATCodeBuilderContext buildContext, OpWrapper<?> parent, Op child) {\n+        return parenWhen(precedenceOf(parent.op) < precedenceOf(child), _ -> recurse(buildContext, OpWrapper.wrap(buildContext.lookup,child)));\n@@ -692,1 +697,1 @@\n-    public T ret(CodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper) {\n+    public T ret(HATCodeBuilderContext buildContext, ReturnOpWrapper returnOpWrapper) {\n@@ -694,2 +699,2 @@\n-        if (returnOpWrapper.hasOperands()) {\n-            space().parencedence(buildContext, returnOpWrapper, returnOpWrapper.operandNAsResult(0).op());\n+        if (!returnOpWrapper.op.operands().isEmpty()) {\n+            space().parencedence(buildContext, returnOpWrapper, ((Op.Result)returnOpWrapper.op.operands().getFirst()).op());\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":97,"deletions":92,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        return operandNAsResult(0).op();\n+        return ((Op.Result)op.operands().getFirst()).op();\n@@ -41,1 +41,1 @@\n-        return operandNAsResult(1).op();\n+        return  ((Op.Result)op.operands().get(1)).op();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BinaryOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,9 +43,0 @@\n-    public static void onlyBlock(Body body, Consumer<BlockWrapper> blockWrapperConsumer) {\n-        blockWrapperConsumer.accept(new BlockWrapper(body.entryBlock()));\n-    }\n-\n-    public void onlyBlock(Consumer<BlockWrapper> blockWrapperConsumer) {\n-        onlyBlock(body(), blockWrapperConsumer);\n-    }\n-\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BodyWrapper.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        return (JavaType) op().resultType();\n+        return (JavaType) op.resultType();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ConvOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-      return hasNoOperands() && resultType() instanceof PrimitiveType;\n+      return op.operands().isEmpty() && op.result().type() instanceof PrimitiveType;\n@@ -53,1 +53,1 @@\n-        return op().fieldDescriptor();\n+        return op.fieldDescriptor();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FieldAccessOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(0));\n+        return wrappedYieldOpStream(op.bodies().getFirst().entryBlock()\/*firstBlockOfBodyN(0)*\/);\n@@ -43,1 +43,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(1));\n+        return wrappedYieldOpStream(op.bodies().get(1).entryBlock()\/*firstBlockOfBodyN(1)*\/);\n@@ -47,1 +47,1 @@\n-        return wrappedRootOpStream(firstBlockOfBodyN(2));\n+        return wrappedRootOpStream(op.bodies().get(2).entryBlock()\/*firstBlockOfBodyN(2)*\/);\n@@ -52,1 +52,1 @@\n-        return wrappedRootOpStreamSansFinalContinue(firstBlockOfBodyN(3));\n+        return wrappedRootOpStreamSansFinalContinue(op.bodies().get(3).entryBlock()\/*firstBlockOfBodyN(3)*\/);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ForOpWrapper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        return op().funcName();\n+        return op.funcName();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncCallOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        return (JavaType) op().body().yieldType();\n+        return (JavaType) op.body().yieldType();\n@@ -172,1 +172,1 @@\n-        op().parameters().forEach(parameter -> {\n+        op.parameters().forEach(parameter -> {\n@@ -193,1 +193,1 @@\n-        return OpWrapper.wrap(lookup,op().transform(OpTransformer.LOWERING_TRANSFORMER));\n+        return OpWrapper.wrap(lookup,op.transform(OpTransformer.LOWERING_TRANSFORMER));\n@@ -197,1 +197,1 @@\n-        return OpWrapper.wrap(lookup,SSA.transform(op()));\n+        return OpWrapper.wrap(lookup,SSA.transform(op));\n@@ -202,1 +202,1 @@\n-        return wrappedRootOpStream(firstBlockOfFirstBody());\n+        return wrappedRootOpStream(op.bodies().getFirst().entryBlock());\n@@ -206,1 +206,1 @@\n-        return op().transform(newName, opTransformer);\n+        return op.transform(newName, opTransformer);\n@@ -210,1 +210,1 @@\n-        return paramTable().isParameterVarOp(varDeclarationOpWrapper.op());\n+        return paramTable().isParameterVarOp(varDeclarationOpWrapper.op);\n@@ -224,1 +224,1 @@\n-        return OpWrapper.wrap(lookup,op().transform((b, op) -> {\n+        return OpWrapper.wrap(lookup,op.transform((b, op) -> {\n@@ -235,1 +235,1 @@\n-        return OpWrapper.wrap(lookup,op().transform((b, op) -> {\n+        return OpWrapper.wrap(lookup,op.transform((b, op) -> {\n@@ -261,1 +261,1 @@\n-            return context.getValues(current.operands());\n+            return context.getValues(current.op.operands());\n@@ -265,1 +265,1 @@\n-            context.mapValue(current.result(), builder.op(replacement));\n+            context.mapValue(current.op.result(), builder.op(replacement));\n@@ -274,1 +274,1 @@\n-            return current.resultType();\n+            return current.op.resultType();\n@@ -279,1 +279,1 @@\n-        return OpWrapper.wrap(lookup, op().transform((b, op) -> {\n+        return OpWrapper.wrap(lookup, op.transform((b, op) -> {\n@@ -293,1 +293,1 @@\n-        return OpWrapper.wrap(lookup, op().transform((b, op) -> {\n+        return OpWrapper.wrap(lookup, op.transform((b, op) -> {\n@@ -308,1 +308,1 @@\n-        return op().funcName();\n+        return op.funcName();\n@@ -312,1 +312,1 @@\n-        return op().resultType();\n+        return op.resultType();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.stream.Stream;\n@@ -38,13 +37,1 @@\n-        return hasBodyN(idx) && firstBlockOfBodyN(idx).ops().size() > 1;\n-    }\n-\n-    public Stream<OpWrapper<?>> conditionWrappedYieldOpStream() {\n-        return wrappedYieldOpStream(bodyN(0).entryBlock());\n-    }\n-\n-    public Stream<OpWrapper<?>> thenWrappedRootOpStream() {\n-        return wrappedRootOpStream(bodyN(1).entryBlock());\n-    }\n-\n-    public Stream<OpWrapper<?>> elseWrappedRootOpStream() {\n-        return wrappedRootOpStream(bodyN(2).entryBlock());\n+        return op.bodies().size()>idx && op.bodies().get(idx).entryBlock().ops().size() > 1;\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfOpWrapper.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        return op().invokeDescriptor();\n+        return op.invokeDescriptor();\n@@ -62,1 +62,1 @@\n-        return (operandCount() > 1 && operandNAsValue(0) instanceof Value value\n+        return (op.operands().size() > 1 && op.operands().getFirst() instanceof Value value\n@@ -90,19 +90,1 @@\n-\/*\n-    public Method methodNoLookup() {\n-        Class<?> declaringClass = javaRefClass().orElseThrow();\n-        \/\/ TODO this is just matching the name....\n-        Optional<Method> declaredMethod = Stream.of(declaringClass.getDeclaredMethods())\n-                .filter(method -> method.getName().equals(methodRef().name()))\n-                .findFirst();\n-        if (declaredMethod.isPresent()) {\n-            return declaredMethod.get();\n-        }\n-        Optional<Method> nonDeclaredMethod = Stream.of(declaringClass.getMethods())\n-                .filter(method -> method.getName().equals(methodRef().name()))\n-                .findFirst();\n-        if (nonDeclaredMethod.isPresent()) {\n-            return nonDeclaredMethod.get();\n-        } else {\n-            throw new IllegalStateException(\"what were we looking for ?\"); \/\/ getClass causes this\n-        }\n-    } *\/\n+\n@@ -110,1 +92,0 @@\n-        Method invokedMethod = null;\n@@ -112,3 +93,1 @@\n-            return methodRef().resolveToMethod(lookup, op().invokeKind());\n-          \/\/  MethodRef methodRef = methodRef();\n-         \/\/   return invokedMethod;\n+            return methodRef().resolveToMethod(lookup, op.invokeKind());\n@@ -121,1 +100,1 @@\n-        return hasReceiver() ? operandNAsValue(0) : null;\n+        return hasReceiver() ? op.operands().getFirst() : null;\n@@ -125,1 +104,1 @@\n-        return op().hasReceiver();\n+        return op.hasReceiver();\n@@ -148,1 +127,1 @@\n-        return op().invokeDescriptor().name();\n+        return op.invokeDescriptor().name();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -47,8 +47,0 @@\n-    public InvokeOpWrapper getInvoke(int index) {\n-        var result = new Result<JavaOp.InvokeOp>();\n-        selectOnlyBlockOfOnlyBody(blockWrapper ->\n-                result.of(blockWrapper.op(index))\n-        );\n-        return OpWrapper.wrap(lookup, result.get());\n-    }\n-\n@@ -56,1 +48,1 @@\n-        return op().operands();\n+        return op.operands();\n@@ -64,1 +56,1 @@\n-        return OpWrapper.wrap(lookup, op().body().entryBlock().ops().stream()\n+        return OpWrapper.wrap(lookup, op.body().entryBlock().ops().stream()\n@@ -75,1 +67,1 @@\n-        var block = op().body().entryBlock();\n+        var block = op.body().entryBlock();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(0));\n+        return wrappedYieldOpStream(op.bodies().getFirst().entryBlock()\/*firstBlockOfBodyN(0)*\/);\n@@ -42,1 +42,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(1));\n+        return wrappedYieldOpStream(op.bodies().get(1).entryBlock()\/*firstBlockOfBodyN(1)*\/);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/LogicalOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        return op().functionTable();\n+        return op.functionTable();\n@@ -74,13 +74,16 @@\n-\n-        entry.selectCalls((invokeOpWrapper) -> {\n-            MethodRef methodRef = invokeOpWrapper.methodRef();\n-            Method method = null;\n-            Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n-            try {\n-                method = methodRef.resolveToMethod(l, invokeOpWrapper.op().invokeKind());\n-            } catch (ReflectiveOperationException _) {\n-                throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n-            }\n-            Optional<CoreOp.FuncOp> f = Op.ofMethod(method);\n-            if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOpWrapper, method, methodRef, javaRefTypeClass)) {\n-                work.push(new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get())));\n+        entry.op.traverse(null, (map, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                var invokeOpWrapper = (InvokeOpWrapper) OpWrapper.wrap(entry.lookup,invokeOp);\n+                MethodRef methodRef = invokeOpWrapper.methodRef();\n+                Method method = null;\n+                Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n+                try {\n+                    method = methodRef.resolveToMethod(l, invokeOpWrapper.op.invokeKind());\n+                } catch (ReflectiveOperationException _) {\n+                    throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n+                }\n+                Optional<CoreOp.FuncOp> f = Op.ofMethod(method);\n+                if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOpWrapper, method, methodRef, javaRefTypeClass)) {\n+                    work.push(new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get())));\n+                }\n+              \/\/  consumer.accept(wrap(lookup,invokeOp));\n@@ -88,0 +91,1 @@\n+            return map;\n@@ -114,1 +118,1 @@\n-                                    call.f.op().invokableType(),\n+                                    call.f.op.invokableType(),\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-    private final T op;\n-public MethodHandles.Lookup lookup;\n+    public final T op;\n+    public final MethodHandles.Lookup lookup;\n@@ -103,112 +103,0 @@\n-\n-    public T op() {\n-        return (T) op;\n-    }\n-\n-    public Body firstBody() {\n-        if (op.bodies().isEmpty()) {\n-            throw new IllegalStateException(\"no body!\");\n-        }\n-        return op.bodies().getFirst();\n-    }\n-\n-    public Body onlyBody() {\n-        if (op.bodies().size() != 1) {\n-            throw new IllegalStateException(\"not the only body!\");\n-        }\n-        return firstBody();\n-    }\n-\n-    public void onlyBody(Consumer<BodyWrapper> bodyWrapperConsumer) {\n-        bodyWrapperConsumer.accept(new BodyWrapper(onlyBody()));\n-    }\n-\n-    public final Stream<Body> bodies() {\n-        return op.bodies().stream();\n-    }\n-\n-    public void selectOnlyBlockOfOnlyBody(Consumer<BlockWrapper> blockWrapperConsumer) {\n-        onlyBody(w -> {\n-            w.onlyBlock(blockWrapperConsumer);\n-        });\n-    }\n-\n-    public void selectCalls(Consumer<InvokeOpWrapper> consumer) {\n-        this.op.traverse(null, (map, op) -> {\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                consumer.accept(wrap(lookup,invokeOp));\n-            }\n-            return map;\n-        });\n-    }\n-    public void selectAssignments(Consumer<VarOpWrapper> consumer) {\n-        this.op.traverse(null, (map, op) -> {\n-            if (op instanceof CoreOp.VarOp varOp) {\n-                consumer.accept(wrap(lookup,varOp));\n-            }\n-            return map;\n-        });\n-    }\n-\n-    public BlockWrapper parentBlock() {\n-        return new BlockWrapper(op.ancestorBlock());\n-    }\n-\n-    public BodyWrapper parentBodyOfParentBlock() {\n-\/\/        return new BodyWrapper(op.ancestorBody());\n-        return parentBlock().parentBody();\n-    }\n-\n-\n-    public Op.Result operandNAsResult(int i) {\n-        if (operandNAsValue(i) instanceof Op.Result result) {\n-            return result;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    public Value operandNAsValue(int i) {\n-        return hasOperandN(i) ? op().operands().get(i) : null;\n-    }\n-\n-    public boolean hasOperandN(int i) {\n-        return operandCount() > i;\n-    }\n-\n-    public int operandCount() {\n-        return op().operands().size();\n-    }\n-\n-    public boolean hasOperands() {\n-        return !hasNoOperands();\n-    }\n-\n-    public boolean hasNoOperands() {\n-        return operands().isEmpty();\n-    }\n-\n-    public List<Value> operands() {\n-        return op.operands();\n-    }\n-\n-    public Body bodyN(int i) {\n-        return op().bodies().get(i);\n-    }\n-\n-    public boolean hasBodyN(int i) {\n-        return op().bodies().size() > i;\n-    }\n-\n-    public Block firstBlockOfBodyN(int i) {\n-        return bodyN(i).entryBlock();\n-    }\n-\n-    public Block firstBlockOfFirstBody() {\n-        return op().bodies().getFirst().entryBlock();\n-    }\n-\n-    public String toText() {\n-        return op().toText();\n-    }\n-\n@@ -248,7 +136,0 @@\n-    public Op.Result result() {\n-        return op.result();\n-    }\n-\n-    public TypeElement resultType() {\n-        return op.resultType();\n-    }\n@@ -256,1 +137,1 @@\n-        return  (isAssignableUsingLookup(lookup,javaType, MappableIface.class));\n+        return  isAssignableUsingLookup(lookup,javaType, MappableIface.class);\n@@ -259,1 +140,1 @@\n-        return  (isAssignable(javaType, MappableIface.class));\n+        return  isAssignable(javaType, MappableIface.class);\n@@ -289,1 +170,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":4,"deletions":124,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -39,18 +39,0 @@\n-\/\/Recursive\n-\/*\n-static Node<Value> dependencyTree(Value value) {\n-    \/\/ @@@ There should exactly one Node in the tree for a given Value\n-    List<Node<Value>> children = new ArrayList<>();\n-    for (Value dependencyOnValue : value.dependsOn()) {\n-        Node<Value> child;\n-        if (dependencyOnValue instanceof Op.Result or && or.op() instanceof JavaOps.VarAccessOp.VarLoadOp) {\n-            \/\/ Break the tree at a var load\n-            child = new Node<>(dependencyOnValue, List.of());\n-        } else {\n-            \/\/ Traverse backwards\n-            child = dependencyTree(dependencyOnValue); \/\/ recurses\n-        }\n-        children.add(child);\n-    }\n-    return new Node<>(value, children);\n-} *\/\n@@ -78,1 +60,1 @@\n-        trees.forEach((op, valueNode) -> {\n+        trees.forEach((op, _) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RootSet.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(0));\n+        return wrappedYieldOpStream(op.bodies().getFirst().entryBlock()\/*,firstBlockOfBodyN(0)*\/);\n@@ -43,1 +43,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(1));\n+        return wrappedYieldOpStream(op.bodies().get(1).entryBlock()\/*firstBlockOfBodyN(1)*\/);\n@@ -47,1 +47,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(2));\n+        return wrappedYieldOpStream(op.bodies().get(2).entryBlock()\/*firstBlockOfBodyN(2)*\/);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/TernaryOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        Value value = operands().getFirst();\n+        Value value = op.operands().getFirst();\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarAccessOpWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        return (JavaType) op().varValueType();\n+        return (JavaType) op.varValueType();\n@@ -42,1 +42,1 @@\n-        return op().varName();\n+        return op.varName();\n@@ -45,3 +45,0 @@\n-    public boolean isIfaceAssignment() {\n-        return isIface(javaType());\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/VarOpWrapper.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        return wrappedYieldOpStream(firstBlockOfBodyN(0));\n+        return wrappedYieldOpStream(op.bodies().getFirst().entryBlock()\/*firstBlockOfBodyN(0)*\/);\n@@ -45,1 +45,1 @@\n-        return wrappedRootOpStreamSansFinalContinue(firstBlockOfBodyN(1));\n+        return wrappedRootOpStreamSansFinalContinue(op.bodies().get(1).entryBlock()\/*firstBlockOfBodyN(1)*\/);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/WhileOpWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-extraction-opengl-1.0.jar!\/\" \/>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/hat-extracted-opengl-1.0.jar!\/\" \/>\n","filename":"hat\/intellij\/wrap_opengl.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -688,0 +688,1 @@\n+\n@@ -691,12 +692,12 @@\n-                            .assign(\"rankdir\", \"RL\")\n-                            .nodeShape(\"record\")\n-                            .record(\"backend-ffi-opencl\", \"backend|{ffi|extracted}|opencl\")\n-                            .record(\"backend-ffi-shared\", \"backend|ffi|<in>shared\")\n-                            .record(\"backend-ffi\", \"backend|ffi\")\n-                            .record(\"core\",  \"core\")\n-                            .record(\"cmake-info-opencl\", \"<in>cmake|info|opencl\")\n-                            .edge(\"backend-ffi-opencl\",\"backend-ffi-shared:se\")\n-                            .edge(\"backend-ffi-shared\",\"backend-ffi:n\")\n-                            .edge(\"backend-ffi\",\"core:s\")\n-                            .edge(\"backend-ffi-opencl\",\"cmake-info-opencl:ne\")\n-                    ));\n+                    .assign(\"rankdir\", \"RL\")\n+                    .nodeShape(\"record\")\n+                    .record(\"backend-ffi-opencl\", \"backend|{ffi|extracted}|opencl\")\n+                    .record(\"backend-ffi-shared\", \"backend|ffi|<in>shared\")\n+                    .record(\"backend-ffi\", \"backend|ffi\")\n+                    .record(\"core\",  \"core\")\n+                    .record(\"cmake-info-opencl\", \"<in>cmake|info|opencl\")\n+                    .edge(\"backend-ffi-opencl\",\"backend-ffi-shared:se\")\n+                    .edge(\"backend-ffi-shared\",\"backend-ffi:n\")\n+                    .edge(\"backend-ffi\",\"core:s\")\n+                    .edge(\"backend-ffi-opencl\",\"cmake-info-opencl:ne\")\n+            ));\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/jdot\/ui\/JDot.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.codebuilders.HATCodeBuilderContext;\n@@ -34,0 +35,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -36,0 +38,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n@@ -38,1 +43,1 @@\n-    public T type(CodeBuilderContext buildContext,JavaType javaType) {\n+    public T type(HATCodeBuilderContext buildContext, JavaType javaType) {\n@@ -40,1 +45,1 @@\n-                typeName(javaType.resolve(buildContext.lookup()).getTypeName());\n+                typeName(javaType.resolve(buildContext.lookup).getTypeName());\n@@ -48,1 +53,1 @@\n-    public T fieldLoad(CodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n+    public T fieldLoad(HATCodeBuilderContext buildContext, FieldLoadOpWrapper fieldLoadOpWrapper) {\n@@ -59,3 +64,3 @@\n-    public T methodCall(CodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n-        if (invokeOpWrapper.operandNAsResult(0) instanceof Op.Result instanceResult) {\n-            recurse(buildContext, OpWrapper.wrap(buildContext.lookup(), instanceResult.op()));\n+    public T methodCall(HATCodeBuilderContext buildContext, InvokeOpWrapper invokeOpWrapper) {\n+        if (!invokeOpWrapper.op.operands().isEmpty() && invokeOpWrapper.op.operands().getFirst() instanceof Op.Result instanceResult) {\n+            recurse(buildContext, OpWrapper.wrap(buildContext.lookup, instanceResult.op()));\n@@ -65,2 +70,2 @@\n-            commaSeparated(  invokeOpWrapper.operands().subList(0,invokeOpWrapper.operandCount()-1), o->\n-                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup(), ((Op.Result) o).op()))\n+            commaSeparated(  invokeOpWrapper.op.operands().subList(0,invokeOpWrapper.op.operands().size()-1), o->\n+                    recurse(buildContext, OpWrapper.wrap(buildContext.lookup, ((Op.Result) o).op()))\n@@ -72,2 +77,2 @@\n-    public T compute(FuncOpWrapper funcOpWrapper) {\n-        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n+    public T compute(MethodHandles.Lookup lookup,FuncOpWrapper funcOpWrapper) {\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(lookup,funcOpWrapper);\n@@ -79,1 +84,1 @@\n-                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.firstBlockOfFirstBody()).forEach(root ->\n+                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.op.bodies().getFirst().entryBlock()).forEach(root ->\n@@ -84,0 +89,13 @@\n+\n+   \/* public T compute(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        HATCodeBuilderContext buildContext = new HATCodeBuilderContext(funcOpWrapper);\n+        typeName(funcOpWrapper.functionReturnTypeDesc().toString()).space().identifier(funcOpWrapper.functionName());\n+        parenNlIndented(_ ->\n+                commaSeparated(funcOpWrapper.paramTable.list(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n+        );\n+        braceNlIndented(_ ->\n+                funcOpWrapper.wrappedRootOpStream(funcOpWrapper.firstBlockOfFirstBody()).forEach(root ->\n+                        recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>)).nl()\n+                ));\n+        return self();\n+    }*\/\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        builder.compute(OpWrapper.wrap(lookup,javaFunc));\n+        builder.compute(lookup,OpWrapper.wrap(lookup,javaFunc));\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}