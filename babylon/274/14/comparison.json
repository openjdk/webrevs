{"files":[{"patch":"@@ -23,0 +23,2 @@\n+ir_text_to_ir_builder\/build\n+ir_text_to_ir_builder\/hat\n","filename":".gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+#!\/bin\/zsh\n+\n+target_file=compiler_tests_stats.csv\n+echo \"classfile, original_size, new_size\" > $target_file\n+\n+target_dir=ir_text_to_ir_builder\n+for cfp in `find ..\/build\/macosx-aarch64-server-release\/JTwork\/classes\/tools\/javac\/reflect -name \"*Test.class\"`; do \\\n+  original_size=$(awk '{print $1}' <<< $(wc -c $cfp))\n+  path_to_new_cf=$(cut -d'\/' -f2- <<< $cfp)\n+  new_size=$(awk '{print $1}' <<< $(wc -c $path_to_new_cf))\n+  echo \"$(basename $cfp) $original_size $new_size\" >> $target_file\n+  ; done\n+\n+echo \"Statistics are in file: $(dirname $0)\/$target_file\"\n\\ No newline at end of file\n","filename":"ir_text_to_ir_builder\/compiler_tests_stats.sh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+#!\/bin\/zsh\n+\n+target_file=hat_examples_stats.csv\n+echo \"classfile, original_size, new_size\" > $target_file\n+\n+target_dir=ir_text_to_ir_builder\n+babylon_dir=~\/babylon\n+\n+for cfp in `find $babylon_dir\/hat\/build\/hat-example*classes -name \"*.class\"`; do \\\n+  original_size=$(awk '{print $1}' <<< $(wc -c $cfp))\n+  path_to_new_cf=$(sed \"s#$babylon_dir\/##\" <<< $cfp)\n+  new_size=$(awk '{print $1}' <<< $(wc -c $path_to_new_cf))\n+  if [ $new_size -gt $original_size ]; then\n+    #\n+    hat_example_name=$(sed 's#^.*classes\/\\(.*\\)#\\1#g'<<< $cfp | sed 's#\/#.#g')\n+    echo \"$hat_example_name $original_size $new_size\" >> $target_file\n+  fi\n+  ; done\n+\n+echo \"Statistics are in file: $(dirname $0)\/$target_file\"\n\\ No newline at end of file\n","filename":"ir_text_to_ir_builder\/hat_examples_stats.sh","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+#!\/bin\/zsh\n+\n+babylon_dir=~\/babylon\n+java_program=$babylon_dir\/test\/jdk\/java\/lang\/reflect\/code\/writer\/IRTextToIRBuilder.java\n+target_dir=ir_text_to_ir_builder\n+compiler_tests_dir=$babylon_dir\/build\/macosx-aarch64-server-release\/JTwork\/classes\/tools\/javac\/reflect\n+for cfp in `find $compiler_tests_dir -name \"*Test.class\"`; do \\\n+  cfp_from_project_root=$(sed \"s#$babylon_dir\/##\" <<< $cfp)\n+  mkdir -p $(dirname $cfp_from_project_root)\n+  java --enable-preview -cp $(dirname $cfp) $java_program $cfp > $cfp_from_project_root\n+  ; done\n+\n+echo \"Transformed classfiles are in $(dirname $0)\/$(sed \"s#$babylon_dir\/##\" <<< $compiler_tests_dir)\"\n+\n+# remember that compiler tests contains the expected text IR, so the new cf will still contains those in its CP\n+\n+# build\/macosx-aarch64-server-release\/JTwork\/classes\/tools\/javac\/reflect\/TryTest.d\/TryTest.class\n+## \/Users\/mabbay\/babylon\/test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldToMethodBuilder.java\n+#javac --enable-preview --source 24 -d . test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldToMethodBuilder.java\n+#echo \"writing data to a.csv ...\"\n+#cho \"\" > a.csv\n+#for fp in `find build\/macosx-aarch64-server-release\/JTwork\/classes\/tools\/javac\/reflect -name \"*.class\"`; do \\\n+ # java --enable-preview -ea -cp .:$(dirname $fp) OpFieldToMethodBuilder $fp | sed 's\/[[:space:]]\/,\/g' | sed \"s\/^[^,]*\/$(basename $fp)\/\" >> a.csv\n+  #; done\n+\n+#ak '!seen[$0]++' a.csv > tmp && mv tmp a.csv\n+\n+#awk -F ',' '$2 < $3' a.csv > tmp && mv tmp a.csv\n+\n+#echo \"classfile, original_size, new_size\" > tmp && cat a.csv >> tmp && mv tmp a.csv\n","filename":"ir_text_to_ir_builder\/transform_compiler_tests.sh","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+#!\/bin\/zsh\n+\n+babylon_dir=~\/babylon\n+java_program=$babylon_dir\/test\/jdk\/java\/lang\/reflect\/code\/writer\/IRTextToIRBuilder.java\n+for cfp in `find $babylon_dir\/hat\/build\/hat-example*classes -name \"*.class\"`; do \\\n+  cfp_from_project_root=$(sed \"s#$babylon_dir\/##\" <<< $cfp)\n+  mkdir -p $(dirname $cfp_from_project_root)\n+  java --enable-preview -ea $java_program $cfp > $cfp_from_project_root\n+; done\n\\ No newline at end of file\n","filename":"ir_text_to_ir_builder\/transform_hat_examples.sh","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -756,1 +756,1 @@\n-                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n+                                        jt.toNominalDescriptor(),\n@@ -783,0 +783,23 @@\n+                                cob.dup();\n+                                cob.loadConstant(j);\n+                                load(varArgOperands.get(j));\n+                                cob.arrayStore(typeKind);\n+                            }\n+                        } else {\n+                            processOperands(op);\n+                        }\n+                        if (op.isVarArgs()) {\n+                            processOperands(op.argOperands());\n+                            var varArgOperands = op.varArgOperands();\n+                            cob.loadConstant(varArgOperands.size());\n+                            var compType = ((ArrayType) op.invokeDescriptor().type().parameterTypes().getLast()).componentType();\n+                            var compTypeDesc = compType.toNominalDescriptor();\n+                            var typeKind = TypeKind.from(compTypeDesc);\n+                            if (compTypeDesc.isPrimitive()) {\n+                                cob.newarray(typeKind);\n+                            } else {\n+                                cob.anewarray(compTypeDesc);\n+                            }\n+                            for (int j = 0; j < varArgOperands.size(); j++) {\n+                                \/\/ we duplicate array value on the stack to be consumed by arrayStore\n+                                \/\/ after completion of this loop the array value will be on top of the stack\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -361,0 +361,4 @@\n+                if (value.type() instanceof PrimitiveType pt) {\n+                    var boxedType = pt.box().orElseThrow();\n+                    value = builder.op(invoke(MethodRef.method(boxedType, \"valueOf\", boxedType, pt), value));\n+                }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.lang.classfile.*;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.writer.OpBuilder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+\n+import static java.lang.reflect.code.op.CoreOp.FuncOp;\n+\n+\/*\n+* @test\n+* *\/\n+\n+public class IRTextToIRBuilder {\n+    \/\/ TODO original cf size of text, new cf size of code builder\n+    \/\/ TODO rename + doc (do it after separation)\n+    \/\/ TODO zip cf\n+    \/\/ TODO can we reduce code builder ?\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: <program> <path_to_cf>\");\n+            System.exit(-1);\n+        }\n+        var cf_path = Path.of(args[0]);\n+        var bytes = Files.readAllBytes(cf_path);\n+        var new_bytes = replaceOpFieldWithBuilderMethod(bytes);\n+        new PrintStream(System.out).write(new_bytes);\n+    }\n+\n+    static byte[] replaceOpFieldWithBuilderMethod(byte[] classData) {\n+        return replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n+    }\n+\n+    static byte[] replaceOpFieldWithBuilderMethod(ClassModel classModel) {\n+        var opFieldsAndIRs = new ArrayList<OpFieldAndIR>();\n+        var classTransform = ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n+                ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n+                    if (!(me instanceof CodeModel codeModel)) {\n+                        mb.with(me);\n+                        return;\n+                    }\n+                    mb.withCode(cob -> {\n+                        ConstantInstruction.LoadConstantInstruction ldc = null;\n+                        for (CodeElement e : codeModel) {\n+                            if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(classModel.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n+                                opFieldsAndIRs.add(new OpFieldAndIR(fi.field(), ((StringEntry) ldc.constantEntry()).stringValue()));\n+                                ldc = null;\n+                            } else {\n+                                if (ldc != null) {\n+                                    cob.with(ldc);\n+                                    ldc = null;\n+                                }\n+                                switch (e) {\n+                                    case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n+                                            ldc = lci;\n+                                    case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n+                                    }\n+                                    default -> cob.with(e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                })).andThen(ClassTransform.endHandler(clb -> {\n+            for (var opFieldAndIR : opFieldsAndIRs) {\n+                var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n+                var builderOp = OpBuilder.createBuilderFunction(funcOp);\n+                var opFieldName = opFieldAndIR.opField().name().stringValue();\n+                var methodName = Utils.irBuilderName(opFieldName);\n+                byte[] bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), methodName, builderOp);\n+                var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().orElseThrow();\n+                clb.with(builderMethod);\n+            }\n+        }));\n+        var cf = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n+        var newBytes = cf.transformClass(classModel, classTransform);\n+        return newBytes;\n+    }\n+\n+    static void print(byte[] bytes) {\n+        print(ClassFile.of().parse(bytes));\n+    }\n+\n+    static void print(ClassModel cm) {\n+        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/IRTextToIRBuilder.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class IRTextToIRBuilderTester {\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length != 2) {\n+            System.err.println(\"Usage: <program> <path_to_original_cf> <path_to_new_cf>\");\n+            System.exit(-1);\n+        }\n+        var path_to_original_cf = Path.of(args[0]);\n+        var path_to_new_cf = Path.of(args[1]);\n+\n+        var original_bytes = Files.readAllBytes(path_to_original_cf);\n+        var original_cm = ClassFile.of().parse(original_bytes);\n+\n+        var url1 = path_to_new_cf.getParent().toUri().toURL();\n+        var url2 = path_to_original_cf.getParent().toUri().toURL();\n+        var ucl = new URLClassLoader(new URL[]{url1, url2});\n+        var fn = path_to_new_cf.getFileName().toString();\n+        var cn = fn.substring(0, fn.lastIndexOf('.'));\n+        var new_class = ucl.loadClass(cn);\n+\n+        var opFieldsAndIRs = Utils.getOpFieldsAndIRs(original_cm);\n+        for (OpFieldAndIR opFieldAndIR : opFieldsAndIRs) {\n+            String mn = Utils.irBuilderName(opFieldAndIR.opField().name().stringValue());\n+            var mh = MethodHandles.lookup().findStatic(new_class, mn, Utils.irBuilderMethodType());\n+            var builtOp = ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY));\n+            assert builtOp.toText().equals(opFieldAndIR.ir());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/IRTextToIRBuilderTester.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+\n+public record OpFieldAndIR (FieldRefEntry opField, String ir) {}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldAndIR.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.TypeElementFactory;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class Utils {\n+\n+    static List<OpFieldAndIR> getOpFieldsAndIRs(ClassModel cm) {\n+        var cinit = cm.methods().stream()\n+                .filter(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME)).findFirst().orElseThrow();\n+        var opFieldsAndIRs = new ArrayList<OpFieldAndIR>();\n+        CodeElement prev = null;\n+        for (CodeElement ce : cinit.code().orElseThrow()) {\n+            if (ce instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC &&\n+                    fi.owner().equals(cm.thisClass()) && fi.name().stringValue().endsWith(\"$op\") &&\n+                    prev instanceof ConstantInstruction.LoadConstantInstruction lci) {\n+                opFieldsAndIRs.add(new OpFieldAndIR(fi.field(), ((StringEntry) lci.constantEntry()).stringValue()));\n+            }\n+            prev = ce;\n+        }\n+        return opFieldsAndIRs;\n+    }\n+\n+    static String irBuilderName(String opFieldName) {\n+        \/\/ e.g. A::add(int, int)int$op ---> add(int, int)int$op\n+        return opFieldName.substring(opFieldName.indexOf(':') + 2);\n+    }\n+\n+    static MethodType irBuilderMethodType() throws ReflectiveOperationException {\n+        var functionType = FunctionType.functionType(JavaType.type(Op.class), JavaType.type(OpFactory.class),\n+                JavaType.type(TypeElementFactory.class));\n+        var mt = MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(MethodHandles.lookup());\n+        return mt;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/Utils.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"}]}