{"files":[{"patch":"@@ -0,0 +1,7 @@\n+#!\/bin\/zsh\n+\n+javac --enable-preview --source 24 -d . test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldToMethodBuilder.java\n+\n+for fp in `find build\/macosx-aarch64-server-release\/JTwork\/classes\/tools\/javac\/reflect -name \"*.class\"`; do \\\n+  java --enable-preview -ea -cp .:$(dirname $fp) OpFieldToMethodBuilder $fp \\\n+  ; done\n","filename":"script.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -361,0 +361,4 @@\n+                if (value.type() instanceof PrimitiveType pt) {\n+                    var boxedType = pt.box().orElseThrow();\n+                    value = builder.op(invoke(MethodRef.method(boxedType, \"valueOf\", boxedType, pt), value));\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.type.*;\n+import java.lang.reflect.code.writer.OpBuilder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOp.FuncOp;\n+\n+public class OpFieldToMethodBuilder {\n+\n+    public static void main(String[] args) {\n+        for (var arg : args) {\n+            var path = Path.of(arg);\n+            byte[] originalBytes;\n+            byte[] newBytes;\n+            try {\n+                originalBytes = Files.readAllBytes(path);\n+                newBytes = OpFieldToMethodBuilder.replaceOpFieldWithBuilderMethod(originalBytes);\n+            } catch (Throwable e) {\n+                continue; \/\/ ignore errors for now\n+            }\n+            System.out.printf(\"%s %d %d%n\", arg, originalBytes.length, newBytes.length);\n+            System.out.println();\n+            \/\/ TODO output useful info like avg size increase\n+            \/\/ TODO remove duplicate\n+            \/\/ TODO reduce size if possible (by reducing the code of the builder method)\n+        }\n+    }\n+\n+    static byte[] replaceOpFieldWithBuilderMethod(byte[] classData) {\n+        return replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n+    }\n+\n+    record OpFieldAndIR(FieldRefEntry opField, String ir) {\n+    }\n+\n+    static byte[] replaceOpFieldWithBuilderMethod(ClassModel classModel) {\n+        var opFieldsAndIRs = new ArrayList<OpFieldAndIR>();\n+        var classTransform = ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n+                ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n+                    if (!(me instanceof CodeModel codeModel)) {\n+                        mb.with(me);\n+                        return;\n+                    }\n+                    mb.withCode(cob -> {\n+                        ConstantInstruction.LoadConstantInstruction ldc = null;\n+                        for (CodeElement e : codeModel) {\n+                            if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(classModel.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n+                                opFieldsAndIRs.add(new OpFieldAndIR(fi.field(), ((StringEntry) ldc.constantEntry()).stringValue()));\n+                                ldc = null;\n+                            } else {\n+                                if (ldc != null) {\n+                                    cob.with(ldc);\n+                                    ldc = null;\n+                                }\n+                                switch (e) {\n+                                    case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n+                                            ldc = lci;\n+                                    case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n+                                    }\n+                                    default -> cob.with(e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                })).andThen(ClassTransform.endHandler(clb -> {\n+            for (var opFieldAndIR : opFieldsAndIRs) {\n+                var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n+                var builderOp = OpBuilder.createBuilderFunction(funcOp);\n+                testBuilderOp(builderOp, opFieldAndIR.ir());\n+                var opFieldName = opFieldAndIR.opField().name().stringValue();\n+                var methodName = builderMethodName(opFieldName);\n+                byte[] bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), methodName, builderOp);\n+                var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().orElseThrow();\n+                clb.with(builderMethod);\n+            }\n+        }));\n+        var cf = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n+        var newBytes = cf.transformClass(classModel, classTransform);\n+        testBuilderMethods(newBytes, opFieldsAndIRs);\n+        return newBytes;\n+    }\n+\n+    static void testBuilderOp(FuncOp builderOp, String expectedIR) {\n+        var op = (Op) Interpreter.invoke(builderOp, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+        assert expectedIR.equals(op.toText());\n+    }\n+\n+    static void testBuilderMethods(byte[] classData, List<OpFieldAndIR> opFieldsAndIRs) {\n+        MethodHandles.Lookup lookup = null;\n+        try {\n+            lookup = MethodHandles.lookup().defineHiddenClass(classData, true);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        for (var opFieldAndIR : opFieldsAndIRs) {\n+            var opFieldName = opFieldAndIR.opField().name().stringValue();\n+            var methodName = builderMethodName(opFieldName);\n+            var functionType = FunctionType.functionType(JavaType.type(Op.class), JavaType.type(OpFactory.class),\n+                    JavaType.type(TypeElementFactory.class));\n+            MethodHandle mh = null;\n+            try {\n+                mh = lookup.findStatic(lookup.lookupClass(),\n+                        methodName,\n+                        MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(lookup));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+            Op builtOp = null;\n+            try {\n+                builtOp = ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY));\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            assert builtOp.toText().equals(opFieldAndIR.ir());\n+        }\n+    }\n+\n+    static String builderMethodName(String opFieldName) {\n+        \/\/ e.g. A::add(int, int)int$op ---> add(int, int)int$op\n+        return opFieldName.substring(opFieldName.indexOf(':') + 2);\n+    }\n+\n+    static void print(byte[] bytes) {\n+        print(ClassFile.of().parse(bytes));\n+    }\n+\n+    static void print(ClassModel cm) {\n+        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldToMethodBuilder.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -1,139 +0,0 @@\n-import java.io.IOException;\n-import java.lang.classfile.*;\n-import java.lang.classfile.components.ClassPrinter;\n-import java.lang.classfile.constantpool.FieldRefEntry;\n-import java.lang.classfile.constantpool.StringEntry;\n-import java.lang.classfile.instruction.*;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.ExtendedOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.parser.OpParser;\n-import java.lang.reflect.code.type.*;\n-import java.lang.reflect.code.writer.OpBuilder;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static java.lang.reflect.code.op.CoreOp.FuncOp;\n-\n-public class TestOpMethod {\n-\n-    public static void main(String[] args) throws IOException, ClassNotFoundException {\n-        for (var arg : args) {\n-            var path = Path.of(arg);\n-            var originalBytes = Files.readAllBytes(path);\n-            var newBytes = TestOpMethod.replaceOpFieldWithBuilderMethod(originalBytes);\n-            System.out.printf(\"%s %d %d%n\", arg, originalBytes.length, newBytes.length);\n-            \/\/ TODO a script that runs the tool for many classes\n-            \/\/ TODO reduce size if possible\n-        }\n-    }\n-\n-    static byte[] replaceOpFieldWithBuilderMethod(byte[] classData) {\n-        return replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n-    }\n-\n-    record OpFieldAndIR(FieldRefEntry opField, String ir) {\n-    }\n-\n-    static byte[] replaceOpFieldWithBuilderMethod(ClassModel classModel) {\n-        var opFieldsAndIRs = new ArrayList<OpFieldAndIR>();\n-        var classTransform = ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n-                ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n-                    if (!(me instanceof CodeModel codeModel)) {\n-                        mb.with(me);\n-                        return;\n-                    }\n-                    mb.withCode(cob -> {\n-                        ConstantInstruction.LoadConstantInstruction ldc = null;\n-                        for (CodeElement e : codeModel) {\n-                            if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(classModel.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n-                                opFieldsAndIRs.add(new OpFieldAndIR(fi.field(), ((StringEntry) ldc.constantEntry()).stringValue()));\n-                                ldc = null;\n-                            } else {\n-                                if (ldc != null) {\n-                                    cob.with(ldc);\n-                                    ldc = null;\n-                                }\n-                                switch (e) {\n-                                    case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n-                                            ldc = lci;\n-                                    case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n-                                    }\n-                                    default -> cob.with(e);\n-                                }\n-                            }\n-                        }\n-                    });\n-                })).andThen(ClassTransform.endHandler(clb -> {\n-            for (var opFieldAndIR : opFieldsAndIRs) {\n-                var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n-                var builderOp = OpBuilder.createBuilderFunction(funcOp);\n-                testBuilderOp(builderOp, opFieldAndIR.ir());\n-                var opFieldName = opFieldAndIR.opField().name().stringValue();\n-                var methodName = builderMethodName(opFieldName);\n-                byte[] bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), methodName, builderOp);\n-                var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n-                        .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().orElseThrow();\n-                clb.with(builderMethod);\n-            }\n-        }));\n-        var newBytes = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(classModel, classTransform);\n-        testBuilderMethods(newBytes, opFieldsAndIRs);\n-        return newBytes;\n-    }\n-\n-    static void testBuilderOp(FuncOp builderOp, String expectedIR) {\n-        var op = (Op) Interpreter.invoke(builderOp, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n-        assert expectedIR.equals(op.toText());\n-    }\n-\n-    static void testBuilderMethods(byte[] classData, List<OpFieldAndIR> opFieldsAndIRs) {\n-        MethodHandles.Lookup lookup = null;\n-        try {\n-            lookup = MethodHandles.lookup().defineHiddenClass(classData, true);\n-        } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-        for (var opFieldAndIR : opFieldsAndIRs) {\n-            var opFieldName = opFieldAndIR.opField().name().stringValue();\n-            var methodName = builderMethodName(opFieldName);\n-            var functionType = FunctionType.functionType(JavaType.type(Op.class), JavaType.type(OpFactory.class),\n-                    JavaType.type(TypeElementFactory.class));\n-            MethodHandle mh = null;\n-            try {\n-                mh = lookup.findStatic(lookup.lookupClass(),\n-                        methodName,\n-                        MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(lookup));\n-            } catch (ReflectiveOperationException e) {\n-                throw new RuntimeException(e);\n-            }\n-            Op builtOp = null;\n-            try {\n-                builtOp = ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY));\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-            assert builtOp.toText().equals(opFieldAndIR.ir());\n-        }\n-    }\n-\n-    static String builderMethodName(String opFieldName) {\n-        \/\/ e.g. A::add(int, int)int$op ---> add(int, int)int$op\n-        return opFieldName.substring(opFieldName.indexOf(':') + 2);\n-    }\n-\n-    static void print(byte[] bytes) {\n-        print(ClassFile.of().parse(bytes));\n-    }\n-\n-    static void print(ClassModel cm) {\n-        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOpMethod.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"}]}