{"files":[{"patch":"@@ -0,0 +1,13 @@\n+#!\/bin\/zsh\n+\n+javac --enable-preview --source 24 -d . test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldToMethodBuilder.java\n+touch a.csv\n+echo \"writing data to a.csv ...\"\n+echo \"classfile, original_size, new_size\" > a.csv\n+for fp in `find build\/macosx-aarch64-server-release\/JTwork\/classes\/tools\/javac\/reflect -name \"*.class\"`; do \\\n+  java --enable-preview -ea -cp .:$(dirname $fp) OpFieldToMethodBuilder $fp | sed 's\/[[:space:]]\/,\/g' | sed \"s\/^[^,]*\/$(basename $fp)\/\" >> a.csv\n+  ; done\n+\n+awk '!seen[$0]++' a.csv > tmp && mv tmp a.csv\n+\n+awk -F ',' '$2 < $3 {print $0}' a.csv > tmp && mv tmp a.csv\n","filename":"script.sh","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -198,0 +198,13 @@\n+    public static byte[] addOpByteCodeToClassFile(MethodHandles.Lookup lookup, ClassModel cm, String methodName, FuncOp builderOp) {\n+        var bytes = generateClassData(lookup, methodName, builderOp);\n+        var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n+                .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().get();\n+        var newBytes = ClassFile.of().build(cm.thisClass().asSymbol(), cb -> {\n+            for (var ce : cm) {\n+                cb.with(ce);\n+            }\n+            cb.with(builderMethod);\n+        });\n+        return newBytes;\n+    }\n+\n@@ -851,1 +864,1 @@\n-                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n+                                        jt.toNominalDescriptor(),\n@@ -863,2 +876,21 @@\n-                        \/\/ @@@ var args\n-                        processOperands(op);\n+                        if (op.isVarArgs()) {\n+                            processOperands(op.operands().subList(0, op.operands().size() - op.varArgOperands().size()));\n+                            var varArgOperands = op.varArgOperands();\n+                            cob.loadConstant(varArgOperands.size());\n+                            var compType = ((ArrayType) op.invokeDescriptor().type().parameterTypes().getLast()).componentType();\n+                            var typeKind = TypeKind.fromDescriptor(compType.toNominalDescriptor().descriptorString());\n+                            if (TypeKind.REFERENCE.equals(typeKind)) {\n+                                var cd = ClassDesc.ofDescriptor(compType.toNominalDescriptor().descriptorString());\n+                                cob.anewarray(cd);\n+                            } else {\n+                                cob.newarray(typeKind);\n+                            }\n+                            for (int j = 0; j < varArgOperands.size(); j++) {\n+                                cob.dup();\n+                                cob.loadConstant(j);\n+                                load(varArgOperands.get(j));\n+                                cob.arrayStore(typeKind);\n+                            }\n+                        } else {\n+                            processOperands(op);\n+                        }\n@@ -876,3 +908,0 @@\n-                        if (op.isVarArgs()) {\n-                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n-                        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -361,0 +361,4 @@\n+                if (value.type() instanceof PrimitiveType pt) {\n+                    var boxedType = pt.box().orElseThrow();\n+                    value = builder.op(invoke(MethodRef.method(boxedType, \"valueOf\", boxedType, pt), value));\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestVarArg\n+ *\n+ *\/\n+public class TestVarArg {\n+\n+    @Test\n+    void test() throws Throwable {\n+        var f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        var lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        var bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        var classModel = ClassFile.of().parse(bytes);\n+        ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        Assert.assertEquals(mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    static String f() {\n+        String r = \"\";\n+        String ls = System.lineSeparator();\n+\n+        r += ls + h(1);\n+        r += ls + h(2, 3);\n+        r += ls + h(4, (byte) 5);\n+\n+        r += ls + k(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+\n+        r += ls + j(\"s1\", \"s2\", \"s3\");\n+\n+        r += ls + w(8, 9);\n+\n+        r += k();\n+\n+        r += w(11L, 12L);\n+\n+        r += w(21.0, 22.0);\n+\n+        return r;\n+    }\n+\n+    static String h(int i, int... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static String k(byte... s) {\n+        return Arrays.toString(s);\n+    }\n+\n+    static String j(String i, String... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static <T extends Number> String w(T... ts) {\n+        return Arrays.toString(ts);\n+    }\n+\n+    private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+import java.lang.runtime.CodeReflection;\n+\n+public class IR {\n+\n+    @CodeReflection\n+    static String add(String a, int b) {\n+        return a + b;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/IR.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.type.*;\n+import java.lang.reflect.code.writer.OpBuilder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOp.FuncOp;\n+\n+public class OpFieldToMethodBuilder {\n+\n+    public static void main(String[] args) {\n+        for (var arg : args) {\n+            var path = Path.of(arg);\n+            byte[] originalBytes;\n+            byte[] newBytes;\n+            try {\n+                originalBytes = Files.readAllBytes(path);\n+                newBytes = OpFieldToMethodBuilder.replaceOpFieldWithBuilderMethod(originalBytes);\n+            } catch (Throwable e) {\n+                continue; \/\/ ignore errors for now\n+            }\n+            System.out.printf(\"%s %d %d%n\", arg, originalBytes.length, newBytes.length);\n+            \/\/ TODO output useful info like avg size increase\n+            \/\/ TODO remove duplicate\n+            \/\/ TODO reduce size if possible (by reducing the code of the builder method)\n+        }\n+    }\n+\n+    static byte[] replaceOpFieldWithBuilderMethod(byte[] classData) {\n+        return replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n+    }\n+\n+    record OpFieldAndIR(FieldRefEntry opField, String ir) {\n+    }\n+\n+    static byte[] replaceOpFieldWithBuilderMethod(ClassModel classModel) {\n+        var opFieldsAndIRs = new ArrayList<OpFieldAndIR>();\n+        var classTransform = ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n+                ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n+                    if (!(me instanceof CodeModel codeModel)) {\n+                        mb.with(me);\n+                        return;\n+                    }\n+                    mb.withCode(cob -> {\n+                        ConstantInstruction.LoadConstantInstruction ldc = null;\n+                        for (CodeElement e : codeModel) {\n+                            if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(classModel.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n+                                opFieldsAndIRs.add(new OpFieldAndIR(fi.field(), ((StringEntry) ldc.constantEntry()).stringValue()));\n+                                ldc = null;\n+                            } else {\n+                                if (ldc != null) {\n+                                    cob.with(ldc);\n+                                    ldc = null;\n+                                }\n+                                switch (e) {\n+                                    case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n+                                            ldc = lci;\n+                                    case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n+                                    }\n+                                    default -> cob.with(e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                })).andThen(ClassTransform.endHandler(clb -> {\n+            for (var opFieldAndIR : opFieldsAndIRs) {\n+                var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n+                var builderOp = OpBuilder.createBuilderFunction(funcOp);\n+                testBuilderOp(builderOp, opFieldAndIR.ir());\n+                var opFieldName = opFieldAndIR.opField().name().stringValue();\n+                var methodName = builderMethodName(opFieldName);\n+                byte[] bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), methodName, builderOp);\n+                var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().orElseThrow();\n+                clb.with(builderMethod);\n+            }\n+        }));\n+        var cf = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n+        var newBytes = cf.transformClass(classModel, classTransform);\n+        testBuilderMethods(newBytes, opFieldsAndIRs);\n+        return newBytes;\n+    }\n+\n+    static void testBuilderOp(FuncOp builderOp, String expectedIR) {\n+        var op = (Op) Interpreter.invoke(builderOp, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+        assert expectedIR.equals(op.toText());\n+    }\n+\n+    static void testBuilderMethods(byte[] classData, List<OpFieldAndIR> opFieldsAndIRs) {\n+        MethodHandles.Lookup lookup = null;\n+        try {\n+            lookup = MethodHandles.lookup().defineHiddenClass(classData, true);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        for (var opFieldAndIR : opFieldsAndIRs) {\n+            var opFieldName = opFieldAndIR.opField().name().stringValue();\n+            var methodName = builderMethodName(opFieldName);\n+            var functionType = FunctionType.functionType(JavaType.type(Op.class), JavaType.type(OpFactory.class),\n+                    JavaType.type(TypeElementFactory.class));\n+            MethodHandle mh = null;\n+            try {\n+                mh = lookup.findStatic(lookup.lookupClass(),\n+                        methodName,\n+                        MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(lookup));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+            Op builtOp = null;\n+            try {\n+                builtOp = ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY));\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            assert builtOp.toText().equals(opFieldAndIR.ir());\n+        }\n+    }\n+\n+    static String builderMethodName(String opFieldName) {\n+        \/\/ e.g. A::add(int, int)int$op ---> add(int, int)int$op\n+        return opFieldName.substring(opFieldName.indexOf(':') + 2);\n+    }\n+\n+    static void print(byte[] bytes) {\n+        print(ClassFile.of().parse(bytes));\n+    }\n+\n+    static void print(ClassModel cm) {\n+        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/OpFieldToMethodBuilder.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}