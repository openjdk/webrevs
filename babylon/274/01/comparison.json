{"files":[{"patch":"@@ -198,0 +198,13 @@\n+    public static byte[] addOpByteCodeToClassFile(MethodHandles.Lookup lookup, ClassModel cm, String methodName, FuncOp builderOp) {\n+        var bytes = generateClassData(lookup, methodName, builderOp);\n+        var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n+                .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().get();\n+        var newBytes = ClassFile.of().build(cm.thisClass().asSymbol(), cb -> {\n+            for (var ce : cm) {\n+                cb.with(ce);\n+            }\n+            cb.with(builderMethod);\n+        });\n+        return newBytes;\n+    }\n+\n@@ -851,1 +864,1 @@\n-                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n+                                        jt.toNominalDescriptor(),\n@@ -863,2 +876,21 @@\n-                        \/\/ @@@ var args\n-                        processOperands(op);\n+                        if (op.isVarArgs()) {\n+                            processOperands(op.operands().subList(0, op.operands().size() - op.varArgOperands().size()));\n+                            var varArgOperands = op.varArgOperands();\n+                            cob.loadConstant(varArgOperands.size());\n+                            var compType = ((ArrayType) op.invokeDescriptor().type().parameterTypes().getLast()).componentType();\n+                            var typeKind = TypeKind.fromDescriptor(compType.toNominalDescriptor().descriptorString());\n+                            if (TypeKind.REFERENCE.equals(typeKind)) {\n+                                var cd = ClassDesc.ofDescriptor(compType.toNominalDescriptor().descriptorString());\n+                                cob.anewarray(cd);\n+                            } else {\n+                                cob.newarray(typeKind);\n+                            }\n+                            for (int j = 0; j < varArgOperands.size(); j++) {\n+                                cob.dup();\n+                                cob.loadConstant(j);\n+                                load(varArgOperands.get(j));\n+                                cob.arrayStore(typeKind);\n+                            }\n+                        } else {\n+                            processOperands(op);\n+                        }\n@@ -876,3 +908,0 @@\n-                        if (op.isVarArgs()) {\n-                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n-                        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestVarArg\n+ *\n+ *\/\n+public class TestVarArg {\n+\n+    @Test\n+    void test() throws Throwable {\n+        var f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        var lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        var bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), f);\n+        var classModel = ClassFile.of().parse(bytes);\n+        ClassPrinter.toYaml(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+\n+        MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+        Assert.assertEquals(mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    static String f() {\n+        String r = \"\";\n+        String ls = System.lineSeparator();\n+\n+        r += ls + h(1);\n+        r += ls + h(2, 3);\n+        r += ls + h(4, (byte) 5);\n+\n+        r += ls + k(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+\n+        r += ls + j(\"s1\", \"s2\", \"s3\");\n+\n+        r += ls + w(8, 9);\n+\n+        r += k();\n+\n+        r += w(11L, 12L);\n+\n+        r += w(21.0, 22.0);\n+\n+        return r;\n+    }\n+\n+    static String h(int i, int... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static String k(byte... s) {\n+        return Arrays.toString(s);\n+    }\n+\n+    static String j(String i, String... s) {\n+        return i + \", \" + Arrays.toString(s);\n+    }\n+\n+    static <T extends Number> String w(T... ts) {\n+        return Arrays.toString(ts);\n+    }\n+\n+    private CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(this.getClass().getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestVarArg.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+import java.lang.runtime.CodeReflection;\n+\n+public class IR {\n+\n+    @CodeReflection\n+    static String add(String a, int b) {\n+        return a + b;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/IR.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.writer.OpBuilder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOp.FuncOp;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestOpMethod\n+ *\n+ *\/\n+public class TestOpMethod {\n+\n+\/\/    We discussed replacing the mechanism to store models in class files.\n+\/\/    Currently, we serialize to the textual form.\n+\/\/    We want to explore replacing that with methods in class files that build and return models.\n+\/\/    See the test TestCodeBuilder and familiarize yourself with that.\n+\/\/    It's likely that transformation code is buggy because it has not been tested on a wide range of source.\n+\/\/    It would also be interesting to get some size comparison between the two approaches.\n+\/\/    To properly do this we will need to avoid the copying of code from java.base into jdk.compiler,\n+\/\/    otherwise we need to copy more code and there are certain restrictions on what features the code can use.\n+\/\/    Maurizio is looking into that.\n+\/\/    There may be an interim solution before moving the code to an incubating model. We should discuss more in our meetings.\n+\/\/    One way to explore sooner for experimentation purposes to write a class file transformer using the Classfile API\n+\/\/    and rewrite the class file replacing code models in textual form with the corresponding methods.\n+\/\/    That's more challenging when reflecting over lambda bodies, but should more feasible when reflecting over method bodies.\n+\n+    static ClassModel CLASS_MODEL;\n+    @BeforeClass\n+    static void setup() throws IOException {\n+        CLASS_MODEL = ClassFile.of().parse(IR.class.getResourceAsStream(\"IR.class\").readAllBytes());\n+    }\n+\n+    @DataProvider\n+    byte[][] classes() {\n+        try {\n+            return new byte[][] {\n+                    IR.class.getResourceAsStream(\"IR.class\").readAllBytes()\n+            };\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"classes\")\n+    void test(byte[] cd) throws Throwable {\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(cd);\n+        var opFieldsAndIRs = getOpFieldsAndIRs(cm);\n+        cd = removeOpFields(cm);\n+        for (var opFieldAndIR : opFieldsAndIRs) {\n+            var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n+            var builderOp = OpBuilder.createBuilderFunction(funcOp);\n+            var builtOp = (Op) Interpreter.invoke(builderOp, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+            Assert.assertEquals(builtOp.toText(), opFieldAndIR.ir());\n+\n+            cd = BytecodeGenerator.addOpByteCodeToClassFile(MethodHandles.lookup(), cm, opFieldAndIR.fieldName(), builderOp);\n+            cm = cf.parse(cd);\n+            Assert.assertEquals(cm.methods().stream().filter(mm -> mm.methodName().equalsString(opFieldAndIR.fieldName())).count(),\n+                    opFieldsAndIRs.size());\n+\n+            var l = MethodHandles.lookup().defineHiddenClass(cd, true);\n+            var mh = l.findStatic(l.lookupClass(),\n+                    opFieldAndIR.fieldName(),\n+                    MethodRef.toNominalDescriptor(builderOp.invokableType()).resolveConstantDesc(l));\n+            Assert.assertEquals(\n+                    ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY)).toText(),\n+                    opFieldAndIR.ir());\n+        }\n+        print(cm);\n+    }\n+\n+    static void print(byte[] bytes) {\n+        print(ClassFile.of().parse(bytes));\n+    }\n+\n+    static void print(ClassModel cm) {\n+        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+    }\n+\n+    record OpFieldAndIR(String fieldName, String ir) {}\n+\n+    List<OpFieldAndIR> getOpFieldsAndIRs(ClassModel cm) {\n+        List<OpFieldAndIR> res = new ArrayList<>();\n+        var cinit = cm.methods().stream().filter(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME))\n+                .findFirst().orElseThrow();\n+        CodeElement prev = null;\n+        for (CodeElement curr : cinit.code().get().elementList()) {\n+            if (curr instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC\n+                    && fi.owner().equals(cm.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n+                var lci = (ConstantInstruction.LoadConstantInstruction) prev;\n+                var pe = (StringEntry) lci.constantEntry();\n+                res.add(new OpFieldAndIR(fi.name().stringValue().substring(fi.name().stringValue().indexOf(':') + 2), pe.stringValue()));\n+            }\n+            prev = curr;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    void testRemovingOpField() {\n+        var bytes = removeOpFields(CLASS_MODEL);\n+        var cm = ClassFile.of().parse(bytes);\n+        Assert.assertFalse(cm.fields().stream().anyMatch(fm -> fm.fieldName().stringValue().endsWith(\"$op\")\n+                && fm.fieldType().equalsString(\"String\")));\n+        for (PoolEntry poolEntry : cm.constantPool()) {\n+            Assert.assertFalse(poolEntry instanceof StringEntry se && se.stringValue().startsWith(\"func @\"));\n+        }\n+    }\n+\n+    private byte[] removeOpFields(ClassModel cm) {\n+        var bytes = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(cm,\n+                ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n+                        ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n+                            if (me instanceof CodeModel com) {\n+                                mb.withCode(cob -> {\n+                                    ConstantInstruction.LoadConstantInstruction ldc = null;\n+                                    for (CodeElement e : com) {\n+                                        if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(cm.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n+                                            ldc = null;\n+                                        } else {\n+                                            if (ldc != null) {\n+                                                cob.with(ldc);\n+                                                ldc = null;\n+                                            }\n+                                            switch (e) {\n+                                                case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n+                                                        ldc = lci;\n+                                                case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n+                                                }\n+                                                default -> cob.with(e);\n+                                            }\n+                                        }\n+                                    }\n+                                });\n+                            } else {\n+                                mb.with(me);\n+                            }\n+                        })));\n+        return bytes;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOpMethod.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}