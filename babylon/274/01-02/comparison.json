{"files":[{"patch":"@@ -9,1 +9,1 @@\n-import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n@@ -16,1 +16,0 @@\n-import java.lang.reflect.code.interpreter.Interpreter;\n@@ -18,0 +17,1 @@\n+import java.lang.reflect.code.op.OpFactory;\n@@ -19,2 +19,1 @@\n-import java.lang.reflect.code.type.CoreTypeFactory;\n-import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.*;\n@@ -50,0 +49,1 @@\n+\n@@ -58,1 +58,1 @@\n-            return new byte[][] {\n+            return new byte[][]{\n@@ -66,0 +66,44 @@\n+    static byte[] replaceOpFieldWithBuilderMethod(ClassModel classModel) {\n+        var opFieldsAndIRs = new ArrayList<OpFieldAndIR>();\n+        var classTransform = ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n+                ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n+                    if (!(me instanceof CodeModel codeModel)) {\n+                        mb.with(me);\n+                        return;\n+                    }\n+                    mb.withCode(cob -> {\n+                        ConstantInstruction.LoadConstantInstruction ldc = null;\n+                        for (CodeElement e : codeModel) {\n+                            if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(classModel.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n+                                opFieldsAndIRs.add(new OpFieldAndIR(fi.field(), ((StringEntry) ldc.constantEntry()).stringValue()));\n+                                ldc = null;\n+                            } else {\n+                                if (ldc != null) {\n+                                    cob.with(ldc);\n+                                    ldc = null;\n+                                }\n+                                switch (e) {\n+                                    case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n+                                            ldc = lci;\n+                                    case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n+                                    }\n+                                    default -> cob.with(e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                })).andThen(ClassTransform.endHandler(clb -> {\n+            for (var opFieldAndIR : opFieldsAndIRs) {\n+                var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n+                var builderOp = OpBuilder.createBuilderFunction(funcOp);\n+                var opFieldName = opFieldAndIR.opField().name().stringValue();\n+                var methodName = opFieldAndIR.opField().name().stringValue().substring(opFieldName.indexOf(':') + 2);\n+                byte[] bytes = BytecodeGenerator.generateClassData(MethodHandles.lookup(), methodName, builderOp);\n+                var builderMethod = ClassFile.of().parse(bytes).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName)).findFirst().orElseThrow();\n+                clb.with(builderMethod);\n+            }\n+        }));\n+        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(classModel, classTransform);\n+    }\n+\n@@ -67,5 +111,5 @@\n-    void test(byte[] cd) throws Throwable {\n-        var cf = ClassFile.of();\n-        var cm = cf.parse(cd);\n-        var opFieldsAndIRs = getOpFieldsAndIRs(cm);\n-        cd = removeOpFields(cm);\n+    void test(byte[] classData) throws Throwable {\n+        var bytes = replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n+        print(bytes);\n+        var opFieldsAndIRs = getOpFieldsAndIRs(ClassFile.of().parse(bytes));\n+        MethodHandles.Lookup l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n@@ -73,11 +117,4 @@\n-            var funcOp = ((FuncOp) OpParser.fromStringOfFuncOp(opFieldAndIR.ir()));\n-            var builderOp = OpBuilder.createBuilderFunction(funcOp);\n-            var builtOp = (Op) Interpreter.invoke(builderOp, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n-            Assert.assertEquals(builtOp.toText(), opFieldAndIR.ir());\n-\n-            cd = BytecodeGenerator.addOpByteCodeToClassFile(MethodHandles.lookup(), cm, opFieldAndIR.fieldName(), builderOp);\n-            cm = cf.parse(cd);\n-            Assert.assertEquals(cm.methods().stream().filter(mm -> mm.methodName().equalsString(opFieldAndIR.fieldName())).count(),\n-                    opFieldsAndIRs.size());\n-\n-            var l = MethodHandles.lookup().defineHiddenClass(cd, true);\n+            var opFieldName = opFieldAndIR.opField().name().stringValue();\n+            var methodName = opFieldAndIR.opField().name().stringValue().substring(opFieldName.indexOf(':') + 2);\n+            var functionType = FunctionType.functionType(JavaType.type(Op.class), JavaType.type(OpFactory.class),\n+                    JavaType.type(TypeElementFactory.class));\n@@ -85,2 +122,2 @@\n-                    opFieldAndIR.fieldName(),\n-                    MethodRef.toNominalDescriptor(builderOp.invokableType()).resolveConstantDesc(l));\n+                    methodName,\n+                    MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(l));\n@@ -91,1 +128,0 @@\n-        print(cm);\n@@ -102,1 +138,2 @@\n-    record OpFieldAndIR(String fieldName, String ir) {}\n+    record OpFieldAndIR(FieldRefEntry opField, String ir) {\n+    }\n@@ -105,1 +142,1 @@\n-        List<OpFieldAndIR> res = new ArrayList<>();\n+        var res = new ArrayList<OpFieldAndIR>();\n@@ -114,1 +151,1 @@\n-                res.add(new OpFieldAndIR(fi.name().stringValue().substring(fi.name().stringValue().indexOf(':') + 2), pe.stringValue()));\n+                res.add(new OpFieldAndIR(fi.field(), pe.stringValue()));\n@@ -120,43 +157,0 @@\n-\n-    @Test\n-    void testRemovingOpField() {\n-        var bytes = removeOpFields(CLASS_MODEL);\n-        var cm = ClassFile.of().parse(bytes);\n-        Assert.assertFalse(cm.fields().stream().anyMatch(fm -> fm.fieldName().stringValue().endsWith(\"$op\")\n-                && fm.fieldType().equalsString(\"String\")));\n-        for (PoolEntry poolEntry : cm.constantPool()) {\n-            Assert.assertFalse(poolEntry instanceof StringEntry se && se.stringValue().startsWith(\"func @\"));\n-        }\n-    }\n-\n-    private byte[] removeOpFields(ClassModel cm) {\n-        var bytes = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(cm,\n-                ClassTransform.dropping(e -> e instanceof FieldModel fm && fm.fieldName().stringValue().endsWith(\"$op\")).andThen(\n-                        ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME), (mb, me) -> {\n-                            if (me instanceof CodeModel com) {\n-                                mb.withCode(cob -> {\n-                                    ConstantInstruction.LoadConstantInstruction ldc = null;\n-                                    for (CodeElement e : com) {\n-                                        if (ldc != null && e instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC && fi.owner().equals(cm.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n-                                            ldc = null;\n-                                        } else {\n-                                            if (ldc != null) {\n-                                                cob.with(ldc);\n-                                                ldc = null;\n-                                            }\n-                                            switch (e) {\n-                                                case ConstantInstruction.LoadConstantInstruction lci when lci.constantEntry() instanceof StringEntry ->\n-                                                        ldc = lci;\n-                                                case LineNumber _, CharacterRange _, LocalVariable _, LocalVariableType _ -> {\n-                                                }\n-                                                default -> cob.with(e);\n-                                            }\n-                                        }\n-                                    }\n-                                });\n-                            } else {\n-                                mb.with(me);\n-                            }\n-                        })));\n-        return bytes;\n-    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOpMethod.java","additions":64,"deletions":70,"binary":false,"changes":134,"status":"modified"}]}