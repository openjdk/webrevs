{"files":[{"patch":"@@ -1,5 +0,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n@@ -13,0 +8,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -16,0 +12,1 @@\n+import java.lang.reflect.code.interpreter.Interpreter;\n@@ -21,0 +18,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -26,6 +25,0 @@\n-\/*\n- * @test\n- * @enablePreview\n- * @run testng TestOpMethod\n- *\n- *\/\n@@ -34,15 +27,10 @@\n-\/\/    We discussed replacing the mechanism to store models in class files.\n-\/\/    Currently, we serialize to the textual form.\n-\/\/    We want to explore replacing that with methods in class files that build and return models.\n-\/\/    See the test TestCodeBuilder and familiarize yourself with that.\n-\/\/    It's likely that transformation code is buggy because it has not been tested on a wide range of source.\n-\/\/    It would also be interesting to get some size comparison between the two approaches.\n-\/\/    To properly do this we will need to avoid the copying of code from java.base into jdk.compiler,\n-\/\/    otherwise we need to copy more code and there are certain restrictions on what features the code can use.\n-\/\/    Maurizio is looking into that.\n-\/\/    There may be an interim solution before moving the code to an incubating model. We should discuss more in our meetings.\n-\/\/    One way to explore sooner for experimentation purposes to write a class file transformer using the Classfile API\n-\/\/    and rewrite the class file replacing code models in textual form with the corresponding methods.\n-\/\/    That's more challenging when reflecting over lambda bodies, but should more feasible when reflecting over method bodies.\n-\n-    static ClassModel CLASS_MODEL;\n+    public static void main(String[] args) throws IOException, ClassNotFoundException {\n+        for (var arg : args) {\n+            var path = Path.of(arg);\n+            var originalBytes = Files.readAllBytes(path);\n+            var newBytes = TestOpMethod.replaceOpFieldWithBuilderMethod(originalBytes);\n+            System.out.printf(\"%s %d %d%n\", arg, originalBytes.length, newBytes.length);\n+            \/\/ TODO a script that runs the tool for many classes\n+            \/\/ TODO reduce size if possible\n+        }\n+    }\n@@ -50,3 +38,2 @@\n-    @BeforeClass\n-    static void setup() throws IOException {\n-        CLASS_MODEL = ClassFile.of().parse(IR.class.getResourceAsStream(\"IR.class\").readAllBytes());\n+    static byte[] replaceOpFieldWithBuilderMethod(byte[] classData) {\n+        return replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n@@ -55,9 +42,1 @@\n-    @DataProvider\n-    byte[][] classes() {\n-        try {\n-            return new byte[][]{\n-                    IR.class.getResourceAsStream(\"IR.class\").readAllBytes()\n-            };\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n+    record OpFieldAndIR(FieldRefEntry opField, String ir) {\n@@ -99,0 +78,1 @@\n+                testBuilderOp(builderOp, opFieldAndIR.ir());\n@@ -100,1 +80,1 @@\n-                var methodName = opFieldAndIR.opField().name().stringValue().substring(opFieldName.indexOf(':') + 2);\n+                var methodName = builderMethodName(opFieldName);\n@@ -107,1 +87,8 @@\n-        return ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(classModel, classTransform);\n+        var newBytes = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL).transformClass(classModel, classTransform);\n+        testBuilderMethods(newBytes, opFieldsAndIRs);\n+        return newBytes;\n+    }\n+\n+    static void testBuilderOp(FuncOp builderOp, String expectedIR) {\n+        var op = (Op) Interpreter.invoke(builderOp, ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+        assert expectedIR.equals(op.toText());\n@@ -110,6 +97,7 @@\n-    @Test(dataProvider = \"classes\")\n-    void test(byte[] classData) throws Throwable {\n-        var bytes = replaceOpFieldWithBuilderMethod(ClassFile.of().parse(classData));\n-        print(bytes);\n-        var opFieldsAndIRs = getOpFieldsAndIRs(ClassFile.of().parse(classData));\n-        MethodHandles.Lookup l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+    static void testBuilderMethods(byte[] classData, List<OpFieldAndIR> opFieldsAndIRs) {\n+        MethodHandles.Lookup lookup = null;\n+        try {\n+            lookup = MethodHandles.lookup().defineHiddenClass(classData, true);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n@@ -118,1 +106,1 @@\n-            var methodName = opFieldAndIR.opField().name().stringValue().substring(opFieldName.indexOf(':') + 2);\n+            var methodName = builderMethodName(opFieldName);\n@@ -121,6 +109,15 @@\n-            var mh = l.findStatic(l.lookupClass(),\n-                    methodName,\n-                    MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(l));\n-            Assert.assertEquals(\n-                    ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY)).toText(),\n-                    opFieldAndIR.ir());\n+            MethodHandle mh = null;\n+            try {\n+                mh = lookup.findStatic(lookup.lookupClass(),\n+                        methodName,\n+                        MethodRef.toNominalDescriptor(functionType).resolveConstantDesc(lookup));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+            Op builtOp = null;\n+            try {\n+                builtOp = ((Op) mh.invoke(ExtendedOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY));\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            assert builtOp.toText().equals(opFieldAndIR.ir());\n@@ -130,0 +127,5 @@\n+    static String builderMethodName(String opFieldName) {\n+        \/\/ e.g. A::add(int, int)int$op ---> add(int, int)int$op\n+        return opFieldName.substring(opFieldName.indexOf(':') + 2);\n+    }\n+\n@@ -137,20 +139,0 @@\n-\n-    record OpFieldAndIR(FieldRefEntry opField, String ir) {\n-    }\n-\n-    List<OpFieldAndIR> getOpFieldsAndIRs(ClassModel cm) {\n-        var res = new ArrayList<OpFieldAndIR>();\n-        var cinit = cm.methods().stream().filter(mm -> mm.methodName().equalsString(ConstantDescs.CLASS_INIT_NAME))\n-                .findFirst().orElseThrow();\n-        CodeElement prev = null;\n-        for (CodeElement curr : cinit.code().get().elementList()) {\n-            if (curr instanceof FieldInstruction fi && fi.opcode() == Opcode.PUTSTATIC\n-                    && fi.owner().equals(cm.thisClass()) && fi.name().stringValue().endsWith(\"$op\")) {\n-                if (prev instanceof ConstantInstruction.LoadConstantInstruction lci && lci.constantEntry() instanceof StringEntry se) {\n-                    res.add(new OpFieldAndIR(fi.field(), se.stringValue()));\n-                }\n-            }\n-            prev = curr;\n-        }\n-        return res;\n-    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestOpMethod.java","additions":55,"deletions":73,"binary":false,"changes":128,"status":"modified"}]}