{"files":[{"patch":"@@ -150,20 +150,12 @@\n-        Value source = hatVectorLoadOp.operands().get(0);\n-        Value index = hatVectorLoadOp.operands().get(1);\n-\n-        vload(hatVectorLoadOp.vectorN())\n-                .oparen()\n-                .intConstZero()\n-                .comma()\n-                .space()\n-                .ampersand();\n-\n-        if (source instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-\n-        either(hatVectorLoadOp.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n-        identifier(\"array\").osbrace();\n-        if (index instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-        csbrace().cparen();\n+        vload(hatVectorLoadOp.vectorN()).paren(_-> {\n+            intConstZero().comma().space().ampersand();\n+            if (hatVectorLoadOp.operands().get(0) instanceof Op.Result r) {\n+                recurse(buildContext, r.op());\n+            }\n+            either(hatVectorLoadOp.isSharedOrPrivate(), CodeBuilder::dot, CodeBuilder::rarrow);\n+            identifier(\"array\").sbrace(_ -> {\n+                if (hatVectorLoadOp.operands().get(1) instanceof Op.Result r) {\n+                    recurse(buildContext, r.op());\n+                }\n+            });\n+        });\n@@ -196,1 +188,1 @@\n-        } else {\n+        } else\n@@ -198,2 +190,2 @@\n-            Value storeValue = hatVSelectStoreOp.operands().get(1);\n-            if (storeValue instanceof Op.Result r) {\n+          \/\/  Value storeValue = hatVSelectStoreOp.operands().get(1);\n+            if (hatVSelectStoreOp.operands().get(1) instanceof  Op.Result r) {\n@@ -202,1 +194,1 @@\n-        }\n+\n@@ -210,19 +202,21 @@\n-        oparen();\n-        if (reducedFloatType instanceof ReducedFloatType.HalfFloat) {\n-            halfType();\n-        } else if (reducedFloatType instanceof ReducedFloatType.BFloat16) {\n-            bfloatType();\n-        }\n-\n-        cparen().obrace();\n-        if (reducedFloatType instanceof ReducedFloatType.BFloat16) {\n-            builtin_float2bfloat16().oparen();\n-        }\n-        Value initValue = hatF16ConvOp.operands().getFirst();\n-        if (initValue instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-        if (reducedFloatType instanceof ReducedFloatType.BFloat16) {\n-            cparen();\n-        }\n-        cbrace();\n+        paren(_->{\n+           if (reducedFloatType instanceof ReducedFloatType.HalfFloat) {\n+               halfType();\n+           } else if (reducedFloatType instanceof ReducedFloatType.BFloat16) {\n+               bfloatType();\n+           } else{\n+               throw new RuntimeException(\"What is ths reducedType\");\n+           }\n+        });\n+\n+        brace(_-> {\n+            if (reducedFloatType instanceof ReducedFloatType.BFloat16) {\n+                builtin_float2bfloat16().oparen();\n+            }\n+            if (hatF16ConvOp.operands().getFirst()  instanceof Op.Result r) {\n+                recurse(buildContext, r.op());\n+            }\n+            if (reducedFloatType instanceof ReducedFloatType.BFloat16) {\n+                cparen();\n+            }\n+        });\n@@ -238,3 +232,1 @@\n-\n-        Value operand = hatVectorVarOp.operands().getFirst();\n-        if (operand instanceof Op.Result r) {\n+        if (hatVectorVarOp.operands().getFirst() instanceof Op.Result r) {\n@@ -248,2 +240,1 @@\n-        oparen().identifier(hatVectorOfOp.buildType()).cparen().oparen();\n-        return self();\n+        return paren(_->identifier(hatVectorOfOp.buildType()));\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":39,"deletions":48,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -173,4 +173,1 @@\n-        } else {\n-            \/\/ otherwise, we traverse to resolve the expression\n-            Value storeValue = hatVSelectStoreOp.operands().get(1);\n-            if (storeValue instanceof Op.Result r) {\n+        } else if (hatVSelectStoreOp.operands().get(1) instanceof Op.Result r) {\n@@ -178,1 +175,1 @@\n-            }\n+\n@@ -185,3 +182,2 @@\n-        oparen().typeName(\"half\").cparen();\n-        Value initValue = hatF16ConvOp.operands().getFirst();\n-        if (initValue instanceof Op.Result r) {\n+        paren(_->typeName(\"half\"));\n+        if (hatF16ConvOp.operands().getFirst() instanceof Op.Result r) {\n@@ -209,2 +205,1 @@\n-        oparen().identifier(hatVectorOfOp.buildType()).cparen().oparen();\n-        return self();\n+        return paren(_->identifier(hatVectorOfOp.buildType()));\n@@ -215,3 +210,1 @@\n-        oparen().halfType().cparen();\n-        identifier(hatF16ToFloatConvOp.varName());\n-        return self();\n+        return paren(_->halfType()).identifier(hatF16ToFloatConvOp.varName());\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -362,1 +362,0 @@\n-\n@@ -367,1 +366,0 @@\n-\n@@ -372,24 +370,22 @@\n-        oparen().halfType();\n-\n-        cparen().obrace().oparen();\n-        if (op1 instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-        if (references.getFirst()) {\n-            rarrow().identifier(\"value\");\n-        } else if (op1 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n-            dot().identifier(\"value\");\n-        }\n-        space().identifier(hatF16BinaryOp.binaryOperationType().symbol()).space();\n-\n-        if (op2 instanceof Op.Result r) {\n-            recurse(buildContext, r.op());\n-        }\n-\n-        if (references.get(1)) {\n-            rarrow().identifier(\"value\");\n-        } else if (op2 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n-            dot().identifier(\"value\");\n-        }\n-\n-        cparen().cbrace();\n+        paren(_-> halfType());\n+        brace(_-> {\n+            paren(_-> {\n+                if (op1 instanceof Op.Result r) {\n+                    recurse(buildContext, r.op());\n+                }\n+                if (references.getFirst()) {\n+                    rarrow().identifier(\"value\");\n+                } else if (op1 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n+                    dot().identifier(\"value\");\n+                }\n+                space().identifier(hatF16BinaryOp.binaryOperationType().symbol()).space();\n+                if (op2 instanceof Op.Result r) {\n+                    recurse(buildContext, r.op());\n+                }\n+                if (references.get(1)) {\n+                    rarrow().identifier(\"value\");\n+                } else if (op2 instanceof Op.Result r && !(r.op().resultType() instanceof PrimitiveType)) {\n+                    dot().identifier(\"value\");\n+                }\n+            });\n+        });\n@@ -401,3 +397,1 @@\n-        identifier(hatF16VarLoadOp.varName());\n-        dot().identifier(\"value\");\n-        return self();\n+        return identifier(hatF16VarLoadOp.varName()).dot().identifier(\"value\");\n@@ -416,18 +410,7 @@\n-        genVectorIdentifier(buildContext, hatVectorOp);\n-\n-        List<Value> inputOperands = hatVectorOp.operands();\n-        int i;\n-        for (i = 0; i < (inputOperands.size() - 1); i++) {\n-            var operand = inputOperands.get(i);\n-            if ((operand instanceof Op.Result r)) {\n-                recurse(buildContext, r.op());\n-            }\n-            comma().space();\n-        }\n-        \/\/ Last parameter\n-        var operand = inputOperands.get(i);\n-        if ((operand instanceof Op.Result r)) {\n-            recurse(buildContext, r.op());\n-        }\n-        cparen();\n-        return self();\n+        return genVectorIdentifier(buildContext, hatVectorOp)\n+                .paren(_->separated(\n+                        hatVectorOp.operands(),\/\/.stream().map(operand->(Op.Result)operand),\n+                        _ -> commaSpace(),\n+                        (operand) -> recurse(buildContext, OpTk.asResultOrThrow(operand).op())\n+                        )\n+                );\n@@ -438,7 +421,7 @@\n-        suffix_t(hatPrivateInitVarOp.classType()).space().identifier(hatPrivateInitVarOp.varName());\n-        space().equals().space();\n-        Value operand = hatPrivateInitVarOp.operands().getFirst();\n-        if (operand instanceof Op.Result r) {\n-            recurse(builderContext, r.op());\n-        }\n-        return self();\n+        return suffix_t(hatPrivateInitVarOp.classType())\n+                .space()\n+                .identifier(hatPrivateInitVarOp.varName())\n+                .space()\n+                .equals()\n+                .space()\n+                .recurse(builderContext,OpTk.asResultOrThrow(hatPrivateInitVarOp.operands().getFirst()).op());\n@@ -449,22 +432,5 @@\n-        List<Value> operands = hatMemoryLoadOp.operands();\n-        Value base = operands.get(0);\n-        if (base instanceof Op.Result r) {\n-           recurse(builderContext, r.op());\n-        }\n-        dot().identifier(hatMemoryLoadOp.memberName());\n-\n-        if (operands.size() > 1) {\n-            \/\/ If the hatMemoryLoadOp has more than 1 operand,\n-            \/\/ then we know that the second operand represents\n-            \/\/ an index to access an array, since members, otherwise,\n-            \/\/ will be accessed via structVarName.member1.member2.member3...,  etc.\n-\n-            \/\/ The following code generates [ indexValue ]\n-            osbrace();\n-            Value index = operands.get(1);\n-            if (index instanceof Op.Result r) {\n-                recurse(builderContext, r.op());\n-            }\n-            csbrace();\n-        }\n-        return self();\n+        return recurse(builderContext, OpTk.asResultOrThrow(hatMemoryLoadOp.operands().getFirst()).op())\n+                .dot().identifier(hatMemoryLoadOp.memberName())\n+                .when(hatMemoryLoadOp.operands().size() > 1,_->\/\/ If the hatMemoryLoadOp has more than 1 operand, the second is the index\n+                   sbrace(_-> recurse(builderContext, OpTk.asResultOrThrow(hatMemoryLoadOp.operands().get(1)).op()))\n+                );\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":42,"deletions":76,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -553,0 +553,8 @@\n+    public static Op.Result asResultOrThrow(Value value) {\n+        if (value instanceof Op.Result r) {\n+           return r;\n+        }else{\n+            throw new RuntimeException(\"Value not a result\");\n+        }\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}