{"files":[{"patch":"@@ -72,4 +72,3 @@\n-    final MethodHandle quotableOpField;       \/\/ A getter method handle that is used to retrieve the\n-                                              \/\/ string representation of the quotable lambda's associated\n-                                              \/\/ intermediate representation (can be null).\n-    final MethodHandleInfo quotableOpFieldInfo;  \/\/ Info about the quotable getter method handle (can be null).\n+    final MethodHandle quotableOpGetter;       \/\/ A getter method handle that is used to retrieve the\n+                                              \/\/ the quotable lambda's associated intermediate representation (can be null).\n+    final MethodHandleInfo quotableOpGetterInfo;  \/\/ Info about the quotable getter method handle (can be null).\n@@ -190,1 +189,1 @@\n-        this.quotableOpField = reflectiveField;\n+        this.quotableOpGetter = reflectiveField;\n@@ -220,1 +219,1 @@\n-                quotableOpFieldInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+                quotableOpGetterInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n@@ -224,3 +223,2 @@\n-            if (quotableOpFieldInfo.getReferenceKind() != REF_getField &&\n-                    quotableOpFieldInfo.getReferenceKind() != REF_getStatic) {\n-                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpFieldInfo));\n+            if (quotableOpGetterInfo.getReferenceKind() != REF_invokeStatic) {\n+                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpGetterInfo));\n@@ -229,1 +227,1 @@\n-            quotableOpFieldInfo = null;\n+            quotableOpGetterInfo = null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-                if (quotableOpField != null) {\n+                if (quotableOpGetter != null) {\n@@ -370,1 +370,1 @@\n-                if (quotableOpField != null) {\n+                if (quotableOpGetter != null) {\n@@ -381,2 +381,2 @@\n-            if (useImplMethodHandle || quotableOpField != null) {\n-                classdata = quotableOpField == null ?\n+            if (useImplMethodHandle || quotableOpGetter != null) {\n+                classdata = quotableOpGetter == null ?\n@@ -384,1 +384,1 @@\n-                        List.of(implementation, quotableOpField, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n+                        List.of(implementation, quotableOpGetter, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n@@ -437,1 +437,1 @@\n-                        if (quotableOpField != null) {\n+                        if (quotableOpGetter != null) {\n@@ -454,2 +454,2 @@\n-        MethodType mtype = quotableOpFieldInfo.getMethodType();\n-        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+        MethodType mtype = quotableOpGetterInfo.getMethodType();\n+        if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n@@ -475,1 +475,1 @@\n-        \/\/ now create a Quoted from String and captured args Object[]\n+        \/\/ Create a Quoted from FuncOp and captured args Object[]\n@@ -489,6 +489,5 @@\n-                QUOTED_CLASS = layer.findLoader(\"jdk.incubator.code\")\n-                        .loadClass(\"jdk.incubator.code.Quoted\");\n-                QUOTABLE_CLASS = layer.findLoader(\"jdk.incubator.code\")\n-                        .loadClass(\"jdk.incubator.code.Quotable\");\n-                Class<?> quotedHelper = layer.findLoader(\"jdk.incubator.code\")\n-                        .loadClass(\"jdk.incubator.code.internal.QuotedHelper\");\n+                ClassLoader cl = layer.findLoader(\"jdk.incubator.code\");\n+                QUOTED_CLASS = cl.loadClass(\"jdk.incubator.code.Quoted\");\n+                QUOTABLE_CLASS = cl.loadClass(\"jdk.incubator.code.Quotable\");\n+                Class<?> quotedHelper = cl.loadClass(\"jdk.incubator.code.internal.QuotedHelper\");\n+                Class<?> funcOp = cl.loadClass(\"jdk.incubator.code.op.CoreOp$FuncOp\");\n@@ -496,1 +495,1 @@\n-                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, String.class, Object[].class));\n+                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, funcOp, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -503,1 +503,2 @@\n-        MethodHandle quotableField = null;\n+        \/\/ Getter that returns the op of a Quotable instance\n+        MethodHandle quotableOpGetter = null;\n@@ -525,1 +526,1 @@\n-            quotableField = extractArg(args, argIndex++, MethodHandle.class);\n+            quotableOpGetter = extractArg(args, argIndex++, MethodHandle.class);\n@@ -554,1 +555,1 @@\n-                                                  quotableField);\n+                                                  quotableOpGetter);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -882,2 +882,2 @@\n-                VarSymbol reflectField = (VarSymbol)tree.codeModel;\n-                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+                MethodSymbol opMethodSym = tree.codeModel;\n+                staticArgs = staticArgs.append(opMethodSym.asHandle());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-        public Symbol codeModel;\n+        public MethodSymbol codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-        String opMethodName = \"method$op$\" + new String(sig);\n+        String opMethodName = \"op$\" + new String(sig);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.incubator.code.parser.OpParser;\n@@ -166,3 +167,9 @@\n-                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n-                            .withFlags(ClassFile.ACC_STATIC)\n-                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                    \/\/ return (FuncOp) OpParser.fromOpString(opText)\n+                    clb.withMethod(\"op$lambda$\" + i, MethodTypeDesc.of(FuncOp.class.describeConstable().get()),\n+                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n+                                .loadConstant(quote(lop).toText())\n+                                .invoke(Opcode.INVOKESTATIC, OpParser.class.describeConstable().get(),\n+                                        \"fromStringOfFuncOp\",\n+                                        MethodTypeDesc.of(Op.class.describeConstable().get(), CD_String), false)\n+                                .checkcast(FuncOp.class.describeConstable().get())\n+                                .areturn()));\n@@ -894,4 +901,4 @@\n-                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER,\n-                                                                 className,\n-                                                                 \"lambda$\" + lambdaIndex + \"$op\",\n-                                                                 CD_String)));\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                className,\n+                                                \"op$lambda$\" + lambdaIndex,\n+                                                MethodTypeDesc.of(FuncOp.class.describeConstable().get()))));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-    public static Quoted makeQuoted(MethodHandles.Lookup lookup, String opText, Object[] args) {\n-        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n+    public static Quoted makeQuoted(MethodHandles.Lookup lookup, FuncOp op, Object[] args) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/QuotedHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -256,4 +256,3 @@\n-                \/\/ create a static final field holding the op' string text.\n-                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n-                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n-                classOps.add(opField);\n+                \/\/ create a static method that returns the FuncOp representing the lambda\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                classOps.add(opMethod);\n@@ -265,1 +264,1 @@\n-                        JCIdent opFieldId = make.Ident(opField.sym);\n+                        JCIdent opMethodId = make.Ident(opMethod.sym);\n@@ -272,2 +271,2 @@\n-                        JCMethodInvocation parsedOp = make.App(make.Ident(crSyms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n-                        interpreterArgs.append(parsedOp);\n+                        JCMethodInvocation op = make.App(opMethodId);\n+                        interpreterArgs.append(op);\n@@ -286,1 +285,1 @@\n-                        tree.codeModel = opField.sym;\n+                        tree.codeModel = opMethod.sym;\n@@ -318,5 +317,4 @@\n-                \/\/ create a static final field holding the op' string text.\n-                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n-                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n-                classOps.add(opField);\n-                tree.codeModel = opField.sym;\n+                \/\/ create a method that returns the FuncOp representing the lambda\n+                JCMethodDecl opMethod = opMethodDecl(lambdaName(), funcOp);\n+                classOps.add(opMethod);\n+                tree.codeModel = opMethod.sym;\n@@ -393,12 +391,0 @@\n-    private JCVariableDecl opFieldDecl(Name prefix, long flags, CoreOp.FuncOp op) {\n-        VarSymbol opFieldSym = new VarSymbol(flags | Flags.STATIC | Flags.FINAL | Flags.SYNTHETIC,\n-                prefix.append('$', names.fromString(\"op\")),\n-                syms.stringType,\n-                currentClassSym);\n-\n-        currentClassSym.members().enter(opFieldSym);\n-        JCLiteral opText = make.Literal(op.toText());\n-        JCVariableDecl opFieldTree = make.VarDef(opFieldSym, opText);\n-        return opFieldTree;\n-    }\n-\n@@ -408,1 +394,1 @@\n-        var mn = names.fromString(\"method$op$\").append(methodName);\n+        var mn = names.fromString(\"op$\").append(methodName);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"}]}