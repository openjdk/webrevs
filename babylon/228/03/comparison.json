{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -31,6 +33,0 @@\n-import java.lang.constant.*;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.CoreOp.*;\n-\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassModel;\n@@ -40,0 +36,7 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.Constable;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -41,2 +44,0 @@\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Op;\n@@ -46,0 +47,7 @@\n+import java.lang.invoke.StringConcatFactory;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.TypeElement;\n@@ -48,0 +56,2 @@\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.CoreOp.*;\n@@ -50,1 +60,0 @@\n-import java.lang.reflect.code.type.MethodRef;\n@@ -53,1 +62,2 @@\n-import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n@@ -55,0 +65,1 @@\n+import java.util.ArrayDeque;\n@@ -57,0 +68,1 @@\n+import java.util.Deque;\n@@ -58,0 +70,1 @@\n+import java.util.HashSet;\n@@ -61,10 +74,0 @@\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import java.lang.invoke.StringConcatFactory;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-import java.util.HashSet;\n@@ -74,0 +77,2 @@\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -326,1 +331,1 @@\n-        processOperand(op.operands().getFirst());;\n+        processOperand(op.operands().getFirst());\n@@ -821,2 +826,1 @@\n-                            processOperands(op);\n-                            cob.ifThenElse(prepareReverseCondition(op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                            cob.ifThenElse(prepareConditionalBranch(op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n@@ -1038,2 +1042,1 @@\n-                        processOperands(btop);\n-                        conditionalBranch(btop, op.trueBranch(), op.falseBranch());\n+                        conditionalBranch(prepareConditionalBranch(btop), op.trueBranch(), op.falseBranch());\n@@ -1041,2 +1044,2 @@\n-                        processOperands(op);\n-                        conditionalBranch(Opcode.IFEQ, op, op.trueBranch(), op.falseBranch());\n+                        processFirstOperand(op);\n+                        conditionalBranch(Opcode.IFEQ, op.trueBranch(), op.falseBranch());\n@@ -1148,5 +1151,1 @@\n-    private void conditionalBranch(BinaryTestOp op, Block.Reference trueBlock, Block.Reference falseBlock) {\n-        conditionalBranch(prepareReverseCondition(op), op, trueBlock, falseBlock);\n-    }\n-\n-    private void conditionalBranch(Opcode reverseOpcode, Op op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+    private void conditionalBranch(Opcode reverseOpcode, Block.Reference trueBlock, Block.Reference falseBlock) {\n@@ -1166,2 +1165,31 @@\n-    private Opcode prepareReverseCondition(BinaryTestOp op) {\n-        return switch (toTypeKind(op.operands().get(0).type())) {\n+    private Opcode prepareConditionalBranch(BinaryTestOp op) {\n+        Value firstOperand = op.operands().get(0);\n+        TypeKind typeKind = toTypeKind(firstOperand.type());\n+        Value secondOperand = op.operands().get(1);\n+        processOperand(firstOperand);\n+        if (isZeroIntOrNullConstant(secondOperand)) {\n+            return switch (typeKind) {\n+                case IntType, BooleanType, ByteType, ShortType, CharType ->\n+                    switch (op) {\n+                        case EqOp _ -> Opcode.IFNE;\n+                        case NeqOp _ -> Opcode.IFEQ;\n+                        case GtOp _ -> Opcode.IFLE;\n+                        case GeOp _ -> Opcode.IFLT;\n+                        case LtOp _ -> Opcode.IFGE;\n+                        case LeOp _ -> Opcode.IFGT;\n+                        default ->\n+                            throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                    };\n+                case ReferenceType ->\n+                    switch (op) {\n+                        case EqOp _ -> Opcode.IFNONNULL;\n+                        case NeqOp _ -> Opcode.IFNULL;\n+                        default ->\n+                            throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                    };\n+                default ->\n+                    throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+            };\n+        }\n+        processOperand(secondOperand);\n+        return switch (typeKind) {\n@@ -1203,0 +1231,14 @@\n+    private boolean isZeroIntOrNullConstant(Value v) {\n+        return v instanceof Op.Result or\n+                && or.op() instanceof ConstantOp cop\n+                && switch (cop.value()) {\n+                    case null -> true;\n+                    case Integer i -> i == 0;\n+                    case Boolean b -> !b;\n+                    case Byte b -> b == 0;\n+                    case Short s -> s == 0;\n+                    case Character ch -> ch == 0;\n+                    default -> false;\n+                };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":76,"deletions":34,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import java.util.BitSet;\n@@ -76,2 +77,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.util.BitSet;\n@@ -81,2 +80,0 @@\n-    public static boolean DUMP = false; \/\/ @@@ only for debugging purpose\n-\n@@ -112,1 +109,1 @@\n-    private final LocalsTypeMapper codeTracker;\n+    private final LocalsToVarMapper localsToVarMapper;\n@@ -114,0 +111,1 @@\n+    private final Map<LocalsToVarMapper.Variable, Value> varToValueMap;\n@@ -128,0 +126,1 @@\n+        this.varToValueMap = new HashMap<>();\n@@ -140,1 +139,1 @@\n-        this.codeTracker = new LocalsTypeMapper(classModel.thisClass().asSymbol(), initLocalTypes, codeModel.exceptionHandlers(), smta, elements, codeAttribtue);\n+        this.localsToVarMapper = new LocalsToVarMapper(classModel.thisClass().asSymbol(), initLocalTypes, codeModel.exceptionHandlers(), smta, elements);\n@@ -325,5 +324,5 @@\n-        for (int i = 0; i < codeTracker.slotsToInitialize.size(); i++) {\n-            LocalsTypeMapper.Slot sl = codeTracker.slotsToInitialize.get(i);\n-            if (sl != null) {\n-                if (sl.var.isSingleValue) {\n-                    sl.var.value = initLocalValues.get(i);\n+        for (int i = 0; i < localsToVarMapper.slotsToInit(); i++) {\n+            LocalsToVarMapper.Variable v = localsToVarMapper.initSlotVar(i);\n+            if (v != null) {\n+                if (v.hasSingleAssignment()) {\n+                    varToValueMap.put(v, initLocalValues.get(i)); \/\/ Single value var initialized with entry block parameter\n@@ -331,1 +330,5 @@\n-                    sl.var.value = op(CoreOp.var(\"slot#\" + i, sl.var.type(), i < initLocalValues.size() ? initLocalValues.get(i) : liftConstant(sl.var.defaultValue())));\n+                    varToValueMap.put(v, op(CoreOp.var(\"slot#\" + i, \/\/ New var with slot# name\n+                                                       JavaType.type(v.type()), \/\/ Type calculated by LocalsToVarMapper\n+                                                       i < initLocalValues.size()\n+                                                               ? initLocalValues.get(i) \/\/ Initialized with entry block parameter\n+                                                               : liftDefaultValue(v.type())))); \/\/ Initialized with default\n@@ -820,4 +823,5 @@\n-        LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n-        if (var.isSingleValue) {\n-            assert var.value != null;\n-            return var.value;\n+        LocalsToVarMapper.Variable var = localsToVarMapper.instructionVar(i);\n+        if (var.hasSingleAssignment()) {\n+            Value value = varToValueMap.get(var);\n+            assert value != null: \"Uninitialized single-value variable\";\n+            return value;\n@@ -825,2 +829,3 @@\n-            assert var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n-            return op(CoreOp.varLoad(var.value));\n+            Value value = varToValueMap.get(var);\n+            assert value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp: \"Invalid variable reference\";\n+            return op(CoreOp.varLoad(value));\n@@ -831,4 +836,4 @@\n-        LocalsTypeMapper.Variable var = codeTracker.getVarOf(i);\n-        if (var.isSingleValue) {\n-            assert var.value == null;\n-            var.value = value;\n+        LocalsToVarMapper.Variable var = localsToVarMapper.instructionVar(i);\n+        if (var.hasSingleAssignment()) {\n+            Value expectedNull = varToValueMap.put(var, value);\n+            assert expectedNull == null: \"Multiple assignements to a single-value variable\";\n@@ -836,6 +841,11 @@\n-            if (var.value == null) {\n-                var.value = op(CoreOp.var(\"slot#\" + slot, var.type(), value));\n-            } else {\n-                assert var.value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp;\n-                op(CoreOp.varStore(var.value, value));\n-            }\n+            varToValueMap.compute(var, (_, varOpResult) -> {\n+                if (varOpResult == null) {\n+                    return op(CoreOp.var(\"slot#\" + slot,  \/\/ Initial variable declaration with slot# name\n+                                         JavaType.type(var.type()), \/\/ Type calculated by LocalsToVarMapper\n+                                         value));\n+                } else {\n+                    assert varOpResult instanceof Op.Result r && r.op() instanceof CoreOp.VarOp: \"Invalid variable reference\";\n+                    op(CoreOp.varStore(varOpResult, value)); \/\/ Store into an existig variable\n+                    return varOpResult;\n+                }\n+            });\n@@ -857,0 +867,15 @@\n+    private Op.Result liftDefaultValue(ClassDesc type) {\n+        return liftConstant(switch (TypeKind.from(type)) {\n+            case BooleanType -> false;\n+            case ByteType -> (byte)0;\n+            case CharType -> (char)0;\n+            case DoubleType -> 0d;\n+            case FloatType -> 0f;\n+            case IntType -> 0;\n+            case LongType -> 0l;\n+            case ReferenceType -> null;\n+            case ShortType -> (short)0;\n+            default -> throw new IllegalStateException(\"Invalid type \" + type.displayName());\n+        });\n+    }\n+\n@@ -979,2 +1004,1 @@\n-       var vt = valueType(otherOperand);\n-        return vt.equals(PrimitiveType.BOOLEAN) ? liftConstant(false) : liftConstant(0);\n+        return liftDefaultValue(BytecodeGenerator.toClassDesc(otherOperand.type()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":54,"deletions":30,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -54,1 +54,47 @@\n- * LocalsCompactor is a CodeTransform reducing maxLocals.\n+ * LocalsCompactor transforms class to reduce allocation of local slots in the Code attribute (max_locals).\n+ * It collects slot maps, compacts them and transforms the Code attribute accordingly.\n+ * <p>\n+ * Example of maps before compaction (max_locals = 13):\n+ * <pre>\n+ *  slots:  0   1   2   3   4   5   6   7   8   9   10  11  12  13\n+ *  ---------------------------------------------------------------\n+ *  bci 0:  *   *\n+ *      8:      *   *   *\n+ *     10:      *   *   *\n+ *     15:      *   *   *   *   *\n+ *     17:      *   *   *   *   *\n+ *     18:      *           *   *\n+ *     25:      *                   *   *\n+ *     27:      *                   *   *\n+ *     32:      *                   *   *   *   *\n+ *     34:      *                   *   *   *   *\n+ *     36:      *                           *   *\n+ *     43:      *                                   *   *\n+ *     45:      *                                   *   *\n+ *     50:                                          *   *   *   *\n+ *     52:                                          *   *   *   *\n+ *     54:                                                  *   *\n+ * <\/pre>\n+ * Compact form of the same maps (max_locals = 5):\n+ * <pre>\n+ *  slots:   0   1   2   3   4   5\n+ *         +12 +13  +6  +7  +8  +9\n+ *                 +10 +11\n+ *  -------------------------------\n+ *  bci 0:  *   *\n+ *      8:      *   *   *\n+ *     10:      *   *   *\n+ *     15:      *   *   *   *   *\n+ *     17:      *   *   *   *   *\n+ *     18:      *           *   *\n+ *     25:      *   *   *\n+ *     27:      *   *   *\n+ *     32:      *   *   *   *   *\n+ *     34:      *   *   *   *   *\n+ *     36:      *           *   *\n+ *     43:      *   *   *\n+ *     45:      *   *   *\n+ *     50:  *   *   *   *\n+ *     52:  *   *   *   *\n+ *     54:  *   *\n+ * <\/pre>\n@@ -152,1 +198,1 @@\n-        \/\/ Iterative merging of slots\n+        \/\/ Iterative compaction of slots\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsCompactor.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,881 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * LocalsToVarMapper scans bytecode for slot operations, forms oriented flow graphs of the slot operation segments,\n+ * analyzes the graphs and maps the segments to distinct variables, calculates each variable type and identifies\n+ * single-assigned variables and variables requiring initialization in the entry block.\n+ *\/\n+final class LocalsToVarMapper {\n+\n+    \/**\n+     * Variable identity object result of the LocalsToVarMapper analysis.\n+     *\/\n+    public static final class Variable {\n+        private ClassDesc type;\n+        private boolean single;\n+\n+        \/**\n+         * {@return Variable type}\n+         *\/\n+        ClassDesc type() {\n+            return type;\n+        }\n+\n+        \/**\n+         * {@return whether the variable has only single assignement}\n+         *\/\n+        boolean hasSingleAssignment() {\n+            return single;\n+        }\n+    }\n+\n+    \/**\n+     * Segment of bytecode related to one local slot, it represents a node in the segment graph.\n+     *\/\n+    private static final class Segment {\n+\n+        \/**\n+         * Categorization of the segment graph nodes.\n+         *\/\n+        enum Kind {\n+\n+            \/**\n+             * Segment storing a value into the local slot.\n+             *\/\n+            STORE,\n+\n+            \/**\n+             * Segment requesting to load value from the local slot.\n+             *\/\n+            LOAD,\n+\n+            \/**\n+             * Segment forming a frame of connection to other segments.\n+             * This kind of segment is later either resolved as LOAD or it identifies false connection.\n+             *\/\n+            FRAME;\n+        }\n+\n+        \/**\n+         * Link between segments.\n+         *\/\n+        record Link(Segment segment, Link other) {}\n+\n+        \/**\n+         * Kind of segment.\n+         * The value is not final, {@link Kind.FRAME} segments may be later resolved to {@link Kind.LOAD}.\n+         *\/\n+        Kind kind;\n+\n+        \/**\n+         * Segment type.\n+         * The value is not final, int type may be later changed to {@code boolean}, {@code byte}, {@code short} or {@code char}.\n+         *\/\n+        ClassDesc type;\n+\n+        \/**\n+         * Variable this segment belongs to.\n+         * The value is calculated later in the process.\n+         *\/\n+        Variable var;\n+\n+\n+        \/**\n+         * Incoming segments in the flow graph.\n+         *\/\n+        Link from;\n+\n+        \/**\n+         * Outgoing segments in the flow graph.\n+         *\/\n+        Link to;\n+\n+        \/**\n+         * Links this segment to an outgoing segment.\n+         * @param toSegment outgoing segment\n+         *\/\n+        void link(Segment toSegment) {\n+            if (this != toSegment) {\n+                toSegment.from = new Link(this, toSegment.from);\n+                this.to = new Link(toSegment, this.to);\n+            }\n+        }\n+\n+        \/**\n+         * {@return Iterable over incomming segments.}\n+         *\/\n+        Iterable<Segment> fromSegments() {\n+            return () -> new LinkIterator(from);\n+        }\n+\n+        \/**\n+         * {@return Iterable over outgoing segments.}\n+         *\/\n+        Iterable<Segment> toSegments() {\n+            return () -> new LinkIterator(to);\n+        }\n+\n+        private static final class LinkIterator implements Iterator<Segment> {\n+            Link l;\n+            public LinkIterator(Link l) {\n+                this.l = l;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return l != null;\n+            }\n+\n+            @Override\n+            public Segment next() {\n+                if (l == null) throw new NoSuchElementException();\n+                Segment s = l.segment();\n+                l = l.other();\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Stack map frame\n+     *\/\n+    private record Frame(List<ClassDesc> stack, List<Segment> locals) {}\n+\n+    \/**\n+     * Specific instance of CD_Object identifying null initialized objects.\n+     *\/\n+    private static final ClassDesc NULL_TYPE = ClassDesc.ofDescriptor(CD_Object.descriptorString());\n+\n+    \/**\n+     * Map from instruction index to a segment.\n+     *\/\n+    private final Map<Integer, Segment> insMap;\n+\n+    \/**\n+     * Set of all involved segments.\n+     *\/\n+    private final LinkedHashSet<Segment> allSegments;\n+\n+    \/**\n+     * This class descriptor.\n+     *\/\n+    private final ClassDesc thisClass;\n+\n+    \/**\n+     * All exception handlers.\n+     *\/\n+    private final List<ExceptionCatch> exceptionHandlers;\n+\n+    \/**\n+     * Actual exception handlers stack.\n+     *\/\n+    private final Set<ExceptionCatch> handlersStack;\n+\n+    \/**\n+     * Actual stack.\n+     *\/\n+    private final List<ClassDesc> stack;\n+\n+    \/**\n+     * Actual locals.\n+     *\/\n+    private final List<Segment> locals;\n+\n+    \/**\n+     * Stack map.\n+     *\/\n+    private final Map<Label, Frame> stackMap;\n+\n+    \/**\n+     * Map of new object types (to resolve unitialized verification types in the stack map).\n+     *\/\n+    private final Map<Label, ClassDesc> newMap;\n+\n+    \/**\n+     * Dirty flag indicates modified stack map frame (sub-int adjustments), so the scanning process must restart\n+     *\/\n+    private boolean frameDirty;\n+\n+    \/**\n+     * Initial set of slots. Static part comes from method arguments.\n+     * Later phase of the analysis adds synthetic slots (declarations of multiple-assigned variables)\n+     * with mandatory initialization in the entry block.\n+     *\/\n+    private final List<Segment> initSlots;\n+\n+    \/**\n+     * Constructor and executor of the LocalsToVarMapper.\n+     * @param thisClass This class descriptor.\n+     * @param initFrameLocals Entry frame locals, expanded form of the method receiver and arguments. Second positions of double slots are null.\n+     * @param exceptionHandlers Exception handlers.\n+     * @param stackMapTableAttribute Stack map table attribute.\n+     * @param codeElements Code elements list. Indexes of this list are keys to the {@link #instructionVar(int) } method.\n+     *\/\n+    public LocalsToVarMapper(ClassDesc thisClass,\n+                     List<ClassDesc> initFrameLocals,\n+                     List<ExceptionCatch> exceptionHandlers,\n+                     Optional<StackMapTableAttribute> stackMapTableAttribute,\n+                     List<CodeElement> codeElements) {\n+        this.insMap = new HashMap<>();\n+        this.thisClass = thisClass;\n+        this.exceptionHandlers = exceptionHandlers;\n+        this.handlersStack = new LinkedHashSet<>();\n+        this.stack = new ArrayList<>();\n+        this.locals = new ArrayList<>();\n+        this.allSegments = new LinkedHashSet<>();\n+        this.newMap = computeNewMap(codeElements);\n+        this.initSlots = new ArrayList<>();\n+        this.stackMap = stackMapTableAttribute.map(a -> a.entries().stream().collect(Collectors.toMap(\n+                StackMapFrameInfo::target,\n+                this::toFrame))).orElse(Map.of());\n+        for (ClassDesc cd : initFrameLocals) {\n+            initSlots.add(cd == null ? null : newSegment(cd, Segment.Kind.STORE));\n+        }\n+        int initSize = allSegments.size();\n+\n+        \/\/ Main loop of the scan phase\n+        do {\n+            \/\/ Reset of the exception handler stack\n+            handlersStack.clear();\n+            \/\/ Slot states reset if running additional rounds (changed stack map frames)\n+            if (allSegments.size() > initSize) {\n+                while (allSegments.size() > initSize) allSegments.removeLast();\n+                allSegments.forEach(sl -> {\n+                    sl.from = null;\n+                    sl.to = null;\n+                    sl.var = null;\n+                });\n+            }\n+            \/\/ Initial frame store\n+            for (int i = 0; i < initFrameLocals.size(); i++) {\n+                storeLocal(i, initSlots.get(i), locals);\n+            }\n+            this.frameDirty = false;\n+            \/\/ Iteration over all code elements\n+            for (int i = 0; i < codeElements.size(); i++) {\n+                var ce = codeElements.get(i);\n+                scan(i, ce);\n+            }\n+            endOfFlow();\n+        } while (this.frameDirty);\n+\n+        \/\/ Segment graph analysis phase\n+        \/\/ First resolve FRAME segments to LOAD segments if directly followed by a LOAD segment\n+        \/\/ Remaining FRAME segments do not form connection with segments of the same variable and will be ignored.\n+        boolean changed = true;\n+        while (changed) {\n+            changed = false;\n+            for (Segment segment : allSegments) {\n+                if (segment.kind == Segment.Kind.FRAME) {\n+                    for (Segment to : segment.toSegments()) {\n+                        if (to.kind == Segment.Kind.LOAD) {\n+                            changed = true;\n+                            segment.kind = Segment.Kind.LOAD;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Assign variable to segments, calculate var type\n+        Set<Segment> stores = new LinkedHashSet<>(); \/\/ Helper set to collect all STORE segments of a variable\n+        ArrayDeque<Segment> q = new ArrayDeque<>(); \/\/ Working queue\n+        Set<Segment> visited = new LinkedHashSet<>(); \/\/ Helper set to traverse segment graph to filter initial stores\n+        for (Segment segment : allSegments) {\n+            \/\/ Only STORE and LOAD segments without assigned var are computed\n+            if (segment.var == null && segment.kind != Segment.Kind.FRAME) {\n+                Variable var = new Variable(); \/\/ New variable\n+                q.add(segment);\n+                var.type = segment.type; \/\/ Initial variable type\n+                while (!q.isEmpty()) {\n+                    Segment se = q.pop();\n+                    if (se.var == null) {\n+                        se.var = var; \/\/ Assign variable to the segment\n+                        for (Segment to : se.toSegments()) {\n+                            \/\/ All following LOAD segments belong to the same variable\n+                            if (to.kind == Segment.Kind.LOAD) {\n+                                if (var.type == NULL_TYPE) {\n+                                    var.type = to.type; \/\/ Initially null type re-assignemnt\n+                                }\n+                                if (to.var == null) {\n+                                    q.add(to);\n+                                }\n+                            }\n+                        }\n+                        if (se.kind == Segment.Kind.LOAD) {\n+                            \/\/ Segments preceeding LOAD segment also belong to the same variable\n+                            for (Segment from : se.fromSegments()) {\n+                                if (from.kind != Segment.Kind.FRAME) { \/\/ FRAME segments are ignored\n+                                    if (var.type == NULL_TYPE) {\n+                                        var.type = from.type; \/\/ Initially null type re-assignemnt\n+                                    }\n+                                    if (from.var == null) {\n+                                        q.add(from);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if (se.var == var && se.kind == Segment.Kind.STORE) {\n+                        stores.add(se); \/\/ Collection of all STORE segments of the variable\n+                    }\n+                }\n+\n+                \/\/ Single-assigned variable has only one STORE segment\n+                var.single = stores.size() < 2;\n+\n+                \/\/ Identification of initial STORE segments\n+                for (var it = stores.iterator(); it.hasNext();) {\n+                    visited.clear();\n+                    Segment s = it.next();\n+                    if (s.from != null && varDominatesOverSegmentPredecessors(s, var, visited)) {\n+                        \/\/ A store preceeding dominantly with segments of the same variable is not initial\n+                        it.remove();\n+                    }\n+                }\n+\n+                \/\/ Remaining stores are all initial.\n+                if (stores.size() > 1) {\n+                    \/\/ A synthetic default-initialized dominant segment must be inserted to the variable, if there is more than one initial store segment.\n+                    \/\/ It is not necessary to link it with other variable segments, the analysys ends here.\n+                    Segment initialSegment = new Segment();\n+                    initialSegment.var = var;\n+                    initSlots.add(initialSegment);\n+                    if (var.type == CD_long || var.type == CD_double) {\n+                        initSlots.add(null); \/\/ Do not forget to alocate second slot for double slots.\n+                    }\n+                }\n+                stores.clear();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@return Number of slots to initialize at entry block (method receiver + arguments + synthetic variable initialization segments).}\n+     *\/\n+    public int slotsToInit() {\n+        return initSlots.size();\n+    }\n+\n+    \/**\n+     * {@return Variable related to the given initial slot or null}\n+     * @param initSlot initial slot index\n+     *\/\n+    public Variable initSlotVar(int initSlot) {\n+        Segment s = initSlots.get(initSlot);\n+        return s == null ? null : s.var;\n+    }\n+\n+    \/**\n+     * Method returns relevant {@link Variable} for instructions operating with local slots,\n+     * such as {@link LoadInstruction}, {@link StoreInstruction} and {@link IncrementInstruction}.\n+     * For all other elements it returns {@code null}.\n+     *\n+     * Instructions are identified by index into the {@code codeElements} list used in the {@link LocalsToVarMapper} initializer.\n+     *\n+     * {@link IncrementInstruction} relates to two potentially distinct variables, one variable to load the value from\n+     * and one variable to store the incremented value into (see: {@link BytecodeLift#liftBody() }).\n+     *\n+     * @param codeElementIndex code element index\n+     * @return Variable related to the given code element index or null\n+     *\/\n+    public Variable instructionVar(int codeElementIndex) {\n+        return insMap.get(codeElementIndex).var;\n+    }\n+\n+    \/**\n+     * Tests if variable dominates over the segment predecessors.\n+     * All incoming paths to the segment must lead from segments of the given variable and not of any other variable.\n+     * The paths may pass through {@code FRAME} segments, which do not belong to any variable and their dominance must be computed.\n+     * Implementation relies on loops-avoiding breadth-first negative search.\n+     *\/\n+    private static boolean varDominatesOverSegmentPredecessors(Segment segment, Variable var, Set<Segment> visited) {\n+        if (visited.add(segment)) {\n+            for (Segment pred : segment.fromSegments()) {\n+                \/\/ Breath-first\n+                if (pred.kind != Segment.Kind.FRAME && pred.var != var) {\n+                    return false;\n+                }\n+            }\n+            for (Segment pred : segment.fromSegments()) {\n+                \/\/ Preceeding FRAME segment implies there is no directly preceeding variable and the dominance test must go deeper\n+                if (pred.kind == Segment.Kind.FRAME && !varDominatesOverSegmentPredecessors(pred, var, visited)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Cconverts {@link StackMapFrameInfo} to {@code Frame}, where locals are expanded form ({@code null}-filled second slots for double-slots)\n+     * of {@code FRAME} segments.\n+     * @param smfi StackMapFrameInfo\n+     * @return Frame\n+     *\/\n+    private Frame toFrame(StackMapFrameInfo smfi) {\n+        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n+        List<Segment> flocals = new ArrayList<>(smfi.locals().size() * 2);\n+        for (var vti : smfi.stack()) {\n+            fstack.add(vtiToStackType(vti));\n+        }\n+        int i = 0;\n+        for (var vti : smfi.locals()) {\n+            storeLocal(i, vtiToStackType(vti), flocals, Segment.Kind.FRAME);\n+            i += vti == ITEM_DOUBLE || vti == ITEM_LONG ? 2 : 1;\n+        }\n+        return new Frame(fstack, flocals);\n+    }\n+\n+    \/**\n+     * {@return map of labels immediately preceding {@link NewObjectInstruction} to the object types}\n+     * The map is important to resolve unitialized verification types in the stack map.\n+     * @param codeElements List of code elements to scan\n+     *\/\n+    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n+        Map<Label, ClassDesc> newMap = new HashMap<>();\n+        Label lastLabel = null;\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            switch (codeElements.get(i)) {\n+                case LabelTarget lt -> lastLabel = lt.label();\n+                case NewObjectInstruction newI -> {\n+                    if (lastLabel != null) {\n+                        newMap.put(lastLabel, newI.className().asSymbol());\n+                    }\n+                }\n+                case Instruction _ -> lastLabel = null; \/\/invalidate label\n+                default -> {} \/\/skip\n+            }\n+        }\n+        return newMap;\n+    }\n+\n+    \/**\n+     * {@return new segment and registers it in {@code allSegments} list}\n+     * @param type class descriptor of segment type\n+     * @param kind one of the segment kinds: {@code STORE}, {@code LOAD} or {@code FRAME}\n+     *\/\n+    private Segment newSegment(ClassDesc type, Segment.Kind kind) {\n+        Segment s = new Segment();\n+        s.kind = kind;\n+        s.type = type;\n+        allSegments.add(s);\n+        return s;\n+    }\n+\n+    \/**\n+     * {@return resolved class descriptor of the stack map frame verification type, custom {@code NULL_TYPE} for {@code ITEM_NULL}\n+     * or {@code null} for {@code ITEM_TOP}}\n+     * @param vti stack map frame verification type\n+     *\/\n+    private ClassDesc vtiToStackType(StackMapFrameInfo.VerificationTypeInfo vti) {\n+        return switch (vti) {\n+            case ITEM_INTEGER -> CD_int;\n+            case ITEM_FLOAT -> CD_float;\n+            case ITEM_DOUBLE -> CD_double;\n+            case ITEM_LONG -> CD_long;\n+            case ITEM_UNINITIALIZED_THIS -> thisClass;\n+            case ITEM_NULL -> NULL_TYPE;\n+            case ObjectVerificationTypeInfo ovti -> ovti.classSymbol();\n+            case UninitializedVerificationTypeInfo uvti ->\n+                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n+                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n+                });\n+            case ITEM_TOP -> null;\n+        };\n+    }\n+\n+    \/**\n+     * Pushes the class descriptor on {@link #stack}, except for {@code void}.\n+     * @param type class descriptor\n+     *\/\n+    private void push(ClassDesc type) {\n+        if (!ConstantDescs.CD_void.equals(type)) stack.add(type);\n+    }\n+\n+    \/**\n+     * Pushes the class descriptors on the {@link #stack} at the relative position, except for {@code void}.\n+     * @param pos position relative to the stack tip\n+     * @param types class descriptors\n+     *\/\n+    private void pushAt(int pos, ClassDesc... types) {\n+        for (var t : types)\n+            if (!ConstantDescs.CD_void.equals(t))\n+                stack.add(stack.size() + pos, t);\n+    }\n+\n+    \/**\n+     * {@return if class descriptor on the {@link #stack} at the relative position is {@code long} or {@code double}}\n+     * @param pos position relative to the stack tip\n+     *\/\n+    private boolean doubleAt(int pos) {\n+        var t  = stack.get(stack.size() + pos);\n+        return t.equals(CD_long) || t.equals(CD_double);\n+    }\n+\n+    \/**\n+     * {@return class descriptor poped from the {@link #stack}}\n+     *\/\n+    private ClassDesc pop() {\n+        return stack.removeLast();\n+    }\n+\n+    \/**\n+     * {@return class descriptor from the relative position of the {@link #stack}}\n+     * @param pos position relative to the stack tip\n+     *\/\n+    private ClassDesc get(int pos) {\n+        return stack.get(stack.size() + pos);\n+    }\n+\n+    \/**\n+     * {@return class descriptor from the tip of the {@link #stack}}\n+     *\/\n+    private ClassDesc top() {\n+        return stack.getLast();\n+    }\n+\n+    \/**\n+     * {@return two class descriptors from the tip of the {@link #stack}}\n+     *\/\n+    private ClassDesc[] top2() {\n+        return new ClassDesc[] {stack.get(stack.size() - 2), stack.getLast()};\n+    }\n+\n+    \/**\n+     * Pops given number of class descriptors from the {@link #stack}.\n+     * @param i number of class descriptors to pop\n+     * @return this LocalsToVarMapper\n+     *\/\n+    private LocalsToVarMapper pop(int i) {\n+        while (i-- > 0) pop();\n+        return this;\n+    }\n+\n+    \/**\n+     * Stores class descriptor as a new {@code STORE} {@link Segment} to the {@link #locals}.\n+     * The new segment is linked with the previous segment on the same slot position (if any).\n+     * @param slot locals slot number\n+     * @param type new segment class descriptor\n+     *\/\n+    private void storeLocal(int slot, ClassDesc type) {\n+        storeLocal(slot, type, locals, Segment.Kind.STORE);\n+    }\n+\n+    \/**\n+     * Stores class descriptor as a new {@link Segment} of given kind to the given list .\n+     * The new segment is linked with the previous segment on the same slot position (if any).\n+     * @param slot locals slot number\n+     * @param type new segment class descriptor\n+     * @param where target list of segments\n+     * @param kind new segment kind\n+     *\/\n+    private void storeLocal(int slot, ClassDesc type, List<Segment> where, Segment.Kind kind) {\n+        storeLocal(slot, type == null ? null : newSegment(type, kind), where);\n+    }\n+\n+    \/**\n+     * Stores the {@link Segment} to the given list.\n+     * The new segment is linked with the previous segment on the same slot position (if any).\n+     * @param slot locals slot number\n+     * @param segment the segment to store\n+     * @param where target list of segments\n+     *\/\n+    private void storeLocal(int slot, Segment segment, List<Segment> where) {\n+        if (segment != null) {\n+            for (int i = where.size(); i <= slot; i++) where.add(null);\n+            Segment prev = where.set(slot, segment);\n+            if (prev != null) {\n+                prev.link(segment);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Links existing {@link Segment} of the {@link #locals} with a new {@code LOAD} {@link Segment} with inherited type.\n+     * @param slot slot number to load\n+     * @return type of the local\n+     *\/\n+    private ClassDesc loadLocal(int slot) {\n+        Segment segment = locals.get(slot);\n+        Segment newSegment = newSegment(segment.type, Segment.Kind.LOAD);\n+        segment.link(newSegment);\n+        return segment.type;\n+    }\n+\n+    \/**\n+     * Main code element scanning method of the scan loop.\n+     * @param elementIndex element index\n+     * @param el code element\n+     *\/\n+    private void scan(int elementIndex, CodeElement el) {\n+        switch (el) {\n+            case ArrayLoadInstruction _ ->\n+                pop(1).push(pop().componentType());\n+            case ArrayStoreInstruction _ ->\n+                pop(3);\n+            case BranchInstruction i -> {\n+                switch (i.opcode()) {\n+                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n+                        pop();\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n+                        pop(2);\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case GOTO, GOTO_W -> {\n+                        mergeToTargetFrame(i.target());\n+                        endOfFlow();\n+                    }\n+                }\n+            }\n+            case ConstantInstruction i ->\n+                push(switch (i.constantValue()) {\n+                    case null -> NULL_TYPE;\n+                    case ClassDesc _ -> CD_Class;\n+                    case Double _ -> CD_double;\n+                    case Float _ -> CD_float;\n+                    case Integer _ -> CD_int;\n+                    case Long _ -> CD_long;\n+                    case String _ -> CD_String;\n+                    case DynamicConstantDesc<?> cd when cd.equals(NULL) -> NULL_TYPE;\n+                    case DynamicConstantDesc<?> cd -> cd.constantType();\n+                    case DirectMethodHandleDesc _ -> CD_MethodHandle;\n+                    case MethodTypeDesc _ -> CD_MethodType;\n+                });\n+            case ConvertInstruction i ->\n+                pop(1).push(ClassDesc.ofDescriptor(i.toType().descriptor()));\n+            case FieldInstruction i -> {\n+                switch (i.opcode()) {\n+                    case GETSTATIC ->\n+                        push(i.typeSymbol());\n+                    case GETFIELD ->\n+                        pop(1).push(i.typeSymbol());\n+                    case PUTSTATIC ->\n+                        pop(1);\n+                    case PUTFIELD ->\n+                        pop(2);\n+                }\n+            }\n+            case IncrementInstruction i -> { \/\/ Increment instruction maps to two segments\n+                loadLocal(i.slot());\n+                insMap.put(-elementIndex - 1, locals.get(i.slot())); \/\/ source segment is mapped with -elementIndex - 1 key\n+                storeLocal(i.slot(), CD_int);\n+                insMap.put(elementIndex, locals.get(i.slot())); \/\/ target segment is mapped with elementIndex key\n+                for (var ec : handlersStack) {\n+                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                }\n+            }\n+            case InvokeDynamicInstruction i ->\n+                pop(i.typeSymbol().parameterCount()).push(i.typeSymbol().returnType());\n+            case InvokeInstruction i ->\n+                pop(i.typeSymbol().parameterCount() + (i.opcode() == Opcode.INVOKESTATIC ? 0 : 1))\n+                        .push(i.typeSymbol().returnType());\n+            case LoadInstruction i -> {\n+                push(loadLocal(i.slot())); \/\/ Load instruction segment is mapped with elementIndex key\n+                insMap.put(elementIndex, locals.get(i.slot()));\n+            }\n+            case StoreInstruction i -> {\n+                storeLocal(i.slot(), pop());\n+                insMap.put(elementIndex, locals.get(i.slot()));  \/\/ Store instruction segment is mapped with elementIndex key\n+                for (var ec : handlersStack) {\n+                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                }\n+            }\n+            case MonitorInstruction _ ->\n+                pop(1);\n+            case NewMultiArrayInstruction i ->\n+                pop(i.dimensions()).push(i.arrayType().asSymbol());\n+            case NewObjectInstruction i ->\n+                push(i.className().asSymbol());\n+            case NewPrimitiveArrayInstruction i ->\n+                pop(1).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()).arrayType());\n+            case NewReferenceArrayInstruction i ->\n+                pop(1).push(i.componentType().asSymbol().arrayType());\n+            case OperatorInstruction i ->\n+                pop(switch (i.opcode()) {\n+                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> 1;\n+                    default -> 2;\n+                }).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()));\n+            case StackInstruction i -> {\n+                switch (i.opcode()) {\n+                    case POP -> pop(1);\n+                    case POP2 -> pop(doubleAt(-1) ? 1 : 2);\n+                    case DUP -> push(top());\n+                    case DUP2 -> {\n+                        if (doubleAt(-1)) {\n+                            push(top());\n+                        } else {\n+                            pushAt(-2, top2());\n+                        }\n+                    }\n+                    case DUP_X1 -> pushAt(-2, top());\n+                    case DUP_X2 -> pushAt(doubleAt(-2) ? -2 : -3, top());\n+                    case DUP2_X1 -> {\n+                        if (doubleAt(-1)) {\n+                            pushAt(-2, top());\n+                        } else {\n+                            pushAt(-3, top2());\n+                        }\n+                    }\n+                    case DUP2_X2 -> {\n+                        if (doubleAt(-1)) {\n+                            pushAt(doubleAt(-2) ? -2 : -3, top());\n+                        } else {\n+                            pushAt(doubleAt(-3) ? -3 : -4, top2());\n+                        }\n+                    }\n+                    case SWAP -> pushAt(-1, pop());\n+                }\n+            }\n+            case TypeCheckInstruction i ->\n+                pop(1).push(i.opcode() == Opcode.CHECKCAST ? i.type().asSymbol() : ConstantDescs.CD_int);\n+            case LabelTarget lt -> {\n+                var frame = stackMap.get(lt.label());\n+                if (frame != null) { \/\/ Here we reached a stack map frame, so we merge actual stack and locals into the frame\n+                    if (!stack.isEmpty() || !locals.isEmpty()) {\n+                        mergeToTargetFrame(lt.label());\n+                        endOfFlow();\n+                    }\n+                    \/\/ Stack and locals are then taken from the frame\n+                    stack.addAll(frame.stack());\n+                    locals.addAll(frame.locals());\n+                }\n+                for (ExceptionCatch ec : exceptionHandlers) {\n+                    if (lt.label() == ec.tryStart()) { \/\/ Entering a try block\n+                        handlersStack.add(ec);\n+                        mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                    }\n+                    if (lt.label() == ec.tryEnd()) { \/\/ Leaving a try block\n+                        handlersStack.remove(ec);\n+                    }\n+                }\n+            }\n+            case ReturnInstruction _ , ThrowInstruction _ -> {\n+                endOfFlow();\n+            }\n+            case TableSwitchInstruction tsi -> {\n+                pop();\n+                mergeToTargetFrame(tsi.defaultTarget());\n+                for (var c : tsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            case LookupSwitchInstruction lsi -> {\n+                pop();\n+                mergeToTargetFrame(lsi.defaultTarget());\n+                for (var c : lsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            default -> {}\n+        }\n+    }\n+\n+    private void endOfFlow() {\n+        stack.clear();\n+        locals.clear();\n+    }\n+\n+    \/**\n+     * Merge of the actual {@link #stack} and {@link #locals} to the target stack map frame\n+     * @param target label of the target stack map frame\n+     *\/\n+    private void mergeToTargetFrame(Label target) {\n+        Frame targetFrame = stackMap.get(target);\n+        \/\/ Merge stack\n+        assert stack.size() == targetFrame.stack.size();\n+        for (int i = 0; i < targetFrame.stack.size(); i++) {\n+            ClassDesc se = stack.get(i);\n+            ClassDesc fe = targetFrame.stack.get(i);\n+            if (!se.equals(fe)) {\n+                if (se.isPrimitive() && CD_int.equals(fe)) {\n+                    targetFrame.stack.set(i, se); \/\/ Override int target frame type with more specific int sub-type\n+                    this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n+                } else {\n+                    stack.set(i, fe); \/\/ Override stack type with target frame type\n+                }\n+            }\n+        }\n+        mergeLocalsToTargetFrame(targetFrame);\n+    }\n+\n+\n+    \/**\n+     * Merge of the actual {@link #locals} to the target stack map frame\n+     * @param targetFrame target stack map frame\n+     *\/\n+    private void mergeLocalsToTargetFrame(Frame targetFrame) {\n+        \/\/ Merge locals\n+        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n+        for (int i = 0; i < lSize; i++) {\n+            Segment le = locals.get(i);\n+            Segment fe = targetFrame.locals.get(i);\n+            if (le != null && fe != null) {\n+                le.link(fe); \/\/ Link target frame var with its source\n+                if (!le.type.equals(fe.type)) {\n+                    if (le.type.isPrimitive() && CD_int.equals(fe.type) ) {\n+                        fe.type = le.type; \/\/ Override int target frame type with more specific int sub-type\n+                        this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":881,"deletions":0,"binary":false,"changes":881,"status":"added"},{"patch":"@@ -1,656 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.reflect.code.bytecode;\n-\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.Instruction;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.TypeKind;\n-import java.lang.classfile.attribute.CodeAttribute;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapFrameInfo.*;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.instruction.*;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodTypeDesc;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n-import java.lang.classfile.components.ClassPrinter;\n-import static java.lang.constant.ConstantDescs.*;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.type.JavaType;\n-import java.util.ArrayDeque;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-\n-final class LocalsTypeMapper {\n-\n-    static class Variable {\n-        private ClassDesc type;\n-        boolean isSingleValue;\n-        Value value;\n-\n-        JavaType type() {\n-            return JavaType.type(type);\n-        }\n-\n-        Object defaultValue() {\n-            return switch (TypeKind.from(type)) {\n-                case BooleanType -> false;\n-                case ByteType -> (byte)0;\n-                case CharType -> (char)0;\n-                case DoubleType -> 0d;\n-                case FloatType -> 0f;\n-                case IntType -> 0;\n-                case LongType -> 0l;\n-                case ReferenceType -> null;\n-                case ShortType -> (short)0;\n-                default -> throw new IllegalStateException(\"Invalid type \" + type.displayName());\n-            };\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return Integer.toHexString(hashCode()).substring(0, 2) + \" \" + isSingleValue;\n-        }\n-    }\n-\n-    static final class Slot {\n-\n-        enum Kind {\n-            STORE, LOAD, FRAME;\n-        }\n-\n-        private record Link(Slot slot, Link other) {}\n-\n-        int bci, sl; \/\/ @@@ only for debugging purpose\n-        Kind kind;\n-        ClassDesc type;\n-        Variable var;\n-        private Link up, down;\n-\n-        void link(Slot target) {\n-            if (this != target) {\n-                target.up = new Link(this, target.up);\n-                this.down = new Link(target, this.down);\n-            }\n-        }\n-\n-        Iterable<Slot> upSlots() {\n-            return () -> new LinkIterator(up);\n-        }\n-\n-        Iterable<Slot> downSlots() {\n-            return () -> new LinkIterator(down);\n-        }\n-\n-        @Override\n-        public String toString() {\n-             \/\/ @@@ only for debugging purpose\n-            return \"%d: #%d %s %s var:%s\".formatted(bci, sl, kind, type.displayName(),  var == null ? null : var.toString());\n-        }\n-\n-        static final class LinkIterator implements Iterator<Slot> {\n-            Link l;\n-            public LinkIterator(Link l) {\n-                this.l = l;\n-            }\n-\n-            @Override\n-            public boolean hasNext() {\n-                return l != null;\n-            }\n-\n-            @Override\n-            public Slot next() {\n-                if (l == null) throw new NoSuchElementException();\n-                Slot s = l.slot();\n-                l = l.other();\n-                return s;\n-            }\n-        }\n-    }\n-\n-    record Frame(List<ClassDesc> stack, List<Slot> locals) {}\n-\n-    private static final ClassDesc NULL_TYPE = ClassDesc.ofDescriptor(CD_Object.descriptorString());\n-    private final Map<Integer, Slot> insMap;\n-    private final LinkedHashSet<Slot> allSlots;\n-    private final ClassDesc thisClass;\n-    private final List<ExceptionCatch> exceptionHandlers;\n-    private final Set<ExceptionCatch> handlersStack;\n-    private final List<ClassDesc> stack;\n-    private final List<Slot> locals;\n-    private final Map<Label, Frame> stackMap;\n-    private final Map<Label, ClassDesc> newMap;\n-    private final CodeAttribute ca;\n-    private boolean frameDirty;\n-    final List<Slot> slotsToInitialize;\n-\n-    LocalsTypeMapper(ClassDesc thisClass,\n-                     List<ClassDesc> initFrameLocals,\n-                     List<ExceptionCatch> exceptionHandlers,\n-                     Optional<StackMapTableAttribute> stackMapTableAttribute,\n-                     List<CodeElement> codeElements,\n-                     CodeAttribute ca) {\n-        this.insMap = new HashMap<>();\n-        this.thisClass = thisClass;\n-        this.exceptionHandlers = exceptionHandlers;\n-        this.handlersStack = new LinkedHashSet<>();\n-        this.stack = new ArrayList<>();\n-        this.locals = new ArrayList<>();\n-        this.allSlots = new LinkedHashSet<>();\n-        this.newMap = computeNewMap(codeElements);\n-        this.slotsToInitialize = new ArrayList<>();\n-        this.ca = ca; \/\/ @@@ only for debugging purpose\n-        this.stackMap = stackMapTableAttribute.map(a -> a.entries().stream().collect(Collectors.toMap(\n-                StackMapFrameInfo::target,\n-                this::toFrame))).orElse(Map.of());\n-        for (ClassDesc cd : initFrameLocals) {\n-            slotsToInitialize.add(cd == null ? null : newSlot(cd, Slot.Kind.STORE, -1, slotsToInitialize.size()));\n-        }\n-        int initSize = allSlots.size();\n-        do {\n-            handlersStack.clear();\n-            \/\/ Slot states reset if running additional rounds with adjusted frames\n-            if (allSlots.size() > initSize) {\n-                while (allSlots.size() > initSize) allSlots.removeLast();\n-                allSlots.forEach(sl -> {\n-                    sl.up = null;\n-                    sl.down = null;\n-                    sl.var = null;\n-                });\n-            }\n-            for (int i = 0; i < initFrameLocals.size(); i++) {\n-                store(i, slotsToInitialize.get(i), locals);\n-            }\n-            this.frameDirty = false;\n-            int bci = 0;\n-            for (int i = 0; i < codeElements.size(); i++) {\n-                var ce = codeElements.get(i);\n-                accept(i, ce, bci);\n-                if (ce instanceof Instruction ins) bci += ins.sizeInBytes();\n-            }\n-            endOfFlow();\n-        } while (this.frameDirty);\n-\n-        \/\/ Pull LOADs up the FRAMEs\n-        boolean changed = true;\n-        while (changed) {\n-            changed = false;\n-            for (Slot slot : allSlots) {\n-                if (slot.kind == Slot.Kind.FRAME) {\n-                    for (Slot down : slot.downSlots()) {\n-                        if (down.kind == Slot.Kind.LOAD) {\n-                            changed = true;\n-                            slot.kind = Slot.Kind.LOAD;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Assign variable to slots, calculate var type\n-        Set<Slot> stores = new LinkedHashSet<>();\n-        ArrayDeque<Slot> q = new ArrayDeque<>();\n-        Set<Slot> visited = new LinkedHashSet<>();\n-        for (Slot slot : allSlots) {\n-            if (slot.var == null && slot.kind != Slot.Kind.FRAME) {\n-                Variable var = new Variable();\n-                q.add(slot);\n-                var.type = slot.type;\n-                while (!q.isEmpty()) {\n-                    Slot sl = q.pop();\n-                    if (sl.var == null) {\n-                        sl.var = var;\n-                        for (Slot down : sl.downSlots()) {\n-                            if (down.kind == Slot.Kind.LOAD) {\n-                                if (var.type == NULL_TYPE) var.type = down.type;\n-                                if (down.var == null) q.add(down);\n-                            }\n-                        }\n-                        if (sl.kind == Slot.Kind.LOAD) {\n-                            for (Slot up : sl.upSlots()) {\n-                                if (up.kind != Slot.Kind.FRAME) {\n-                                    if (var.type == NULL_TYPE) var.type = up.type;\n-                                    if (up.var == null) {\n-                                        q.add(up);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if (sl.var == var && sl.kind == Slot.Kind.STORE) {\n-                        stores.add(sl);\n-                    }\n-                }\n-\n-                \/\/ Detect single value\n-                var.isSingleValue = stores.size() < 2;\n-\n-                \/\/ Filter initial stores\n-                for (var it = stores.iterator(); it.hasNext();) {\n-                    visited.clear();\n-                    Slot s = it.next();\n-                    if (s.up != null && preceedsWithTheVar(s, var, visited)) {\n-                        it.remove();\n-                    }\n-                }\n-\n-                \/\/ Insert var initialization if necessary\n-                if (stores.size() > 1) {\n-                    \/\/ Add synthetic dominant slot, which needs to be initialized with a default value\n-                    Slot initialSlot = new Slot();\n-                    initialSlot.var = var;\n-                    slotsToInitialize.add(initialSlot);\n-                    if (var.type == CD_long || var.type == CD_double) {\n-                        slotsToInitialize.add(null);\n-                    }\n-                }\n-                stores.clear();\n-            }\n-        }\n-\n-        \/\/ @@@ only for debugging purpose\n-        if (BytecodeLift.DUMP) {\n-            ClassPrinter.toYaml(ca, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n-            System.out.println(\"digraph {\");\n-            for (Slot s : allSlots) {\n-                System.out.println(\"    S\" + Integer.toHexString(s.hashCode()) + \" [label=\\\"\" + s.toString() + \"\\\"]\");\n-            }\n-            System.out.println();\n-            for (Slot s : allSlots) {\n-                var it = s.downSlots().iterator();\n-                if (it.hasNext()) {\n-                    System.out.print(\"    S\" + Integer.toHexString(s.hashCode()) + \" -> {S\" + Integer.toHexString(it.next().hashCode()));\n-                    while (it.hasNext()) {\n-                        System.out.print(\", S\" + Integer.toHexString(it.next().hashCode()));\n-                    }\n-                    System.out.println(\"};\");\n-                }\n-            }\n-            System.out.println(\"}\");\n-        }\n-    }\n-\n-    \/\/ Detects if all of the preceding slots belong to the var\n-    private static boolean preceedsWithTheVar(Slot slot, Variable var, Set<Slot> visited) {\n-        if (visited.add(slot)) {\n-            for (Slot up : slot.upSlots()) {\n-                if (up.var == null ? up.kind != Slot.Kind.FRAME || !preceedsWithTheVar(up, var, visited) : up.var != var) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private Frame toFrame(StackMapFrameInfo smfi) {\n-        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n-        List<Slot> flocals = new ArrayList<>(smfi.locals().size() * 2);\n-        for (var vti : smfi.stack()) {\n-            fstack.add(vtiToStackType(vti));\n-        }\n-        int i = 0;\n-        int bci = ca.labelToBci(smfi.target()); \/\/@@@ only for debugging purpose\n-        for (var vti : smfi.locals()) {\n-            store(i, vtiToStackType(vti), flocals, Slot.Kind.FRAME, bci);\n-            i += vti == ITEM_DOUBLE || vti == ITEM_LONG ? 2 : 1;\n-        }\n-        return new Frame(fstack, flocals);\n-    }\n-\n-    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n-        Map<Label, ClassDesc> newMap = new HashMap<>();\n-        Label lastLabel = null;\n-        for (int i = 0; i < codeElements.size(); i++) {\n-            switch (codeElements.get(i)) {\n-                case LabelTarget lt -> lastLabel = lt.label();\n-                case NewObjectInstruction newI -> {\n-                    if (lastLabel != null) {\n-                        newMap.put(lastLabel, newI.className().asSymbol());\n-                    }\n-                }\n-                case Instruction _ -> lastLabel = null; \/\/invalidate label\n-                default -> {} \/\/skip\n-            }\n-        }\n-        return newMap;\n-    }\n-\n-    Variable getVarOf(int li) {\n-        return insMap.get(li).var;\n-    }\n-\n-    private Slot newSlot(ClassDesc type, Slot.Kind kind, int bci, int sl) {\n-        Slot s = new Slot();\n-        s.kind = kind;\n-        s.type = type;\n-        s.bci = bci;\n-        s.sl = sl; \/\/ @@@ only for debugging purpose\n-        allSlots.add(s);\n-        return s;\n-    }\n-\n-    private ClassDesc vtiToStackType(StackMapFrameInfo.VerificationTypeInfo vti) {\n-        return switch (vti) {\n-            case ITEM_INTEGER -> CD_int;\n-            case ITEM_FLOAT -> CD_float;\n-            case ITEM_DOUBLE -> CD_double;\n-            case ITEM_LONG -> CD_long;\n-            case ITEM_UNINITIALIZED_THIS -> thisClass;\n-            case ITEM_NULL -> NULL_TYPE;\n-            case ObjectVerificationTypeInfo ovti -> ovti.classSymbol();\n-            case UninitializedVerificationTypeInfo uvti ->\n-                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n-                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n-                });\n-            case ITEM_TOP -> null;\n-        };\n-    }\n-\n-    private void push(ClassDesc type) {\n-        if (!ConstantDescs.CD_void.equals(type)) stack.add(type);\n-    }\n-\n-    private void pushAt(int pos, ClassDesc... types) {\n-        for (var t : types)\n-            if (!ConstantDescs.CD_void.equals(t))\n-                stack.add(stack.size() + pos, t);\n-    }\n-\n-    private boolean doubleAt(int pos) {\n-        var t  = stack.get(stack.size() + pos);\n-        return t.equals(CD_long) || t.equals(CD_double);\n-    }\n-\n-    private ClassDesc pop() {\n-        return stack.removeLast();\n-    }\n-\n-    private ClassDesc get(int pos) {\n-        return stack.get(stack.size() + pos);\n-    }\n-\n-    private ClassDesc top() {\n-        return stack.getLast();\n-    }\n-\n-    private ClassDesc[] top2() {\n-        return new ClassDesc[] {stack.get(stack.size() - 2), stack.getLast()};\n-    }\n-\n-    private LocalsTypeMapper pop(int i) {\n-        while (i-- > 0) pop();\n-        return this;\n-    }\n-\n-    private void store(int slot, ClassDesc type, int bci) {\n-        store(slot, type, locals, Slot.Kind.STORE, bci);\n-    }\n-\n-    private void store(int slot, ClassDesc type, List<Slot> where, Slot.Kind kind, int bci) {\n-        store(slot, type == null ? null : newSlot(type, kind, bci, slot), where);\n-    }\n-\n-    private void store(int slot, Slot s, List<Slot> where) {\n-        if (s != null) {\n-            for (int i = where.size(); i <= slot; i++) where.add(null);\n-            Slot prev = where.set(slot, s);\n-            if (prev != null) {\n-                prev.link(s);\n-            }\n-        }\n-    }\n-\n-    private ClassDesc load(int slot, int bci) {\n-        Slot sl = locals.get(slot);\n-        Slot nsl = newSlot(sl.type, Slot.Kind.LOAD, bci, slot);\n-        sl.link(nsl);\n-        return sl.type;\n-    }\n-\n-    private void accept(int elIndex, CodeElement el, int bci) {\n-        switch (el) {\n-            case ArrayLoadInstruction _ ->\n-                pop(1).push(pop().componentType());\n-            case ArrayStoreInstruction _ ->\n-                pop(3);\n-            case BranchInstruction i -> {\n-                switch (i.opcode()) {\n-                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n-                        pop();\n-                        mergeToTargetFrame(i.target());\n-                    }\n-                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n-                        pop(2);\n-                        mergeToTargetFrame(i.target());\n-                    }\n-                    case GOTO, GOTO_W -> {\n-                        mergeToTargetFrame(i.target());\n-                        endOfFlow();\n-                    }\n-                }\n-            }\n-            case ConstantInstruction i ->\n-                push(switch (i.constantValue()) {\n-                    case null -> NULL_TYPE;\n-                    case ClassDesc _ -> CD_Class;\n-                    case Double _ -> CD_double;\n-                    case Float _ -> CD_float;\n-                    case Integer _ -> CD_int;\n-                    case Long _ -> CD_long;\n-                    case String _ -> CD_String;\n-                    case DynamicConstantDesc<?> cd when cd.equals(NULL) -> NULL_TYPE;\n-                    case DynamicConstantDesc<?> cd -> cd.constantType();\n-                    case DirectMethodHandleDesc _ -> CD_MethodHandle;\n-                    case MethodTypeDesc _ -> CD_MethodType;\n-                });\n-            case ConvertInstruction i ->\n-                pop(1).push(ClassDesc.ofDescriptor(i.toType().descriptor()));\n-            case FieldInstruction i -> {\n-                switch (i.opcode()) {\n-                    case GETSTATIC ->\n-                        push(i.typeSymbol());\n-                    case GETFIELD ->\n-                        pop(1).push(i.typeSymbol());\n-                    case PUTSTATIC ->\n-                        pop(1);\n-                    case PUTFIELD ->\n-                        pop(2);\n-                }\n-            }\n-            case IncrementInstruction i -> {\n-                load(i.slot(), bci);\n-                insMap.put(-elIndex - 1, locals.get(i.slot()));\n-                store(i.slot(), CD_int, bci);\n-                insMap.put(elIndex, locals.get(i.slot()));\n-                for (var ec : handlersStack) {\n-                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n-                }\n-            }\n-            case InvokeDynamicInstruction i ->\n-                pop(i.typeSymbol().parameterCount()).push(i.typeSymbol().returnType());\n-            case InvokeInstruction i ->\n-                pop(i.typeSymbol().parameterCount() + (i.opcode() == Opcode.INVOKESTATIC ? 0 : 1))\n-                        .push(i.typeSymbol().returnType());\n-            case LoadInstruction i -> {\n-                push(load(i.slot(), bci));\n-                insMap.put(elIndex, locals.get(i.slot()));\n-            }\n-            case StoreInstruction i -> {\n-                store(i.slot(), pop(), bci);\n-                insMap.put(elIndex, locals.get(i.slot()));\n-                for (var ec : handlersStack) {\n-                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n-                }\n-            }\n-            case MonitorInstruction _ ->\n-                pop(1);\n-            case NewMultiArrayInstruction i ->\n-                pop(i.dimensions()).push(i.arrayType().asSymbol());\n-            case NewObjectInstruction i ->\n-                push(i.className().asSymbol());\n-            case NewPrimitiveArrayInstruction i ->\n-                pop(1).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()).arrayType());\n-            case NewReferenceArrayInstruction i ->\n-                pop(1).push(i.componentType().asSymbol().arrayType());\n-            case OperatorInstruction i ->\n-                pop(switch (i.opcode()) {\n-                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> 1;\n-                    default -> 2;\n-                }).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()));\n-            case StackInstruction i -> {\n-                switch (i.opcode()) {\n-                    case POP -> pop(1);\n-                    case POP2 -> pop(doubleAt(-1) ? 1 : 2);\n-                    case DUP -> push(top());\n-                    case DUP2 -> {\n-                        if (doubleAt(-1)) {\n-                            push(top());\n-                        } else {\n-                            pushAt(-2, top2());\n-                        }\n-                    }\n-                    case DUP_X1 -> pushAt(-2, top());\n-                    case DUP_X2 -> pushAt(doubleAt(-2) ? -2 : -3, top());\n-                    case DUP2_X1 -> {\n-                        if (doubleAt(-1)) {\n-                            pushAt(-2, top());\n-                        } else {\n-                            pushAt(-3, top2());\n-                        }\n-                    }\n-                    case DUP2_X2 -> {\n-                        if (doubleAt(-1)) {\n-                            pushAt(doubleAt(-2) ? -2 : -3, top());\n-                        } else {\n-                            pushAt(doubleAt(-3) ? -3 : -4, top2());\n-                        }\n-                    }\n-                    case SWAP -> pushAt(-1, pop());\n-                }\n-            }\n-            case TypeCheckInstruction i ->\n-                pop(1).push(i.opcode() == Opcode.CHECKCAST ? i.type().asSymbol() : ConstantDescs.CD_int);\n-            case LabelTarget lt -> {\n-                var frame = stackMap.get(lt.label());\n-                if (frame != null) {\n-                    if (!stack.isEmpty() || !locals.isEmpty()) {\n-                        mergeToTargetFrame(lt.label());\n-                        endOfFlow();\n-                    }\n-                    stack.addAll(frame.stack());\n-                    locals.addAll(frame.locals());\n-                }\n-                for (ExceptionCatch ec : exceptionHandlers) {\n-                    if (lt.label() == ec.tryStart()) {\n-                        handlersStack.add(ec);\n-                        mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n-                    }\n-                    if (lt.label() == ec.tryEnd()) {\n-                        handlersStack.remove(ec);\n-                    }\n-                }\n-            }\n-            case ReturnInstruction _ , ThrowInstruction _ -> {\n-                endOfFlow();\n-            }\n-            case TableSwitchInstruction tsi -> {\n-                pop();\n-                mergeToTargetFrame(tsi.defaultTarget());\n-                for (var c : tsi.cases()) {\n-                    mergeToTargetFrame(c.target());\n-                }\n-                endOfFlow();\n-            }\n-            case LookupSwitchInstruction lsi -> {\n-                pop();\n-                mergeToTargetFrame(lsi.defaultTarget());\n-                for (var c : lsi.cases()) {\n-                    mergeToTargetFrame(c.target());\n-                }\n-                endOfFlow();\n-            }\n-            default -> {}\n-        }\n-    }\n-\n-    private void endOfFlow() {\n-        stack.clear();\n-        locals.clear();\n-    }\n-\n-    private void mergeToTargetFrame(Label target) {\n-        Frame targetFrame = stackMap.get(target);\n-        \/\/ Merge stack\n-        assert stack.size() == targetFrame.stack.size();\n-        for (int i = 0; i < targetFrame.stack.size(); i++) {\n-            ClassDesc se = stack.get(i);\n-            ClassDesc fe = targetFrame.stack.get(i);\n-            if (!se.equals(fe)) {\n-                if (se.isPrimitive() && CD_int.equals(fe)) {\n-                    targetFrame.stack.set(i, se); \/\/ Override int target frame type with more specific int sub-type\n-                    this.frameDirty = true;\n-                } else {\n-                    stack.set(i, fe); \/\/ Override stack type with target frame type\n-                }\n-            }\n-        }\n-        mergeLocalsToTargetFrame(targetFrame);\n-    }\n-\n-    private void mergeLocalsToTargetFrame(Frame targetFrame) {\n-        \/\/ Merge locals\n-        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n-        for (int i = 0; i < lSize; i++) {\n-            Slot le = locals.get(i);\n-            Slot fe = targetFrame.locals.get(i);\n-            if (le != null && fe != null) {\n-                le.link(fe); \/\/ Link target frame var with its source\n-                if (!le.type.equals(fe.type)) {\n-                    if (le.type.isPrimitive() && CD_int.equals(fe.type) ) {\n-                        fe.type = le.type; \/\/ Override int target frame type with more specific int sub-type\n-                        this.frameDirty = true;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsTypeMapper.java","additions":0,"deletions":656,"binary":false,"changes":656,"status":"deleted"},{"patch":"@@ -70,1 +70,0 @@\n-        BytecodeLift.DUMP = false;\n@@ -82,1 +81,2 @@\n-    private int stable, unstable, originalMaxLocals, maxLocals;\n+    private int stable, unstable;\n+    private Long[] stats = new Long[6];\n@@ -89,2 +89,1 @@\n-        originalMaxLocals = 0;\n-        maxLocals = 0;\n+        Arrays.fill(stats, 0l);\n@@ -97,0 +96,7 @@\n+        System.out.println(\"\"\"\n+        statistics     original  generated\n+        code length: %1$,10d %4$,10d\n+        max locals:  %2$,10d %5$,10d\n+        max stack:   %3$,10d %6$,10d\n+        \"\"\".formatted((Object[])stats));\n+\n@@ -98,1 +104,1 @@\n-        Assert.assertTrue(stable > 65290 && unstable < 100, String.format(\"stable: %d unstable: %d original maxLocals: %d maxLocals: %d\", stable, unstable, originalMaxLocals, maxLocals));\n+        Assert.assertTrue(stable > 65290 && unstable < 100, String.format(\"stable: %d unstable: %d\", stable, unstable));\n@@ -132,2 +138,8 @@\n-                    originalMaxLocals += ((CodeAttribute)originalModel.code().get()).maxLocals();\n-                    maxLocals += ((CodeAttribute)bytecode.code().get()).maxLocals();\n+                    var ca = (CodeAttribute)originalModel.code().get();\n+                    stats[0] += ca.codeLength();\n+                    stats[1] += ca.maxLocals();\n+                    stats[2] += ca.maxStack();\n+                    ca = (CodeAttribute)bytecode.code().get();\n+                    stats[3] += ca.codeLength();\n+                    stats[4] += ca.maxLocals();\n+                    stats[5] += ca.maxStack();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"}]}