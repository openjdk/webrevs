{"files":[{"patch":"@@ -27,1 +27,0 @@\n-\n@@ -39,2 +38,0 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.Body;\n@@ -64,2 +61,2 @@\n-            case CoreOp.VarOp varOp -> varName(varOp);\n-            case HatMemoryOp hatMemoryOp -> varName(hatMemoryOp);\n+            case CoreOp.VarOp $ -> varName($);\n+            case HatMemoryOp $ -> varName($);\n@@ -121,3 +118,1 @@\n-        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n-            identifier(\"kc\").rarrow().fieldName(fieldLoadOp);\n-        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n+        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n@@ -302,3 +297,0 @@\n-\n-\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -215,2 +215,6 @@\n-                           Stream.of( \"Arrays\", \"MatMul\", \"Mandel\", \"Local\", \"Reductions\", \"Private\", \"Parenthesis\", \"Costants\")\n-                              .map(s->\"oracle.code.hat.Test\"+s)\n+                           Stream.of( \"Arrays\", \"MatMul\", \"Mandel\",\n+                                           \"Local\", \"Reductions\",\n+                                           \"Private\", \"Parenthesis\",\n+                                           \"Constants\", \"Blackscholes\",\n+                                           \"Nbody\")\n+                              .map(s->\"oracle.code.hat.Test\" + s)\n","filename":"hat\/hat.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -174,1 +174,3 @@\n-                \"oracle.code.hat.TestConstants\"\n+                \"oracle.code.hat.TestConstants\",\n+                \"oracle.code.hat.TestBlackscholes\",\n+                \"oracle.code.hat.TestNbody\"\n","filename":"hat\/hat\/test.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+GREEN=\"\\033[0;32m\"\n+NC=\"\\033[0m\" # No Color (reset)\n+\n@@ -154,1 +157,1 @@\n-    echo \"ssh $user@$server\"\n+    echo -e \"${GREEN}[info] ssh $user@$server${NC}\"\n@@ -180,1 +183,1 @@\n-      tar xvzf openjdk-22-jextract+6-47_linux-x64_bin.tar.gz\n+      tar xvzf openjdk-22-jextract+6-47_linux-x64_bin.tar.gz > \/dev\/null\n@@ -183,1 +186,1 @@\n-      tar xvzf openjdk-22-jextract+6-47_macos-aarch64_bin.tar.gz\n+      tar xvzf openjdk-22-jextract+6-47_macos-aarch64_bin.tar.gz > \/dev\/null\n@@ -189,3 +192,3 @@\n-source setup.sh\n-java @hat\/clean \n-java @hat\/bld > hatCompilation.log\n+source setup.sh > \/dev\/null 2> \/dev\/null\n+java @hat\/clean > hatCompilation.log 2> hatCompilationErrors.log\n+java @hat\/bld >> hatCompilation.log 2>> hatCompilationErrors.log\n@@ -207,1 +210,1 @@\n-echo \"ssh $user@$server\"\n+echo -e \"\\n${GREEN}[info] ssh $user@$server${NC}\"\n@@ -217,3 +220,3 @@\n-source setup.sh\n-java @hat\/clean \n-java @hat\/bld > compilation.log\n+source setup.sh > \/dev\/null 2> \/dev\/null\n+java @hat\/clean > hatCompilation.log 2> hatCompilationErrors.log\n+java @hat\/bld >> hatCompilation.log 2>> hatCompilationErrors.log\n@@ -224,2 +227,2 @@\n-echo \"[running] java @hat\/test suite \"\\$backend\"  > \"\\$backend\".txt\"\n-java @hat\/test suite \"\\$backend\"  > \"\\$backend\".txt\n+echo -e \"${GREEN}[running] java @hat\/test suite \"\\$backend\" ${NC}\"\n+java @hat\/test suite \"\\$backend\" > \"\\$backend\".txt 2> \"\\$backend\"Errors.txt\n@@ -233,0 +236,12 @@\n+\n+## Run violajones\n+for backend in \"\\${BACKENDS[@]}\"\n+do\n+echo -e \"${GREEN}[running] java -cp hat\/job.jar hat.java run \"\\$backend\" -Dheadless=true violajones${NC}\"\n+java -cp hat\/job.jar hat.java run \"\\$backend\" -Dheadless=true violajones > \"\\$backend\"Violajones.log\n+done\n+\n+for backend in \"\\${BACKENDS[@]}\"\n+do\n+cat \"\\$backend\"Violajones.log | grep \"336faces found\"\n+done\n","filename":"hat\/scripts\/remoteTesting.sh","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.F32Array;\n+import hat.ifacemapper.MappableIface;\n+import hat.ifacemapper.MappableIface.RO;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+import static hat.ifacemapper.MappableIface.*;\n+\n+public class TestBlackscholes {\n+\n+    @CodeReflection\n+    public static void blackScholesKernel(@RO KernelContext kc, @WO F32Array call, @WO F32Array put,\n+                                          @RO F32Array sArray, @RO F32Array xArray, @RO F32Array tArray,\n+                                          float r, float v) {\n+        if (kc.x < kc.gsx) {\n+            float S = sArray.array(kc.x);\n+            float X = xArray.array(kc.x);\n+            float T = tArray.array(kc.x);\n+            float expNegRt = (float) Math.exp(-r * T);\n+            float d1 = (float) ((Math.log(S \/ X) + (r + v * v * .5f) * T) \/ (v * Math.sqrt(T)));\n+            float d2 = (float) (d1 - v * Math.sqrt(T));\n+            float cnd1 = CND(d1);\n+            float cnd2 = CND(d2);\n+            float value = S * cnd1 - expNegRt * X * cnd2;\n+            call.array(kc.x, value);\n+            put.array(kc.x, expNegRt * X * (1 - cnd2) - S * (1 - cnd1));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static float CND(float input) {\n+        float x = input;\n+        if (input < 0f) {\n+            x = -input;\n+        }\n+        float term = 1f \/ (1f + (0.2316419f * x));\n+        float term_pow2 = term * term;\n+        float term_pow3 = term_pow2 * term;\n+        float term_pow4 = term_pow2 * term_pow2;\n+        float term_pow5 = term_pow2 * term_pow3;\n+        float part1 = (1f \/ (float)Math.sqrt(2f * 3.1415926535f)) * (float)Math.exp((-x * x) * 0.5f);\n+        float part2 = (0.31938153f * term) +\n+                (-0.356563782f * term_pow2) +\n+                (1.781477937f * term_pow3) +\n+                (-1.821255978f * term_pow4) +\n+                (1.330274429f * term_pow5);\n+        if (input >= 0f) {\n+            return 1f - part1 * part2;\n+        }\n+        return part1 * part2;\n+    }\n+\n+    @CodeReflection\n+    public static void blackScholes(@MappableIface.RO ComputeContext cc, @WO F32Array call, @WO F32Array put, @MappableIface.RO F32Array S, @MappableIface.RO F32Array X, @MappableIface.RO F32Array T, float r, float v) {\n+        cc.dispatchKernel(call.length(),\n+                kc -> blackScholesKernel(kc, call, put, S, X, T, r, v)\n+        );\n+    }\n+\n+    static F32Array floatArray(Accelerator accelerator, int size, float low, float high) {\n+        F32Array array = F32Array.create(accelerator, size);\n+        Random random = new Random();\n+        for (int i = 0; i <size; i++) {\n+            array.array(i, random.nextFloat() * (high - low) + low);\n+        }\n+        return array;\n+    }\n+\n+    public static void blackScholesKernelSeq(F32Array call, F32Array put, F32Array sArray, F32Array xArray, F32Array tArray, float r, float v) {\n+        for (int i = 0; i <call.length() ; i++) {\n+            float S = sArray.array(i);\n+            float X = xArray.array(i);\n+            float T = tArray.array(i);\n+            float expNegRt = (float) Math.exp(-r * T);\n+            float d1 = (float) ((Math.log(S \/ X) + (r + v * v * .5f) * T) \/ (v * Math.sqrt(T)));\n+            float d2 = (float) (d1 - v * Math.sqrt(T));\n+            float cnd1 = CND(d1);\n+            float cnd2 = CND(d2);\n+            float value = S * cnd1 - expNegRt * X * cnd2;\n+            call.array(i, value);\n+            put.array(i, expNegRt * X * (1 - cnd2) - S * (1 - cnd1));\n+        }\n+    }\n+\n+    @HatTest\n+    public void testBlackscholes() {\n+        int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var call = F32Array.create(accelerator, size);\n+        var put = F32Array.create(accelerator, size);\n+        for (int i = 0; i < put.length(); i++) {\n+            put.array(i, i);\n+            call.array(i, i);\n+        }\n+\n+        var S = floatArray(accelerator, size,1f, 100f);\n+        var X = floatArray(accelerator, size,1f, 100f);\n+        var T = floatArray(accelerator,size, 0.25f, 10f);\n+        float r = 0.02f;\n+        float v = 0.30f;\n+\n+        accelerator.compute(cc -> blackScholes(cc, call, put, S, X, T, r, v));\n+\n+        var seqCall = F32Array.create(accelerator, size);\n+        var seqPut = F32Array.create(accelerator, size);\n+        for (int i = 0; i < seqCall.length(); i++) {\n+            seqCall.array(i, i);\n+            seqPut.array(i, i);\n+        }\n+\n+        blackScholesKernelSeq(seqCall, seqPut, S, X, T, r, v);\n+\n+        for (int i = 0; i < call.length(); i++) {\n+            HatAsserts.assertEquals(seqCall.array(i), call.array(i), 0.01f);\n+            HatAsserts.assertEquals(seqPut.array(i), put.array(i), 0.01f);\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestBlackscholes.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+import static hat.ifacemapper.MappableIface.RO;\n+import static hat.ifacemapper.MappableIface.RW;\n+import static oracle.code.hat.TestNbody.Universe.*;\n+\n+public class TestNbody {\n+\n+    public interface Universe extends Buffer {\n+        int length();\n+\n+        interface Body extends Struct {\n+            float x();\n+            float y();\n+            float z();\n+            float vx();\n+            float vy();\n+            float vz();\n+            void x(float x);\n+            void y(float y);\n+            void z(float z);\n+            void vx(float vx);\n+            void vy(float vy);\n+            void vz(float vz);\n+        }\n+\n+        Body body(long idx);\n+\n+        Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n+                .arrayLen(\"length\").array(\"body\", array -> array\n+                        .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n+                )\n+        );\n+        static Universe create(Accelerator accelerator, int length) {\n+            return schema.allocate(accelerator, length);\n+        }\n+    }\n+\n+    @CodeReflection\n+    static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n+        float accx = 0.0f;\n+        float accy = 0.0f;\n+        float accz = 0.0f;\n+        Body body = universe.body(kc.gix);\n+\n+        for (int i = 0; i < universe.length(); i++) {\n+            Body otherBody = universe.body(i);\n+            float dx = otherBody.x() - body.x();\n+            float dy = otherBody.y() - body.y();\n+            float dz = otherBody.z() - body.z();\n+            float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n+            float s = mass * invDist * invDist * invDist;\n+            accx = accx + (s * dx);\n+            accy = accy + (s * dy);\n+            accz = accz + (s * dz);\n+        }\n+        accx = accx * delT;\n+        accy = accy * delT;\n+        accz = accz * delT;\n+        body.x(body.x() + (body.vx() * delT) + accx * .5f * delT);\n+        body.y(body.y() + (body.vy() * delT) + accy * .5f * delT);\n+        body.z(body.z() + (body.vz() * delT) + accz * .5f * delT);\n+        body.vx(body.vx() + accx);\n+        body.vy(body.vy() + accy);\n+        body.vz(body.vz() + accz);\n+    }\n+\n+    @CodeReflection\n+    public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, final float mass, final float delT, final float espSqr) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(universe.length()));\n+        cc.dispatchKernel(computeRange, kernelContext -> nbodyKernel(kernelContext, universe, mass, delT, espSqr));\n+    }\n+\n+    public static void computeSequential(Universe universe, float mass, float delT, float espSqr) {\n+        float accx = 0.0f;\n+        float accy = 0.0f;\n+        float accz = 0.0f;\n+        for (int j = 0; j < universe.length(); j++) {\n+            Body body = universe.body(j);\n+\n+            for (int i = 0; i < universe.length(); i++) {\n+                Body otherBody = universe.body(i);\n+                float dx = otherBody.x() - body.x();\n+                float dy = otherBody.y() - body.y();\n+                float dz = otherBody.z() - body.z();\n+                float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n+                float s = mass * invDist * invDist * invDist;\n+                accx = accx + (s * dx);\n+                accy = accy + (s * dy);\n+                accz = accz + (s * dz);\n+            }\n+            accx = accx * delT;\n+            accy = accy * delT;\n+            accz = accz * delT;\n+            body.x(body.x() + (body.vx() * delT) + accx * .5f * delT);\n+            body.y(body.y() + (body.vy() * delT) + accy * .5f * delT);\n+            body.z(body.z() + (body.vz() * delT) + accz * .5f * delT);\n+            body.vx(body.vx() + accx);\n+            body.vy(body.vy() + accy);\n+            body.vz(body.vz() + accz);\n+        }\n+    }\n+\n+    @HatTest\n+    public void testNbody() {\n+        final int NUM_BODIES = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        Universe universe = create(accelerator, NUM_BODIES);\n+        Universe universeSeq = create(accelerator, NUM_BODIES);\n+        final float delT = .1f;\n+        final float espSqr = 0.1f;\n+        final float mass = .5f;\n+\n+        Random random = new Random(71);\n+        for (int bodyIdx = 0; bodyIdx < NUM_BODIES; bodyIdx++) {\n+            Body b = universe.body(bodyIdx);\n+\n+            final float theta = (float) (Math.random() * Math.PI * 2);\n+            final float phi = (float) (Math.random() * Math.PI * 2);\n+            final float radius = (float) (Math.random() * 100.f);\n+\n+            \/\/ get random 3D coordinates in sphere\n+            b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n+            b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n+            b.z((float) (radius * Math.cos(phi)));\n+            b.vx(random.nextFloat(1));\n+            b.vy(random.nextFloat(1));\n+            b.vz(random.nextFloat(1));\n+\n+            \/\/ Copy random values into the other body to check results\n+            Body seqBody = universeSeq.body(bodyIdx);\n+            seqBody.x(b.x());\n+            seqBody.y(b.y());\n+            seqBody.z(b.z());\n+\n+            seqBody.vx(b.vx());\n+            seqBody.vy(b.vy());\n+            seqBody.vz(b.vz());\n+\n+        }\n+\n+        accelerator.compute(computeContext -> {\n+            TestNbody.nbodyCompute(computeContext, universe, mass, delT, espSqr);\n+        });\n+\n+        computeSequential(universeSeq, espSqr, mass, espSqr);\n+\n+        \/\/ Check results\n+        float delta = 0.1f;\n+        for (int i = 0; i < NUM_BODIES; i++) {\n+            Body hatBody = universe.body(i);\n+            Body seqBody = universeSeq.body(i);\n+            IO.println(i);\n+            HatAsserts.assertEquals(seqBody.x(), hatBody.x(), delta);\n+            HatAsserts.assertEquals(seqBody.y(), hatBody.y(), delta);\n+            HatAsserts.assertEquals(seqBody.z(), hatBody.z(), delta);\n+            HatAsserts.assertEquals(seqBody.vx(), hatBody.vx(), delta);\n+            HatAsserts.assertEquals(seqBody.vy(), hatBody.vy(), delta);\n+            HatAsserts.assertEquals(seqBody.vz(), hatBody.vz(), delta);\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestNbody.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}