{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import hat.buffer.BufferAllocator;\n@@ -32,2 +31,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n@@ -35,1 +32,0 @@\n-\n@@ -52,1 +48,10 @@\n-    Schema<Box> schema = Schema.of(Box.class, s -> s.fields(\"x1\", \"y1\", \"x2\", \"y2\"));\n+\n+    void width(int width);\n+    void height(int height);\n+    int width();\n+    int height();\n+    int area();\n+    void area(int area);\n+    Schema<Box> schema = Schema.of(Box.class, s ->\n+            s.fields(\"x1\", \"y1\", \"x2\", \"y2\", \"width\", \"height\", \"area\")\n+    );\n@@ -60,0 +65,3 @@\n+        box.width(x2-x1);\n+        box.height(y2-y1);\n+        box.area(box.width()* box.height());\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Box.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package heal;\n-\n-import java.awt.Rectangle;\n-\n-public class BoxImpl implements Box{\n-    final Rectangle rectangle;\n-    public BoxImpl(int x1, int y1, int x2, int y2) {\n-         rectangle =new Rectangle(x1,y1,x2-x1,y2-y1);\n-    }\n-\n-\n-    @Override\n-    public int x1() {\n-        return rectangle.x;\n-    }\n-\n-    @Override\n-    public void x1(int x1) {\n-        rectangle.x=x1;\n-    }\n-\n-    @Override\n-    public int y1() {\n-        return rectangle.y;\n-    }\n-\n-    @Override\n-    public void y1(int y1) {\n-        rectangle.y = y1;\n-    }\n-\n-\n-    @Override\n-    public int x2() {\n-        return rectangle.width+rectangle.x;\n-    }\n-\n-    @Override\n-    public int y2() {\n-        return rectangle.height+rectangle.y;\n-    }\n-\n-    @Override\n-    public void y2(int y2) {\n-        rectangle.height = y2-rectangle.y;\n-    }\n-\n-    @Override\n-    public void x2(int x2) {\n-        rectangle.width = x2-rectangle.x;\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/BoxImpl.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * Based on code from HealingBrush renderscript example\n+ *\n+ * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n+ *\n+ * Copyright (C) 2015 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\n+\n+package heal;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.buffer.F32Array;\n+import hat.buffer.S32Array2D;\n+import java.awt.Point;\n+import java.lang.runtime.CodeReflection;\n+import java.util.stream.IntStream;\n+\n+public class Compute {\n+    \/*\n+     * Original renderscript\n+     *\n+     *  float3 __attribute__((kernel)) solve1(uchar in, uint32_t x, uint32_t y) {\n+     *   if (in > 0) {\n+     *      float3 k = getF32_3(dest1, x - 1, y);\n+     *      k += getF32_3(dest1, x + 1, y);\n+     *      k += getF32_3(dest1, x, y - 1);\n+     *      k += getF32_3(dest1, x, y + 1);\n+     *      k += getF32_3(laplace, x, y);\n+     *      k \/= 4;\n+     *      return k;\n+     *   }\n+     *   return rsGetElementAt_float3(dest1, x, y);\n+     *  }\n+     *\n+     *\n+     *  float3 __attribute__((kernel)) solve2(uchar in, uint32_t x, uint32_t y) {\n+     *   if (in > 0) {\n+     *     float3 k = getF32_3(dest2, x - 1, y);\n+     *     k += getF32_3(dest2, x + 1, y);\n+     *     k += getF32_3(dest2, x, y - 1);\n+     *     k += getF32_3(dest2, x, y + 1);\n+     *        k += getF32_3(laplace, x, y);\n+     *        k \/= 4;\n+     *        return k;\n+     *   }\n+     *   return getF32_3(dest2, x, y);\n+     *  }\n+     *\/\n+\n+    public static void heal(Accelerator accelerator, S32Array2D s32Array2D, Selection selection, Point bestMatchOffset) {\n+        long start = System.currentTimeMillis();\n+        Selection.Mask mask = selection.getMask();\n+        var dest = new int[mask.maskRGBData.length];\n+\n+        IntStream.range(0,mask.maskRGBData.length).parallel().forEach(i-> { \/\/parallel\n+            int x = selection.x1() + i % mask.width;\n+            int y = selection.y1() + i \/ mask.width;\n+            dest[i] = (mask.maskRGBData[i] != 0)\n+                    ? s32Array2D.get( x + bestMatchOffset.x,  y + bestMatchOffset.y)\n+                    : s32Array2D.get( x,  y );\n+        });\n+\n+        System.out.println(\"mask \" + (System.currentTimeMillis() - start) + \"ms\");\n+        \/*   TODO .. Implement lapclacian\n+         * int[] stencil = new int[]{-1, 1, -mask.width, mask.width};\n+         *\n+         * int[] laplaced = new int[dest.length];\n+         *\n+         * boolean laplacian = true;\n+         * if (laplacian) {\n+         *     start = System.currentTimeMillis();\n+         *\n+         *     for (int p = 0; p < src.length; p++) { \/\/parallel\n+         *         int x = p % mask.width;\n+         *         int y = p \/ mask.width;\n+         *\n+         *         int r = 0, g = 0, b = 0;\n+         *         if (x > 0 && x < mask.width - 1 && y > 0 && y < mask.height - 1) {\n+         *             for (int offset : stencil) {\n+         *                 var v = src[p + offset];\n+         *                 r += red(v);\n+         *                 g += green(v);\n+         *                 b += blue(v);\n+         *             }\n+         *         }\n+         *         laplaced[p] = rgb(r, g, b);\n+         *     }\n+         * }\n+         *\n+         * System.out.println(\"laplacian \" + (System.currentTimeMillis() - start) + \"ms\");\n+         * boolean solve = false;\n+         * if (solve) {\n+         *\n+         *     var tmp = new int[dest.length];\n+         *     start = System.currentTimeMillis();\n+         *     for (int i = 0; i < 500; i++) {\n+         *         for (int p = 0; p < mask.width * mask.height; p++) { \/\/ parallel\n+         *             int x = p % mask.width;\n+         *             int y = p \/ mask.width;\n+         *             if (x > 0 && x < mask.width - 1 && y > 0 && y < mask.height - 1 && mask.data[p] != 0) {\n+         *                 \/\/   var rgb = rgbList.rgb(p);\n+         *\n+         *                 var r = red(laplaced[i]);\/\/rgb.r();\n+         *                 var g = green(laplaced[i]);\/\/rgb.g();\n+         *                 var b = blue(laplaced[i]);\/\/rgb.b();\n+         *                 for (int offset : stencil) {\n+         *                     var v = dest[p + offset];\n+         *                     r += red(v);\n+         *                     g += green(v);\n+         *                     b += blue(v);\n+         *                 }\n+         *                 tmp[p] = rgb((r + 2) \/ 4, (g + 2) \/ 4, (b + 2) \/ 4);\n+         *             }\n+         *         }\n+         *         var swap = tmp;\n+         *         tmp = dest;\n+         *         dest = swap;\n+         *     }\n+         *     System.out.println(\"solve \" + (System.currentTimeMillis() - start) + \"ms\");\n+         * }\n+         *\/\n+        start = System.currentTimeMillis();\n+        IntStream.range(0, mask.maskRGBData.length).parallel().forEach(i->{ \/\/parallel\n+            int x =  selection.x1() +i % mask.width;\n+            int y = selection.y1() +i \/ mask.width;\n+            s32Array2D.set( x,  y, dest[i]);\n+        });\n+        System.out.println(\"heal2 \" + (System.currentTimeMillis() - start) + \"ms\");\n+    }\n+\n+    @CodeReflection\n+    static int red(int rgb) {\n+        return (rgb >> 16) & 0xff;\n+    }\n+\n+    @CodeReflection\n+    static int green(int rgb) {\n+        return (rgb >> 8) & 0xff;\n+    }\n+\n+    @CodeReflection\n+    static int blue(int rgb) {\n+        return rgb & 0xff;\n+    }\n+\n+    @CodeReflection\n+    public static void bestFitCore(int id,\n+                                  S32Array2D s32Array2D,\n+                                  Box searchArea,\n+                                  Box selBox,\n+                                  XYRGBList xyrgbList,\n+                                  F32Array sumArray) {\n+        int x = searchArea.x1() + id % searchArea.width();\n+        int y = searchArea.y1() + id \/ searchArea.width();\n+        float sum = 0;\n+        \/\/ don't search inside the area we are trying to heal healing :)\n+        if  (x > selBox.x2() || x + selBox.width() < selBox.x1() || y > selBox.y2() || y + selBox.height() < selBox.y1()){\n+            \/*\n+             * Renderscript\n+             * float __attribute__((kernel)) bordercorrelation(uint32_t x, uint32_t y) {\n+             *    float sum = 0;\n+             *    for(int i = 0 ; i < borderLength; i++) {\n+             *       int2  coord = rsGetElementAt_int2(border_coords,i);\n+             *       float3 orig = convert_float3(rsGetElementAt_uchar4(image, coord.x + x, coord.y + y).xyz);\n+             *       float3 candidate = rsGetElementAt_float3(border, i).xyz;\n+             *       sum += distance(orig, candidate);\n+             *    }\n+             *    return sum;\n+             * }\n+             *\/\n+            int offset = (y - selBox.y1()) * s32Array2D.width() + (x - selBox.x1());\n+            for (int i = 0; i < xyrgbList.length(); i++) {\n+                var xyrgb = xyrgbList.xyrgb(i);\n+                int rgbInt = s32Array2D.array(offset + xyrgb.y() * s32Array2D.width() + xyrgb.x());\n+                int dr = red(rgbInt) - xyrgb.r();\n+                int dg = green(rgbInt) - xyrgb.g();\n+                int db = blue(rgbInt) - xyrgb.b();\n+                sum += dr * dr + dg * dg + db * db;\n+            }\n+        }else{\n+            sum = Float.MAX_VALUE;\n+        }\n+        sumArray.array(id,sum);\n+    }\n+\n+    @CodeReflection\n+    public static void bestFitKernel(KernelContext kc,\n+                                  S32Array2D s32Array2D,\n+                                  Box searchArea,\n+                                  Box selectionBox,\n+                                  XYRGBList xyrgbList,\n+                                  F32Array sumArray) {\n+        bestFitCore(kc.x, s32Array2D, searchArea, selectionBox, xyrgbList, sumArray);\n+    }\n+\n+    @CodeReflection\n+    public static void  bestFitCompute(ComputeContext cc,\n+             Point bestMatchOffset, S32Array2D s32Array2D, Box searchArea, Box selectionBox, XYRGBList xyrgbList){\n+\n+        F32Array sumArrayF32 = F32Array.create(cc.accelerator, searchArea.area());\n+\n+        cc.dispatchKernel(searchArea.area(),\n+                kc -> bestFitKernel(kc,  s32Array2D, searchArea, selectionBox, xyrgbList, sumArrayF32)\n+        );\n+\n+        float[] sumArray = new float[searchArea.area()];\n+        sumArrayF32.copyTo(sumArray);\n+\n+        float minSoFar = Float.MAX_VALUE;\n+        int id = sumArray.length;\n+        for (int i = 0; i < sumArray.length; i++) {\n+            float value = sumArray[i];\n+            if (value < minSoFar) {\n+                id = i;\n+                minSoFar = value;\n+            }\n+        }\n+\n+        int x = searchArea.x1() + (id % searchArea.width());\n+        int y = searchArea.y1() + (id \/ searchArea.width());\n+        bestMatchOffset.setLocation(x - selectionBox.x1(),y - selectionBox.y1());\n+    }\n+\n+    public static Point getBestMatchOffset(Accelerator accelerator, S32Array2D s32Array2D, Selection selection) {\n+        final Point bestMatchOffset  =new Point(0,0);\n+        if (!selection.pointList.isEmpty()) {\n+            long hatStart = System.currentTimeMillis();\n+            XYRGBList xyrgbList = XYRGBList.create(accelerator, selection);\n+            \/*\n+             * Map Point's in the selection to list of XYRGB values at those coordinates.\n+             * Renderscript\n+             * float3 __attribute__((kernel))extractBorder(int2 in) {\n+             *    return convert_float3(rsGetElementAt_uchar4(image, in.x, in.y).xyz);\n+             * }\n+             *\/\n+\n+             IntStream.range(0,selection.pointList.size()).parallel().forEach(i->{\n+                 Point point=selection.pointList.get(i);\n+                 var to = xyrgbList.xyrgb(i);\n+                 var rgbint = s32Array2D.array((long) point.y * s32Array2D.width() + point.x);\n+                 to.x(point.x);\n+                 to.y(point.y);\n+                 to.r(red(rgbint));\n+                 to.g(green(rgbint));\n+                 to.b(blue(rgbint));\n+            });\n+\n+            \/* Create a search box of pad * selection (w & h), but constrain to bounds of the image\n+             *\n+             *            +----------------------+Image\n+             *       +.W..W--W--W--W--W--W--W-+  |\n+             *       .  ^ |                   |  |\n+             *       .    |    +-W-+Selection |  |\n+             *       .    |   H|   |          |  |\n+             *       .    |    +---+          |  |\n+             *       .    |                   |  |\n+             *       .  v +-------------------|--+\n+             *       .    <- SearchBoxWidth ->.\n+             *       +........................+SearchBox\n+             *\/\n+            int pad = 8;\n+            int padx = selection.width() * pad;\n+            int pady = selection.height() * pad;\n+\n+            Box searchArea = Box.create(accelerator,\n+                    Math.max(0, selection.x1() - padx),\n+                    Math.max(0, selection.y1() - pady),\n+                    Math.min(s32Array2D.width(), selection.x2() + padx) - selection.width(),\n+                    Math.min(s32Array2D.height(), selection.y2() + pady) - selection.height()\n+            );\n+            Box selectionBox = Box.create(accelerator, selection.x1(), selection.y1(), selection.x2(), selection.y2());\n+\n+            accelerator.compute(cc->\n+                    Compute.bestFitCompute(cc, bestMatchOffset, s32Array2D, searchArea, selectionBox, xyrgbList\n+            ));\n+            System.out.println(\"total search \" + (System.currentTimeMillis() - hatStart) + \"ms\");\n+        }\n+        return bestMatchOffset;\n+    }\n+}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Compute.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-package heal;\n-\n-\n-import javax.swing.JPanel;\n-import javax.swing.SwingUtilities;\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Graphics;\n-import java.awt.Point;\n-import java.awt.Graphics2D;\n-import java.awt.event.MouseEvent;\n-import java.awt.event.MouseListener;\n-import java.awt.event.MouseMotionListener;\n-import java.awt.event.MouseWheelEvent;\n-import java.awt.event.MouseWheelListener;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.NoninvertibleTransformException;\n-import java.awt.geom.Point2D;\n-\n-public abstract class Display extends JPanel implements MouseListener, MouseMotionListener, MouseWheelListener {\n-    protected ImageData imageData;\n-    protected AffineTransform transform = new AffineTransform();\n-    protected float zoom = .95f; \/\/ set the zoom factor 1.0 = fit to screen\n-\n-    protected float xOffset = 0; \/\/ 0 is centered -1 is to the left;\n-    protected float yOffset = 0; \/\/ 0 is centered -1 is to the top;\n-\n-    Point mousePressedPosition;\n-    Point2D imageRelativeMouseDownPosition = new Point2D.Float();\n-    Point2D imageRelativeMovePosition = new Point2D.Float();\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        if (SwingUtilities.isRightMouseButton(e)) {\n-            mousePressedPosition = e.getPoint();\n-            try {\n-                imageRelativeMouseDownPosition= transform.inverseTransform(e.getPoint(), null);\n-            } catch (NoninvertibleTransformException e1) {\n-                e1.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void mouseWheelMoved(MouseWheelEvent e) {\n-        zoom = zoom * (1 + e.getWheelRotation() \/ 10f);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        if (SwingUtilities.isRightMouseButton(e)) {\n-            Point rightButonPoint = e.getPoint();\n-            Dimension deltaFromInitialMousePress = new Dimension(rightButonPoint.x - mousePressedPosition.x, rightButonPoint.y - mousePressedPosition.y);\n-            try {\n-                imageRelativeMovePosition = transform.inverseTransform(e.getPoint(), null);\n-                Dimension displaySize = getSize();\n-                Dimension imageSize = new Dimension( imageData.width(),imageData.height());\n-                float scale = zoom *\n-                        Math.min(displaySize.width \/ (float) imageSize.width,\n-                                displaySize.height \/ (float) imageSize.height);\n-                xOffset =  2 * (deltaFromInitialMousePress.width \/ (displaySize.width - scale * imageSize.width));\n-                yOffset =  2 * (deltaFromInitialMousePress.height \/ (displaySize.height - scale * imageSize.height));\n-                xOffset = Math.max(Math.min(xOffset, 1), -1);\n-                yOffset = Math.max(Math.min(yOffset, 1), -1);\n-                repaint();\n-            } catch (NoninvertibleTransformException e1) {\n-                e1.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    public Display(ImageData imageData) {\n-        this.imageData = imageData;\n-        addMouseListener(this);\n-        addMouseWheelListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D g2d = (Graphics2D) g;\n-        g2d.setBackground(Color.BLACK);\n-        g2d.fillRect(0, 0, getWidth(), getHeight());\n-        if (imageData != null) {\n-            Dimension displaySize = getSize();\n-            Dimension imageSize = new Dimension( imageData.width(),imageData.height());\n-            AffineTransform safeTransform = g2d.getTransform();\n-            transform.setToIdentity();\n-            double scale = zoom *\n-                    Math.min(displaySize.width \/ (double) imageSize.width,\n-                            displaySize.height \/ (double) imageSize.height);\n-            transform.translate((1 + xOffset) * (displaySize.width - imageSize.width * scale) \/ 2,\n-                    (1 + yOffset) * (displaySize.height - imageSize.height * scale) \/ 2);\n-            transform.scale(scale, scale);\n-            g2d.transform(transform);\n-            g.drawImage(imageData.bufferedImage, 0, 0, imageSize.width, imageSize.height, null);\n-            paintInScale(g2d);\n-            g2d.setTransform(safeTransform);\n-        }\n-    }\n-\n-    abstract protected void paintInScale(Graphics2D g) ;\n-\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Display.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-\n-\n-package heal;\n-\n-import hat.Accelerator;\n-\n-import java.awt.Point;\n-import java.lang.runtime.CodeReflection;\n-\n-\/*\n- From the original renderscript\n-\n- float3 __attribute__((kernel)) solve1(uchar in, uint32_t x, uint32_t y) {\n-  if (in > 0) {\n-     float3 k = getF32_3(dest1, x - 1, y);\n-     k += getF32_3(dest1, x + 1, y);\n-     k += getF32_3(dest1, x, y - 1);\n-     k += getF32_3(dest1, x, y + 1);\n-     k += getF32_3(laplace, x, y);\n-     k \/= 4;\n-     return k;\n-  }\n-  return rsGetElementAt_float3(dest1, x, y);;\n-}\n-\n-\n-float3 __attribute__((kernel)) solve2(uchar in, uint32_t x, uint32_t y) {\n-  if (in > 0) {\n-    float3 k = getF32_3(dest2, x - 1, y);\n-    k += getF32_3(dest2, x + 1, y);\n-    k += getF32_3(dest2, x, y - 1);\n-    k += getF32_3(dest2, x, y + 1);\n-       k += getF32_3(laplace, x, y);\n-       k \/= 4;\n-       return k;\n-  }\n-  return getF32_3(dest2, x, y);;\n-}\n-\n- *\/\n-public class HealCompute {\n-\n-    static int red(int rgb) {\n-        return (rgb >> 16) & 0xff;\n-    }\n-\n-\n-    static int green(int rgb) {\n-        return (rgb >> 8) & 0xff;\n-    }\n-\n-\n-    static int blue(int rgb) {\n-        return rgb & 0xff;\n-    }\n-\n-    @CodeReflection\n-    static int rgb(int r, int g, int b) {\n-        return ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);\n-    }\n-\n-\n-    public static void heal(Accelerator accelerator,ImageData imageData, Path selectionPath, Point healPositionOffset) {\n-        long start = System.currentTimeMillis();\n-        Mask mask = new Mask(selectionPath);\n-        var src = new int[mask.data.length];\n-        var dest = new int[mask.data.length];\n-\n-        for (int i = 0; i < mask.data.length; i++) { \/\/parallel\n-            int x = i % mask.width;\n-            int y = i \/ mask.width;\n-            src[i] = imageData.getXY(selectionPath.x1() + x + healPositionOffset.x, selectionPath.y1() + y - 1 + healPositionOffset.y);\n-            dest[i] = (mask.data[i] != 0)\n-                    ? src[i]\n-                    : imageData.getXY(+selectionPath.x1() + x, selectionPath.y1() + y - 1);\n-        }\n-\n-        System.out.println(\"mask \" + (System.currentTimeMillis() - start) + \"ms\");\n-\/*\n-        int[] stencil = new int[]{-1, 1, -mask.width, mask.width};\n-\n-        int[] laplaced = new int[dest.length];\n-\n-        boolean laplacian = true;\n-        if (laplacian) {\n-            start = System.currentTimeMillis();\n-\n-            for (int p = 0; p < src.length; p++) { \/\/parallel\n-                int x = p % mask.width;\n-                int y = p \/ mask.width;\n-\n-                int r = 0, g = 0, b = 0;\n-                if (x > 0 && x < mask.width - 1 && y > 0 && y < mask.height - 1) {\n-                    for (int offset : stencil) {\n-                        var v = src[p + offset];\n-                        r += red(v);\n-                        g += green(v);\n-                        b += blue(v);\n-                    }\n-                }\n-                laplaced[p] = rgb(r, g, b);\n-            }\n-        }\n-\n-        System.out.println(\"laplacian \" + (System.currentTimeMillis() - start) + \"ms\");\n-        boolean solve = false;\n-        if (solve) {\n-\n-            var tmp = new int[dest.length];\n-            start = System.currentTimeMillis();\n-            for (int i = 0; i < 500; i++) {\n-                for (int p = 0; p < mask.width * mask.height; p++) { \/\/ parallel\n-                    int x = p % mask.width;\n-                    int y = p \/ mask.width;\n-                    if (x > 0 && x < mask.width - 1 && y > 0 && y < mask.height - 1 && mask.data[p] != 0) {\n-                        \/\/   var rgb = rgbList.rgb(p);\n-\n-                        var r = red(laplaced[i]);\/\/rgb.r();\n-                        var g = green(laplaced[i]);\/\/rgb.g();\n-                        var b = blue(laplaced[i]);\/\/rgb.b();\n-                        for (int offset : stencil) {\n-                            var v = dest[p + offset];\n-                            r += red(v);\n-                            g += green(v);\n-                            b += blue(v);\n-                        }\n-                        tmp[p] = rgb((r + 2) \/ 4, (g + 2) \/ 4, (b + 2) \/ 4);\n-                    }\n-                }\n-                var swap = tmp;\n-                tmp = dest;\n-                dest = swap;\n-            }\n-            System.out.println(\"solve \" + (System.currentTimeMillis() - start) + \"ms\");\n-        }\n-*\/\n-        start = System.currentTimeMillis();\n-        for (int i = 0; i < mask.data.length; i++) { \/\/parallel\n-            int x = i % mask.width;\n-            int y = i \/ mask.width;\n-            imageData.setXY(selectionPath.x1() + x, selectionPath.y1() + y - 1, dest[i]);\n-        }\n-        System.out.println(\"heal2 \" + (System.currentTimeMillis() - start) + \"ms\");\n-    }\n-\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/HealCompute.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-package heal;\n-\n-import hat.buffer.S32Array;\n-import hat.buffer.S32Array2D;\n-\n-import javax.imageio.ImageIO;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.DataBufferInt;\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-public class ImageData implements S32Array2D {\n-    final BufferedImage bufferedImage;\n-     int widthField;\n-     int heightField;\n-    public final int[] arrayOfData;\n-\n-    @Override\n-    public int width() {\n-        return widthField;\n-    }\n-\n-    @Override\n-    public int height() {\n-        return heightField;\n-    }\n-    public int length() {\n-        return width()*height();\n-    }\n-\n-\n-    @Override\n-    public int array(long idx){\n-        return arrayOfData[(int)idx];\n-    }\n-    @Override\n-    public void array(long idx, int v){\n-        arrayOfData[(int) idx]=v;\n-    }\n-\n-    private  ImageData(BufferedImage bufferedImage) {\n-        this.bufferedImage = bufferedImage;\n-        this.widthField=bufferedImage.getWidth();\n-        this.heightField=bufferedImage.getHeight();\n-        this.arrayOfData = ((DataBufferInt) (bufferedImage.getRaster().getDataBuffer())).getData();\n-    }\n-    static BufferedImage to(BufferedImage originalImage, int type){\n-        BufferedImage image=null;\n-        if (originalImage.getType() == type){\n-            image = originalImage;\n-        }else {\n-            image = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), type);\n-            image.getGraphics().drawImage(originalImage, 0, 0, null);\n-        }\n-        return image;\n-    }\n-    static ImageData of(InputStream inputStream){\n-        try {\n-           return new ImageData(ImageData.to(ImageIO.read(inputStream),BufferedImage.TYPE_INT_RGB));\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    public int getXY(int x, int y) {\n-        return this.array(y*this.widthField+x);\n-    }\n-\n-    public void setXY(int x, int y, int rgb) {\n-        this.array(y*this.widthField+x,rgb);\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/ImageData.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.buffer.S32Array2D;\n@@ -30,0 +31,1 @@\n+import javax.imageio.ImageIO;\n@@ -32,0 +34,2 @@\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n@@ -35,1 +39,8 @@\n-    public static void main(String[] args) {\n+\n+    public static void main(String[] args) throws IOException {\n+        var image= ImageIO.read(Main.class.getResourceAsStream(\"\/images\/bolton.png\"));\n+        if (image.getType() != BufferedImage.TYPE_INT_RGB){\/\/Better way?\n+            var rgbimage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n+            rgbimage.getGraphics().drawImage(image, 0, 0, null);\n+            image=rgbimage;\n+        }\n@@ -37,3 +48,1 @@\n-        ImageData imageData = ImageData.of(\n-                Viewer.class.getResourceAsStream(\"\/images\/bolton.png\")\n-        );\n+\n@@ -41,1 +50,1 @@\n-        f.setBounds(new Rectangle(imageData.width(), imageData.height()));\n+        f.setBounds(new Rectangle(image.getWidth(),image.getHeight()));\n@@ -43,2 +52,1 @@\n-        Viewer viewerDisplay = new Viewer(imageData, accelerator);\n-        f.setContentPane(viewerDisplay);\n+        f.setContentPane( new Viewer(accelerator,image));\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Main.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package heal;\n-\n-import java.awt.Color;\n-import java.awt.Graphics2D;\n-import java.awt.Polygon;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.DataBufferInt;\n-import java.util.Arrays;\n-\n-class Mask {\n-    public final int[] data;\n-    public final int width;\n-    public final int height;\n-\n-    public Mask(Path path) {\n-        width = path.width()+2;\n-        height = path.height()+2;\n-        Polygon polygon = new Polygon();\n-        for (int i = 0; i < path.xyList.length(); i++) {\n-            XYList.XY xy = path.xyList.xy(i);\n-            polygon.addPoint(xy.x() - path.x1() + 1, xy.y() - path.y1() + 1);\n-        }\n-        BufferedImage maskImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n-        data = ((DataBufferInt) (maskImg.getRaster().getDataBuffer())).getData();\n-        Arrays.fill(data, 0);\n-        Graphics2D g = maskImg.createGraphics();\n-        g.setColor(Color.WHITE);\n-        g.fillPolygon(polygon);\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Mask.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-package heal;\n-\n-import java.awt.Rectangle;\n-\n-public class Path  {\n-\n-    public final XYList xyList;\n-    private Rectangle bounds = new Rectangle(Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE);\n-    Path(XYList xyList){\n-        this.xyList =xyList;\n-    }\n-\n-    public void add(int x, int y){\n-        if (xyList.length()>0) {\n-            XYList.XY lastxy = xyList.xy(xyList.length() - 1);\n-            add(lastxy.x(), lastxy.y(), x, y);\n-        }else{\n-            ( (XYListImpl)xyList).add(x, y);\n-            bounds.add(x,y);\n-        }\n-    }\n-    public Path close(){\n-        var first = xyList.xy(0);\n-        add(first.x(), first.y());\n-        return this;\n-    }\n-\n-    public int x1(){\n-        return bounds.x;\n-    }\n-    public int y1(){\n-        return bounds.y;\n-    }\n-    public int width(){\n-        return bounds.width;\n-    }\n-    public int height(){\n-        return bounds.height;\n-    }\n-    public int x2(){\n-        return x1()+width();\n-    }\n-    public int y2(){\n-        return y1()+height();\n-    }\n-\n-    private void add(int x1, int y1, int x2, int y2) {\n-        int x = x1;\n-        int y = y1;\n-        int w = x2 - x;\n-        int h = y2 - y;\n-        int dx1 = Integer.compare(w, 0);\n-        int dy1 = Integer.compare(h, 0);\n-        int dx2 = dx1;\n-        int dy2 = 0;\n-        int longest = Math.abs(w);\n-        int shortest = Math.abs(h);\n-        if (longest <= shortest) {\n-            longest = Math.abs(h);\n-            shortest = Math.abs(w);\n-            dy2 = Integer.compare(h, 0);\n-            dx2 = 0;\n-        }\n-        int numerator = longest >> 1;\n-        for (int i = 0; i <= longest; i++) {\n-\n-            ( (XYListImpl)xyList).add(x, y);\n-            bounds.add(x,y);\n-            numerator += shortest;\n-            if (numerator >= longest) {\n-                numerator -= longest;\n-                x += dx1;\n-                y += dy1;\n-            } else {\n-                x += dx2;\n-                y += dy2;\n-            }\n-        }\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Path.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package heal;\n-\n-import hat.Accelerator;\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.Schema;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public interface RGBList extends Buffer {\n-    interface RGB extends Buffer.Struct{\n-        int r();\n-        int g();\n-        int b();\n-        void r(int r);\n-        void g(int g);\n-        void b(int b);\n-    }\n-    int length();\n-    RGB rgb(long idx);\n-\n-    Schema<RGBList> schema= Schema.of(RGBList.class, s->s\n-            .arrayLen(\"length\")\n-            .array(\"rgb\", rgb->rgb\n-                    .fields(\"r\",\"g\",\"b\")\n-            )\n-    );\n-\n-    static RGBList create(Accelerator accelerator, int length) {\n-        return schema.allocate(accelerator,length);\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/RGBList.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-package heal;\n-\n-import java.util.Arrays;\n-\n-public class RGBListImpl implements RGBList {\n-    final static int INIT=32;\n-    final static int STRIDE= 3;\n-    final static int Ridx= 0;\n-    final static int Gidx= 1;\n-    final static int Bidx= 2;\n-\n-    public int length;\n-    int[] rgb = new int[INIT*STRIDE];\n-\n-    @Override\n-    public RGB rgb(long idx) {\n-        return new RGB(this, (int)idx);\n-    }\n-\n-    @Override\n-    public int length() {\n-        return length;\n-    }\n-\n-\n-    static public class RGB implements RGBList.RGB{\n-        RGBListImpl rgbList;\n-        final int idx;\n-        RGB(RGBListImpl rgbList, int idx){\n-            this.rgbList = rgbList;\n-            this.idx = idx;\n-        }\n-        @Override\n-        public int r() {\n-            return rgbList.rgb[idx*STRIDE+Ridx];\n-        }\n-\n-        @Override\n-        public int g() {\n-            return rgbList.rgb[idx*STRIDE+Gidx];\n-        }\n-\n-        @Override\n-        public int b() {\n-                return rgbList.rgb[idx*STRIDE+Bidx];\n-        }\n-\n-        @Override\n-        public void r(int r) {\n-            rgbList.rgb[idx*STRIDE+Ridx]=r;\n-        }\n-\n-        @Override\n-        public void g(int g) {\n-            rgbList.rgb[idx*STRIDE+Gidx]=g;\n-        }\n-\n-        @Override\n-        public void b(int b) {\n-            rgbList.rgb[idx*STRIDE+Bidx]=b;\n-        }\n-    }\n-    void r(int idx, int r){\n-        rgb[idx*STRIDE+Ridx]=r;\n-\n-    }\n-    void g(int idx, int g){\n-        rgb[idx*STRIDE+Gidx]=g;\n-\n-    }\n-    void b(int idx, int b){\n-        rgb[idx*STRIDE+Bidx]=b;\n-\n-    }\n-    void set(int idx, int r,int g, int b){\n-        rgb[idx*STRIDE+Ridx]=r;\n-        rgb[idx*STRIDE+Gidx]=g;\n-        rgb[idx*STRIDE+Bidx]=b;\n-    }\n-\n-    void add(int r,int g, int b){\n-        if (length*STRIDE>= rgb.length){\n-            rgb = Arrays.copyOf(rgb, rgb.length*STRIDE);\n-        }\n-        set(length, r, g, b);\n-        length++;\n-    }\n-\n-    public void addRGB(int v) {\n-        add( ((v >> 16) & 0xFF), ((v >> 8) & 0xFF), ((v >> 0) & 0xFF));\n-    }\n-\n-    public RGBListImpl(){\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/RGBListImpl.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-\n-\n-package heal;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.buffer.F32Array;\n-import hat.buffer.S32Array;\n-import hat.buffer.S32Array2D;\n-\n-import java.awt.Point;\n-import java.lang.runtime.CodeReflection;\n-import java.util.stream.IntStream;\n-\n-\/*\n- From the original renderscript\n-\n-float3 __attribute__((kernel))extractBorder(int2 in) {\n-  return convert_float3(rsGetElementAt_uchar4(image, in.x, in.y).xyz);\n-}\n-\n-float __attribute__((kernel)) bordercorrelation(uint32_t x, uint32_t y) {\n-  float sum = 0;\n-  for(int i = 0 ; i < borderLength; i++) {\n-    int2  coord = rsGetElementAt_int2(border_coords,i);\n-    float3 orig = convert_float3(rsGetElementAt_uchar4(image, coord.x + x, coord.y + y).xyz);\n-    float3 candidate = rsGetElementAt_float3(border, i).xyz;\n-    sum += distance(orig, candidate);\n-  }\n-  return sum;\n-}\n- *\/\n-public class SearchCompute {\n-    @CodeReflection\n-    static int red(int rgb) {\n-        return (rgb >> 16) & 0xff;\n-    }\n-\n-    @CodeReflection\n-    static int green(int rgb) {\n-        return (rgb >> 8) & 0xff;\n-    }\n-\n-    @CodeReflection\n-    static int blue(int rgb) {\n-        return rgb & 0xff;\n-    }\n-\n-\n-    @CodeReflection\n-    public static float getSum(S32Array2D imageData, Box selectionBox, XYList selectionXYList, RGBList selectionRgbList, int x, int y) {\n-        int offset = (y - selectionBox.y1()) * imageData.width() + (x - selectionBox.x1());\n-        float sum = 0;\n-        for (int i = 0; i < selectionXYList.length(); i++) {\n-            var xy = selectionXYList.xy(i);\n-            var rgb = selectionRgbList.rgb(i);\n-            int rgbFromImage = imageData.array(offset + xy.y() * imageData.width() + xy.x());\n-            int dr = red(rgbFromImage) - rgb.r();\n-            int dg = green(rgbFromImage) - rgb.g();\n-            int db = blue(rgbFromImage) - rgb.b();\n-            sum += dr * dr + dg * dg + db * db;\n-        }\n-        return sum;\n-    }\n-    @CodeReflection\n-    public static boolean isInSelection(Box selectionBox, int x, int y) {\n-        int selectionBoxWidth = selectionBox.x2() - selectionBox.x1();\n-        int selectionBoxHeight = selectionBox.y2() - selectionBox.y1();\n-        return (!(x > selectionBox.x2() || x + selectionBoxWidth < selectionBox.x1() || y > selectionBox.y2() || y + selectionBoxHeight < selectionBox.y1()));\n-    }\n-\n-    \/*\n-          float __attribute__((kernel)) bordercorrelation(uint32_t x, uint32_t y) {\n-            float sum = 0;\n-            for(int i = 0 ; i < borderLength; i++) {\n-               int2  coord = rsGetElementAt_int2(border_coords,i);\n-               float3 orig = convert_float3(rsGetElementAt_uchar4(image, coord.x + x, coord.y + y).xyz);\n-               float3 candidate = rsGetElementAt_float3(border, i).xyz;\n-               sum += distance(orig, candidate);\n-            }\n-            return sum;\n-          }\n-       *\/\n-    @CodeReflection\n-    public static void bestKernel(KernelContext kc,\n-                                  S32Array2D s32Array2D,\n-                                  RGBList rgbList,\n-                                  Box searchBox,\n-                                  Box selectionBox,\n-                                  XYList selectionXYList,\n-                                  F32Array sumArray) {\n-        int id = kc.x;\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int x = searchBox.x1() + id % searchBoxWidth;\n-        int y = searchBox.y1() + id \/ searchBoxWidth;\n-        if (isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-            sumArray.array(id, Float.MAX_VALUE);\n-        } else {\n-            sumArray.array(id,  getSum(s32Array2D, selectionBox, selectionXYList, rgbList, x, y));\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static int getMinIdx(float[] sumArray){\n-        float minSoFar = Float.MAX_VALUE;\n-        int id = sumArray.length;\n-        for (int i = 0; i < sumArray.length; i++) {\n-            float value = sumArray[i];\n-            if (value < minSoFar) {\n-                id = i;\n-                minSoFar = value;\n-            }\n-        }\n-        return id;\n-    }\n-\n-    @CodeReflection\n-    public static void  bestCompute(ComputeContext cc,\n-             Point offset,\n-                                    S32Array2D s32Array2D,  RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList){\n-\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int searchBoxHeight = searchBox.y2() - searchBox.y1();\n-        int range = searchBoxWidth * searchBoxHeight;\n-        F32Array sumArrayF32 = F32Array.create(cc.accelerator, range);\n-        cc.dispatchKernel(range,\n-                kc -> bestKernel(kc,  s32Array2D,rgbList, searchBox, selectionBox, selectionXYList, sumArrayF32));\n-        float[] sumArray = new float[range];\n-        sumArrayF32.copyTo(sumArray);\n-        int id = getMinIdx(sumArray);\n-        int x = searchBox.x1() + (id % searchBoxWidth);\n-        int y = searchBox.y1() + (id \/ searchBoxWidth);\n-        offset.setLocation(x - selectionBox.x1(),y - selectionBox.y1());\n-    }\n-\n-    public static Point getOffsetOfBestMatch(Accelerator accelerator, ImageData imageData, Path selectionPath) {\n-        final Point offset  =new Point(0,0);\n-        if (selectionPath.xyList.length() != 0) {\n-            \/*\n-            Walk the list of xy coordinates in the path and extract a list of RGB values\n-            for those coordinates.\n-             *\/\n-            RGBListImpl rgbList = new RGBListImpl();\n-            for (int i = 0; i < selectionPath.xyList.length(); i++) {\n-                XYList.XY xy = selectionPath.xyList.xy(i);\n-                rgbList.addRGB(imageData.array(xy.y() * imageData.width() + xy.x()));\n-            }\n-\n-            \/*\n-              Create a search box of pad * selection (w & h), but constrain the box to bounds of the image\n-             *\/\n-            int pad = 4;\n-            int padx = selectionPath.width() * pad;\n-            int pady = selectionPath.height() * pad;\n-            int x1 = Math.max(0, selectionPath.x1() - padx);\n-            int y1 = Math.max(0, selectionPath.y1() - pady);\n-            int x2 = Math.min(imageData.width(), selectionPath.x2() + padx) - selectionPath.width();\n-            int y2 = Math.min(imageData.height(), selectionPath.y2() + pady) - selectionPath.height();\n-            BoxImpl searchBox = new BoxImpl(x1, y1, x2, y2);\n-\n-\n-            \/\/All data passed to accelerator needs to be iface mapped segments\n-            RGBList mappedRGBList = RGBList.create(accelerator,rgbList.length);\n-            for (int i=0;i<rgbList.length; i++){\n-                var from = rgbList.rgb(i);\n-                var to = mappedRGBList.rgb(i);\n-                to.r(from.r());\n-                to.g(from.g());\n-                to.b(from.b());\n-            }\n-\n-            Box  mappedSearchBox = Box.create(accelerator, searchBox.x1(),searchBox.y1(),searchBox.x2(),searchBox.y2());\n-            Box  mappedSelectionBox = Box.create(accelerator, selectionPath.x1(),selectionPath.y1(),selectionPath.x2(),selectionPath.y2());\n-\n-\n-            XYList  mappedSelectionXYList = XYList.create(accelerator,selectionPath.xyList.length());\n-            for (int i=0;i<mappedSelectionXYList.length();i++){\n-                var from = selectionPath.xyList.xy(i);\n-                var to = mappedSelectionXYList.xy(i);\n-                to.x(from.x());\n-                to.y(from.y());\n-            }\n-            S32Array2D s32Array2D = S32Array2D.create(accelerator,imageData.width(),imageData.height());\n-            s32Array2D.copyFrom(imageData.arrayOfData);\n-            long hatStart = System.currentTimeMillis();\n-            accelerator.compute(cc->SearchCompute.bestCompute(cc,offset,\n-                    s32Array2D,mappedRGBList,mappedSearchBox,\n-                    mappedSelectionBox,\n-                    mappedSelectionXYList\n-            ));\n-            System.out.println(\"total search \" + (System.currentTimeMillis() - hatStart) + \"ms\");\n-        }\n-        return offset;\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/SearchCompute.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * Based on code from HealingBrush renderscript example\n+ *\n+ * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n+ *\n+ * Copyright (C) 2015 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+package heal;\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import java.awt.geom.Point2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferInt;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class Selection {\n+    public static class Mask {\n+        public final Selection selection;\n+        public final int[] maskRGBData;\n+        public final int width;\n+        public final int height;\n+        public final Polygon polygon;\n+        private Mask(Selection selection) {\n+            this.selection = selection;\n+            width = selection.width()+2;\n+            height = selection.height()+2;\n+\n+            this.polygon = new Polygon();\n+            selection.pointList.forEach(p->\n+                    polygon.addPoint(p.x- selection.x1() + 1,p.y- selection.y1() + 1)\n+            );\n+\n+            BufferedImage maskImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+            maskRGBData = ((DataBufferInt) (maskImg.getRaster().getDataBuffer())).getData();\n+            Arrays.fill(maskRGBData, 0);\n+            Graphics2D g = maskImg.createGraphics();\n+            g.setColor(Color.WHITE);\n+            g.fillPolygon(polygon);\n+        }\n+    }\n+\n+    private Rectangle bounds = new Rectangle(Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE);\n+    final List<Point> pointList = new ArrayList<>();\n+    final Point first;\n+    Point prevPoint = null;\n+\n+    Selection(Point2D point){\n+        this.first = new Point((int)point.getX(),(int)point.getY());\n+        this.prevPoint=first;\n+        this.bounds.add(first);\n+    }\n+    public void add(Point2D point){\n+        var newPoint = new Point((int)point.getX(),(int)point.getY());\n+        add(prevPoint, newPoint);\n+        bounds.add(newPoint);\n+        prevPoint = newPoint;\n+    }\n+    public Selection close(){\n+        add(first);\n+        return this;\n+    }\n+\n+    public Mask getMask(){\n+        return new Mask(this);\n+    }\n+\n+    public int x1(){\n+        return bounds.x;\n+    }\n+    public int y1(){\n+        return bounds.y;\n+    }\n+    public int width(){\n+        return bounds.width;\n+    }\n+    public int height(){\n+        return bounds.height;\n+    }\n+    public int x2(){\n+        return x1()+width();\n+    }\n+    public int y2(){\n+        return y1()+height();\n+    }\n+    private void add(Point2D from, Point2D to) {\n+        int x = (int)from.getX();\n+        int y = (int)from.getY();\n+        int w = (int)(to.getX() - from.getX());\n+        int h = (int)(to.getY() - from.getY());\n+        int dx1 = Integer.compare(w, 0);\n+        int dy1 = Integer.compare(h, 0);\n+        int dx2 = dx1;\n+        int dy2 = 0;\n+        int longest = Math.abs(w);\n+        int shortest = Math.abs(h);\n+        if (longest <= shortest) {\n+            longest = Math.abs(h);\n+            shortest = Math.abs(w);\n+            dy2 = Integer.compare(h, 0);\n+            dx2 = 0;\n+        }\n+        int numerator = longest >> 1;\n+        for (int i = 0; i <= longest; i++) {\n+            Point point  = new Point(x, y);\n+            pointList.add(point);\n+            bounds.add(point);\n+            numerator += shortest;\n+            if (numerator >= longest) {\n+                numerator -= longest;\n+                x += dx1;\n+                y += dy1;\n+            } else {\n+                x += dx2;\n+                y += dy2;\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Selection.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+\n@@ -47,0 +48,1 @@\n+import hat.buffer.S32Array2D;\n@@ -48,0 +50,1 @@\n+import javax.swing.JPanel;\n@@ -51,1 +54,2 @@\n-import java.awt.Graphics2D;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n@@ -53,0 +57,1 @@\n+import java.awt.Graphics2D;\n@@ -59,0 +64,1 @@\n+import java.awt.geom.AffineTransform;\n@@ -60,0 +66,10 @@\n+import java.awt.geom.Point2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferInt;\n+\n+public  class Viewer extends JPanel {\n+    protected BufferedImage image;\n+    protected  int[] rasterData;\n+    protected S32Array2D s32Array2D;\n+    protected AffineTransform transform = new AffineTransform();\n+    protected float zoom = .95f; \/\/ set the zoom factor 1.0 = fit to screen\n@@ -61,2 +77,7 @@\n-public class Viewer extends Display {\n-    volatile Path selectionPath = null;\n+    protected float xOffset = 0; \/\/ 0 is centered -1 is to the left;\n+    protected float yOffset = 0; \/\/ 0 is centered -1 is to the top;\n+\n+    Point mousePressedPosition;\n+    Point2D imageRelativeMouseDownPosition = new Point2D.Float();\n+    Point2D imageRelativeMovePosition = new Point2D.Float();\n+    volatile Selection selection = null;\n@@ -64,4 +85,7 @@\n-    public final Accelerator accelerator;\n-    public Viewer(ImageData imageData, Accelerator accelerator) {\n-        super(imageData);\n-        this.accelerator = accelerator;\n+\n+\n+    public Viewer(Accelerator accelerator,BufferedImage image) {\n+        this.image = image;\n+        this.rasterData = ((DataBufferInt) (image.getRaster().getDataBuffer())).getData();\n+        this.s32Array2D =  S32Array2D.create(accelerator,image.getWidth(),image.getHeight());\n+        s32Array2D.copyFrom(rasterData);\n@@ -69,1 +93,2 @@\n-           @Override\n+\n+            @Override\n@@ -72,2 +97,2 @@\n-                    bestMatchOffset = SearchCompute.getOffsetOfBestMatch(accelerator, imageData, selectionPath.close());\n-                    HealCompute.heal(accelerator,imageData,selectionPath, bestMatchOffset);\n+                    bestMatchOffset = Compute.getBestMatchOffset(accelerator, s32Array2D, selection.close());\n+                    Compute.heal(accelerator,s32Array2D, selection, bestMatchOffset);\n@@ -77,1 +102,1 @@\n-                            selectionPath = null;\n+                            selection = null;\n@@ -93,2 +118,8 @@\n-                        selectionPath = new Path(new XYListImpl());\n-                        selectionPath.add((int)ptDst.getX(), (int) ptDst.getY());\n+                        selection = new Selection(ptDst);\n+                    } catch (NoninvertibleTransformException e1) {\n+                        e1.printStackTrace();\n+                    }\n+                }else if (SwingUtilities.isRightMouseButton(e)) {\n+                    mousePressedPosition = e.getPoint();\n+                    try {\n+                        imageRelativeMouseDownPosition= transform.inverseTransform(e.getPoint(), null);\n@@ -102,0 +133,4 @@\n+        addMouseWheelListener(e -> {\n+            zoom = zoom * (1 + e.getWheelRotation() \/ 10f);\n+            repaint();\n+        });\n@@ -103,0 +138,1 @@\n+            @Override\n@@ -104,1 +140,19 @@\n-                if (SwingUtilities.isLeftMouseButton(e)) {\n+                if (SwingUtilities.isRightMouseButton(e)) {\n+                    Point rightButonPoint = e.getPoint();\n+                    Dimension deltaFromInitialMousePress = new Dimension(rightButonPoint.x - mousePressedPosition.x, rightButonPoint.y - mousePressedPosition.y);\n+                    try {\n+                        imageRelativeMovePosition = transform.inverseTransform(e.getPoint(), null);\n+                        Dimension displaySize = getSize();\n+                        Dimension imageSize = new Dimension( s32Array2D.width(),s32Array2D.height());\n+                        float scale = zoom *\n+                                Math.min(displaySize.width \/ (float) imageSize.width,\n+                                        displaySize.height \/ (float) imageSize.height);\n+                        xOffset =  2 * (deltaFromInitialMousePress.width \/ (displaySize.width - scale * imageSize.width));\n+                        yOffset =  2 * (deltaFromInitialMousePress.height \/ (displaySize.height - scale * imageSize.height));\n+                        xOffset = Math.max(Math.min(xOffset, 1), -1);\n+                        yOffset = Math.max(Math.min(yOffset, 1), -1);\n+                        repaint();\n+                    } catch (NoninvertibleTransformException e1) {\n+                        e1.printStackTrace();\n+                    }\n+                } else if (SwingUtilities.isLeftMouseButton(e)) {\n@@ -107,1 +161,1 @@\n-                        selectionPath.add((int) ptDst.getX(), (int) ptDst.getY());\n+                        selection.add(ptDst);\n@@ -118,0 +172,23 @@\n+    @Override\n+    public void paint(Graphics g) {\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.setBackground(Color.BLACK);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+        if (s32Array2D != null) {\n+            Dimension displaySize = getSize();\n+            Dimension imageSize = new Dimension( s32Array2D.width(),s32Array2D.height());\n+            AffineTransform safeTransform = g2d.getTransform();\n+            transform.setToIdentity();\n+            double scale = zoom *\n+                    Math.min(displaySize.width \/ (double) imageSize.width,\n+                            displaySize.height \/ (double) imageSize.height);\n+            transform.translate((1 + xOffset) * (displaySize.width - imageSize.width * scale) \/ 2,\n+                    (1 + yOffset) * (displaySize.height - imageSize.height * scale) \/ 2);\n+            transform.scale(scale, scale);\n+            g2d.transform(transform);\n+            s32Array2D.copyTo(rasterData);\n+            g.drawImage(image, 0, 0, imageSize.width, imageSize.height, null);\n+            paintInScale(g2d);\n+            g2d.setTransform(safeTransform);\n+        }\n+    }\n@@ -119,1 +196,1 @@\n-        if (selectionPath != null) {\n+        if (selection != null) {\n@@ -122,3 +199,2 @@\n-            for (int i=0;i<selectionPath.xyList.length();i++){\n-                XYList.XY xy = selectionPath.xyList.xy(i);\n-                selectionPolygon.addPoint(xy.x(), xy.y());\n+            selection.pointList.forEach(point -> {\n+                selectionPolygon.addPoint(point.x, point.y);\n@@ -126,1 +202,1 @@\n-                    solutionPolygon.addPoint(xy.x()+bestMatchOffset.x, xy.y()+bestMatchOffset.y);\n+                    solutionPolygon.addPoint(point.x+bestMatchOffset.x, point.y+bestMatchOffset.y);\n@@ -128,1 +204,1 @@\n-            }\n+            });\n@@ -137,0 +213,2 @@\n+\n+\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Viewer.java","additions":99,"deletions":21,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package heal;\n-\n-import hat.Accelerator;\n-import hat.buffer.Buffer;\n-import hat.buffer.BufferAllocator;\n-import hat.ifacemapper.Schema;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-public interface XYList extends Buffer {\n-    interface XY extends Buffer.Struct{\n-        int x();\n-        int y();\n-        void y(int y);\n-        void x(int x);\n-    }\n-    int length();\n-  \/\/  void length(int length );\n-    XY xy(long idx);\n-\n-    Schema<XYList> schema= Schema.of(XYList.class, s->s\n-            .arrayLen(\"length\")\n-            .array(\"xy\", xy->xy\n-                    .fields(\"x\",\"y\")\n-            )\n-    );\n-\n-    static XYList create(Accelerator accelerator, int length) {\n-        return  schema.allocate(accelerator,length);\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/XYList.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-package heal;\n-\n-import java.util.Arrays;\n-\n-public class XYListImpl implements XYList {\n-    final static int INIT= 32;\n-    final static int STRIDE= 2;\n-    final static int Xidx = 0;\n-    final static int Yidx = 1;\n-    private int length;\n-    protected int[] xy = new int[INIT*STRIDE];\n-\n-    @Override\n-    public XYList.XY xy(long idx) {\n-        return new XY(this, (int) idx);\n-    }\n-\n-    @Override\n-    public int length() {\n-        return length;\n-    }\n-\n-    public static class XY implements XYList.XY{\n-        final XYListImpl xyList;\n-        final private int idx;\n-        public XY(XYListImpl table, int idx) {\n-            this.xyList=table;this.idx = idx;\n-        }\n-\n-        @Override\n-        public int x() {\n-            return xyList.xy[idx*STRIDE+ Xidx];\n-        }\n-\n-        @Override\n-        public int y() {\n-            return xyList.xy[idx*STRIDE+ Yidx];\n-        }\n-\n-\n-        @Override\n-        public void y(int y) {\n-            xyList.xy[idx*STRIDE+ Yidx] =y;\n-        }\n-\n-        @Override\n-        public void x(int x) {\n-            xyList.xy[idx*STRIDE+ Yidx]=x;\n-        }\n-    }\n-\n-\n-    void add(int x,int y){\n-        if (length*STRIDE>=xy.length){\n-            xy = Arrays.copyOf(xy, xy.length*STRIDE);\n-        }\n-        xy[length*STRIDE+Xidx]=x;\n-        xy[length*STRIDE+Yidx]=y;\n-        length++;\n-    }\n-\n-    XYListImpl(){\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/XYListImpl.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package heal;\n+\n+import hat.Accelerator;\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.Schema;\n+\n+public interface XYRGBList extends Buffer {\n+    interface XYRGB extends Buffer.Struct{\n+        int x();\n+        int y();\n+        void y(int y);\n+        void x(int x);\n+        int r();\n+        int g();\n+        int b();\n+        void r(int r);\n+        void g(int g);\n+        void b(int b);\n+    }\n+    int length();\n+    XYRGB xyrgb(long idx);\n+    Schema<XYRGBList> schema= Schema.of(XYRGBList.class, s->s\n+            .arrayLen(\"length\")\n+            .array(\"xyrgb\", xy->xy\n+                    .fields(\"x\",\"y\",\"r\",\"g\",\"b\")\n+            )\n+    );\n+    static XYRGBList create(Accelerator accelerator, Selection selection) {\n+        return  schema.allocate(accelerator,selection.pointList.size());\n+    }\n+}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/XYRGBList.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -1,346 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * Based on code from HealingBrush renderscript example\n- *\n- * https:\/\/github.com\/yongjhih\/HealingBrush\/tree\/master\n- *\n- * Copyright (C) 2015 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\/\n-\n-\n-package heal.attic;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.buffer.F32Array;\n-import hat.buffer.S32Array2D;\n-import heal.Box;\n-import heal.BoxImpl;\n-import heal.ImageData;\n-import heal.Path;\n-import heal.RGBList;\n-import heal.RGBListImpl;\n-import heal.XYList;\n-\n-import java.awt.Point;\n-import java.lang.runtime.CodeReflection;\n-import java.util.stream.IntStream;\n-\n-\/*\n- From the original renderscript\n-\n-float3 __attribute__((kernel))extractBorder(int2 in) {\n-  return convert_float3(rsGetElementAt_uchar4(image, in.x, in.y).xyz);\n-}\n-\n-float __attribute__((kernel)) bordercorrelation(uint32_t x, uint32_t y) {\n-  float sum = 0;\n-  for(int i = 0 ; i < borderLength; i++) {\n-    int2  coord = rsGetElementAt_int2(border_coords,i);\n-    float3 orig = convert_float3(rsGetElementAt_uchar4(image, coord.x + x, coord.y + y).xyz);\n-    float3 candidate = rsGetElementAt_float3(border, i).xyz;\n-    sum += distance(orig, candidate);\n-  }\n-  return sum;\n-}\n- *\/\n-public class SearchComputeSafe {\n-    @CodeReflection\n-    static int red(int rgb) {\n-        return (rgb >> 16) & 0xff;\n-    }\n-\n-    @CodeReflection\n-    static int green(int rgb) {\n-        return (rgb >> 8) & 0xff;\n-    }\n-\n-    @CodeReflection\n-    static int blue(int rgb) {\n-        return rgb & 0xff;\n-    }\n-\n-\n-    @CodeReflection\n-    public static float getSum(S32Array2D imageData, Box selectionBox, XYList selectionXYList, RGBList selectionRgbList, int x, int y) {\n-        int offset = (y - selectionBox.y1()) * imageData.width() + (x - selectionBox.x1());\n-        float sum = 0;\n-        for (int i = 0; i < selectionXYList.length(); i++) {\n-            var xy = selectionXYList.xy(i);\n-            var rgb = selectionRgbList.rgb(i);\n-            int rgbFromImage = imageData.array(offset + xy.y() * imageData.width() + xy.x());\n-            int dr = red(rgbFromImage) - rgb.r();\n-            int dg = green(rgbFromImage) - rgb.g();\n-            int db = blue(rgbFromImage) - rgb.b();\n-            sum += dr * dr + dg * dg + db * db;\n-        }\n-        return sum;\n-    }\n-    @CodeReflection\n-    public static boolean isInSelection(Box selectionBox, int x, int y) {\n-        int selectionBoxWidth = selectionBox.x2() - selectionBox.x1();\n-        int selectionBoxHeight = selectionBox.y2() - selectionBox.y1();\n-        return (!(x > selectionBox.x2() || x + selectionBoxWidth < selectionBox.x1() || y > selectionBox.y2() || y + selectionBoxHeight < selectionBox.y1()));\n-    }\n-\n-    public static Point original(ImageData imageData, RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList) {\n-        float minSoFar = Float.MAX_VALUE;\n-        Point bestSoFar = new Point(0, 0);\n-        for (int y = searchBox.y1(); y < searchBox.y2(); y++) {\n-            for (int x = searchBox.x1(); x < searchBox.x2(); x++) {\n-                if (!isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-                    float sum = getSum(imageData, selectionBox, selectionXYList, rgbList, x, y);\n-                    if (sum < minSoFar) {\n-                        minSoFar = sum;\n-                        bestSoFar.setLocation(x - selectionBox.x1(), y - selectionBox.y1());\n-                    }\n-                }\n-            }\n-        }\n-        return bestSoFar;\n-    }\n-\n-    public static Point sequential(ImageData imageData, RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList) {\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int searchBoxHeight = searchBox.y2() - searchBox.y1();\n-        int range = searchBoxWidth * searchBoxHeight;\n-        float minSoFar = Float.MAX_VALUE;\n-        int bestId = range+1;\n-        for (int id = 0; id < range; id++) {\n-            int x = searchBox.x1() + id % searchBoxWidth;\n-            int y = searchBox.y1() + id \/ searchBoxWidth;\n-            if (!isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-                float sum = getSum(imageData, selectionBox, selectionXYList, rgbList, x, y);\n-                if (sum < minSoFar) {\n-                    minSoFar = sum;\n-                    bestId = id;\n-\n-                }\n-            }\n-        }\n-        int x = searchBox.x1() + (bestId % searchBoxWidth);\n-        int y = searchBox.y1() + (bestId \/ searchBoxWidth);\n-        return new Point(x - selectionBox.x1(), y - selectionBox.y1());\n-    }\n-\n-\n-    public static Point parallel(ImageData imageData, RGBList rgbList, Box searchBox, Box selectionBox, XYList selectionXYList) {\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int searchBoxHeight = searchBox.y2() - searchBox.y1();\n-        int range = searchBoxWidth * searchBoxHeight;\n-        float[] sumArray = new float[range];\n-        IntStream.range(0, range).parallel().forEach(id -> {\n-            int x = searchBox.x1() + id % searchBoxWidth;\n-            int y = searchBox.y1() + id \/ searchBoxWidth;\n-            if (isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-                sumArray[id] = Float.MAX_VALUE;\n-            } else {\n-                sumArray[id] = getSum(imageData, selectionBox, selectionXYList, rgbList, x, y);\n-            }\n-        });\n-        float minSoFar = Float.MAX_VALUE;\n-        int id = sumArray.length + 1;\n-        for (int i = 0; i < sumArray.length; i++) {\n-            float value = sumArray[i];\n-            if (value < minSoFar) {\n-                id = i;\n-                minSoFar = value;\n-            }\n-        }\n-        int x = searchBox.x1() + (id % searchBoxWidth);\n-        int y = searchBox.y1() + (id \/ searchBoxWidth);\n-        return new Point(x - selectionBox.x1(), y - selectionBox.y1());\n-    }\n-\n-    \/*\n-          float __attribute__((kernel)) bordercorrelation(uint32_t x, uint32_t y) {\n-            float sum = 0;\n-            for(int i = 0 ; i < borderLength; i++) {\n-               int2  coord = rsGetElementAt_int2(border_coords,i);\n-               float3 orig = convert_float3(rsGetElementAt_uchar4(image, coord.x + x, coord.y + y).xyz);\n-               float3 candidate = rsGetElementAt_float3(border, i).xyz;\n-               sum += distance(orig, candidate);\n-            }\n-            return sum;\n-          }\n-       *\/\n-    @CodeReflection\n-    public static void bestKernel(KernelContext kc,\n-                                  S32Array2D s32Array2D,\n-                                  RGBList rgbList,\n-                                  Box searchBox,\n-                                  Box selectionBox,\n-                                  XYList selectionXYList,\n-                                  F32Array sumArray) {\n-        int id = kc.x;\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int x = searchBox.x1() + id % searchBoxWidth;\n-        int y = searchBox.y1() + id \/ searchBoxWidth;\n-        if (isInSelection(selectionBox, x, y)) {\/\/ don't search inside the area we are healing\n-            sumArray.array(id, Float.MAX_VALUE);\n-        } else {\n-            sumArray.array(id,  getSum(s32Array2D, selectionBox, selectionXYList, rgbList, x, y));\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static int getMinIdx(float[] sumArray){\n-        float minSoFar = Float.MAX_VALUE;\n-        int id = sumArray.length;\n-        for (int i = 0; i < sumArray.length; i++) {\n-            float value = sumArray[i];\n-            if (value < minSoFar) {\n-                id = i;\n-                minSoFar = value;\n-            }\n-        }\n-        return id;\n-    }\n-\n-    @CodeReflection\n-    public static void  bestCompute(ComputeContext cc,\n-                                  S32Array2D s32Array2D,  RGBList rgbList,\n-                                    Box searchBox, Box selectionBox, XYList selectionXYList, XY result){\n-\n-        int searchBoxWidth = searchBox.x2() - searchBox.x1();\n-        int searchBoxHeight = searchBox.y2() - searchBox.y1();\n-        int range = searchBoxWidth * searchBoxHeight;\n-\n-        F32Array sumArrayF32 = F32Array.create(cc.accelerator, range);\n-\n-        cc.dispatchKernel(range,\n-                kc -> bestKernel(kc,  s32Array2D,rgbList, searchBox, selectionBox, selectionXYList, sumArrayF32));\n-\n-        float[] sumArray = new float[range];\n-        sumArrayF32.copyTo(sumArray);\n-        int id = getMinIdx(sumArray);\n-\n-\n-        int x = searchBox.x1() + (id % searchBoxWidth);\n-        int y = searchBox.y1() + (id \/ searchBoxWidth);\n-        result.x(x - selectionBox.x1());\n-        result.y(y - selectionBox.y1());\n-        \/\/return new Point(x - selectionBox.x1(), y - selectionBox.y1());\n-    }\n-\n-    public static Point getOffsetOfBestMatch(Accelerator accelerator,ImageData imageData, Path selectionPath) {\n-        Point offset = null;\n-        if (selectionPath.xyList.length() != 0) {\n-            \/*\n-            Walk the list of xy coordinates in the path and extract a list of RGB values\n-            for those coordinates.\n-             *\/\n-            RGBListImpl rgbList = new RGBListImpl();\n-            for (int i = 0; i < selectionPath.xyList.length(); i++) {\n-                XYList.XY xy = selectionPath.xyList.xy(i);\n-                rgbList.addRGB(imageData.array(xy.y() * imageData.width() + xy.x()));\n-            }\n-\n-            \/*\n-              Create a search box of pad * selection (w & h), but constrain the box to bounds of the image\n-             *\/\n-            int pad = 4;\n-            int padx = selectionPath.width() * pad;\n-            int pady = selectionPath.height() * pad;\n-            int x1 = Math.max(0, selectionPath.x1() - padx);\n-            int y1 = Math.max(0, selectionPath.y1() - pady);\n-            int x2 = Math.min(imageData.width(), selectionPath.x2() + padx) - selectionPath.width();\n-            int y2 = Math.min(imageData.height(), selectionPath.y2() + pady) - selectionPath.height();\n-            BoxImpl searchBox = new BoxImpl(x1, y1, x2, y2);\n-            long searchStart = System.currentTimeMillis();\n-\n-            boolean useOriginal = true;\n-            boolean useSequential = true;\n-            \/\/ if (useOriginal) {\n-            long originalStart = System.currentTimeMillis();\n-            Box selectionBox = new BoxImpl(selectionPath.x1(), selectionPath.y1(), selectionPath.x2(), selectionPath.y2());\n-            XYList selectionXYList = selectionPath.xyList;\n-            offset = original(imageData, rgbList, searchBox, selectionBox, selectionXYList);\n-            System.out.println(\"original search \" + (System.currentTimeMillis() - originalStart) + \"ms\");\n-            \/\/  } else {\n-            \/\/   if (useSequential) {\n-            long sequentialStart = System.currentTimeMillis();\n-            offset = sequential(imageData, rgbList, searchBox, selectionBox, selectionXYList);\n-            System.out.println(\"sequential search \" + (System.currentTimeMillis() - sequentialStart) + \"ms\");\n-            \/\/    } else {\n-            long parallelStart = System.currentTimeMillis();\n-            offset = parallel(imageData, rgbList, searchBox, selectionBox, selectionXYList);\n-            System.out.println(\"parallel search \" + (System.currentTimeMillis() - parallelStart) + \"ms\");\n-            \/\/ }\n-\n-            \/\/All data passed to accelerator needs to be iface mapped segments\n-            RGBList mappedRGBList = RGBList.create(accelerator,rgbList.length);\n-            for (int i=0;i<rgbList.length; i++){\n-                var from = rgbList.rgb(i);\n-                var to = mappedRGBList.rgb(i);\n-                to.r(from.r());\n-                to.g(from.g());\n-                to.b(from.b());\n-            }\n-\n-            Box  mappedSearchBox = Box.create(accelerator, searchBox.x1(),searchBox.y1(),searchBox.x2(),searchBox.y2());\n-            Box  mappedSelectionBox = Box.create(accelerator, selectionPath.x1(),selectionPath.y1(),selectionPath.x2(),selectionPath.y2());\n-            XY result = XY.create(accelerator,0,0);\n-\n-            XYList  mappedSelectionXYList = XYList.create(accelerator,selectionPath.xyList.length());\n-            for (int i=0;i<mappedSelectionXYList.length();i++){\n-                var from = selectionPath.xyList.xy(i);\n-                var to = mappedSelectionXYList.xy(i);\n-                to.x(from.x());\n-                to.y(from.y());\n-            }\n-            S32Array2D s32Array2D = S32Array2D.create(accelerator,imageData.width(),imageData.height());\n-            s32Array2D.copyFrom(imageData.arrayOfData);\n-            long hatStart = System.currentTimeMillis();\n-            accelerator.compute(cc-> SearchComputeSafe.bestCompute(cc,s32Array2D,mappedRGBList,mappedSearchBox,\n-                    mappedSelectionBox,\n-                    mappedSelectionXYList,\n-                    result\n-            ));\n-\n-\n-            System.out.println(\"offset \"+offset+ \" result\"+result.x()+\",\"+result.y());\n-            System.out.println(\"hat search \" + (System.currentTimeMillis() - hatStart) + \"ms\");\n-\n-\n-            System.out.println(\"total search \" + (System.currentTimeMillis() - searchStart) + \"ms\");\n-        }\n-        return offset;\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/attic\/SearchComputeSafe.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package heal.attic;\n-\n-import hat.Accelerator;\n-import hat.buffer.Buffer;\n-import hat.ifacemapper.Schema;\n-\n-public interface XY extends Buffer {\n-    int x();\n-    void x(int x);\n-    int y();\n-    void y(int y);\n-\n-    Schema<XY> schema = Schema.of(XY.class, s -> s.fields(\"x\", \"y\"));\n-\n-    static XY create(Accelerator accelerator, int x,int y) {\n-        XY xy = schema.allocate(accelerator);\n-        xy.x(x);\n-        xy.y(y);\n-        return xy;\n-    }\n-}\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/attic\/XY.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -60,0 +61,4 @@\n+    default S32Array2D copyTo(int[] ints) {\n+        MemorySegment.copy(Buffer.getMemorySegment(this), JAVA_INT, 2* JAVA_INT.byteSize(),  ints, 0, width()*height());\n+        return this;\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}