{"files":[{"patch":"@@ -82,2 +82,1 @@\n-        Regex szRegex = Regex.of(\"ls([xyz])\");\n-        Regex idxRegex = Regex.of(\"li([xyz])\");\n+\n@@ -90,1 +89,1 @@\n-        Regex idxRegex = Regex.of(\"bi([xyz])\");\n+\n@@ -94,2 +93,1 @@\n-        Regex idxRegex = Regex.of(\"(gi[xyz])\");\n-        Regex szRegex = Regex.of(\"(gs[xyz])\");\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/NDRange.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import hat.phases.HATDialectifyTier;\n-import jdk.incubator.code.*;\n+import hat.phases.HATDTier;\n@@ -35,1 +34,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -88,1 +86,1 @@\n-        HATDialectifyTier tier = new HATDialectifyTier(this);\n+        HATDTier tier = new HATDTier(this);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    public final static Regex regex = NDRange.Block.idxRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBlockThreadIdOp.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    static final public Regex regex= NDRange.Global.szRegex;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalSizeOp.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-    public static final Regex regex= NDRange.Global.idxRegex;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalThreadIdOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-    public static Regex regex= NDRange.Local.szRegex;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalSizeOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-    static public  final Regex regex = NDRange.Local.idxRegex;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalThreadIdOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,5 +55,0 @@\n-   \/\/ @Override\n-   \/\/ public TypeElement resultType() {\n-     \/\/   return super.typeElement;\n-   \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorStoreView.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,3 +52,0 @@\n-        static boolean isVarAccessFromKernelContextFieldOp(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return isKernelContextFieldAccessOp(lookup, varLoadOp, AnyFieldAccess);\/\/varLoadOp.resultType());\n-        }\n@@ -57,1 +54,2 @@\n-            if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp && KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType())) {\n+            if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp\n+                    && KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType())) {\n@@ -63,12 +61,0 @@\n-        static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, String name) {\n-            return asKernelContextFieldAccessOrNull(lookup, ce, fieldAccessOp -> name.equals(fieldAccessOp.fieldDescriptor().name()));\n-        }\n-\n-        static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Regex regex) {\n-            return asKernelContextFieldAccessOrNull(lookup, ce, fieldAccessOp -> regex.matches(fieldAccessOp.fieldDescriptor().name()));\n-        }\n-\n-        static boolean isKernelContextFieldAccessOp(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n-            return Objects.nonNull(asKernelContextFieldAccessOrNull(lookup, ce, predicate));\n-        }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/KernelContextPattern.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public class PatternSelector {\n+    Set<CodeModelPattern> codeModelPatterns = new LinkedHashSet<>();\n+    public PatternSelector add(CodeModelPattern codeModelPattern){\n+        codeModelPatterns.add(codeModelPattern);\n+        return this;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/PatternSelector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -330,12 +330,0 @@\n-        static Edge<JavaOp.FieldAccessOp.FieldLoadOp, CoreOp.VarAccessOp.VarLoadOp> kernelContextFieldVarLoad(\n-                MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp, Predicate<String> fieldNamePredicate) {\n-            record FieldVarLoadEdge<\n-                    F extends JavaOp.FieldAccessOp.FieldLoadOp,\n-                    T extends CoreOp.VarAccessOp.VarLoadOp>(F f, T t, Set<Op> ops) implements Edge<F, T> {\n-            }\n-            return (\n-                    fieldAccessOpNameMatches(fieldLoadOp, fieldNamePredicate) instanceof JavaOp.FieldAccessOp.FieldLoadOp\n-                            && opFromOperandAsResult(fieldLoadOp, 0) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                            && KernelContextPattern.KernelContextFieldAccessPattern.isVarAccessFromKernelContextFieldOp(lookup,varLoadOp))\n-                    ? new FieldVarLoadEdge<>(fieldLoadOp, varLoadOp, Set.of(fieldLoadOp, varLoadOp)) : null;\n-        }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public record HATDialectifyArrayViewPhase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n+public record HATArrayViewPhase(KernelCallGraph kernelCallGraph) implements HATPhase {\n@@ -368,1 +368,1 @@\n-        var here = CallSite.of(HATDialectifyArrayViewPhase.class, \"isArrayView\");\n+        var here = CallSite.of(HATArrayViewPhase.class, \"isArrayView\");\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","status":"renamed"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.callgraph.KernelCallGraph;\n+import hat.dialect.HATBarrierOp;\n+import hat.optools.KernelContextPattern;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.util.CallSite;\n+import optkl.OpTkl;\n+\n+import java.util.Objects;\n+\n+import static optkl.OpTkl.simpleOpMappingTransform;\n+\n+public record HATBarrierPhase(KernelCallGraph kernelCallGraph) implements HATPhase {\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp fromFuncOp) {\n+        var here = CallSite.of(HATBarrierPhase.class, \"apply\");\n+        before(here, fromFuncOp);\n+        OpTkl.OpMap opMap = simpleOpMappingTransform(\n+                \/* for debugging we will remove *\/ here,\n+                                                   fromFuncOp,\n+                \/* filter op                    *\/ ce -> Objects.nonNull(\n+                                                         KernelContextPattern.KernelContextInvokePattern.matches(lookup(), ce,\n+                                                         invokeOp->invokeOp.invokeDescriptor().name().equals(HATBarrierOp.NAME))),\n+                \/* replace op                   *\/ HATBarrierOp::new\n+        );\n+        after(here, opMap.toFuncOp());\n+        return opMap.toFuncOp();\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -58,1 +58,1 @@\n-public abstract sealed class HATDialectifyMemoryPhase implements HATDialectPhase {\n+public abstract sealed class HATDMemoryPhase implements HATPhase {\n@@ -81,1 +81,1 @@\n-    public HATDialectifyMemoryPhase(KernelCallGraph kernelCallGraph) {\n+    public HATDMemoryPhase(KernelCallGraph kernelCallGraph) {\n@@ -129,1 +129,1 @@\n-    public static final class PrivateMemoryPhase extends HATDialectifyMemoryPhase {\n+    public static final class PrivateMemoryPhase extends HATDMemoryPhase {\n@@ -158,1 +158,1 @@\n-    public static final  class LocalMemoryPhase extends HATDialectifyMemoryPhase {\n+    public static final  class LocalMemoryPhase extends HATDMemoryPhase {\n@@ -189,1 +189,1 @@\n-    public static final class DeviceTypePhase extends HATDialectifyMemoryPhase {\n+    public static final class DeviceTypePhase extends HATDMemoryPhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDMemoryPhase.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","status":"renamed"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.callgraph.KernelCallGraph;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.util.carriers.LookupCarrier;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.function.Function;\n+\n+public class HATDTier implements  LookupCarrier {\n+    KernelCallGraph kernelCallGraph;\n+    @Override\n+    public MethodHandles.Lookup lookup(){\n+        return kernelCallGraph.lookup();\n+    }\n+    private List<HATPhase> hatPhases = new ArrayList<>();\n+\n+    public HATDTier(KernelCallGraph kernelCallGraph) {\n+        this.kernelCallGraph = kernelCallGraph;\n+        \/\/ barriers\n+        hatPhases.add(new HATBarrierPhase(kernelCallGraph));\n+\n+        \/\/ array views\n+        hatPhases.add(new HATArrayViewPhase(kernelCallGraph));\n+\n+        \/\/ Memory\n+        hatPhases.add(new HATDMemoryPhase.LocalMemoryPhase(kernelCallGraph));\n+        hatPhases.add(new HATDMemoryPhase.PrivateMemoryPhase(kernelCallGraph));\n+        hatPhases.add(new HATDMemoryPhase.DeviceTypePhase(kernelCallGraph));\n+\n+        \/\/ ID's \/thread access\n+        hatPhases.add(new HATThreadsPhase.GlobalIdPhase(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.GlobalSizePhase(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LocalIdPhase(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LocalSizePhase(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.BlockPhase(kernelCallGraph));\n+\n+        \/\/ views for vector types\n+        hatPhases.add(new HATVectorPhase.Float4LoadPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.Float2LoadPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.Float4OfPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.AddPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.SubPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.MulPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.DivPhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorPhase.MakeMutable(kernelCallGraph));\n+        hatPhases.add(new HATVectorStorePhase.Float4StorePhase(kernelCallGraph));\n+        hatPhases.add(new HATVectorStorePhase.Float2StorePhase(kernelCallGraph));\n+\n+        \/\/ Vector Select individual lines\n+        hatPhases.add(new HATVectorSelectPhase(kernelCallGraph));\n+\n+        \/\/ F16 type\n+        hatPhases.add(new HATFP16Phase(kernelCallGraph));\n+\n+    }\n+\n+    \/\/ It computes a set of function code model transformations from FuncOp to FuncOp'.\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        BlockingQueue<Function<CoreOp.FuncOp,CoreOp.FuncOp>> queue = new ArrayBlockingQueue<>(hatPhases.size());\n+        queue.addAll(hatPhases);\n+\n+        CoreOp.FuncOp f = funcOp;\n+        while (!queue.isEmpty()) {\n+            try {\n+                \/\/ TODO Did we just trash side tables ?\n+                Function<CoreOp.FuncOp,CoreOp.FuncOp> phase = queue.take();\n+                f = phase.apply(f);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return f;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDTier.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.callgraph.KernelCallGraph;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import optkl.util.CallSite;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Function;\n-\n-public sealed interface HATDialectPhase extends Function<CoreOp.FuncOp,CoreOp.FuncOp>,LookupCarrier\n-        permits HATDialectifyArrayViewPhase, HATDialectifyBarrierPhase, HATDialectifyFP16Phase,\n-        HATDialectifyMemoryPhase, HATDialectifyThreadsPhase, HATDialectifyVectorOpPhase, HATDialectifyVectorSelectPhase, HATDialectifyVectorStorePhase {\n-\n-\n-    KernelCallGraph kernelCallGraph();\n-\n-    @Override default MethodHandles.Lookup lookup(){\n-        return kernelCallGraph().lookup();\n-    }\n-\n-    default boolean tracing(){\n-            return kernelCallGraph().config().showCompilationPhases();\n-    }\n-\n-    default void before(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model before [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \"  + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-\n-    default void after(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \" + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectPhase.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.callgraph.KernelCallGraph;\n-import hat.dialect.HATBarrierOp;\n-import hat.optools.KernelContextPattern;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n-\n-import java.util.Objects;\n-\n-import static optkl.OpTkl.simpleOpMappingTransform;\n-\n-public record HATDialectifyBarrierPhase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n-\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp fromFuncOp) {\n-        var here = CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n-        before(here, fromFuncOp);\n-        \/\/ The resulting op map also includes all op mappings (so op -> op') and the to and from funcOp\n-        \/\/ I expect this to be useful for tracking state...\n-\n-        OpTkl.OpMap opMap = simpleOpMappingTransform(\n-                \/* for debugging we will remove *\/ here, fromFuncOp,\n-                \/* filter op                    *\/ ce -> Objects.nonNull(KernelContextPattern.KernelContextInvokePattern.matches(lookup(), ce, invokeOp->invokeOp.invokeDescriptor().name().equals(HATBarrierOp.NAME))),\n-                \/* replace op                   *\/ HATBarrierOp::new\n-        );\n-        after(here, opMap.toFuncOp());\n-        return opMap.toFuncOp();\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-\n-import hat.callgraph.KernelCallGraph;\n-import hat.dialect.HATBlockThreadIdOp;\n-import hat.dialect.HATGlobalSizeOp;\n-import hat.dialect.HATGlobalThreadIdOp;\n-import hat.dialect.HATLocalSizeOp;\n-import hat.dialect.HATLocalThreadIdOp;\n-import hat.dialect.HATThreadOp;\n-import hat.optools.KernelContextPattern;\n-import hat.optools.Trxfmr;\n-\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n-import optkl.util.Regex;\n-\n-import java.util.Objects;\n-\n-import static optkl.OpTkl.operandsAsResults;\n-\n-public sealed abstract class HATDialectifyThreadsPhase<T extends HATDialectifyThreadsPhase<T,C>,C extends HATThreadOp> implements HATDialectPhase {\n-    private final KernelCallGraph kernelCallGraph;\n-    @Override public KernelCallGraph kernelCallGraph(){\n-        return kernelCallGraph;\n-    }\n-    final Class<C> clazz;\n-    static int dimIdx(String name){\n-        int dim = name.length()==3?name.charAt(2)-'x':-1;\n-        if (dim <0||dim>3){\n-            throw new IllegalStateException();\/\/'x'=1,'y'=2....\n-        }\n-        return dim;\n-    }\n-    static int dimIdx(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-        return dimIdx(fieldLoadOp.fieldDescriptor().name());\n-    }\n-    public HATDialectifyThreadsPhase(KernelCallGraph kernelCallGraph, Class<C> clazz) {\n-        this.kernelCallGraph=kernelCallGraph;\n-        this.clazz=clazz;\n-    }\n-\n-    protected abstract  HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp);\n-\n-    protected abstract Regex regex();\n-\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-        var txfmr = new Trxfmr(CallSite.of(this.getClass()),funcOp);\n-       \/\/ var collect =  funcOp.elements().map(ce-> KernelContextFieldAccessPattern.matches(lookup(),ce, _->true)).filter(Objects::nonNull).toList();\n-        \/\/System.out.println(\"@@@@@@@@@@@@@@@@Found \"+collect.size());\n-\n-\n-        return txfmr.select(\n-                ce-> KernelContextPattern.KernelContextFieldAccessPattern.asNamedKernelContextFieldAccessOrNull(lookup(),ce,regex())!=null,(s, o)->\n-                   operandsAsResults(o)\n-                     .map(OpTkl::opOfResultOrNull)\n-                     .map(OpTkl::asVarLoadOrNull)\n-                     .filter(Objects::nonNull) \/\/ ((Result)operand).op()) instanceof VarLoad varload && varload is KernelContext.class\n-                     .findFirst()\n-                     .ifPresent(varLoadOp -> s.select(o,varLoadOp))\n-                ).transform(txfmr.selected::contains, c->{\n-                   switch (c.op()){\n-                      case JavaOp.FieldAccessOp.FieldLoadOp $  -> c.replace(factory($));\n-                      case CoreOp.VarAccessOp.VarLoadOp _ -> c.remove();\n-                      default -> {}\n-                }\n-        }).funcOp();\n-    }\n-\n-    public static final class BlockPhase extends HATDialectifyThreadsPhase<BlockPhase,HATBlockThreadIdOp> {\n-        public BlockPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph, HATBlockThreadIdOp.class);\n-        }\n-        @Override protected Regex regex(){\n-            return HATBlockThreadIdOp.regex;\n-        }\n-\n-        @Override\n-        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-                return HATBlockThreadIdOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n-        }\n-    }\n-\n-    public static final class GlobalIdPhase extends HATDialectifyThreadsPhase<GlobalIdPhase,HATGlobalThreadIdOp>  {\n-        public GlobalIdPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph, HATGlobalThreadIdOp.class);\n-        }\n-        @Override protected Regex regex(){\n-            return HATGlobalThreadIdOp.regex;\n-        }\n-        @Override\n-        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-                return HATGlobalThreadIdOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n-        }\n-    }\n-\n-    public static final class GlobalSizePhase extends HATDialectifyThreadsPhase<GlobalSizePhase,HATGlobalSizeOp>  {\n-        public GlobalSizePhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph, HATGlobalSizeOp.class);\n-        }\n-        @Override protected Regex regex(){\n-            return HATGlobalSizeOp.regex;\n-        }\n-        @Override\n-        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-                return  HATGlobalSizeOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n-        }\n-    }\n-\n-    public static final class LocalIdPhase extends HATDialectifyThreadsPhase<LocalIdPhase,HATLocalThreadIdOp>  {\n-        public LocalIdPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph,HATLocalThreadIdOp.class);\n-        }\n-        @Override protected Regex regex(){\n-            return HATLocalThreadIdOp.regex;\n-        }\n-        @Override\n-        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-                return HATLocalThreadIdOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n-        }\n-    }\n-\n-    public static final class LocalSizePhase extends HATDialectifyThreadsPhase<LocalSizePhase,HATLocalSizeOp>  {\n-        public LocalSizePhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph,HATLocalSizeOp.class);\n-        }\n-        @Override public Regex regex(){\n-           return HATLocalSizeOp.regex;\n-        }\n-        @Override\n-        public HATThreadOp factory(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-            return HATLocalSizeOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.callgraph.KernelCallGraph;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import optkl.util.carriers.LookupCarrier;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.function.Function;\n-\n-public class HATDialectifyTier implements Function<CoreOp.FuncOp, CoreOp.FuncOp>, LookupCarrier {\n-    KernelCallGraph kernelCallGraph;\n-    @Override\n-    public MethodHandles.Lookup lookup(){\n-        return kernelCallGraph.lookup();\n-    }\n-    private List<HATDialectPhase> hatPhases = new ArrayList<>();\n-\n-    public HATDialectifyTier(KernelCallGraph kernelCallGraph) {\n-        this.kernelCallGraph = kernelCallGraph;\n-        \/\/ barriers\n-        hatPhases.add(new HATDialectifyBarrierPhase(kernelCallGraph));\n-\n-        \/\/ array views\n-        hatPhases.add(new HATDialectifyArrayViewPhase(kernelCallGraph));\n-\n-        \/\/ Memory\n-        hatPhases.add(new HATDialectifyMemoryPhase.LocalMemoryPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyMemoryPhase.PrivateMemoryPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyMemoryPhase.DeviceTypePhase(kernelCallGraph));\n-\n-        \/\/ ID's \/thread access\n-        hatPhases.add(new HATDialectifyThreadsPhase.GlobalIdPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyThreadsPhase.GlobalSizePhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyThreadsPhase.LocalIdPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyThreadsPhase.LocalSizePhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyThreadsPhase.BlockPhase(kernelCallGraph));\n-\n-        \/\/ views for vector types\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float4LoadPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float2LoadPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.Float4OfPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.AddPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.SubPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.MulPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.DivPhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorOpPhase.MakeMutable(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorStorePhase.Float4StorePhase(kernelCallGraph));\n-        hatPhases.add(new HATDialectifyVectorStorePhase.Float2StorePhase(kernelCallGraph));\n-\n-        \/\/ Vector Select individual lines\n-        hatPhases.add(new HATDialectifyVectorSelectPhase(kernelCallGraph));\n-\n-        \/\/ F16 type\n-        hatPhases.add(new HATDialectifyFP16Phase(kernelCallGraph));\n-\n-    }\n-\n-    \/\/ It computes a set of function code model transformations from FuncOp to FuncOp'.\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-        BlockingQueue<Function<CoreOp.FuncOp,CoreOp.FuncOp>> queue = new ArrayBlockingQueue<>(hatPhases.size());\n-        queue.addAll(hatPhases);\n-\n-        CoreOp.FuncOp f = funcOp;\n-        while (!queue.isEmpty()) {\n-            try {\n-                \/\/ TODO Did we just trash side tables ?\n-                Function<CoreOp.FuncOp,CoreOp.FuncOp> phase = queue.take();\n-                f = phase.apply(f);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        return f;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.dialect.BinaryOpEnum;\n@@ -61,13 +62,1 @@\n-public record HATDialectifyFP16Phase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n-\n-    private enum BinaryOpMethod {\n-        ADD(\"add\"),\n-        SUB(\"sub\"),\n-        MUL(\"mul\"),\n-        DIV(\"div\");\n-\n-        final String methodName;\n-        BinaryOpMethod(String name) {\n-            this.methodName = name;\n-        }\n-    }\n+public record HATFP16Phase(KernelCallGraph kernelCallGraph) implements HATPhase {\n@@ -174,1 +163,1 @@\n-    private void createF16BinaryOp(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, BinaryOpMethod method, ReducedFloatType reducedFloatType) {\n+    private void createF16BinaryOp(JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder, BinaryOpEnum binaryOpEnum, ReducedFloatType reducedFloatType) {\n@@ -194,1 +183,1 @@\n-        HATF16BinaryOp binaryOp = switch (method) {\n+        HATF16BinaryOp binaryOp = switch (binaryOpEnum) {\n@@ -206,1 +195,1 @@\n-    private CoreOp.FuncOp dialectifyF16Ops(CoreOp.FuncOp funcOp, BinaryOpMethod method) {\n+    private CoreOp.FuncOp dialectifyF16Ops(CoreOp.FuncOp funcOp, BinaryOpEnum binaryOpEnum) {\n@@ -215,1 +204,1 @@\n-                        if (is16BitFloatOperation(invokeOp, method.methodName) && invokeOp.resultType() != JavaType.VOID) {\n+                        if (is16BitFloatOperation(invokeOp, binaryOpEnum.name().toLowerCase()) && invokeOp.resultType() != JavaType.VOID) {\n@@ -237,1 +226,1 @@\n-                createF16BinaryOp(invokeOp, blockBuilder, method, reducedFloatsType.get(invokeOp));\n+                createF16BinaryOp(invokeOp, blockBuilder, binaryOpEnum, reducedFloatsType.get(invokeOp));\n@@ -381,1 +370,1 @@\n-        for (BinaryOpMethod method : BinaryOpMethod.values())\n+        for (BinaryOpEnum binaryOpEnum : BinaryOpEnum.values())\n@@ -383,1 +372,1 @@\n-            funcOp = dialectifyF16Ops(funcOp, method);\n+            funcOp = dialectifyF16Ops(funcOp, binaryOpEnum);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":9,"deletions":20,"binary":false,"changes":29,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","status":"renamed"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.callgraph.KernelCallGraph;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.util.CallSite;\n+import optkl.util.carriers.LookupCarrier;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.Function;\n+\n+public sealed interface HATPhase extends Function<CoreOp.FuncOp,CoreOp.FuncOp>,LookupCarrier\n+        permits HATArrayViewPhase, HATBarrierPhase, HATFP16Phase,\n+        HATDMemoryPhase, HATThreadsPhase, HATVectorPhase, HATVectorSelectPhase, HATVectorStorePhase {\n+\n+\n+    KernelCallGraph kernelCallGraph();\n+\n+    @Override default MethodHandles.Lookup lookup(){\n+        return kernelCallGraph().lookup();\n+    }\n+\n+    default boolean tracing(){\n+            return kernelCallGraph().config().showCompilationPhases();\n+    }\n+\n+    default void before(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (tracing()) {\n+            IO.println(\"[INFO] Code model before [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \"  + System.lineSeparator() + funcOp.toText());\n+        }\n+    }\n+\n+    default void after(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (tracing()) {\n+            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \" + System.lineSeparator() + funcOp.toText());\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhase.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+\n+import hat.callgraph.KernelCallGraph;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n+import hat.optools.KernelContextPattern;\n+import hat.optools.Trxfmr;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.util.CallSite;\n+import optkl.OpTkl;\n+import optkl.util.Regex;\n+\n+import java.util.Objects;\n+import static optkl.OpTkl.operandsAsResults;\n+\n+public sealed abstract class HATThreadsPhase implements HATPhase\n+permits HATThreadsPhase.BlockPhase, HATThreadsPhase.GlobalIdPhase, HATThreadsPhase.GlobalSizePhase, HATThreadsPhase.LocalIdPhase, HATThreadsPhase.LocalSizePhase {\n+    private final KernelCallGraph kernelCallGraph;\n+    @Override public KernelCallGraph kernelCallGraph(){\n+        return kernelCallGraph;\n+    }\n+\n+    public HATThreadsPhase(KernelCallGraph kernelCallGraph) {\n+        this.kernelCallGraph=kernelCallGraph;\n+    }\n+\n+    private static final Regex localSizeRegex = Regex.of(\"ls([xyz])\");\n+    private static final Regex localIdRegex = Regex.of(\"li([xyz])\");\n+    private static final Regex globalSzRegex = Regex.of(\"(gs[xyz])\");\n+    private static final Regex blockIdRegex = Regex.of(\"bi([xyz])\");\n+    private static final Regex globalIdxRegex = Regex.of(\"(gi[xyz])\");\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        var txfmr = new Trxfmr(CallSite.of(this.getClass()),funcOp);\n+        Regex fieldNameRegex  = switch (this){\n+            case BlockPhase _->blockIdRegex;\n+            case GlobalIdPhase _->globalIdxRegex;\n+            case GlobalSizePhase _->globalSzRegex;\n+            case LocalIdPhase _-> localIdRegex;\n+            case LocalSizePhase _-> localSizeRegex;\n+        };\n+        return txfmr.select(\n+                ce-> KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull(\n+                        lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null,(s, o)->\n+                   operandsAsResults(o)\n+                     .map(OpTkl::opOfResultOrNull)\n+                     .map(OpTkl::asVarLoadOrNull)\n+                     .filter(Objects::nonNull) \/\/ ((Result)operand).op()) instanceof VarLoad varload && varload is KernelContext.class\n+                     .findFirst()\n+                     .ifPresent(varLoadOp -> s.select(o,varLoadOp))\n+                ).transform(txfmr.selected::contains, c->{\n+                   switch (c.op()){\n+                      case JavaOp.FieldAccessOp.FieldLoadOp $  -> {\n+                          String name = $.fieldDescriptor().name();\n+                          int dimIdx = name.length()==3 ?name.charAt(2)-'x' :-1;\n+                          if (dimIdx <0||dimIdx>3){\n+                              throw new IllegalStateException();\/\/'x'=1,'y'=2....\n+                          }\n+                          c.replace(switch (HATThreadsPhase.this){\n+                              case BlockPhase _->HATBlockThreadIdOp.of(dimIdx, $.resultType());\n+                              case GlobalIdPhase _->HATGlobalThreadIdOp.of(dimIdx, $.resultType());\n+                              case GlobalSizePhase _-> HATGlobalSizeOp.of(dimIdx, $.resultType());\n+                              case LocalIdPhase _-> HATLocalThreadIdOp.of(dimIdx, $.resultType());\n+                              case LocalSizePhase _-> HATLocalSizeOp.of(dimIdx,$.resultType());\n+                          });\n+                      }\n+                      case CoreOp.VarAccessOp.VarLoadOp _ -> c.remove();\n+                      default -> {}\n+                }\n+        }).funcOp();\n+    }\n+\n+    public static final class BlockPhase extends HATThreadsPhase {\n+        public BlockPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+    }\n+\n+    public static final class GlobalIdPhase extends HATThreadsPhase {\n+        public GlobalIdPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+    }\n+\n+    public static final class GlobalSizePhase extends HATThreadsPhase {\n+        public GlobalSizePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+    }\n+\n+    public static final class LocalIdPhase extends HATThreadsPhase {\n+        public LocalIdPhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+    }\n+\n+    public static final class LocalSizePhase extends HATThreadsPhase {\n+        public LocalSizePhase(KernelCallGraph kernelCallGraph) {\n+            super(kernelCallGraph);\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -70,1 +70,3 @@\n-public abstract sealed class HATDialectifyVectorOpPhase implements HATDialectPhase {\n+public abstract sealed class HATVectorPhase implements HATPhase\n+        permits HATVectorPhase.AddPhase, HATVectorPhase.DivPhase, HATVectorPhase.Float2LoadPhase, HATVectorPhase.Float4LoadPhase\n+      , HATVectorPhase.MulPhase, HATVectorPhase.MakeMutable, HATVectorPhase.SubPhase, HATVectorPhase.Float4OfPhase{\n@@ -94,1 +96,1 @@\n-    public HATDialectifyVectorOpPhase(KernelCallGraph kernelCallGraph, VectorOperation vectorOperation) {\n+    public HATVectorPhase(KernelCallGraph kernelCallGraph, VectorOperation vectorOperation) {\n@@ -449,1 +451,1 @@\n-    public static final class AddPhase extends HATDialectifyVectorOpPhase {\n+    public static final class AddPhase extends HATVectorPhase {\n@@ -455,1 +457,1 @@\n-    public static final class DivPhase extends HATDialectifyVectorOpPhase {\n+    public static final class DivPhase extends HATVectorPhase {\n@@ -462,1 +464,1 @@\n-    public static final class MakeMutable extends HATDialectifyVectorOpPhase {\n+    public static final class MakeMutable extends HATVectorPhase {\n@@ -469,1 +471,1 @@\n-    public static final class Float4LoadPhase extends HATDialectifyVectorOpPhase {\n+    public static final class Float4LoadPhase extends HATVectorPhase {\n@@ -476,1 +478,1 @@\n-    public static final class Float2LoadPhase extends HATDialectifyVectorOpPhase {\n+    public static final class Float2LoadPhase extends HATVectorPhase {\n@@ -483,1 +485,1 @@\n-    public static final class Float4OfPhase extends HATDialectifyVectorOpPhase {\n+    public static final class Float4OfPhase extends HATVectorPhase {\n@@ -490,1 +492,1 @@\n-    public static final class MulPhase extends HATDialectifyVectorOpPhase {\n+    public static final class MulPhase extends HATVectorPhase {\n@@ -497,1 +499,1 @@\n-    public static final class SubPhase extends HATDialectifyVectorOpPhase {\n+    public static final class SubPhase extends HATVectorPhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":12,"deletions":10,"binary":false,"changes":22,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","status":"renamed"},{"patch":"@@ -53,2 +53,2 @@\n-public record HATDialectifyVectorSelectPhase(KernelCallGraph kernelCallGraph) implements HATDialectPhase {\n-    static Regex xyzw = Regex.of(\"[xyzw]\");\n+public record HATVectorSelectPhase(KernelCallGraph kernelCallGraph) implements HATPhase {\n+    private static final Regex xyzw = Regex.of(\"[xyzw]\");\n@@ -63,1 +63,1 @@\n-            Class<?> aClass = Class.forName(typeElement);\n+            Class<?> aClass = Class.forName(typeElement); \/\/ WHY?\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","status":"renamed"},{"patch":"@@ -49,2 +49,2 @@\n-public abstract sealed class HATDialectifyVectorStorePhase implements HATDialectPhase\n-        permits HATDialectifyVectorStorePhase.Float2StorePhase,HATDialectifyVectorStorePhase.Float4StorePhase{\n+public abstract sealed class HATVectorStorePhase implements HATPhase\n+        permits HATVectorStorePhase.Float2StorePhase, HATVectorStorePhase.Float4StorePhase{\n@@ -56,1 +56,1 @@\n-    public HATDialectifyVectorStorePhase(KernelCallGraph kernelCallGraph\/*, StoreView vectorOperation*\/) {\n+    public HATVectorStorePhase(KernelCallGraph kernelCallGraph\/*, StoreView vectorOperation*\/) {\n@@ -127,1 +127,1 @@\n-    public static final class Float4StorePhase extends HATDialectifyVectorStorePhase{\n+    public static final class Float4StorePhase extends HATVectorStorePhase {\n@@ -133,1 +133,1 @@\n-    public static final class Float2StorePhase extends HATDialectifyVectorStorePhase{\n+    public static final class Float2StorePhase extends HATVectorStorePhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","status":"renamed"},{"patch":"@@ -38,1 +38,1 @@\n-import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.isKernelContextFieldAccessOp;\n+import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull;\n@@ -51,1 +51,1 @@\n-        if (isKernelContextFieldAccessOp(buildContext.lookup,fieldLoadOp, _->true)) {\n+        if (asKernelContextFieldAccessOrNull(buildContext.lookup,fieldLoadOp, _->true)!=null) {\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}