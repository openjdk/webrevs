{"files":[{"patch":"@@ -472,1 +472,1 @@\n-    public static final OpFactory FACTORY = def -> {\n+    public static final OpFactory OP_FACTORY = def -> {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(SCFOps.class);\n+    public static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(SCFOps.class);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -33,1 +34,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -833,1 +834,1 @@\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n+    static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n@@ -891,6 +892,12 @@\n-            TRITON_TYPE_FACTORY.andThen(CoreTypeFactory.JAVA_TYPE_FACTORY);\n-\n-    \/\/ Triton types then Java types, combined with code model types\n-    public static final TypeElementFactory TYPE_FACTORY =\n-            CoreTypeFactory.codeModelTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n-\n+            TRITON_TYPE_FACTORY.andThen(JavaOp.JAVA_TYPE_FACTORY);\n+\n+    \/\/ Triton types then Java types, combined with core types\n+    static final TypeElementFactory TYPE_FACTORY =\n+            CoreOp.coreTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n+\n+    public static final DialectFactory DIALECT_FACTORY = new DialectFactory(\n+            OP_FACTORY.andThen(ArithMathOps.OP_FACTORY)\n+                    .andThen(SCFOps.OP_FACTORY)\n+                    .andThen(JavaOp.OP_FACTORY),\n+            TYPE_FACTORY\n+    );\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -34,3 +35,0 @@\n-import java.io.BufferedWriter;\n-import java.io.File;\n-import java.io.FileWriter;\n@@ -103,0 +101,1 @@\n+\n@@ -104,5 +103,3 @@\n-                    TritonOps.FACTORY.andThen(ArithMathOps.FACTORY)\n-                            .andThen(TritonTestOps.FACTORY)\n-                            .andThen(SCFOps.FACTORY)\n-                            .andThen(JavaOp.FACTORY),\n-                    TritonOps.TYPE_FACTORY,\n+                    new DialectFactory(\n+                            TritonOps.DIALECT_FACTORY.opFactory().andThen(TritonTestOps.FACTORY),\n+                            TritonOps.DIALECT_FACTORY.typeElementFactory()),\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-                                        \"fromStringOfFuncOp\",\n+                                        \"fromStringOfJavaCodeModel\",\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -41,1 +42,1 @@\n- * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n+ * A code model, produced by the Java compiler from Java program source, may consist of core operations and Java\n@@ -1353,1 +1354,1 @@\n-     * A factory for core operations.\n+     * An operation factory for core operations.\n@@ -1355,2 +1356,72 @@\n-    \/\/ @@@ Compute lazily\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(CoreOp.class);\n+    public static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(CoreOp.class);\n+\n+    \/**\n+     * Creates a composed type element factory for core type elements and type elements from the given\n+     * type element factory, where the core type elements can refer to type elements from the\n+     * given type element factory.\n+     *\n+     * @param f the type element factory.\n+     * @return the composed type element factory.\n+     *\/\n+    public static TypeElementFactory coreTypeFactory(TypeElementFactory f) {\n+        class CodeModelFactory implements TypeElementFactory {\n+            final TypeElementFactory thisThenF = this.andThen(f);\n+\n+            @Override\n+            public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n+                return switch (tree.identifier()) {\n+                    case VarType.NAME -> {\n+                        if (tree.arguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        yield VarType.varType(v);\n+                    }\n+                    case TupleType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n+                        for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            cs.add(c);\n+                        }\n+                        yield TupleType.tupleType(cs);\n+                    }\n+                    case FunctionType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (rt == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n+                        for (TypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            pts.add(c);\n+                        }\n+                        yield FunctionType.functionType(rt, pts);\n+                    }\n+                    default -> null;\n+                };\n+            }\n+        }\n+        if (f instanceof CodeModelFactory) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new CodeModelFactory().thisThenF;\n+    }\n@@ -1721,5 +1792,0 @@\n-\n-    \/\/\n-    \/\/ Arithmetic ops\n-\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":75,"deletions":9,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-package jdk.incubator.code.dialect.core;\n-\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.TypeElementFactory;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public final class CoreTypeFactory {\n-\n-    private CoreTypeFactory() {\n-    }\n-\n-    \/\/ Code model type factory composed\n-\n-    \/**\n-     * Create a code model factory combining and composing the construction\n-     * of code model types with types constructed from the given type factory.\n-     *\n-     * @param f the type factory.\n-     * @return the code model factory.\n-     *\/\n-    public static TypeElementFactory codeModelTypeFactory(TypeElementFactory f) {\n-        class CodeModelFactory implements TypeElementFactory {\n-            final TypeElementFactory thisThenF = this.andThen(f);\n-\n-            @Override\n-            public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n-                return switch (tree.identifier()) {\n-                    case VarType.NAME -> {\n-                        if (tree.arguments().size() != 1) {\n-                            throw new IllegalArgumentException();\n-                        }\n-\n-                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n-                        if (v == null) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-                        yield VarType.varType(v);\n-                    }\n-                    case TupleType.NAME -> {\n-                        if (tree.arguments().isEmpty()) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-\n-                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n-                        for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n-                            TypeElement c = thisThenF.constructType(child);\n-                            if (c == null) {\n-                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                            }\n-                            cs.add(c);\n-                        }\n-                        yield TupleType.tupleType(cs);\n-                    }\n-                    case FunctionType.NAME -> {\n-                        if (tree.arguments().isEmpty()) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-\n-                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n-                        if (rt == null) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n-                        for (TypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n-                            TypeElement c = thisThenF.constructType(child);\n-                            if (c == null) {\n-                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                            }\n-                            pts.add(c);\n-                        }\n-                        yield FunctionType.functionType(rt, pts);\n-                    }\n-                    default -> null;\n-                };\n-            }\n-        }\n-        if (f instanceof CodeModelFactory) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return new CodeModelFactory().thisThenF;\n-    }\n-\n-    \/\/ Java type factory\n-\n-    \/**\n-     * The Java type factory.\n-     *\/\n-    public static final TypeElementFactory JAVA_TYPE_FACTORY = tree -> switch (JavaTypeUtils.Kind.of(tree)) {\n-            case INFLATED_TYPE -> JavaTypeUtils.toJavaType(tree);\n-            case INFLATED_REF -> JavaTypeUtils.toJavaRef(tree);\n-            default -> throw new UnsupportedOperationException(\"Unsupported: \" + tree);\n-        };\n-\n-\n-    \/**\n-     * The core type factory that can construct instance of {@link JavaType}\n-     * or code model types such as {@link VarType} or {@link TupleType} that\n-     * may contain instances of those types.\n-     *\/\n-    public static final TypeElementFactory CORE_TYPE_FACTORY = codeModelTypeFactory(JAVA_TYPE_FACTORY);\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreTypeFactory.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -34,0 +35,1 @@\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -46,1 +48,1 @@\n- * The top-level operation class for the enclosed set of extended operations.\n+ * The top-level operation class for Java operations.\n@@ -48,1 +50,1 @@\n- * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n+ * A code model, produced by the Java compiler from Java program source, may consist of core operations and Java\n@@ -52,4 +54,4 @@\n- * Extended operations model specific Java language constructs, often those with structured control flow and nested\n- * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n- * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n- * that are not explicitly lowerable.\n+ * Java operations model specific Java language constructs or Java program behaviour. Some Java operations model\n+ * structured control flow and nested code. These operations are transformable, commonly referred to as lowering, into\n+ * a sequence of other core or Java operations. Those that implement {@link Op.Lowerable} can transform themselves and\n+ * will transform associated operations that are not explicitly lowerable.\n@@ -57,3 +59,4 @@\n- * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n- * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n- * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n+ * A code model, produced by the Java compiler from source, and consisting of core operations and Java operations\n+ * can be transformed to one consisting only of non-lowerable operations, where all lowerable operations are lowered.\n+ * This transformation preserves programing meaning. The resulting lowered code model also represents the same Java\n+ * program.\n@@ -5290,0 +5293,13 @@\n+    \/**\n+     * An operation factory for Java operations.\n+     *\/\n+    public static OpFactory JAVA_OP_FACTORY = OpFactory.OP_FACTORY.get(JavaOp.class);\n+\n+    \/**\n+     * A type element factory for Java type elements.\n+     *\/\n+    public static final TypeElementFactory JAVA_TYPE_FACTORY = tree -> switch (JavaTypeUtils.Kind.of(tree)) {\n+        case INFLATED_TYPE -> JavaTypeUtils.toJavaType(tree);\n+        case INFLATED_REF -> JavaTypeUtils.toJavaRef(tree);\n+        default -> throw new UnsupportedOperationException(\"Unsupported: \" + tree);\n+    };\n@@ -5292,1 +5308,1 @@\n-     * A factory for extended and core operations.\n+     * An operation factory for core and Java operations.\n@@ -5294,2 +5310,1 @@\n-    \/\/ @@@ Compute lazily\n-    public static final OpFactory FACTORY = CoreOp.FACTORY.andThen(OpFactory.OP_FACTORY.get(JavaOp.class));\n+    public static final OpFactory OP_FACTORY = CoreOp.OP_FACTORY.andThen(JAVA_OP_FACTORY);\n@@ -5297,0 +5312,11 @@\n+    \/**\n+     * A type element factory for core type and Java type elements, where the core type elements can refer to\n+     * Java type elements.\n+     *\/\n+    public static final TypeElementFactory TYPE_FACTORY = CoreOp.coreTypeFactory(JAVA_TYPE_FACTORY);\n+\n+    \/**\n+     * A Java dialect factory, for constructing core and Java operations and constructing\n+     * core type and Java type elements, where the core type elements can refer to Java\n+     * type elements.\n+     *\/\n@@ -5298,2 +5324,2 @@\n-            FACTORY,\n-            CoreTypeFactory.CORE_TYPE_FACTORY);\n+            OP_FACTORY,\n+            TYPE_FACTORY);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                names.fromString(\"fromStringOfFuncOp\"),\n+                names.fromString(\"fromStringOfJavaCodeModel\"),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -42,1 +43,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -143,0 +143,2 @@\n+    \/\/ @@@ check failure from operation and type element factories\n+\n@@ -146,1 +148,1 @@\n-     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param factory the dialect factory used to construct operations and type elements.\n@@ -149,1 +151,2 @@\n-     * @throws IOException if parsing fails\n+     * @throws IOException if parsing fails to read from the input stream\n+     * @throws IllegalArgumentException if parsing fails\n@@ -151,5 +154,1 @@\n-    public static List<Op> fromStream(OpFactory opFactory, InputStream in) throws IOException {\n-        return fromStream(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n-    }\n-\n-    public static List<Op> fromStream(OpFactory opFactory, TypeElementFactory typeFactory, InputStream in) throws IOException {\n+    public static List<Op> fromStream(DialectFactory factory, InputStream in) throws IOException {\n@@ -157,1 +156,1 @@\n-        return fromString(opFactory, typeFactory, s);\n+        return fromString(factory, s);\n@@ -163,1 +162,1 @@\n-     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param factory the dialect factory used to construct operations and type elements.\n@@ -166,0 +165,1 @@\n+     * @throws IllegalArgumentException if parsing fails\n@@ -167,6 +167,2 @@\n-    public static List<Op> fromString(OpFactory opFactory, String in) {\n-        return parse(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n-    }\n-\n-    public static List<Op> fromString(OpFactory opFactory, TypeElementFactory typeFactory, String in) {\n-        return parse(opFactory, typeFactory, in);\n+    public static List<Op> fromString(DialectFactory factory, String in) {\n+        return parse(factory.opFactory(), factory.typeElementFactory(), in);\n@@ -176,1 +172,5 @@\n-     * Parse a code model, modeling a method, from its serialized textual form obtained from an input string.\n+     * Parse a Java code model, modeling a method body or quoted lambda body, from\n+     * its serialized textual form obtained from an input string.\n+     * <p>\n+     * This method uses the Java {@link JavaOp#DIALECT_FACTORY dialect factory}\n+     * for construction of operations and type elements.\n@@ -179,1 +179,3 @@\n-     * @return the func operation\n+     * @return the code model\n+     * @throws IllegalArgumentException if parsing fails or if top-level operation\n+     * of the code model is not an instance of {@link CoreOp.FuncOp}\n@@ -181,3 +183,4 @@\n-    \/\/@@@ visit return type\n-    public static Op fromStringOfFuncOp(String in) {\n-        Op op = fromString(JavaOp.FACTORY, in).get(0);\n+    public static Op fromStringOfJavaCodeModel(String in) {\n+        \/\/ @@@ Used produce code models stored as text in the class file,\n+        \/\/ can eventually be removed as storing text is now a backup option.\n+        Op op = fromString(JavaOp.DIALECT_FACTORY, in).get(0);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/OpParser.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        Op copy = CoreOp.FACTORY.constructOp(odef);\n+        Op copy = CoreOp.OP_FACTORY.constructOp(odef);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfFuncOp(m);\n+        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfJavaCodeModel(m);\n@@ -391,1 +391,1 @@\n-        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfFuncOp(m);\n+        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfJavaCodeModel(m);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, F).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, F).getFirst();\n@@ -92,1 +92,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, IF_ELSE).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, IF_ELSE).getFirst();\n@@ -130,1 +130,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, LOOP).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, LOOP).getFirst();\n@@ -199,1 +199,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, IF_ELSE_NESTED).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, IF_ELSE_NESTED).getFirst();\n@@ -260,1 +260,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, LOOP_NESTED).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, LOOP_NESTED).getFirst();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-        return Stream.of(models).map(s -> OpParser.fromString(JavaOp.FACTORY, s).getFirst())\n+        return Stream.of(models).map(s -> OpParser.fromString(JavaOp.DIALECT_FACTORY, s).getFirst())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestNormalizeBlocksTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        Op f = OpParser.fromStringOfFuncOp(OP);\n+        Op f = OpParser.fromStringOfJavaCodeModel(OP);\n@@ -85,1 +85,1 @@\n-        Op f = OpParser.fromStringOfFuncOp(OP);\n+        Op f = OpParser.fromStringOfJavaCodeModel(OP);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUsesDependsOn.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -39,1 +40,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -86,1 +86,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY, f.toText()).get(0);\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, f.toText()).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        CoreOp.FuncOp tf = (CoreOp.FuncOp) OpParser.fromString(JavaOp.FACTORY, tfText).getFirst();\n+        CoreOp.FuncOp tf = (CoreOp.FuncOp) OpParser.fromString(JavaOp.DIALECT_FACTORY, tfText).getFirst();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/TestLocation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        List<Op> ops = OpParser.fromString(JavaOp.FACTORY, f.toText());\n+        List<Op> ops = OpParser.fromString(JavaOp.DIALECT_FACTORY, f.toText());\n@@ -100,2 +100,2 @@\n-        Op opE = OpParser.fromString(JavaOp.FACTORY, NAMED_BODY).get(0);\n-        Op opA = OpParser.fromString(JavaOp.FACTORY, opE.toText()).get(0);\n+        Op opE = OpParser.fromString(JavaOp.DIALECT_FACTORY, NAMED_BODY).get(0);\n+        Op opA = OpParser.fromString(JavaOp.DIALECT_FACTORY, opE.toText()).get(0);\n@@ -114,2 +114,2 @@\n-        Op opE = OpParser.fromString(JavaOp.FACTORY, ESCAPED_STRING).get(0);\n-        Op opA = OpParser.fromString(JavaOp.FACTORY, opE.toText()).get(0);\n+        Op opE = OpParser.fromString(JavaOp.DIALECT_FACTORY, ESCAPED_STRING).get(0);\n+        Op opA = OpParser.fromString(JavaOp.DIALECT_FACTORY, opE.toText()).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import jdk.incubator.code.dialect.java.TypeVariableType;\n-import jdk.incubator.code.dialect.java.WildcardType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -37,4 +35,1 @@\n-import jdk.incubator.code.dialect.java.ArrayType;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n-import jdk.incubator.code.dialect.java.JavaType;\n+\n@@ -181,1 +176,1 @@\n-        Assert.assertEquals(javaType, CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(javaType.externalize()));\n+        Assert.assertEquals(javaType, JavaOp.JAVA_TYPE_FACTORY.constructType(javaType.externalize()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0);\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        return serialize(OpParser.fromString(JavaOp.FACTORY, d).get(0));\n+        return serialize(OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0));\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}