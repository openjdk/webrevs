{"files":[{"patch":"@@ -472,1 +472,1 @@\n-    public static final OpFactory FACTORY = def -> {\n+    public static final OpFactory OP_FACTORY = def -> {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(SCFOps.class);\n+    public static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(SCFOps.class);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -33,1 +34,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -833,1 +834,1 @@\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n+    static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n@@ -891,6 +892,12 @@\n-            TRITON_TYPE_FACTORY.andThen(CoreTypeFactory.JAVA_TYPE_FACTORY);\n-\n-    \/\/ Triton types then Java types, combined with code model types\n-    public static final TypeElementFactory TYPE_FACTORY =\n-            CoreTypeFactory.codeModelTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n-\n+            TRITON_TYPE_FACTORY.andThen(JavaOp.JAVA_TYPE_FACTORY);\n+\n+    \/\/ Triton types then Java types, combined with core types\n+    static final TypeElementFactory TYPE_FACTORY =\n+            CoreOp.coreTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n+\n+    public static final DialectFactory DIALECT_FACTORY = new DialectFactory(\n+            OP_FACTORY.andThen(ArithMathOps.OP_FACTORY)\n+                    .andThen(SCFOps.OP_FACTORY)\n+                    .andThen(JavaOp.OP_FACTORY),\n+            TYPE_FACTORY\n+    );\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -34,3 +35,0 @@\n-import java.io.BufferedWriter;\n-import java.io.File;\n-import java.io.FileWriter;\n@@ -103,0 +101,1 @@\n+\n@@ -104,5 +103,3 @@\n-                    TritonOps.FACTORY.andThen(ArithMathOps.FACTORY)\n-                            .andThen(TritonTestOps.FACTORY)\n-                            .andThen(SCFOps.FACTORY)\n-                            .andThen(JavaOp.FACTORY),\n-                    TritonOps.TYPE_FACTORY,\n+                    new DialectFactory(\n+                            TritonOps.DIALECT_FACTORY.opFactory().andThen(TritonTestOps.FACTORY),\n+                            TritonOps.DIALECT_FACTORY.typeElementFactory()),\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -433,6 +432,0 @@\n-                    \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n-                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.JAVA_OP_CLASS.describeConstable().get(),\n-                            \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n-                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n-                            \"CORE_TYPE_FACTORY\",\n-                            CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n@@ -510,4 +503,0 @@\n-        static final Class<?> JAVA_OP_CLASS;\n-        static final Class<?> OP_FACTORY_CLASS;\n-        static final Class<?> CORE_TYPE_FACTORY_CLASS;\n-        static final Class<?> TYPE_ELEMENT_FACTORY_CLASS;\n@@ -527,4 +516,0 @@\n-                JAVA_OP_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.java.JavaOp\");\n-                OP_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.OpFactory\");\n-                CORE_TYPE_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.core.CoreTypeFactory\");\n-                TYPE_ELEMENT_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.TypeElementFactory\");\n@@ -617,1 +602,1 @@\n-        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PRIVATE + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,3 +43,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.OpFactory;\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -48,1 +45,0 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -487,5 +483,8 @@\n-     * Returns the code model of the Quotable passed in.\n-     * @param q the Quotable we want to get its code model.\n-     * @return the code model of the Quotable passed in.\n-     * @apiNote If the Quotable instance is a proxy instance, then the quoted code model is inaccessible and this method\n-     * returns an empty optional.\n+     * Returns the quoted code model of the given quotable reference, if present.\n+     *\n+     * @param q the quotable reference.\n+     * @return the quoted code model or an empty optional if the\n+     *         quoted code model is unavailable.\n+     * @apiNote If the quotable reference is a proxy instance, then the\n+     *          quoted code model is unavailable and this method\n+     *          returns an empty optional.\n@@ -497,0 +496,3 @@\n+            \/\/ @@@ The interpreter implements interpretation of\n+            \/\/ lambdas using a proxy whose invocation handler\n+            \/\/ supports the internal protocol to access the quoted instance\n@@ -502,1 +504,1 @@\n-            method = oq.getClass().getMethod(\"__internal_quoted\");\n+            method = oq.getClass().getDeclaredMethod(\"__internal_quoted\");\n@@ -518,1 +520,3 @@\n-     * Returns the code model of the method body, if present.\n+     * Returns the code model of the given method's body, if present.\n+     *\n+     * @param method the method.\n@@ -542,2 +546,1 @@\n-            opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName, OpFactory.class,\n-                    TypeElementFactory.class);\n+            opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName);\n@@ -549,1 +552,1 @@\n-            FuncOp funcOp = (FuncOp) opMethod.invoke(null, JavaOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+            FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import jdk.incubator.code.dialect.OpFactory;\n@@ -60,1 +59,0 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -93,2 +91,2 @@\n-    private static final MethodTypeDesc opMethodDesc = MethodTypeDesc.of(Op.class.describeConstable().get(),\n-            OpFactory.class.describeConstable().get(), TypeElementFactory.class.describeConstable().get());\n+\n+    private static final MethodTypeDesc OP_METHOD_DESC = MethodTypeDesc.of(Op.class.describeConstable().get());\n@@ -168,2 +166,2 @@\n-                    clb.withMethod(\"op$lambda$\" + i, opMethodDesc,\n-                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n+                    clb.withMethod(\"op$lambda$\" + i, OP_METHOD_DESC,\n+                        ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n@@ -172,1 +170,1 @@\n-                                        \"fromStringOfFuncOp\",\n+                                        \"fromStringOfJavaCodeModel\",\n@@ -903,1 +901,1 @@\n-                                                opMethodDesc)));\n+                                                OP_METHOD_DESC)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+package jdk.incubator.code.dialect;\n+\n+\/**\n+ * A dialect factory for constructing a dialect's operations and type elements from their\n+ * externalized form.\n+ *\n+ * @param opFactory the operation factory.\n+ * @param typeElementFactory the type element factory.\n+ *\/\n+public record DialectFactory(OpFactory opFactory, TypeElementFactory typeElementFactory) {\n+\n+    \/\/ OpFactory\n+    \/\/ OpDeclaration\n+    \/\/ TypeElementFactory\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/DialectFactory.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -41,1 +42,1 @@\n- * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n+ * A code model, produced by the Java compiler from Java program source, may consist of core operations and Java\n@@ -1353,1 +1354,1 @@\n-     * A factory for core operations.\n+     * An operation factory for core operations.\n@@ -1355,2 +1356,72 @@\n-    \/\/ @@@ Compute lazily\n-    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(CoreOp.class);\n+    public static final OpFactory OP_FACTORY = OpFactory.OP_FACTORY.get(CoreOp.class);\n+\n+    \/**\n+     * Creates a composed type element factory for core type elements and type elements from the given\n+     * type element factory, where the core type elements can refer to type elements from the\n+     * given type element factory.\n+     *\n+     * @param f the type element factory.\n+     * @return the composed type element factory.\n+     *\/\n+    public static TypeElementFactory coreTypeFactory(TypeElementFactory f) {\n+        class CodeModelFactory implements TypeElementFactory {\n+            final TypeElementFactory thisThenF = this.andThen(f);\n+\n+            @Override\n+            public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n+                return switch (tree.identifier()) {\n+                    case VarType.NAME -> {\n+                        if (tree.arguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        yield VarType.varType(v);\n+                    }\n+                    case TupleType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n+                        for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            cs.add(c);\n+                        }\n+                        yield TupleType.tupleType(cs);\n+                    }\n+                    case FunctionType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (rt == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n+                        for (TypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            pts.add(c);\n+                        }\n+                        yield FunctionType.functionType(rt, pts);\n+                    }\n+                    default -> null;\n+                };\n+            }\n+        }\n+        if (f instanceof CodeModelFactory) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new CodeModelFactory().thisThenF;\n+    }\n@@ -1721,5 +1792,0 @@\n-\n-    \/\/\n-    \/\/ Arithmetic ops\n-\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":75,"deletions":9,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-package jdk.incubator.code.dialect.core;\n-\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.TypeElementFactory;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public final class CoreTypeFactory {\n-\n-    private CoreTypeFactory() {\n-    }\n-\n-    \/\/ Code model type factory composed\n-\n-    \/**\n-     * Create a code model factory combining and composing the construction\n-     * of code model types with types constructed from the given type factory.\n-     *\n-     * @param f the type factory.\n-     * @return the code model factory.\n-     *\/\n-    public static TypeElementFactory codeModelTypeFactory(TypeElementFactory f) {\n-        class CodeModelFactory implements TypeElementFactory {\n-            final TypeElementFactory thisThenF = this.andThen(f);\n-\n-            @Override\n-            public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n-                return switch (tree.identifier()) {\n-                    case VarType.NAME -> {\n-                        if (tree.arguments().size() != 1) {\n-                            throw new IllegalArgumentException();\n-                        }\n-\n-                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n-                        if (v == null) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-                        yield VarType.varType(v);\n-                    }\n-                    case TupleType.NAME -> {\n-                        if (tree.arguments().isEmpty()) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-\n-                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n-                        for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n-                            TypeElement c = thisThenF.constructType(child);\n-                            if (c == null) {\n-                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                            }\n-                            cs.add(c);\n-                        }\n-                        yield TupleType.tupleType(cs);\n-                    }\n-                    case FunctionType.NAME -> {\n-                        if (tree.arguments().isEmpty()) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-\n-                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n-                        if (rt == null) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n-                        for (TypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n-                            TypeElement c = thisThenF.constructType(child);\n-                            if (c == null) {\n-                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                            }\n-                            pts.add(c);\n-                        }\n-                        yield FunctionType.functionType(rt, pts);\n-                    }\n-                    default -> null;\n-                };\n-            }\n-        }\n-        if (f instanceof CodeModelFactory) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return new CodeModelFactory().thisThenF;\n-    }\n-\n-    \/\/ Java type factory\n-\n-    \/**\n-     * The Java type factory.\n-     *\/\n-    public static final TypeElementFactory JAVA_TYPE_FACTORY = tree -> switch (JavaTypeUtils.Kind.of(tree)) {\n-            case INFLATED_TYPE -> JavaTypeUtils.toJavaType(tree);\n-            case INFLATED_REF -> JavaTypeUtils.toJavaRef(tree);\n-            default -> throw new UnsupportedOperationException(\"Unsupported: \" + tree);\n-        };\n-\n-\n-    \/**\n-     * The core type factory that can construct instance of {@link JavaType}\n-     * or code model types such as {@link VarType} or {@link TupleType} that\n-     * may contain instances of those types.\n-     *\/\n-    public static final TypeElementFactory CORE_TYPE_FACTORY = codeModelTypeFactory(JAVA_TYPE_FACTORY);\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreTypeFactory.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -30,1 +30,3 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.DialectFactory;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.core.*;\n@@ -33,3 +35,1 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.core.TupleType;\n-import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.impl.JavaTypeUtils;\n@@ -48,1 +48,1 @@\n- * The top-level operation class for the enclosed set of extended operations.\n+ * The top-level operation class for Java operations.\n@@ -50,1 +50,1 @@\n- * A code model, produced by the Java compiler from Java program source, may consist of extended operations and core\n+ * A code model, produced by the Java compiler from Java program source, may consist of core operations and Java\n@@ -54,4 +54,4 @@\n- * Extended operations model specific Java language constructs, often those with structured control flow and nested\n- * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n- * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n- * that are not explicitly lowerable.\n+ * Java operations model specific Java language constructs or Java program behaviour. Some Java operations model\n+ * structured control flow and nested code. These operations are transformable, commonly referred to as lowering, into\n+ * a sequence of other core or Java operations. Those that implement {@link Op.Lowerable} can transform themselves and\n+ * will transform associated operations that are not explicitly lowerable.\n@@ -59,3 +59,4 @@\n- * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n- * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n- * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n+ * A code model, produced by the Java compiler from source, and consisting of core operations and Java operations\n+ * can be transformed to one consisting only of non-lowerable operations, where all lowerable operations are lowered.\n+ * This transformation preserves programing meaning. The resulting lowered code model also represents the same Java\n+ * program.\n@@ -5292,0 +5293,13 @@\n+    \/**\n+     * An operation factory for Java operations.\n+     *\/\n+    public static OpFactory JAVA_OP_FACTORY = OpFactory.OP_FACTORY.get(JavaOp.class);\n+\n+    \/**\n+     * A type element factory for Java type elements.\n+     *\/\n+    public static final TypeElementFactory JAVA_TYPE_FACTORY = tree -> switch (JavaTypeUtils.Kind.of(tree)) {\n+        case INFLATED_TYPE -> JavaTypeUtils.toJavaType(tree);\n+        case INFLATED_REF -> JavaTypeUtils.toJavaRef(tree);\n+        default -> throw new UnsupportedOperationException(\"Unsupported: \" + tree);\n+    };\n@@ -5294,1 +5308,1 @@\n-     * A factory for extended and core operations.\n+     * An operation factory for core and Java operations.\n@@ -5296,2 +5310,1 @@\n-    \/\/ @@@ Compute lazily\n-    public static final OpFactory FACTORY = CoreOp.FACTORY.andThen(OpFactory.OP_FACTORY.get(JavaOp.class));\n+    public static final OpFactory OP_FACTORY = CoreOp.OP_FACTORY.andThen(JAVA_OP_FACTORY);\n@@ -5299,0 +5312,14 @@\n+    \/**\n+     * A type element factory for core type and Java type elements, where the core type elements can refer to\n+     * Java type elements.\n+     *\/\n+    public static final TypeElementFactory TYPE_FACTORY = CoreOp.coreTypeFactory(JAVA_TYPE_FACTORY);\n+\n+    \/**\n+     * A Java dialect factory, for constructing core and Java operations and constructing\n+     * core type and Java type elements, where the core type elements can refer to Java\n+     * type elements.\n+     *\/\n+    public static final DialectFactory DIALECT_FACTORY = new DialectFactory(\n+            OP_FACTORY,\n+            TYPE_FACTORY);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,0 +25,4 @@\n+    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+            Op.Result.class, Op.class);\n+    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n+            Block.Parameter.class, TypeElement.class);\n@@ -32,4 +36,0 @@\n-    private final Symbol.ClassSymbol currClassSym;\n-    private final CodeReflectionSymbols crSym;\n-    private Symbol.MethodSymbol ms;\n-    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n@@ -37,4 +37,1 @@\n-    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n-            Op.Result.class, Op.class);\n-    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n-            Block.Parameter.class, TypeElement.class);\n+    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n@@ -43,1 +40,1 @@\n-                          Types types, Env<AttrContext> attrEnv, CodeReflectionSymbols crSym) {\n+                          Types types, Env<AttrContext> attrEnv) {\n@@ -50,2 +47,0 @@\n-        this.currClassSym = attrEnv.enclClass.sym;\n-        this.crSym = crSym;\n@@ -112,1 +107,2 @@\n-    public JCTree.JCMethodDecl transformFuncOpToAST(CoreOp.FuncOp funcOp, Name methodName) {\n+    public JCTree.JCStatement transformFuncOpToAST(CoreOp.FuncOp funcOp, MethodSymbol ms) {\n+        Assert.check(funcOp.parameters().isEmpty());\n@@ -115,9 +111,0 @@\n-        var paramTypes = List.of(crSym.opFactoryType, crSym.typeElementFactoryType);\n-        var mt = new Type.MethodType(paramTypes, crSym.opType, List.nil(), syms.methodClass);\n-        ms = new Symbol.MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currClassSym);\n-        currClassSym.members().enter(ms);\n-\n-        for (int i = 0; i < funcOp.parameters().size(); i++) {\n-            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n-        }\n-\n@@ -133,1 +120,1 @@\n-                l.add(((Op)ce).result());\n+                l.add(((Op) ce).result());\n@@ -154,1 +141,1 @@\n-        return treeMaker.MethodDef(ms, mb);\n+        return mb;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.code.Symbol;\n@@ -51,7 +50,0 @@\n-    public final Type funcOpType;\n-    public final Type opFactoryType;\n-    public final Type typeElementFactoryType;\n-    public final Type javaOpType;\n-    public final Type coreTypeFactoryType;\n-    public final Symbol.VarSymbol javaOpFactorySym;\n-    public final Symbol.VarSymbol coreTypeFactorySym;\n@@ -68,1 +60,0 @@\n-        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n@@ -76,1 +67,1 @@\n-                names.fromString(\"fromStringOfFuncOp\"),\n+                names.fromString(\"fromStringOfJavaCodeModel\"),\n@@ -87,8 +78,0 @@\n-        opFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.OpFactory\");\n-        typeElementFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.TypeElementFactory\");\n-        javaOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.java.JavaOp\");\n-        coreTypeFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreTypeFactory\");\n-        javaOpFactorySym = new Symbol.VarSymbol(PUBLIC | STATIC, names.fromString(\"FACTORY\"), opFactoryType,\n-                javaOpType.tsym);\n-        coreTypeFactorySym = new Symbol.VarSymbol(PUBLIC | STATIC, names.fromString(\"CORE_TYPE_FACTORY\"), typeElementFactoryType,\n-                coreTypeFactoryType.tsym);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -105,5 +106,1 @@\n-import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n-import static com.sun.tools.javac.code.Flags.PARAMETER;\n-import static com.sun.tools.javac.code.Flags.PUBLIC;\n-import static com.sun.tools.javac.code.Flags.STATIC;\n-import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Flags.*;\n@@ -278,5 +275,1 @@\n-                        JCFieldAccess opFactory = make.Select(make.Ident(crSyms.javaOpType.tsym),\n-                                crSyms.javaOpFactorySym);\n-                        JCFieldAccess typeFactory = make.Select(make.Ident(crSyms.coreTypeFactoryType.tsym),\n-                                crSyms.coreTypeFactorySym);\n-                        JCMethodInvocation op = make.App(opMethodId, com.sun.tools.javac.util.List.of(opFactory, typeFactory));\n+                        JCMethodInvocation op = make.App(opMethodId);\n@@ -414,1 +407,8 @@\n-        switch (codeModelStorageOption) {\n+        \/\/ Create the method that constructs the code model stored in the class file\n+        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.opType,\n+                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+        var ms = new MethodSymbol(PRIVATE | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n+        currentClassSym.members().enter(ms);\n+\n+        \/\/ Create the method body\n+        var body = switch (codeModelStorageOption) {\n@@ -416,5 +416,2 @@\n-                var paramTypes = com.sun.tools.javac.util.List.of(crSyms.opFactoryType, crSyms.typeElementFactoryType);\n-                var mt = new MethodType(paramTypes, crSyms.opType,\n-                        com.sun.tools.javac.util.List.nil(), syms.methodClass);\n-                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n-                currentClassSym.members().enter(ms);\n+                \/\/ Code model is stored in textual form as a constant string\n+                \/\/ and is constructed by parsing the string\n@@ -423,3 +420,1 @@\n-                var ret = make.Return(opFromStr);\n-                var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n-                return md;\n+                yield make.Return(opFromStr);\n@@ -428,3 +423,7 @@\n-                var opBuilder = OpBuilder.createBuilderFunction(op);\n-                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym), crSyms);\n-                return cmToASTTransformer.transformFuncOpToAST(opBuilder, methodName);\n+                \/\/ Code model is stored as code that builds the code model\n+                \/\/ using the builder API and public APIs\n+                var opBuilder = OpBuilder.createBuilderFunction(op,\n+                        b -> b.op(JavaOp.fieldLoad(\n+                                FieldRef.field(JavaOp.class, \"DIALECT_FACTORY\", DialectFactory.class))));\n+                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym));\n+                yield cmToASTTransformer.transformFuncOpToAST(opBuilder, ms);\n@@ -432,3 +431,4 @@\n-            case null, default ->\n-                    throw new IllegalStateException(\"unknown code model storage option: \" + codeModelStorageOption);\n-        }\n+        };\n+\n+        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(body)));\n+        return md;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-                            public Quoted __internal_quoted() {\n+                            private Quoted __internal_quoted() {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -42,1 +43,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -143,0 +143,2 @@\n+    \/\/ @@@ check failure from operation and type element factories\n+\n@@ -146,1 +148,1 @@\n-     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param factory the dialect factory used to construct operations and type elements.\n@@ -149,1 +151,2 @@\n-     * @throws IOException if parsing fails\n+     * @throws IOException if parsing fails to read from the input stream\n+     * @throws IllegalArgumentException if parsing fails\n@@ -151,5 +154,1 @@\n-    public static List<Op> fromStream(OpFactory opFactory, InputStream in) throws IOException {\n-        return fromStream(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n-    }\n-\n-    public static List<Op> fromStream(OpFactory opFactory, TypeElementFactory typeFactory, InputStream in) throws IOException {\n+    public static List<Op> fromStream(DialectFactory factory, InputStream in) throws IOException {\n@@ -157,1 +156,1 @@\n-        return fromString(opFactory, typeFactory, s);\n+        return fromString(factory, s);\n@@ -163,1 +162,1 @@\n-     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param factory the dialect factory used to construct operations and type elements.\n@@ -166,0 +165,1 @@\n+     * @throws IllegalArgumentException if parsing fails\n@@ -167,6 +167,2 @@\n-    public static List<Op> fromString(OpFactory opFactory, String in) {\n-        return parse(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n-    }\n-\n-    public static List<Op> fromString(OpFactory opFactory, TypeElementFactory typeFactory, String in) {\n-        return parse(opFactory, typeFactory, in);\n+    public static List<Op> fromString(DialectFactory factory, String in) {\n+        return parse(factory.opFactory(), factory.typeElementFactory(), in);\n@@ -176,1 +172,5 @@\n-     * Parse a code model, modeling a method, from its serialized textual form obtained from an input string.\n+     * Parse a Java code model, modeling a method body or quoted lambda body, from\n+     * its serialized textual form obtained from an input string.\n+     * <p>\n+     * This method uses the Java {@link JavaOp#DIALECT_FACTORY dialect factory}\n+     * for construction of operations and type elements.\n@@ -179,1 +179,3 @@\n-     * @return the func operation\n+     * @return the code model\n+     * @throws IllegalArgumentException if parsing fails or if top-level operation\n+     * of the code model is not an instance of {@link CoreOp.FuncOp}\n@@ -181,3 +183,4 @@\n-    \/\/@@@ visit return type\n-    public static Op fromStringOfFuncOp(String in) {\n-        Op op = fromString(JavaOp.FACTORY, in).get(0);\n+    public static Op fromStringOfJavaCodeModel(String in) {\n+        \/\/ @@@ Used produce code models stored as text in the class file,\n+        \/\/ can eventually be removed as storing text is now a backup option.\n+        Op op = fromString(JavaOp.DIALECT_FACTORY, in).get(0);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/OpParser.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -36,0 +37,1 @@\n+import java.util.function.Function;\n@@ -53,0 +55,6 @@\n+    static final MethodRef DIALECT_FACTORY_OP_FACTORY = MethodRef.method(DialectFactory.class, \"opFactory\",\n+            OpFactory.class);\n+\n+    static final MethodRef DIALECT_FACTORY_TYPE_ELEMENT_FACTORY = MethodRef.method(DialectFactory.class, \"typeElementFactory\",\n+            TypeElementFactory.class);\n+\n@@ -115,3 +123,1 @@\n-    static final FunctionType BUILDER_F_TYPE = functionType(type(Op.class),\n-            type(OpFactory.class),\n-            type(TypeElementFactory.class));\n+    static final FunctionType BUILDER_F_TYPE = functionType(type(Op.class));\n@@ -120,1 +126,1 @@\n-    Map<Value, Value> valueMap;\n+    final Map<Value, Value> valueMap;\n@@ -122,1 +128,1 @@\n-    Map<Block, Value> blockMap;\n+    final Map<Block, Value> blockMap;\n@@ -124,1 +130,1 @@\n-    Map<ExternalizedTypeElement, Value> exTypeElementMap;\n+    final Map<ExternalizedTypeElement, Value> exTypeElementMap;\n@@ -126,1 +132,1 @@\n-    Map<TypeElement, Value> typeElementMap;\n+    final Map<TypeElement, Value> typeElementMap;\n@@ -128,1 +134,1 @@\n-    Block.Builder builder;\n+    final Block.Builder builder;\n@@ -130,1 +136,1 @@\n-    Value opFactory;\n+    final Value dialectFactory;\n@@ -132,1 +138,3 @@\n-    Value typeElementFactory;\n+    final Value opFactory;\n+\n+    final Value typeElementFactory;\n@@ -136,0 +144,5 @@\n+     * <p>\n+     * This method initially applies the function {@code dialectFactoryF} to\n+     * the block builder that is used to build resulting code model. The result\n+     * is a dialect factory value which is subsequently used to build operations\n+     * that construct type elements and operations present in the given code model.\n@@ -137,1 +150,2 @@\n-     * @param op the code model\n+     * @param op the code model.\n+     * @param dialectFactoryF a function that builds code items to produce a dialect factory value.\n@@ -140,2 +154,2 @@\n-    public static FuncOp createBuilderFunction(Op op) {\n-        return new OpBuilder().build(op);\n+    public static FuncOp createBuilderFunction(Op op, Function<Block.Builder, Value> dialectFactoryF) {\n+        return new OpBuilder(dialectFactoryF).build(op);\n@@ -144,1 +158,1 @@\n-    OpBuilder() {\n+    OpBuilder(Function<Block.Builder, Value> dialectFactoryF) {\n@@ -149,1 +163,0 @@\n-    }\n@@ -151,1 +164,0 @@\n-    FuncOp build(Op op) {\n@@ -153,0 +165,5 @@\n+        this.builder = body.entryBlock();\n+        this.dialectFactory = dialectFactoryF.apply(builder);\n+        this.opFactory = builder.op(invoke(DIALECT_FACTORY_OP_FACTORY, dialectFactory));\n+        this.typeElementFactory = builder.op(invoke(DIALECT_FACTORY_TYPE_ELEMENT_FACTORY, dialectFactory));\n+    }\n@@ -154,4 +171,1 @@\n-        builder = body.entryBlock();\n-        opFactory = builder.parameters().get(0);\n-        typeElementFactory = builder.parameters().get(1);\n-\n+    FuncOp build(Op op) {\n@@ -162,1 +176,1 @@\n-        return func(\"builder.\" + op.opName(), body);\n+        return func(\"builder.\" + op.opName(), builder.parentBody());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        Op copy = CoreOp.FACTORY.constructOp(odef);\n+        Op copy = CoreOp.OP_FACTORY.constructOp(odef);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfFuncOp(m);\n+        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfJavaCodeModel(m);\n@@ -391,1 +391,1 @@\n-        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfFuncOp(m);\n+        CoreOp.FuncOp f = (CoreOp.FuncOp) OpParser.fromStringOfJavaCodeModel(m);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, F).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, F).getFirst();\n@@ -92,1 +92,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, IF_ELSE).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, IF_ELSE).getFirst();\n@@ -130,1 +130,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, LOOP).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, LOOP).getFirst();\n@@ -199,1 +199,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, IF_ELSE_NESTED).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, IF_ELSE_NESTED).getFirst();\n@@ -260,1 +260,1 @@\n-        Op op = OpParser.fromString(JavaOp.FACTORY, LOOP_NESTED).getFirst();\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, LOOP_NESTED).getFirst();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-        return Stream.of(models).map(s -> OpParser.fromString(JavaOp.FACTORY, s).getFirst())\n+        return Stream.of(models).map(s -> OpParser.fromString(JavaOp.DIALECT_FACTORY, s).getFirst())\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestNormalizeBlocksTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        Op f = OpParser.fromStringOfFuncOp(OP);\n+        Op f = OpParser.fromStringOfJavaCodeModel(OP);\n@@ -85,1 +85,1 @@\n-        Op f = OpParser.fromStringOfFuncOp(OP);\n+        Op f = OpParser.fromStringOfJavaCodeModel(OP);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUsesDependsOn.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -39,1 +40,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -86,1 +86,1 @@\n-        Op op = OpParser.fromString(CoreOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY, f.toText()).get(0);\n+        Op op = OpParser.fromString(JavaOp.DIALECT_FACTORY, f.toText()).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        CoreOp.FuncOp tf = (CoreOp.FuncOp) OpParser.fromString(JavaOp.FACTORY, tfText).getFirst();\n+        CoreOp.FuncOp tf = (CoreOp.FuncOp) OpParser.fromString(JavaOp.DIALECT_FACTORY, tfText).getFirst();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/TestLocation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        List<Op> ops = OpParser.fromString(JavaOp.FACTORY, f.toText());\n+        List<Op> ops = OpParser.fromString(JavaOp.DIALECT_FACTORY, f.toText());\n@@ -100,2 +100,2 @@\n-        Op opE = OpParser.fromString(JavaOp.FACTORY, NAMED_BODY).get(0);\n-        Op opA = OpParser.fromString(JavaOp.FACTORY, opE.toText()).get(0);\n+        Op opE = OpParser.fromString(JavaOp.DIALECT_FACTORY, NAMED_BODY).get(0);\n+        Op opA = OpParser.fromString(JavaOp.DIALECT_FACTORY, opE.toText()).get(0);\n@@ -114,2 +114,2 @@\n-        Op opE = OpParser.fromString(JavaOp.FACTORY, ESCAPED_STRING).get(0);\n-        Op opA = OpParser.fromString(JavaOp.FACTORY, opE.toText()).get(0);\n+        Op opE = OpParser.fromString(JavaOp.DIALECT_FACTORY, ESCAPED_STRING).get(0);\n+        Op opA = OpParser.fromString(JavaOp.DIALECT_FACTORY, opE.toText()).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n-import jdk.incubator.code.dialect.java.TypeVariableType;\n-import jdk.incubator.code.dialect.java.WildcardType;\n+import jdk.incubator.code.dialect.java.*;\n@@ -37,4 +35,1 @@\n-import jdk.incubator.code.dialect.java.ArrayType;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n-import jdk.incubator.code.dialect.java.JavaType;\n+\n@@ -181,1 +176,1 @@\n-        Assert.assertEquals(javaType, CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(javaType.externalize()));\n+        Assert.assertEquals(javaType, JavaOp.JAVA_TYPE_FACTORY.constructType(javaType.externalize()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -35,1 +37,0 @@\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -124,1 +125,2 @@\n-        CoreOp.FuncOp fb = OpBuilder.createBuilderFunction(fExpected);\n+        CoreOp.FuncOp fb = OpBuilder.createBuilderFunction(fExpected,\n+                b -> b.parameter(JavaType.type(DialectFactory.class)));\n@@ -126,1 +128,1 @@\n-                fb, JavaOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+                fb, JavaOp.DIALECT_FACTORY);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-            o = OpParser.fromString(JavaOp.FACTORY, d).get(0);\n+            o = OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0);\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        return serialize(OpParser.fromString(JavaOp.FACTORY, d).get(0));\n+        return serialize(OpParser.fromString(JavaOp.DIALECT_FACTORY, d).get(0));\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}