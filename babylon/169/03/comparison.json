{"files":[{"patch":"@@ -250,0 +250,4 @@\n+    public static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n@@ -308,0 +312,4 @@\n+    public static boolean eq(char l, char r) {\n+        return l == r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -648,5 +648,1 @@\n-        public Value toValue(JCTree tree) {\n-            return toValue(tree, Type.noType);\n-        }\n-\n-        public Value toValue(JCTree tree, Type target) {\n+        public Value toValue(JCExpression expression, Type targetType) {\n@@ -656,2 +652,2 @@\n-                pt = target;\n-                scan(tree);\n+                pt = targetType;\n+                scan(expression);\n@@ -659,1 +655,1 @@\n-                        coerce(result, tree.type, target) :\n+                        coerce(result, expression.type, targetType) :\n@@ -666,0 +662,10 @@\n+        public Value toValue(JCExpression expression) {\n+            return toValue(expression, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree.JCStatement statement) {\n+            result = null; \/\/ reset\n+            scan(statement);\n+            return result;\n+        }\n+\n@@ -705,0 +711,3 @@\n+                    if (!types.isConvertible(source, unboxedTarget)) {\n+                        exprVal = convert(exprVal, unboxedTarget);\n+                    }\n@@ -1372,1 +1381,1 @@\n-                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n@@ -1382,1 +1391,1 @@\n-                    toValue(tree.body);\n+                    toValue(((JCTree.JCStatement) tree.body));\n@@ -1529,2 +1538,4 @@\n-                        \/\/ @@@ Conversion of localTarget\n-                        if (ccl.expr.type.isPrimitive()) {\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n@@ -1544,1 +1555,1 @@\n-                            \/\/ @@@ Conversion of localTarget\n+                            expr = convert(expr, tree.selector.type);\n@@ -1546,1 +1557,1 @@\n-                            if (ccl.expr.type.isPrimitive()) {\n+                            if (tree.selector.type.isPrimitive()) {\n@@ -1587,3 +1598,2 @@\n-                        if (c.body instanceof JCExpression) {\n-                            \/\/ Yield the boolean result of the condition\n-                            Value bodyVal = toValue(c.body, yieldType);\n+                        if (c.body instanceof JCTree.JCExpression e) {\n+                            Value bodyVal = toValue(e, yieldType);\n@@ -1591,1 +1601,1 @@\n-                        } else {\n+                        } else if (c.body instanceof JCTree.JCStatement s){\n@@ -1596,1 +1606,1 @@\n-                                Value bodyVal = toValue(c.body);\n+                                Value bodyVal = toValue(s);\n@@ -2009,1 +2019,5 @@\n-                    rValues.add(toValue(resource));\n+                    if (resource instanceof JCTree.JCExpression e) {\n+                        rValues.add(toValue(e));\n+                    } else if (resource instanceof JCTree.JCStatement s) {\n+                        rValues.add(toValue(s));\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -4,0 +4,4 @@\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.StringWriter;\n+import java.lang.invoke.MethodHandles;\n@@ -8,0 +12,1 @@\n+import java.lang.reflect.code.writer.OpWriter;\n@@ -18,2 +23,11 @@\n-    \/\/ TODO more testing\n-    \/\/  cover cases where MatchException will be thrown\n+    @Test\n+    void testCaseConstantOtherKindsOfExpr() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantOtherKindsOfExpr\");\n+        for (int i = 0; i < 14; i++) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, i), caseConstantOtherKindsOfExpr(i));\n+        }\n+    }\n+\n+    static class Constants {\n+        static final int c1 = 12;\n+    }\n@@ -22,6 +36,17 @@\n-    public static Object f1(String r) {\n-        return switch (r) {\n-            case \"FOO\" -> \"FOO\";\n-            case \"BAR\" -> \"FOO\";\n-            case \"BAZ\" -> \"FOO\";\n-            default -> \"\";\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        final int eleven = 11;\n+        return switch (i) {\n+            case 1 & 0xF -> \"1\";\n+            case 4>>1 -> \"2\";\n+            case (int) 3L -> \"3\";\n+            case 2<<1 -> \"4\";\n+            case 10 \/ 2 -> \"5\";\n+            case 12 - 6 -> \"6\";\n+            case 3 + 4 -> \"7\";\n+            case 2 * 2 * 2 -> \"8\";\n+            case 8 | 1 -> \"9\";\n+            case (10) -> \"10\";\n+            case eleven -> \"11\";\n+            case Constants.c1 -> String.valueOf(Constants.c1);\n+            case 1 > 0 ? 13 : 133 -> \"13\";\n+            default -> \"an int\";\n@@ -32,2 +57,6 @@\n-    public void test1() {\n-        CoreOp.FuncOp lf = lower(\"f1\");\n+    void testCaseConstantEnum() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantEnum\");\n+        for (Day day : Day.values()) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, day), caseConstantEnum(day));\n+        }\n+    }\n@@ -35,4 +64,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n@@ -42,8 +69,6 @@\n-    public static Object f2(String r) { \/\/ switch expr with fallthrough\n-        return switch (r) {\n-            case \"FOO\" : {\n-            }\n-            case \"BAR\" : {\n-                yield \"2\";\n-            }\n-            default : yield \"\";\n+    private static int caseConstantEnum(Day d) {\n+        return switch (d) {\n+            case MON, FRI, SUN -> 6;\n+            case TUE -> 7;\n+            case THU, SAT -> 8;\n+            case WED -> 9;\n@@ -54,2 +79,7 @@\n-    public void test2() {\n-        CoreOp.FuncOp lf = lower(\"f2\");\n+    void testCaseConstantFallThrough() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantFallThrough\");\n+        char[] args = {'A', 'B', 'C'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantFallThrough(arg));\n+        }\n+    }\n@@ -57,3 +87,28 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    @CodeReflection\n+    private static String caseConstantFallThrough(char c) {\n+        return switch (c) {\n+            case 'A':\n+            case 'B':\n+                yield \"A or B\";\n+            default:\n+                yield \"Neither A nor B\";\n+        };\n+    }\n+\n+    \/\/ @CodeReflection\n+    \/\/ compiler code doesn't support case null, default\n+    \/\/ @@@ support such as case and test the switch expression lowering for this case\n+    private static String caseConstantNullAndDefault(String s) {\n+        return switch (s) {\n+            case \"abc\" -> \"alphabet\";\n+            case null, default -> \"null or default\";\n+        };\n+    }\n+\n+    @Test\n+    void testCaseConstantNullLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantNullLabel\");\n+        String[] args = {null, \"non null\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantNullLabel(arg));\n+        }\n@@ -63,2 +118,1 @@\n-    \/\/ null is handled, when selector expr is null the switch will complete normally\n-    private static String f3(String s) {\n+    private static String caseConstantNullLabel(String s) {\n@@ -67,1 +121,1 @@\n-            default -> \"default\";\n+            default -> \"non null\";\n@@ -72,2 +126,17 @@\n-    public void test3() {\n-        CoreOp.FuncOp lf = lower(\"f3\");\n+    void testCaseConstantThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantThrow\");\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+        int[] args = {9, 10};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantThrow(Integer i) {\n+        return switch (i) {\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> \"NINE\";\n+            default -> \"An integer\";\n+        };\n+    }\n@@ -75,2 +144,7 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, new Object[]{null}), f3(null));\n+    @Test\n+    void testCaseConstantMultiLabels() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantMultiLabels\");\n+        char[] args = {'a', 'e', 'i', 'o', 'u', 'j', 'p', 'g'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+        }\n@@ -80,4 +154,4 @@\n-    \/\/ null not handled, when selector expr is null it will throw NPE\n-    private static String f4(String s) {\n-        return switch (s) {\n-            default -> \"default\";\n+    private static String caseConstantMultiLabels(char c) {\n+        return switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u': yield \"vowel\";\n+            default: yield \"consonant\";\n@@ -88,2 +162,6 @@\n-    public void test4() {\n-        CoreOp.FuncOp lf = lower(\"f4\");\n+    void testCaseConstantBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"caseConstantRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"caseConstantRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"caseConstantStatement\");\n+\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n@@ -91,3 +169,4 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertThrows(NullPointerException.class, () -> f4(null));\n-        Assert.assertThrows(NullPointerException.class, () -> Interpreter.invoke(lf, new Object[]{null}));\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n@@ -97,5 +176,34 @@\n-    private static String f5(int i) {\n-        return switch (i) {\n-            case 1 -> \"1\";\n-            case 2 -> \"2\";\n-            default -> \"default\";\n+    public static String caseConstantRuleExpression(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"BAR\";\n+            case \"BAR\" -> \"BAZ\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> {\n+                yield \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                yield \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                yield \"FOO\";\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        return switch (s) {\n+            case \"FOO\": yield \"BAR\";\n+            case \"BAR\": yield \"BAZ\";\n+            case \"BAZ\": yield \"FOO\";\n+            default: yield \"\";\n@@ -106,2 +214,7 @@\n-    public void test5() {\n-        CoreOp.FuncOp lf = lower(\"f5\");\n+    void testCaseConstantConv() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv\");\n+        short[] args = {1, 2, 3, 4};\n+        for (short arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv(arg));\n+        }\n+    }\n@@ -109,3 +222,10 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, 1), f5(1));\n-        Assert.assertEquals(Interpreter.invoke(lf, 2), f5(2));\n-        Assert.assertEquals(Interpreter.invoke(lf, 99), f5(99));\n+    @CodeReflection\n+    static String caseConstantConv(short a) {\n+        final short s = 1;\n+        final byte b = 2;\n+        return switch (a) {\n+            case s -> \"one\"; \/\/ identity\n+            case b -> \"three\"; \/\/ widening primitive conversion\n+            case 3 -> \"two\"; \/\/ narrowing primitive conversion\n+            default -> \"default\";\n+        };\n@@ -114,4 +234,8 @@\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n+    @Test\n+    void testCaseConstantConv2() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv2\");\n+        Byte[] args = {1, 2, 3};\n+        for (Byte arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv2(arg));\n+        }\n+    }\n@@ -119,1 +243,8 @@\n-        return om.get().getCodeModel().get();\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        return switch (a) {\n+            case 1 -> \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion\n+            case b -> \"two\"; \/\/ boxing\n+            default -> \"default\";\n+        };\n@@ -123,1 +254,1 @@\n-        return lower(getFuncOp(methodName));\n+        return lower(getCodeModel(methodName));\n@@ -127,1 +258,1 @@\n-        f.writeTo(System.out);\n+        writeModel(f, System.out, OpWriter.LocationOption.DROP_LOCATION);\n@@ -130,2 +261,1 @@\n-\n-        lf.writeTo(System.out);\n+        writeModel(lf, System.out, OpWriter.LocationOption.DROP_LOCATION);\n@@ -135,0 +265,18 @@\n+\n+    private static void writeModel(CoreOp.FuncOp f, OutputStream os, OpWriter.Option... options) {\n+        StringWriter sw = new StringWriter();\n+        new OpWriter(sw, options).writeOp(f);\n+        try {\n+            os.write(sw.toString().getBytes());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":210,"deletions":62,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -0,0 +1,747 @@\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @build SwitchExpressionTest2\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SwitchExpressionTest2\n+ *\/\n+public class SwitchExpressionTest2 {\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleExpression\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        yield %7;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"BAZ\";\n+                        yield %11;\n+                    }\n+                    (%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        yield %15;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"BAR\";\n+            case \"BAR\" -> \"BAZ\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantRuleBlock\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        java.yield %7;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"BAZ\";\n+                        java.yield %11;\n+                    }\n+                    (%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        java.yield %15;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        java.yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> {\n+                yield \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                yield \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                yield \"FOO\";\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantStatement\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"BAR\";\n+                        java.yield %7;\n+                    }\n+                    (%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"BAZ\";\n+                        java.yield %11;\n+                    }\n+                    (%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.String -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        java.yield %15;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        java.yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        return switch (s) {\n+            case \"FOO\": yield \"BAR\";\n+            case \"BAR\": yield \"BAZ\";\n+            case \"BAZ\": yield \"FOO\";\n+            default: yield \"\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantMultiLabels\" (%0 : char)java.lang.String -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : char = var.load %1;\n+                %3 : char = invoke %2 @\"java.lang.Character::toLowerCase(char)char\";\n+                %4 : java.lang.String = java.switch.expression %3\n+                    (%5 : char)boolean -> {\n+                        %6 : boolean = java.cor\n+                            ()boolean -> {\n+                                %7 : char = constant @\"a\";\n+                                %8 : boolean = eq %5 %7;\n+                                yield %8;\n+                            }\n+                            ()boolean -> {\n+                                %9 : char = constant @\"e\";\n+                                %10 : boolean = eq %5 %9;\n+                                yield %10;\n+                            }\n+                            ()boolean -> {\n+                                %11 : char = constant @\"i\";\n+                                %12 : boolean = eq %5 %11;\n+                                yield %12;\n+                            }\n+                            ()boolean -> {\n+                                %13 : char = constant @\"o\";\n+                                %14 : boolean = eq %5 %13;\n+                                yield %14;\n+                            }\n+                            ()boolean -> {\n+                                %15 : char = constant @\"u\";\n+                                %16 : boolean = eq %5 %15;\n+                                yield %16;\n+                            };\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"vowel\";\n+                        java.yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.String = constant @\"consonant\";\n+                        java.yield %18;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        return switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u': yield \"vowel\";\n+            default: yield \"consonant\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantThrow\" (%0 : java.lang.Integer)java.lang.String -> {\n+                %1 : Var<java.lang.Integer> = var %0 @\"i\";\n+                %2 : java.lang.Integer = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.Integer)boolean -> {\n+                        %5 : int = constant @\"8\";\n+                        %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.IllegalArgumentException = new @\"func<java.lang.IllegalArgumentException>\";\n+                        throw %8;\n+                    }\n+                    (%9 : java.lang.Integer)boolean -> {\n+                        %10 : int = constant @\"9\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        %12 : boolean = invoke %9 %11 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %12;\n+                    }\n+                    ()java.lang.String -> {\n+                        %13 : java.lang.String = constant @\"NINE\";\n+                        yield %13;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %14 : java.lang.String = constant @\"An integer\";\n+                        yield %14;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantThrow(Integer i) {\n+        return switch (i) {\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> \"NINE\";\n+            default -> \"An integer\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantNullLabel\" (%0 : java.lang.String)java.lang.String -> {\n+                %1 : Var<java.lang.String> = var %0 @\"s\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.Object = constant @null;\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        %7 : java.lang.String = constant @\"null\";\n+                        yield %7;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"non null\";\n+                        yield %8;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantNullLabel(String s) {\n+        return switch (s) {\n+            case null -> \"null\";\n+            default -> \"non null\";\n+        };\n+    }\n+\n+    \/\/ @CodeReflection\n+    \/\/ compiler code doesn't support case null, default\n+    \/\/ @@@ support such as case and test the switch expression lowering for this case\n+    private static String caseConstantNullAndDefault(String s) {\n+        return switch (s) {\n+            case \"abc\" -> \"alphabet\";\n+            case null, default -> \"null or default\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantFallThrough\" (%0 : char)java.lang.String -> {\n+                %1 : Var<char> = var %0 @\"c\";\n+                %2 : char = var.load %1;\n+                %3 : java.lang.String = java.switch.expression %2\n+                    (%4 : char)boolean -> {\n+                        %5 : char = constant @\"A\";\n+                        %6 : boolean = eq %4 %5;\n+                        yield %6;\n+                    }\n+                    ()java.lang.String -> {\n+                        java.switch.fallthrough;\n+                    }\n+                    (%7 : char)boolean -> {\n+                        %8 : char = constant @\"B\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()java.lang.String -> {\n+                        %10 : java.lang.String = constant @\"A or B\";\n+                        java.yield %10;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"Neither A nor B\";\n+                        java.yield %11;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantFallThrough(char c) {\n+        return switch (c) {\n+            case 'A':\n+            case 'B':\n+                yield \"A or B\";\n+            default:\n+                yield \"Neither A nor B\";\n+        };\n+    }\n+\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n+    }\n+    @IR(\"\"\"\n+            func @\"caseConstantEnum\" (%0 : SwitchExpressionTest2$Day)int -> {\n+                %1 : Var<SwitchExpressionTest2$Day> = var %0 @\"d\";\n+                %2 : SwitchExpressionTest2$Day = var.load %1;\n+                %3 : int = java.switch.expression %2\n+                    (%4 : SwitchExpressionTest2$Day)boolean -> {\n+                        %5 : boolean = java.cor\n+                            ()boolean -> {\n+                                %6 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::MON()SwitchExpressionTest2$Day\";\n+                                %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::FRI()SwitchExpressionTest2$Day\";\n+                                %9 : boolean = invoke %4 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::SUN()SwitchExpressionTest2$Day\";\n+                                %11 : boolean = invoke %4 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %11;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()int -> {\n+                        %12 : int = constant @\"6\";\n+                        yield %12;\n+                    }\n+                    (%13 : SwitchExpressionTest2$Day)boolean -> {\n+                        %14 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::TUE()SwitchExpressionTest2$Day\";\n+                        %15 : boolean = invoke %13 %14 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %15;\n+                    }\n+                    ()int -> {\n+                        %16 : int = constant @\"7\";\n+                        yield %16;\n+                    }\n+                    (%17 : SwitchExpressionTest2$Day)boolean -> {\n+                        %18 : boolean = java.cor\n+                            ()boolean -> {\n+                                %19 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::THU()SwitchExpressionTest2$Day\";\n+                                %20 : boolean = invoke %17 %19 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %20;\n+                            }\n+                            ()boolean -> {\n+                                %21 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::SAT()SwitchExpressionTest2$Day\";\n+                                %22 : boolean = invoke %17 %21 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %22;\n+                            };\n+                        yield %18;\n+                    }\n+                    ()int -> {\n+                        %23 : int = constant @\"8\";\n+                        yield %23;\n+                    }\n+                    (%24 : SwitchExpressionTest2$Day)boolean -> {\n+                        %25 : SwitchExpressionTest2$Day = field.load @\"SwitchExpressionTest2$Day::WED()SwitchExpressionTest2$Day\";\n+                        %26 : boolean = invoke %24 %25 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %26;\n+                    }\n+                    ()int -> {\n+                        %27 : int = constant @\"9\";\n+                        yield %27;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static int caseConstantEnum(Day d) {\n+        return switch (d) {\n+            case MON, FRI, SUN -> 6;\n+            case TUE -> 7;\n+            case THU, SAT -> 8;\n+            case WED -> 9;\n+        };\n+    }\n+\n+    static class Constants {\n+        static final int c1 = 12;\n+    }\n+    @IR(\"\"\"\n+            func @\"caseConstantOtherKindsOfExpr\" (%0 : int)java.lang.String -> {\n+                %1 : Var<int> = var %0 @\"i\";\n+                %2 : int = constant @\"11\";\n+                %3 : Var<int> = var %2 @\"eleven\";\n+                %4 : int = var.load %1;\n+                %5 : java.lang.String = java.switch.expression %4\n+                    (%6 : int)boolean -> {\n+                        %7 : int = constant @\"1\";\n+                        %8 : int = constant @\"15\";\n+                        %9 : int = and %7 %8;\n+                        %10 : boolean = eq %6 %9;\n+                        yield %10;\n+                    }\n+                    ()java.lang.String -> {\n+                        %11 : java.lang.String = constant @\"1\";\n+                        yield %11;\n+                    }\n+                    (%12 : int)boolean -> {\n+                        %13 : int = constant @\"4\";\n+                        %14 : int = constant @\"1\";\n+                        %15 : int = ashr %13 %14;\n+                        %16 : boolean = eq %12 %15;\n+                        yield %16;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"2\";\n+                        yield %17;\n+                    }\n+                    (%18 : int)boolean -> {\n+                        %19 : long = constant @\"3\";\n+                        %20 : int = conv %19;\n+                        %21 : boolean = eq %18 %20;\n+                        yield %21;\n+                    }\n+                    ()java.lang.String -> {\n+                        %22 : java.lang.String = constant @\"3\";\n+                        yield %22;\n+                    }\n+                    (%23 : int)boolean -> {\n+                        %24 : int = constant @\"2\";\n+                        %25 : int = constant @\"1\";\n+                        %26 : int = lshl %24 %25;\n+                        %27 : boolean = eq %23 %26;\n+                        yield %27;\n+                    }\n+                    ()java.lang.String -> {\n+                        %28 : java.lang.String = constant @\"4\";\n+                        yield %28;\n+                    }\n+                    (%29 : int)boolean -> {\n+                        %30 : int = constant @\"10\";\n+                        %31 : int = constant @\"2\";\n+                        %32 : int = div %30 %31;\n+                        %33 : boolean = eq %29 %32;\n+                        yield %33;\n+                    }\n+                    ()java.lang.String -> {\n+                        %34 : java.lang.String = constant @\"5\";\n+                        yield %34;\n+                    }\n+                    (%35 : int)boolean -> {\n+                        %36 : int = constant @\"12\";\n+                        %37 : int = constant @\"6\";\n+                        %38 : int = sub %36 %37;\n+                        %39 : boolean = eq %35 %38;\n+                        yield %39;\n+                    }\n+                    ()java.lang.String -> {\n+                        %40 : java.lang.String = constant @\"6\";\n+                        yield %40;\n+                    }\n+                    (%41 : int)boolean -> {\n+                        %42 : int = constant @\"3\";\n+                        %43 : int = constant @\"4\";\n+                        %44 : int = add %42 %43;\n+                        %45 : boolean = eq %41 %44;\n+                        yield %45;\n+                    }\n+                    ()java.lang.String -> {\n+                        %46 : java.lang.String = constant @\"7\";\n+                        yield %46;\n+                    }\n+                    (%47 : int)boolean -> {\n+                        %48 : int = constant @\"2\";\n+                        %49 : int = constant @\"2\";\n+                        %50 : int = mul %48 %49;\n+                        %51 : int = constant @\"2\";\n+                        %52 : int = mul %50 %51;\n+                        %53 : boolean = eq %47 %52;\n+                        yield %53;\n+                    }\n+                    ()java.lang.String -> {\n+                        %54 : java.lang.String = constant @\"8\";\n+                        yield %54;\n+                    }\n+                    (%55 : int)boolean -> {\n+                        %56 : int = constant @\"8\";\n+                        %57 : int = constant @\"1\";\n+                        %58 : int = or %56 %57;\n+                        %59 : boolean = eq %55 %58;\n+                        yield %59;\n+                    }\n+                    ()java.lang.String -> {\n+                        %60 : java.lang.String = constant @\"9\";\n+                        yield %60;\n+                    }\n+                    (%61 : int)boolean -> {\n+                        %62 : int = constant @\"10\";\n+                        %63 : boolean = eq %61 %62;\n+                        yield %63;\n+                    }\n+                    ()java.lang.String -> {\n+                        %64 : java.lang.String = constant @\"10\";\n+                        yield %64;\n+                    }\n+                    (%65 : int)boolean -> {\n+                        %66 : int = var.load %3;\n+                        %67 : boolean = eq %65 %66;\n+                        yield %67;\n+                    }\n+                    ()java.lang.String -> {\n+                        %68 : java.lang.String = constant @\"11\";\n+                        yield %68;\n+                    }\n+                    (%69 : int)boolean -> {\n+                        %70 : int = field.load @\"SwitchExpressionTest2$Constants::c1()int\";\n+                        %71 : boolean = eq %69 %70;\n+                        yield %71;\n+                    }\n+                    ()java.lang.String -> {\n+                        %72 : int = field.load @\"SwitchExpressionTest2$Constants::c1()int\";\n+                        %73 : java.lang.String = invoke %72 @\"java.lang.String::valueOf(int)java.lang.String\";\n+                        yield %73;\n+                    }\n+                    (%74 : int)boolean -> {\n+                        %75 : int = java.cexpression\n+                            ()boolean -> {\n+                                %76 : int = constant @\"1\";\n+                                %77 : int = constant @\"0\";\n+                                %78 : boolean = gt %76 %77;\n+                                yield %78;\n+                            }\n+                            ()int -> {\n+                                %79 : int = constant @\"13\";\n+                                yield %79;\n+                            }\n+                            ()int -> {\n+                                %80 : int = constant @\"133\";\n+                                yield %80;\n+                            };\n+                        %81 : boolean = eq %74 %75;\n+                        yield %81;\n+                    }\n+                    ()java.lang.String -> {\n+                        %82 : java.lang.String = constant @\"13\";\n+                        yield %82;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %83 : java.lang.String = constant @\"an int\";\n+                        yield %83;\n+                    };\n+                return %5;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        final int eleven = 11;\n+        return switch (i) {\n+            case 1 & 0xF -> \"1\";\n+            case 4>>1 -> \"2\";\n+            case (int) 3L -> \"3\";\n+            case 2<<1 -> \"4\";\n+            case 10 \/ 2 -> \"5\";\n+            case 12 - 6 -> \"6\";\n+            case 3 + 4 -> \"7\";\n+            case 2 * 2 * 2 -> \"8\";\n+            case 8 | 1 -> \"9\";\n+            case (10) -> \"10\";\n+            case eleven -> \"11\";\n+            case Constants.c1 -> String.valueOf(Constants.c1);\n+            case 1 > 0 ? 13 : 133 -> \"13\";\n+            default -> \"an int\";\n+        };\n+    }\n+\n+    \/\/ these are the conversions that applies in switch\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantConv\" (%0 : short)java.lang.String -> {\n+                %1 : Var<short> = var %0 @\"a\";\n+                %2 : int = constant @\"1\";\n+                %3 : short = conv %2;\n+                %4 : Var<short> = var %3 @\"s\";\n+                %5 : int = constant @\"2\";\n+                %6 : byte = conv %5;\n+                %7 : Var<byte> = var %6 @\"b\";\n+                %8 : short = var.load %1;\n+                %9 : java.lang.String = java.switch.expression %8\n+                    (%10 : short)boolean -> {\n+                        %11 : short = var.load %4;\n+                        %12 : boolean = eq %10 %11;\n+                        yield %12;\n+                    }\n+                    ()java.lang.String -> {\n+                        %13 : java.lang.String = constant @\"one\";\n+                        yield %13;\n+                    }\n+                    (%14 : short)boolean -> {\n+                        %15 : byte = var.load %7;\n+                        %16 : short = conv %15;\n+                        %17 : boolean = eq %14 %16;\n+                        yield %17;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.String = constant @\"three\";\n+                        yield %18;\n+                    }\n+                    (%19 : short)boolean -> {\n+                        %20 : int = constant @\"3\";\n+                        %21 : short = conv %20;\n+                        %22 : boolean = eq %19 %21;\n+                        yield %22;\n+                    }\n+                    ()java.lang.String -> {\n+                        %23 : java.lang.String = constant @\"two\";\n+                        yield %23;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %24 : java.lang.String = constant @\"default\";\n+                        yield %24;\n+                    };\n+                return %9;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseConstantConv(short a) {\n+        final short s = 1;\n+        final byte b = 2;\n+        return switch (a) {\n+            case s -> \"one\"; \/\/ identity\n+            case b -> \"three\"; \/\/ widening primitive conversion\n+            case 3 -> \"two\"; \/\/ narrowing primitive conversion\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantConv2\" (%0 : java.lang.Byte)java.lang.String -> {\n+                %1 : Var<java.lang.Byte> = var %0 @\"a\";\n+                %2 : int = constant @\"2\";\n+                %3 : byte = conv %2;\n+                %4 : Var<byte> = var %3 @\"b\";\n+                %5 : java.lang.Byte = var.load %1;\n+                %6 : java.lang.String = java.switch.expression %5\n+                    (%7 : java.lang.Byte)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : byte = conv %8;\n+                        %10 : java.lang.Byte = invoke %9 @\"java.lang.Byte::valueOf(byte)java.lang.Byte\";\n+                        %11 : boolean = invoke %7 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"one\";\n+                        yield %12;\n+                    }\n+                    (%13 : java.lang.Byte)boolean -> {\n+                        %14 : byte = var.load %4;\n+                        %15 : java.lang.Byte = invoke %14 @\"java.lang.Byte::valueOf(byte)java.lang.Byte\";\n+                        %16 : boolean = invoke %13 %15 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %16;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"two\";\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.String = constant @\"default\";\n+                        yield %18;\n+                    };\n+                return %6;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        return switch (a) {\n+            \/\/ narrowing conv is missing in the code model\n+            case 1 -> \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion\n+            case b -> \"two\"; \/\/ boxing\n+            default -> \"default\";\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":747,"deletions":0,"binary":false,"changes":747,"status":"added"}]}