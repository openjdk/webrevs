{"files":[{"patch":"@@ -308,0 +308,4 @@\n+    public static boolean eq(char l, char r) {\n+        return l == r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -648,5 +648,1 @@\n-        public Value toValue(JCTree tree) {\n-            return toValue(tree, Type.noType);\n-        }\n-\n-        public Value toValue(JCTree tree, Type target) {\n+        public Value toValue(JCExpression expression, Type targetType) {\n@@ -656,2 +652,2 @@\n-                pt = target;\n-                scan(tree);\n+                pt = targetType;\n+                scan(expression);\n@@ -659,1 +655,1 @@\n-                        coerce(result, tree.type, target) :\n+                        coerce(result, expression.type, targetType) :\n@@ -666,0 +662,10 @@\n+        public Value toValue(JCExpression expression) {\n+            return toValue(expression, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree.JCStatement statement) {\n+            result = null; \/\/ reset\n+            scan(statement);\n+            return result;\n+        }\n+\n@@ -1372,1 +1378,1 @@\n-                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n@@ -1382,1 +1388,1 @@\n-                    toValue(tree.body);\n+                    toValue(((JCTree.JCStatement) tree.body));\n@@ -1529,2 +1535,4 @@\n-                        \/\/ @@@ Conversion of localTarget\n-                        if (ccl.expr.type.isPrimitive()) {\n+                        \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                        \/\/ so, we convert constant to the type of the selector expression\n+                        expr = convert(expr, tree.selector.type);\n+                        if (tree.selector.type.isPrimitive()) {\n@@ -1544,1 +1552,1 @@\n-                            \/\/ @@@ Conversion of localTarget\n+                            expr = convert(expr, tree.selector.type);\n@@ -1546,1 +1554,1 @@\n-                            if (ccl.expr.type.isPrimitive()) {\n+                            if (tree.selector.type.isPrimitive()) {\n@@ -1587,3 +1595,2 @@\n-                        if (c.body instanceof JCExpression) {\n-                            \/\/ Yield the boolean result of the condition\n-                            Value bodyVal = toValue(c.body, yieldType);\n+                        if (c.body instanceof JCTree.JCExpression e) {\n+                            Value bodyVal = toValue(e, yieldType);\n@@ -1591,1 +1598,1 @@\n-                        } else {\n+                        } else if (c.body instanceof JCTree.JCStatement s){\n@@ -1596,1 +1603,1 @@\n-                                Value bodyVal = toValue(c.body);\n+                                Value bodyVal = toValue(s);\n@@ -2009,1 +2016,5 @@\n-                    rValues.add(toValue(resource));\n+                    if (resource instanceof JCTree.JCExpression e) {\n+                        rValues.add(toValue(e));\n+                    } else if (resource instanceof JCTree.JCStatement s) {\n+                        rValues.add(toValue(s));\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":31,"deletions":20,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -18,2 +19,11 @@\n-    \/\/ TODO more testing\n-    \/\/  cover cases where MatchException will be thrown\n+    @Test\n+    void testCaseConstantOtherKindsOfExpr() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantOtherKindsOfExpr\");\n+        for (int i = 0; i < 14; i++) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, i), caseConstantOtherKindsOfExpr(i));\n+        }\n+    }\n+\n+    static class Constants {\n+        static final int c1 = 12;\n+    }\n@@ -22,6 +32,17 @@\n-    public static Object f1(String r) {\n-        return switch (r) {\n-            case \"FOO\" -> \"FOO\";\n-            case \"BAR\" -> \"FOO\";\n-            case \"BAZ\" -> \"FOO\";\n-            default -> \"\";\n+    private static String caseConstantOtherKindsOfExpr(int i) {\n+        final int eleven = 11;\n+        return switch (i) {\n+            case 1 & 0xF -> \"1\";\n+            case 4>>1 -> \"2\";\n+            case (int) 3L -> \"3\";\n+            case 2<<1 -> \"4\";\n+            case 10 \/ 2 -> \"5\";\n+            case 12 - 6 -> \"6\";\n+            case 3 + 4 -> \"7\";\n+            case 2 * 2 * 2 -> \"8\";\n+            case 0xF | 1 -> \"9\";\n+            case (10) -> \"10\";\n+            case eleven -> \"11\";\n+            case Constants.c1 -> String.valueOf(Constants.c1);\n+            case 1 > 0 ? 13 : 133 -> \"13\";\n+            default -> \"an int\";\n@@ -32,2 +53,6 @@\n-    public void test1() {\n-        CoreOp.FuncOp lf = lower(\"f1\");\n+    void testCaseConstantEnum() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantEnum\");\n+        for (Day day : Day.values()) {\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lmodel, day), caseConstantEnum(day));\n+        }\n+    }\n@@ -35,4 +60,2 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f1(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f1(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAZ\"), f1(\"BAZ\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f1(\"ELSE\"));\n+    enum Day {\n+        MON, TUE, WED, THU, FRI, SAT, SUN\n@@ -42,8 +65,6 @@\n-    public static Object f2(String r) { \/\/ switch expr with fallthrough\n-        return switch (r) {\n-            case \"FOO\" : {\n-            }\n-            case \"BAR\" : {\n-                yield \"2\";\n-            }\n-            default : yield \"\";\n+    private static int caseConstantEnum(Day d) {\n+        return switch (d) {\n+            case MON, FRI, SUN -> 6;\n+            case TUE -> 7;\n+            case THU, SAT -> 8;\n+            case WED -> 9;\n@@ -54,6 +75,6 @@\n-    public void test2() {\n-        CoreOp.FuncOp lf = lower(\"f2\");\n-\n-        Assert.assertEquals(Interpreter.invoke(lf, \"FOO\"), f2(\"FOO\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"BAR\"), f2(\"BAR\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, \"ELSE\"), f2(\"ELSE\"));\n+    void testCaseConstantFallThrough() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantFallThrough\");\n+        char[] args = {'A', 'B', 'C'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantFallThrough(arg));\n+        }\n@@ -63,2 +84,14 @@\n-    \/\/ null is handled, when selector expr is null the switch will complete normally\n-    private static String f3(String s) {\n+    private static String caseConstantFallThrough(char c) {\n+        return switch (c) {\n+            case 'A':\n+            case 'B':\n+                yield \"A or B\";\n+            default:\n+                yield \"Neither A nor B\";\n+        };\n+    }\n+\n+    \/\/ @CodeReflection\n+    \/\/ compiler code doesn't support case null, default\n+    \/\/ @@@ support such as case and test the switch expression lowering for this case\n+    private static String caseConstantNullAndDefault(String s) {\n@@ -66,2 +99,2 @@\n-            case null -> \"null\";\n-            default -> \"default\";\n+            case \"abc\" -> \"alphabet\";\n+            case null, default -> \"null or default\";\n@@ -72,5 +105,6 @@\n-    public void test3() {\n-        CoreOp.FuncOp lf = lower(\"f3\");\n-\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertEquals(Interpreter.invoke(lf, new Object[]{null}), f3(null));\n+    void testCaseConstantNullLabel() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantNullLabel\");\n+        String[] args = {null, \"non null\"};\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantNullLabel(arg));\n+        }\n@@ -80,2 +114,1 @@\n-    \/\/ null not handled, when selector expr is null it will throw NPE\n-    private static String f4(String s) {\n+    private static String caseConstantNullLabel(String s) {\n@@ -83,1 +116,2 @@\n-            default -> \"default\";\n+            case null -> \"null\";\n+            default -> \"non null\";\n@@ -88,6 +122,7 @@\n-    public void test4() {\n-        CoreOp.FuncOp lf = lower(\"f4\");\n-\n-        Assert.assertEquals(Interpreter.invoke(lf, \"SOMETHING\"), f3(\"SOMETHING\"));\n-        Assert.assertThrows(NullPointerException.class, () -> f4(null));\n-        Assert.assertThrows(NullPointerException.class, () -> Interpreter.invoke(lf, new Object[]{null}));\n+    void testCaseConstantThrow() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantThrow\");\n+        Assert.assertThrows(IllegalArgumentException.class, () -> Interpreter.invoke(lmodel, 8));\n+        int[] args = {9, 10};\n+        for (int arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantThrow(arg));\n+        }\n@@ -97,1 +132,1 @@\n-    private static String f5(int i) {\n+    private static String caseConstantThrow(Integer i) {\n@@ -99,3 +134,3 @@\n-            case 1 -> \"1\";\n-            case 2 -> \"2\";\n-            default -> \"default\";\n+            case 8 -> throw new IllegalArgumentException();\n+            case 9 -> \"NINE\";\n+            default -> \"An integer\";\n@@ -106,2 +141,7 @@\n-    public void test5() {\n-        CoreOp.FuncOp lf = lower(\"f5\");\n+    void testCaseConstantMultiLabels() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantMultiLabels\");\n+        char[] args = {'a', 'e', 'i', 'o', 'u', 'j', 'p', 'g'};\n+        for (char arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantMultiLabels(arg));\n+        }\n+    }\n@@ -109,3 +149,6 @@\n-        Assert.assertEquals(Interpreter.invoke(lf, 1), f5(1));\n-        Assert.assertEquals(Interpreter.invoke(lf, 2), f5(2));\n-        Assert.assertEquals(Interpreter.invoke(lf, 99), f5(99));\n+    @CodeReflection\n+    private static String caseConstantMultiLabels(char c) {\n+        return switch (Character.toLowerCase(c)) {\n+            case 'a', 'e', 'i', 'o', 'u': yield \"vowel\";\n+            default: yield \"consonant\";\n+        };\n@@ -114,4 +157,5 @@\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n+    @Test\n+    void testCaseConstantBehaviorIsSyntaxIndependent() {\n+        CoreOp.FuncOp ruleExpression = lower(\"caseConstantRuleExpression\");\n+        CoreOp.FuncOp ruleBlock = lower(\"caseConstantRuleBlock\");\n+        CoreOp.FuncOp statement = lower(\"caseConstantStatement\");\n@@ -119,1 +163,44 @@\n-        return om.get().getCodeModel().get();\n+        String[] args = {\"FOO\", \"BAR\", \"BAZ\", \"OTHER\"};\n+\n+        for (String arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(ruleBlock, arg));\n+            Assert.assertEquals(Interpreter.invoke(ruleExpression, arg), Interpreter.invoke(statement, arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleExpression(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"BAR\";\n+            case \"BAR\" -> \"BAZ\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    public static String caseConstantRuleBlock(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> {\n+                yield \"BAR\";\n+            }\n+            case \"BAR\" -> {\n+                yield \"BAZ\";\n+            }\n+            case \"BAZ\" -> {\n+                yield \"FOO\";\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    private static String caseConstantStatement(String s) {\n+        return switch (s) {\n+            case \"FOO\": yield \"BAR\";\n+            case \"BAR\": yield \"BAZ\";\n+            case \"BAZ\": yield \"FOO\";\n+            default: yield \"\";\n+        };\n@@ -123,1 +210,1 @@\n-        return lower(getFuncOp(methodName));\n+        return lower(getCodeModel(methodName));\n@@ -135,0 +222,8 @@\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestSwitchExpressionOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":156,"deletions":61,"binary":false,"changes":217,"status":"modified"}]}