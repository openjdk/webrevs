{"files":[{"patch":"@@ -250,0 +250,4 @@\n+    public static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -711,0 +711,3 @@\n+                    if (!types.isConvertible(source, unboxedTarget)) {\n+                        exprVal = convert(exprVal, unboxedTarget);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,0 +213,40 @@\n+    @Test\n+    void testCaseConstantConv() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv\");\n+        short[] args = {1, 2, 3, 4};\n+        for (short arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseConstantConv(short a) {\n+        final short s = 1;\n+        final byte b = 2;\n+        return switch (a) {\n+            case s -> \"one\"; \/\/ identity\n+            case b -> \"three\"; \/\/ widening primitive conversion\n+            case 3 -> \"two\"; \/\/ narrowing primitive conversion\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @Test\n+    void testCaseConstantConv2() {\n+        CoreOp.FuncOp lmodel = lower(\"caseConstantConv2\");\n+        Byte[] args = {1, 2, 3};\n+        for (Byte arg : args) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, arg), caseConstantConv2(arg));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        return switch (a) {\n+            case 1 -> \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion\n+            case b -> \"two\"; \/\/ boxing\n+            default -> \"default\";\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSwitchExpressionOp.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -633,0 +633,114 @@\n+\n+    \/\/ these are the conversions that applies in switch\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantConv\" (%0 : short)java.lang.String -> {\n+                %1 : Var<short> = var %0 @\"a\";\n+                %2 : int = constant @\"1\";\n+                %3 : short = conv %2;\n+                %4 : Var<short> = var %3 @\"s\";\n+                %5 : int = constant @\"2\";\n+                %6 : byte = conv %5;\n+                %7 : Var<byte> = var %6 @\"b\";\n+                %8 : short = var.load %1;\n+                %9 : java.lang.String = java.switch.expression %8\n+                    (%10 : short)boolean -> {\n+                        %11 : short = var.load %4;\n+                        %12 : boolean = eq %10 %11;\n+                        yield %12;\n+                    }\n+                    ()java.lang.String -> {\n+                        %13 : java.lang.String = constant @\"one\";\n+                        yield %13;\n+                    }\n+                    (%14 : short)boolean -> {\n+                        %15 : byte = var.load %7;\n+                        %16 : short = conv %15;\n+                        %17 : boolean = eq %14 %16;\n+                        yield %17;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.String = constant @\"three\";\n+                        yield %18;\n+                    }\n+                    (%19 : short)boolean -> {\n+                        %20 : int = constant @\"3\";\n+                        %21 : short = conv %20;\n+                        %22 : boolean = eq %19 %21;\n+                        yield %22;\n+                    }\n+                    ()java.lang.String -> {\n+                        %23 : java.lang.String = constant @\"two\";\n+                        yield %23;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %24 : java.lang.String = constant @\"default\";\n+                        yield %24;\n+                    };\n+                return %9;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseConstantConv(short a) {\n+        final short s = 1;\n+        final byte b = 2;\n+        return switch (a) {\n+            case s -> \"one\"; \/\/ identity\n+            case b -> \"three\"; \/\/ widening primitive conversion\n+            case 3 -> \"two\"; \/\/ narrowing primitive conversion\n+            default -> \"default\";\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"caseConstantConv2\" (%0 : java.lang.Byte)java.lang.String -> {\n+                %1 : Var<java.lang.Byte> = var %0 @\"a\";\n+                %2 : int = constant @\"2\";\n+                %3 : byte = conv %2;\n+                %4 : Var<byte> = var %3 @\"b\";\n+                %5 : java.lang.Byte = var.load %1;\n+                %6 : java.lang.String = java.switch.expression %5\n+                    (%7 : java.lang.Byte)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : byte = conv %8;\n+                        %10 : java.lang.Byte = invoke %9 @\"java.lang.Byte::valueOf(byte)java.lang.Byte\";\n+                        %11 : boolean = invoke %7 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %11;\n+                    }\n+                    ()java.lang.String -> {\n+                        %12 : java.lang.String = constant @\"one\";\n+                        yield %12;\n+                    }\n+                    (%13 : java.lang.Byte)boolean -> {\n+                        %14 : byte = var.load %4;\n+                        %15 : java.lang.Byte = invoke %14 @\"java.lang.Byte::valueOf(byte)java.lang.Byte\";\n+                        %16 : boolean = invoke %13 %15 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %16;\n+                    }\n+                    ()java.lang.String -> {\n+                        %17 : java.lang.String = constant @\"two\";\n+                        yield %17;\n+                    }\n+                    ()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %18 : java.lang.String = constant @\"default\";\n+                        yield %18;\n+                    };\n+                return %6;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static String caseConstantConv2(Byte a) {\n+        final byte b = 2;\n+        return switch (a) {\n+            \/\/ narrowing conv is missing in the code model\n+            case 1 -> \"one\"; \/\/ narrowing primitive conversion followed by a boxing conversion\n+            case b -> \"two\"; \/\/ boxing\n+            default -> \"default\";\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest2.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"modified"}]}