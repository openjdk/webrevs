{"files":[{"patch":"@@ -53,0 +53,2 @@\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Func.Statement;\n+import static optkl.OpHelper.Named.NamedStaticOrInstance.Func.func;\n@@ -54,1 +56,0 @@\n-import static optkl.OpHelper.Named.NamedStaticOrInstance.Func.*;\n@@ -57,0 +58,1 @@\n+import static optkl.OpHelper.methodModelOrNull;\n@@ -69,1 +71,1 @@\n-        int l = 40*s32Array.length()+25;\n+        int l = 40 * s32Array.length() + 25;\n@@ -71,1 +73,1 @@\n-        s32Array.array(0,s32Array.array(0)+1);\n+        s32Array.array(0, s32Array.array(0) + 1);\n@@ -81,1 +83,1 @@\n-        var func = func(lookup, InjectBufferTracking.class,\"add\",ComputeContext.class, S32Array.class, int.class, int.class);\n+        var func = func(lookup, InjectBufferTracking.class, \"add\", ComputeContext.class, S32Array.class, int.class, int.class);\n@@ -86,2 +88,2 @@\n-            void put(Value value, boolean mutate){\n-                if (mutate){\n+            void put(Value value, boolean mutate) {\n+                if (mutate) {\n@@ -89,1 +91,1 @@\n-                }else {\n+                } else {\n@@ -93,0 +95,16 @@\n+            boolean mutates(Value value){\n+                return StatementSpanImpl.this.mutates.contains(value);\n+            }\n+            boolean accesses(Value value){\n+                return StatementSpanImpl.this.accesses.contains(value);\n+            }\n+            boolean accessesOrMutates(Value value){\n+                return mutates(value)|accesses(value);\n+            }\n+            boolean accessesAndMutates(Value value){\n+                return mutates(value)&accesses(value);\n+            }\n+\n+            public String describe(Value value) {\n+                return  (mutates(value) ? \"mutates \" : \"\") + (accessesAndMutates(value) ? \"and \" : \"\") + (accesses(value) ? \"accesses \" : \"\");\n+            }\n@@ -97,3 +115,3 @@\n-        Map<Op,StatementSpanImpl> opToStatementSpans = createOpToStatementSpanMap(func.op(),\n-                op->op instanceof JavaOp.InvokeOp, \/\/ we only care if the statement actually contains an invoke\n-                ops-> new StatementSpanImpl(new HashSet<>(), new HashSet<>(), Mutable.of(null),ops)\n+        Map<Op, StatementSpanImpl> opToStatementSpans = createOpToStatementSpanMap(func.op(),\n+                op -> op instanceof JavaOp.InvokeOp, \/\/ we only care if the statement actually contains an invoke\n+                ops -> new StatementSpanImpl(new HashSet<>(), new HashSet<>(), Mutable.of(null), ops)\n@@ -105,1 +123,1 @@\n-        opToStatementSpans.values().forEach(statementSpan -> {\n+        opToStatementSpans.values().forEach(statementSpan ->\n@@ -109,1 +127,1 @@\n-                }else if (Invoke.invoke(lookup, opInStatement) instanceof Invoke invoke\n+                } else if (Invoke.invoke(lookup, opInStatement) instanceof Invoke invoke\n@@ -115,2 +133,2 @@\n-            });\n-        });\n+            })\n+        );\n@@ -120,2 +138,5 @@\n-        Trxfmr.of(lookup,func.op())\n-               \/\/ .toText(\"COMPUTE before injecting buffer tracking...\")\n+\n+        enum Acc{NONE,ACCESSES,MUTATES}\n+\n+        Trxfmr.of(lookup, func.op())\n+                \/\/ .toText(\"COMPUTE before injecting buffer tracking...\")\n@@ -123,26 +144,23 @@\n-                .transform((block, op) ->{\n-                    if (opToStatementSpans.containsKey(op)) {\n-                        var statementSpan = opToStatementSpans.get(op);\n-                        if (statementSpan.firstOrLast(op)) {\n-                            var computeContext = getFuncParamOrNull(op, 0);\n-                            \/\/Value mappedComputeContext = block.context().mapValue(getFuncParamOrNull(op, 0));\n-                            if (!OpHelper.isAssignable(lookup, computeContext.type(), ComputeContext.class)) {\n-                             \/\/   System.out.println(\"ok we found the compute context\");\n-                            \/\/}else {\n-                                throw new RuntimeException(\"parameter 0 is not compute context \"+computeContext.type());\n-                            }\n-                            if (statementSpan.isFrom(op)) {\n-                                statementSpan.ops.stream()\n-                                        .filter(o->o instanceof JavaOp.InvokeOp)\n-                                        .map(o->Invoke.invoke(lookup,o))\n-                                        .filter(Invoke::isInstance)\n-                                        .forEach(invoke -> {\n-                                            if (OpHelper.isAssignable(lookup,invoke.refType(),MappableIface.class)){\n-                                                boolean mutates = statementSpan.mutates.contains(invoke.op().operands().getFirst());\n-                                                boolean accesses  = statementSpan.accesses.contains(invoke.op().operands().getFirst());\n-                                               var before = block.op(CoreOp.constant(JavaType.J_L_STRING, \"The following statement \"\n-                                                       +(mutates?\"mutates \":\"\")+ ((mutates&accesses)?\"and \":\"\")+(accesses?\"accesses \":\"\")+\n-                                                       \"iface mapped buffer \"));\n-                                               block.op(JavaOp.invoke( JavaType.VOID, Println, before));\n-                                            } else {\n-                                                \/\/ System.out.println(\"nope\");\n+                .transform(ce -> ce instanceof Op op\n+                        && opToStatementSpans.containsKey(op)\n+                        && opToStatementSpans.get(ce).firstOrLast(op),\n+                        c -> {\n+                    var statementSpan = opToStatementSpans.get(c.op());\n+                   \/\/ var computeContext = getFuncParamOrNull(c.op(), 0);\n+                   \/\/ Value mappedComputeContext = c.getValue(getFuncParamOrNull(c.op(), 0));\n+                    if (statementSpan.isTo(c.op())) {\n+                        c.retain();\n+                    }\n+                    var acc = Mutable.of(Acc.NONE);\n+                            statementSpan.ops.stream()\n+                                    .map(o -> Invoke.invoke(lookup, o))\n+                                    .filter(invoke -> invoke!=null && invoke.isInstance() && invoke.refIs(MappableIface.class))\n+                                    .forEach(invoke -> {\n+                                        acc.set(switch(acc.get()) {\n+                                            case NONE -> {\n+                                                if (statementSpan.mutates(invoke.instance())) {\n+                                                    yield Acc.MUTATES;\n+                                                } else if (statementSpan.accesses(invoke.instance())) {\n+                                                    yield Acc.ACCESSES;\n+                                                } else {\n+                                                    yield acc.get();\n@@ -150,23 +168,0 @@\n-\n-                                    \/\/ var mappedIfaceBuffer =c.getValue(ifaceBuffer);\n-                                    \/\/ c.add(JavaOp.invoke(accessOrMutateWrapper.pre, mappedComputeContext,ifaceBuffer));\n-                                    \/\/c.retain();\n-                                });\n-                                block.op(op);\n-                            } else if (statementSpan.isTo(op)) {\n-                                block.op(op);\n-                                statementSpan.ops.stream()\n-                                        .filter(o->o instanceof JavaOp.InvokeOp)\n-                                        .map(o->Invoke.invoke(lookup,o))\n-                                        .filter(Invoke::isInstance)\n-                                        .forEach(invoke -> {\n-                                            if (OpHelper.isAssignable(lookup,invoke.refType(),MappableIface.class)){\n-                                                boolean mutates = statementSpan.mutates.contains(invoke.op().operands().getFirst());\n-                                                boolean accesses  = statementSpan.accesses.contains(invoke.op().operands().getFirst());\n-                                                var after = block.op(CoreOp.constant(JavaType.J_L_STRING,\n-                                                        \"The previous statement \"\n-                                                                +(mutates?\"mutates \":\"\")+ ((mutates&accesses)?\"and \":\"\")+(accesses?\"accesses \":\"\")+\n-                                                                \"iface mapped buffer \"));\n-                                                block.op(JavaOp.invoke( JavaType.VOID, Println, after));\n-                                            } else {\n-                                                \/\/  System.out.println(\"nope\");\n@@ -174,4 +169,14 @@\n-                                    \/\/ var mappedIfaceBuffer =c.getValue(ifaceBuffer);\n-                                    \/\/  c.retain();\n-                                    \/\/ c.add(JavaOp.invoke(accessorMutateWrapper.post, mappedComputeContext,mappedIfaceBuffer));\n-                                });\n+                                            case ACCESSES -> {\n+                                                if (statementSpan.mutates(invoke.instance())) {\n+                                                    yield Acc.MUTATES;\n+                                                } else {\n+                                                    yield acc.get();\n+                                                }\n+                                            }\n+                                            default -> acc.get();\n+                                        });\n+\n+                                    });\n+                            if (!acc.get().equals(Acc.NONE)) {\n+                                var msg = (statementSpan.isTo(c.op()) ? \"Prev\" : \"Next\") + \" statement \" +acc.get() + \" iface mapped buffer \";\n+                                c.add(JavaOp.invoke(JavaType.VOID, Println, c.builder().op(CoreOp.constant(JavaType.J_L_STRING, msg))));\n@@ -179,5 +184,2 @@\n-                        }else {\n-                            block.op(op);\n-                        }\n-                    }else {\n-                        block.op(op);\n+                    if (statementSpan.isFrom(c.op())){\n+                        c.retain();\n@@ -185,1 +187,0 @@\n-                    return block;\n@@ -187,2 +188,1 @@\n-\n-             \/\/   .toText(\"COMPUTE after injecting buffer tracking...\")\n+                \/\/   .toText(\"COMPUTE after injecting buffer tracking...\")\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InjectBufferTracking.java","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"}]}