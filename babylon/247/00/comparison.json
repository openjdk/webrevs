{"files":[{"patch":"@@ -58,0 +58,1 @@\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n@@ -79,1 +80,0 @@\n-import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n@@ -293,10 +293,0 @@\n-    private void moveTo(Block.Builder next) {\n-        currentBlock = next;\n-        constantCache.clear();\n-        \/\/ Stack is reconstructed from block parameters\n-        stack.clear();\n-        if (currentBlock != null) {\n-            currentBlock.parameters().forEach(stack::add);\n-        }\n-    }\n-\n@@ -332,0 +322,1 @@\n+                var type = JavaType.type(v.type());\n@@ -336,1 +327,1 @@\n-                                                       JavaType.type(v.type()), \/\/ Type calculated by LocalsToVarMapper\n+                                                       type, \/\/ Type calculated by LocalsToVarMapper\n@@ -369,1 +360,5 @@\n-                        moveTo(next);\n+                        constantCache.clear();\n+                        \/\/ Stack is reconstructed from block parameters\n+                        stack.clear();\n+                        stack.addAll(next.parameters());\n+                        currentBlock = next;\n@@ -412,1 +407,1 @@\n-                    Block.Builder next = newBlock(branch.parameters());\n+                    Block.Builder next = entryBlock.block();\n@@ -414,1 +409,1 @@\n-                            successor(next),\n+                            next.successor(),\n@@ -416,1 +411,1 @@\n-                    moveTo(next);\n+                    currentBlock = next;\n@@ -953,1 +948,1 @@\n-            constantCache.put(c, res);\n+            if (c != null) constantCache.put(c, res); \/\/ Do not cache null constants, they may differ in types\n@@ -985,6 +980,13 @@\n-            Block.Builder next = sc == last ? def : newBlock(def.parameters());\n-            op(CoreOp.conditionalBranch(\n-                    op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n-                    successor(findTargetBlock(sc.target())),\n-                    successor(next)));\n-            moveTo(next);\n+            if (sc == last) {\n+                op(CoreOp.conditionalBranch(\n+                        op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                        successor(findTargetBlock(sc.target())),\n+                        successor(def)));\n+            } else {\n+                Block.Builder next = entryBlock.block();\n+                op(CoreOp.conditionalBranch(\n+                        op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                        successor(findTargetBlock(sc.target())),\n+                        next.successor()));\n+                currentBlock = next;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -247,5 +247,0 @@\n-    \/**\n-     * Dirty flag indicates modified stack map frame (sub-int adjustments), so the scanning process must restart\n-     *\/\n-    private boolean frameDirty;\n-\n@@ -287,27 +282,11 @@\n-        int initSize = allSegments.size();\n-\n-        \/\/ Main loop of the scan phase\n-        do {\n-            \/\/ Reset of the exception handler stack\n-            handlersStack.clear();\n-            \/\/ Slot states reset if running additional rounds (changed stack map frames)\n-            if (allSegments.size() > initSize) {\n-                while (allSegments.size() > initSize) allSegments.removeLast();\n-                allSegments.forEach(sl -> {\n-                    sl.from = null;\n-                    sl.to = null;\n-                    sl.var = null;\n-                });\n-            }\n-            \/\/ Initial frame store\n-            for (int i = 0; i < initFrameLocals.size(); i++) {\n-                storeLocal(i, initSlots.get(i), locals);\n-            }\n-            this.frameDirty = false;\n-            \/\/ Iteration over all code elements\n-            for (int i = 0; i < codeElements.size(); i++) {\n-                var ce = codeElements.get(i);\n-                scan(i, ce);\n-            }\n-            endOfFlow();\n-        } while (this.frameDirty);\n+\n+        \/\/ Scan phase\n+        \/\/ Initial frame store\n+        for (int i = 0; i < initFrameLocals.size(); i++) {\n+            storeLocal(i, initSlots.get(i), locals);\n+        }\n+        \/\/ Iteration over all code elements\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            var ce = codeElements.get(i);\n+            scan(i, ce);\n+        }\n@@ -351,3 +330,1 @@\n-                                if (var.type == NULL_TYPE) {\n-                                    var.type = to.type; \/\/ Initially null type re-assignemnt\n-                                }\n+                                var.type = merge(var.type, to.type);\n@@ -363,3 +340,1 @@\n-                                    if (var.type == NULL_TYPE) {\n-                                        var.type = from.type; \/\/ Initially null type re-assignemnt\n-                                    }\n+                                    var.type = merge(from.type, var.type);\n@@ -407,0 +382,4 @@\n+    private static ClassDesc merge(ClassDesc fromType, ClassDesc toType) {\n+        return toType == NULL_TYPE || fromType == CD_boolean ? fromType : toType;\n+    }\n+\n@@ -849,6 +828,1 @@\n-                if (se.isPrimitive() && CD_int.equals(fe)) {\n-                    targetFrame.stack.set(i, se); \/\/ Override int target frame type with more specific int sub-type\n-                    this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n-                } else {\n-                    stack.set(i, fe); \/\/ Override stack type with target frame type\n-                }\n+                stack.set(i, fe); \/\/ Override stack type with target frame type\n@@ -873,6 +847,0 @@\n-                if (!le.type.equals(fe.type)) {\n-                    if (le.type.isPrimitive() && CD_int.equals(fe.type) ) {\n-                        fe.type = le.type; \/\/ Override int target frame type with more specific int sub-type\n-                        this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n-                    }\n-                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":18,"deletions":50,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import sun.invoke.util.Wrapper;\n@@ -422,2 +423,0 @@\n-\n-            mh = mh.asType(target).asFixedArity();\n@@ -425,0 +424,2 @@\n+            target = eraseInts(mh.type(), target, values);\n+            mh = mh.asType(target).asFixedArity();\n@@ -540,1 +541,1 @@\n-            MethodHandle mh = opHandle(o.opName(), o.opType());\n+            MethodHandle mh = opHandle(l, o.opName(), o.opType());\n@@ -544,1 +545,1 @@\n-            MethodHandle mh = opHandle(o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+            MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -592,0 +593,24 @@\n+    \/\/ method type with converted int types and int values wrapped as expected by the handleType\n+    static MethodType eraseInts(MethodType handleType, MethodType target, Object[] values) {\n+        for (int i = 0; i < Math.min(values.length, handleType.parameterCount()); i++) {\n+            Object v = values[i];\n+            Class<?> ht = handleType.parameterType(i);\n+            Class<?> vt;\n+            Wrapper w;\n+            if (v != null && ht != (vt = v.getClass()) && (w = intTypeWrapper(ht)) != null && w.wrapperType() != vt) {\n+                values[i] = w.wrap(v);\n+                target = target.changeParameterType(i, ht);\n+            }\n+        }\n+        return target;\n+    }\n+\n+    static Wrapper intTypeWrapper(Class<?> type) {\n+        if (type == int.class)      return Wrapper.INT;\n+        if (type == boolean.class)  return Wrapper.BOOLEAN;\n+        if (type == byte.class)     return Wrapper.BYTE;\n+        if (type == char.class)     return Wrapper.CHAR;\n+        if (type == short.class)    return Wrapper.SHORT;\n+        return null;\n+    }\n+\n@@ -607,2 +632,2 @@\n-    static MethodHandle opHandle(String opName, FunctionType ft) {\n-        MethodType mt = resolveToMethodType(MethodHandles.lookup(), ft).erase();\n+    static MethodHandle opHandle(MethodHandles.Lookup l, String opName, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(l, ft).erase();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -200,0 +200,24 @@\n+    public static boolean eq(byte l, byte r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(byte l, byte r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(byte l, byte r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(byte l, byte r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(byte l, byte r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(byte l, byte r) {\n+        return l <= r;\n+    }\n+\n@@ -262,2 +286,22 @@\n-    public static boolean eq(short a, short b) {\n-        return a == b;\n+    public static boolean eq(short l, short r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(short l, short r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(short l, short r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(short l, short r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(short l, short r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(short l, short r) {\n+        return l <= r;\n@@ -332,0 +376,19 @@\n+    public static boolean neq(char l, char r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(char l, char r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(char l, char r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(char l, char r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(char l, char r) {\n+        return l <= r;\n+    }\n@@ -502,0 +565,23 @@\n+    public static boolean eq(double l, double r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(double l, double r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(double l, double r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(double l, double r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(double l, double r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(double l, double r) {\n+        return l <= r;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":88,"deletions":2,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.interpreter;\n+\n+import java.lang.classfile.TypeKind;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Verifier {\n+\n+    @SuppressWarnings(\"serial\")\n+    public final class VerifyError extends Error {\n+\n+        public VerifyError(String message) {\n+            super(message);\n+        }\n+\n+        public String getPrintedContext() {\n+            return toText(rootOp);\n+        }\n+    }\n+\n+    public static List<Verifier.VerifyError> verify(Op op) {\n+        return verify(MethodHandles.publicLookup(), op);\n+    }\n+\n+    public static List<Verifier.VerifyError> verify(MethodHandles.Lookup l, Op op) {\n+        var verifier = new Verifier(l, op);\n+        verifier.verifyOps();\n+        return verifier.errors == null ? List.of() : Collections.unmodifiableList(verifier.errors);\n+    }\n+\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final Op rootOp;\n+    private OpWriter.CodeItemNamerOption namerOption;\n+    private List<Verifier.VerifyError> errors;\n+\n+    private Verifier(MethodHandles.Lookup lookup, Op rootOp) {\n+        this.lookup = lookup;\n+        this.rootOp = rootOp;\n+    }\n+\n+    private OpWriter.CodeItemNamerOption getNamer() {\n+        if (namerOption == null) {\n+            namerOption = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(rootOp));\n+        }\n+        return namerOption;\n+    }\n+\n+    private String toText(Op op) {\n+        return OpWriter.toText(op, getNamer());\n+    }\n+\n+    private String getName(CodeItem codeItem) {\n+        return getNamer().namer().apply(codeItem);\n+    }\n+\n+    private void error(String message, Object... args) {\n+        if (errors == null) {\n+            errors = new ArrayList<>();\n+        }\n+        for (int i = 0; i < args.length; i++) {\n+            var arg = args[i];\n+            if (arg instanceof Op op) {\n+                args[i] = toText(op);\n+            } else if (arg instanceof Block b) {\n+                args[i] = getName(b);\n+            } else if (arg instanceof Value v) {\n+                args[i] = getName(v);\n+            }\n+        }\n+        errors.add(new VerifyError(message.formatted(args)));\n+    }\n+\n+    private void verifyOps() {\n+        rootOp.traverse(null, CodeElement.opVisitor((n, op) -> {\n+            \/\/ Verify operands declaration dominannce\n+            for (var v : op.operands()) {\n+                if (!op.result().isDominatedBy(v)) {\n+                    error(\"%s %s operand %s is not dominated by its declaration in %s\", op.parentBlock(), op, v, v.declaringBlock());\n+                }\n+            }\n+\n+            \/\/ Verify individual Ops\n+            switch (op) {\n+                case CoreOp.BranchOp br ->\n+                    verifyBlockReferences(op, br.successors());\n+                case CoreOp.ArithmeticOperation _, CoreOp.TestOperation _ ->\n+                    verifyOpHandleExists(op, op.opName());\n+                case CoreOp.ConvOp _ -> {\n+                    verifyOpHandleExists(op, op.opName() + \"_\" + op.opType().returnType());\n+                }\n+                default -> {}\n+\n+            }\n+            return null;\n+        }));\n+    }\n+\n+    private void verifyBlockReferences(Op op, List<Block.Reference> references) {\n+        for (Block.Reference r : references) {\n+            Block b = r.targetBlock();\n+            List<Value> args = r.arguments();\n+            List<Block.Parameter> params = r.targetBlock().parameters();\n+            if (args.size() != params.size()) {\n+                error(\"%s %s block reference arguments size to target block parameters size mismatch\", b, op);\n+            } else {\n+                Block tb = r.targetBlock();\n+                for (int i = 0; i < args.size(); i++) {\n+                    if (toTypeKind(params.get(i).type(), tb).asLoadable() != toTypeKind(args.get(i).type(), b).asLoadable()) {\n+                        error(\"%s %s parameter type %s is not compatible with argument type %s\", op.parentBlock(), op, params.get(i).type(), args.get(i).type());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private TypeKind toTypeKind(TypeElement e, Block context) {\n+        if (e instanceof JavaType jt) {\n+            return TypeKind.from(jt.toNominalDescriptor());\n+        }\n+        error(\"%s %s is not a Java type\", context, e);\n+        return TypeKind.REFERENCE;\n+    }\n+\n+    private void verifyOpHandleExists(Op op, String opName) {\n+        try {\n+            var mt = Interpreter.resolveToMethodType(lookup, op.opType()).erase();\n+            MethodHandles.lookup().findStatic(InvokableLeafOps.class, opName, mt);\n+        } catch (NoSuchMethodException nsme) {\n+            error(\"%s %s of type %s is not supported\", op.parentBlock(), op, op.opType());\n+        } catch (IllegalAccessException iae) {\n+            error(\"%s %s %s\",  op.parentBlock(), op, iae.getMessage());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Verifier.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -39,1 +38,2 @@\n-import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.constant.ConstantDescs.*;\n@@ -52,1 +52,1 @@\n-                clb.withMethodBody(\"backJumps\", MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int), ClassFile.ACC_STATIC, cob -> {\n+                clb.withMethodBody(\"backJumps\", MethodTypeDesc.of(CD_int, CD_int), ClassFile.ACC_STATIC, cob -> {\n@@ -73,0 +73,13 @@\n+    @Test\n+    public void testEraseInts() throws Throwable {\n+        CoreOp.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"EraseInts\"), clb ->\n+                clb.withMethodBody(\"compare\", MethodTypeDesc.of(CD_short, CD_boolean, CD_char), ClassFile.ACC_STATIC, cob -> {\n+                    cob.iload(0)\n+                       .iload(1)\n+                       .invokestatic(Short.class.describeConstable().get(), \"compare\", MethodTypeDesc.of(CD_int, CD_short, CD_short))\n+                       .ireturn();\n+                })), \"compare\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, true, 1), '\\0');\n+    }\n+\n@@ -76,1 +89,1 @@\n-                clb.withMethodBody(\"deepStackJump\", MethodTypeDesc.of(ConstantDescs.CD_long), ClassFile.ACC_STATIC, cob -> {\n+                clb.withMethodBody(\"deepStackJump\", MethodTypeDesc.of(CD_long), ClassFile.ACC_STATIC, cob -> {\n@@ -113,1 +126,1 @@\n-                clb.withMethodBody(\"condyMethod\", MethodTypeDesc.of(ConstantDescs.CD_Class), ClassFile.ACC_STATIC, cob ->\n+                clb.withMethodBody(\"condyMethod\", MethodTypeDesc.of(CD_Class), ClassFile.ACC_STATIC, cob ->\n@@ -115,1 +128,1 @@\n-                                ConstantDescs.ofConstantBootstrap(ConstantDescs.CD_ConstantBootstraps, \"primitiveClass\", ConstantDescs.CD_Class),\n+                                ofConstantBootstrap(CD_ConstantBootstraps, \"primitiveClass\", CD_Class),\n@@ -117,1 +130,1 @@\n-                                ConstantDescs.CD_Class))\n+                                CD_Class))\n@@ -129,1 +142,1 @@\n-                clb.withMethodBody(\"concatMethod\", MethodTypeDesc.of(ConstantDescs.CD_String), ClassFile.ACC_STATIC, cob ->\n+                clb.withMethodBody(\"concatMethod\", MethodTypeDesc.of(CD_String), ClassFile.ACC_STATIC, cob ->\n@@ -132,2 +145,2 @@\n-                                ConstantDescs.ofCallsiteBootstrap(StringConcatFactory.class.describeConstable().get(), \"makeConcat\", ConstantDescs.CD_CallSite),\n-                                MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String, ConstantDescs.CD_String)))\n+                                ofCallsiteBootstrap(StringConcatFactory.class.describeConstable().get(), \"makeConcat\", CD_CallSite),\n+                                MethodTypeDesc.of(CD_String, CD_String, CD_String, CD_String)))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.lang.reflect.code.CodeElement;\n-import java.lang.reflect.code.Value;\n@@ -38,0 +36,1 @@\n+import java.lang.reflect.code.interpreter.Verifier;\n@@ -39,1 +38,0 @@\n-import java.lang.reflect.code.writer.OpWriter;\n@@ -104,1 +102,1 @@\n-        Assert.assertTrue(stable > 54140 && unstable < 100, String.format(\"stable: %d unstable: %d\", stable, unstable));\n+        Assert.assertTrue(stable > 54000 && unstable < 100, String.format(\"stable: %d unstable: %d\", stable, unstable));\n@@ -136,0 +134,1 @@\n+                        if (prevReflection != null) printInColumns(prevReflection, reflection);\n@@ -137,1 +136,0 @@\n-                        printInColumns(prevReflection, reflection);\n@@ -156,14 +154,8 @@\n-        reflection.traverse(null, CodeElement.opVisitor((n, op) -> {\n-            for (Value v : op.operands()) {\n-                \/\/ Verify operands dominance\n-                if (!op.result().isDominatedBy(v)) {\n-                    printBytecode();\n-                    var naming = OpWriter.CodeItemNamerOption.of(OpWriter.computeGlobalNames(reflection));\n-                    System.out.println(OpWriter.toText(reflection, naming));\n-                    System.out.println(\"Reflection verification failed\");\n-                    throw new AssertionError(\"block_%d %s is not dominated by its operand declaration in block_%d\".formatted(\n-                            op.parentBlock().index(), OpWriter.toText(op, naming), v.declaringBlock().index()));\n-                }\n-            }\n-            return null;\n-        }));\n+        var errors = Verifier.verify(TRUSTED_LOOKUP, reflection);\n+        if (!errors.isEmpty()) {\n+            printBytecode();\n+            System.out.println(\"Code reflection model verification failed\");\n+            errors.forEach(System.out::println);\n+            System.out.println(errors.getFirst().getPrintedContext());\n+            throw errors.getFirst();\n+        }\n@@ -178,1 +170,1 @@\n-                throw new AssertionError(e.getMessage());\n+                throw e;\n@@ -216,0 +208,2 @@\n+        } catch (UnsupportedOperationException uoe) {\n+            throw uoe;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"}]}