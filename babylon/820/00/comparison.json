{"files":[{"patch":"@@ -375,1 +375,1 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -41,0 +40,1 @@\n+import optkl.ifacemapper.AccessType;\n@@ -43,1 +43,0 @@\n-import java.lang.annotation.Annotation;\n@@ -46,1 +45,0 @@\n-import java.util.ArrayList;\n@@ -81,92 +79,0 @@\n-    record TypeAndAccess(Annotation[] annotations, Value value, JavaType javaType) {\n-        static TypeAndAccess of(Annotation[] annotations, Value value) {\n-            return new TypeAndAccess(annotations, value, (JavaType) value.type());\n-        }\n-\n-        boolean isIface(MethodHandles.Lookup lookup) {\n-            return OpHelper.isAssignable(lookup, javaType, MappableIface.class);\n-        }\n-\n-        boolean ro() {\n-            for (Annotation annotation : annotations) {\n-                if (annotation instanceof MappableIface.RO) {\n-                    \/\/System.out.println(\"MappableIface.RO\");\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        boolean rw() {\n-            for (Annotation annotation : annotations) {\n-                if (annotation instanceof MappableIface.RW) {\n-                    \/\/System.out.println(\"MappableIface.RW\");\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        boolean wo() {\n-            for (Annotation annotation : annotations) {\n-                if (annotation instanceof MappableIface.WO) {\n-                   \/\/ System.out.println(\"MappableIface.WO\");\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    \/\/ This code should be common with jextracted-shared probably should be pushed down into another lib?\n-    protected CoreOp.FuncOp injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n-\n-        var transformer =   Trxfmr.of(computeMethod.funcOp());\n-        if (config().minimizeCopies()) {\n-            var paramTable = new FuncOpParams(computeMethod.funcOp());\n-            transformer\n-                    .when(config().showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE before injecting buffer tracking...\"))\n-                    .when(config().showComputeModelJavaCode(), trxfmr -> trxfmr.toJavaSource(lookup(),\"COMPUTE (Java) before injecting buffer tracking...\"))\n-                    .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n-                        var invoke = invokeOpHelper(lookup(), c.op());\n-                        if (invoke.isMappableIface() && (invoke.returns(MappableIface.class) || invoke.returnsPrimitive())) {\n-                            Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n-                            Value ifaceMappedBuffer = c.builder().context().getValue(invoke.op().operands().getFirst());\n-                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.pre : ACCESS.pre, computeContext, ifaceMappedBuffer));\n-                            c.retain();\n-                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.post : ACCESS.post, computeContext, ifaceMappedBuffer));\n-                        } else if (!invoke.refIs(ComputeContext.class) && invoke.operandCount()>0) {\n-                                Annotation[][] parameterAnnotations =  invoke.resolveMethodOrThrow().getParameterAnnotations();\n-                                int firstParam =invoke.isInstance()?1:0; \/\/ if virtual\n-                                List<TypeAndAccess> typeAndAccesses = new ArrayList<>();\n-                                for (int i = firstParam; i < invoke.operandCount(); i++) {\n-                                    typeAndAccesses.add(TypeAndAccess.of(parameterAnnotations[i - firstParam], invoke.op().operands().get(i)));\n-                                }\n-                                Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n-                                typeAndAccesses.stream()\n-                                        .filter(typeAndAccess -> typeAndAccess.isIface(lookup()))\n-                                        .forEach(typeAndAccess ->\n-                                            c.add(JavaOp.invoke(\n-                                                    typeAndAccess.ro() ? ACCESS.pre : MUTATE.pre,\n-                                                    computeContext, c.builder().context().getValue(typeAndAccess.value))\n-                                            )\n-                                        );\n-                                c.retain();\n-                                typeAndAccesses.stream()\n-                                        .filter(typeAndAccess -> OpHelper.isAssignable(lookup(), typeAndAccess.javaType, MappableIface.class))\n-                                        .forEach(typeAndAccess ->\n-                                            c.add(JavaOp.invoke(\n-                                                    typeAndAccess.ro() ? ACCESS.post : MUTATE.post,\n-                                                    computeContext, c.builder().context().getValue(typeAndAccess.value))\n-                                            )\n-                                        );\n-                            }\n-                    })\n-                    .when(config().showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE after injecting buffer tracking...\"))\n-                    .run(trxfmr -> computeMethod.funcOp(trxfmr.funcOp()));\n-        } else {\n-            transformer.when(config().showComputeModel(),trxfmr -> trxfmr.toText(\"COMPUTE not injecting buffer tracking)\"));\n-        }\n-        return computeMethod.funcOp();\n-    }\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":1,"deletions":95,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.backend.Backend;\n@@ -64,1 +65,1 @@\n-        injectBufferTracking(computeContext.computeEntrypoint());\n+        computeContext.computeEntrypoint().funcOp(injectBufferTracking(config(),lookup(),computeContext.computeEntrypoint().funcOp()));\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,8 +65,0 @@\n-\n-    \/\/ This code should be common with ffi-shared probably should be pushed down into another lib?\n-    protected static CoreOp.FuncOp injectBufferTracking(CallGraph.ResolvedMethodCall computeMethod) {\n-      \/\/  System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-       \/\/ System.out.println(computeMethod.funcOp().toText());\n-        throw new RuntimeException(\"implement inject buffer tracking \");\n-        \/\/return transformedFuncOp;\n-    }\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,8 @@\n+import hat.callgraph.CallGraph;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.FuncOpParams;\n+import optkl.OpHelper;\n+import optkl.Trxfmr;\n+import optkl.ifacemapper.AccessType;\n@@ -35,0 +43,1 @@\n+import optkl.ifacemapper.MappableIface;\n@@ -39,0 +48,1 @@\n+import java.util.List;\n@@ -42,0 +52,4 @@\n+import static hat.ComputeContext.WRAPPER.ACCESS;\n+import static hat.ComputeContext.WRAPPER.MUTATE;\n+import static optkl.OpHelper.NamedOpHelper.Invoke.invokeOpHelper;\n+\n@@ -91,0 +105,47 @@\n+\n+\n+    public static  CoreOp.FuncOp injectBufferTracking(Config config, MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+        var transformer = Trxfmr.of(funcOp);\n+        if (config.minimizeCopies()) {\n+            var paramTable = new FuncOpParams(funcOp);\n+            return transformer\n+                    .when(config.showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE before injecting buffer tracking...\"))\n+                    .when(config.showComputeModelJavaCode(), trxfmr -> trxfmr.toJavaSource(lookup, \"COMPUTE (Java) before injecting buffer tracking...\"))\n+                    .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+                        var invoke = invokeOpHelper(lookup, c.op());\n+                        if (invoke.isMappableIface() && (invoke.returns(MappableIface.class) || invoke.returnsPrimitive())) {\n+                            Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n+                            Value ifaceMappedBuffer = c.builder().context().getValue(invoke.op().operands().getFirst());\n+                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.pre : ACCESS.pre, computeContext, ifaceMappedBuffer));\n+                            c.retain();\n+                            c.add(JavaOp.invoke(invoke.returnsVoid() ? MUTATE.post : ACCESS.post, computeContext, ifaceMappedBuffer));\n+                        } else if (!invoke.refIs(ComputeContext.class) && invoke.operandCount() > 0) {\n+                            List<AccessType.TypeAndAccess> typeAndAccesses = invoke.paramaterAccessList();\n+                            Value computeContext = c.builder().context().getValue(paramTable.list().getFirst().parameter);\n+                            typeAndAccesses.stream()\n+                                    .filter(typeAndAccess -> typeAndAccess.isIface(lookup))\n+                                    .forEach(typeAndAccess ->\n+                                            c.add(JavaOp.invoke(\n+                                                    typeAndAccess.ro() ? ACCESS.pre : MUTATE.pre,\n+                                                    computeContext, c.builder().context().getValue(typeAndAccess.value()))\n+                                            )\n+                                    );\n+                            c.retain();\n+                            typeAndAccesses.stream()\n+                                    .filter(typeAndAccess -> OpHelper.isAssignable(lookup, typeAndAccess.javaType(), MappableIface.class))\n+                                    .forEach(typeAndAccess ->\n+                                            c.add(JavaOp.invoke(\n+                                                    typeAndAccess.ro() ? ACCESS.post : MUTATE.post,\n+                                                    computeContext, c.builder().context().getValue(typeAndAccess.value()))\n+                                            )\n+                                    );\n+                        }\n+                    })\n+                    .when(config.showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE after injecting buffer tracking...\"))\n+                    .funcOp();\n+        } else {\n+            return transformer.when(config.showComputeModel(), trxfmr -> trxfmr.toText(\"COMPUTE not injecting buffer tracking)\")).funcOp();\n+        }\n+    }\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/Backend.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+import hat.device.DeviceSchema;\n+import hat.device.DeviceType;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.MethodRef;\n+import optkl.codebuilders.JavaCodeBuilder;\n@@ -46,0 +51,1 @@\n+import java.util.Map;\n@@ -57,1 +63,1 @@\n-    private interface SharedS32x256Array extends Buffer {\n+    private interface SharedS32x256Array extends DeviceType {\n@@ -62,1 +68,1 @@\n-        Schema<SharedS32x256Array> schema = Schema.of(SharedS32x256Array.class, $ -> $.array(\"array\", 32));\n+        DeviceSchema<SharedS32x256Array> schema = DeviceSchema.of(SharedS32x256Array.class, $ -> $.withArray(\"array\", 32));\n@@ -65,1 +71,1 @@\n-            return schema.allocate(accelerator); \/\/ Why would we get here?\n+           return null;\/\/ return schema.allocate(accelerator); \/\/ Why would we get here?\n@@ -369,2 +375,1 @@\n-    public static void main(String[] args) {\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+    public static void main(String[] args) throws ReflectiveOperationException {\n@@ -372,0 +377,6 @@\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var methodRef= MethodRef.method(PrefixSum.class, \"compute\", void.class, ComputeContext.class,S32Array.class);\n+        var funcOp = CoreOp.FuncOp.ofMethod(methodRef.resolveToMethod(MethodHandles.lookup())).get();\n+       Backend.injectBufferTracking(accelerator.config(),accelerator.lookup(),funcOp);\n+        JavaCodeBuilder jc = new JavaCodeBuilder(accelerator.lookup(),funcOp);\n+        System.out.println(jc.toText());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.Body;\n@@ -40,0 +41,1 @@\n+import optkl.ifacemapper.AccessType;\n@@ -45,0 +47,1 @@\n+import java.lang.annotation.Annotation;\n@@ -265,0 +268,1 @@\n+\n@@ -269,1 +273,8 @@\n-                        throw new RuntimeException(e);\n+                        try {\n+                            Field field = clazz.getDeclaredField(name());\n+                            field.setAccessible(true);\n+                            return field.get(null);\n+                        }catch (NoSuchFieldException |  IllegalAccessException e2){\n+                            throw new RuntimeException(e2);\n+                        }\n+\n@@ -397,0 +408,10 @@\n+           default List<AccessType.TypeAndAccess> paramaterAccessList(){\n+                Annotation[][] parameterAnnotations =  resolveMethodOrThrow().getParameterAnnotations();\n+                int firstParam =isInstance()?1:0; \/\/ if virtual\n+                List<AccessType.TypeAndAccess> typeAndAccesses = new ArrayList<>();\n+                for (int i = firstParam; i < operandCount(); i++) {\n+                    typeAndAccesses.add(AccessType.TypeAndAccess.of(parameterAnnotations[i - firstParam], op().operands().get(i)));\n+                }\n+                return typeAndAccesses;\n+            }\n+\n@@ -450,2 +471,3 @@\n-        static Stream<Op> loopBodyStatements(Op.Loop op) {\n-            var list = new ArrayList<>(statements(op.loopBody().entryBlock()).toList());\n+\n+        static Stream<Op> bodyStatements(Body body) {\n+            var list = new ArrayList<>(statements(body.entryBlock()).toList());\n@@ -457,0 +479,3 @@\n+        static Stream<Op> loopBodyStatements(Op.Loop op) {\n+           return bodyStatements(op.loopBody());\n+        }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+    T newOp(SB buildContext, JavaOp.NewOp newOp);\n+    T arrayLoadOp(SB buildContext, JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp);\n+    T arrayStoreOp(SB buildContext, JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp);\n+    T enhancedForOp(SB buildContext, JavaOp.EnhancedForOp enhancedForOp);\n@@ -116,1 +120,4 @@\n-\n+            case JavaOp.NewOp $ -> newOp(buildContext, $);\n+            case JavaOp.ArrayAccessOp.ArrayStoreOp  $ ->  arrayStoreOp(buildContext,$);\n+            case JavaOp.ArrayAccessOp.ArrayLoadOp  $ ->  arrayLoadOp(buildContext,$);\n+            case JavaOp.EnhancedForOp $ -> enhancedForOp(buildContext,$);\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/BabylonOpDispatcher.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -727,0 +727,3 @@\n+    public final T varName(CoreOp.VarAccessOp.VarLoadOp varOp) {\n+        return blockInlineComment(\"varName of varLoadOp?\");\/\/varName(varOp.varOp());\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.ArrayType;\n@@ -90,1 +91,5 @@\n-        varName((CoreOp.VarOp)resolve);\n+        if (resolve instanceof CoreOp.VarOp varOp) {\n+            varName(varOp);\n+        }else if (resolve instanceof CoreOp.VarAccessOp.VarLoadOp){\n+            varName(varLoadOp);\n+        }\n@@ -112,1 +117,7 @@\n-            parenthesisIfNeeded(buildContext, varOp, ((Op.Result)varOp.operands().getFirst()).op());\n+            var first = varOp.operands().getFirst();\n+            if (first instanceof Op.Result result) {\n+                parenthesisIfNeeded(buildContext, varOp, result.op());\n+            }else {\n+\n+                blockInlineComment(\"how \"+first);\n+            }\n@@ -206,2 +217,0 @@\n-    @Override\n-    public final T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n@@ -209,2 +218,0 @@\n-        return comment(\"\/* how to generate LAMBDA code! \/\");\n-    }\n@@ -409,0 +416,72 @@\n+\n+    @Override\n+    public T newOp(ScopedCodeBuilderContext buildContext, JavaOp.NewOp newOp) {\n+         newKeyword().space().type(buildContext,(JavaType) newOp.type());\n+       if (newOp.operands().isEmpty()){\n+           ocparen();\n+       }else {\n+           if (newOp.type() instanceof ArrayType){\n+               brace(_ -> {\n+                   commaSpaceSeparated(newOp.operands(),\n+                           op -> {\n+                               if (op instanceof Op.Result result) {\n+                                   recurse(buildContext, result.op());\n+                               }\n+                           });\n+               });\n+           }else {\n+               paren(_ -> {\n+                   commaSpaceSeparated(newOp.operands(),\n+                           op -> {\n+                               if (op instanceof Op.Result result) {\n+                                   recurse(buildContext, result.op());\n+                               }\n+                           });\n+               });\n+           }\n+       }\n+       return self();\n+    }\n+    @Override\n+    public T arrayLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp){\n+        recurse(buildContext,((Op.Result)arrayLoadOp.operands().get(0)).op());\n+        sbrace(_-> recurse(buildContext,((Op.Result)arrayLoadOp.operands().get(1)).op()));\n+        return self();\n+    }\n+\n+    @Override\n+    public T arrayStoreOp(ScopedCodeBuilderContext buildContext, JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp){\n+        recurse(buildContext,((Op.Result)arrayStoreOp.operands().get(0)).op());\n+        sbrace(_-> recurse(buildContext,((Op.Result)arrayStoreOp.operands().get(1)).op()));\n+        space().equals().space();\n+        recurse(buildContext,((Op.Result)arrayStoreOp.operands().get(2)).op());\n+        return self();\n+    }\n+\n+    @Override\n+    public T enhancedForOp(ScopedCodeBuilderContext builderContext, JavaOp.EnhancedForOp enhancedForOp){\n+        forKeyword().paren(_-> {\n+            keyword(\"var\").space().blockInlineComment(\"v\").space().colon().space();\n+            \/\/  enhancedForOp.initialization().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+            enhancedForOp.expression().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+            \/\/ enhancedForOp.loopBody().entryBlock().ops().stream().filter(o -> o instanceof CoreOp.YieldOp).forEach(o -> recurse(builderContext, o));\n+            \/\/ recurse(builderContext,exp);\n+        }).braceNlIndented(_->\n+            nlSeparated(OpHelper.Statement.loopBodyStatements(enhancedForOp),\n+                    statement ->statement(builderContext,statement)\n+            )\n+\n+        );\n+        return self();\n+    }\n+    @Override\n+    public final T lambdaOp(ScopedCodeBuilderContext buildContext, JavaOp.LambdaOp lambdaOp) {\n+        braceNlIndented(_-> {\n+            blockInlineComment(\"LAMBDA\");\n+            nlSeparated(OpHelper.Statement.bodyStatements(lambdaOp.body()),\n+                    statement -> statement(buildContext, statement)\n+            );\n+            blockInlineComment(\"ADBMAL\");\n+        });\n+        return self();\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/JavaOrC99StyleCodeBuilder.java","additions":85,"deletions":6,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.core.VarType;\n@@ -65,0 +66,3 @@\n+            if (value instanceof Block.Parameter parameter){\n+                return parameter.uses().iterator().next().op();\n+            }\n@@ -82,1 +86,2 @@\n-                    throw new IllegalStateException(\"what ?\");\n+                    return super.resolve(value);\n+                    \/\/throw new IllegalStateException(\"what ?\");\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/ScopedCodeBuilderContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.OpHelper;\n+\n@@ -28,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -61,0 +66,40 @@\n+\n+\n+\n+    public record TypeAndAccess(Annotation[] annotations, Value value, JavaType javaType) {\n+        public static TypeAndAccess of(Annotation[] annotations, Value value) {\n+            return new TypeAndAccess(annotations, value, (JavaType) value.type());\n+        }\n+\n+      public  boolean isIface(MethodHandles.Lookup lookup) {\n+            return OpHelper.isAssignable(lookup, javaType, MappableIface.class);\n+        }\n+\n+      public   boolean ro() {\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof MappableIface.RO) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+       public boolean rw() {\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof MappableIface.RW) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+       public boolean wo() {\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof MappableIface.WO) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/AccessType.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-                 JavaOp.WhileOp _\n+                 JavaOp.WhileOp _,\n+                 JavaOp.ArrayAccessOp.ArrayLoadOp _,\n+                 JavaOp.ArrayAccessOp.ArrayStoreOp _,\n+                 JavaOp.NewOp _\n@@ -94,0 +97,1 @@\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/util\/ops\/Precedence.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}