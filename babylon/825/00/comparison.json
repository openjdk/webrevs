{"files":[{"patch":"@@ -209,1 +209,0 @@\n-        var here = CallSite.of(C99FFIBackend.class, \"createCode\");\n@@ -307,1 +306,1 @@\n-                IO.println(\"Original\");\n+                IO.println(\"Non Lowered\");\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,23 +141,0 @@\n-\n-    @Override\n-    public final T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp globalThreadIdOp) {\n-        switch (globalThreadIdOp.getDimension()) {\n-            case 0 -> HAT_GIX();\n-            case 1 -> HAT_GIY();\n-            case 2 -> HAT_GIZ();\n-            default -> throw new RuntimeException(\"globalId id = \" + globalThreadIdOp.getDimension());\n-        }\n-        return self();\n-    }\n-\n-    @Override\n-    public final T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp globalSizeOp) {\n-        return (switch (globalSizeOp.getDimension()) {\n-            case 0 -> HAT_GSX();\n-            case 1 -> HAT_GSY();\n-            case 2 -> HAT_GSZ();\n-            default -> throw new RuntimeException(\"globalSize id = \" + globalSizeOp.getDimension());\n-        });\n-\n-    }\n-\n@@ -165,6 +142,17 @@\n-    public final T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp localThreadIdOp) {\n-        return (switch (localThreadIdOp.getDimension()) {\n-            case 0 -> HAT_LIX();\n-            case 1 -> HAT_LIY();\n-            case 2 -> HAT_LIZ();\n-            default -> throw new RuntimeException(\"localId id = \" + localThreadIdOp.getDimension());\n+    public final T hatThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp threadOp) {\n+        return (switch (threadOp) {\n+            case HATThreadOp.HAT_LI.HAT_LIX _ -> HAT_LIX();\n+            case HATThreadOp.HAT_LI.HAT_LIY _ -> HAT_LIY();\n+            case HATThreadOp.HAT_LI.HAT_LIZ _ -> HAT_LIZ();\n+            case HATThreadOp.HAT_LS.HAT_LSX _ -> HAT_LSX();\n+            case HATThreadOp.HAT_LS.HAT_LSY _ -> HAT_LSY();\n+            case HATThreadOp.HAT_LS.HAT_LSZ _ -> HAT_LSZ();\n+            case HATThreadOp.HAT_GI.HAT_GIX _ -> HAT_GIX();\n+            case HATThreadOp.HAT_GI.HAT_GIY _ -> HAT_GIY();\n+            case HATThreadOp.HAT_GI.HAT_GIZ _ -> HAT_GIZ();\n+            case HATThreadOp.HAT_GS.HAT_GSX _ -> HAT_GSX();\n+            case HATThreadOp.HAT_GS.HAT_GSY _ -> HAT_GSY();\n+            case HATThreadOp.HAT_GS.HAT_GSZ _ -> HAT_GSZ();\n+            case HATThreadOp.HAT_BI.HAT_BIX _ -> HAT_BIX();\n+            case HATThreadOp.HAT_BI.HAT_BIY _ -> HAT_BIY();\n+            case HATThreadOp.HAT_BI.HAT_BIZ _ -> HAT_BIZ();\n@@ -175,20 +163,0 @@\n-    @Override\n-    public final T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp) {\n-        return (switch (hatLocalSizeOp.getDimension()) {\n-            case 0 -> HAT_LSX();\n-            case 1 -> HAT_LSY();\n-            case 2 -> HAT_LSZ();\n-            default -> throw new RuntimeException(\"localSize id = \" + hatLocalSizeOp.getDimension());\n-        });\n-    }\n-\n-    @Override\n-    public final T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp) {\n-        return (switch (hatBlockThreadIdOp.getDimension()) {\n-            case 0 -> HAT_BIX();\n-            case 1 -> HAT_BIY();\n-            case 2 -> HAT_BIZ();\n-            default -> throw new RuntimeException(\"blockId id = \" + hatBlockThreadIdOp.getDimension());\n-        });\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":17,"deletions":49,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -42,9 +42,1 @@\n-    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalThreadIdOp hatGlobalThreadIdOp);\n-\n-    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATGlobalSizeOp hatGlobalSizeOp);\n-\n-    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalThreadIdOp hatLocalThreadIdOp);\n-\n-    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATLocalSizeOp hatLocalSizeOp);\n-\n-    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp.HATBlockThreadIdOp hatBlockThreadIdOp);\n+    T hatThreadIdOp(ScopedCodeBuilderContext buildContext, HATThreadOp hatThreadOp);\n@@ -98,5 +90,1 @@\n-                case HATThreadOp.HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n-                case HATThreadOp.HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n-                case HATThreadOp.HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n-                case HATThreadOp.HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n-                case HATThreadOp.HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n+                case HATThreadOp $ -> hatThreadIdOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATOpDispatcher.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\/*\n+ This is suspiciously  similar to NDRange's Dim interface.  in this case we return 0,1,2 vs 1,2,3\n+ *\/\n+ interface Dim  {\n+          interface X extends Dim{}\n+         interface Y extends Dim{}\n+          interface Z extends Dim{}\n+\n+\n+    default int dimension() {\n+        return switch (Dim.this){\n+            case X  _ -> 0;\n+            case Y _ -> 1;\n+            case Z  _ ->2;\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + Dim.this);\n+        };\n+    }\n+    }\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/Dim.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -37,5 +38,2 @@\n-public abstract sealed class HATThreadOp extends HATOp implements Precedence.LoadOrConv\n-        permits HATThreadOp.HATBlockThreadIdOp, HATThreadOp.HATGlobalSizeOp, HATThreadOp.HATGlobalThreadIdOp, HATThreadOp.HATLocalSizeOp, HATThreadOp.HATLocalThreadIdOp {\n-   final  private String name;\n-   final  private TypeElement resultType;\n-   final  private int dimension;\n+public abstract sealed class HATThreadOp extends HATOp implements Dim,  Precedence.LoadOrConv\n+        permits HATThreadOp.HAT_BI, HATThreadOp.HAT_GS, HATThreadOp.HAT_GI, HATThreadOp.HAT_LS, HATThreadOp.HAT_LI {\n@@ -43,1 +41,1 @@\n-    public HATThreadOp(String name, TypeElement resultType,int dimension, List<Value> operands) {\n+    public HATThreadOp( List<Value> operands) {\n@@ -45,3 +43,0 @@\n-        this.name = name;\n-        this.resultType = resultType;\n-        this.dimension = dimension;\n@@ -52,3 +47,0 @@\n-        this.name =that.name;\n-        this.resultType = that.resultType;\n-        this.dimension = that.dimension;\n@@ -57,5 +49,0 @@\n-    public int getDimension() {\n-        return dimension;\n-    }\n-\n-\n@@ -64,1 +51,1 @@\n-        return resultType;\n+        return JavaType.INT;\n@@ -66,4 +53,25 @@\n-\n-    @Override\n-    final public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + name, this.getDimension());\n+  \/\/  @Override\n+  \/\/  final public Map<String, Object> externalize() {\n+    \/\/    return Map.of(\"hat.dialect.\" + getClass().getSimpleName(), \"\");\n+   \/\/ }\n+\n+\n+    public static HATThreadOp create(String name){\n+        return switch (name){\n+            case \"gix\"->  new HATThreadOp.HAT_GI.HAT_GIX();\n+            case \"giy\"->  new HATThreadOp.HAT_GI.HAT_GIY();\n+            case \"giz\"->  new HATThreadOp.HAT_GI.HAT_GIZ();\n+            case \"gsx\"->  new HATThreadOp.HAT_GS.HAT_GSX();\n+            case \"gsy\"->  new HATThreadOp.HAT_GS.HAT_GSY();\n+            case \"gsz\"->  new HATThreadOp.HAT_GS.HAT_GSZ();\n+            case \"lix\"->  new HATThreadOp.HAT_LI.HAT_LIX();\n+            case \"liy\"->  new HATThreadOp.HAT_LI.HAT_LIY();\n+            case \"liz\"->  new HATThreadOp.HAT_LI.HAT_LIZ();\n+            case \"lsx\"->  new HATThreadOp.HAT_LS.HAT_LSX();\n+            case \"lsy\"->  new HATThreadOp.HAT_LS.HAT_LSY();\n+            case \"lsz\"->  new HATThreadOp.HAT_LS.HAT_LSZ();\n+            case \"bix\"->  new HATThreadOp.HAT_BI.HAT_BIX();\n+            case \"biy\"->  new HATThreadOp.HAT_BI.HAT_BIY();\n+            case \"biz\"->  new HATThreadOp.HAT_BI.HAT_BIZ();\n+            default -> throw  new RuntimeException(\"what is this ?\");\n+        };\n@@ -72,1 +80,1 @@\n-    public static final class HATLocalThreadIdOp extends HATThreadOp {\n+    public static sealed abstract class HAT_LI extends HATThreadOp  permits HAT_LI.HAT_LIX, HAT_LI.HAT_LIY, HAT_LI.HAT_LIZ {\n@@ -74,2 +82,2 @@\n-        public HATLocalThreadIdOp(int dimension, TypeElement resultType) {\n-            super(\"LocalThreadId\",resultType,dimension, List.of());\n+        public HAT_LI() {\n+            super(List.of());\n@@ -78,1 +86,1 @@\n-        public HATLocalThreadIdOp(HATLocalThreadIdOp op, CodeContext copyContext) {\n+        public HAT_LI(HAT_LI op, CodeContext copyContext) {\n@@ -82,3 +90,11 @@\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            return new HATLocalThreadIdOp(this, copyContext);\n+        public static final class HAT_LIX extends HAT_LI implements Dim.X{\n+            public HAT_LIX(HAT_LIX op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_LIX() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_LIX(this, copyContext);\n+            }\n@@ -86,3 +102,23 @@\n-\n-        public static HATLocalThreadIdOp of(int dimension, TypeElement resultType){\n-            return new HATLocalThreadIdOp(dimension,resultType);\n+        public static final class HAT_LIY extends HAT_LI implements Dim.Y{\n+            public HAT_LIY(HAT_LIY op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_LIY() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_LIY(this, copyContext);\n+            }\n+        }\n+        public static final class HAT_LIZ extends HAT_LI implements Dim.Z{\n+            public HAT_LIZ(HAT_LI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_LIZ() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_LIZ(this, copyContext);\n+            }\n@@ -90,0 +126,1 @@\n+\n@@ -92,3 +129,3 @@\n-    public static final class HATBlockThreadIdOp extends HATThreadOp {\n-        public HATBlockThreadIdOp(int dimension, TypeElement resultType) {\n-            super(\"BlockThreadId\", resultType,dimension, List.of());\n+    public static abstract sealed class HAT_BI extends HATThreadOp {\n+        public HAT_BI() {\n+            super(List.of());\n@@ -97,1 +134,1 @@\n-        public HATBlockThreadIdOp(HATBlockThreadIdOp op, CodeContext copyContext) {\n+        public HAT_BI(HAT_BI op, CodeContext copyContext) {\n@@ -101,3 +138,11 @@\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            return new HATBlockThreadIdOp(this, copyContext);\n+        public static final class HAT_BIX extends HAT_BI implements Dim.X{\n+            public HAT_BIX(HAT_BI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_BIX() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_BIX(this, copyContext);\n+            }\n@@ -105,4 +150,23 @@\n-\n-\n-        public static HATBlockThreadIdOp of(int dimension, TypeElement resultType){\n-            return new HATBlockThreadIdOp(dimension,resultType);\n+        public static final class HAT_BIY extends HAT_BI implements Dim.Y{\n+            public HAT_BIY(HAT_BI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_BIY() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_BIY(this, copyContext);\n+            }\n+        }\n+        public static final class HAT_BIZ extends HAT_BI implements Dim.Z{\n+            public HAT_BIZ(HAT_BI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_BIZ() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_BIZ(this, copyContext);\n+            }\n@@ -112,1 +176,1 @@\n-    public static final class HATLocalSizeOp extends HATThreadOp {\n+    public static abstract sealed class HAT_LS extends HATThreadOp permits HAT_LS.HAT_LSX, HAT_LS.HAT_LSY, HAT_LS.HAT_LSZ {\n@@ -114,2 +178,2 @@\n-        public HATLocalSizeOp(int dimension, TypeElement resultType) {\n-            super(\"GlobalThreadSize\",resultType,dimension, List.of());\n+        public HAT_LS() {\n+            super(List.of());\n@@ -118,1 +182,1 @@\n-        public HATLocalSizeOp(HATLocalSizeOp op, CodeContext copyContext) {\n+        public HAT_LS(HAT_LS op, CodeContext copyContext) {\n@@ -121,4 +185,11 @@\n-\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            return new HATLocalSizeOp(this, copyContext);\n+        public static final class HAT_LSX extends HAT_LS implements Dim.X{\n+            public HAT_LSX(HAT_LS op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_LSX() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_LSX(this, copyContext);\n+            }\n@@ -126,3 +197,23 @@\n-\n-        public static HATThreadOp of(int dimension, TypeElement resultType){\n-            return new HATLocalSizeOp(dimension, resultType);\n+        public static final class HAT_LSY extends HAT_LS implements Dim.Y{\n+            public HAT_LSY(HAT_LS op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_LSY() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_LSY(this, copyContext);\n+            }\n+        }\n+        public static final class HAT_LSZ extends HAT_LS implements Dim.Z{\n+            public HAT_LSZ(HAT_LS op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_LSZ() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_LSZ(this, copyContext);\n+            }\n@@ -132,1 +223,2 @@\n-    public static final class HATGlobalThreadIdOp extends HATThreadOp {\n+    public static abstract sealed class HAT_GI extends HATThreadOp\n+            permits HAT_GI.HAT_GIX, HAT_GI.HAT_GIY, HAT_GI.HAT_GIZ {\n@@ -134,2 +226,2 @@\n-        public HATGlobalThreadIdOp(int dimension, TypeElement resultType) {\n-            super(\"GlobalThreadId\",resultType,dimension, List.of());\n+        public HAT_GI() {\n+            super(List.of());\n@@ -138,1 +230,1 @@\n-        public HATGlobalThreadIdOp(HATGlobalThreadIdOp op, CodeContext copyContext) {\n+        public HAT_GI(HAT_GI op, CodeContext copyContext) {\n@@ -142,3 +234,11 @@\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            return new HATGlobalThreadIdOp(this, copyContext);\n+        public static final class HAT_GIX extends HAT_GI implements Dim.X{\n+            public HAT_GIX(HAT_GI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_GIX() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_GIX(this, copyContext);\n+            }\n@@ -146,3 +246,23 @@\n-\n-        public static HATGlobalThreadIdOp of(int dimension, TypeElement resultType){\n-            return new HATGlobalThreadIdOp(dimension, resultType);\n+        public static final class HAT_GIY extends HAT_GI implements Dim.Y{\n+            public HAT_GIY(HAT_GI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_GIY() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_GIY(this, copyContext);\n+            }\n+        }\n+        public static final class HAT_GIZ extends HAT_GI implements Dim.Z{\n+            public HAT_GIZ(HAT_GI op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_GIZ() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_GIZ(this, copyContext);\n+            }\n@@ -152,3 +272,3 @@\n-    public static final class HATGlobalSizeOp extends HATThreadOp {\n-        public HATGlobalSizeOp(int dimension, TypeElement resultType) {\n-            super(\"GlobalThreadSize\",resultType,dimension, List.of());\n+    public static abstract sealed class HAT_GS extends HATThreadOp permits HAT_GS.HAT_GSY, HAT_GS.HAT_GSX, HAT_GS.HAT_GSZ {\n+        public HAT_GS() {\n+            super( List.of());\n@@ -156,2 +276,1 @@\n-\n-        public HATGlobalSizeOp(HATGlobalSizeOp op, CodeContext copyContext) {\n+        public HAT_GS(HAT_GS op, CodeContext copyContext) {\n@@ -161,3 +280,11 @@\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            return new HATGlobalSizeOp(this, copyContext);\n+        public static final class HAT_GSX extends HAT_GS implements Dim.X{\n+            public HAT_GSX(HAT_GS op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_GSX() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_GSX(this, copyContext);\n+            }\n@@ -165,4 +292,23 @@\n-\n-\n-        static public HATGlobalSizeOp of(int dimension, TypeElement resultType){\n-            return new HATGlobalSizeOp(dimension,resultType);\n+        public static final class HAT_GSY extends HAT_GS implements Dim.Y{\n+            public HAT_GSY(HAT_GS op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_GSY() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_GSY(this, copyContext);\n+            }\n+        }\n+        public static final class HAT_GSZ extends HAT_GS implements Dim.Z{\n+            public HAT_GSZ(HAT_GS op, CodeContext copyContext) {\n+                super(op, copyContext);\n+            }\n+            public HAT_GSZ() {\n+                super();\n+            }\n+            @Override\n+            public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n+                return new HAT_GSZ(this, copyContext);\n+            }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATThreadOp.java","additions":222,"deletions":76,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -45,16 +45,1 @@\n-public sealed abstract class HATThreadsPhase implements HATPhase\n-permits HATThreadsPhase.BlockPhase, HATThreadsPhase.GlobalIdPhase, HATThreadsPhase.GlobalSizePhase, HATThreadsPhase.LocalIdPhase, HATThreadsPhase.LocalSizePhase {\n-    private final KernelCallGraph kernelCallGraph;\n-    @Override public KernelCallGraph kernelCallGraph(){\n-        return kernelCallGraph;\n-    }\n-\n-    public HATThreadsPhase(KernelCallGraph kernelCallGraph) {\n-        this.kernelCallGraph=kernelCallGraph;\n-    }\n-\n-    private static final Regex localSizeRegex = Regex.of(\"ls([xyz])\");\n-    private static final Regex localIdRegex = Regex.of(\"li([xyz])\");\n-    private static final Regex globalSzRegex = Regex.of(\"(gs[xyz])\");\n-    private static final Regex blockIdRegex = Regex.of(\"bi([xyz])\");\n-    private static final Regex globalIdxRegex = Regex.of(\"(gi[xyz])\");\n+public record HATThreadsPhase(KernelCallGraph kernelCallGraph) implements HATPhase {\n@@ -62,0 +47,1 @@\n+    private static final Regex allfieldNameRegex = Regex.of(\"[glb][si]([xyz])\");\n@@ -65,10 +51,4 @@\n-        Regex fieldNameRegex  = switch (this){\n-            case BlockPhase _->blockIdRegex;\n-            case GlobalIdPhase _->globalIdxRegex;\n-            case GlobalSizePhase _->globalSzRegex;\n-            case LocalIdPhase _-> localIdRegex;\n-            case LocalSizePhase _-> localSizeRegex;\n-        };\n-        Set<CodeElement<?,?>> removeMe= new HashSet<>();\n-        return Trxfmr.of(this,funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n-                    if (fieldAccess(lookup(),c.op()) instanceof FieldAccess fieldAccess\n+        Set<CodeElement<?, ?>> removeMe = new HashSet<>();\n+        return Trxfmr.of(this, funcOp)\n+                .transform(ce -> ce instanceof JavaOp.FieldAccessOp, c -> { \/\/ We care about field accesses\n+                    if (fieldAccess(lookup(), c.op()) instanceof FieldAccess fieldAccess \/\/ get a FieldAccessHelper\n@@ -77,1 +57,1 @@\n-                            && fieldAccess.named(fieldNameRegex)\n+                            && fieldAccess.named(allfieldNameRegex)\n@@ -79,10 +59,3 @@\n-                                    removeMe.add(varAccess.op()); \/\/ We will need to remove this\n-                                    int dimIdx = fieldAccess.name().charAt(2) - 'x';\n-                                    c.replace(switch (HATThreadsPhase.this) {\n-                                        case BlockPhase _ -> HATThreadOp.HATBlockThreadIdOp.of(dimIdx, fieldAccess.resultType());\n-                                        case GlobalIdPhase _ -> HATThreadOp.HATGlobalThreadIdOp.of(dimIdx, fieldAccess.resultType());\n-                                        case GlobalSizePhase _ -> HATThreadOp.HATGlobalSizeOp.of(dimIdx, fieldAccess.resultType());\n-                                        case LocalIdPhase _ -> HATThreadOp.HATLocalThreadIdOp.of(dimIdx, fieldAccess.resultType());\n-                                        case LocalSizePhase _ -> HATThreadOp.HATLocalSizeOp.of(dimIdx, fieldAccess.resultType());\n-                                    });\n-                                }\n+                        removeMe.add(varAccess.op());\/\/ We will remove in the next transform (see removeme)\n+                        c.replace(HATThreadOp.create(fieldAccess.name()));\n+                    }\n@@ -94,30 +67,0 @@\n-\n-    public static final class BlockPhase extends HATThreadsPhase {\n-        public BlockPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-    }\n-\n-    public static final class GlobalIdPhase extends HATThreadsPhase {\n-        public GlobalIdPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-    }\n-\n-    public static final class GlobalSizePhase extends HATThreadsPhase {\n-        public GlobalSizePhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-    }\n-\n-    public static final class LocalIdPhase extends HATThreadsPhase {\n-        public LocalIdPhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-    }\n-\n-    public static final class LocalSizePhase extends HATThreadsPhase {\n-        public LocalSizePhase(KernelCallGraph kernelCallGraph) {\n-            super(kernelCallGraph);\n-        }\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":10,"deletions":67,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -60,5 +60,16 @@\n-        hatPhases.add(new HATThreadsPhase.GlobalIdPhase(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.GlobalSizePhase(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LocalIdPhase(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.LocalSizePhase(kernelCallGraph));\n-        hatPhases.add(new HATThreadsPhase.BlockPhase(kernelCallGraph));\n+      \/*  hatPhases.add(new HATThreadsPhase.GI_Phase.HAT_GIX(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.GI_Phase.HAT_GIY(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.GI_Phase.HAT_GIZ(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.GS_Phase.HAT_GSX(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.GS_Phase.HAT_GSY(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.GS_Phase.HAT_GSZ(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LI_Phase.HAT_LIX(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LI_Phase.HAT_LIY(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LI_Phase.HAT_LIZ(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LS_Phase.HAT_LSX(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LS_Phase.HAT_LSY(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.LS_Phase.HAT_LSZ(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.BI_Phase.HAT_BIY(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.BI_Phase.HAT_BIZ(kernelCallGraph));\n+        hatPhases.add(new HATThreadsPhase.BI_Phase.HAT_BIX(kernelCallGraph)); *\/\n+        hatPhases.add(new HATThreadsPhase(kernelCallGraph));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATTier.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            if (kc.gix < kc.gsy) {\n+            if (kc.giy < kc.gsy) {\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.tools;\n+\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.NDRange;\n+import hat.buffer.S32Array;\n+import hat.buffer.S32Array2D;\n+import optkl.ifacemapper.MappableIface;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import optkl.textmodel.ui.FuncOpViewer;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+\n+public class TestFuncOpViewer {\n+    static class Compute {\n+        @Reflect\n+        public static void mandel(@MappableIface.RO KernelContext kc, @MappableIface.RW S32Array2D s32Array2D, @MappableIface.RO S32Array pallette, float offsetx, float offsety, float scale) {\n+            if (kc.gix < kc.gsx) {\n+                float width = s32Array2D.width();\n+                float height = s32Array2D.height();\n+                float x = ((kc.gix % s32Array2D.width()) * scale - (scale \/ 2f * width)) \/ width + offsetx;\n+                float y = ((kc.gix \/ s32Array2D.width()) * scale - (scale \/ 2f * height)) \/ height + offsety;\n+                float zx = x;\n+                float zy = y;\n+                float new_zx;\n+                int colorIdx = 0;\n+                while ((colorIdx < pallette.length()) && (((zx * zx) + (zy * zy)) < 4f)) {\n+                    new_zx = ((zx * zx) - (zy * zy)) + x;\n+                    zy = (2f * zx * zy) + y;\n+                    zx = new_zx;\n+                    colorIdx++;\n+                }\n+                int color = colorIdx < pallette.length() ? pallette.array(colorIdx) : 0;\n+                s32Array2D.array(kc.gix, color);\n+            }\n+        }\n+\n+\n+        @Reflect\n+        static public void compute(final ComputeContext computeContext, S32Array pallete, S32Array2D s32Array2D, float x, float y, float scale) {\n+\n+            computeContext.dispatchKernel(\n+                    NDRange.of1D(s32Array2D.width() * s32Array2D.height()),         \/\/0..S32Array2D.size()\n+                    kc -> mandel(kc, s32Array2D, pallete, x, y, scale));\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws NoSuchMethodException, IOException {\n+        String methodName = \"mandel\";\n+        Method method = Compute.class.getDeclaredMethod(methodName,\n+                KernelContext.class, S32Array2D.class, S32Array.class, float.class, float.class, float.class);\n+        CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n+        FuncOpViewer.launch(javaFunc);\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/TestFuncOpViewer.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}