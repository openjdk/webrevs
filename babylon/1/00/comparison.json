{"files":[{"patch":"@@ -0,0 +1,58 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# copy selected cr packages into jdk.compiler\n+\n+base=java\/lang\/reflect\/code\n+packages=\"\n+  $base \\\n+  $base\/descriptor \\\n+  $base\/descriptor\/impl \\\n+  $base\/impl \\\n+  $base\/op \\\n+  \"\n+\n+removeclasses=\"\"\n+\n+java_base_dir=$1\n+jdk_compiler_dir=$2\n+\n+for p in $packages; do\n+  mkdir -p $jdk_compiler_dir\/jdk\/internal\/$p\n+  cp -r $java_base_dir\/$p\/*.java $jdk_compiler_dir\/jdk\/internal\/$p\/.\n+done\n+\n+for f in $removeclasses; do\n+  rm $jdk_compiler_dir\/jdk\/internal\/$f\n+done\n+\n+find $jdk_compiler_dir\/jdk\/internal\/$base -name \"*.java\" -print \\\n+  | xargs sed -i'.bck' \\\n+  -e 's\/java\\.lang\\.reflect\\.code\/jdk\\.internal\\.java\\.lang\\.reflect\\.code\/g' \\\n+  -e 's\/^\\\/\\*__\\(.*\\)__\\*\\\/.*$\/\\1\/'\n+\n+find $jdk_compiler_dir\/jdk\/internal\/$base -name \"*.bck\" -exec rm {} \\;\n+\n","filename":"cr-util\/copy-to-compiler.sh","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+    jdk.code.tools \\\n","filename":"make\/conf\/module-loader-map.conf","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  ~ Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+  ~ Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,9 @@\n-    <target name=\"generate-sources\"  depends=\"-prepare-build,-def-pparse,-def-pcompile\">\n+    <target name=\"copy-cr-sources\">\n+        <exec executable=\"\/bin\/bash\">\n+            <arg value=\"cr-util\/copy-to-compiler.sh\"\/>\n+            <arg value=\"src\/java.base\/share\/classes\"\/>\n+            <arg value=\"${build.gensrc}\/jdk.compiler\"\/>\n+        <\/exec>\n+    <\/target>\n+\n+    <target name=\"generate-sources\"  depends=\"copy-cr-sources,-prepare-build,-def-pparse,-def-pcompile\">\n","filename":"make\/langtools\/build.xml","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+DISABLED_WARNINGS_java += preview\n@@ -28,3 +29,4 @@\n-DOCLINT += -Xdoclint:all\/protected \\\n-    '-Xdoclint\/package:java.*,javax.*'\n-JAVAC_FLAGS += -XDstringConcat=inline\n+# DOCLINT += -Xdoclint:all\/protected \\\n+#     '-Xdoclint\/package:java.*,javax.*'\n+JAVAC_FLAGS += -XDstringConcat=inline \\\n+    --enable-preview\n","filename":"make\/modules\/java.base\/Java.gmk","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,16 @@\n+\n+################################################################################\n+#\n+# Copy stubs of code reflection API in langtools\n+\n+GENSTUBS_SCRIPT := $(TOPDIR)\/cr-util\/copy-to-compiler.sh\n+\n+GENSTUBS_CMD := $(BASH) $(GENSTUBS_SCRIPT) $(TOPDIR)\/src\/java.base\/share\/classes $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\n+\n+$(eval $(call SetupExecute, GENSTUBS, \\\n+    WARN := Generating compiler stubs for code reflection, \\\n+    OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE), \\\n+    COMMAND := $(GENSTUBS_CMD), \\\n+))\n+\n+TARGETS += $(GENSTUBS)\n","filename":"make\/modules\/jdk.compiler\/Gensrc.gmk","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,7 @@\n+    final MethodHandle quotableOpField;       \/\/ A getter method handle that is used to retrieve the\n+                                              \/\/ string representation of the quotable lambda's associated\n+                                              \/\/ intermediate representation (can be null).\n+    final MethodHandleInfo quotableOpFieldInfo;  \/\/ Info about the quotable getter method handle (can be null).\n+\n+    final MethodType quotableOpType;          \/\/ The type of the quotable lambda's associated\n+                                              \/\/ intermediate representation (can be null).\n@@ -108,0 +115,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -122,1 +132,2 @@\n-                                        MethodType[] altMethods)\n+                                        MethodType[] altMethods,\n+                                        MethodHandle reflectiveField)\n@@ -183,0 +194,13 @@\n+        this.quotableOpField = reflectiveField;\n+        if (reflectiveField != null) {\n+            \/\/ infer the method type associated with the intermediate representation of the\n+            \/\/ quotable lambda. Since {@code factoryType} contains all the captured args\n+            \/\/ we need to subtract the captured args that are required to invoke the lambda's\n+            \/\/ bytecode. The type of {@code implementation} is useful here, as it corresponds to\n+            \/\/ the signature of the emitted javac lambda implementation. From there, we need to\n+            \/\/ drop all the dynamic arguments, which are obtained from {@code interfaceMethodType}.\n+            this.quotableOpType = factoryType.dropParameterTypes(0,\n+                    implementation.type().parameterCount() - interfaceMethodType.parameterCount());\n+        } else {\n+            quotableOpType = null;\n+        }\n@@ -209,0 +233,14 @@\n+\n+        if (reflectiveField != null) {\n+            try {\n+                quotableOpFieldInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+            } catch (IllegalArgumentException e) {\n+                throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+            }\n+            if (quotableOpFieldInfo.getReferenceKind() != REF_getField &&\n+                    quotableOpFieldInfo.getReferenceKind() != REF_getStatic) {\n+                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpFieldInfo));\n+            }\n+        } else {\n+            quotableOpFieldInfo = null;\n+        }\n@@ -228,1 +266,1 @@\n-        final int capturedArity = factoryType.parameterCount();\n+        final int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -319,0 +357,4 @@\n+    int reflectiveCaptureCount() {\n+        return quotableOpType == null ? 0 : quotableOpType.parameterCount();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,5 @@\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -38,2 +43,1 @@\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n+import java.util.*;\n@@ -65,0 +69,1 @@\n+    private static final String DESCR_METHOD_QUOTED = \"()Ljava\/lang\/reflect\/code\/Quoted;\";\n@@ -69,0 +74,1 @@\n+    private static final String NAME_METHOD_QUOTED = \"quoted\";\n@@ -90,0 +96,11 @@\n+    \/\/ condy to load reflective field from class data\n+    private static final ConstantDynamic reflectiveFieldCondy;\n+\n+    private static final ConstantDynamic makeQuotedMethodCondy;\n+\n+    private static final MethodHandle HANDLE_MAKE_QUOTED;\n+\n+    private static final String quotedInstanceFieldName = \"quoted\";\n+    private static final String quotedInstanceFieldDesc = Quoted.class.descriptorString();\n+\n+\n@@ -101,4 +118,14 @@\n-        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n-        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n-                                         classDataMType.descriptorString(), false);\n-        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm);\n+        MethodType classDataAtMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class, int.class);\n+        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classDataAt\",\n+                                         classDataAtMType.descriptorString(), false);\n+        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 0);\n+        reflectiveFieldCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 1);\n+        makeQuotedMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 2);\n+\n+        try {\n+            HANDLE_MAKE_QUOTED = MethodHandles.lookup().findStatic(\n+                    InnerClassLambdaMetafactory.class, \"makeQuoted\",\n+                    MethodType.methodType(Quoted.class, String.class, Object[].class));\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n@@ -152,0 +179,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -166,1 +196,2 @@\n-                                       MethodType[] altMethods)\n+                                       MethodType[] altMethods,\n+                                       MethodHandle reflectiveField)\n@@ -170,1 +201,1 @@\n-              isSerializable, altInterfaces, altMethods);\n+              isSerializable, altInterfaces, altMethods, reflectiveField);\n@@ -185,1 +216,1 @@\n-        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n@@ -330,0 +361,8 @@\n+        \/\/ if quotable, generate the field that will hold the value of quoted\n+        if (quotableOpField != null) {\n+            cw.visitField(ACC_PRIVATE + ACC_FINAL,\n+                          quotedInstanceFieldName,\n+                          quotedInstanceFieldDesc,\n+                          null, null);\n+        }\n+\n@@ -355,0 +394,4 @@\n+        if (quotableOpField != null) {\n+            generateQuotableMethod();\n+        }\n+\n@@ -362,1 +405,8 @@\n-            var classdata = useImplMethodHandle? implementation : null;\n+            List<?> classdata;\n+            if (useImplMethodHandle || quotableOpField != null) {\n+                classdata = quotableOpField == null ?\n+                        List.of(implementation) :\n+                        List.of(implementation, quotableOpField, HANDLE_MAKE_QUOTED);\n+            } else {\n+                classdata = null;\n+            }\n@@ -416,0 +466,5 @@\n+\n+        if (quotableOpField != null) {\n+            generateQuotedFieldInitializer(ctor);\n+        }\n+\n@@ -422,0 +477,41 @@\n+    private void generateQuotedFieldInitializer(MethodVisitor ctor) {\n+        ctor.visitCode();\n+\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        ctor.visitVarInsn(ALOAD, 0);\n+\n+        ctor.visitLdcInsn(makeQuotedMethodCondy);\n+\n+        \/\/ load op string from field\n+\n+        ctor.visitLdcInsn(reflectiveFieldCondy);\n+        MethodType mtype = quotableOpFieldInfo.getMethodType();\n+        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+            mtype = mtype.insertParameterTypes(0, implClass);\n+        }\n+        ctor.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n+                \"invokeExact\", mtype.descriptorString(), false);\n+\n+        \/\/ load captured args in array\n+\n+        ctor.visitLdcInsn(quotableOpType.parameterCount());\n+        ctor.visitTypeInsn(ANEWARRAY, JAVA_LANG_OBJECT);\n+        int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n+        \/\/ initialize quoted captures\n+        TypeConvertingMethodAdapter tcmv = new TypeConvertingMethodAdapter(ctor);\n+        for (int i = 0; i < reflectiveCaptureCount(); i++) {\n+            ctor.visitInsn(DUP);\n+            ctor.visitIntInsn(BIPUSH, i); \/\/ is it possible that i can be greater than Byte.MAX_VALUE ?\n+            ctor.visitVarInsn(ALOAD, 0);\n+            ctor.visitFieldInsn(GETFIELD, lambdaClassName, argNames[capturedArity + i], argDescs[capturedArity + i]);\n+            tcmv.boxIfTypePrimitive(Type.getType(argDescs[capturedArity + i]));\n+            ctor.visitInsn(AASTORE);\n+        }\n+\n+        \/\/ now create a Quoted from String and captured args Object[]\n+\n+        ctor.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n+                \"invokeExact\", HANDLE_MAKE_QUOTED.type().toMethodDescriptorString(), false);\n+        ctor.visitFieldInsn(PUTFIELD, lambdaClassName, quotedInstanceFieldName, quotedInstanceFieldDesc);\n+    }\n+\n@@ -462,0 +558,17 @@\n+    \/**\n+     * Generate a writeReplace method that supports serialization\n+     *\/\n+    private void generateQuotableMethod() {\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL,\n+                                          NAME_METHOD_QUOTED, DESCR_METHOD_QUOTED,\n+                                          null, null);\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, lambdaClassName, quotedInstanceFieldName, quotedInstanceFieldDesc);\n+        mv.visitInsn(ARETURN);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n@@ -548,1 +661,1 @@\n-            int captureArity = factoryType.parameterCount();\n+            int captureArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -607,0 +720,4 @@\n+    private static Quoted makeQuoted(String opText, Object[] args) {\n+        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n+        return (Quoted)Interpreter.invoke(Lookup.IMPL_LOOKUP, op, args);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":129,"deletions":12,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.reflect.code.Quotable;\n+\n@@ -254,0 +256,4 @@\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n+     * must be a {@code Quotable} object, inspectable using code reflection. *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -339,1 +345,2 @@\n-                                             EMPTY_MT_ARRAY);\n+                                             EMPTY_MT_ARRAY,\n+                                 null);\n@@ -385,0 +392,2 @@\n+     *                          MethodType reflectType        \/\/ IF flags has QUOTABLE set\n+     *                          MethodHandle reflectField     \/\/ IF flags has QUOTABLE set\n@@ -408,0 +417,4 @@\n+     *     <li>{@code quotableField} is a\n+     *     {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter} method handle\n+     *     that is used to retrieve the string representation of the quotable lambda's associated\n+     *     intermediate representation.<\/li>\n@@ -422,0 +435,3 @@\n+     * <p>When FLAG_QUOTABLE is set in {@code flags}, the function objects\n+     * will implement {@code Quotable}.\n+     *\n@@ -490,0 +506,1 @@\n+        MethodHandle quotableField = null;\n@@ -510,0 +527,5 @@\n+        if ((flags & FLAG_QUOTABLE) != 0) {\n+            quotableField = extractArg(args, argIndex++, MethodHandle.class);\n+            altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+            altInterfaces[altInterfaces.length-1] = Quotable.class;\n+        }\n@@ -534,1 +556,2 @@\n-                                                  altMethods);\n+                                                  altMethods,\n+                                                  quotableField);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,4 @@\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.parser.OpParser;\n@@ -49,0 +53,2 @@\n+import java.util.List;\n+import java.util.Optional;\n@@ -51,0 +57,2 @@\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n@@ -98,0 +106,1 @@\n+    private volatile Optional<FuncOp>     codeModel;\n@@ -248,0 +257,52 @@\n+    \/**\n+     * Returns the code model of the method body, if present.\n+     * @return the code model of the method body.\n+     * @since 99\n+     *\/\n+    \/\/ @@@ Make caller sensitive with the same access control as invoke\n+    \/\/ and throwing IllegalAccessException\n+\/\/    @CallerSensitive\n+    public Optional<FuncOp> getCodeModel() {\n+        Optional<FuncOp> localRef = codeModel;\n+        if (localRef == null) {\n+            synchronized (this) {\n+                localRef = codeModel;\n+                if (localRef == null) {\n+                    Optional<FuncOp> op = createCodeModel();\n+                    codeModel = localRef = op;\n+                }\n+            }\n+        }\n+        return localRef;\n+    }\n+\n+    private Optional<FuncOp> createCodeModel() {\n+        Class<?> dc = getDeclaringClass();\n+        String fieldName = getName() + \"$\" + \"op\";\n+        Field f;\n+        try {\n+            f = dc.getDeclaredField(fieldName);\n+        } catch (NoSuchFieldException e) {\n+            return Optional.empty();\n+        }\n+\n+        String modelText;\n+        try {\n+            \/\/ @@@ Use method handle with full power mode\n+            f.setAccessible(true);\n+            modelText = (String) f.get(null);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        FuncOp op;\n+        try {\n+            List<Op> ops = OpParser.fromString(ExtendedOps.FACTORY, modelText);\n+            op = (FuncOp) ops.get(0);\n+        } catch (RuntimeException e) {\n+            \/\/ @@@ Error or Exception?\n+            throw e;\n+        }\n+        return Optional.of(op);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,907 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+\n+\/**\n+ * A (basic) block containing an ordered sequence of operations, where the last operation is\n+ * a {@link Op.Terminating terminating} operation.\n+ * <p>\n+ * The terminating operation, according to its specification, may branch to other blocks contained in the\n+ * same parent body, by way of its {@link Op#successors() successors}, or exit the parent body and optionally\n+ * yield a result.\n+ * <p>\n+ * Blocks may declare one or more block parameters.\n+ *\/\n+public final class Block implements CodeElement<Block, Op> {\n+\n+    \/**\n+     * A value that is a block parameter\n+     *\/\n+    public static final class Parameter extends Value {\n+        Parameter(Block block, TypeDesc type) {\n+            super(block, type);\n+        }\n+\n+        @Override\n+        public Set<Value> dependsOn() {\n+            return Set.of();\n+        }\n+    }\n+\n+    \/**\n+     * A block reference that refers to a block with arguments.\n+     * <p>\n+     * A terminating operation may refer, via a block reference, to one or more blocks as its successors.\n+     * When control is passed from a block to a successor block the values of the block reference's arguments are\n+     * assigned, in order, to the successor block's parameters.\n+     *\/\n+    public static final class Reference {\n+        final Block target;\n+        final List<Value> arguments;\n+\n+        \/**\n+         * Constructs a block reference for a given target block and arguments.\n+         *\n+         * @param target    the target block.\n+         * @param arguments the target block arguments, a copy will be made as needed.\n+         *\/\n+        Reference(Block target, List<? extends Value> arguments) {\n+            this.target = target;\n+            this.arguments = List.copyOf(arguments);\n+        }\n+\n+        \/**\n+         * {@return the target block.}\n+         * @throws IllegalStateException if the target block is partially built\n+         *\/\n+        public Block targetBlock() {\n+            if (!isBound()) {\n+                throw new IllegalStateException(\"Target block is partially built\");\n+            }\n+\n+            return target;\n+        }\n+\n+        \/**\n+         * {@return the block arguments.}\n+         *\/\n+        public List<Value> arguments() {\n+            return arguments;\n+        }\n+\n+        boolean isBound() {\n+            return target.isBound();\n+        }\n+    }\n+\n+    final Body parentBody;\n+\n+    final List<Parameter> parameters;\n+\n+    final List<Op> ops;\n+\n+    \/\/ @@@ In topological order\n+    \/\/ @@@ Create lazily\n+    \/\/     Can the representation be more efficient e.g. an array?\n+    final Set<Block> predecessors;\n+\n+    \/\/ Reverse postorder index\n+    \/\/ Set when block's body has sorted its blocks and therefore set when built\n+    \/\/ Block is inoperable when < 0 i.e., when partially built\n+    int index = -1;\n+\n+    Block(Body parentBody) {\n+        this(parentBody, List.of());\n+    }\n+\n+    Block(Body parentBody, List<TypeDesc> parameterTypes) {\n+        this.parentBody = parentBody;\n+        this.parameters = new ArrayList<>();\n+        for (TypeDesc param : parameterTypes) {\n+            parameters.add(new Parameter(this, param));\n+        }\n+        this.ops = new ArrayList<>();\n+        this.predecessors = new LinkedHashSet<>();\n+    }\n+\n+    \/**\n+     * Returns this block's parent body.\n+     *\n+     * @return this block's parent body.\n+     *\/\n+    public Body parentBody() {\n+        return parentBody;\n+    }\n+\n+    \/**\n+     * Returns this block's index within the parent bodies list of blocks.\n+     *\n+     * @return the block index.\n+     *\/\n+    public int index() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Returns the block parameters.\n+     *\n+     * @return the block parameters, as an unmodifiable list.\n+     *\/\n+    public List<Parameter> parameters() {\n+        return Collections.unmodifiableList(parameters);\n+    }\n+\n+    \/**\n+     * Returns the block parameter types.\n+     *\n+     * @return the block parameter types, as am unmodifiable list.\n+     *\/\n+    public List<TypeDesc> parameterTypes() {\n+        return parameters.stream().map(Value::type).toList();\n+    }\n+\n+    \/**\n+     * Returns the sequence of operations contained in this block.\n+     *\n+     * @return returns the sequence operations, as an unmodifiable list.\n+     *\/\n+    public List<Op> ops() {\n+        return Collections.unmodifiableList(ops);\n+    }\n+\n+    \/**\n+     * Finds the operation in this block that is the ancestor of the given operation.\n+     *\n+     * @param op the given operation.\n+     * @return the operation in this block that is the ancestor of the given operation,\n+     * otherwise {@code null}\n+     *\/\n+    public Op findAncestorOpInBlock(Op op) {\n+        Objects.requireNonNull(op);\n+\n+        while (op != null && op.parentBlock() != this) {\n+            Body encBody = op.ancestorBody();\n+            if (encBody == null) {\n+                return null;\n+            }\n+\n+            op = encBody.parentOp();\n+        }\n+\n+        return op;\n+    }\n+\n+    @Override\n+    public List<Op> children() {\n+        return ops();\n+    }\n+\n+    \/**\n+     * Returns the first operation in this block.\n+     *\n+     * @return the first operation in this block.\n+     *\/\n+    public Op firstOp() {\n+        return ops.getFirst();\n+    }\n+\n+    \/**\n+     * Returns the last, terminating, operation in this block.\n+     * <p>\n+     * The terminating operation implements {@link Op.Terminating}.\n+     *\n+     * @return the last, terminating, operation in this block.\n+     *\/\n+    public Op terminatingOp() {\n+        Op lop = ops.getLast();\n+        assert lop instanceof Op.Terminating;\n+        return lop;\n+    }\n+\n+    \/**\n+     * Returns the next operation after the given operation, otherwise {@code null}\n+     * if this operation is the last operation.\n+     *\n+     * @param op the operation\n+     * @return the next operation after the given operation.\n+     *\/\n+    public Op nextOp(Op op) {\n+        int i = ops.indexOf(op);\n+        if (i == -1) {\n+            throw new IllegalArgumentException();\n+        }\n+        return i < ops().size() - 1 ? ops.get(i + 1) : null;\n+    }\n+\n+    \/**\n+     * Returns the list of predecessors, namely each block in the parent body that refers\n+     * to this block as a successor.\n+     *\n+     * @return the set of predecessors, as an unmodifiable list.\n+     * @apiNote A block may refer to itself as a successor and therefore also be its predecessor.\n+     *\/\n+    public Set<Block> predecessors() {\n+        return Collections.unmodifiableSet(predecessors);\n+    }\n+\n+    \/**\n+     * Returns the list of successors referring to other blocks in the parent body.\n+     * <p>\n+     * The successors are declared by the terminating operation contained in this block.\n+     *\n+     * @return the list of successors, as an unmodifiable list.\n+     *\/\n+    public List<Reference> successors() {\n+        Op lopr = ops.get(ops.size() - 1);\n+        return lopr.successors();\n+    }\n+\n+    \/**\n+     * Returns true if this block is an entry block.\n+     *\n+     * @return true if this block is an entry block.\n+     *\/\n+    public boolean isEntryBlock() {\n+        return parentBody.entryBlock() == this;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this block is\n+     * <a href=\"https:\/\/en.wikipedia.org\/wiki\/Dominator_(graph_theory)\">dominated by<\/a> the given block {@code dom}.\n+     * This block is dominated by {@code dom}, if every path from the root entry block to this block passes through\n+     * {@code dom}.\n+     * <p>\n+     * If this block, {@code b} say, and {@code dom} are not in the same parent body,\n+     * then {@code b} becomes the nearest ancestor block, result of {@code b.parentBody().parentOp().parentBlock()},\n+     * and so on until either:\n+     * {@code b} is {@code null}, therefore {@code b} is <b>not<\/b> dominated by {@code dom} and this method\n+     * returns {@code false}; or\n+     * {@code b.parentBody() == dom.parentBody()}, therefore this method returns the result\n+     * of {@code b.isDominatedBy(dom)}.\n+     * <p>\n+     * If this method returns {@code true} then {@code dom.isDominatedBy(this)}\n+     * will return {@code false}. However, if this method returns {@code false} then it\n+     * does not imply {@code dom.isDominatedBy(this)} returns {@code true}, as neither\n+     * block may dominate the other.\n+     *\n+     * @param dom the dominating block\n+     * @return {@code true} if this block is dominated by the given block.\n+     *\/\n+    \/\/ @@@ Should this be reversed and named dominates(Block b)\n+    public boolean isDominatedBy(Block dom) {\n+        Block b = findBlockForDomBody(this, dom.parentBody());\n+        if (b == null) {\n+            return false;\n+        }\n+\n+        \/\/ A block non-strictly dominates itself\n+        if (b == dom) {\n+            return true;\n+        }\n+\n+        \/\/ The entry block in b's body dominates all other blocks in the body\n+        Block entry = b.parentBody().entryBlock();\n+        if (dom == entry) {\n+            return true;\n+        }\n+\n+        \/\/ Traverse the immediate dominators until dom is reached or the entry block\n+        Map<Block, Block> idoms = b.parentBody().immediateDominators();\n+        Block idom = idoms.get(b);\n+        while (idom != entry) {\n+            if (idom == dom) {\n+                return true;\n+            }\n+\n+            idom = idoms.get(idom);\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the immediate dominator of this block, otherwise {@code null} if this block is the entry block.\n+     * Both this block and the immediate dominator (if defined) have the same parent body.\n+     * <p>\n+     * The immediate dominator is the unique block that strictly dominates this block, but does not strictly dominate\n+     * any other block that strictly dominates this block.\n+     *\n+     * @return the immediate dominator of this block, otherwise {@code null} if this block is the entry block.\n+     *\/\n+    public Block immediateDominator() {\n+        if (this == parentBody().entryBlock()) {\n+            return null;\n+        }\n+\n+        Map<Block, Block> idoms = parentBody().immediateDominators();\n+        return idoms.get(this);\n+    }\n+\n+    \/\/ @@@ isPostDominatedBy and immediatePostDominator\n+\n+    private static Block findBlockForDomBody(Block b, final Body domr) {\n+        Body rb = b.parentBody();\n+        while (domr != rb) {\n+            \/\/ @@@ What if body is isolated\n+\n+            b = rb.parentOp().parentBlock();\n+            \/\/ null when op is top-level (and its body is isolated), or not yet assigned to block\n+            if (b == null) {\n+                return null;\n+            }\n+            rb = b.parentBody();\n+        }\n+        return b;\n+    }\n+\n+    \/**\n+     * A builder of a block.\n+     * <p>\n+     * When the parent body builder is built this block builder is also built. If a built builder\n+     * is operated on to append a block parameter, append an operation, or add a block, then\n+     * an {@code IllegalStateException} is thrown.\n+     *\/\n+    public final class Builder implements Function<Op, Op.Result> {\n+        final Body.Builder parentBody;\n+        final CopyContext cc;\n+        final OpTransformer ot;\n+\n+        Builder(Body.Builder parentBody, CopyContext cc, OpTransformer ot) {\n+            this.parentBody = parentBody;\n+            this.cc = cc;\n+            this.ot = ot;\n+        }\n+\n+        void check() {\n+            parentBody.check();\n+        }\n+\n+        Block target() {\n+            return Block.this;\n+        }\n+\n+        \/**\n+         * {@return the block builder's operation transformer}\n+         *\/\n+        public OpTransformer transformer() {\n+            return ot;\n+        }\n+\n+        \/**\n+         * {@return the block builder's context}\n+         *\/\n+        public CopyContext context() {\n+            return cc;\n+        }\n+\n+        \/**\n+         * {@return the parent body builder}\n+         *\/\n+        public Body.Builder parentBody() {\n+            return parentBody;\n+        }\n+\n+        \/**\n+         * Returns the entry block builder for parent body.\n+         *\n+         * <p>The returned block is rebound if necessary to this block builder's\n+         * context and transformer.\n+         *\n+         * @return the entry block builder for parent body builder\n+         *\/\n+        public Block.Builder entryBlock() {\n+            return parentBody.entryBlock.rebind(cc, ot);\n+        }\n+\n+        \/**\n+         * {@return true if this block builder is a builder of the entry block}\n+         *\/\n+        public boolean isEntryBlock() {\n+            return Block.this == parentBody.target().entryBlock();\n+        }\n+\n+        \/**\n+         * Rebinds this block builder with the given context and operation transformer.\n+         *\n+         * <p>Either this block builder and the returned block builder may be operated on to build\n+         * the same block.\n+         * Both are equal to each other, and both are closed when the parent body builder is closed.\n+         *\n+         * @param cc the context\n+         * @param ot the operation transformer\n+         * @return the rebound block builder\n+         *\/\n+        public Block.Builder rebind(CopyContext cc, OpTransformer ot) {\n+            return this.cc == cc && this.ot == ot\n+                    ? this\n+                    : this.target().new Builder(parentBody(), cc, ot);\n+        }\n+\n+        \/**\n+         * Adds a new block to the parent body.\n+         *\n+         * @param params the block's parameter types\n+         * @return the new block builder\n+         *\/\n+        public Block.Builder block(TypeDesc... params) {\n+            return block(List.of(params));\n+        }\n+\n+        \/**\n+         * Adds a new block to the parent body.\n+         *\n+         * @param params the block's parameter types\n+         * @return the new block builder\n+         *\/\n+        public Block.Builder block(List<TypeDesc> params) {\n+            return parentBody.block(params, cc, ot);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable list of the block's parameters.\n+         *\n+         * @return the unmodifiable list of the block's parameters\n+         *\/\n+        public List<Parameter> parameters() {\n+            return Collections.unmodifiableList(parameters);\n+        }\n+\n+        \/**\n+         * Appends a block parameter to the block's parameters.\n+         *\n+         * @param p the parameter type\n+         * @return the appended block parameter\n+         *\/\n+        public Parameter parameter(TypeDesc p) {\n+            check();\n+            return appendBlockParameter(p);\n+        }\n+\n+        \/**\n+         * Creates a reference to this block that can be used as a successor of a terminating operation.\n+         *\n+         * @param args the block arguments\n+         * @return the reference to this block\n+         * @throws IllegalStateException if this block builder is associated with the entry block.\n+         *\/\n+        public Reference successor(Value... args) {\n+            return successor(List.of(args));\n+        }\n+\n+        \/**\n+         * Creates a reference to this block that can be used as a successor of a terminating operation.\n+         *\n+         * @param args the block arguments\n+         * @return the reference to this block\n+         * @throws IllegalStateException if this block builder is associated with the entry block.\n+         *\/\n+        public Reference successor(List<? extends Value> args) {\n+            if (isEntryBlock()) {\n+                throw new IllegalStateException(\"Entry block cannot be referred to as a successor\");\n+            }\n+\n+            return new Reference(Block.this, List.copyOf(args));\n+        }\n+\n+        \/**\n+         * An inline consumer that inserts a return operation with a value, if non-null.\n+         *\/\n+        public static final BiConsumer<Block.Builder, Value> INLINE_RETURN = (block, value) -> {\n+            block.op(value != null ? _return(value) : _return());\n+        };\n+\n+        \/**\n+         * Inlines the invokable operation into this block and returns the block builder from which to\n+         * continue building.\n+         * <p>\n+         * This method {@link #transformBody(Body, List, CopyContext, OpTransformer) transforms} the body of the\n+         * invokable operation with the given arguments, a new context, and an operation transformer that\n+         * replaces return operations by applying the given consumer to a block builder and a return value.\n+         * <p>\n+         * The operation transformer copies all operations except return operations whose nearest invokable operation\n+         * ancestor is the given the invokable operation. When such a return operation is encountered, then on\n+         * first encounter of its grandparent body a return block builder is computed and used for this return operation\n+         * and encounters of subsequent return operations with the same grandparent body.\n+         * <p>\n+         * If the grandparent body has only one block then operation transformer's block builder is the return\n+         * block builder. Otherwise, if the grandparent body has one or more blocks then the return block builder is\n+         * created from the operation transformer's block builder. The created return block builder will have a block\n+         * parameter whose type corresponds to the return type, or will have no parameter for void return.\n+         * The computation finishes by applying the return block builder and a return value to the inlining consumer.\n+         * If the grandparent body has only one block then the return value is the value mapped from the return\n+         * operation's operand, or is null for void return. Otherwise, if the grandparent body has one or more blocks\n+         * then the value is the block parameter of the created return block builder, or is null for void return.\n+         * <p>\n+         * For every encounter of a return operation the associated return block builder is compared against the\n+         * operation transformer's block builder. If they are not equal then a branch operation is added to the\n+         * operation transformer's block builder whose successor is the return block builder with a block argument\n+         * that is the value mapped from the return operation's operand, or with no block argument for void return.\n+         * @apiNote\n+         * It is easier to inline an invokable op if its body is in lowered form (there are no operations in the blocks\n+         * of the body that are lowerable). This ensures a single exit point can be created (paired with the single\n+         * entry point). If there are one or more nested return operations, then there is unlikely to be a single exit.\n+         * Transforming the model to create a single exit point while preserving nested structure is in general\n+         * non-trivial and outside the scope of this method. In such cases the invokable operation can be transformed\n+         * with a lowering transformation after which it can then be inlined.\n+         *\n+         * @param invokableOp the invokable operation\n+         * @param args the arguments to map to the invokable operation's parameters\n+         * @param inlineConsumer the consumer applied to process the return from the invokable operation.\n+         *                       This is called once for each grandparent body of a return operation, with a block to\n+         *                       build replacement operations and the return value, or null for void return.\n+         * @return the block builder to continue building from\n+         * @param <O> The invokable type\n+         *\/\n+        public <O extends Op & Op.Invokable> Block.Builder inline(O invokableOp, List<? extends Value> args,\n+                                                                  BiConsumer<Block.Builder, Value> inlineConsumer) {\n+            Map<Body, Block.Builder> returnBlocks = new HashMap<>();\n+            \/\/ Create new context, ensuring inlining is isolated\n+            transformBody(invokableOp.body(), args, CopyContext.create(), (block, op) -> {\n+                \/\/ If the return operation is associated with the invokable operation\n+                if (op instanceof CoreOps.ReturnOp rop && getNearestInvokeableAncestorOp(op) == invokableOp) {\n+                    \/\/ Compute the return block\n+                    Block.Builder returnBlock = returnBlocks.computeIfAbsent(rop.ancestorBody(), _body -> {\n+                        Block.Builder rb;\n+                        \/\/ If the body has one block we know there is just one return op declared, otherwise there may\n+                        \/\/ one or more. If so, create a new block that joins all the returns.\n+                        \/\/ Note: we could count all return op in a body to avoid creating a new block for a body\n+                        \/\/ with two or more blocks with only one returnOp is declared.\n+                        Value r;\n+                        if (rop.ancestorBody().blocks().size() != 1) {\n+                            List<TypeDesc> param = rop.returnValue() != null\n+                                    ? List.of(invokableOp.funcDescriptor().returnType())\n+                                    : List.of();\n+                            rb = block.block(param);\n+                            r = !param.isEmpty()\n+                                    ? rb.parameters().get(0)\n+                                    : null;\n+                        } else {\n+                            r = rop.returnValue() != null\n+                                    ? block.context().getValue(rop.returnValue())\n+                                    : null;\n+                            rb = block;\n+                        }\n+\n+                        \/\/ Inline the return\n+                        inlineConsumer.accept(rb, r);\n+\n+                        return rb;\n+                    });\n+\n+                    \/\/ Replace the return op with a branch to the return block, if needed\n+                    if (!returnBlock.equals(block)) {\n+                        \/\/ Replace return op with branch to return block, with given return value\n+                        List<Value> arg = rop.returnValue() != null\n+                                ? List.of(block.context().getValue(rop.returnValue()))\n+                                : List.of();\n+                        block.apply(branch(returnBlock.successor(arg)));\n+                    }\n+\n+                    return block;\n+                }\n+\n+                block.apply(op);\n+                return block;\n+            });\n+\n+\n+            Builder builder = returnBlocks.get(invokableOp.body());\n+            return builder != null ? builder : this;\n+        }\n+\n+        private static Op getNearestInvokeableAncestorOp(Op op) {\n+            do {\n+                op = op.ancestorBody().parentOp();\n+            } while (!(op instanceof Op.Invokable));\n+            return op;\n+        }\n+\n+        \/**\n+         * Transforms a body into this block, with this block builder's context.\n+         *\n+         * @param bodyToTransform the body to transform\n+         * @param args        the list of values to map to the parameters of the body's entry block\n+         * @param ot          the operation transformer\n+         * @see #transformBody(Body, List, CopyContext, OpTransformer)\n+         *\/\n+        public void transformBody(Body bodyToTransform, List<? extends Value> args,\n+                                  OpTransformer ot) {\n+            transformBody(bodyToTransform, args, cc, ot);\n+        }\n+\n+        \/**\n+         * Transforms a body into this block.\n+         * <p>\n+         * First, a new context is created from the given context and that new context is used to map values and\n+         * blocks.\n+         * <p>\n+         * Second, the entry block is mapped to this block builder rebound with the given operation transformer and\n+         * copy context, the input block parameters of the body's entry block are mapped to the given arguments.\n+         * <p>\n+         * Third, for each input block in the body (except the entry block) an output block builder is created with\n+         * equivalent parameters as the input block and with the given operation transformer and copy context.\n+         * The input block parameters are mapped to the output block parameters, and the input block is mapped to the\n+         * output block builder.\n+         * <p>\n+         * Fourth, for each input block in the body (in order) the input block's operations are transformed\n+         * by applying the output block builder and input block to the given operation transformer.\n+         * <p>\n+         * When the parent body is built any empty non-entry blocks that have no successors will be removed.\n+         *\n+         * @param bodyToTransform the body to transform\n+         * @param args            the list of values to map to the parameters of the body's entry block\n+         * @param cc              the copy context, for values captured in the body\n+         * @param ot              the operation transformer\n+         *\/\n+        public void transformBody(Body bodyToTransform, List<? extends Value> args,\n+                                  CopyContext cc, OpTransformer ot) {\n+            check();\n+\n+            \/\/ @@@ This might be a new context e.g., when transforming a body\n+            cc = CopyContext.create(cc);\n+\n+            Block entryBlockToTransform  = bodyToTransform.entryBlock();\n+            List<Block> blocksToTransform = bodyToTransform.blocks();\n+\n+            \/\/ Map entry block\n+            \/\/ Rebind this block builder to the created context and transformer\n+            Block.Builder startingBlock = rebind(cc, ot);\n+            cc.mapBlock(entryBlockToTransform, startingBlock);\n+            cc.mapValues(entryBlockToTransform.parameters(), args);\n+\n+            \/\/ Map subsequent blocks up front, for forward referencing successors\n+            for (int i = 1; i < blocksToTransform.size(); i++) {\n+                Block blockToTransform = blocksToTransform.get(i);\n+                if (cc.getBlock(blockToTransform) != null) {\n+                    throw new IllegalStateException(\"Block is already transformed\");\n+                }\n+\n+                \/\/ Create block and map block\n+                Block.Builder transformedBlock = startingBlock.block(List.of());\n+                for (Block.Parameter ba : blockToTransform.parameters()) {\n+                    transformedBlock.parameter(ba.type());\n+                }\n+                cc.mapBlock(blockToTransform, transformedBlock);\n+                cc.mapValues(blockToTransform.parameters(), transformedBlock.parameters());\n+            }\n+\n+            for (Block blockToTransform : blocksToTransform) {\n+                ot.apply(cc.getBlock(blockToTransform), blockToTransform);\n+            }\n+        }\n+\n+        \/**\n+         * Appends operations into the block builder in the scope of the builder as an argument\n+         * to the given consumer.\n+         *\n+         * @param c the consumer.\n+         *\/\n+        \/\/ @@@ Is this needed?\n+        public void ops(Consumer<Builder> c) {\n+            c.accept(this);\n+        }\n+\n+        \/**\n+         * Appends an operation to this block, with no operation result name, and this builder's transformer.\n+         *\n+         * @param op the operation to append\n+         * @return the operation result of the appended operation\n+         * @throws IllegalStateException if the operation is structurally invalid\n+         * @see #op(Op, OpTransformer)\n+         *\/\n+        @Override\n+        public Op.Result apply(Op op) {\n+            return op(op, ot);\n+        }\n+\n+        \/**\n+         * Appends an operation to this block, with no operation result name, and this builder's transformer.\n+         *\n+         * @param op the operation to append\n+         * @return the operation result of the appended operation\n+         * @throws IllegalStateException if the operation is structurally invalid\n+         * @see #op(Op, OpTransformer)\n+         *\/\n+        public Op.Result op(Op op) {\n+            return op(op, ot);\n+        }\n+\n+        \/**\n+         * Appends an operation to this block.\n+         * <p>\n+         * If the operation is not bound to a block, then the operation is appended and bound to this block.\n+         * Otherwise, if the operation is bound, the operation is first\n+         * {@link Op#transform(CopyContext, OpTransformer) transformed} with this builder's context and the given\n+         * operation transformer, the unbound transformed operation is appended, and the operation's result is mapped\n+         * to the transformed operation's result (using the builder's context).\n+         * <p>\n+         * If the unbound operation (transformed, or otherwise) is structurally invalid then an\n+         * {@code IllegalStateException} is thrown. An unbound operation is structurally invalid if:\n+         * <ul>\n+         * <li>any of its bodies does not have the same ancestor body as this block's parent body.\n+         * <li>any of its operands (values) is not reachable from this block.\n+         * <li>any of its successors is not a sibling of this block.\n+         * <li>any of its successors arguments (values) is not reachable from this block.\n+         * <\/ul>\n+         * A value is reachable from this block if there is a path from this block's parent body,\n+         * via its ancestor bodies, to the value's block's parent body. (Note this structural check\n+         * ensures values are only used from the same tree being built, but it is weaker than a\n+         * dominance check that may be performed when the parent body is built.)\n+         *\n+         * @param op the operation to append\n+         * @param transformer the transformer to use when appending a bound operation\n+         * @return the operation result of the appended operation\n+         * @throws IllegalStateException if the operation is structurally invalid\n+         *\/\n+        public Op.Result op(Op op, OpTransformer transformer) {\n+            check();\n+            final Op.Result oprToTransform = op.result();\n+\n+            Op transformedOp = op;\n+            if (oprToTransform != null) {\n+                \/\/ If operation is assigned to block, then copy it and transform its contents\n+                transformedOp = op.transform(cc, transformer);\n+                assert transformedOp.result == null;\n+            }\n+\n+            Op.Result transformedOpr = insertOp(transformedOp);\n+\n+            if (oprToTransform != null) {\n+                \/\/ Map the result of the first transformation\n+                \/\/ @@@ If the same operation is transformed more than once then subsequent\n+                \/\/  transformed ops will not get implicitly mapped\n+                \/\/  Should this be an error?\n+                cc.mapValueIfAbsent(oprToTransform, transformedOpr);\n+            }\n+\n+            return transformedOpr;\n+        }\n+\n+        \/**\n+         * Returns true if this block builder is equal to the other object.\n+         * <p>This block builder is equal if the other object is an instance of a block builder, and they are\n+         * associated with the same block (but perhaps bound to different contexts and transformers).\n+         *\n+         * @param o the other object\n+         * @return true if this builder is equal to the other object.\n+         *\/\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            return o instanceof Builder that && Block.this == that.target();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Block.this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Modifying methods\n+\n+    \/\/ Create block parameter associated with this block\n+    private Parameter appendBlockParameter(TypeDesc type) {\n+        Parameter blockParameter = new Parameter(this, type);\n+        parameters.add(blockParameter);\n+\n+        return blockParameter;\n+    }\n+\n+    \/\/ Create an operation, adding to the end of the list of existing operations\n+    private Op.Result insertOp(Op op) {\n+        Op.Result opResult = new Op.Result(this, op);\n+        bindOp(opResult, op);\n+\n+        ops.add(op);\n+        return opResult;\n+    }\n+\n+    private void bindOp(Op.Result opr, Op op) {\n+        \/\/ Structural checks\n+        if (!ops.isEmpty() && ops.getLast() instanceof Op.Terminating) {\n+            throw new IllegalStateException(\"Operation cannot be appended, the block has a terminal operation\");\n+        }\n+\n+        for (Body b : op.bodies()) {\n+            if (b.ancestorBody != null && b.ancestorBody != this.parentBody) {\n+                throw new IllegalStateException(\"Body of operation is bound to a different ancestor body: \");\n+            }\n+        }\n+\n+        for (Value v : op.operands()) {\n+            if (!isReachable(v)) {\n+                throw new IllegalStateException(\n+                        String.format(\"Operand of operation %s is not defined in tree: %s\", op, v));\n+            }\n+            assert !v.isBound();\n+        }\n+\n+        for (Reference s : op.successors()) {\n+            if (s.target.parentBody != this.parentBody) {\n+                throw new IllegalStateException(\"Target of block reference is not a sibling of this block\");\n+            }\n+\n+            for (Value v : s.arguments()) {\n+                if (!isReachable(v)) {\n+                    throw new IllegalStateException(\n+                            String.format(\"Argument of block reference %s of terminating operation %s is not defined in tree: %s\", s, op, v));\n+                }\n+                assert !v.isBound();\n+            }\n+        }\n+\n+        \/\/ State updates after structural checks\n+        \/\/ @@@ The alternative is to close the body builder on failure, rendering it inoperable,\n+        \/\/ so checks and updates can be merged\n+        for (Value v : op.operands()) {\n+            v.uses.add(opr);\n+        }\n+\n+        for (Reference s : op.successors()) {\n+            for (Value v : s.arguments()) {\n+                v.uses.add(opr);\n+            }\n+\n+            s.target.predecessors.add(Block.this);\n+        }\n+\n+        op.result = opr;\n+    }\n+\n+    \/\/ Determine if the parent body of value's block is an ancestor of this block\n+    private boolean isReachable(Value v) {\n+        Body b = parentBody;\n+        while (b != null && b != v.block.parentBody) {\n+            b = b.ancestorBody;\n+        }\n+        return b != null;\n+    }\n+\n+    \/\/\n+\n+    boolean isBound() {\n+        return index >= 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","additions":907,"deletions":0,"binary":false,"changes":907,"status":"added"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.util.*;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * A body containing a sequence of (basic) blocks.\n+ * <p>\n+ * The sequence of blocks form a graph. The last operation in a block, a terminating operation,\n+ * may refer to other blocks in the sequence as successors, thus forming the graph. Otherwise, the last\n+ * operation defines how the body passes control flow back to the parent operation, and in doing so may optionally\n+ * yield a value.\n+ * <p>\n+ * The first block in the sequence is the entry block, and no other blocks refer to it as a successor.\n+ * <p>\n+ * A body has a descriptor whose return type is the body's return type and whose parameter types are the entry block's\n+ * parameters types, in order.\n+ * The descriptor describes the sequence of input parameters types for arguments that are passed to the\n+ * body when control flow is passed it, and describes the return type of values that are returned when body passes\n+ * control back to the operation.\n+ *\/\n+public final class Body implements CodeElement<Body, Block> {\n+    \/\/ Parent operation\n+    \/\/ Non-null when body is built, and therefore bound to operation\n+    Op parentOp;\n+\n+    \/\/ The ancestor body, when null the body is isolated and cannot refer to values defined outside\n+    \/\/ When non-null and body is built, ancestorBody == parentOp.result.block.parentBody\n+    final Body ancestorBody;\n+\n+    final TypeDesc yieldType;\n+\n+    \/\/ Sorted in reverse postorder\n+    final List<Block> blocks;\n+\n+    \/\/ Map of a block to its immediate dominator\n+    \/\/ Computed lazily, null if not computed\n+    Map<Block, Block> idoms;\n+\n+    \/**\n+     * Constructs a body, whose ancestor is the given ancestor body.\n+     *\n+     *\/\n+    Body(Body ancestorBody, TypeDesc yieldType) {\n+        this.ancestorBody = ancestorBody;\n+        this.yieldType = yieldType;\n+        this.blocks = new ArrayList<>();\n+    }\n+\n+    \/**\n+     * {@return the yield type of this body}\n+     *\/\n+    public TypeDesc yieldType() {\n+        return yieldType;\n+    }\n+\n+    \/**\n+     * Returns the descriptor of this body.\n+     * <p>The descriptor is composed of the body's entry block parameter types and\n+     * the body's yield type.\n+     *\n+     * @return the descriptor of this body.\n+     *\/\n+    public MethodTypeDesc descriptor() {\n+        Block entryBlock = entryBlock();\n+        return MethodTypeDesc.methodType(yieldType, entryBlock.parameterTypes());\n+    }\n+\n+    \/**\n+     * Returns this body's parent operation.\n+     *\n+     * @return the body's parent operation.\n+     *\/\n+    public Op parentOp() {\n+        return parentOp;\n+    }\n+\n+    \/**\n+     * Finds the block in this body that is the ancestor of the given block.\n+     *\n+     * @param b the given block.\n+     * @return the block in this body that is the ancestor of the given block,\n+     * otherwise {@code null}\n+     *\/\n+    public Block findAncestorBlockInBody(Block b) {\n+        Objects.requireNonNull(b);\n+\n+        while (b != null && b.parentBody() != this) {\n+            b = b.parentBody().parentOp().parentBlock();\n+        }\n+\n+        return b;\n+    }\n+\n+    \/**\n+     * Returns body's blocks in reverse-postorder as an unmodifiable list.\n+     *\n+     * @return the body's blocks in reverse-postorder.\n+     *\/\n+    public List<Block> blocks() {\n+        return Collections.unmodifiableList(blocks);\n+    }\n+\n+    @Override\n+    public List<Block> children() {\n+        return blocks();\n+    }\n+\n+    \/**\n+     * Returns this body's entry block.\n+     * <p>\n+     * The entry block is the first block in the sequence. No other blocks refer to it as a successor.\n+     *\n+     * @return the body's entry block\n+     *\/\n+    public Block entryBlock() {\n+        return blocks.getFirst();\n+    }\n+\n+    \/**\n+     * Returns a map of block to its immediate dominator.\n+     *\n+     * @return a map of block to its immediate dominator\n+     *\/\n+    public Map<Block, Block> immediateDominators() {\n+        \/*\n+         * Compute dominators of blocks in a body.\n+         * <p>\n+         * https:\/\/www.cs.rice.edu\/~keith\/EMBED\/dom.pdf\n+         * A Simple, Fast Dominance Algorithm\n+         * Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy\n+         *\/\n+\n+        if (idoms != null) {\n+            return idoms;\n+        }\n+\n+        Map<Block, Block> doms = idoms = new HashMap<>();\n+        doms.put(entryBlock(), entryBlock());\n+\n+        \/\/ Blocks are sorted in reverse postorder\n+        boolean changed;\n+        do {\n+            changed = false;\n+            \/\/ Iterate through blocks in reverse postorder, except for entry block\n+            for (int i = 1; i < blocks.size(); i++) {\n+                Block b = blocks.get(i);\n+\n+                \/\/ Find first processed predecessor of b\n+                Block newIdom = null;\n+                for (Block p : b.predecessors()) {\n+                    if (doms.containsKey(p)) {\n+                        newIdom = p;\n+                        break;\n+                    }\n+                }\n+                assert b.predecessors().isEmpty() || newIdom != null : b;\n+\n+                \/\/ For all other predecessors, p, of b\n+                for (Block p : b.predecessors()) {\n+                    if (p == newIdom) {\n+                        continue;\n+                    }\n+\n+                    if (doms.containsKey(p)) {\n+                        \/\/ If already calculated\n+                        newIdom = intersect(doms, p, newIdom);\n+                    }\n+                }\n+\n+                if (doms.get(b) != newIdom) {\n+                    doms.put(b, newIdom);\n+                    changed = true;\n+                }\n+            }\n+        } while (changed);\n+\n+        return doms;\n+    }\n+\n+    static Block intersect(Map<Block, Block> doms, Block b1, Block b2) {\n+        while (b1 != b2) {\n+            while (b1.index > b2.index) {\n+                b1 = doms.get(b1);\n+            }\n+\n+            while (b2.index > b1.index) {\n+                b2 = doms.get(b2);\n+            }\n+        }\n+\n+        return b1;\n+    }\n+\n+    \/**\n+     * Returns the dominance frontier of each block in the body.\n+     * <p>\n+     * The dominance frontier of block, {@code B} say, is the set of all blocks, {@code C} say,\n+     * such that {@code B} dominates a predecessor of {@code C} but does not strictly dominate\n+     * {@code C}.\n+     *\n+     * @return the dominance frontier of each block in the body\n+     *\/\n+    public Map<Block, Set<Block>> dominanceFrontier() {\n+        \/\/ @@@ cache result?\n+        Map<Block, Block> idoms = immediateDominators();\n+        Map<Block, Set<Block>> df = new HashMap<>();\n+\n+        for (Block b : blocks) {\n+            Set<Block> preds = b.predecessors();\n+\n+            if (preds.size() > 1) {\n+                for (Block p : preds) {\n+                    Block runner = p;\n+                    while (runner != idoms.get(b)) {\n+                        df.computeIfAbsent(runner, k -> new LinkedHashSet<>()).add(b);\n+                        runner = idoms.get(runner);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return df;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this body is dominated by the given body {@code dom}.\n+     * <p>\n+     * A body, {@code b} say, is dominated by {@code dom} if {@code b} is the same as {@code dom} or a descendant of\n+     * {@code dom}. Specifically, if {@code b} and {@code dom} are not equal then {@code b} becomes the nearest ancestor\n+     * body, the result of {@code b.parentOp().parentBlock().parentBody()}, and so on until either:\n+     * {@code b == dom}, therefore {@code b} is dominated by {@code dom} and this method returns {@code true};\n+     * or {@code b.parentOp().parentBlock() == null}, therefore {@code b} is <b>not<\/b> dominated\n+     * by {@code dom} and this method returns {@code false}.\n+     *\n+     * @param dom the dominating body\n+     * @return {@code true} if this body is dominated by the given body {@code dom}.\n+     *\/\n+    public boolean isDominatedBy(Body dom) {\n+        return isDominatedBy(this, dom);\n+    }\n+\n+    static boolean isDominatedBy(Body r, Body dom) {\n+        while (r != dom) {\n+            Block eb = r.parentOp().parentBlock();\n+            if (eb == null) {\n+                return false;\n+            }\n+\n+            r = eb.parentBody();\n+        }\n+\n+        return true;\n+    }\n+\n+    \/**\n+     * A builder of a body.\n+     * <p>\n+     * When the body builder is built any associated block builders are also considered built.\n+     *\/\n+    public final class Builder {\n+        \/**\n+         * Creates a body build with a new context, and a copying transformer.\n+         *\n+         * @param ancestorBody the nearest ancestor body builder\n+         * @param desc         the body descriptor\n+         * @return the body builder\n+         * @throws IllegalStateException if the ancestor body builder is built\n+         * @see #of(Builder, MethodTypeDesc, CopyContext, OpTransformer)\n+         *\/\n+        public static Builder of(Builder ancestorBody, MethodTypeDesc desc) {\n+            \/\/ @@@ Creation of CopyContext\n+            return of(ancestorBody, desc, CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n+        }\n+\n+        \/**\n+         * Creates a body build with a copying transformer.\n+         *\n+         * @param ancestorBody the nearest ancestor body builder\n+         * @param desc         the body descriptor\n+         * @param cc           the context\n+         * @return the body builder\n+         * @throws IllegalStateException if the ancestor body builder is built\n+         * @see #of(Builder, MethodTypeDesc, CopyContext, OpTransformer)\n+         *\/\n+        public static Builder of(Builder ancestorBody, MethodTypeDesc desc, CopyContext cc) {\n+            return of(ancestorBody, desc, cc, OpTransformer.COPYING_TRANSFORMER);\n+        }\n+\n+        \/**\n+         * Creates a body builder.\n+         * <p>\n+         * Structurally, the created body builder must be built before its ancestor body builder (if non-null) is built,\n+         * otherwise an {@code IllegalStateException} will occur.\n+         * <p>\n+         * The body descriptor defines the body's yield type and the initial sequence of entry block parameters.\n+         * The body's yield is the descriptors return type.\n+         * An entry block builder is created with appended block parameters corresponding, in order, to\n+         * the body descriptor parameter types.\n+         * <p>\n+         * If the ancestor body is null then the created body builder is isolated and descendant operations may only\n+         * refer to values declared within the created body builder. Otherwise, operations\n+         * may refer to values declared in the ancestor body builders (outside the created body builder).\n+         *\n+         * @param ancestorBody the nearest ancestor body builder, may be null if isolated\n+         * @param desc         the body descriptor\n+         * @param cc           the context\n+         * @param ot           the transformer\n+         * @return the body builder\n+         * @throws IllegalStateException if the ancestor body builder is built\n+         * @see #of(Builder, MethodTypeDesc, CopyContext, OpTransformer)\n+         *\/\n+        public static Builder of(Builder ancestorBody, MethodTypeDesc desc,\n+                                 CopyContext cc, OpTransformer ot) {\n+            Body body = new Body(ancestorBody != null ? ancestorBody.target() : null, desc.returnType());\n+            return body.new Builder(ancestorBody, desc, cc, ot);\n+        }\n+\n+        \/\/ The ancestor body, may be null\n+        final Builder ancestorBody;\n+\n+        \/\/ The entry block of this body, whose parameters are given by the body's descriptor\n+        final Block.Builder entryBlock;\n+\n+        \/\/ When non-null contains one or more great-grandchildren\n+        List<Builder> greatgrandchildren;\n+\n+        \/\/ True when built\n+        boolean closed;\n+\n+        Builder(Builder ancestorBody, MethodTypeDesc descriptor,\n+                CopyContext cc, OpTransformer ot) {\n+            \/\/ Structural check\n+            \/\/ The ancestor body should not be built before this body is created\n+            if (ancestorBody != null) {\n+                ancestorBody.check();\n+                ancestorBody.addGreatgrandchild(this);\n+            }\n+\n+            this.ancestorBody = ancestorBody;\n+            \/\/ Create entry block from descriptor\n+            Block eb = Body.this.createBlock(descriptor.parameters());\n+            this.entryBlock = eb.new Builder(this, cc, ot);\n+        }\n+\n+        void addGreatgrandchild(Builder greatgrandchild) {\n+            var l = greatgrandchildren == null\n+                    ? (greatgrandchildren = new ArrayList<>()) : greatgrandchildren;\n+            l.add(greatgrandchild);\n+        }\n+\n+        \/**\n+         * Builds the body and its blocks, associating the body with a parent operation.\n+         * <p>\n+         * Structurally, any descendant body builders must be built before this body builder is built,\n+         * otherwise an {@code IllegalStateException} will occur.\n+         * <p>\n+         * Blocks are sorted in reserve postorder.\n+         * Any non-entry blocks with no operations and are not referred to as successors of other blocks\n+         * are removed.\n+         *\n+         * @param op the parent operation\n+         * @return the build body\n+         * @throws IllegalStateException if this body builder is built\n+         * @throws IllegalStateException if any descendant body builders are not built\n+         *\/\n+        \/\/ @@@ Validation\n+        \/\/ e.g., every operand dominates the operation result (potentially expensive)\n+        public Body build(Op op) {\n+            \/\/ Structural check\n+            \/\/ This body should not be closed\n+            check();\n+            closed = true;\n+\n+            \/\/ Structural check\n+            \/\/ All great-grandchildren bodies should be built\n+            if (greatgrandchildren != null) {\n+                for (Builder greatgrandchild : greatgrandchildren) {\n+                    if (!greatgrandchild.closed) {\n+                        throw new IllegalStateException(\"Descendant body builder is not built\");\n+                    }\n+                }\n+            }\n+\n+            Iterator<Block> i = blocks.iterator();\n+            while (i.hasNext()) {\n+                Block block = i.next();\n+                boolean empty = block.ops.isEmpty();\n+\n+                \/\/ Structural check\n+                \/\/ All blocks should have a terminating operation as the last operation\n+                if (!empty && !(block.ops.getLast() instanceof Op.Terminating)) {\n+                    \/\/ @@@ exception\n+                    throw new IllegalStateException(\"Block has no terminating operation as the last operation\");\n+                }\n+\n+                \/\/ Remove any non-entry blocks with no operations and no predecessors\n+                if (empty &&\n+                        !block.isEntryBlock() &&\n+                        block.predecessors.isEmpty()) {\n+                    i.remove();\n+                }\n+            }\n+\n+            sortReversePostorder();\n+\n+            Body.this.parentOp = op;\n+            return Body.this;\n+        }\n+\n+        \/**\n+         * Returns the body's descriptor.\n+         * <p>\n+         * The descriptor is composed of the body's yield type, as the descriptor's return type, and the currently built\n+         * entry block's parameter types, in order, as the descriptor's parameter types.\n+         * @return the body's descriptor\n+         *\/\n+        public MethodTypeDesc descriptor() {\n+            TypeDesc returnType = Body.this.yieldType();\n+            Block eb = Body.this.entryBlock();\n+            return MethodTypeDesc.methodType(returnType, eb.parameterTypes());\n+        }\n+\n+        \/**\n+         * {@return the body builder's nearest ancestor body builder}\n+         *\/\n+        public Builder ancestorBody() {\n+            return ancestorBody;\n+        }\n+\n+        \/**\n+         * {@return the body's entry block builder}\n+         *\/\n+        public Block.Builder entryBlock() {\n+            return entryBlock;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            return o instanceof Builder that && Body.this == that.target();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Body.this.hashCode();\n+        }\n+\n+        void check() {\n+            if (closed) {\n+                throw new IllegalStateException(\"Builder is closed\");\n+            }\n+        }\n+\n+        Body target() {\n+            return Body.this;\n+        }\n+\n+        \/\/ Build new block in body\n+        Block.Builder block(List<TypeDesc> params, CopyContext cc, OpTransformer ot) {\n+            check();\n+            Block block = Body.this.createBlock(params);\n+\n+            return block.new Builder(this, cc, ot);\n+        }\n+    }\n+\n+    \/**\n+     * Copies the contents of this body.\n+     *\n+     * @param cc the copy context\n+     * @return the builder of a body containing the copied body\n+     * @see #transform(CopyContext, OpTransformer)\n+     *\/\n+    public Builder copy(CopyContext cc) {\n+        return transform(cc, OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Transforms this body.\n+     * <p>\n+     * A new body builder is created with the same descriptor as this body.\n+     * Then, this body is {@link Block.Builder#transformBody(Body, java.util.List, CopyContext, OpTransformer) transformed}\n+     * into the body builder's entry block builder with the given copy context, operation transformer, and values\n+     * that are the entry block's parameters.\n+     *\n+     * @param cc the copy context\n+     * @param ot the operation transformer\n+     * @return a body builder containing the transformed body\n+     *\/\n+    public Builder transform(CopyContext cc, OpTransformer ot) {\n+        Block.Builder ancestorBlockBuilder = ancestorBody != null\n+                ? cc.getBlock(ancestorBody.entryBlock()) : null;\n+        Builder ancestorBodyBuilder = ancestorBlockBuilder != null\n+                ? ancestorBlockBuilder.parentBody() : null;\n+        Builder body = Builder.of(ancestorBodyBuilder,\n+                \/\/ Create descriptor with just the return type and add parameters afterward\n+                MethodTypeDesc.methodType(yieldType),\n+                cc, ot);\n+\n+        for (Block.Parameter p : entryBlock().parameters()) {\n+            body.entryBlock.parameter(p.type());\n+        }\n+\n+        body.entryBlock.transformBody(this, body.entryBlock.parameters(), cc, ot);\n+        return body;\n+    }\n+\n+    private void sortReversePostorder() {\n+        if (blocks.size() < 2) {\n+            for (int i = 0; i < blocks.size(); i++) {\n+                blocks.get(i).index = i;\n+            }\n+            return;\n+        }\n+\n+        \/\/ Reset block indexes\n+        \/\/ Ensure unreferenced blocks occur last\n+        for (Block b : blocks) {\n+            b.index = Integer.MAX_VALUE;\n+        }\n+\n+        Deque<Block> stack = new ArrayDeque<>();\n+        stack.push(blocks.get(0));\n+\n+        \/\/ Postorder iteration\n+        int index = blocks.size();\n+        while (!stack.isEmpty()) {\n+            Block n = stack.peek();\n+            if (n.index == Integer.MIN_VALUE) {\n+                \/\/ If n's successor has been processed then add n\n+                stack.pop();\n+                n.index = --index;\n+            } else if (n.index < Integer.MAX_VALUE) {\n+                \/\/ If n has already been processed then ignore\n+                stack.pop();\n+            } else {\n+                \/\/ Mark before processing successors, a successor may refer back to n\n+                n.index = Integer.MIN_VALUE;\n+                for (Block.Reference s : n.successors()) {\n+                    if (s.target.index < Integer.MAX_VALUE) {\n+                        continue;\n+                    }\n+\n+                    stack.push(s.target);\n+                }\n+            }\n+        }\n+\n+        blocks.sort(Comparator.comparingInt(b -> b.index));\n+    }\n+\n+    \/\/ Modifying methods\n+\n+    \/\/ Create block\n+    private Block createBlock(List<TypeDesc> params) {\n+        Block b = new Block(this, params);\n+        blocks.add(b);\n+        return b;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * A code element, one of {@link Body body}, {@link Block block}, or {@link Op operation}.\n+ * <p>\n+ * A code element may have child code elements, and so on, to form a tree. A (root) code element and all its descendants\n+ * can be traversed.\n+ *\n+ * @param <E> the code element type\n+ * @param <C> the child code element type.\n+ *\/\n+\/\/ @@@ E may not be needed\n+public sealed interface CodeElement<\n+        E extends CodeElement<E, C>,\n+        C extends CodeElement<C, ?>>\n+        permits Body, Block, Op {\n+\n+    \/**\n+     * Traverses this code element and any descendant code elements.\n+     * <p>\n+     * Traversal is performed in pre-order, reporting each code element to the visitor.\n+     *\n+     * @param t   the traversing accumulator\n+     * @param v   the code element visitor\n+     * @param <T> accumulator type\n+     * @return the traversing accumulator\n+     *\/\n+    default <T> T traverse(T t, BiFunction<T, CodeElement<?, ?>, T> v) {\n+        t = v.apply(t, this);\n+        for (C r : children()) {\n+            t = r.traverse(t, v);\n+        }\n+\n+        return t;\n+    }\n+\n+    \/**\n+     * Creates a visiting function for bodies.\n+     *\n+     * @param v the body visitor\n+     * @return the visiting function for bodies\n+     * @param <T> accumulator type\n+     *\/\n+    static <T> BiFunction<T, CodeElement<?, ?>, T> bodyVisitor(BiFunction<T, Body, T> v) {\n+        return (t, e) -> e instanceof Body f\n+                ? v.apply(t, f)\n+                : t;\n+    }\n+\n+    \/**\n+     * Creates a visiting function for blocks.\n+     *\n+     * @param v the block visitor\n+     * @return the visiting function for blocks\n+     * @param <T> accumulator type\n+     *\/\n+    static <T> BiFunction<T, CodeElement<?, ?>, T> blockVisitor(BiFunction<T, Block, T> v) {\n+        return (t, e) -> e instanceof Block f\n+            ? v.apply(t, f)\n+            : t;\n+    }\n+\n+    \/**\n+     * Creates a visiting function for operations.\n+     *\n+     * @param v the operation visitor\n+     * @return the visiting function for operations\n+     * @param <T> accumulator type\n+     *\/\n+    static <T> BiFunction<T, CodeElement<?, ?>, T> opVisitor(BiFunction<T, Op, T> v) {\n+        return (t, e) -> e instanceof Op f\n+                ? v.apply(t, f)\n+                : t;\n+    }\n+\n+    \/**\n+     * Returns the child code elements, as an unmodifiable list.\n+     *\n+     * @return the child code elements\n+     *\/\n+    List<C> children();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeElement.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+\/**\n+ * A context utilized when transforming code models.\n+ * <p>\n+ * The context holds a mapping of input values to output values, input blocks to output block builders,\n+ * and input block references to output block references.\n+ * These mappings are built as an input model is transformed to produce an output model. Mappings are built implicitly\n+ * when an operation is transformed by copying, and can be explicitly added by the transformation when removing or\n+ * adding new operations.\n+ * <p>\n+ * Unless otherwise specified the passing of a {@code null} argument to the methods of this interface results in a\n+ * {@code NullPointerException}.\n+ *\/\n+public sealed interface CopyContext permits CopyContextImpl {\n+\n+    \/\/ @@@ ?\n+    \/\/ CopyContext parent();\n+\n+\n+    \/\/ Value mappings\n+\n+    \/**\n+     * {@return the output value mapped to the input value}\n+     * <p>\n+     * If this context is not isolated and there is no value mapping in this context then this method will return\n+     * the result of calling {@code getValue} on the parent context, if present. Otherwise if this context is isolated\n+     * or there is no parent context, then there is no mapping.\n+     *\n+     * @param input the input value\n+     * @throws IllegalArgumentException if there is no mapping\n+     *\/\n+    Value getValue(Value input);\n+\n+    \/**\n+     * {@return the output value mapped to the input value or a default value if no mapping}\n+     *\n+     * @param input the input value\n+     * @param defaultValue the default value to return if no mapping\n+     *\/\n+    Value getValueOrDefault(Value input, Value defaultValue);\n+\n+    \/**\n+     * Maps an input value to an output value.\n+     * <p>\n+     * Uses of the input value will be mapped to the output value when transforming.\n+     *\n+     * @param input the input value\n+     * @param output the output value\n+     * @throws IllegalArgumentException if the output value is already bound\n+     *\/\n+    void mapValue(Value input, Value output);\n+\n+    \/**\n+     * Maps an input value to an output value, if no such mapping exists.\n+     * <p>\n+     * Uses of the input value will be mapped to the output value when transforming.\n+     *\n+     * @param input the input value\n+     * @param output the output value\n+     * @return the previous mapped value, or null of there was no mapping.\n+     * @throws IllegalArgumentException if the output value is already bound\n+     *\/\n+    \/\/ @@@ Is this needed?\n+    Value mapValueIfAbsent(Value input, Value output);\n+\n+    \/**\n+     * Returns a list of mapped output values by obtaining, in order, the output value for each element in the list\n+     * of input values.\n+     *\n+     * @param inputs the list of input values\n+     * @return a modifiable list of output values\n+     * @throws IllegalArgumentException if an input value has no mapping\n+     *\/\n+    \/\/ @@@ If getValue is modified to return null then this method should fail on null\n+    default List<Value> getValues(List<? extends Value> inputs) {\n+        return inputs.stream().map(this::getValue).collect(toList());\n+    }\n+\n+    \/**\n+     * Maps the list of input values, in order, to the corresponding list of output values, up to the number of\n+     * elements that is the minimum of the size of both lists.\n+     * <p>\n+     * Uses of an input value will be mapped to the corresponding output value when transforming.\n+     *\n+     * @param inputs the input values\n+     * @param outputs the output values.\n+     * @throws IllegalArgumentException if an output value is already bound\n+     *\/\n+    default void mapValues(List<? extends Value> inputs, List<? extends Value> outputs) {\n+        \/\/ @@@ sizes should be the same?\n+        for (int i = 0; i < Math.min(inputs.size(), outputs.size()); i++) {\n+            mapValue(inputs.get(i), outputs.get(i));\n+        }\n+    }\n+\n+\n+    \/\/ Block mappings\n+\n+    \/**\n+     * {@return the output block builder mapped to the input block, otherwise null if no mapping}\n+     *\n+     * @param input the input block\n+     *\/\n+    Block.Builder getBlock(Block input);\n+\n+    \/**\n+     * Maps an input block to an output block builder.\n+     * <p>\n+     * Uses of the input block will be mapped to the output block builder when transforming.\n+     *\n+     * @param input the input block\n+     * @param output the output block builder\n+     * @throws IllegalArgumentException if the output block is already bound\n+     *\/\n+    void mapBlock(Block input, Block.Builder output);\n+\n+\n+    \/\/ Successor mappings\n+\n+    \/**\n+     * {@return the output block reference mapped to the input block reference,\n+     * otherwise null if no mapping}\n+     *\n+     * @param input the input reference\n+     *\/\n+    Block.Reference getSuccessor(Block.Reference input);\n+\n+    \/**\n+     * Maps an input block reference to an output block reference.\n+     * <p>\n+     * Uses of the input block reference will be mapped to the output block reference when transforming.\n+     *\n+     * @param input the input block reference\n+     * @param output the output block reference\n+     * @throws IllegalArgumentException if the output block builder associated with the block reference or any of its\n+     * argument values are already bound\n+     *\/\n+    void mapSuccessor(Block.Reference input, Block.Reference output);\n+\n+    \/**\n+     * Returns a mapped output block reference, if present, otherwise creates a new, unmapped, reference from the input\n+     * block reference.\n+     * <p>\n+     * A new, unmapped reference, is created by obtaining the mapped output block builder from the input reference's\n+     * target block, and creating a successor from the output block builder with arguments that is the result of\n+     * obtaining the mapped values from the input reference's arguments.\n+     *\n+     * @param input the input block reference\n+     * @return the output block reference, if present, otherwise a created block reference\n+     * @throws IllegalArgumentException if a new reference is to be created and there is no mapped output block builder\n+     *\/\n+    default Block.Reference getSuccessorOrCreate(Block.Reference input) {\n+        Block.Reference successor = getSuccessor(input);\n+        if (successor != null) {\n+            return successor;\n+        }\n+\n+        \/\/ Create successor\n+        Block.Builder outputBlock = getBlock(input.targetBlock());\n+        if (outputBlock == null) {\n+            throw new IllegalArgumentException(\"No mapping for input reference target block\" + input.targetBlock());\n+        }\n+        return outputBlock.successor(getValues(input.arguments()));\n+    }\n+\n+\n+    \/\/ Properties mappings\n+\n+    \/**\n+     * {@return an object associated with a property key}\n+     *\n+     * @param key the property key\n+     *\/\n+    Object getProperty(Object key);\n+\n+    \/**\n+     * Associates an object with a property key.\n+     *\n+     * @param key the property key\n+     * @param value the associated object\n+     * @return the current associated object, or null if not associated\n+     *\/\n+    Object putProperty(Object key, Object value);\n+\n+    \/**\n+     * If the property key is not already associated with an object, attempts to compute the object using the\n+     * mapping function and associates it unless {@code null}.\n+     *\n+     * @param key the property key\n+     * @param mappingFunction the mapping function\n+     * @return the current (existing or computed) object associated with the property key,\n+     * or null if the computed object is null\n+     *\/\n+    Object computePropertyIfAbsent(Object key, Function<Object, Object> mappingFunction);\n+\n+\n+    \/\/ Factories\n+\n+    \/**\n+     * {@return a new isolated context initialized with no mappings and no parent }\n+     *\/\n+    static CopyContext create() {\n+        return new CopyContextImpl(null);\n+    }\n+\n+    \/**\n+     * {@return a new non-isolated context initialized with no mappings and a parent }\n+     * The returned context will query value and property mappings in the parent context\n+     * if a query of its value and property mappings yields no result.\n+     *\/\n+    static CopyContext create(CopyContext parent) {\n+        return new CopyContextImpl((CopyContextImpl) parent);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CopyContext.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+final class CopyContextImpl implements CopyContext {\n+\n+    private static final Map<?, ?> EMPTY_MAP = Map.of();\n+\n+    final CopyContextImpl parent;\n+\n+    Map<Value, Value> valueMap;\n+    Map<Block, Block.Builder> blockMap;\n+    Map<Block.Reference, Block.Reference> successorMap;\n+    Map<Object, Object> propertiesMap;\n+\n+    CopyContextImpl(CopyContextImpl that) {\n+        this.parent = that;\n+        this.blockMap = emptyMap();\n+        this.valueMap = emptyMap();\n+        this.successorMap = emptyMap();\n+        this.propertiesMap = emptyMap();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <K, V> Map<K, V> emptyMap() {\n+        return (Map<K, V>) EMPTY_MAP;\n+    }\n+\n+\n+    \/\/ Values\n+\n+    @Override\n+    public Value getValue(Value input) {\n+        Value output = getValueOrNull(input);\n+        if (output != null) {\n+            return output;\n+        }\n+        throw new IllegalArgumentException(\"No mapping for input value: \" + input);\n+    }\n+\n+    @Override\n+    public Value getValueOrDefault(Value input, Value defaultValue) {\n+        Value output = getValueOrNull(input);\n+        if (output != null) {\n+            return output;\n+        }\n+        return defaultValue;\n+    }\n+\n+    private Value getValueOrNull(Value input) {\n+        Objects.requireNonNull(input);\n+\n+        CopyContextImpl p = this;\n+        do {\n+            Value output = p.valueMap.get(input);\n+            if (output != null) {\n+                return output;\n+            }\n+            p = p.parent;\n+        } while (p != null);\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public void mapValue(Value input, Value output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.isBound()) {\n+            throw new IllegalArgumentException(\"Output value bound: \" + output);\n+        }\n+\n+        if (valueMap == EMPTY_MAP) {\n+            valueMap = new HashMap<>();\n+        }\n+        valueMap.put(input, output);\n+    }\n+\n+    @Override\n+    public Value mapValueIfAbsent(Value input, Value output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.isBound()) {\n+            throw new IllegalArgumentException(\"Output value is bound: \" + output);\n+        }\n+\n+        if (valueMap == EMPTY_MAP) {\n+            valueMap = new HashMap<>();\n+        }\n+        return valueMap.putIfAbsent(input, output);\n+    }\n+\n+\n+    \/\/ Blocks\n+\n+    @Override\n+    public Block.Builder getBlock(Block input) {\n+        Objects.requireNonNull(input);\n+\n+        return blockMap.get(input);\n+    }\n+\n+    @Override\n+    public void mapBlock(Block input, Block.Builder output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.target().isBound()) {\n+            throw new IllegalArgumentException(\"Output block builder is built: \" + output);\n+        }\n+\n+        if (blockMap == EMPTY_MAP) {\n+            blockMap = new HashMap<>();\n+        }\n+        blockMap.put(input, output);\n+    }\n+\n+\n+    \/\/ Successors\n+\n+    @Override\n+    public Block.Reference getSuccessor(Block.Reference input) {\n+        Objects.requireNonNull(input);\n+\n+        return successorMap.get(input);\n+    }\n+\n+    @Override\n+    public void mapSuccessor(Block.Reference input, Block.Reference output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.target.isBound()) {\n+            throw new IllegalArgumentException(\"Output block reference target is built: \" + output);\n+        }\n+\n+        for (Value outputArgument : output.arguments()) {\n+            if (outputArgument.isBound()) {\n+                throw new IllegalArgumentException(\"Output block reference argument is bound: \" + outputArgument);\n+            }\n+        }\n+\n+        if (successorMap == EMPTY_MAP) {\n+            successorMap = new HashMap<>();\n+        }\n+        successorMap.put(input, output);\n+    }\n+\n+\n+    \/\/ Properties\n+\n+    @Override\n+    public Object getProperty(Object key) {\n+        CopyContextImpl p = this;\n+        do {\n+            Object value = p.propertiesMap.get(key);\n+            if (value != null) {\n+                return value;\n+            }\n+            p = p.parent;\n+        } while (p != null);\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Object putProperty(Object key, Object value) {\n+        if (propertiesMap == EMPTY_MAP) {\n+            propertiesMap = new HashMap<>();\n+        }\n+        return propertiesMap.put(key, value);\n+    }\n+\n+    @Override\n+    public Object computePropertyIfAbsent(Object key, Function<Object, Object> mappingFunction) {\n+        if (propertiesMap == EMPTY_MAP) {\n+            propertiesMap = new HashMap<>();\n+        }\n+        Object value = getProperty(key);\n+        if (value != null) {\n+            return value;\n+        }\n+        propertiesMap.put(key, value = mappingFunction.apply(key));\n+        return value;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CopyContextImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.code.impl.OpWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * An operation modelling a unit of functionality.\n+ * <p>\n+ * An operation might model the addition of two 32-integers, or a Java method call.\n+ * Alternatively an operation may model something more complex like a method bodies, lambda bodies, or\n+ * try\/catch\/finally statements. In this case such an operation will contain one or more bodies modelling\n+ * the nested structure.\n+ *\/\n+public non-sealed abstract class Op implements CodeElement<Op, Body> {\n+\n+    \/**\n+     * An operation characteristic indicating the operation is pure and has no side effects.\n+     *\/\n+    public interface Pure {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation has one or more bodies.\n+     *\/\n+    public interface Nested {\n+        List<Body> bodies();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation represents a loop\n+     *\/\n+    public interface Loop extends Nested {\n+        Body loopBody();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation has one or more bodies,\n+     * all of which are isolated.\n+     *\/\n+    public interface Isolated extends Nested {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is invokable, so the operation may be interpreted\n+     * or compiled.\n+     *\/\n+    public interface Invokable extends Nested {\n+        \/**\n+         * @return the body of the invokable operation.\n+         *\/\n+        Body body();\n+\n+        \/**\n+         * @return the function descriptor describing the input parameter types and return type.\n+         *\/\n+        MethodTypeDesc funcDescriptor();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation can replace itself with a lowered form,\n+     * consisting only of operations in the core dialect.\n+     *\/\n+    public interface Lowerable {\n+        default Block.Builder lower(Block.Builder b) {\n+            return lower(b, OpTransformer.NOOP_TRANSFORMER);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, OpTransformer opT);\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * A terminating operation passes control to either another block within the same parent body\n+     * or to that parent body.\n+     *\/\n+    public interface Terminating {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a body terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * A body terminating operation passes control back to its nearest ancestor body.\n+     *\/\n+    public interface BodyTerminating extends Terminating {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a block terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * The operation has one or more successors to other blocks within the same parent body, and passes\n+     * control to one of those blocks.\n+     *\/\n+    public interface BlockTerminating extends Terminating {\n+        List<Block.Reference> successors();\n+    }\n+\n+    \/**\n+     * A value that is the result of an operation.\n+     *\/\n+    public static final class Result extends Value {\n+        final Op op;\n+\n+        Result(Block block, Op op) {\n+            super(block, op.descriptor().returnType());\n+\n+            this.op = op;\n+        }\n+\n+        @Override\n+        public Set<Value> dependsOn() {\n+            Set<Value> depends = new LinkedHashSet<>(op.operands());\n+            if (op instanceof Terminating) {\n+                op.successors().stream().flatMap(h -> h.arguments().stream()).forEach(depends::add);\n+            }\n+\n+            return Collections.unmodifiableSet(depends);\n+        }\n+\n+        \/**\n+         * Returns the result's operation.\n+         *\n+         * @return the result's operation.\n+         *\/\n+        public Op op() {\n+            return op;\n+        }\n+    }\n+\n+    \/\/ Set when op is bound to block, otherwise null when unbound\n+    Result result;\n+\n+    final String name;\n+\n+    final List<Value> operands;\n+\n+    final TypeDesc resultType;\n+\n+    \/**\n+     * Constructs an operation by copying given operation.\n+     *\n+     * @param that the operation to copy.\n+     * @param cc   the copy context.\n+     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n+     * values computed, in order, by mapping the operation's operands using the copy context.\n+     *\/\n+    protected Op(Op that, CopyContext cc) {\n+        this(that.name, that.resultType, cc.getValues(that.operands));\n+    }\n+\n+    \/**\n+     * Copies this operation and its bodies, if any.\n+     * <p>\n+     * The returned operation is structurally identical to this operation and is otherwise independent\n+     * of the values declared and used.\n+     *\n+     * @return the copied operation.\n+     *\/\n+    public Op copy() {\n+        return transform(CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Copies this operation and its bodies, if any.\n+     * <p>\n+     * The returned operation is structurally identical to this operation and is otherwise independent\n+     * of the values declared and used.\n+     *\n+     * @param cc the copy context.\n+     * @return the copied operation.\n+     *\/\n+    public Op copy(CopyContext cc) {\n+        return transform(cc, OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Copies this operation and transforms its bodies, if any.\n+     * <p>\n+     * Bodies are {@link Body#transform(CopyContext, OpTransformer) transformed} with the given copy context and\n+     * operation transformer.\n+     *\n+     * @param cc the copy context.\n+     * @param ot the operation transformer.\n+     * @return the transformed operation.\n+     *\/\n+    public abstract Op transform(CopyContext cc, OpTransformer ot);\n+\n+    \/**\n+     * Constructs an operation with a name, operation result type, and list of operands.\n+     *\n+     * @param name       the operation name.\n+     * @param resultType the operation result type.\n+     * @param operands   the list of operands, a copy of the list is performed if required.\n+     *\/\n+    protected Op(String name, TypeDesc resultType, List<? extends Value> operands) {\n+        this.name = name;\n+        this.resultType = resultType;\n+        this.operands = List.copyOf(operands);\n+    }\n+\n+    \/**\n+     * Returns the operation's result, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return the operation's result, or {@code null} if not assigned to a block.\n+     *\/\n+    public final Result result() {\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    public final Block parentBlock() {\n+        if (result == null) {\n+            return null;\n+        }\n+\n+        if (!result.block.isBound()) {\n+            throw new IllegalStateException(\"Parent block is partially constructed\");\n+        }\n+\n+        return result.block;\n+    }\n+\n+    \/**\n+     * Returns this operation's nearest ancestor body (the parent body of this operation's parent block),\n+     * otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's nearest ancestor body, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    public final Body ancestorBody() {\n+        if (result == null) {\n+            return null;\n+        }\n+\n+        if (!result.block.isBound()) {\n+            throw new IllegalStateException(\"Parent body is partially constructed\");\n+        }\n+\n+        return result.block.parentBody;\n+    }\n+\n+    \/**\n+     * {@return the operation name}\n+     *\/\n+    public String opName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * {@return the operation's operands, as an unmodifiable list}\n+     *\/\n+    public List<Value> operands() {\n+        return operands;\n+    }\n+\n+    \/**\n+     * {@return the operation's successors, as an unmodifiable list}\n+     *\/\n+    public List<Block.Reference> successors() {\n+        return List.of();\n+    }\n+\n+    \/**\n+     * The attribute value that represents null.\n+     *\/\n+    public static final Object NULL_ATTRIBUTE_VALUE = new Object();\n+\n+    \/**\n+     * Returns the operation's attributes.\n+     *\n+     * <p>A null attribute value is represented by the constant value {@link #NULL_ATTRIBUTE_VALUE}.\n+     *\n+     * @return the operation's attributes, as an unmodifiable map\n+     *\/\n+    public Map<String, Object> attributes() {\n+        return Map.of();\n+    }\n+\n+    \/**\n+     * {@return the operation's result type}\n+     *\/\n+    public TypeDesc resultType() {\n+        return resultType;\n+    }\n+\n+    \/**\n+     * Returns the operation's descriptor.\n+     * <p>\n+     * The descriptor's result type is the operation's return type and the descriptor's parameter types are the\n+     * operation's operand types, in order.\n+     *\n+     * @return the descriptor\n+     *\/\n+    public MethodTypeDesc descriptor() {\n+        List<TypeDesc> operandTypes = operands.stream().map(Value::type).toList();\n+        return MethodTypeDesc.methodType(resultType, operandTypes);\n+    }\n+\n+    \/**\n+     * {@return the operation's bodies, as an unmodifiable list}\n+     * @implSpec this implementation returns an unmodifiable empty list.\n+     *\/\n+    public List<Body> bodies() {\n+        return List.of();\n+    }\n+\n+    @Override\n+    public final List<Body> children() {\n+        return bodies();\n+    }\n+\n+    \/**\n+     * Traverse the operands of this operation that are the results of prior operations, recursively.\n+     * <p>\n+     * Traversal is performed in pre-order, reporting the operation of each operand to the visitor.\n+     *\n+     * @param t   the traversing accumulator\n+     * @param v   the visitor\n+     * @param <T> accumulator type\n+     * @return the traversing accumulator\n+     * @apiNote A visitor that implements the abstract method of {@code OpVisitor} and does not override any\n+     * other default method will only visit operations. As such a lambda expression or method reference\n+     * may be used to visit operations.\n+     *\/\n+    public final <T> T traverseOperands(T t, BiFunction<T, Op, T> v) {\n+        for (Value arg : operands()) {\n+            if (arg instanceof Result or) {\n+                t = v.apply(t, or.op);\n+                t = or.op.traverseOperands(t, v);\n+            }\n+        }\n+\n+        return t;\n+    }\n+\n+    \/**\n+     * Writes the textual form of this operation to the given output stream, using the UTF-8 character set.\n+     *\n+     * @param out the stream to write to.\n+     *\/\n+    public void writeTo(OutputStream out) {\n+        writeTo(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n+    }\n+\n+    \/**\n+     * Writes the textual form of this operation to the given writer.\n+     *\n+     * @param w the writer to write to.\n+     *\/\n+    public void writeTo(Writer w) {\n+        OpWriter.writeTo(w, this);\n+    }\n+\n+    \/**\n+     * Returns the textual form of this operation.\n+     *\n+     * @return the textual form of this operation.\n+     *\/\n+    public String toText() {\n+        StringWriter w = new StringWriter();\n+        writeTo(w);\n+        return w.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * An operation transformer.\n+ *\/\n+@FunctionalInterface\n+public interface OpTransformer extends BiFunction<Block.Builder, Op, Block.Builder> {\n+    \/**\n+     * A copying transformer that applies the operation to the block builder, and returning the block builder.\n+     *\/\n+    OpTransformer COPYING_TRANSFORMER = (block, op) -> {\n+        block.apply(op);\n+        return block;\n+    };\n+\n+    \/**\n+     * A transformer that performs no action on the block builder.\n+     *\/\n+    OpTransformer NOOP_TRANSFORMER = (block, op) -> block;\n+\n+    \/**\n+     * Transforms a given operation to zero or more other operations appended to the\n+     * given block builder. Returns a block builder to be used for appending further operations, such\n+     * as subsequent operations from the same block as the given operation.\n+     *\n+     * @param block the block builder.\n+     * @param op    the operation to transform.\n+     * @return      the block builder to append to for subsequent operations to transform that have same parent block.\n+     *\/\n+    Block.Builder apply(Block.Builder block, Op op);\n+\n+    \/**\n+     * Transforms a given block to zero or more operations appended to the given block builder.\n+     *\n+     * @implSpec\n+     * The default implementation iterates through each operation of the block to transform\n+     * and {@link #apply(Block.Builder, Op) applies} a block builder and the operation to this\n+     * transformer.\n+     * On first iteration the block builder that is applied is block builder passed as an argument\n+     * to this method.\n+     * On second and subsequent iterations the block builder that is applied is the resulting\n+     * block builder of the prior iteration.\n+     *\n+     * @param block the block builder\n+     * @param b     the block to transform\n+     * @throws NullPointerException if a resulting block builder is null\n+     *\/\n+    default void apply(Block.Builder block, Block b) {\n+        for (Op op : b.ops()) {\n+            block = apply(block, op);\n+            \/\/ @@@ See andThen composition\n+            Objects.requireNonNull(block);\n+        }\n+    }\n+\n+    default OpTransformer compose(OpTransformer before) {\n+        return before.andThen(this);\n+    }\n+\n+    default OpTransformer andThen(OpTransformer after) {\n+        if (after == NOOP_TRANSFORMER) {\n+            return this;\n+        } else if (this == NOOP_TRANSFORMER) {\n+            return after;\n+        } else {\n+            return (bb, o) -> {\n+                Block.Builder nbb = apply(bb, o);\n+                if (nbb != null) {\n+                    return after.apply(nbb, o);\n+                } else {\n+                    \/\/ @@@ This does not currently occur\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/OpTransformer.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+\/**\n+ * Classes implementing this interface support code reflection. That is, they can obtain\n+ * a {@link Quoted} object using {@link #quoted()}, which returns the intermediate\n+ * representation associated with a lambda expression or method reference.\n+ *\/\n+public interface Quotable {\n+    default Quoted quoted() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quotable.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.Map;\n+\n+\/**\n+ * The quoted form of an operation.\n+ * <p>\n+ * The quoted form is utilized when the code model of some code is to be obtained rather than obtaining the result of\n+ * executing that code. For example passing the of a lambda expression in quoted form rather than the expression being\n+ * targeted to a functional interface from which it can be invoked.\n+ *\/\n+public final class Quoted {\n+    private final Op op;\n+    private final Map<Value, Object> capturedValues;\n+\n+    \/**\n+     * Constructs the quoted form of a given invokable operation.\n+     *\n+     * @param op the invokable operation.\n+     *\/\n+    public Quoted(Op op) {\n+        this(op, Map.of());\n+    }\n+\n+    \/**\n+     * Constructs the quoted form of a given invokable operation.\n+     *\n+     * @param op             the invokable operation.\n+     * @param capturedValues the capture values referred to by the operation\n+     *\/\n+    public Quoted(Op op, Map<Value, Object> capturedValues) {\n+        this.op = op;\n+        this.capturedValues = Map.copyOf(capturedValues);\n+    }\n+\n+    \/**\n+     * Returns the invokable operation.\n+     *\n+     * @return the invokable operation.\n+     *\/\n+    public Op op() {\n+        return op;\n+    }\n+\n+    \/**\n+     * Returns the captured values.\n+     *\n+     * @return the captured values, as an unmodifiable map.\n+     *\/\n+    public Map<Value, Object> capturedValues() {\n+        return capturedValues;\n+    }\n+\n+    public static Quoted quote(Op t) {\n+        return new Quoted(t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quoted.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * A value, that is the result of an operation or a block parameter.\n+ *\/\n+public abstract sealed class Value implements Comparable<Value>\n+        permits Block.Parameter, Op.Result {\n+    final Block block;\n+    final TypeDesc type;\n+    \/\/ @@@ In topological order?\n+    \/\/     Can the representation be more efficient e.g. an array?\n+    final Set<Op.Result> uses;\n+\n+    Value(Block block, TypeDesc type) {\n+        this.block = block;\n+        this.type = type;\n+        this.uses = new LinkedHashSet<>();\n+    }\n+\n+    \/**\n+     * Returns this value's declaring block.\n+     * <p>If the value is an operation result, then the declaring block is the operation's parent block.\n+     * If the value is a block parameter then the declaring block is the block declaring the parameter.\n+     *\n+     * @return the value's declaring block.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public Block declaringBlock() {\n+        if (!isBound()) {\n+            throw new IllegalStateException(\"Declaring block is partially constructed\");\n+        }\n+        return block;\n+    }\n+\n+    \/**\n+     * Returns the type of the value.\n+     *\n+     * @return the type of the value.\n+     *\/\n+    public TypeDesc type() {\n+        return type;\n+    }\n+\n+    \/**\n+     * Returns the values this value directly depends on.\n+     * <p>\n+     * An operation result depends on the set of values whose members are the operation's operands and block arguments\n+     * of the operation's successors.\n+     * A block parameter does not depend on any values.\n+     *\n+     * @return the values this value directly depends on, as an unmodifiable set.\n+     *\/\n+    public abstract Set<Value> dependsOn();\n+\n+    \/**\n+     * Returns the uses of this value, specifically each operation result of an operation where this value is used as\n+     * an operand or as an argument of a block reference that is a successor.\n+     *\n+     * @return the uses of this value, as an unmodifiable set.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public Set<Op.Result> uses() {\n+        if (!isBound()) {\n+            throw new IllegalStateException(\"Users are partially constructed\");\n+        }\n+\n+        return Collections.unmodifiableSet(uses);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this value is dominated by the given value {@code dom}.\n+     * <p>\n+     * If {@code v} and {@code dom} are in not declared in the same block then, domination is the result of\n+     * if the declaring block of {@code v} is dominated by the declaring block of {@code dom}.\n+     * <p>\n+     * Otherwise, if {@code v} and {@code dom} are declared in the same block then (in order):\n+     * <ul>\n+     * <li>if {@code dom} is a block parameter, then {@code v} is dominated by {@code dom}.\n+     * <li>if {@code v} is a block parameter, then {@code v} is <b>not<\/b> dominated by {@code dom}.\n+     * <li>otherwise, both {@code v} and {@code dom} are operation results, then {@code v} is dominated by {@code dom}\n+     * if {@code v} is the same as {@code dom} or {@code v} occurs after {@code dom} in the declaring block.\n+     * <\/ul>\n+     *\n+     * @param dom the dominating value\n+     * @return {@code true} if this value is dominated by the given value {@code dom}.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public boolean isDominatedBy(Value dom) {\n+        if (this == dom) {\n+            return true;\n+        }\n+\n+        if (declaringBlock() != dom.declaringBlock()) {\n+            return declaringBlock().isDominatedBy(dom.declaringBlock());\n+        }\n+\n+        \/\/ Any value is dominated by a block parameter\n+        if (dom instanceof Block.Parameter) {\n+            return true;\n+        } else if (this instanceof Block.Parameter) {\n+            return false;\n+        } else {\n+            assert this instanceof Op.Result &&\n+                    dom instanceof Op.Result;\n+            List<Op> ops = declaringBlock().ops();\n+            return ops.indexOf(((Op.Result) this).op()) >= ops.indexOf(((Op.Result) dom).op());\n+        }\n+    }\n+\n+\n+    @Override\n+    public int compareTo(Value o) {\n+        return compare(this, o);\n+    }\n+\n+    \/\/ @@@\n+    public static int compare(Value v1, Value v2) {\n+        if (v1 == v2) return 0;\n+\n+        Block b1 = v1.declaringBlock();\n+        Block b2 = v2.declaringBlock();\n+        if (b1 == b2) {\n+            if (v1 instanceof Op.Result or1 && v2 instanceof Op.Result or2) {\n+                List<Op> ops = b1.ops();\n+                return Integer.compare(ops.indexOf(or1.op()), ops.indexOf(or2.op()));\n+            } else if (v1 instanceof Op.Result) {\n+                \/\/ v2 instanceof BlockParameter\n+                return 1;\n+            } else if (v2 instanceof Op.Result) {\n+                \/\/ v1 instanceof BlockParameter\n+                return -1;\n+            } else { \/\/ v1 && v2 instanceof BlockParameter\n+                assert v1 instanceof Block.Parameter && v2 instanceof Block.Parameter;\n+                List<Block.Parameter> args = b1.parameters();\n+                return Integer.compare(args.indexOf(v1), args.indexOf(v2));\n+            }\n+        }\n+\n+        Body r1 = b1.parentBody();\n+        Body r2 = b2.parentBody();\n+        if (r1 == r2) {\n+            \/\/ @@@ order should be defined by CFG and dominator relations\n+            List<Block> bs = r1.blocks();\n+            return Integer.compare(bs.indexOf(b1), bs.indexOf(b2));\n+        }\n+\n+        Op o1 = r1.parentOp();\n+        Op o2 = r2.parentOp();\n+        if (o1 == o2) {\n+            List<Body> rs = o1.bodies();\n+            return Integer.compare(rs.indexOf(r1), rs.indexOf(r2));\n+        }\n+\n+        return compare(o1.result(), o2.result());\n+    }\n+\n+    boolean isBound() {\n+        return block.isBound();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Value.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.analysis;\n+\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.impl.GlobalValueBlockNaming;\n+import java.lang.reflect.code.impl.OpWriter;\n+import java.util.*;\n+\n+\/**\n+ * Provides liveness information for values declared in the bodies of an operation.\n+ *\/\n+public class Liveness {\n+\n+    \/**\n+     * Liveness information associated with a block.\n+     * Each block has two sets of values, live-in values and live-out values.\n+     *\/\n+    public static final class BlockInfo {\n+        final Block block;\n+        final Deque<Value> inValues;\n+        final Deque<Value> outValues;\n+\n+        BlockInfo(Block block) {\n+            this.block = block;\n+            this.inValues = new ArrayDeque<>();\n+            this.outValues = new ArrayDeque<>();\n+        }\n+\n+        \/**\n+         * {@return the block associated with the liveness information}\n+         *\/\n+        public Block getBlock() {\n+            return block;\n+        }\n+\n+        \/**\n+         * Returns true if a value is live-in for the associated block.\n+         * <p>\n+         * A value is live-in for a block if it is not declared in the block\n+         * and is used in the block or (transitively) by some successor.\n+         *\n+         * @param value the value\n+         * @return true if the value is live-in\n+         *\/\n+        public boolean isLiveIn(Value value) {\n+            return inValues.contains(value);\n+        }\n+\n+        \/**\n+         * {@return the set of live-in values}\n+         *\/\n+        public Set<Value> liveIn() {\n+            return new HashSet<>(inValues);\n+        }\n+\n+        \/**\n+         * Returns true if a value is live-out for the associated block.\n+         * <p>\n+         * A value is live-out for a block if it is used (transitively) by some successor.\n+         *\n+         * @param value the value\n+         * @return true if the value is live-out\n+         *\/\n+        public boolean isLiveOut(Value value) {\n+            return outValues.contains(value);\n+        }\n+\n+        \/**\n+         * {@return the set of live-out values}\n+         *\/\n+        public Set<Value> liveOut() {\n+            return new HashSet<>(outValues);\n+        }\n+\n+        \/**\n+         * Returns the first operation associated with a value and the associated block.\n+         * <p>\n+         * If the value is live-in or a block argument then the blocks first operation\n+         * is returned. Otherwise, the value is an operation result and its operation\n+         * is returned.\n+         *\n+         * @param value the value\n+         * @return first operation associated with a value and the associated block.\n+         *\/\n+        public Op getStartOperation(Value value) {\n+            if (isLiveIn(value) || value instanceof Block.Parameter) {\n+                \/\/ @@@ Check value is from this block\n+                return block.firstOp();\n+            } else {\n+                \/\/ @@@ Check value is from block\n+                Op.Result or = (Op.Result) value;\n+                return or.op();\n+            }\n+        }\n+\n+        \/**\n+         * Returns the end operation associated with a value and the associated block.\n+         * <p>\n+         * If the value is live-out then the blocks last (and terminating) operation\n+         * is returned. Otherwise, the value is dying in this block and the last\n+         * operation to use this value is returned.\n+         *\n+         * @param value the value\n+         * @return first operation associated with a value and the associated block.\n+         *\/\n+        public Op getEndOperation(Value value, Op startOp) {\n+            \/\/ Value is used by some other operation\n+            if (isLiveOut(value)) {\n+                return block.terminatingOp();\n+            }\n+\n+            \/\/ Value may be last used in this block, if so find it\n+            \/\/ @@@ Check startOp is of this block\n+            Op endOp = startOp;\n+            for (Op.Result useOpr : value.uses()) {\n+                Op useOp = useOpr.op();\n+                \/\/ Find the operation in the current block\n+                useOp = block.findAncestorOpInBlock(useOp);\n+                \/\/ Update if after\n+                if (useOp != null && isBeforeInBlock(endOp, useOp)) {\n+                    endOp = useOp;\n+                }\n+            }\n+            return endOp;\n+        }\n+    }\n+\n+    final Op op;\n+    final Map<Block, BlockInfo> livenessMapping;\n+\n+    \/**\n+     * Constructs liveness information for values declared in the bodies\n+     * of an operation.\n+     *\n+     * @param op the operation.\n+     *\/\n+    public Liveness(Op op) {\n+        this.op = op;\n+        this.livenessMapping = new HashMap<>();\n+        for (Body cfg : op.bodies()) {\n+            Compute_LiveSets_SSA_ByVar(cfg);\n+        }\n+    }\n+\n+    \/*\n+    The algorithm to compute liveness information is derived from\n+    Domaine, & Brandner, Florian & Boissinot, Benoit & Darte, Alain & Dinechin, Benoit & Rastello, Fabrice.\n+    (2011). Computing Liveness Sets for SSA-Form Programs.\n+    https:\/\/inria.hal.science\/inria-00558509v2\/document\n+    Specifically Algorithm 6 & 7, adapted to work with block arguments and\n+    block parameters instead of phi operations.\n+    This is a simple algorithm that is easy to understand. We may need to review\n+    its usage within exception regions.\n+    We also may revisit this later with a more performant implementation\n+    perhaps based on the well known algorithm that uses fixpoint iteration.\n+     *\/\n+\n+    void Compute_LiveSets_SSA_ByVar(Body CFG) {\n+        for (Block b : CFG.blocks()) {\n+            livenessMapping.put(b, new BlockInfo(b));\n+        }\n+        for (Block b : CFG.blocks()) {\n+            for (Block.Parameter p : b.parameters()) {\n+                Compute_LiveSets_SSA_ByVar(CFG, p);\n+            }\n+\n+            for (Op op : b.ops()) {\n+                Compute_LiveSets_SSA_ByVar(CFG, op.result());\n+            }\n+        }\n+    }\n+\n+    void Compute_LiveSets_SSA_ByVar(Body CFG, Value v) {\n+        for (Op.Result use : v.uses()) {\n+            Block B = CFG.findAncestorBlockInBody(use.declaringBlock());\n+            Up_and_Mark_Stack(B, v);\n+        }\n+    }\n+\n+    void Up_and_Mark_Stack(Block B, Value v) {\n+        if (v.declaringBlock() == B) {\n+            return;\n+        }\n+        var lbi = livenessMapping.get(B);\n+        if (lbi.inValues.peek() == v) {\n+            return;\n+        }\n+        lbi.inValues.push(v);\n+        for (Block P : B.predecessors()) {\n+            lbi = livenessMapping.get(P);\n+            if (lbi.outValues.peek() != v) {\n+                lbi.outValues.push(v);\n+            }\n+            Up_and_Mark_Stack(P, v);\n+        }\n+    }\n+\n+    \/**\n+     * {@return the liveness information as a string}\n+     *\/\n+    public String toString() {\n+        StringWriter w = new StringWriter();\n+        writeTo(w);\n+        return w.toString();\n+    }\n+\n+    \/**\n+     * Writes the liveness information to the given writer.\n+     *\n+     * @param w the writer to write to.\n+     *\/\n+    public void writeTo(Writer w) {\n+        GlobalValueBlockNaming gn = new GlobalValueBlockNaming();\n+\n+        OpWriter ow = new OpWriter(w, gn);\n+        ow.writeOp(op);\n+        ow.write(\"\\n\");\n+\n+        op.traverse(null, CodeElement.blockVisitor((_, b) -> {\n+            BlockInfo liveness = getLiveness(b);\n+            ow.write(\"^\");\n+            ow.write(gn.getBlockName(b));\n+            ow.write(\"\\n\");\n+            ow.write(\"  Live-in values: \");\n+            ow.writeCommaSeparatedList(liveness.inValues, v -> {\n+                ow.write(\"%\");\n+                ow.write(gn.getValueName(v));\n+            });\n+            ow.write(\"\\n\");\n+            ow.write(\"  Live-out values: \");\n+            ow.writeCommaSeparatedList(liveness.outValues, v -> {\n+                ow.write(\"%\");\n+                ow.write(gn.getValueName(v));\n+            });\n+            ow.write(\"\\n\");\n+\n+            return null;\n+        }));\n+    }\n+\n+    \/**\n+     * Returns true if a value is last used by an operation.\n+     * <p>\n+     * The liveness information for the operation's parent block\n+     * is obtained. If the value is live-out then the value escapes\n+     * the block and is therefore not the last use, and this method\n+     * returns false.\n+     * If the operation is the last to use the value, this method\n+     * returns true. If the operation does not use the value and\n+     * the {@link BlockInfo#getEndOperation end operation}\n+     * occurs before the operation, this method returns true.\n+     * Otherwise, this method returns false.\n+     *\n+     * @param value the value\n+     * @param op    the operation\n+     * @return true if a value is last used by an operation\n+     *\/\n+    public boolean isLastUse(Value value, Op op) {\n+        Block block = op.parentBlock();\n+        BlockInfo liveness = getLiveness(block);\n+\n+        \/\/ Value is used by some successor\n+        if (liveness.isLiveOut(value))\n+            return false;\n+\n+        Op endOp = liveness.getEndOperation(value, op);\n+        \/\/ Last use or operation is after last use\n+        return endOp == op || isBeforeInBlock(endOp, op);\n+    }\n+\n+    \/**\n+     * {@return the liveness information associated with a block}\n+     *\n+     * @param block the block\n+     * @throws IllegalArgumentException if the block has no liveness information\n+     *\/\n+    public BlockInfo getLiveness(Block block) {\n+        BlockInfo lbi = livenessMapping.get(block);\n+        if (lbi == null) {\n+            throw new IllegalArgumentException(\"Block has no liveness information\");\n+        }\n+        return lbi;\n+    }\n+\n+    private static boolean isBeforeInBlock(Op thisOp, Op thatOp) {\n+        if (thisOp.result() == null || thatOp.result() == null) {\n+            throw new IllegalArgumentException(\"This or the given operation is not assigned to a block\");\n+        }\n+\n+        if (thisOp.parentBlock() != thatOp.parentBlock()) {\n+            throw new IllegalArgumentException(\"This and that operation are not assigned to the same blocks\");\n+        }\n+\n+        List<Op> ops = thisOp.parentBlock().ops();\n+        return ops.indexOf(thisOp) < ops.indexOf(thatOp);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * A simple and experimental pattern match mechanism on values and operations.\n+ * <p>\n+ * When the language has support for pattern matching with matcher methods we should be able to express\n+ * matching on values and operations more powerfully and concisely.\n+ *\/\n+public final class Patterns {\n+\n+    private Patterns() {\n+    }\n+\n+\n+    \/**\n+     * Traverses this operation and its descendant operations and returns the set of operations that are unused\n+     * (have no uses) and are pure (are instances of {@code Op.Pure} and thus have no side effects).\n+     *\n+     * @param op the operation to traverse\n+     * @return the set of used and pure operations.\n+     *\/\n+    public static Set<Op> matchUnusedPureOps(Op op) {\n+        return matchUnusedPureOps(op, o -> o instanceof Op.Pure);\n+    }\n+\n+    \/**\n+     * Traverses this operation and its descendant operations and returns the set of operations that are unused\n+     * (have no uses) and are pure (according to the given predicate).\n+     *\n+     * @param op       the operation to traverse\n+     * @param testPure the predicate to test if an operation is pure\n+     * @return the set of used and pure operations.\n+     *\/\n+    public static Set<Op> matchUnusedPureOps(Op op, Predicate<Op> testPure) {\n+        return match(\n+                new HashSet<>(),\n+                op, opP(o -> isDeadOp(o, testPure)),\n+                (ms, deadOps) -> {\n+                    deadOps.add(ms.op());\n+\n+                    \/\/ Dependent dead ops\n+                    matchDependentDeadOps(ms.op(), deadOps, testPure);\n+                    \/\/ @@@ No means to control traversal and only go deeper when\n+                    \/\/ there is only one user\n+\/\/                    ms.op().traverseOperands(null, (_a, arg) -> {\n+\/\/                        if (arg.result().users().size() == 1) {\n+\/\/                            deadOps.add(arg);\n+\/\/                        }\n+\/\/\n+\/\/                        return null;\n+\/\/                    });\n+\n+                    return deadOps;\n+                });\n+    }\n+\n+    static boolean isDeadOp(Op op, Predicate<Op> testPure) {\n+        if (op instanceof Op.Terminating) {\n+            return false;\n+        }\n+\n+        return op.result() != null && op.result().uses().isEmpty() && testPure.test(op);\n+    }\n+\n+    \/\/ @@@ this could be made generic with a method traversing backwards\n+    static void matchDependentDeadOps(Op op, Set<Op> deadOps, Predicate<Op> testPure) {\n+        for (Value arg : op.operands()) {\n+            if (arg instanceof Op.Result or) {\n+                if (arg.uses().size() == 1 && testPure.test(or.op())) {\n+                    deadOps.add(or.op());\n+\n+                    \/\/ Traverse only when a single user\n+                    matchDependentDeadOps(or.op(), deadOps, testPure);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ Matching of patterns\n+\n+    \/**\n+     * The state of a successful match of an operation with matched operands (if any)\n+     *\/\n+    public static final class MatchState {\n+        final Op op;\n+        final List<Value> matchedOperands;\n+\n+        MatchState(Op op, List<Value> matchedOperands) {\n+            this.op = op;\n+            this.matchedOperands = matchedOperands;\n+        }\n+\n+        \/**\n+         * {@return the matched operation}\n+         *\/\n+        public Op op() {\n+            return op;\n+        }\n+\n+        \/**\n+         * {@return the matched operands}\n+         *\/\n+        public List<Value> matchedOperands() {\n+            return matchedOperands;\n+        }\n+    }\n+\n+    record PatternAndFunction<R>(OpPattern p, BiFunction<MatchState, R, R> f) {\n+    }\n+\n+    \/\/ Visiting op pattern matcher\n+    static class OpPatternMatcher<R> implements BiFunction<R, Op, R> {\n+        final List<PatternAndFunction<R>> patterns;\n+        final PatternState state;\n+        final Map<MatchState, BiFunction<MatchState, R, R>> matches;\n+\n+        OpPatternMatcher(OpPattern p, BiFunction<MatchState, R, R> f) {\n+            this(List.of(new PatternAndFunction<>(p, f)));\n+        }\n+\n+        OpPatternMatcher(List<PatternAndFunction<R>> patterns) {\n+            this.patterns = patterns;\n+            this.state = new PatternState();\n+            this.matches = new HashMap<>();\n+        }\n+\n+        @Override\n+        public R apply(R r, Op op) {\n+            for (PatternAndFunction<R> pf : patterns) {\n+                if (pf.p.match(op, state)) {\n+                    MatchState ms = new MatchState(op, state.resetOnMatch());\n+\n+                    r = pf.f.apply(ms, r);\n+                } else {\n+                    state.resetOnNoMatch();\n+                }\n+            }\n+\n+            return r;\n+        }\n+    }\n+\n+    \/**\n+     * A match builder for declaring matching for one or more groups of operation patterns against a given traversable\n+     * and descendant operations (in order).\n+     * @param <R> the match result type\n+     *\/\n+    public static final class MultiMatchBuilder<R> {\n+        final CodeElement<?, ?> o;\n+        final R r;\n+        List<PatternAndFunction<R>> patterns;\n+\n+        MultiMatchBuilder(CodeElement<?, ?> o, R r) {\n+            this.o = o;\n+            this.r = r;\n+            this.patterns = new ArrayList<>();\n+        }\n+\n+        \/**\n+         * Declares a first of possibly other operation patterns in a group.\n+         *\n+         * @param p the operation pattern\n+         * @return a builder to declare further patterns in the group.\n+         *\/\n+        public MultiMatchCaseBuilder pattern(OpPattern p) {\n+            return new MultiMatchCaseBuilder(p);\n+        }\n+\n+        public R matchThenApply() {\n+            OpPatternMatcher<R> opm = new OpPatternMatcher<>(patterns);\n+            return o.traverse(r, CodeElement.opVisitor(opm));\n+        }\n+\n+        \/**\n+         * A builder to declare further operation patterns in a group or to associate a\n+         * target function to be applied if any of the patterns in the group match.\n+         *\/\n+        public final class MultiMatchCaseBuilder {\n+            List<OpPattern> patterns;\n+\n+            MultiMatchCaseBuilder(OpPattern p) {\n+                this.patterns = new ArrayList<>();\n+                patterns.add(p);\n+            }\n+\n+            \/**\n+             * Declares an operation pattern in the group.\n+             *\n+             * @param p the operation pattern\n+             * @return this builder.\n+             *\/\n+            public MultiMatchCaseBuilder pattern(OpPattern p) {\n+                patterns.add(p);\n+                return this;\n+            }\n+\n+            \/**\n+             * Declares the target function to be applied if any of the operation patterns on the group match.\n+             *\n+             * @param f the target function.\n+             * @return the match builder to build further groups.\n+             *\/\n+            public MultiMatchBuilder<R> target(BiFunction<MatchState, R, R> f) {\n+                patterns.stream().map(p -> new PatternAndFunction<>(p, f)).forEach(MultiMatchBuilder.this.patterns::add);\n+                return MultiMatchBuilder.this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Constructs a match builder from which to declare matching for one or more groups of operation patterns against a\n+     * given traversable and descendant operations (in order).\n+     *\n+     * @param r   the initial match result\n+     * @param t   the traversable\n+     * @param <R> the match result type\n+     * @return the match builder\n+     *\/\n+    public static <R> MultiMatchBuilder<R> multiMatch(R r, CodeElement<?, ?> t) {\n+        return new MultiMatchBuilder<>(t, r);\n+    }\n+\n+    \/**\n+     * Matches an operation pattern against the given traversable and descendant operations (in order).\n+     *\n+     * @param r         the initial match result\n+     * @param t         the traversable\n+     * @param opPattern the operation pattern\n+     * @param matcher   the function to be applied with a match state and the current match result when an\n+     *                  encountered operation matches the operation pattern\n+     * @param <R>       the match result type\n+     * @return the match result\n+     *\/\n+    public static <R> R match(R r, CodeElement<?, ?> t, OpPattern opPattern,\n+                              BiFunction<MatchState, R, R> matcher) {\n+        OpPatternMatcher<R> opm = new OpPatternMatcher<>(opPattern, matcher);\n+        return t.traverse(r, CodeElement.opVisitor(opm));\n+    }\n+\n+\n+    \/\/ Pattern classes\n+\n+    static final class PatternState {\n+        List<Value> matchedOperands;\n+\n+        void addOperand(Value v) {\n+            if (matchedOperands == null) {\n+                matchedOperands = new ArrayList<>();\n+            }\n+            matchedOperands.add(v);\n+        }\n+\n+        List<Value> resetOnMatch() {\n+            if (matchedOperands != null) {\n+                List<Value> r = matchedOperands;\n+                matchedOperands = null;\n+                return r;\n+            } else {\n+                return List.of();\n+            }\n+        }\n+\n+        void resetOnNoMatch() {\n+            if (matchedOperands != null) {\n+                matchedOperands.clear();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A pattern matching against a value or operation.\n+     *\/\n+    public static sealed abstract class Pattern {\n+        Pattern() {\n+        }\n+\n+        abstract boolean match(Value v, PatternState state);\n+    }\n+\n+    \/**\n+     * A pattern matching against an operation.\n+     *\/\n+    public static final class OpPattern extends Pattern {\n+        final Predicate<Op> opTest;\n+        final List<Pattern> operandPatterns;\n+\n+        OpPattern(Predicate<Op> opTest, List<Pattern> operandPatterns) {\n+            this.opTest = opTest;\n+            this.operandPatterns = List.copyOf(operandPatterns);\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            if (v instanceof Op.Result or) {\n+                return match(or.op(), state);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean match(Op op, PatternState state) {\n+            \/\/ Test does not match\n+            if (!opTest.test(op)) {\n+                return false;\n+            }\n+\n+            if (!operandPatterns.isEmpty()) {\n+                \/\/ Arity does not match\n+                if (op.operands().size() != operandPatterns.size()) {\n+                    return false;\n+                }\n+\n+                \/\/ Match all arguments\n+                for (int i = 0; i < operandPatterns.size(); i++) {\n+                    Pattern p = operandPatterns.get(i);\n+                    Value v = op.operands().get(i);\n+\n+                    if (!p.match(v, state)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * A pattern that unconditionally matches a value which is captured. If the value is an operation result of an\n+     * operation, then an operation pattern (if any) is further matched against the operation.\n+     *\/\n+    \/\/ @@@ type?\n+    static final class ValuePattern extends Pattern {\n+        final OpPattern opMatcher;\n+\n+        ValuePattern() {\n+            this(null);\n+        }\n+\n+        public ValuePattern(OpPattern opMatcher) {\n+            this.opMatcher = opMatcher;\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            \/\/ Capture the operand\n+            state.addOperand(v);\n+\n+            \/\/ Match on operation on nested pattern, if any\n+            return opMatcher == null || opMatcher.match(v, state);\n+        }\n+    }\n+\n+    \/**\n+     * A pattern that conditionally matches an operation result which is captured,  then an operation pattern (if any)\n+     * is further matched against the result's operation.\n+     *\/\n+    static final class OpResultPattern extends Pattern {\n+        final OpPattern opMatcher;\n+\n+        OpResultPattern() {\n+            this(null);\n+        }\n+\n+        public OpResultPattern(OpPattern opMatcher) {\n+            this.opMatcher = opMatcher;\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            if (!(v instanceof Op.Result)) {\n+                return false;\n+            }\n+\n+            \/\/ Capture the operand\n+            state.addOperand(v);\n+\n+            \/\/ Match on operation on nested pattern, if any\n+            return opMatcher == null || opMatcher.match(v, state);\n+        }\n+    }\n+\n+    \/**\n+     * A pattern that conditionally matches a block parameter which is captured.\n+     *\/\n+    static final class BlockParameterPattern extends Pattern {\n+        BlockParameterPattern() {\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            if (!(v instanceof Block.Parameter)) {\n+                return false;\n+            }\n+\n+            \/\/ Capture the operand\n+            state.addOperand(v);\n+\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * A pattern matching any value or operation.\n+     *\/\n+    static final class AnyPattern extends Pattern {\n+        AnyPattern() {\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            return true;\n+        }\n+    }\n+\n+\n+    \/\/ Pattern factories\n+\n+    \/**\n+     * Creates an operation pattern that tests against an operation by applying it to the predicate, and if\n+     * {@code true}, matches operand patterns against the operation's operands (in order) .\n+     * This operation pattern matches an operation if the test returns {@code true} and all operand patterns match\n+     * against the operation's operands.\n+     *\n+     * @param opTest the predicate\n+     * @param patterns the operand patterns\n+     * @return the operation pattern\n+     *\/\n+    public static OpPattern opP(Predicate<Op> opTest, Pattern... patterns) {\n+        return opP(opTest, List.of(patterns));\n+    }\n+\n+    \/**\n+     * Creates an operation pattern that tests against an operation by applying it to the predicate, and if\n+     * {@code true}, matches operand patterns against the operation's operands (in order) .\n+     * This operation pattern matches an operation if the test returns {@code true} and all operand patterns match\n+     * against the operation's operands.\n+     *\n+     * @param opTest the predicate\n+     * @param patterns the operand patterns\n+     * @return the operation pattern\n+     *\/\n+    public static OpPattern opP(Predicate<Op> opTest, List<Pattern> patterns) {\n+        return new OpPattern(opTest, patterns);\n+    }\n+\n+    \/**\n+     * Creates an operation pattern that tests if the operation is an instance of the class, and if\n+     * {@code true}, matches operand patterns against the operation's operands (in order) .\n+     * This operation pattern matches an operation if the test returns {@code true} and all operand patterns match\n+     * against the operation's operands.\n+     *\n+     * @param opClass the operation class\n+     * @param patterns the operand patterns\n+     * @return the operation pattern\n+     *\/\n+    public static OpPattern opP(Class<?> opClass, Pattern... patterns) {\n+        return opP(opClass::isInstance, patterns);\n+    }\n+\n+    \/**\n+     * Creates an operation pattern that tests if the operation is a {@link CoreOps.ConstantOp constant} operation\n+     * and whose constant value is equal to the given value.\n+     * This operation pattern matches an operation if the test returns {@code true}.\n+     *\n+     * @param value the value\n+     * @return the operation pattern.\n+     *\/\n+    public static OpPattern constantP(Object value) {\n+        return opP(op -> {\n+            if (op instanceof CoreOps.ConstantOp cop) {\n+                return Objects.equals(value, cop.value());\n+            }\n+\n+            return false;\n+        });\n+    }\n+\n+    \/**\n+     * Creates a value pattern that unconditionally matches any value and captures the value in match state.\n+     *\n+     * @return the value pattern.\n+     *\/\n+    public static Pattern valueP() {\n+        return new ValuePattern();\n+    }\n+\n+    \/**\n+     * Creates a value pattern that unconditionally matches any value and captures the value in match state, and\n+     * if the value is an operation result of an operation, then the operation pattern is matched against that\n+     * operation.\n+     * This value pattern matches value if value is not an operation result, or otherwise matches if the operation\n+     * pattern matches.\n+     *\n+     * @param opMatcher the operation pattern\n+     * @return the value pattern.\n+     *\/\n+    public static Pattern valueP(OpPattern opMatcher) {\n+        return new ValuePattern(opMatcher);\n+    }\n+\n+    \/**\n+     * Creates an operation result pattern that conditionally matches an operation result and captures it in match state.\n+     *\n+     * @return the operation result.\n+     *\/\n+    public static Pattern opResultP() {\n+        return new OpResultPattern();\n+    }\n+\n+    \/**\n+     * Creates an operation result pattern that conditionally matches an operation result and captures it in match state,\n+     * then the operation pattern is matched against the result's operation.\n+     *\n+     * @param opMatcher the operation pattern\n+     * @return the operation result.\n+     *\/\n+    public static Pattern opResultP(OpPattern opMatcher) {\n+        return new OpResultPattern(opMatcher);\n+    }\n+\n+    \/**\n+     * Creates a block parameter result pattern that conditionally matches a block parameter and captures it in match state.\n+     *\n+     * @return the block parameter.\n+     *\/\n+    public static Pattern blockParameterP() {\n+        return new BlockParameterPattern();\n+    }\n+\n+    \/**\n+     * Creates a pattern that unconditionally matches any value or operation.\n+     *\n+     * @return the value pattern.\n+     *\/\n+    public static Pattern _P() {\n+        return new AnyPattern();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Patterns.java","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Functionality to transform a code model into pure SSA form, replacing operations that declare variables and\n+ * access them with the use of values they depend on or additional block parameters.\n+ *\/\n+public final class SSA {\n+    private SSA() {\n+    }\n+\n+    \/**\n+     * Applies an SSA transformation to an invokable operation, replacing operations that declare variables and\n+     * access them with the use of values they depend on or additional block parameters.\n+     * <p>\n+     * The operation should first be in lowered form before applying this transformation.\n+     * <p>\n+     * Note: this implementation does not currently work correctly when a variable is stored to within an exception\n+     * region and read from outside as a result of catching an exception. In such cases a complete transformation may be\n+     * not possible and such variables will need to be retained.\n+     *\n+     * @param iop the invokable operation\n+     * @return the transformed operation\n+     * @param <T> the invokable type\n+     *\/\n+    public static <T extends Op & Op.Invokable> T transform(T iop) {\n+        Map<Block, Set<CoreOps.VarOp>> joinPoints = new HashMap<>();\n+        Map<CoreOps.VarAccessOp.VarLoadOp, Object> loadValues = new HashMap<>();\n+        Map<Block.Reference, List<Object>> joinSuccessorValues = new HashMap<>();\n+\n+        Map<Body, Boolean> visited = new HashMap<>();\n+        Map<Block, Map<CoreOps.VarOp, Block.Parameter>> joinBlockArguments = new HashMap<>();\n+        @SuppressWarnings(\"unchecked\")\n+        T liop = (T) iop.transform(CopyContext.create(), (block, op) -> {\n+            \/\/ Compute join points and value mappings for body\n+            visited.computeIfAbsent(op.ancestorBody(), b -> {\n+                findJoinPoints(b, joinPoints);\n+                variableToValue(b, joinPoints, loadValues, joinSuccessorValues);\n+                return true;\n+            });\n+\n+            if (op instanceof CoreOps.VarOp || op instanceof CoreOps.VarAccessOp) {\n+                \/\/ Drop var operations\n+                if (op instanceof CoreOps.VarAccessOp.VarLoadOp vl) {\n+                    \/\/ Replace result of load\n+                    Object loadValue = loadValues.get(vl);\n+                    CopyContext cc = block.context();\n+                    Value v = loadValue instanceof VarOpBlockArgument vba\n+                            ? joinBlockArguments.get(vba.b()).get(vba.vop())\n+                            : cc.getValue((Value) loadValue);\n+                    cc.mapValue(op.result(), v);\n+                }\n+            } else if (op instanceof Op.Terminating) {\n+                for (Block.Reference s : op.successors()) {\n+                    List<Object> joinValues = joinSuccessorValues.get(s);\n+                    \/\/ Successor has join values\n+                    if (joinValues != null) {\n+                        CopyContext cc = block.context();\n+\n+                        \/\/ Lazily append target block arguments\n+                        joinBlockArguments.computeIfAbsent(s.targetBlock(), b -> {\n+                            Block.Builder bb = cc.getBlock(b);\n+                            return joinPoints.get(b).stream().collect(Collectors.toMap(\n+                                    varOp -> varOp,\n+                                    varOp -> bb.parameter(varOp.varType())));\n+                        });\n+\n+                        \/\/ Append successor arguments\n+                        List<Value> values = new ArrayList<>();\n+                        for (Object o : joinValues) {\n+                            Value v = o instanceof VarOpBlockArgument vba\n+                                    ? joinBlockArguments.get(vba.b()).get(vba.vop())\n+                                    : cc.getValue((Value) o);\n+                            values.add(v);\n+                        }\n+\n+                        \/\/ Map successor with append arguments\n+                        List<Value> toArgs = cc.getValues(s.arguments());\n+                        toArgs.addAll(values);\n+                        Block.Reference toS = cc.getBlock(s.targetBlock()).successor(toArgs);\n+                        cc.mapSuccessor(s, toS);\n+                    }\n+                }\n+\n+                block.apply(op);\n+            } else {\n+                block.apply(op);\n+            }\n+\n+            return block;\n+        });\n+        return liop;\n+    }\n+\n+    record VarOpBlockArgument(Block b, CoreOps.VarOp vop) {\n+    }\n+\n+    \/\/ @@@ Check for var uses in exception regions\n+    \/\/     A variable cannot be converted to SAA form if the variable is stored\n+    \/\/     to in an exception region and accessed from an associated catch region\n+\n+    static void variableToValue(Body body,\n+                                Map<Block, Set<CoreOps.VarOp>> joinPoints,\n+                                Map<CoreOps.VarAccessOp.VarLoadOp, Object> loadValues,\n+                                Map<Block.Reference, List<Object>> joinSuccessorValues) {\n+        Map<CoreOps.VarOp, Deque<Object>> variableStack = new HashMap<>();\n+        Node top = buildDomTree(body.entryBlock(), body.immediateDominators());\n+        variableToValue(top, variableStack, joinPoints, loadValues, joinSuccessorValues);\n+    }\n+\n+    \/**\n+     * Replaces usages of a variable with the corresponding value, from a given block node in the dominator tree.\n+     * <p>\n+     * The result of a {@code VarLoadOp} for variable, {@code V} say the result of a {@code VarOp} operation,\n+     * is replaced with the value passed as an operand to the immediately dominating {@code VarStoreOp} that operates\n+     * on {@code V}, or a block argument representing the equivalent of a phi-value of {@code V}.\n+     * After which, any related {@code VarOp}, {@code VarLoadOp}, or {@code VarStoreOp} operations are removed.\n+     *\n+     * @param n             the node in the dominator tree\n+     * @param variableStack the variable stack\n+     * @param joinPoints    the join points\n+     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+     * Section 5.2 and Figure 12.\n+     *\/\n+    static void variableToValue(Node n,\n+                                Map<CoreOps.VarOp, Deque<Object>> variableStack,\n+                                Map<Block, Set<CoreOps.VarOp>> joinPoints,\n+                                Map<CoreOps.VarAccessOp.VarLoadOp, Object> loadValues,\n+                                Map<Block.Reference, List<Object>> joinSuccessorValues) {\n+        int size = n.b().ops().size();\n+\n+        \/\/ Check if V is associated with block argument (phi)\n+        \/\/ Push argument onto V's stack\n+        {\n+            Set<CoreOps.VarOp> varOps = joinPoints.get(n.b());\n+            if (varOps != null) {\n+                varOps.forEach(v -> {\n+                    assert variableStack.get(v) != null;\n+                    variableStack.get(v).push(new VarOpBlockArgument(n.b(), v));\n+                });\n+            }\n+        }\n+\n+        {\n+            for (int i = 0; i < size - 1; i++) {\n+                Op op = n.b().ops().get(i);\n+\n+                if (op instanceof CoreOps.VarOp varOp) {\n+                    \/\/ Initial value assigned to variable\n+                    Value current = op.operands().get(0);\n+                    variableStack.computeIfAbsent(varOp, _k -> new ArrayDeque<>())\n+                            .push(current);\n+                } else if (op instanceof CoreOps.VarAccessOp.VarStoreOp storeOp) {\n+                    \/\/ Value assigned to variable\n+                    Value current = op.operands().get(1);\n+                    variableStack.computeIfAbsent(storeOp.varOp(), _k -> new ArrayDeque<>())\n+                            .push(current);\n+                } else if (op instanceof CoreOps.VarAccessOp.VarLoadOp loadOp) {\n+                    Object to = variableStack.get(loadOp.varOp()).peek();\n+                    loadValues.put(loadOp, to);\n+                } else if (op instanceof Op.Nested) {\n+                    \/\/ Traverse descendant variable loads for variables\n+                    \/\/ declared in the block's parent body\n+                    op.traverse(null, (o, codeElement) -> {\n+                        if (o instanceof CoreOps.VarAccessOp.VarLoadOp loadOp &&\n+                                loadOp.varOp().ancestorBody() == op.ancestorBody()) {\n+                            Object to = variableStack.get(loadOp.varOp()).peek();\n+                            loadValues.put(loadOp, to);\n+                        }\n+                        return null;\n+                    });\n+                }\n+            }\n+\n+            \/\/ Add successor args for joint points\n+            for (Block.Reference succ : n.b().successors()) {\n+                Set<CoreOps.VarOp> varOps = joinPoints.get(succ.targetBlock());\n+                if (varOps != null) {\n+                    List<Object> joinValues = varOps.stream()\n+                            .map(vop -> variableStack.get(vop).peek()).toList();\n+                    joinSuccessorValues.put(succ, joinValues);\n+                }\n+            }\n+\n+            \/\/ The result of a VarOp, a variable value, can only be used in VarStoreOp and VarLoadOp\n+            \/\/ therefore there is no need to check existing successor arguments\n+        }\n+\n+        \/\/ Traverse children of dom tree\n+        for (Node y : n.children()) {\n+            variableToValue(y, variableStack, joinPoints, loadValues, joinSuccessorValues);\n+        }\n+\n+        \/\/ Pop off values for variables\n+        {\n+            Set<CoreOps.VarOp> varOps = joinPoints.get(n.b());\n+            if (varOps != null) {\n+                varOps.forEach(v -> {\n+                    variableStack.get(v).pop();\n+                });\n+            }\n+\n+            for (int i = 0; i < size - 1; i++) {\n+                Op op = n.b().ops().get(i);\n+\n+                if (op instanceof CoreOps.VarOp varOp) {\n+                    variableStack.get(varOp).pop();\n+                } else if (op instanceof CoreOps.VarAccessOp.VarStoreOp storeOp) {\n+                    variableStack.get(storeOp.varOp()).pop();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Finds the join points of a body.\n+     * <p>\n+     * A join point is a block that is in the dominance frontier of one or more predecessors, that make one or more\n+     * stores to variables (using the {@code VarStoreOp} operation on the result of a {@code VarOp} operation).\n+     * The join point contains the set variables ({@code VarOp} operations) that are stored to.\n+     * <p>\n+     * A variable of a joint point indicates that a block argument may need to be added to the join point's block\n+     * when converting variables to SSA form. Different values of a variable may occur at different control flow\n+     * paths at the join point. The block argument represents the convergence of multiple values for the same\n+     * variable, where a predecessor assigns to the block argument.\n+     * (Block arguments are equivalent to phi-values, or phi-nodes, used in other representations.)\n+     *\n+     * @param body the body.\n+     * @param joinPoints the returned join points.\n+     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+     * Section 5.1 and Figure 11.\n+     *\/\n+    public static void findJoinPoints(Body body, Map<Block, Set<CoreOps.VarOp>> joinPoints) {\n+        Map<Block, Set<Block>> df = body.dominanceFrontier();\n+        Map<CoreOps.VarOp, Set<Block>> a = findVarStores(body);\n+\n+        int iterCount = 0;\n+        int[] hasAlready = new int[body.blocks().size()];\n+        int[] work = new int[body.blocks().size()];\n+\n+        Deque<Block> w = new ArrayDeque<>();\n+\n+        for (CoreOps.VarOp v : a.keySet()) {\n+            iterCount++;\n+\n+            for (Block x : a.get(v)) {\n+                work[x.index()] = iterCount;\n+                w.push(x);\n+            }\n+\n+            while (!w.isEmpty()) {\n+                Block x = w.pop();\n+\n+                for (Block y : df.getOrDefault(x, Set.of())) {\n+                    if (hasAlready[y.index()] < iterCount) {\n+                        \/\/ Only add to the join points if y is dominated by the var's block\n+                        if (y.isDominatedBy(v.parentBlock())) {\n+                            joinPoints.computeIfAbsent(y, _k -> new LinkedHashSet<>()).add(v);\n+                        }\n+                        hasAlready[y.index()] = iterCount;\n+\n+                        if (work[y.index()] < iterCount) {\n+                            work[y.index()] = iterCount;\n+                            w.push(y);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Returns map of variable to blocks that contain stores to the variables declared in the body\n+    \/\/ Throws ISE if a descendant store operation is encountered\n+    \/\/ @@@ Compute map for whole tree, then traverse keys with filter\n+    static Map<CoreOps.VarOp, Set<Block>> findVarStores(Body r) {\n+        return r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((stores, op) -> {\n+            if (op instanceof CoreOps.VarAccessOp.VarStoreOp storeOp) {\n+                if (storeOp.varOp().ancestorBody() != storeOp.ancestorBody()) {\n+                    throw new IllegalStateException(\"Descendant variable store operation\");\n+                }\n+                if (storeOp.varOp().ancestorBody() == r) {\n+                    stores.computeIfAbsent(storeOp.varOp(), _v -> new LinkedHashSet<>()).add(storeOp.parentBlock());\n+                }\n+            }\n+            return stores;\n+        }));\n+    }\n+\n+    record Node(Block b, Set<Node> children) {\n+    }\n+\n+    static Node buildDomTree(Block entryBlock, Map<Block, Block> idoms) {\n+        Map<Block, Node> tree = new HashMap<>();\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block id = e.getValue();\n+            Block b = e.getKey();\n+\n+            Node parent = tree.computeIfAbsent(id, _k -> new Node(_k, new HashSet<>()));\n+            if (b == entryBlock) {\n+                continue;\n+            }\n+\n+            Node child = tree.computeIfAbsent(b, _k -> new Node(_k, new HashSet<>()));\n+            parent.children.add(child);\n+        }\n+        return tree.get(entryBlock);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for analysing code models.\n+ *\/\n+package java.lang.reflect.code.analysis;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.components.ClassPrinter;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class BytecodeGenerator {\n+    private BytecodeGenerator() {\n+    }\n+\n+    public static MethodHandle generate(MethodHandles.Lookup l, CoreOps.FuncOp fop) {\n+        byte[] classBytes = generateClassData(l, fop);\n+\n+        {\n+            print(classBytes);\n+            try {\n+                File f = new File(\"f.class\");\n+                try (FileOutputStream fos = new FileOutputStream(f)) {\n+                    fos.write(classBytes);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        MethodHandles.Lookup hcl;\n+        try {\n+            hcl = l.defineHiddenClass(classBytes, true);\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            MethodType mt = fop.funcDescriptor().resolve(hcl);\n+            return hcl.findStatic(hcl.lookupClass(), fop.funcName(), mt);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void print(byte[] classBytes) {\n+        ClassModel cm = ClassFile.of().parse(classBytes);\n+        ClassPrinter.toYaml(cm, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+    }\n+\n+    public static byte[] generateClassData(MethodHandles.Lookup l, CoreOps.FuncOp fop) {\n+        String packageName = l.lookupClass().getPackageName();\n+        String className = packageName.isEmpty()\n+                ? fop.funcName()\n+                : packageName + \".\" + fop.funcName();\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(className),\n+                clb -> {\n+                    clb.withMethodBody(\n+                            fop.funcName(),\n+                            fop.funcDescriptor().toNominalDescriptor(),\n+                            ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                            cob -> {\n+                                ConversionContext c = new ConversionContext(cob);\n+                                generateMethodBody(fop, cob, c);\n+                            });\n+                });\n+        return classBytes;\n+    }\n+\n+    \/*\n+        Live list of slot, value, v, and value, r, after which no usage of v dominates r\n+        i.e. liveness range.\n+        Free list, once slot goes dead it is added to the free list, so it can be reused.\n+\n+        Block args need to have a fixed mapping to locals, unless the stack is used.\n+     *\/\n+\n+    static final class ConversionContext implements BytecodeInstructionOps.MethodVisitorContext {\n+        final CodeBuilder cb;\n+        final Deque<BytecodeInstructionOps.ExceptionTableStart> labelStack;\n+        final Map<Object, Label> labels;\n+\n+        public ConversionContext(CodeBuilder cb) {\n+            this.cb = cb;\n+            this.labelStack = new ArrayDeque<>();\n+            this.labels = new HashMap<>();\n+        }\n+\n+        @Override\n+        public Deque<BytecodeInstructionOps.ExceptionTableStart> exceptionRegionStack() {\n+            return labelStack;\n+        }\n+\n+        @Override\n+        public Label getLabel(Object b) {\n+            return labels.computeIfAbsent(b, _b -> cb.newLabel());\n+        }\n+    }\n+\n+    private static void generateMethodBody(CoreOps.FuncOp fop, CodeBuilder mv, ConversionContext c) {\n+        Body r = fop.body();\n+        generateFromBody(r, mv, c);\n+    }\n+\n+    private static void generateFromBody(Body body, CodeBuilder mv, ConversionContext c) {\n+        \/\/ Process blocks in topological order\n+        \/\/ A jump instruction assumes the false successor block is\n+        \/\/ immediately after, in sequence, to the predecessor\n+        \/\/ since the jump instructions branch on a true condition\n+        \/\/ Conditions are inverted when lowered to bytecode\n+        List<Block> blocks = body.blocks();\n+        for (Block b : blocks) {\n+            \/\/ Ignore any non-entry blocks that have no predecessors\n+            if (body.entryBlock() != b && b.predecessors().isEmpty()) {\n+                continue;\n+            }\n+\n+            Label blockLabel = c.getLabel(b);\n+            mv.labelBinding(blockLabel);\n+\n+            List<Op> ops = b.ops();\n+            for (int i = 0; i < ops.size() - 1; i++) {\n+                Op op = ops.get(i);\n+                if (op instanceof BytecodeInstructionOps.InstructionOp inst) {\n+                    inst.apply(mv, c);\n+                } else if (op instanceof BytecodeInstructionOps.ControlInstructionOp inst) {\n+                    inst.apply(mv, c);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unsupported operation: \" + op);\n+                }\n+            }\n+\n+            Op top = b.terminatingOp();\n+            if (top instanceof BytecodeInstructionOps.GotoInstructionOp inst) {\n+                Block s = inst.successors().get(0).targetBlock();\n+                int bi = blocks.indexOf(b);\n+                int si = blocks.indexOf(s);\n+                \/\/ If successor occurs immediately after this block,\n+                \/\/ then no need for goto instruction\n+                if (bi != si - 1) {\n+                    inst.apply(mv, c);\n+                }\n+            } else if (top instanceof BytecodeInstructionOps.TerminatingInstructionOp inst) {\n+                inst.apply(mv, c);\n+            } else if (top instanceof BytecodeInstructionOps.ControlInstructionOp inst) {\n+                inst.apply(mv, c);\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported operation: \" + top.opName());\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,2568 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.DoubleEntry;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+import java.lang.classfile.constantpool.FloatEntry;\n+import java.lang.classfile.constantpool.IntegerEntry;\n+import java.lang.classfile.constantpool.LoadableConstantEntry;\n+import java.lang.classfile.constantpool.LongEntry;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.ArrayLoadInstruction;\n+import java.lang.classfile.instruction.ArrayStoreInstruction;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.IncrementInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.LoadInstruction;\n+import java.lang.classfile.instruction.LookupSwitchInstruction;\n+import java.lang.classfile.instruction.NewMultiArrayInstruction;\n+import java.lang.classfile.instruction.NewObjectInstruction;\n+import java.lang.classfile.instruction.NewPrimitiveArrayInstruction;\n+import java.lang.classfile.instruction.NewReferenceArrayInstruction;\n+import java.lang.classfile.instruction.OperatorInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.classfile.instruction.StackInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.classfile.instruction.TableSwitchInstruction;\n+import java.lang.classfile.instruction.ThrowInstruction;\n+import java.lang.classfile.instruction.TypeCheckInstruction;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.OpDeclaration;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class BytecodeInstructionOps {\n+\n+    interface MethodVisitorContext {\n+        Deque<ExceptionTableStart> exceptionRegionStack();\n+\n+        Label getLabel(Object o);\n+    }\n+\n+    public record InstructionDef<T extends Instruction>(T instruction, List<Block.Reference> successors) {\n+\n+        InstructionDef(T instruction) {\n+            this(instruction, List.of());\n+        }\n+\n+        Opcode opcode() {\n+            return instruction.opcode();\n+        }\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface Opcodes {\n+        Opcode[] value();\n+    }\n+\n+    public static abstract class InstructionOp extends Op {\n+        InstructionOp(InstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        InstructionOp(String name) {\n+            super(name, TypeDesc.VOID, List.of());\n+        }\n+\n+        @Override\n+        public final Map<String, Object> attributes() {\n+            Map<String, Object> m = _attributes();\n+            return m.isEmpty() ? m : Collections.unmodifiableMap(m);\n+        }\n+\n+        Map<String, Object> _attributes() {\n+            return Map.of();\n+        }\n+\n+        \/\/ Produce an ASM bytecode instruction\n+        public abstract void apply(CodeBuilder b, MethodVisitorContext c);\n+    }\n+\n+    public static abstract class TerminatingInstructionOp extends InstructionOp implements Op.Terminating {\n+        final List<Block.Reference> successors;\n+\n+        TerminatingInstructionOp(TerminatingInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            \/\/ Copy successors\n+            this.successors = that.successors().stream()\n+                    .map(cc::getSuccessorOrCreate)\n+                    .toList();\n+        }\n+\n+        TerminatingInstructionOp(String name) {\n+            super(name);\n+\n+            this.successors = List.of();\n+        }\n+\n+        TerminatingInstructionOp(String name, List<Block.Reference> s) {\n+            super(name);\n+\n+            this.successors = List.copyOf(s);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return successors;\n+        }\n+    }\n+\n+    public static abstract class TypedInstructionOp extends InstructionOp {\n+        public static final String ATTRIBUTE_TYPE = \"type\";\n+\n+        final TypeKind type;\n+\n+        TypedInstructionOp(TypedInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+        }\n+\n+        TypedInstructionOp(String name, TypeKind type) {\n+            super(name);\n+\n+            this.type = type;\n+        }\n+\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_TYPE, type);\n+            return m;\n+        }\n+\n+        public TypeKind type() {\n+            return type;\n+        }\n+\n+        public TypeDesc typeDesc() {\n+            return switch (type) {\n+\/\/                case BooleanType -> TypeDesc.BOOLEAN;\n+\/\/                case ByteType -> TypeDesc.BYTE;\n+\/\/                case ShortType -> TypeDesc.SHORT;\n+\/\/                case CharType -> TypeDesc.CHAR;\n+                case IntType -> TypeDesc.INT;\n+                case FloatType -> TypeDesc.FLOAT;\n+                case LongType -> TypeDesc.LONG;\n+                case DoubleType -> TypeDesc.DOUBLE;\n+                case ReferenceType -> TypeDesc.J_L_OBJECT;\n+                default -> throw new IllegalArgumentException(\"Bad type kind: \" + type);\n+            };\n+        }\n+\n+    }\n+\n+    public static abstract class TypedTerminatingInstructionOp extends TerminatingInstructionOp {\n+        public static final String ATTRIBUTE_TYPE = \"type\";\n+\n+        final TypeKind type;\n+\n+        TypedTerminatingInstructionOp(TypedTerminatingInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+        }\n+\n+        TypedTerminatingInstructionOp(String name, TypeKind type, List<Block.Reference> s) {\n+            super(name, s);\n+\n+            this.type = type;\n+        }\n+\n+        TypedTerminatingInstructionOp(String name, TypeKind type) {\n+            super(name);\n+\n+            this.type = type;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_TYPE, type);\n+            return m;\n+        }\n+\n+        public TypeKind type() {\n+            return type;\n+        }\n+    }\n+\n+    public static abstract class VarInstructionOp extends TypedInstructionOp {\n+        public static final String ATTRIBUTE_INDEX = \"index\";\n+\n+        final int slot;\n+\n+        VarInstructionOp(VarInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.slot = that.slot;\n+        }\n+\n+        VarInstructionOp(String name, TypeKind type, int slot) {\n+            super(name, type);\n+\n+            this.slot = slot;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = super._attributes();\n+            m.put(ATTRIBUTE_INDEX, slot);\n+            return m;\n+        }\n+\n+        public int slot() {\n+            return slot;\n+        }\n+    }\n+\n+\n+    @Opcodes({\n+            Opcode.ALOAD,\n+            Opcode.ALOAD_0,\n+            Opcode.ALOAD_1,\n+            Opcode.ALOAD_2,\n+            Opcode.ALOAD_3,\n+            Opcode.ILOAD,\n+            Opcode.ILOAD_0,\n+            Opcode.ILOAD_1,\n+            Opcode.ILOAD_2,\n+            Opcode.ILOAD_3,\n+            Opcode.LLOAD,\n+            Opcode.LLOAD_0,\n+            Opcode.LLOAD_1,\n+            Opcode.LLOAD_2,\n+            Opcode.LLOAD_3,\n+            Opcode.FLOAD,\n+            Opcode.FLOAD_0,\n+            Opcode.FLOAD_1,\n+            Opcode.FLOAD_2,\n+            Opcode.FLOAD_3,\n+            Opcode.DLOAD,\n+            Opcode.DLOAD_0,\n+            Opcode.DLOAD_1,\n+            Opcode.DLOAD_2,\n+            Opcode.DLOAD_3\n+    })\n+    @OpDeclaration(LoadInstructionOp.NAME)\n+    public static final class LoadInstructionOp extends VarInstructionOp {\n+        public static final String NAME = \"Tload\";\n+\n+        LoadInstructionOp(InstructionDef<LoadInstruction> def) {\n+            this(def.instruction().typeKind(), def.instruction().slot());\n+        }\n+\n+        LoadInstructionOp(LoadInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LoadInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LoadInstructionOp(this, cc);\n+        }\n+\n+        LoadInstructionOp(TypeKind type, int slot) {\n+            super(NAME, type, slot);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.loadInstruction(type(), slot());\n+        }\n+    }\n+\n+    public static LoadInstructionOp load(TypeKind type, int index) {\n+        return new LoadInstructionOp(type, index);\n+    }\n+\n+    @Opcodes({\n+            Opcode.ASTORE,\n+            Opcode.ASTORE_0,\n+            Opcode.ASTORE_1,\n+            Opcode.ASTORE_2,\n+            Opcode.ASTORE_3,\n+            Opcode.ISTORE,\n+            Opcode.ISTORE_0,\n+            Opcode.ISTORE_1,\n+            Opcode.ISTORE_2,\n+            Opcode.ISTORE_3,\n+            Opcode.LSTORE,\n+            Opcode.LSTORE_0,\n+            Opcode.LSTORE_1,\n+            Opcode.LSTORE_2,\n+            Opcode.LSTORE_3,\n+            Opcode.FSTORE,\n+            Opcode.FSTORE_0,\n+            Opcode.FSTORE_1,\n+            Opcode.FSTORE_2,\n+            Opcode.FSTORE_3,\n+            Opcode.DSTORE,\n+            Opcode.DSTORE_0,\n+            Opcode.DSTORE_1,\n+            Opcode.DSTORE_2,\n+            Opcode.DSTORE_3\n+    })\n+    @OpDeclaration(StoreInstructionOp.NAME)\n+    public static final class StoreInstructionOp extends VarInstructionOp {\n+        public static final String NAME = \"Tstore\";\n+\n+        StoreInstructionOp(InstructionDef<StoreInstruction> def) {\n+            this(def.instruction().typeKind(), def.instruction().slot());\n+        }\n+\n+        StoreInstructionOp(StoreInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StoreInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StoreInstructionOp(this, cc);\n+        }\n+\n+        StoreInstructionOp(TypeKind type, int index) {\n+            super(NAME, type, index);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.storeInstruction(type(), slot());\n+        }\n+    }\n+\n+    public static StoreInstructionOp store(TypeKind type, int index) {\n+        return new StoreInstructionOp(type, index);\n+    }\n+\n+\n+    @Opcodes({Opcode.LDC, Opcode.LDC_W, Opcode.LDC2_W})\n+    @OpDeclaration(LdcInstructionOp.NAME)\n+    public static final class LdcInstructionOp extends InstructionOp {\n+        public static final String NAME = \"ldc\";\n+\n+        public static final String ATTRIBUTE_TYPE = \"type\";\n+\n+        public static final String ATTRIBUTE_VALUE = \"value\";\n+\n+        final TypeDesc type;\n+        final Object value;\n+\n+        LdcInstructionOp(InstructionDef<ConstantInstruction.LoadConstantInstruction> def) {\n+            this(toTypeDesc(def.instruction().constantEntry()), toValue(def.instruction().constantEntry()));\n+        }\n+\n+        private static TypeDesc toTypeDesc(LoadableConstantEntry entry) {\n+            if (entry instanceof IntegerEntry) {\n+                return TypeDesc.INT;\n+            } else if (entry instanceof LongEntry) {\n+                return TypeDesc.LONG;\n+            } else if (entry instanceof FloatEntry) {\n+                return TypeDesc.FLOAT;\n+            } else if (entry instanceof DoubleEntry) {\n+                return TypeDesc.DOUBLE;\n+            } else if (entry instanceof StringEntry) {\n+                return TypeDesc.J_L_STRING;\n+            } else if (entry instanceof ClassEntry) {\n+                return TypeDesc.J_L_CLASS;\n+            } else {\n+                \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                throw new IllegalArgumentException(\"Unsupported constant entry: \" + entry);\n+            }\n+        }\n+\n+        private static Object toValue(LoadableConstantEntry entry) {\n+            if (entry instanceof IntegerEntry e) {\n+                return e.intValue();\n+            } else if (entry instanceof LongEntry e) {\n+                return e.longValue();\n+            } else if (entry instanceof FloatEntry e) {\n+                return e.floatValue();\n+            } else if (entry instanceof DoubleEntry e) {\n+                return e.doubleValue();\n+            } else if (entry instanceof StringEntry e) {\n+                return e.stringValue();\n+            } else if (entry instanceof ClassEntry e) {\n+                return TypeDesc.ofNominalDescriptor(e.asSymbol());\n+            } else {\n+                \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                throw new IllegalArgumentException(\"Unsupported constant entry: \" + entry);\n+            }\n+        }\n+\n+        LdcInstructionOp(LdcInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public LdcInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LdcInstructionOp(this, cc);\n+        }\n+\n+        LdcInstructionOp(TypeDesc type, Object value) {\n+            super(NAME);\n+\n+            \/\/ @@@ constant dynamic\n+            \/\/ @@@ check value\n+\n+            this.type = type;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_TYPE, type);\n+            m.put(ATTRIBUTE_VALUE, value);\n+            return m;\n+        }\n+\n+        public TypeDesc type() {\n+            return type;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.ldc(fromValue(mv.constantPool(), value()));\n+        }\n+\n+        static LoadableConstantEntry fromValue(ConstantPoolBuilder b, Object value) {\n+            if (value instanceof ConstantDesc cd) {\n+                return b.constantValueEntry(cd);\n+            } else if (value instanceof TypeDesc td) {\n+                return b.classEntry(td.toNominalDescriptor());\n+            } else {\n+                throw new IllegalArgumentException(\"Unsupported constant value: \" + value);\n+            }\n+        }\n+    }\n+\n+    public static LdcInstructionOp ldc(TypeDesc type, Object value) {\n+        return new LdcInstructionOp(type, value);\n+    }\n+\n+    @Opcodes({Opcode.ICONST_M1,\n+            Opcode.ICONST_0, Opcode.ICONST_1, Opcode.ICONST_2, Opcode.ICONST_3, Opcode.ICONST_4, Opcode.ICONST_5,\n+            Opcode.LCONST_0, Opcode.LCONST_1,\n+            Opcode.FCONST_0, Opcode.FCONST_1, Opcode.FCONST_2,\n+            Opcode.DCONST_0, Opcode.DCONST_1\n+    })\n+    @OpDeclaration(ConstInstructionOp.NAME)\n+    public static final class ConstInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tconst\";\n+\n+        public static final String ATTRIBUTE_VALUE = \"value\";\n+\n+        final int value;\n+\n+        ConstInstructionOp(InstructionDef<ConstantInstruction.IntrinsicConstantInstruction> def) {\n+            this(def.instruction().typeKind(), getValue(def.instruction().opcode().constantValue()));\n+        }\n+\n+        ConstInstructionOp(ConstInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstInstructionOp(this, cc);\n+        }\n+\n+        ConstInstructionOp(TypeKind type, int value) {\n+            super(NAME, type);\n+\n+            switch (type) {\n+                case IntType -> {\n+                    if (value < -2 || value > 5) {\n+                        throw new IllegalArgumentException(\"Constant integer value out of range [-1, 5]: \" + value);\n+                    }\n+                }\n+                case LongType -> {\n+                    if (value < 0 || value > 1) {\n+                        throw new IllegalArgumentException(\"Constant long value out of range [0, 1]: \" + value);\n+                    }\n+                }\n+                case FloatType -> {\n+                    if (value < 0 || value > 2) {\n+                        throw new IllegalArgumentException(\"Constant float value not 0.0, 1.0, or 2.0: \" + value);\n+                    }\n+                }\n+                case DoubleType -> {\n+                    if (value < 0 || value > 1) {\n+                        throw new IllegalArgumentException(\"Constant double value not 0.0, or 1.0: \" + value);\n+                    }\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException(\"Bad type for const instruction: \" + type);\n+                }\n+            }\n+\n+            this.value = value;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = super._attributes();\n+            m.put(ATTRIBUTE_VALUE, value);\n+            return m;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.with(ConstantInstruction.ofIntrinsic(getOpcode(type, value)));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t, int v) {\n+            return switch (t) {\n+                case IntType -> switch (v) {\n+                    case -1 -> Opcode.ICONST_M1;\n+                    case 0 -> Opcode.ICONST_0;\n+                    case 1 -> Opcode.ICONST_1;\n+                    case 2 -> Opcode.ICONST_2;\n+                    case 3 -> Opcode.ICONST_3;\n+                    case 4 -> Opcode.ICONST_4;\n+                    case 5 -> Opcode.ICONST_5;\n+                    default -> throw new InternalError(\"Should not reach here\");\n+                };\n+                case LongType -> switch (v) {\n+                    case 0 -> Opcode.LCONST_0;\n+                    case 1 -> Opcode.LCONST_1;\n+                    default -> throw new InternalError(\"Should not reach here\");\n+                };\n+                case FloatType -> switch (v) {\n+                    case 0 -> Opcode.FCONST_0;\n+                    case 1 -> Opcode.FCONST_1;\n+                    case 2 -> Opcode.FCONST_2;\n+                    default -> throw new InternalError(\"Should not reach here\");\n+                };\n+                case DoubleType -> switch (v) {\n+                    case 0 -> Opcode.DCONST_0;\n+                    case 1 -> Opcode.DCONST_1;\n+                    default -> throw new InternalError(\"Should not reach here\");\n+                };\n+                default -> throw new InternalError(\"Should not reach here\");\n+            };\n+        }\n+\n+        private static int getValue(ConstantDesc c) {\n+            if (c instanceof Number n) {\n+                return n.intValue();\n+            } else {\n+                throw new IllegalArgumentException(\"Unsupported constant value: \" + c);\n+            }\n+        }\n+    }\n+\n+    public static ConstInstructionOp _const(TypeKind type, int value) {\n+        return new ConstInstructionOp(type, value);\n+    }\n+\n+    @Opcodes(Opcode.ARRAYLENGTH)\n+    @OpDeclaration(ArrayLengthInstructionOp.NAME)\n+    public static final class ArrayLengthInstructionOp extends InstructionOp {\n+        public static final String NAME = \"arraylength\";\n+\n+        ArrayLengthInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this();\n+        }\n+\n+        ArrayLengthInstructionOp(ArrayLengthInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthInstructionOp(this, cc);\n+        }\n+\n+        ArrayLengthInstructionOp() {\n+            super(NAME);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.arraylength();\n+        }\n+    }\n+\n+    public static ArrayLengthInstructionOp arraylength() {\n+        return new ArrayLengthInstructionOp();\n+    }\n+\n+    @Opcodes({Opcode.AALOAD, Opcode.BALOAD, Opcode.CALOAD, Opcode.SALOAD,\n+            Opcode.IALOAD, Opcode.LALOAD, Opcode.FALOAD, Opcode.DALOAD})\n+    @OpDeclaration(ArrayLoadInstructionOp.NAME)\n+    public static final class ArrayLoadInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Taload\";\n+\n+        ArrayLoadInstructionOp(InstructionDef<ArrayLoadInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        ArrayLoadInstructionOp(ArrayLoadInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLoadInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLoadInstructionOp(this, cc);\n+        }\n+\n+        ArrayLoadInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.arrayLoadInstruction(type);\n+        }\n+    }\n+\n+    public static ArrayLoadInstructionOp aload(TypeKind t) {\n+        return new ArrayLoadInstructionOp(t);\n+    }\n+\n+    @Opcodes({Opcode.AASTORE, Opcode.BASTORE, Opcode.CASTORE, Opcode.SASTORE,\n+            Opcode.IASTORE, Opcode.LASTORE, Opcode.FASTORE, Opcode.DASTORE})\n+    @OpDeclaration(ArrayStoreInstructionOp.NAME)\n+    public static final class ArrayStoreInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tastore\";\n+\n+        ArrayStoreInstructionOp(InstructionDef<ArrayStoreInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        ArrayStoreInstructionOp(ArrayStoreInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayStoreInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayStoreInstructionOp(this, cc);\n+        }\n+\n+        ArrayStoreInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.arrayStoreInstruction(type);\n+        }\n+    }\n+\n+    public static ArrayStoreInstructionOp astore(TypeKind t) {\n+        return new ArrayStoreInstructionOp(t);\n+    }\n+\n+\n+    @Opcodes({Opcode.INEG, Opcode.LNEG, Opcode.FNEG, Opcode.DNEG})\n+    @OpDeclaration(NegInstructionOp.NAME)\n+    public static final class NegInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tneg\";\n+\n+        NegInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        NegInstructionOp(NegInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NegInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NegInstructionOp(this, cc);\n+        }\n+\n+        NegInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case IntType -> Opcode.INEG;\n+                case LongType -> Opcode.LNEG;\n+                case FloatType -> Opcode.FNEG;\n+                case DoubleType -> Opcode.DNEG;\n+                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n+            };\n+        }\n+    }\n+\n+    public static NegInstructionOp neg(TypeKind type) {\n+        return new NegInstructionOp(type);\n+    }\n+\n+    @Opcodes({Opcode.IADD, Opcode.LADD, Opcode.FADD, Opcode.DADD})\n+    @OpDeclaration(AddInstructionOp.NAME)\n+    public static final class AddInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tadd\";\n+\n+        AddInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        AddInstructionOp(AddInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AddInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AddInstructionOp(this, cc);\n+        }\n+\n+        AddInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case IntType -> Opcode.IADD;\n+                case LongType -> Opcode.LADD;\n+                case FloatType -> Opcode.FADD;\n+                case DoubleType -> Opcode.DADD;\n+                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n+            };\n+        }\n+    }\n+\n+    public static AddInstructionOp add(TypeKind type) {\n+        return new AddInstructionOp(type);\n+    }\n+\n+    @Opcodes({Opcode.IMUL, Opcode.LMUL, Opcode.FMUL, Opcode.DMUL})\n+    @OpDeclaration(MulInstructionOp.NAME)\n+    public static final class MulInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tmul\";\n+\n+        MulInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        MulInstructionOp(MulInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MulInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MulInstructionOp(this, cc);\n+        }\n+\n+        MulInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case IntType -> Opcode.IMUL;\n+                case LongType -> Opcode.LMUL;\n+                case FloatType -> Opcode.FMUL;\n+                case DoubleType -> Opcode.DMUL;\n+                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n+            };\n+        }\n+    }\n+\n+    public static MulInstructionOp mul(TypeKind type) {\n+        return new MulInstructionOp(type);\n+    }\n+\n+\n+    @Opcodes({Opcode.IDIV, Opcode.LDIV, Opcode.FDIV, Opcode.DDIV})\n+    @OpDeclaration(DivInstructionOp.NAME)\n+    public static final class DivInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tdiv\";\n+\n+        DivInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        DivInstructionOp(DivInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DivInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DivInstructionOp(this, cc);\n+        }\n+\n+        DivInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type()));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case IntType -> Opcode.IDIV;\n+                case LongType -> Opcode.LDIV;\n+                case FloatType -> Opcode.FDIV;\n+                case DoubleType -> Opcode.DDIV;\n+                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n+            };\n+        }\n+    }\n+\n+    public static DivInstructionOp div(TypeKind type) {\n+        return new DivInstructionOp(type);\n+    }\n+\n+    @Opcodes({Opcode.ISUB, Opcode.LSUB, Opcode.FSUB, Opcode.DSUB})\n+    @OpDeclaration(SubInstructionOp.NAME)\n+    public static final class SubInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tsub\";\n+\n+        SubInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        SubInstructionOp(SubInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SubInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SubInstructionOp(this, cc);\n+        }\n+\n+        SubInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type()));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case IntType -> Opcode.ISUB;\n+                case LongType -> Opcode.LSUB;\n+                case FloatType -> Opcode.FSUB;\n+                case DoubleType -> Opcode.DSUB;\n+                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n+            };\n+        }\n+    }\n+\n+    public static SubInstructionOp sub(TypeKind type) {\n+        return new SubInstructionOp(type);\n+    }\n+\n+    @Opcodes({Opcode.IREM, Opcode.LREM, Opcode.FREM, Opcode.DREM})\n+    @OpDeclaration(RemInstructionOp.NAME)\n+    public static final class RemInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Trem\";\n+\n+        RemInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        RemInstructionOp(RemInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RemInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new RemInstructionOp(this, cc);\n+        }\n+\n+        RemInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type()));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case IntType -> Opcode.IREM;\n+                case LongType -> Opcode.LREM;\n+                case FloatType -> Opcode.FREM;\n+                case DoubleType -> Opcode.DREM;\n+                default -> throw new IllegalArgumentException(\"Bad type: \" + t);\n+            };\n+        }\n+    }\n+\n+    public static RemInstructionOp rem(TypeKind type) {\n+        return new RemInstructionOp(type);\n+    }\n+\n+    @Opcodes(Opcode.IINC)\n+    @OpDeclaration(IIncInstructionOp.NAME)\n+    public static final class IIncInstructionOp extends InstructionOp {\n+        public static final String NAME = \"iinc\";\n+\n+        public static final String ATTRIBUTE_INDEX = \"index\";\n+\n+        public static final String ATTRIBUTE_INCR = \"incr\";\n+\n+        final int slot;\n+        final int incr;\n+\n+        IIncInstructionOp(InstructionDef<IncrementInstruction> def) {\n+            this(def.instruction.slot(), def.instruction.constant());\n+        }\n+\n+        IIncInstructionOp(IIncInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.slot = that.slot;\n+            this.incr = that.incr;\n+        }\n+\n+        @Override\n+        public IIncInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IIncInstructionOp(this, cc);\n+        }\n+\n+        IIncInstructionOp(int slot, int incr) {\n+            super(NAME);\n+\n+            this.slot = slot;\n+            this.incr = incr;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_INDEX, slot);\n+            m.put(ATTRIBUTE_INCR, incr);\n+            return m;\n+        }\n+\n+        public int index() {\n+            return slot;\n+        }\n+\n+        public int incr() {\n+            return incr;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.incrementInstruction(slot, incr);\n+        }\n+    }\n+\n+    public static IIncInstructionOp iinc(int slot, int incr) {\n+        return new IIncInstructionOp(slot, incr);\n+    }\n+\n+\n+    @Opcodes({Opcode.LCMP, Opcode.FCMPG, Opcode.DCMPG})\n+    @OpDeclaration(CmpInstructionOp.NAME)\n+    public static final class CmpInstructionOp extends TypedInstructionOp {\n+        public static final String NAME = \"Tcmp\";\n+\n+        CmpInstructionOp(InstructionDef<OperatorInstruction> def) {\n+            this(def.instruction.typeKind());\n+        }\n+\n+        CmpInstructionOp(CmpInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CmpInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CmpInstructionOp(this, cc);\n+        }\n+\n+        CmpInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+\n+            getOpcode(type);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.operatorInstruction(getOpcode(type()));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t) {\n+            return switch (t) {\n+                case LongType -> Opcode.LCMP;\n+                case FloatType -> Opcode.FCMPG; \/\/ FCMPL?\n+                case DoubleType -> Opcode.DCMPG; \/\/ DCMPL?\n+                default -> throw new InternalError(\"Should not reach here\");\n+            };\n+        }\n+    }\n+\n+    public static CmpInstructionOp cmp(TypeKind type) {\n+        return new CmpInstructionOp(type);\n+    }\n+\n+\n+    \/\/ Stack instructions\n+\n+    @Opcodes(Opcode.DUP)\n+    @OpDeclaration(DupInstructionOp.NAME)\n+    public static final class DupInstructionOp extends InstructionOp {\n+        public static final String NAME = \"dup\";\n+\n+        DupInstructionOp(InstructionDef<StackInstruction> def) {\n+            this();\n+        }\n+\n+        DupInstructionOp(DupInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DupInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DupInstructionOp(this, cc);\n+        }\n+\n+        DupInstructionOp() {\n+            super(NAME);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.dup();\n+        }\n+    }\n+\n+    public static DupInstructionOp dup() {\n+        return new DupInstructionOp();\n+    }\n+\n+    @Opcodes(Opcode.POP)\n+    @OpDeclaration(PopInstructionOp.NAME)\n+    public static final class PopInstructionOp extends InstructionOp {\n+        public static final String NAME = \"pop\";\n+\n+        PopInstructionOp(InstructionDef<StackInstruction> def) {\n+            this();\n+        }\n+\n+        PopInstructionOp(PopInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PopInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PopInstructionOp(this, cc);\n+        }\n+\n+        PopInstructionOp() {\n+            super(NAME);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.pop();\n+        }\n+    }\n+\n+    public static PopInstructionOp pop() {\n+        return new PopInstructionOp();\n+    }\n+\n+    @Opcodes(Opcode.BIPUSH)\n+    @OpDeclaration(BipushInstructionOp.NAME)\n+    public static final class BipushInstructionOp extends InstructionOp {\n+        public static final String NAME = \"bipush\";\n+\n+        public static final String ATTRIBUTE_VALUE = \"value\";\n+\n+        final int value;\n+\n+        BipushInstructionOp(InstructionDef<ConstantInstruction.ArgumentConstantInstruction> def) {\n+            this(def.instruction.constantValue());\n+        }\n+\n+        BipushInstructionOp(BipushInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public BipushInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BipushInstructionOp(this, cc);\n+        }\n+\n+        BipushInstructionOp(int value) {\n+            super(NAME);\n+\n+            this.value = value;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_VALUE, value);\n+            return m;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.bipush(value);\n+        }\n+    }\n+\n+    public static BipushInstructionOp bipush(byte value) {\n+        return new BipushInstructionOp(value);\n+    }\n+\n+    @Opcodes(Opcode.SIPUSH)\n+    @OpDeclaration(SipushInstructionOp.NAME)\n+    public static final class SipushInstructionOp extends InstructionOp {\n+        public static final String NAME = \"sipush\";\n+\n+        public static final String ATTRIBUTE_VALUE = \"value\";\n+\n+        final int value;\n+\n+        SipushInstructionOp(InstructionDef<ConstantInstruction.ArgumentConstantInstruction> def) {\n+            this(def.instruction.constantValue());\n+        }\n+\n+        SipushInstructionOp(SipushInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public SipushInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SipushInstructionOp(this, cc);\n+        }\n+\n+        SipushInstructionOp(int value) {\n+            super(NAME);\n+\n+            this.value = value;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_VALUE, value);\n+            return m;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.sipush(value);\n+        }\n+    }\n+\n+    public static SipushInstructionOp sipush(short value) {\n+        return new SipushInstructionOp(value);\n+    }\n+\n+    \/\/ Reflective instructions\n+\n+    public static abstract class ClassTypeInstructionOp extends InstructionOp {\n+        public static final String ATTRIBUTE_DESC = \"desc\";\n+\n+        final TypeDesc desc;\n+\n+        ClassTypeInstructionOp(ClassTypeInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.desc = that.desc;\n+        }\n+\n+        ClassTypeInstructionOp(String name, TypeDesc desc) {\n+            super(name);\n+\n+            this.desc = desc;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_DESC, desc);\n+            return m;\n+        }\n+\n+        public TypeDesc desc() {\n+            return desc;\n+        }\n+    }\n+\n+    @Opcodes(Opcode.NEW)\n+    @OpDeclaration(NewInstructionOp.NAME)\n+    public static final class NewInstructionOp extends ClassTypeInstructionOp {\n+        public static final String NAME = \"new\";\n+\n+        NewInstructionOp(InstructionDef<NewObjectInstruction> def) {\n+            this(TypeDesc.ofNominalDescriptor(def.instruction.className().asSymbol()));\n+        }\n+\n+        NewInstructionOp(NewInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NewInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NewInstructionOp(this, cc);\n+        }\n+\n+        NewInstructionOp(TypeDesc desc) {\n+            super(NAME, desc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.new_(desc.toNominalDescriptor());\n+        }\n+    }\n+\n+    public static NewInstructionOp _new(TypeDesc desc) {\n+        return new NewInstructionOp(desc);\n+    }\n+\n+    @Opcodes({Opcode.ANEWARRAY, Opcode.NEWARRAY})\n+    @OpDeclaration(NewArrayInstructionOp.NAME)\n+    public static final class NewArrayInstructionOp extends ClassTypeInstructionOp {\n+        public static final String NAME = \"Tnewarray\";\n+\n+        NewArrayInstructionOp(InstructionDef<Instruction> def) {\n+            this(getType(def.instruction));\n+        }\n+\n+        static TypeDesc getType(Instruction instruction) {\n+            if (instruction instanceof NewPrimitiveArrayInstruction a) {\n+                return switch (a.typeKind()) {\n+                    case BooleanType -> TypeDesc.BOOLEAN;\n+                    case ByteType -> TypeDesc.BYTE;\n+                    case ShortType -> TypeDesc.SHORT;\n+                    case CharType -> TypeDesc.CHAR;\n+                    case IntType -> TypeDesc.INT;\n+                    case FloatType -> TypeDesc.FLOAT;\n+                    case LongType -> TypeDesc.LONG;\n+                    case DoubleType -> TypeDesc.DOUBLE;\n+                    default -> throw new IllegalArgumentException(\"Bad array component type: \" + a.typeKind());\n+                };\n+            } else if (instruction instanceof NewReferenceArrayInstruction ra) {\n+                return TypeDesc.ofNominalDescriptor(ra.componentType().asSymbol());\n+            } else {\n+                throw new InternalError();\n+            }\n+        }\n+\n+        NewArrayInstructionOp(NewArrayInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NewArrayInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NewArrayInstructionOp(this, cc);\n+        }\n+\n+        NewArrayInstructionOp(TypeDesc desc) {\n+            super(NAME, desc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            ClassDesc cd = desc().toNominalDescriptor();\n+            if (cd.isPrimitive()) {\n+                mv.newPrimitiveArrayInstruction(TypeKind.fromDescriptor(cd.descriptorString()));\n+            } else {\n+                mv.newReferenceArrayInstruction(cd);\n+            }\n+        }\n+    }\n+\n+    public static NewArrayInstructionOp newarray(TypeDesc desc) {\n+        return new NewArrayInstructionOp(desc);\n+    }\n+\n+    @Opcodes(Opcode.MULTIANEWARRAY)\n+    @OpDeclaration(MultiNewArrayInstructionOp.NAME)\n+    public static final class MultiNewArrayInstructionOp extends ClassTypeInstructionOp {\n+        public static final String NAME = \"multinewarray\";\n+\n+        public static final String ATTRIBUTE_DIMS = \"dims\";\n+\n+        final int dims;\n+\n+        MultiNewArrayInstructionOp(InstructionDef<NewMultiArrayInstruction> def) {\n+            this(TypeDesc.ofNominalDescriptor(def.instruction().arrayType().asSymbol()), def.instruction().dimensions());\n+        }\n+\n+        MultiNewArrayInstructionOp(MultiNewArrayInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.dims = that.dims;\n+        }\n+\n+        @Override\n+        public MultiNewArrayInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MultiNewArrayInstructionOp(this, cc);\n+        }\n+\n+        MultiNewArrayInstructionOp(TypeDesc desc, int dims) {\n+            super(NAME, desc);\n+\n+            this.dims = dims;\n+        }\n+\n+        public int dims() {\n+            return dims;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = super._attributes();\n+            m.put(ATTRIBUTE_DIMS, dims);\n+            return m;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.multianewarray(desc().toNominalDescriptor(), dims);\n+        }\n+    }\n+\n+    public static MultiNewArrayInstructionOp multinewarray(TypeDesc desc, int dims) {\n+        return new MultiNewArrayInstructionOp(desc, dims);\n+    }\n+\n+    @Opcodes(Opcode.INSTANCEOF)\n+    @OpDeclaration(InstanceOfInstructionOp.NAME)\n+    public static final class InstanceOfInstructionOp extends ClassTypeInstructionOp {\n+        public static final String NAME = \"instanceof\";\n+\n+        InstanceOfInstructionOp(InstructionDef<TypeCheckInstruction> def) {\n+            this(TypeDesc.ofNominalDescriptor(def.instruction().type().asSymbol()));\n+        }\n+\n+        InstanceOfInstructionOp(InstanceOfInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public InstanceOfInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InstanceOfInstructionOp(this, cc);\n+        }\n+\n+        InstanceOfInstructionOp(TypeDesc desc) {\n+            super(NAME, desc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.instanceof_(desc().toNominalDescriptor());\n+        }\n+    }\n+\n+    public static InstanceOfInstructionOp instanceOf(TypeDesc desc) {\n+        return new InstanceOfInstructionOp(desc);\n+    }\n+\n+    @Opcodes(Opcode.CHECKCAST)\n+    @OpDeclaration(CheckCastInstructionOp.NAME)\n+    public static final class CheckCastInstructionOp extends ClassTypeInstructionOp {\n+        public static final String NAME = \"checkcast\";\n+\n+        CheckCastInstructionOp(InstructionDef<TypeCheckInstruction> def) {\n+            this(TypeDesc.ofNominalDescriptor(def.instruction().type().asSymbol()));\n+        }\n+\n+        CheckCastInstructionOp(CheckCastInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CheckCastInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CheckCastInstructionOp(this, cc);\n+        }\n+\n+        CheckCastInstructionOp(TypeDesc desc) {\n+            super(NAME, desc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.checkcast(desc().toNominalDescriptor());\n+        }\n+    }\n+\n+    public static CheckCastInstructionOp checkCast(TypeDesc desc) {\n+        return new CheckCastInstructionOp(desc);\n+    }\n+\n+    enum FieldKind {\n+        STATIC, INSTANCE,\n+    }\n+\n+    public static abstract class FieldInstructionOp extends InstructionOp {\n+        public static final String ATTRIBUTE_KIND = \"kind\";\n+        public static final String ATTRIBUTE_DESC = \"desc\";\n+\n+        final FieldKind kind;\n+        final FieldDesc desc;\n+\n+        FieldInstructionOp(FieldInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.kind = that.kind;\n+            this.desc = that.desc;\n+        }\n+\n+        FieldInstructionOp(String name, FieldKind kind, FieldDesc desc) {\n+            super(name);\n+\n+            this.kind = kind;\n+            this.desc = desc;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_KIND, kind);\n+            m.put(ATTRIBUTE_DESC, desc);\n+            return m;\n+        }\n+\n+        public FieldKind kind() {\n+            return kind;\n+        }\n+\n+        public FieldDesc desc() {\n+            return desc;\n+        }\n+\n+        static FieldDesc getFieldDesc(FieldRefEntry node) {\n+            return FieldDesc.field(\n+                    TypeDesc.ofNominalDescriptor(node.owner().asSymbol()),\n+                    node.name().stringValue(),\n+                    TypeDesc.ofNominalDescriptorString(node.type().stringValue()));\n+        }\n+    }\n+\n+    @Opcodes({Opcode.GETFIELD, Opcode.GETSTATIC})\n+    @OpDeclaration(GetFieldInstructionOp.NAME)\n+    public static final class GetFieldInstructionOp extends FieldInstructionOp {\n+        public static final String NAME = \"getfield\";\n+\n+        GetFieldInstructionOp(InstructionDef<FieldInstruction> def) {\n+            this(getFieldKind(def.opcode()), getFieldDesc(def.instruction().field()));\n+        }\n+\n+        GetFieldInstructionOp(GetFieldInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GetFieldInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GetFieldInstructionOp(this, cc);\n+        }\n+\n+        GetFieldInstructionOp(FieldKind kind, FieldDesc desc) {\n+            super(NAME, kind, desc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            FieldDesc desc = desc();\n+            mv.fieldInstruction(getOpcode(kind),\n+                    desc.refType().toNominalDescriptor(), desc.name(), desc.type().toNominalDescriptor());\n+        }\n+\n+        private static Opcode getOpcode(FieldKind kind) {\n+            return switch (kind) {\n+                case STATIC -> Opcode.GETSTATIC;\n+                case INSTANCE -> Opcode.GETFIELD;\n+            };\n+        }\n+\n+        private static FieldKind getFieldKind(Opcode opcode) {\n+            return switch (opcode) {\n+                case GETSTATIC -> FieldKind.STATIC;\n+                case GETFIELD -> FieldKind.INSTANCE;\n+                default -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n+    public static GetFieldInstructionOp getField(FieldKind kind, FieldDesc desc) {\n+        return new GetFieldInstructionOp(kind, desc);\n+    }\n+\n+    @Opcodes({Opcode.PUTFIELD, Opcode.PUTSTATIC})\n+    @OpDeclaration(PutFieldInstructionOp.NAME)\n+    public static final class PutFieldInstructionOp extends FieldInstructionOp {\n+        public static final String NAME = \"putfield\";\n+\n+        PutFieldInstructionOp(InstructionDef<FieldInstruction> def) {\n+            this(getFieldKind(def.opcode()), getFieldDesc(def.instruction().field()));\n+        }\n+\n+        PutFieldInstructionOp(PutFieldInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PutFieldInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PutFieldInstructionOp(this, cc);\n+        }\n+\n+        PutFieldInstructionOp(FieldKind kind, FieldDesc desc) {\n+            super(NAME, kind, desc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            FieldDesc desc = desc();\n+            mv.fieldInstruction(getOpcode(kind),\n+                    desc.refType().toNominalDescriptor(), desc.name(), desc.type().toNominalDescriptor());\n+        }\n+\n+        private static Opcode getOpcode(FieldKind kind) {\n+            return switch (kind) {\n+                case STATIC -> Opcode.PUTSTATIC;\n+                case INSTANCE -> Opcode.PUTFIELD;\n+            };\n+        }\n+\n+        private static FieldKind getFieldKind(Opcode opcode) {\n+            return switch (opcode) {\n+                case PUTSTATIC -> FieldKind.STATIC;\n+                case PUTFIELD -> FieldKind.INSTANCE;\n+                default -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n+    public static PutFieldInstructionOp putField(FieldKind kind, FieldDesc desc) {\n+        return new PutFieldInstructionOp(kind, desc);\n+    }\n+\n+    enum InvokeKind {\n+        STATIC, VIRTUAL, INTERFACE, SPECIAL,\n+    }\n+\n+    \/\/ @@@ static\/virtual\/special invocation on interfaces\n+    @Opcodes({Opcode.INVOKESTATIC, Opcode.INVOKEVIRTUAL, Opcode.INVOKEINTERFACE, Opcode.INVOKESPECIAL})\n+    @OpDeclaration(InvokeInstructionOp.NAME)\n+    public static final class InvokeInstructionOp extends InstructionOp {\n+        public static final String NAME = \"invoke\";\n+\n+        public static final String ATTRIBUTE_KIND = \"kind\";\n+        public static final String ATTRIBUTE_DESC = \"desc\";\n+        public static final String ATTRIBUTE_IFACE = \"iface\";\n+\n+        final InvokeKind kind;\n+        final MethodDesc desc;\n+        final boolean iface;\n+\n+        InvokeInstructionOp(InstructionDef<InvokeInstruction> def) {\n+            this(getInvokeKind(def.opcode()), getMethodDesc(def.instruction().method()), def.instruction().isInterface());\n+        }\n+\n+        InvokeInstructionOp(InvokeInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.kind = that.kind;\n+            this.desc = that.desc;\n+            this.iface = that.iface;\n+        }\n+\n+        @Override\n+        public InvokeInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InvokeInstructionOp(this, cc);\n+        }\n+\n+        InvokeInstructionOp(InvokeKind kind, MethodDesc desc, boolean iface) {\n+            super(NAME);\n+\n+            this.kind = kind;\n+            this.desc = desc;\n+            this.iface = iface;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_KIND, kind);\n+            m.put(ATTRIBUTE_DESC, desc);\n+            m.put(ATTRIBUTE_IFACE, iface);\n+            return m;\n+        }\n+\n+        public InvokeKind kind() {\n+            return kind;\n+        }\n+\n+        public MethodDesc desc() {\n+            return desc;\n+        }\n+\n+        public boolean iface() {\n+            return iface;\n+        }\n+\n+        public MethodTypeDesc callOpDescriptor() {\n+            return switch (kind) {\n+                case STATIC -> desc.type();\n+                case VIRTUAL, INTERFACE, SPECIAL -> {\n+                    List<TypeDesc> params = new ArrayList<>();\n+                    params.add(desc.refType());\n+                    params.addAll(desc.type().parameters());\n+                    yield MethodTypeDesc.methodType(desc.type().returnType(), params);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            MethodDesc desc = desc();\n+\n+            \/\/ @@@ interfaces\n+            mv.invokeInstruction(\n+                    getOpcode(kind()),\n+                    desc.refType().toNominalDescriptor(),\n+                    desc.name(),\n+                    desc.type().toNominalDescriptor(),\n+                    iface()\n+            );\n+        }\n+\n+        private static Opcode getOpcode(InvokeKind kind) {\n+            return switch (kind) {\n+                case STATIC -> Opcode.INVOKESTATIC;\n+                case VIRTUAL -> Opcode.INVOKEVIRTUAL;\n+                case INTERFACE -> Opcode.INVOKEINTERFACE;\n+                case SPECIAL -> Opcode.INVOKESPECIAL;\n+            };\n+        }\n+\n+        private static InvokeKind getInvokeKind(Opcode opcode) {\n+            return switch (opcode) {\n+                case INVOKESTATIC -> InvokeKind.STATIC;\n+                case INVOKEVIRTUAL -> InvokeKind.VIRTUAL;\n+                case INVOKEINTERFACE -> InvokeKind.INTERFACE;\n+                case INVOKESPECIAL -> InvokeKind.SPECIAL;\n+                default -> throw new InternalError();\n+            };\n+        }\n+\n+        private static MethodDesc getMethodDesc(MemberRefEntry node) {\n+            return MethodDesc.method(\n+                    TypeDesc.ofNominalDescriptor(node.owner().asSymbol()),\n+                    node.name().stringValue(),\n+                    MethodTypeDesc.ofNominalDescriptor(java.lang.constant.MethodTypeDesc.ofDescriptor(node.type().stringValue())));\n+        }\n+    }\n+\n+    public static InvokeInstructionOp invoke(InvokeKind kind, MethodDesc desc) {\n+        return new InvokeInstructionOp(kind, desc, false);\n+    }\n+\n+    public static InvokeInstructionOp invoke(InvokeKind kind, MethodDesc desc, boolean isInterface) {\n+        return new InvokeInstructionOp(kind, desc, isInterface);\n+    }\n+\n+    \/\/ Terminating instructions\n+\n+    @Opcodes(Opcode.GOTO)\n+    @OpDeclaration(GotoInstructionOp.NAME)\n+    public static final class GotoInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n+        public static final String NAME = \"goto\";\n+\n+        GotoInstructionOp(InstructionDef<BranchInstruction> def) {\n+            this(def.successors.get(0));\n+        }\n+\n+        GotoInstructionOp(GotoInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GotoInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GotoInstructionOp(this, cc);\n+        }\n+\n+        GotoInstructionOp(Block.Reference t) {\n+            super(NAME, List.of(t));\n+\n+            if (!t.arguments().isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public Block targetBranch() {\n+            return successors().get(0).targetBlock();\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.goto_(c.getLabel(targetBranch()));\n+        }\n+    }\n+\n+    public static GotoInstructionOp _goto(Block.Reference t) {\n+        return new GotoInstructionOp(t);\n+    }\n+\n+    enum Comparison {\n+        EQ(\"NE\"),\n+        NE(\"EQ\"),\n+        LT(\"GE\"),\n+        GE(\"LT\"),\n+        GT(\"LE\"),\n+        LE(\"GT\");\n+\n+        private final String inverseName;\n+\n+        Comparison(String inverseName) {\n+            this.inverseName = inverseName;\n+        }\n+\n+        public Comparison inverse() {\n+            return Comparison.valueOf(inverseName);\n+        }\n+    }\n+\n+    @Opcodes({Opcode.IF_ACMPEQ, Opcode.IF_ACMPNE,\n+            Opcode.IF_ICMPEQ, Opcode.IF_ICMPNE, Opcode.IF_ICMPLT, Opcode.IF_ICMPGE, Opcode.IF_ICMPGT, Opcode.IF_ICMPLE\n+    })\n+    @OpDeclaration(IfcmpInstructionOp.NAME)\n+    public static final class IfcmpInstructionOp extends TypedTerminatingInstructionOp implements Op.BlockTerminating {\n+        public static final String NAME = \"if_TcmpC\";\n+\n+        public static final String ATTRIBUTE_COND = \"cond\";\n+\n+        final Comparison cond;\n+\n+        IfcmpInstructionOp(InstructionDef<BranchInstruction> def) {\n+            this(def.instruction().opcode().primaryTypeKind(), getComparison(def.opcode()),\n+                    def.successors.get(0), def.successors.get(1));\n+        }\n+\n+        IfcmpInstructionOp(IfcmpInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.cond = that.cond;\n+        }\n+\n+        @Override\n+        public IfcmpInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IfcmpInstructionOp(this, cc);\n+        }\n+\n+        IfcmpInstructionOp(TypeKind type, Comparison c, Block.Reference t, Block.Reference f) {\n+            \/\/ Ensure successor order is false branch, then true branch, for correct topological ordering\n+            super(NAME, type, List.of(f, t));\n+\n+            if (type != TypeKind.IntType && type != TypeKind.ReferenceType) {\n+                throw new IllegalArgumentException(\"Unsupported type: \" + type);\n+            }\n+\n+            if (type == TypeKind.ReferenceType) {\n+                if (c != Comparison.EQ && c != Comparison.NE) {\n+                    throw new IllegalArgumentException(\"Unsupported condition for reference (A) type: \" + c);\n+                }\n+            }\n+\n+            if (!t.arguments().isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (!f.arguments().isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.cond = c;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = super._attributes();\n+            m.put(ATTRIBUTE_COND, cond);\n+            return m;\n+        }\n+\n+        public Comparison cond() {\n+            return cond;\n+        }\n+\n+        public Block trueBranch() {\n+            return successors().get(1).targetBlock();\n+        }\n+\n+        public Block falseBranch() {\n+            return successors().get(0).targetBlock();\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            \/\/ False branch must be immediately after (in sequence) to this block\n+            mv.branchInstruction(getOpcode(type(), cond()), c.getLabel(trueBranch()));\n+        }\n+\n+        private static Opcode getOpcode(TypeKind t, Comparison c) {\n+            return switch (t) {\n+                case ReferenceType -> switch (c) {\n+                    case EQ -> Opcode.IF_ACMPEQ;\n+                    case NE -> Opcode.IF_ACMPNE;\n+                    default -> throw new InternalError(\"Should not reach here\");\n+                };\n+                case IntType -> switch (c) {\n+                    case EQ -> Opcode.IF_ICMPEQ;\n+                    case NE -> Opcode.IF_ICMPNE;\n+                    case LT -> Opcode.IF_ICMPLT;\n+                    case GE -> Opcode.IF_ICMPGE;\n+                    case GT -> Opcode.IF_ICMPGT;\n+                    case LE -> Opcode.IF_ICMPLE;\n+                };\n+                default -> throw new InternalError(\"Should not reach here\");\n+            };\n+        }\n+\n+        private static Comparison getComparison(Opcode opcode) {\n+            return switch (opcode) {\n+                case IF_ACMPEQ -> Comparison.EQ;\n+                case IF_ACMPNE -> Comparison.NE;\n+                case IF_ICMPEQ -> Comparison.EQ;\n+                case IF_ICMPNE -> Comparison.NE;\n+                case IF_ICMPLT -> Comparison.LT;\n+                case IF_ICMPGE -> Comparison.GE;\n+                case IF_ICMPGT -> Comparison.GT;\n+                case IF_ICMPLE -> Comparison.LE;\n+                default -> throw new InternalError(\"Should not reach here\");\n+            };\n+        }\n+    }\n+\n+    public static IfcmpInstructionOp if_cmp(TypeKind type, Comparison c, Block.Reference t, Block.Reference f) {\n+        return new IfcmpInstructionOp(type, c, t, f);\n+    }\n+\n+    @Opcodes({Opcode.IFEQ, Opcode.IFNE,\n+            Opcode.IFLT, Opcode.IFGE, Opcode.IFGT, Opcode.IFLE\n+    })\n+    @OpDeclaration(IfInstructionOp.NAME)\n+    public static final class IfInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n+        public static final String NAME = \"ifC\";\n+\n+        public static final String ATTRIBUTE_COND = \"cond\";\n+\n+        final Comparison cond;\n+\n+        IfInstructionOp(InstructionDef<BranchInstruction> def) {\n+            this(getComparison(def.opcode()), def.successors.get(0), def.successors.get(1));\n+        }\n+\n+        IfInstructionOp(IfInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.cond = that.cond;\n+        }\n+\n+        IfInstructionOp(Comparison c, Block.Reference t, Block.Reference f) {\n+            \/\/ Ensure successor order is false branch, then true branch, for correct topological ordering\n+            super(NAME, List.of(f, t));\n+\n+            if (!t.arguments().isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (!f.arguments().isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.cond = c;\n+        }\n+\n+        @Override\n+        public IfInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IfInstructionOp(this, cc);\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_COND, cond);\n+            return m;\n+        }\n+\n+        public Comparison cond() {\n+            return cond;\n+        }\n+\n+        public Block trueBranch() {\n+            return successors().get(1).targetBlock();\n+        }\n+\n+        public Block falseBranch() {\n+            return successors().get(0).targetBlock();\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            \/\/ False branch must be immediately after (in sequence) to this block\n+            mv.branchInstruction(getOpcode(cond()), c.getLabel(trueBranch()));\n+        }\n+\n+        private static Opcode getOpcode(Comparison c) {\n+            return switch (c) {\n+                case EQ -> Opcode.IFEQ;\n+                case NE -> Opcode.IFNE;\n+                case LT -> Opcode.IFLT;\n+                case GE -> Opcode.IFGE;\n+                case GT -> Opcode.IFGT;\n+                case LE -> Opcode.IFLE;\n+            };\n+        }\n+\n+        private static Comparison getComparison(Opcode opcode) {\n+            return switch (opcode) {\n+                case IFEQ -> Comparison.EQ;\n+                case IFNE -> Comparison.NE;\n+                case IFLT -> Comparison.LT;\n+                case IFGE -> Comparison.GE;\n+                case IFGT -> Comparison.GT;\n+                case IFLE -> Comparison.LE;\n+                default -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n+    public static IfInstructionOp _if(Comparison c, Block.Reference t, Block.Reference f) {\n+        return new IfInstructionOp(c, t, f);\n+    }\n+\n+    @Opcodes({Opcode.ARETURN, Opcode.IRETURN, Opcode.LRETURN, Opcode.FRETURN, Opcode.DRETURN})\n+    @OpDeclaration(ReturnInstructionOp.NAME)\n+    public static final class ReturnInstructionOp extends TypedTerminatingInstructionOp implements Op.BodyTerminating {\n+        public static final String NAME = \"Treturn\";\n+\n+        ReturnInstructionOp(InstructionDef<ReturnInstruction> def) {\n+            this(def.instruction().typeKind());\n+        }\n+\n+        ReturnInstructionOp(ReturnInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        ReturnInstructionOp(TypeKind type) {\n+            super(NAME, type);\n+        }\n+\n+        @Override\n+        public ReturnInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnInstructionOp(this, cc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.returnInstruction(type());\n+        }\n+    }\n+\n+    @Opcodes(Opcode.RETURN)\n+    @OpDeclaration(VoidReturnInstructionOp.NAME)\n+    public static final class VoidReturnInstructionOp extends TerminatingInstructionOp implements Op.BodyTerminating {\n+        public static final String NAME = \"return\";\n+\n+        VoidReturnInstructionOp(InstructionDef<ReturnInstruction> def) {\n+            this();\n+        }\n+\n+        VoidReturnInstructionOp(VoidReturnInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        VoidReturnInstructionOp() {\n+            super(NAME);\n+        }\n+\n+        @Override\n+        public VoidReturnInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VoidReturnInstructionOp(this, cc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.return_();\n+        }\n+    }\n+\n+    public static ReturnInstructionOp _return(TypeKind type) {\n+        return new ReturnInstructionOp(type);\n+    }\n+\n+    public static VoidReturnInstructionOp _return() {\n+        return new VoidReturnInstructionOp();\n+    }\n+\n+    @Opcodes(Opcode.ATHROW)\n+    @OpDeclaration(AthrowInstructionOp.NAME)\n+    public static final class AthrowInstructionOp extends TerminatingInstructionOp implements Op.BodyTerminating {\n+        public static final String NAME = \"athrow\";\n+\n+        AthrowInstructionOp(InstructionDef<ThrowInstruction> def) {\n+            this();\n+        }\n+\n+        AthrowInstructionOp(AthrowInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        AthrowInstructionOp() {\n+            super(NAME);\n+        }\n+\n+        @Override\n+        public AthrowInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AthrowInstructionOp(this, cc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.athrow();\n+        }\n+    }\n+\n+    static public AthrowInstructionOp athrow() {\n+        return new AthrowInstructionOp();\n+    }\n+\n+    @Opcodes(Opcode.TABLESWITCH)\n+    @OpDeclaration(TableswitchInstructionOp.NAME)\n+    public static final class TableswitchInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n+        public static final String NAME = \"tableswitch\";\n+\n+        public static final String ATTRIBUTE_LOW = \"low\";\n+        public static final String ATTRIBUTE_HIGH = \"high\";\n+\n+        final int low;\n+        final int high;\n+\n+        TableswitchInstructionOp(InstructionDef<TableSwitchInstruction> def) {\n+            this(def.instruction().lowValue(), def.instruction().highValue(), def.successors);\n+        }\n+\n+        TableswitchInstructionOp(TableswitchInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.low = that.low;\n+            this.high = that.high;\n+        }\n+\n+        TableswitchInstructionOp(int low, int high, List<Block.Reference> successors) {\n+            super(NAME, successors);\n+\n+            if (low > high) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (high - low + 1 != successors.size()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.low = low;\n+            this.high = high;\n+        }\n+\n+        @Override\n+        public TableswitchInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TableswitchInstructionOp(this, cc);\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_LOW, low);\n+            m.put(ATTRIBUTE_HIGH, high);\n+            return m;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.tableswitch(low, high, c.getLabel(successors().get(0).targetBlock()), getSwitchCases(c));\n+        }\n+\n+        private List<SwitchCase> getSwitchCases(MethodVisitorContext c) {\n+            List<SwitchCase> cases = new ArrayList<>();\n+            int caseValue = low;\n+            for (int i = 1; i < successors.size(); i++) {\n+                cases.add(SwitchCase.of(caseValue++, c.getLabel(successors.get(i))));\n+            }\n+            return cases;\n+        }\n+    }\n+\n+    static public TableswitchInstructionOp tableswitch(int min, int max, List<Block.Reference> successors) {\n+        return new TableswitchInstructionOp(min, max, successors);\n+    }\n+\n+    @Opcodes(Opcode.LOOKUPSWITCH)\n+    @OpDeclaration(LookupswitchInstructionOp.NAME)\n+    public static final class LookupswitchInstructionOp extends TerminatingInstructionOp implements Op.BlockTerminating {\n+        public static final String NAME = \"lookupswitch\";\n+\n+        public static final String ATTRIBUTE_KEYS = \"keys\";\n+\n+        final List<Integer> keys;\n+\n+        LookupswitchInstructionOp(InstructionDef<LookupSwitchInstruction> def) {\n+            this(getKeys(def.instruction().cases()), def.successors);\n+        }\n+\n+        LookupswitchInstructionOp(LookupswitchInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.keys = that.keys;\n+        }\n+\n+        LookupswitchInstructionOp(List<Integer> keys, List<Block.Reference> successors) {\n+            super(NAME, successors);\n+\n+            if (keys.size() != successors.size() - 1) {\n+                throw new IllegalArgumentException(\"Number of keys must be one less than number of successors\");\n+            }\n+\n+            this.keys = List.copyOf(keys);\n+        }\n+\n+        @Override\n+        public LookupswitchInstructionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LookupswitchInstructionOp(this, cc);\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            m.put(ATTRIBUTE_KEYS, keys.toString());\n+            return m;\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            mv.lookupswitch(c.getLabel(successors().get(0).targetBlock()), getSwitchCases(c));\n+        }\n+\n+        private static List<Integer> getKeys(List<SwitchCase> cases) {\n+            return cases.stream().map(SwitchCase::caseValue).toList();\n+        }\n+\n+        private List<SwitchCase> getSwitchCases(MethodVisitorContext c) {\n+            List<SwitchCase> cases = new ArrayList<>();\n+            for (int i = 1; i < successors.size(); i++) {\n+                cases.add(SwitchCase.of(keys.get(i - 1), c.getLabel(successors.get(i))));\n+            }\n+            return cases;\n+        }\n+    }\n+\n+    static public LookupswitchInstructionOp lookupswitch(List<Integer> keys, List<Block.Reference> successors) {\n+        return new LookupswitchInstructionOp(keys, successors);\n+    }\n+\n+    \/\/ Internal control operations\n+\n+    public static abstract class ControlInstructionOp extends Op {\n+        ControlInstructionOp(ControlInstructionOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        ControlInstructionOp(String name, TypeDesc resultType, List<Value> operands) {\n+            super(name, resultType, operands);\n+        }\n+\n+        @Override\n+        public final Map<String, Object> attributes() {\n+            Map<String, Object> m = _attributes();\n+            return m.isEmpty() ? m : Collections.unmodifiableMap(m);\n+        }\n+\n+        Map<String, Object> _attributes() {\n+            return Map.of();\n+        }\n+\n+        public abstract void apply(CodeBuilder mv, MethodVisitorContext c);\n+    }\n+\n+    enum PrimitiveFrameType {\n+        TOP, INTEGER, FLOAT, DOUBLE, LONG, NULL, UNINITIALIZED_THIS\n+    }\n+\n+    public static class Frame extends ControlInstructionOp {\n+        public static final String NAME = \"frame\";\n+\n+        public static final String ATTRIBUTE_TYPE = \"type\";\n+        public static final String ATTRIBUTE_LOCAL = \"local\";\n+        public static final String ATTRIBUTE_STACK = \"stack\";\n+\n+        final StackMapFrameInfo node;\n+\n+        Frame(Frame that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.node = that.node;\n+        }\n+\n+        @Override\n+        public Frame transform(CopyContext cc, OpTransformer ot) {\n+            return new Frame(this, cc);\n+        }\n+\n+        Frame(StackMapFrameInfo node) {\n+            super(NAME, TypeDesc.VOID, List.of());\n+\n+            this.node = node;\n+        }\n+\n+        @Override\n+        Map<String, Object> _attributes() {\n+            Map<String, Object> m = new HashMap<>();\n+            \/\/ @@@ Convert local\/stack elements to types\n+            m.put(ATTRIBUTE_TYPE, node.frameType());\n+            m.put(ATTRIBUTE_LOCAL, node.locals().toString());\n+            m.put(ATTRIBUTE_STACK, node.stack().toString());\n+            return m;\n+        }\n+\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+        }\n+\n+        public boolean hasOperandStackElements() {\n+            return !node.stack().isEmpty();\n+        }\n+\n+        public List<TypeDesc> operandStackTypes() {\n+            List<TypeDesc> stackTypes = new ArrayList<>();\n+            for (StackMapFrameInfo.VerificationTypeInfo ost : node.stack()) {\n+                if (ost instanceof StackMapFrameInfo.SimpleVerificationTypeInfo i) {\n+                    switch (i) {\n+                        case ITEM_TOP -> {\n+                            \/\/ @@@\n+                            stackTypes.add(TypeDesc.J_L_OBJECT);\n+                        }\n+                        case ITEM_INTEGER -> {\n+                            stackTypes.add(TypeDesc.INT);\n+                        }\n+                        case ITEM_FLOAT -> {\n+                            stackTypes.add(TypeDesc.FLOAT);\n+                        }\n+                        case ITEM_DOUBLE -> {\n+                            stackTypes.add(TypeDesc.DOUBLE);\n+                        }\n+                        case ITEM_LONG -> {\n+                            stackTypes.add(TypeDesc.LONG);\n+                        }\n+                        case ITEM_NULL -> {\n+                            \/\/ @@@\n+                            stackTypes.add(TypeDesc.J_L_OBJECT);\n+                        }\n+                        case ITEM_UNINITIALIZED_THIS -> {\n+                            \/\/ @@@\n+                            stackTypes.add(TypeDesc.J_L_OBJECT);\n+                        }\n+                    }\n+                } else if (ost instanceof StackMapFrameInfo.ObjectVerificationTypeInfo i) {\n+                    stackTypes.add(TypeDesc.ofNominalDescriptor(i.classSymbol()));\n+                } else if (ost instanceof StackMapFrameInfo.UninitializedVerificationTypeInfo i) {\n+                    \/\/ @@@\n+                    \/\/ label designates the NEW instruction that created the uninitialized value\n+                }\n+            }\n+            return stackTypes;\n+        }\n+    }\n+\n+    public static Frame frame(StackMapFrameInfo node) {\n+        return new Frame(node);\n+    }\n+\n+\n+    public static final class ExceptionTableStart extends ControlInstructionOp implements Op.BlockTerminating {\n+        public static final String NAME = \"exceptionTableStart\";\n+\n+        \/\/ First successor is the non-exceptional successor whose target indicates\n+        \/\/ the first block in the exception region.\n+        \/\/ One or more subsequent successors target the exception catching blocks\n+        \/\/ each of which have one block argument whose type is an exception type,\n+        \/\/ or no block argument for the finally block (that occurs last)\n+        final List<Block.Reference> s;\n+\n+        ExceptionTableStart(ExceptionTableStart that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+        }\n+\n+        @Override\n+        public ExceptionTableStart transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionTableStart(this, cc);\n+        }\n+\n+        ExceptionTableStart(List<Block.Reference> s) {\n+            super(NAME, TypeDesc.VOID, List.of());\n+\n+            if (s.size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            }\n+\n+            this.s = List.copyOf(s);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return s;\n+        }\n+\n+        public Block.Reference start() {\n+            return s.get(0);\n+        }\n+\n+        public List<Block.Reference> catchBlocks() {\n+            return s.subList(1, s.size());\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            Label start = c.getLabel(result());\n+            c.exceptionRegionStack().push(this);\n+            mv.labelBinding(start);\n+        }\n+    }\n+\n+    public static ExceptionTableStart exceptionTableStart(Block.Reference start, Block.Reference... catchers) {\n+        return exceptionTableStart(start, List.of(catchers));\n+    }\n+\n+    public static ExceptionTableStart exceptionTableStart(Block.Reference start, List<Block.Reference> catchers) {\n+        List<Block.Reference> s = new ArrayList<>();\n+        s.add(start);\n+        s.addAll(catchers);\n+        return new ExceptionTableStart(s);\n+    }\n+\n+    public static final class ExceptionTableEnd extends ControlInstructionOp {\n+        public static final String NAME = \"exceptionTableEnd\";\n+\n+        ExceptionTableEnd(ExceptionTableEnd that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        ExceptionTableEnd() {\n+            super(NAME, TypeDesc.VOID, List.of());\n+        }\n+\n+        @Override\n+        public ExceptionTableEnd transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionTableEnd(this, cc);\n+        }\n+\n+        @Override\n+        public void apply(CodeBuilder mv, MethodVisitorContext c) {\n+            ExceptionTableStart er = c.exceptionRegionStack().pop();\n+            Label start = c.getLabel(er.result());\n+            Label end = c.getLabel(er);\n+            mv.labelBinding(end);\n+            for (Block.Reference catchBlockSuccessor : er.catchBlocks()) {\n+                Block catchBlock = catchBlockSuccessor.targetBlock();\n+                Label handle = c.getLabel(catchBlock);\n+\n+                if (!catchBlock.parameters().isEmpty()) {\n+                    ClassDesc type = catchBlock.parameters().get(0).type().toNominalDescriptor();\n+                    mv.exceptionCatch(start, end, handle, type);\n+                } else {\n+                    mv.exceptionCatchAll(start, end, handle);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static ExceptionTableEnd exceptionTableEnd() {\n+        return new ExceptionTableEnd();\n+    }\n+\n+\n+    \/\/ Opcode factory creation\n+\n+    public static InstructionOp create(InstructionDef<? extends Instruction> def) {\n+        MethodHandle mh = INSTRUCTION_FACTORY[def.opcode().bytecode()];\n+        if (mh == null) {\n+            throw new UnsupportedOperationException(\"Instruction unsupported, opcode = '\" + def.opcode());\n+        }\n+        try {\n+            return (InstructionOp) mh.invoke(def);\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    static final MethodHandle[] INSTRUCTION_FACTORY = createInstructionMapping();\n+\n+    static MethodHandle[] createInstructionMapping() {\n+        MethodHandle[] instructionFactory = new MethodHandle[ClassFile.GOTO_W + 1];\n+\n+        for (Class<?> opClass : BytecodeInstructionOps.class.getNestMembers()) {\n+            if (opClass.isAnnotationPresent(Opcodes.class)) {\n+                if (!Modifier.isPublic(opClass.getModifiers())) {\n+                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n+                }\n+\n+                if (!InstructionOp.class.isAssignableFrom(opClass)) {\n+                    throw new InternalError(\"Operation class is not assignable to Instruction: \" + opClass);\n+                }\n+\n+                MethodHandle handle = getOpcodeConstructorMethodHandle(opClass);\n+                if (handle == null) {\n+                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n+                }\n+\n+                if (!InstructionOp.class.isAssignableFrom(handle.type().returnType())) {\n+                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n+                }\n+\n+                Opcode[] opcodes = opClass.getAnnotation(Opcodes.class).value();\n+                for (Opcode opcode : opcodes) {\n+                    if (instructionFactory[opcode.bytecode()] != null) {\n+                        throw new InternalError(\"Opcode already assigned to \" + instructionFactory[opcode.bytecode()]);\n+                    }\n+                    instructionFactory[opcode.bytecode()] = handle;\n+                }\n+            }\n+        }\n+\n+        return instructionFactory;\n+    }\n+\n+    static MethodHandle getOpcodeConstructorMethodHandle(Class<?> opClass) {\n+        Optional<Constructor<?>> oc = Stream.of(opClass.getDeclaredConstructors())\n+                .filter(c -> c.getParameterCount() == 1)\n+                .filter(c -> InstructionDef.class.isAssignableFrom(c.getParameterTypes()[0]))\n+                .findFirst();\n+        Constructor<?> constructor = oc.orElse(null);\n+        if (constructor == null) {\n+            return null;\n+        }\n+\n+        try {\n+            return MethodHandles.lookup().unreflectConstructor(constructor);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                    constructor);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeInstructionOps.java","additions":2568,"deletions":0,"binary":false,"changes":2568,"status":"added"},{"patch":"@@ -0,0 +1,651 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.ExceptionCatch;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.classfile.instruction.LineNumber;\n+import java.lang.classfile.instruction.LocalVariable;\n+import java.lang.classfile.instruction.LocalVariableType;\n+import java.lang.classfile.instruction.LookupSwitchInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.classfile.instruction.TableSwitchInstruction;\n+import java.lang.classfile.instruction.ThrowInstruction;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class BytecodeLift {\n+\n+    BytecodeLift() {\n+    }\n+\n+    \/\/\n+    \/\/ Lift to core dialect\n+\n+    public static CoreOps.FuncOp liftToCoreDialect(CoreOps.FuncOp lf) {\n+        Body.Builder body = Body.Builder.of(null, lf.funcDescriptor());\n+        liftToCoreDialect(lf.body(), body);\n+        return CoreOps.func(lf.funcName(), body);\n+    }\n+\n+    \/\/ @@@ boolean, byte, short, and char are erased to int on the stack\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void liftToCoreDialect(Body lbody, Body.Builder c) {\n+        Block.Builder eb = c.entryBlock();\n+\n+        \/\/ Create blocks\n+        Map<Block, Block.Builder> blockMap = new HashMap<>();\n+        for (Block lb : lbody.blocks()) {\n+            Block.Builder b = lb.isEntryBlock() ? eb : eb.block();\n+            if (!lb.isEntryBlock()) {\n+                for (Block.Parameter lbp : lb.parameters()) {\n+                    b.parameter(lbp.type());\n+                }\n+            }\n+            blockMap.put(lb, b);\n+        }\n+\n+\n+        \/\/ @@@ catch\/finally handlers are disconnected block\n+        \/\/ treat as effectively separate bodies\n+\n+        \/\/ @@@ Needs to be cloned when there are two or more successors\n+        Map<Integer, Op.Result> locals = new HashMap<>();\n+        Deque<Value> stack = new ArrayDeque<>();\n+\n+        \/\/ Map Block arguments to local variables\n+        int lvm = 0;\n+        for (Block.Parameter bp : eb.parameters()) {\n+            \/\/ @@@ Reference type\n+            Op.Result local = eb.op(CoreOps.var(Integer.toString(lvm), bp));\n+            locals.put(lvm++, local);\n+        }\n+\n+        Set<Block> visited = new HashSet<>();\n+        Deque<Block> wl = new ArrayDeque<>();\n+        wl.push(lbody.entryBlock());\n+        while (!wl.isEmpty()) {\n+            Block lb = wl.pop();\n+            if (!visited.add(lb)) {\n+                continue;\n+            }\n+\n+            Block.Builder b = blockMap.get(lb);\n+\n+            \/\/ If a non-entry block has parameters then they correspond to stack arguments\n+            \/\/ Push back block parameters on the stack, in reverse order to preserve order on the stack\n+            if (b.parameters().size() > 0 && !b.isEntryBlock()) {\n+                for (int i = b.parameters().size() - 1; i >= 0; i--) {\n+                    stack.push(b.parameters().get(i));\n+                }\n+            }\n+\n+            int nops = lb.ops().size();\n+            for (int i = 0; i < nops - 1; i++) {\n+                Op lop = lb.ops().get(i);\n+\n+                if (lop instanceof BytecodeInstructionOps.LoadInstructionOp inst) {\n+                    Op.Result result = b.op(CoreOps.varLoad(locals.get(inst.slot())));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.StoreInstructionOp inst) {\n+                    Value operand = stack.pop();\n+\n+                    Op.Result local = locals.get(inst.slot());\n+                    if (local == null) {\n+                        local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n+                        locals.put(lvm++, local);\n+                    } else {\n+                        TypeDesc varType = ((CoreOps.VarOp) local.op()).varType();\n+                        if (!operand.type().equals(varType)) {\n+                            local = b.op(CoreOps.var(Integer.toString(lvm), operand));\n+                            locals.put(lvm++, local);\n+                        } else {\n+                            b.op(CoreOps.varStore(local, operand));\n+                        }\n+                    }\n+                } else if (lop instanceof BytecodeInstructionOps.IIncInstructionOp inst) {\n+                    Op.Result local = locals.get(inst.index());\n+                    Op.Result v1 = b.op(CoreOps.varLoad(local));\n+                    Op.Result v2 = b.op(CoreOps.constant(TypeDesc.INT, inst.incr()));\n+                    Op.Result result = b.op(CoreOps.add(v1, v2));\n+                    b.op(CoreOps.varStore(local, result));\n+                } else if (lop instanceof BytecodeInstructionOps.LdcInstructionOp inst) {\n+                    Op.Result result = b.op(CoreOps.constant(inst.type(), inst.value()));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.ConstInstructionOp inst) {\n+                    Op.Result result = b.op(CoreOps.constant(inst.typeDesc(), inst.value()));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.BipushInstructionOp inst) {\n+                    Op.Result result = b.op(CoreOps.constant(TypeDesc.INT, inst.value()));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.AddInstructionOp inst) {\n+                    Value operand2 = stack.pop();\n+                    Value operand1 = stack.pop();\n+                    Op.Result result = b.op(CoreOps.add(operand1, operand2));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.GetFieldInstructionOp inst) {\n+                    if (inst.kind() == BytecodeInstructionOps.FieldKind.INSTANCE) {\n+                        Value operand = stack.pop();\n+                        Op.Result result = b.op(CoreOps.fieldLoad(inst.desc(), operand));\n+                        stack.push(result);\n+                    } else {\n+                        Op.Result result = b.op(CoreOps.fieldLoad(inst.desc()));\n+                        stack.push(result);\n+                    }\n+                } else if (lop instanceof BytecodeInstructionOps.PutFieldInstructionOp inst) {\n+                    Value value = stack.pop();\n+                    if (inst.kind() == BytecodeInstructionOps.FieldKind.INSTANCE) {\n+                        Value receiver = stack.pop();\n+                        Op.Result result = b.op(CoreOps.fieldStore(inst.desc(), receiver, value));\n+                        stack.push(result);\n+                    } else {\n+                        Op.Result result = b.op(CoreOps.fieldStore(inst.desc(), value));\n+                        stack.push(result);\n+                    }\n+                } else if (lop instanceof BytecodeInstructionOps.ArrayStoreInstructionOp inst) {\n+                    Value value = stack.pop();\n+                    Value index = stack.pop();\n+                    Value array = stack.pop();\n+                    b.op(CoreOps.arrayStoreOp(array, index, value));\n+                } else if (lop instanceof BytecodeInstructionOps.ArrayLoadInstructionOp inst) {\n+                    Value index = stack.pop();\n+                    Value array = stack.pop();\n+                    Op.Result result = b.op(CoreOps.arrayLoadOp(array, index));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.ArrayLengthInstructionOp inst) {\n+                    Value array = stack.pop();\n+                    Op.Result result = b.op(CoreOps.arrayLength(array));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.InvokeInstructionOp inst) {\n+                    MethodTypeDesc descriptor = inst.callOpDescriptor();\n+\n+                    List<Value> operands = new ArrayList<>();\n+                    for (int p = 0; p < inst.desc().type().parameters().size(); p++) {\n+                        operands.add(stack.pop());\n+                    }\n+\n+                    switch (inst.kind()) {\n+                        case VIRTUAL:\n+                        case INTERFACE:\n+                            operands.add(stack.pop());\n+                            \/\/ Fallthrough\n+                        case STATIC: {\n+                            Collections.reverse(operands);\n+                            Op.Result result = b.op(CoreOps.invoke(descriptor.returnType(), inst.desc(), operands.toArray(Value[]::new)));\n+                            if (!result.type().equals(TypeDesc.VOID)) {\n+                                stack.push(result);\n+                            }\n+                            break;\n+                        }\n+                        case SPECIAL: {\n+                            if (inst.desc().name().equals(\"<init>\")) {\n+                                Collections.reverse(operands);\n+\n+                                TypeDesc ref = descriptor.parameters().get(0);\n+                                List<TypeDesc> params = descriptor.parameters().subList(1, descriptor.parameters().size());\n+                                MethodTypeDesc constructorDescriptor = MethodTypeDesc.methodType(ref, params);\n+                                Op.Result result = b.op(CoreOps._new(constructorDescriptor, operands.toArray(Value[]::new)));\n+                                stack.push(result);\n+                            } else {\n+                                operands.add(stack.pop());\n+                                Collections.reverse(operands);\n+                                Op.Result result = b.op(CoreOps.invoke(descriptor.returnType(), inst.desc(), operands.toArray(Value[]::new)));\n+                                if (!result.type().equals(TypeDesc.VOID)) {\n+                                    stack.push(result);\n+                                }\n+                                break;\n+                            }\n+                        }\n+\n+                    }\n+                } else if (lop instanceof BytecodeInstructionOps.NewInstructionOp inst) {\n+                    \/\/ Skip over this and the dup to process the invoke special\n+                    if (i + 2 >= nops - 1) {\n+                        throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial\");\n+                    }\n+                    Op dup = lb.ops().get(i + 1);\n+                    if (!(dup instanceof BytecodeInstructionOps.DupInstructionOp)) {\n+                        throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial\");\n+                    }\n+                    Op special = lb.ops().get(i + 2);\n+                    if (special instanceof BytecodeInstructionOps.InvokeInstructionOp invoke) {\n+                        if (!invoke.desc().name().equals(\"<init>\")) {\n+                            throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial for <init>\");\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException(\"new must be followed by dup and invokespecial\");\n+                    }\n+\n+                    i++;\n+                } else if (lop instanceof BytecodeInstructionOps.NewArrayInstructionOp inst) {\n+                    Value length = stack.pop();\n+                    Op.Result result = b.op(CoreOps.newArray(TypeDesc.type(inst.desc(), 1), length));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.MultiNewArrayInstructionOp inst) {\n+                    int dims = inst.dims();\n+                    Value[] counts = new Value[dims];\n+                    for (int d = dims - 1; d >= 0; d--) {\n+                        counts[d] = stack.pop();\n+                    }\n+                    MethodTypeDesc m = MethodTypeDesc.methodType(inst.desc(), Collections.nCopies(dims, TypeDesc.INT));\n+                    Op.Result result = b.op(CoreOps._new(m, counts));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.CheckCastInstructionOp inst) {\n+                    Value instance = stack.pop();\n+                    Op.Result result = b.op(CoreOps.cast(inst.desc(), instance));\n+                    stack.push(result);\n+                } else if (lop instanceof BytecodeInstructionOps.PopInstructionOp inst) {\n+                    stack.pop();\n+                } else if (lop instanceof BytecodeInstructionOps.DupInstructionOp inst) {\n+                    stack.push(stack.peek());\n+                } else if (lop instanceof BytecodeInstructionOps.Frame inst) {\n+                    \/\/ Ignore\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unsupported operation: \" + lop.opName());\n+                }\n+            }\n+\n+            Op ltop = lb.terminatingOp();\n+            if (ltop instanceof BytecodeInstructionOps.GotoInstructionOp inst) {\n+                Block slb = inst.successors().get(0).targetBlock();\n+                Block.Reference sb;\n+                \/\/ If the block has block parameters for stack operands then\n+                \/\/ pop arguments off the stack and use as successor arguments\n+                if (!slb.parameters().isEmpty()) {\n+                    List<Value> args = new ArrayList<>();\n+                    for (int x = 0; x < slb.parameters().size(); x++) {\n+                        args.add(stack.pop());\n+                    }\n+                    sb = blockMap.get(slb).successor(args);\n+                } else {\n+                    sb = blockMap.get(slb).successor();\n+                }\n+                b.op(CoreOps.branch(sb));\n+\n+                wl.push(slb);\n+            } else if (ltop instanceof BytecodeInstructionOps.IfInstructionOp inst) {\n+                Value operand = stack.pop();\n+                Value zero = b.op(CoreOps.constant(TypeDesc.INT, 0));\n+\n+                if (!stack.isEmpty()) {\n+                    throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                }\n+\n+                BytecodeInstructionOps.Comparison cond = inst.cond().inverse();\n+                Op cop = switch (cond) {\n+                    case EQ -> CoreOps.eq(operand, zero);\n+                    case NE -> CoreOps.neq(operand, zero);\n+                    case LT -> CoreOps.lt(operand, zero);\n+                    case GT -> CoreOps.gt(operand, zero);\n+                    default -> throw new UnsupportedOperationException(\"Unsupported condition \" + cond);\n+                };\n+\n+                Block fslb = inst.successors().get(0).targetBlock();\n+                Block tslb = inst.successors().get(1).targetBlock();\n+                b.op(CoreOps.conditionalBranch(b.op(cop), blockMap.get(fslb).successor(), blockMap.get(tslb).successor()));\n+\n+                wl.push(tslb);\n+                wl.push(fslb);\n+            } else if (ltop instanceof BytecodeInstructionOps.IfcmpInstructionOp inst) {\n+                Value operand2 = stack.pop();\n+                Value operand1 = stack.pop();\n+\n+                if (!stack.isEmpty()) {\n+                    throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                }\n+\n+                BytecodeInstructionOps.Comparison cond = inst.cond().inverse();\n+                Op cop = switch (cond) {\n+                    case EQ -> CoreOps.eq(operand1, operand2);\n+                    case NE -> CoreOps.neq(operand1, operand2);\n+                    case LT -> CoreOps.lt(operand1, operand2);\n+                    case GT -> CoreOps.gt(operand1, operand2);\n+                    default -> throw new UnsupportedOperationException(\"Unsupported condition \" + cond);\n+                };\n+\n+                Block tslb = inst.trueBranch();\n+                Block fslb = inst.falseBranch();\n+                b.op(CoreOps.conditionalBranch(b.op(cop), blockMap.get(fslb).successor(), blockMap.get(tslb).successor()));\n+\n+                wl.push(tslb);\n+                wl.push(fslb);\n+            } else if (ltop instanceof BytecodeInstructionOps.ReturnInstructionOp inst) {\n+                Value operand = stack.pop();\n+                b.op(CoreOps._return(operand));\n+            } else if (ltop instanceof BytecodeInstructionOps.VoidReturnInstructionOp inst) {\n+                b.op(CoreOps._return());\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported terminating operation: \" + ltop.opName());\n+            }\n+        }\n+    }\n+\n+\n+    \/\/\n+    \/\/ Lift to bytecode dialect\n+\n+    static final class LiftContext {\n+        final Map<BytecodeBasicBlock, Block.Builder> blockMap = new HashMap<>();\n+    }\n+\n+    public static CoreOps.FuncOp liftToBytecodeDialect(byte[] classdata, String methodName) {\n+        BytecodeMethodBody bcr = createBodyForMethod(classdata, methodName);\n+\n+        MethodTypeDesc methodTypeDescriptor = MethodTypeDesc.ofNominalDescriptor(bcr.methodModel.methodTypeSymbol());\n+\n+        CoreOps.FuncOp f = CoreOps.func(\n+                bcr.methodModel.methodName().stringValue(),\n+                methodTypeDescriptor).body(entryBlock -> {\n+            LiftContext c = new LiftContext();\n+\n+            \/\/ Create blocks\n+            int count = 0;\n+            for (BytecodeBasicBlock bcb : bcr.blocks) {\n+                Block.Builder b = count > 0 ? entryBlock.block() : entryBlock;\n+\n+                count++;\n+                c.blockMap.put(bcb, b);\n+            }\n+\n+            \/\/ Process blocks\n+            for (BytecodeBasicBlock bcb : bcr.blocks) {\n+                Block.Builder b = c.blockMap.get(bcb);\n+\n+                \/\/ Add exception parameter to catch handler blocks\n+                for (ExceptionCatch tryCatchBlock : bcr.codeModel.exceptionHandlers()) {\n+                    BytecodeBasicBlock handler = bcr.blockMap.get(tryCatchBlock.handler());\n+                    if (handler == bcb) {\n+                        if (b.parameters().size() == 0) {\n+                            TypeDesc throwableType = tryCatchBlock.catchType()\n+                                    .map(ClassEntry::asSymbol)\n+                                    .map(TypeDesc::ofNominalDescriptor)\n+                                    .orElse(null);\n+                            if (throwableType != null) {\n+                                b.parameter(throwableType);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+\n+                \/\/ If the frame has operand stack elements then represent as block arguments\n+                if (bcb.frame != null) {\n+                    BytecodeInstructionOps.Frame frame = BytecodeInstructionOps.frame(bcb.frame);\n+                    if (frame.hasOperandStackElements()) {\n+                        for (TypeDesc t : frame.operandStackTypes()) {\n+                            b.parameter(t);\n+                        }\n+                    }\n+                    b.op(frame);\n+                }\n+\n+                liftBytecodeBlock(bcr, bcb, b, c);\n+            }\n+        });\n+\n+        return f;\n+    }\n+\n+    static void liftBytecodeBlock(BytecodeMethodBody bcr, BytecodeBasicBlock bcb, Block.Builder b, LiftContext c) {\n+        int ni = bcb.instructions.size();\n+        for (int i = 0; i < ni - 1; i++) {\n+            CodeElement codeElement = bcb.instructions.get(i);\n+            if (codeElement instanceof LabelTarget labelTarget) {\n+                \/\/ Insert control instructions for exception start\/end bodies\n+                for (ExceptionCatch tryCatchBlock : bcr.codeModel.exceptionHandlers()) {\n+                    if (labelTarget.label() == tryCatchBlock.tryStart()) {\n+                        BytecodeBasicBlock handler = bcr.blockMap.get(tryCatchBlock.handler());\n+                        b.op(BytecodeInstructionOps.\n+                                exceptionTableStart(c.blockMap.get(handler).successor()));\n+                    } else if (labelTarget.label() == tryCatchBlock.tryEnd()) {\n+                        b.op(BytecodeInstructionOps.exceptionTableEnd());\n+                    }\n+                }\n+            } else if (codeElement instanceof LineNumber) {\n+                \/\/ @@@ Add special line number instructions\n+            } else if (codeElement instanceof LocalVariable) {\n+                \/\/ @@@\n+            } else if (codeElement instanceof LocalVariableType) {\n+                \/\/ @@@\n+            } else if (codeElement instanceof Instruction instruction) {\n+                var def = new BytecodeInstructionOps.InstructionDef<>(instruction);\n+                b.op(BytecodeInstructionOps.create(def));\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported code element: \" + codeElement);\n+            }\n+        }\n+\n+        \/\/ @@@ cast, select last Instruction, and adjust prior loop\n+        Instruction top = (Instruction) bcb.instructions.get(ni - 1);\n+        if (bcb.isImplicitTermination) {\n+            var def = new BytecodeInstructionOps.InstructionDef<>(top);\n+            b.op(BytecodeInstructionOps.create(def));\n+\n+            BytecodeBasicBlock succ = bcb.successors.get(0);\n+            b.op(BytecodeInstructionOps._goto(c.blockMap.get(succ).successor()));\n+        } else {\n+            List<Block.Reference> successors = bcb.successors.stream().map(s -> c.blockMap.get(s).successor()).toList();\n+            var def = new BytecodeInstructionOps.InstructionDef<>(top, successors);\n+            b.op(BytecodeInstructionOps.create(def));\n+        }\n+    }\n+\n+\n+    \/\/\n+    \/\/ Lift to basic blocks of code elements\n+\n+    record BytecodeMethodBody(MethodModel methodModel,\n+                              CodeModel codeModel,\n+                              List<BytecodeBasicBlock> blocks,\n+                              Map<Label, BytecodeBasicBlock> blockMap) {\n+    }\n+\n+    static final class BytecodeBasicBlock {\n+        final List<CodeElement> instructions;\n+\n+        final List<BytecodeBasicBlock> successors;\n+\n+        StackMapFrameInfo frame;\n+\n+        boolean isImplicitTermination;\n+\n+        public BytecodeBasicBlock() {\n+            this.instructions = new ArrayList<>();\n+            this.successors = new ArrayList<>();\n+        }\n+\n+        void setFrame(StackMapFrameInfo frame) {\n+            this.frame = frame;\n+        }\n+\n+        void setImplicitTermination() {\n+            isImplicitTermination = true;\n+        }\n+\n+        void addInstruction(CodeElement i) {\n+            instructions.add(i);\n+        }\n+\n+        CodeElement firstInstruction() {\n+            return instructions.get(0);\n+        }\n+\n+        CodeElement lastInstruction() {\n+            return instructions.get(instructions.size() - 1);\n+        }\n+\n+        void addSuccessor(BytecodeBasicBlock s) {\n+            successors.add(s);\n+        }\n+    }\n+\n+    static BytecodeMethodBody createBodyForMethod(byte[] classdata, String methodName) {\n+        MethodModel methodModel = ClassFile.of().parse(classdata).methods().stream()\n+                .filter(mm -> mm.methodName().equalsString(methodName))\n+                .findFirst().orElseThrow(() -> new IllegalArgumentException(\"Unknown method: \" + methodName));\n+\n+        return createBlocks(methodModel);\n+    }\n+\n+    static BytecodeMethodBody createBlocks(MethodModel methodModel) {\n+        CodeModel codeModel = methodModel.code().orElseThrow();\n+\n+        \/\/ Obtain stack map frames\n+        Map<Label, StackMapFrameInfo> labelToFrameMap = codeModel.attributes().stream()\n+                .<StackMapFrameInfo>mapMulti((a, consumer) -> {\n+                    if (a instanceof StackMapTableAttribute sa) {\n+                        sa.entries().forEach(consumer::accept);\n+                    }\n+                })\n+                .collect(Collectors.toMap(StackMapFrameInfo::target, sa -> sa));\n+\n+        \/\/ Construct list of basic blocks\n+        Map<Label, BytecodeBasicBlock> blockMap = new HashMap<>();\n+        List<BytecodeBasicBlock> blocks = new ArrayList<>();\n+        BytecodeBasicBlock currentBlock = new BytecodeBasicBlock();\n+        for (CodeElement ce : codeModel) {\n+            if (ce instanceof LabelTarget labelTarget) {\n+                StackMapFrameInfo frame = labelToFrameMap.get(labelTarget.label());\n+                if (frame != null) {\n+                    \/\/ Not first block, nor prior block with non-terminating instruction\n+                    if (!currentBlock.instructions.isEmpty()) {\n+                        blocks.add(currentBlock);\n+                        currentBlock = new BytecodeBasicBlock();\n+                    }\n+\n+                    currentBlock.setFrame(frame);\n+                }\n+\n+                blockMap.put(labelTarget.label(), currentBlock);\n+                currentBlock.addInstruction(ce);\n+            } else if (ce instanceof BranchInstruction ||\n+                    ce instanceof TableSwitchInstruction ||\n+                    ce instanceof LookupSwitchInstruction) {\n+                \/\/ End of block, branch\n+                currentBlock.addInstruction(ce);\n+\n+                blocks.add(currentBlock);\n+                currentBlock = new BytecodeBasicBlock();\n+            } else if (ce instanceof ReturnInstruction || ce instanceof ThrowInstruction) {\n+                \/\/ End of block, method terminating instruction,\n+                currentBlock.addInstruction(ce);\n+\n+                blocks.add(currentBlock);\n+                currentBlock = new BytecodeBasicBlock();\n+            } else {\n+                currentBlock.addInstruction(ce);\n+            }\n+        }\n+\n+        \/\/ Update successors\n+        for (int i = 0; i < blocks.size(); i++) {\n+            BytecodeBasicBlock b = blocks.get(i);\n+            CodeElement lastElement = b.lastInstruction();\n+            switch (lastElement) {\n+                case BranchInstruction bi -> {\n+                    switch (bi.opcode()) {\n+                        case GOTO, GOTO_W -> {\n+                            BytecodeBasicBlock branch = blockMap.get(bi.target());\n+                            b.addSuccessor(branch);\n+                        }\n+                        \/\/ Conditional branch\n+                        default -> {\n+                            assert !bi.opcode().isUnconditionalBranch();\n+\n+                            BytecodeBasicBlock tBranch = blockMap.get(bi.target());\n+                            BytecodeBasicBlock fBranch = blocks.get(i + 1);\n+                            \/\/ True branch is first\n+                            b.addSuccessor(tBranch);\n+                            \/\/ False (or continuation) branch is second\n+                            b.addSuccessor(fBranch);\n+                        }\n+                    }\n+                }\n+                case LookupSwitchInstruction si -> {\n+                    \/\/ Default label is first successor\n+                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+                    addSuccessors(si.cases(), blockMap, b);\n+                }\n+                case TableSwitchInstruction si -> {\n+                    \/\/ Default label is first successor\n+                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+                    addSuccessors(si.cases(), blockMap, b);\n+                }\n+                \/\/ @@@ Merge cases and use _, after merge with master\n+                case ReturnInstruction ri -> {\n+                    \/\/ Ignore, method terminating\n+                }\n+                case ThrowInstruction ti -> {\n+                    \/\/ Ignore, method terminating\n+                }\n+                default -> {\n+                    \/\/ Implicit goto next block, add explicitly\n+                    b.setImplicitTermination();\n+                    BytecodeBasicBlock branch = blocks.get(i + 1);\n+                    b.addSuccessor(branch);\n+                }\n+            }\n+        }\n+\n+        return new BytecodeMethodBody(methodModel, codeModel, blocks, blockMap);\n+    }\n+\n+    static void addSuccessors(List<SwitchCase> cases,\n+                              Map<Label, BytecodeBasicBlock> blockMap,\n+                              BytecodeBasicBlock b) {\n+        cases.stream().map(SwitchCase::target)\n+                .map(blockMap::get)\n+                .forEach(b::addSuccessor);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":651,"deletions":0,"binary":false,"changes":651,"status":"added"},{"patch":"@@ -0,0 +1,1006 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.TypeKind;\n+\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class BytecodeLower {\n+    private BytecodeLower() {\n+    }\n+\n+    public static CoreOps.FuncOp lowerToBytecodeDialect(CoreOps.FuncOp f) {\n+        return lowerToBytecodeDialect(MethodHandles.publicLookup(), f);\n+    }\n+\n+    public static CoreOps.FuncOp lowerToBytecodeDialect(MethodHandles.Lookup l, CoreOps.FuncOp f) {\n+        return lowerToBytecodeDialect(l, f, false);\n+    }\n+\n+    public static CoreOps.FuncOp lowerToBytecodeDialect(MethodHandles.Lookup lookup, CoreOps.FuncOp f, boolean neverFreeSlots) {\n+        CoreOps.FuncOp lf = CoreOps.func(f.funcName(), f.funcDescriptor()).body(block -> {\n+            Liveness l = new Liveness(f);\n+            LoweringContext c = new LoweringContext(lookup, l, neverFreeSlots);\n+            lowerBodyToBytecodeDialect(f.body(), block, c);\n+        });\n+        return lf;\n+    }\n+\n+    static final class LiveSlotSet {\n+        final boolean neverFreeSlots;\n+        final Map<Value, Integer> liveSet;\n+        final BitSet freeSlots;\n+\n+        public LiveSlotSet(boolean neverFreeSlots) {\n+            this.neverFreeSlots = neverFreeSlots;\n+            this.liveSet = new HashMap<>();\n+            this.freeSlots = new BitSet();\n+        }\n+\n+        void transitionLiveSlotSetFrom(LiveSlotSet that) {\n+            freeSlots.or(that.freeSlots);\n+\n+            \/\/ Filter dead values, those whose slots have been freed\n+            Iterator<Map.Entry<Value, Integer>> slots = that.liveSet.entrySet().iterator();\n+            while (slots.hasNext()) {\n+                var slot = slots.next();\n+                if (!freeSlots.get(slot.getValue())) {\n+                    liveSet.put(slot.getKey(), slot.getValue());\n+                }\n+            }\n+        }\n+\n+        int getSlot(Value v) {\n+            Integer slot = liveSet.get(v);\n+            if (slot == null) {\n+                throw new IllegalArgumentException(\"Value is not assigned a slot\");\n+            }\n+\n+            return slot;\n+        }\n+\n+        int assignSlot(Value v) {\n+            if (liveSet.containsKey(v)) {\n+                throw new IllegalArgumentException(\"Value is assigned a slot\");\n+            }\n+\n+            \/\/ If no uses then no slot is assigned\n+            Set<Op.Result> uses = v.uses();\n+            if (uses.isEmpty()) {\n+                \/\/ @@@\n+                return -1;\n+            }\n+\n+            \/\/ Find a free slot\n+            int slot = findSlot(slotsPerValue(v));\n+\n+            liveSet.put(v, slot);\n+            return slot;\n+        }\n+\n+        int getOrAssignSlot(Value v) {\n+            \/\/ If value is already active return slot\n+            Integer slotBox = liveSet.get(v);\n+            if (slotBox != null) {\n+                \/\/ Remove any free slot if present for reassignment\n+                freeSlots.clear(slotBox);\n+                if (slotsPerValue(v) == 2) {\n+                    freeSlots.clear(slotBox + 1);\n+                }\n+                return slotBox;\n+            }\n+\n+            \/\/ If no users then no slot is assigned\n+            Set<Op.Result> users = v.uses();\n+            if (users.isEmpty()) {\n+                \/\/ @@@\n+                return -1;\n+            }\n+\n+            \/\/ Find a free slot\n+            int slot = findSlot(slotsPerValue(v));\n+\n+            liveSet.put(v, slot);\n+            return slot;\n+        }\n+\n+        private int findSlot(int nSlots) {\n+            if (freeSlots.isEmpty()) {\n+                return createNewSlot();\n+            } else if (nSlots == 1) {\n+                int slot = freeSlots.nextSetBit(0);\n+                freeSlots.clear(slot);\n+                return slot;\n+            } else {\n+                assert nSlots == 2;\n+                \/\/ Find first 2 contiguous slots\n+                int slot = 0;\n+                slot = freeSlots.nextSetBit(slot);\n+                while (slot != -1) {\n+                    int next = freeSlots.nextSetBit(slot + 1);\n+                    if (next - slot == 1) {\n+                        freeSlots.clear(slot);\n+                        freeSlots.clear(next);\n+                        return slot;\n+                    }\n+\n+                    slot = next;\n+                }\n+                return createNewSlot();\n+            }\n+        }\n+\n+        private int createNewSlot() {\n+            int slot = 0;\n+            if (!liveSet.isEmpty()) {\n+                \/\/ @@@ this is inefficient, track mox slot value\n+                Map.Entry<Value, Integer> e = liveSet.entrySet().stream().reduce((e1, e2) -> {\n+                    return e1.getValue() >= e2.getValue()\n+                            ? e1 : e2;\n+                }).get();\n+                slot = e.getValue() + slotsPerValue(e.getKey());\n+            }\n+            return slot;\n+        }\n+\n+        void freeSlot(Value v) {\n+            if (neverFreeSlots) {\n+                return;\n+            }\n+\n+            \/\/ Add the value's slot to the free list, if present\n+            \/\/ The value and slot are still preserved in the live set,\n+            \/\/ so slots can still be queried, but no slots should be assigned\n+            \/\/ to new values until it is safe to do so\n+            Integer slot = liveSet.get(v);\n+            if (slot != null) {\n+                freeSlots.set(slot);\n+                if (slotsPerValue(v) == 2) {\n+                    freeSlots.set(slot + 1);\n+                }\n+            }\n+        }\n+\n+        static int slotsPerValue(Value x) {\n+            return x.type().equals(TypeDesc.DOUBLE) || x.type().equals(TypeDesc.LONG)\n+                    ? 2\n+                    : 1;\n+        }\n+    }\n+\n+    static final class LoweringContext {\n+        final MethodHandles.Lookup lookup;\n+        final boolean neverFreeSlots;\n+        final Liveness liveness;\n+        final Map<Block, LiveSlotSet> liveSet;\n+        final Map<Block, Block.Builder> blockMap;\n+        final Set<Block> catchingBlocks;\n+        final Map<Block, ExceptionRegionNode> coveredBlocks;\n+\n+        Block current;\n+\n+        LoweringContext(MethodHandles.Lookup lookup, Liveness liveness, boolean neverFreeSlots) {\n+            this.lookup = lookup;\n+            this.neverFreeSlots = neverFreeSlots;\n+            this.liveness = liveness;\n+            this.liveSet = new HashMap<>();\n+            this.blockMap = new HashMap<>();\n+            this.catchingBlocks = new HashSet<>();\n+            this.coveredBlocks = new HashMap<>();\n+        }\n+\n+        void setCurrentBlock(Block current) {\n+            this.current = current;\n+            liveSet.computeIfAbsent(current, b -> new LiveSlotSet(neverFreeSlots));\n+        }\n+\n+        LiveSlotSet liveSlotSet(Block b) {\n+            return liveSet.computeIfAbsent(b, _b -> new LiveSlotSet(neverFreeSlots));\n+        }\n+\n+        LiveSlotSet liveSlotSet() {\n+            return liveSet.get(current);\n+        }\n+\n+        int getSlot(Value v) {\n+            return liveSlotSet().getSlot(v);\n+        }\n+\n+        int assignSlot(Value v) {\n+            return liveSlotSet().assignSlot(v);\n+        }\n+\n+        int getOrAssignSlot(Value v) {\n+            return liveSlotSet().getOrAssignSlot(v);\n+        }\n+\n+        void freeSlot(Value v) {\n+            liveSlotSet().freeSlot(v);\n+        }\n+\n+        void freeSlotsOfOp(Op op) {\n+            for (Value v : op.operands()) {\n+                if (isLastUse(v, op)) {\n+                    freeSlot(v);\n+                }\n+            }\n+\n+            for (Block.Reference s : op.successors()) {\n+                for (Value v : s.arguments()) {\n+                    if (isLastUse(v, op)) {\n+                        freeSlot(v);\n+                    }\n+                }\n+            }\n+        }\n+\n+        void transitionLiveSlotSetTo(Block successor) {\n+            liveSlotSet(successor).transitionLiveSlotSetFrom(liveSlotSet());\n+        }\n+\n+        boolean isLastUse(Value v, Op op) {\n+            return liveness.isLastUse(v, op);\n+        }\n+\n+        public void mapBlock(Block b, Block.Builder lb) {\n+            blockMap.put(b, lb);\n+        }\n+\n+        public Block.Builder getLoweredBlock(Block b) {\n+            return blockMap.get(b);\n+        }\n+    }\n+\n+    private static TypeKind toTypeKind(TypeDesc t) {\n+        TypeDesc rbt = t.toBasicType();\n+\n+        if (rbt.equals(TypeDesc.INT)) {\n+            return TypeKind.IntType;\n+        } else if (rbt.equals(TypeDesc.LONG)) {\n+            return TypeKind.LongType;\n+        } else if (rbt.equals(TypeDesc.FLOAT)) {\n+            return TypeKind.FloatType;\n+        } else if (rbt.equals(TypeDesc.DOUBLE)) {\n+            return TypeKind.DoubleType;\n+        } else if (rbt.equals(TypeDesc.J_L_OBJECT)) {\n+            return TypeKind.ReferenceType;\n+        } else {\n+            throw new IllegalArgumentException(\"Bad type: \" + t);\n+        }\n+    }\n+\n+    private static BytecodeInstructionOps.Comparison toComparisonType(CoreOps.BinaryTestOp op) {\n+        if (op instanceof CoreOps.EqOp) {\n+            return BytecodeInstructionOps.Comparison.EQ;\n+        } else if (op instanceof CoreOps.GtOp) {\n+            return BytecodeInstructionOps.Comparison.GT;\n+        } else if (op instanceof CoreOps.LtOp) {\n+            return BytecodeInstructionOps.Comparison.LT;\n+        } else {\n+            throw new UnsupportedOperationException(op.opName());\n+        }\n+    }\n+\n+    record ExceptionRegionNode(CoreOps.ExceptionRegionEnter ere, int size, ExceptionRegionNode next) {\n+    }\n+\n+    static final ExceptionRegionNode NIL = new ExceptionRegionNode(null, 0, null);\n+\n+    private static void computeExceptionRegionMembership(Body r, LoweringContext c) {\n+        Set<Block> visited = new HashSet<>();\n+        Deque<Block> stack = new ArrayDeque<>();\n+        stack.push(r.entryBlock());\n+\n+        \/\/ Set of catching blocks\n+        Set<Block> catchingBlocks = c.catchingBlocks;\n+        \/\/ Map of block to stack of covered exception regions\n+        Map<Block, ExceptionRegionNode> coveredBlocks = c.coveredBlocks;\n+        \/\/ Compute exception region membership\n+        while (!stack.isEmpty()) {\n+            Block b = stack.pop();\n+            if (!visited.add(b)) {\n+                continue;\n+            }\n+\n+            Op top = b.terminatingOp();\n+            ExceptionRegionNode bRegions = coveredBlocks.get(b);\n+            if (top instanceof CoreOps.BranchOp bop) {\n+                if (bRegions != null) {\n+                    coveredBlocks.put(bop.branch().targetBlock(), bRegions);\n+                }\n+\n+                stack.push(bop.branch().targetBlock());\n+            } else if (top instanceof CoreOps.ConditionalBranchOp cop) {\n+                if (bRegions != null) {\n+                    coveredBlocks.put(cop.falseBranch().targetBlock(), bRegions);\n+                    coveredBlocks.put(cop.trueBranch().targetBlock(), bRegions);\n+                }\n+\n+                stack.push(cop.falseBranch().targetBlock());\n+                stack.push(cop.trueBranch().targetBlock());\n+            } else if (top instanceof CoreOps.ExceptionRegionEnter er) {\n+                ArrayList<Block.Reference> catchBlocks = new ArrayList<>(er.catchBlocks());\n+                Collections.reverse(catchBlocks);\n+                for (Block.Reference catchBlock : catchBlocks) {\n+                    catchingBlocks.add(catchBlock.targetBlock());\n+                    if (bRegions != null) {\n+                        coveredBlocks.put(catchBlock.targetBlock(), bRegions);\n+                    }\n+\n+                    stack.push(catchBlock.targetBlock());\n+                }\n+\n+                ExceptionRegionNode n;\n+                if (bRegions != null) {\n+                    n = new ExceptionRegionNode(er, bRegions.size + 1, bRegions);\n+                } else {\n+                    n = new ExceptionRegionNode(er, 1, NIL);\n+                }\n+                coveredBlocks.put(er.start().targetBlock(), n);\n+\n+                stack.push(er.start().targetBlock());\n+            } else if (top instanceof CoreOps.ExceptionRegionExit er) {\n+                assert bRegions != null;\n+\n+                if (bRegions.size() > 1) {\n+                    coveredBlocks.put(er.end().targetBlock(), bRegions.next());\n+                }\n+\n+                stack.push(er.end().targetBlock());\n+            }\n+        }\n+    }\n+\n+    private static void lowerBodyToBytecodeDialect(Body r, Block.Builder entryBlock, LoweringContext c) {\n+        computeExceptionRegionMembership(r, c);\n+\n+        \/\/ Copy blocks, preserving topological order\n+        \/\/ Lowered blocks have no arguments\n+        c.mapBlock(r.entryBlock(), entryBlock);\n+        List<Block> blocks = r.blocks();\n+        for (Block b : blocks.subList(1, blocks.size())) {\n+            Block.Builder lb;\n+            lb = entryBlock.block();\n+            c.mapBlock(b, lb);\n+        }\n+\n+        \/\/ Process blocks in topological order\n+        for (int bi = 0; bi < blocks.size(); bi++) {\n+            \/\/ Previous block in topological order\n+            Block pb = bi > 0 ? blocks.get(bi - 1) : null;\n+\n+            Block b = blocks.get(bi);\n+            c.setCurrentBlock(b);\n+            Block.Builder lb = c.getLoweredBlock(b);\n+            Block.Builder clb = lb;\n+\n+            \/\/ @@@ Generate linear exception ranges when generating bytecode?\n+\n+            \/\/ If disjoint adjacent blocks, then may need to insert linear exception region enter and exit operations\n+            if (pb != null && !b.predecessors().contains(pb)) {\n+                ExceptionRegionNode pbRegions = c.coveredBlocks.getOrDefault(pb, NIL);\n+                ExceptionRegionNode bRegions = c.coveredBlocks.getOrDefault(b, NIL);\n+                if (pbRegions.size() < bRegions.size()) {\n+                    \/\/ 1. pb < b\n+                    \/\/    A. enter regions in b up to that covered by pb\n+                    \/\/ @@@ is pbRegions always empty ?\n+\n+                    \/\/ Enter regions in reverse order\n+                    Deque<CoreOps.ExceptionRegionEnter> regions = new ArrayDeque<>();\n+                    while (pbRegions != bRegions && bRegions != NIL) {\n+                        regions.push(bRegions.ere);\n+                        bRegions = bRegions.next();\n+                    }\n+\n+                    for (CoreOps.ExceptionRegionEnter region : regions) {\n+                        Block.Builder exRegionEnter = lb.block();\n+                        lb.op(BytecodeInstructionOps.exceptionTableStart(\n+                                exRegionEnter.successor(),\n+                                region.catchBlocks().stream().map(b1 -> c.getLoweredBlock(b1.targetBlock()).successor()).toList()));\n+                        lb = exRegionEnter;\n+                    }\n+                } else if (pbRegions.size() > bRegions.size()) {\n+                    \/\/ 2. pb > b\n+                    \/\/    2.1 pb.exit\n+                    \/\/      2.1.1 pb.exit.target == b\n+                    \/\/        A. Nothing\n+                    \/\/      2.1.2 Otherwise,\n+                    \/\/        A. ??? Can this occur ???\n+                    \/\/    2.2 Otherwise,\n+                    \/\/      A. exit regions in pb up to that covered by b\n+                    if (!(pb.terminatingOp() instanceof CoreOps.ExceptionRegionExit ere)) {\n+                        lb.op(BytecodeInstructionOps.exceptionTableEnd());\n+                    } else {\n+                        ExceptionRegionNode tRegions = c.coveredBlocks.getOrDefault(ere.end().targetBlock(), NIL);\n+                        if (tRegions == bRegions) {\n+                        } else {\n+                            \/\/ @@@ Can this case occur?\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    }\n+                } else if (pb.terminatingOp() instanceof CoreOps.ExceptionRegionExit) {\n+                    \/\/ 3. pb == b\n+                    \/\/    3.1 pb.exit\n+                    \/\/      A. enter pb.exit region in b\n+                    \/\/         or replace pb.exit.target with pb.branch.target\n+                    \/\/    3.2 Otherwise,\n+                    \/\/      A. Nothing\n+                    Block.Builder exRegionEnter = lb.block();\n+                    lb.op(BytecodeInstructionOps.exceptionTableStart(\n+                            exRegionEnter.successor(),\n+                            bRegions.ere().catchBlocks().stream().map(b1 -> c.getLoweredBlock(b1.targetBlock()).successor()).toList()));\n+                    lb = exRegionEnter;\n+                }\n+            }\n+\n+            \/\/ Assign slots to block arguments\n+            b.parameters().forEach(c::getOrAssignSlot);\n+\n+            \/\/ If b is a catch block then the exception argument will be represented on the stack\n+            if (c.catchingBlocks.contains(b)) {\n+                \/\/ Retain block argument for exception table generation\n+                Block.Parameter ex = b.parameters().get(0);\n+                clb.parameter(ex.type());\n+\n+                \/\/ Store in slot if used, otherwise pop\n+                if (!ex.uses().isEmpty()) {\n+                    int slot = c.getSlot(ex);\n+                    lb.op(BytecodeInstructionOps.store(toTypeKind(ex.type()), slot));\n+                } else {\n+                    lb.op(BytecodeInstructionOps.pop());\n+                }\n+            }\n+\n+            List<Op> ops = b.ops();\n+            \/\/ True if the last result is retained on the stack for use as first operand of current operation\n+            boolean isLastOpResultOnStack = false;\n+            Op.Result oprOnStack = null;\n+            for (int i = 0; i < ops.size() - 1; i++) {\n+                Op op = ops.get(i);\n+                Op.Result opr = op.result();\n+                TypeDesc oprType = opr.type();\n+                TypeKind rvt = oprType.equals(TypeDesc.VOID) ? null : toTypeKind(oprType);\n+\n+                if (op instanceof CoreOps.ConstantOp constantOp) {\n+                    if (constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                        \/\/ Loading a class constant may throw an exception so it cannot be deferred\n+                        lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n+                    } else {\n+                        \/\/ Defer process to use, where constants are inlined\n+                        \/\/ This applies to both operands and successor arguments\n+                        rvt = null;\n+                    }\n+                } else if (op instanceof CoreOps.VarOp vop) {\n+                    \/\/     %1 : Var<int> = var %0 @\"i\";\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+                    isLastOpResultOnStack = false;\n+\n+                    \/\/ Use slot of variable result\n+                    int slot = c.assignSlot(opr);\n+                    lb.op(BytecodeInstructionOps.store(toTypeKind(vop.varType()), slot));\n+\n+                    \/\/ Ignore result\n+                    rvt = null;\n+                } else if (op instanceof CoreOps.VarAccessOp.VarLoadOp vaop) {\n+                    \/\/ Use slot of variable result\n+                    int slot = c.getSlot(op.operands().get(0));\n+\n+                    CoreOps.VarOp vop = vaop.varOp();\n+                    lb.op(BytecodeInstructionOps.load(toTypeKind(vop.varType()), slot));\n+                } else if (op instanceof CoreOps.VarAccessOp.VarStoreOp vaop) {\n+                    if (!isLastOpResultOnStack) {\n+                        Value operand = op.operands().get(1);\n+                        if (operand instanceof Op.Result or &&\n+                                or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                                !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                            lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n+                        } else {\n+                            int slot = c.getSlot(operand);\n+                            lb.op(BytecodeInstructionOps.load(toTypeKind(operand.type()), slot));\n+                        }\n+                        isLastOpResultOnStack = false;\n+                    }\n+\n+                    \/\/ Use slot of variable result\n+                    int slot = c.getSlot(op.operands().get(0));\n+\n+                    CoreOps.VarOp vop = vaop.varOp();\n+                    lb.op(BytecodeInstructionOps.store(toTypeKind(vop.varType()), slot));\n+                } else if (op instanceof CoreOps.NegOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.neg(rvt));\n+                } else if (op instanceof CoreOps.NotOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    \/\/ True block\n+                    Block.Builder ctBlock = lb.block();\n+                    \/\/ False block\n+                    Block.Builder cfBlock = lb.block();\n+                    \/\/ Merge block\n+                    Block.Builder mergeBlock = lb.block();\n+\n+                    lb.op(BytecodeInstructionOps._if(BytecodeInstructionOps.Comparison.NE, ctBlock.successor(), cfBlock.successor()));\n+\n+                    ctBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 0));\n+                    ctBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n+\n+                    cfBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 1));\n+                    cfBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n+\n+                    lb = mergeBlock;\n+                } else if (op instanceof CoreOps.AddOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.add(rvt));\n+                } else if (op instanceof CoreOps.SubOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.sub(rvt));\n+                } else if (op instanceof CoreOps.MulOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.mul(rvt));\n+                } else if (op instanceof CoreOps.DivOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.div(rvt));\n+                } else if (op instanceof CoreOps.ModOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.rem(rvt));\n+                } else if (op instanceof CoreOps.ArrayAccessOp.ArrayLoadOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.aload(rvt));\n+                } else if (op instanceof CoreOps.ArrayAccessOp.ArrayStoreOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    TypeKind evt = toTypeKind(op.operands().get(2).type());\n+                    lb.op(BytecodeInstructionOps.astore(evt));\n+                } else if (op instanceof CoreOps.ArrayLengthOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.arraylength());\n+                } else if (op instanceof CoreOps.BinaryTestOp btop) {\n+                    if (!isConditionForCondBrOp(btop)) {\n+                        lb = comparison(lb, op, toComparisonType(btop),\n+                                c, isLastOpResultOnStack);\n+                    } else {\n+                        \/\/ Processing is deferred to the CondBrOp, do not process the op result\n+                        rvt = null;\n+                    }\n+                } else if (op instanceof CoreOps.NewOp newOp) {\n+                    TypeDesc t = newOp.constructorDescriptor().returnType();\n+                    if (t.dimensions() > 0) {\n+                        processOperands(lb, op, c, isLastOpResultOnStack);\n+                        if (t.dimensions() == 1) {\n+                            lb.op(BytecodeInstructionOps.newarray(t.componentType()));\n+                        } else {\n+                            lb.op(BytecodeInstructionOps.multinewarray(t, op.operands().size()));\n+                        }\n+                    } else {\n+                        if (isLastOpResultOnStack) {\n+                            int slot = c.assignSlot(oprOnStack);\n+                            lb.op(BytecodeInstructionOps.store(rvt, slot));\n+                            isLastOpResultOnStack = false;\n+                            oprOnStack = null;\n+                        }\n+\n+                        lb.op(BytecodeInstructionOps._new(t));\n+                        lb.op(BytecodeInstructionOps.dup());\n+\n+                        processOperands(lb, op, c, false);\n+                        lb.op(BytecodeInstructionOps.invoke(BytecodeInstructionOps.InvokeKind.SPECIAL, MethodDesc.initMethod(newOp.constructorDescriptor())));\n+                    }\n+                } else if (op instanceof CoreOps.InvokeOp invokeOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    \/\/ @@@ Enhance method descriptor to include how the method is to be invoked\n+                    \/\/ Example result of DirectMethodHandleDesc.toString()\n+                    \/\/   INTERFACE_VIRTUAL\/IntBinaryOperator::applyAsInt(IntBinaryOperator,int,int)int\n+                    \/\/ This will avoid the need to reflectively operate on the descriptor\n+                    \/\/ which may be insufficient in certain cases.\n+                    DirectMethodHandleDesc.Kind descKind;\n+                    try {\n+                        descKind = resolveToMethodHandleDesc(c.lookup, invokeOp.invokeDescriptor()).kind();\n+                    } catch (ReflectiveOperationException e) {\n+                        \/\/ @@@ Approximate fallback\n+                        if (invokeOp.hasReceiver()) {\n+                            descKind = DirectMethodHandleDesc.Kind.VIRTUAL;\n+                        } else {\n+                            descKind = DirectMethodHandleDesc.Kind.STATIC;\n+                        }\n+                    }\n+\n+                    BytecodeInstructionOps.InvokeKind ik = switch (descKind) {\n+                        case STATIC, INTERFACE_STATIC -> BytecodeInstructionOps.InvokeKind.STATIC;\n+                        case VIRTUAL -> BytecodeInstructionOps.InvokeKind.VIRTUAL;\n+                        case INTERFACE_VIRTUAL -> BytecodeInstructionOps.InvokeKind.INTERFACE;\n+                        case SPECIAL, INTERFACE_SPECIAL -> BytecodeInstructionOps.InvokeKind.SPECIAL;\n+                        default -> throw new IllegalStateException(\"Bad method descriptor resolution: \" +\n+                                invokeOp.descriptor() + \" > \" + invokeOp.invokeDescriptor());\n+                    };\n+                    boolean isInterface = switch (descKind) {\n+                        case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> true;\n+                        default -> false;\n+                    };\n+                    lb.op(BytecodeInstructionOps.invoke(ik, invokeOp.invokeDescriptor(), isInterface));\n+\n+                    if (rvt == null && !op.operands().isEmpty()) {\n+                        isLastOpResultOnStack = false;\n+                    }\n+                } else if (op instanceof CoreOps.FieldAccessOp.FieldLoadOp fieldOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    if (fieldOp.operands().isEmpty()) {\n+                        lb.op(BytecodeInstructionOps.getField(BytecodeInstructionOps.FieldKind.STATIC, fieldOp.fieldDescriptor()));\n+                    } else {\n+                        lb.op(BytecodeInstructionOps.getField(BytecodeInstructionOps.FieldKind.INSTANCE, fieldOp.fieldDescriptor()));\n+                    }\n+                } else if (op instanceof CoreOps.FieldAccessOp.FieldStoreOp fieldOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+                    isLastOpResultOnStack = false;\n+\n+                    if (fieldOp.operands().size() == 1) {\n+                        lb.op(BytecodeInstructionOps.putField(BytecodeInstructionOps.FieldKind.STATIC, fieldOp.fieldDescriptor()));\n+                    } else {\n+                        lb.op(BytecodeInstructionOps.putField(BytecodeInstructionOps.FieldKind.INSTANCE, fieldOp.fieldDescriptor()));\n+                    }\n+                } else if (op instanceof CoreOps.InstanceOfOp instOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.instanceOf(instOp.type()));\n+                } else if (op instanceof CoreOps.CastOp castOp) {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    lb.op(BytecodeInstructionOps.checkCast(castOp.type()));\n+                } else {\n+                    throw new UnsupportedOperationException(\"Operation not supported: \" + op);\n+                }\n+\n+                \/\/ Free up slots for values that are no longer live\n+                c.freeSlotsOfOp(op);\n+\n+                \/\/ Assign slot to operation result\n+                if (rvt != null) {\n+                    if (!isResultOnlyUse(opr)) {\n+                        isLastOpResultOnStack = false;\n+                        oprOnStack = null;\n+                        int slot = c.assignSlot(opr);\n+                        lb.op(BytecodeInstructionOps.store(rvt, slot));\n+                    } else {\n+                        isLastOpResultOnStack = true;\n+                        oprOnStack = opr;\n+                    }\n+                }\n+            }\n+\n+            Op top = b.terminatingOp();\n+            c.freeSlotsOfOp(top);\n+            if (top instanceof CoreOps.ReturnOp op) {\n+                Value a = op.returnValue();\n+                if (a == null) {\n+                    lb.op(BytecodeInstructionOps._return());\n+                } else {\n+                    processOperands(lb, op, c, isLastOpResultOnStack);\n+\n+                    TypeKind vt = toTypeKind(a.type());\n+                    lb.op(BytecodeInstructionOps._return(vt));\n+                }\n+            } else if (top instanceof CoreOps.YieldOp op) {\n+                processOperands(lb, op, c, isLastOpResultOnStack);\n+                lb.op(CoreOps._yield());\n+            } else if (top instanceof CoreOps.ThrowOp _throw) {\n+                processOperands(lb, _throw, c, isLastOpResultOnStack);\n+\n+                lb.op(BytecodeInstructionOps.athrow());\n+            } else if (top instanceof CoreOps.BranchOp op) {\n+                assignBlockArguments(op, op.branch(), lb, c);\n+                lb.op(BytecodeInstructionOps._goto(c.getLoweredBlock(op.branch().targetBlock()).successor()));\n+            } else if (top instanceof CoreOps.ConditionalBranchOp cop) {\n+                if (getConditionForCondBrOp(cop) instanceof CoreOps.BinaryTestOp btop) {\n+                    \/\/ Processing of the BinaryTestOp was deferred, so it can be merged with CondBrOp\n+                    conditionalBranch(lb, btop, cop, c, isLastOpResultOnStack,\n+                            (_lb, tBlock, fBlock) -> {\n+                                \/\/ Inverse condition and ensure true block is the immediate successor, in sequence, of lb\n+                                var vt = toTypeKind(btop.operands().get(0).type());\n+                                var cond = toComparisonType(btop).inverse();\n+                                if (vt == TypeKind.IntType) {\n+                                    _lb.op(BytecodeInstructionOps.if_cmp(TypeKind.IntType, cond, fBlock.successor(), tBlock.successor()));\n+                                } else {\n+                                    _lb.op(BytecodeInstructionOps.cmp(vt));\n+                                    _lb.op(BytecodeInstructionOps._if(cond, fBlock.successor(), tBlock.successor()));\n+                                }\n+                            });\n+\n+                } else {\n+                    conditionalBranch(lb, cop, cop, c, isLastOpResultOnStack,\n+                            (_lb, tBlock, fBlock) -> {\n+                                _lb.op(BytecodeInstructionOps._if(BytecodeInstructionOps.Comparison.EQ, fBlock.successor(), tBlock.successor()));\n+                            });\n+                }\n+            } else if (top instanceof CoreOps.ExceptionRegionEnter er) {\n+                assignBlockArguments(er, er.start(), lb, c);\n+                lb.op(BytecodeInstructionOps.exceptionTableStart(c.getLoweredBlock(er.start().targetBlock()).successor(),\n+                        er.catchBlocks().stream().map(b1 -> c.getLoweredBlock(b1.targetBlock()).successor()).toList()));\n+\n+                for (Block.Reference catchBlock : er.catchBlocks()) {\n+                    c.transitionLiveSlotSetTo(catchBlock.targetBlock());\n+                }\n+            } else if (top instanceof CoreOps.ExceptionRegionExit er) {\n+                assignBlockArguments(er, er.end(), lb, c);\n+                lb.op(BytecodeInstructionOps.exceptionTableEnd());\n+                lb.op(BytecodeInstructionOps._goto(c.getLoweredBlock(er.end().targetBlock()).successor()));\n+            } else {\n+                throw new UnsupportedOperationException(\"Terminating operation not supported: \" + top);\n+            }\n+        }\n+    }\n+\n+    private static void processOperands(Block.Builder lb,\n+                                        Op op,\n+                                        LoweringContext c,\n+                                        boolean isLastOpResultOnStack) {\n+        for (int i = isLastOpResultOnStack ? 1 : 0; i < op.operands().size(); i++) {\n+            Value operand = op.operands().get(i);\n+            if (operand instanceof Op.Result or &&\n+                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n+            } else {\n+                int slot = c.getSlot(operand);\n+                lb.op(BytecodeInstructionOps.load(toTypeKind(operand.type()), slot));\n+            }\n+        }\n+    }\n+\n+    \/\/ Determines if the operation result used only by the next operation as the first operand\n+    private static boolean isResultOnlyUse(Op.Result opr) {\n+        Set<Op.Result> uses = opr.uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+\n+        \/\/ Pass over constant operations\n+        Op.Result use = uses.iterator().next();\n+        Op nextOp = opr.op();\n+        do {\n+            nextOp = opr.declaringBlock().nextOp(nextOp);\n+        } while (nextOp instanceof CoreOps.ConstantOp);\n+\n+        if (nextOp == null || use != nextOp.result()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : nextOp.successors()) {\n+            if (s.arguments().contains(opr)) {\n+                return false;\n+            }\n+        }\n+\n+        List<Value> operands = nextOp.operands();\n+        return operands.size() > 0 && opr == operands.get(0);\n+    }\n+\n+    private static boolean isConditionForCondBrOp(CoreOps.BinaryTestOp op) {\n+        \/\/ Result of op has one use as the operand of a CondBrOp op,\n+        \/\/ and both ops are in the same block\n+\n+        Set<Op.Result> uses = op.result().uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+        Op.Result use = uses.iterator().next();\n+\n+        if (use.declaringBlock() != op.parentBlock()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : use.op().successors()) {\n+            if (s.arguments().contains(op.result())) {\n+                return false;\n+            }\n+        }\n+\n+        return use.op() instanceof CoreOps.ConditionalBranchOp;\n+    }\n+\n+    private static Op getConditionForCondBrOp(CoreOps.ConditionalBranchOp op) {\n+        Value p = op.predicate();\n+        if (p.uses().size() != 1) {\n+            return null;\n+        }\n+\n+        if (p.declaringBlock() != op.parentBlock()) {\n+            return null;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : op.successors()) {\n+            if (s.arguments().contains(p)) {\n+                return null;\n+            }\n+        }\n+\n+        if (p instanceof Op.Result or) {\n+            return or.op();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static Block.Builder comparison(Block.Builder lb,\n+                                            Op btop,\n+                                            BytecodeInstructionOps.Comparison cond, LoweringContext c,\n+                                            boolean isLastOpResultOnStack) {\n+        processOperands(lb, btop, c, isLastOpResultOnStack);\n+\n+        TypeKind vt = toTypeKind(btop.operands().get(0).type());\n+\n+        \/\/ Inverse condition and ensure true block is the immediate successor, in sequence, of lb\n+        cond = cond.inverse();\n+        \/\/ True block\n+        Block.Builder ctBlock = lb.block();\n+        \/\/ False block\n+        Block.Builder cfBlock = lb.block();\n+        \/\/ Merge block\n+        Block.Builder mergeBlock = lb.block();\n+        if (vt == TypeKind.IntType) {\n+            lb.op(BytecodeInstructionOps.if_cmp(TypeKind.IntType, cond, cfBlock.successor(), ctBlock.successor()));\n+        } else {\n+            lb.op(BytecodeInstructionOps.cmp(vt));\n+            lb.op(BytecodeInstructionOps._if(cond, cfBlock.successor(), ctBlock.successor()));\n+        }\n+\n+        ctBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 1));\n+        ctBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n+\n+        cfBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 0));\n+        cfBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n+\n+        return mergeBlock;\n+    }\n+\n+    interface ConditionalBranchConsumer {\n+        void accept(Block.Builder lb, Block.Builder tBlock, Block.Builder fBlock);\n+    }\n+\n+    private static void conditionalBranch(Block.Builder lb,\n+                                          Op operandOp, CoreOps.ConditionalBranchOp cop,\n+                                          LoweringContext c,\n+                                          boolean isLastOpResultOnStack,\n+                                          ConditionalBranchConsumer cbc) {\n+        processOperands(lb, operandOp, c, isLastOpResultOnStack);\n+\n+        Block.Builder tBlock = lb.block();\n+        Block.Builder fBlock = lb.block();\n+\n+        cbc.accept(lb, tBlock, fBlock);\n+\n+        assignBlockArguments(cop, cop.trueBranch(), tBlock, c);\n+        tBlock.op(BytecodeInstructionOps._goto(c.getLoweredBlock(cop.trueBranch().targetBlock()).successor()));\n+\n+        assignBlockArguments(cop, cop.falseBranch(), fBlock, c);\n+        fBlock.op(BytecodeInstructionOps._goto(c.getLoweredBlock(cop.falseBranch().targetBlock()).successor()));\n+    }\n+\n+    private static void assignBlockArguments(Op op, Block.Reference s, Block.Builder lb, LoweringContext c) {\n+        List<Value> sargs = s.arguments();\n+        List<Block.Parameter> bargs = s.targetBlock().parameters();\n+\n+        \/\/ Transition over live-out to successor block\n+        \/\/ All predecessors of successor will have the same live-out set so it does not\n+        \/\/ matter which predecessor performs this action\n+        c.transitionLiveSlotSetTo(s.targetBlock());\n+\n+        \/\/ First push successor arguments on the stack, then pop and assign\n+        \/\/ so as not to overwrite slots that are reused slots at different argument positions\n+\n+        \/\/ Push successor values on the stack\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n+\n+            Value value = sargs.get(i);\n+            if (value instanceof Op.Result or &&\n+                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n+            } else {\n+                int sslot = c.getSlot(value);\n+\n+                \/\/ Assignment only required if slots differ\n+                if (sslot != bslot) {\n+                    TypeKind vt = toTypeKind(barg.type());\n+                    lb.op(BytecodeInstructionOps.load(vt, sslot));\n+                }\n+            }\n+        }\n+\n+        \/\/ Pop successor arguments on the stack assigning to block argument slots if necessary\n+        for (int i = bargs.size() - 1; i >= 0; i--) {\n+            Block.Parameter barg = bargs.get(i);\n+            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n+\n+            Value value = sargs.get(i);\n+            if (value instanceof Op.Result or &&\n+                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                TypeKind vt = toTypeKind(barg.type());\n+                lb.op(BytecodeInstructionOps.store(vt, bslot));\n+            } else {\n+                int sslot = c.getSlot(value);\n+\n+                \/\/ Assignment only required if slots differ\n+                if (sslot != bslot) {\n+                    TypeKind vt = toTypeKind(barg.type());\n+                    lb.op(BytecodeInstructionOps.store(vt, bslot));\n+                }\n+            }\n+        }\n+    }\n+\n+    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l, MethodDesc d) throws ReflectiveOperationException {\n+        MethodHandle mh = d.resolve(l);\n+\n+        if (mh.describeConstable().isEmpty()) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        MethodHandleDesc mhd = mh.describeConstable().get();\n+        if (!(mhd instanceof DirectMethodHandleDesc dmhd)) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        return dmhd;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLower.java","additions":1006,"deletions":0,"binary":false,"changes":1006,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for generating bytecode from code models and for generating code models from bytecode.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor;\n+\n+import java.lang.reflect.code.descriptor.impl.FieldDescImpl;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+\n+\/**\n+ * The symbolic description of a Java field.\n+ *\/\n+public sealed interface FieldDesc permits FieldDescImpl {\n+    TypeDesc refType();\n+\n+    String name();\n+\n+    TypeDesc type();\n+\n+    \/\/ Conversions\n+\n+    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    VarHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static FieldDesc field(Field f) {\n+        return field(f.getDeclaringClass(), f.getName(), f.getType());\n+    }\n+\n+    static FieldDesc field(Class<?> refType, String name, Class<?> type) {\n+        return field(TypeDesc.type(refType), name, TypeDesc.type(type));\n+    }\n+\n+    static FieldDesc field(TypeDesc refType, String name, TypeDesc type) {\n+        return new FieldDescImpl(refType, name, type);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static FieldDesc ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseFieldDesc(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/FieldDesc.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+package java.lang.reflect.code.descriptor;\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.descriptor.impl.MethodDescImpl;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+\n+\/**\n+ * The symbolic description of a Java method.\n+ *\/\n+\/\/ @@@ require invoke kind:\n+\/\/    special, static, virtual\n+\/\/    interface_special, interface_static, interface_virtual\n+\/\/  Otherwise it is not possible to generate correct bytecode invoke instruction with\n+\/\/  a symbolic reference to a method or an interface method, specifically a\n+\/\/  constant pool entry of CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info.\n+\/\/\n+\/\/  We can infer the kind, if we can resolve the types and lookup the declared method\n+public sealed interface MethodDesc permits MethodDescImpl {\n+\n+    TypeDesc refType();\n+\n+    String name();\n+\n+    MethodTypeDesc type();\n+\n+    \/\/ Conversions\n+\n+    Executable resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    MethodHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static MethodDesc method(Method m) {\n+        return method(m.getDeclaringClass(), m.getName(), m.getReturnType(), m.getParameterTypes());\n+    }\n+\n+    static MethodDesc method(Class<?> refType, String name, MethodType mt) {\n+        return method(TypeDesc.type(refType), name, MethodTypeDesc.methodType(mt));\n+    }\n+\n+    static MethodDesc method(Class<?> refType, String name, Class<?> retType, Class<?>... params) {\n+        return method(TypeDesc.type(refType), name, methodType(retType, params));\n+    }\n+\n+    static MethodDesc method(Class<?> refType, String name, Class<?> retType, List<Class<?>> params) {\n+        return method(TypeDesc.type(refType), name, methodType(retType, params));\n+    }\n+\n+    static MethodDesc initMethod(MethodTypeDesc mt) {\n+        return new MethodDescImpl(\n+                mt.returnType(),\n+                \"<init>\",\n+                MethodTypeDesc.methodType(TypeDesc.VOID, mt.parameters()));\n+    }\n+\n+    static MethodDesc method(TypeDesc refType, String name, MethodTypeDesc type) {\n+        return new MethodDescImpl(refType, name, type);\n+    }\n+\n+    static MethodDesc method(TypeDesc refType, String name, TypeDesc retType, TypeDesc... params) {\n+        return method(refType, name, methodType(retType, params));\n+    }\n+\n+    static MethodDesc method(TypeDesc refType, String name, TypeDesc retType, List<TypeDesc> params) {\n+        return method(refType, name, methodType(retType, params));\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodDesc ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodDesc(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodDesc.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor;\n+\n+import java.lang.reflect.code.descriptor.impl.MethodTypeDescImpl;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+\n+\/**\n+ * The symbolic description of a method type, comprising descriptions of zero or more parameter types and a return type.\n+ *\/\n+public sealed interface MethodTypeDesc permits MethodTypeDescImpl {\n+    MethodTypeDesc VOID = methodType(TypeDesc.VOID);\n+\n+    \/\/\n+\n+    TypeDesc returnType();\n+\n+    List<TypeDesc> parameters();\n+\n+    \/\/ Conversions\n+\n+    MethodTypeDesc erase();\n+\n+    String toNominalDescriptorString();\n+\n+    default java.lang.constant.MethodTypeDesc toNominalDescriptor() {\n+        return java.lang.constant.MethodTypeDesc.ofDescriptor(toNominalDescriptorString());\n+    }\n+\n+    @SuppressWarnings(\"cast\")\n+    default MethodType resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        return toNominalDescriptor().resolveConstantDesc(l);\n+    }\n+\n+    \/\/ Factories\n+\n+    static MethodTypeDesc methodType(MethodType mt) {\n+        return methodType(mt.returnType(), mt.parameterList());\n+    }\n+\n+    static MethodTypeDesc methodType(Class<?> ret, Class<?>... params) {\n+        return methodType(ret, List.of(params));\n+    }\n+\n+    static MethodTypeDesc methodType(Class<?> ret, List<Class<?>> params) {\n+        return new MethodTypeDescImpl(TypeDesc.type(ret), params.stream().map(TypeDesc::type).toList());\n+    }\n+\n+    static MethodTypeDesc ofNominalDescriptor(java.lang.constant.MethodTypeDesc d) {\n+        return methodType(TypeDesc.ofNominalDescriptor(d.returnType()),\n+                d.parameterList().stream().map(TypeDesc::ofNominalDescriptor).toList());\n+    }\n+\n+    static MethodTypeDesc ofNominalDescriptorString(String d) {\n+        return ofNominalDescriptor(java.lang.constant.MethodTypeDesc.ofDescriptor(d));\n+    }\n+\n+    static MethodTypeDesc methodType(TypeDesc ret, TypeDesc... params) {\n+        return methodType(ret, List.of(params));\n+    }\n+\n+    static MethodTypeDesc methodType(TypeDesc ret, List<TypeDesc> params) {\n+        return new MethodTypeDescImpl(ret, params);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodTypeDesc ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodTypeDesc(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/MethodTypeDesc.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor;\n+\n+import java.lang.reflect.code.descriptor.impl.RecordTypeDescImpl;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The symbolic description of a Java record type.\n+ *\/\n+public sealed interface RecordTypeDesc permits RecordTypeDescImpl {\n+    TypeDesc recordType();\n+\n+    \/**\n+     * The symbolic description a Java record component.\n+     * @param type the type of the component\n+     * @param name the name of the component\n+     *\/\n+    record ComponentDesc(TypeDesc type, String name) {}\n+\n+    List<ComponentDesc> components();\n+\n+    MethodDesc methodForComponent(int i);\n+\n+    \/\/ Factories\n+\n+    static RecordTypeDesc recordType(Class<? extends Record> c) {\n+        List<ComponentDesc> components = Stream.of(c.getRecordComponents())\n+                .map(rc -> new ComponentDesc(TypeDesc.type(rc.getType()), rc.getName()))\n+                .toList();\n+        return recordType(TypeDesc.type(c), components);\n+    }\n+\n+    static RecordTypeDesc recordType(TypeDesc recordType, ComponentDesc... components) {\n+        return recordType(recordType, List.of(components));\n+    }\n+\n+    static RecordTypeDesc recordType(TypeDesc recordType, List<ComponentDesc> components) {\n+        return new RecordTypeDescImpl(recordType, components);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static RecordTypeDesc ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseRecordTypeDesc(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/RecordTypeDesc.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+\n+\/**\n+ * The symbolic description of a type.\n+ *\/\n+public sealed interface TypeDesc permits TypeDescImpl {\n+\n+    TypeDesc VOID = new TypeDescImpl(\"void\");\n+\n+    TypeDesc BOOLEAN = new TypeDescImpl(\"boolean\");\n+\n+    TypeDesc J_L_BOOLEAN = new TypeDescImpl(\"java.lang.Boolean\");\n+\n+    TypeDesc BOOLEAN_ARRAY = new TypeDescImpl(\"boolean\", 1);\n+\n+    TypeDesc BYTE = new TypeDescImpl(\"byte\");\n+\n+    TypeDesc J_L_BYTE = new TypeDescImpl(\"java.lang.Byte\");\n+\n+    TypeDesc BYTE_ARRAY = new TypeDescImpl(\"byte\", 1);\n+\n+    TypeDesc CHAR = new TypeDescImpl(\"char\");\n+\n+    TypeDesc J_L_CHARACTER = new TypeDescImpl(\"java.lang.Character\");\n+\n+    TypeDesc CHAR_ARRAY = new TypeDescImpl(\"char\", 1);\n+\n+    TypeDesc SHORT = new TypeDescImpl(\"short\");\n+\n+    TypeDesc J_L_SHORT = new TypeDescImpl(\"java.lang.Short\");\n+\n+    TypeDesc SHORT_ARRAY = new TypeDescImpl(\"short\", 1);\n+\n+    TypeDesc INT = new TypeDescImpl(\"int\");\n+\n+    TypeDesc J_L_INTEGER = new TypeDescImpl(\"java.lang.Integer\");\n+\n+    TypeDesc INT_ARRAY = new TypeDescImpl(\"int\", 1);\n+\n+    TypeDesc LONG = new TypeDescImpl(\"long\");\n+\n+    TypeDesc J_L_LONG = new TypeDescImpl(\"java.lang.Long\");\n+\n+    TypeDesc LONG_ARRAY = new TypeDescImpl(\"long\", 1);\n+\n+    TypeDesc FLOAT = new TypeDescImpl(\"float\");\n+\n+    TypeDesc J_L_FLOAT = new TypeDescImpl(\"java.lang.Float\");\n+\n+    TypeDesc FLOAT_ARRAY = new TypeDescImpl(\"float\", 1);\n+\n+    TypeDesc DOUBLE = new TypeDescImpl(\"double\");\n+\n+    TypeDesc J_L_DOUBLE = new TypeDescImpl(\"java.lang.Double\");\n+\n+    TypeDesc DOUBLE_ARRAY = new TypeDescImpl(\"double\", 1);\n+\n+    TypeDesc J_L_OBJECT = new TypeDescImpl(\"java.lang.Object\");\n+\n+    TypeDesc J_L_OBJECT_ARRAY = new TypeDescImpl(\"java.lang.Object\", 1);\n+\n+    TypeDesc J_L_CLASS = new TypeDescImpl(\"java.lang.Class\");\n+\n+    TypeDesc J_L_STRING = new TypeDescImpl(\"java.lang.String\");\n+\n+    \/\/\n+\n+    boolean isArray();\n+\n+    int dimensions();\n+\n+    TypeDesc componentType();\n+\n+    TypeDesc rawType();\n+\n+    boolean hasTypeArguments();\n+\n+    List<TypeDesc> typeArguments();\n+\n+    \/\/ Conversions\n+\n+    TypeDesc toBasicType();\n+\n+    String toClassName();\n+\n+    String toInternalName();\n+\n+    String toNominalDescriptorString();\n+\n+    default ClassDesc toNominalDescriptor() {\n+        return ClassDesc.ofDescriptor(toNominalDescriptorString());\n+    }\n+\n+    default Class<?> resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        return (Class<?>) toNominalDescriptor().resolveConstantDesc(l);\n+    }\n+\n+    \/\/ Factories\n+\n+    static TypeDesc type(Class<?> c) {\n+        int dims = 0;\n+        if (c.isArray()) {\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+                dims++;\n+            }\n+        }\n+        return new TypeDescImpl(c.getName(), dims);\n+    }\n+\n+    static TypeDesc type(Class<?> c, Class<?>... typeArguments) {\n+        return type(c, List.of(typeArguments));\n+    }\n+\n+    static TypeDesc type(Class<?> c, List<Class<?>> typeArguments) {\n+        int dims = 0;\n+        if (c.isArray()) {\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+                dims++;\n+            }\n+        }\n+        return new TypeDescImpl(c.getName(), dims, typeArguments.stream().map(TypeDesc::type).toList());\n+    }\n+\n+    static TypeDesc ofNominalDescriptor(ClassDesc d) {\n+        String descriptor = d.descriptorString();\n+        int i = 0;\n+        while (descriptor.charAt(i) == '[') {\n+            i++;\n+        }\n+        int dims = i;\n+\n+        TypeDesc td = switch (descriptor.charAt(i)) {\n+            case 'V' -> TypeDesc.VOID;\n+            case 'I' -> TypeDesc.INT;\n+            case 'J' -> TypeDesc.LONG;\n+            case 'C' -> TypeDesc.CHAR;\n+            case 'S' -> TypeDesc.SHORT;\n+            case 'B' -> TypeDesc.BYTE;\n+            case 'F' -> TypeDesc.FLOAT;\n+            case 'D' -> TypeDesc.DOUBLE;\n+            case 'Z' -> TypeDesc.BOOLEAN;\n+            case 'L' -> {\n+                \/\/ La.b.c.Class;\n+                String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n+                yield new TypeDescImpl(typeName, 0);\n+            }\n+            default -> throw new InternalError();\n+        };\n+\n+        return TypeDesc.type(td, dims);\n+    }\n+\n+    static TypeDesc ofNominalDescriptorString(String d) {\n+        return ofNominalDescriptor(ClassDesc.ofDescriptor(d));\n+    }\n+\n+    static TypeDesc type(TypeDesc t, TypeDesc... typeArguments) {\n+        return type(t, List.of(typeArguments));\n+    }\n+\n+    static TypeDesc type(TypeDesc t, List<TypeDesc> typeArguments) {\n+        if (t.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        }\n+        TypeDescImpl timpl = (TypeDescImpl) t;\n+        return new TypeDescImpl(timpl.type, timpl.dims, typeArguments);\n+    }\n+\n+    static TypeDesc type(TypeDesc t, int dims, TypeDesc... typeArguments) {\n+        return type(t, dims, List.of(typeArguments));\n+    }\n+\n+    static TypeDesc type(TypeDesc t, int dims, List<TypeDesc> typeArguments) {\n+        if (t.isArray()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not be an array: \" + t);\n+        }\n+        if (t.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Type descriptor must not have type arguments: \" + t);\n+        }\n+        TypeDescImpl timpl = (TypeDescImpl) t;\n+        return new TypeDescImpl(timpl.type, dims, typeArguments);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static TypeDesc ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDesc(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/TypeDesc.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor.impl;\n+\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+\n+public final class FieldDescImpl implements FieldDesc {\n+    final TypeDesc refType;\n+    final String name;\n+    final TypeDesc type;\n+\n+    public FieldDescImpl(TypeDesc refType, String name, TypeDesc type) {\n+        this.refType = refType;\n+        this.name = name;\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TypeDesc refType() {\n+        return refType;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public TypeDesc type() {\n+        return type;\n+    }\n+\n+    @Override\n+    public Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        Class<?> refC = refType.resolve(l);\n+        Class<?> typeC = type.resolve(l);\n+\n+        Field f = refC.getDeclaredField(name);\n+        if (!f.getType().equals(typeC)) {\n+            throw new NoSuchFieldException();\n+        }\n+\n+        return f;\n+    }\n+\n+    @Override\n+    public VarHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        Class<?> refC = refType.resolve(l);\n+        Class<?> typeC = type.resolve(l);\n+\n+        VarHandle vh = null;\n+        ReflectiveOperationException c = null;\n+\n+        try {\n+            vh = l.findStaticVarHandle(refC, name, typeC);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            c = e;\n+        }\n+\n+        if (c != null) {\n+            c = null;\n+            try {\n+                vh = l.findVarHandle(refC, name, typeC);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                c = e;\n+            }\n+        }\n+\n+        if (c != null) {\n+            throw c;\n+        }\n+\n+        assert vh != null;\n+        return vh;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return refType + \"::\" + name + \"()\" + type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        FieldDescImpl fieldDesc = (FieldDescImpl) o;\n+\n+        if (!refType.equals(fieldDesc.refType)) return false;\n+        if (!name.equals(fieldDesc.name)) return false;\n+        return type.equals(fieldDesc.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = refType.hashCode();\n+        result = 31 * result + name.hashCode();\n+        result = 31 * result + type.hashCode();\n+        return result;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/FieldDescImpl.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor.impl;\n+\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleInfo;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+public final class MethodDescImpl implements MethodDesc {\n+    final TypeDesc refType;\n+    final String name;\n+    final MethodTypeDesc type;\n+\n+    public MethodDescImpl(TypeDesc refType, String name, MethodTypeDesc type) {\n+        this.refType = refType;\n+        this.name = name;\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TypeDesc refType() {\n+        return refType;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public MethodTypeDesc type() {\n+        return type;\n+    }\n+\n+    @Override\n+    public Method resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        MethodHandleInfo methodHandleInfo = l.revealDirect(resolve(l));\n+        return methodHandleInfo.reflectAs(Method.class, l);\n+    }\n+\n+    @Override\n+    public MethodHandle resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        \/\/ @@@ kind\n+\n+        Class<?> refC = refType.resolve(l);\n+        MethodType mt = type.resolve(l);\n+\n+        MethodHandle mh = null;\n+        ReflectiveOperationException c = null;\n+\n+        try {\n+            mh = l.findStatic(refC, name, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            c = e;\n+        }\n+\n+        if (c != null) {\n+            c = null;\n+            try {\n+                mh = l.findVirtual(refC, name, mt);\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                c = e;\n+            }\n+        }\n+\n+        if (c != null) {\n+            throw c;\n+        }\n+\n+        assert mh != null;\n+        return mh;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return refType + \"::\" + name + type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        MethodDescImpl that = (MethodDescImpl) o;\n+\n+        if (!refType.equals(that.refType)) return false;\n+        if (!name.equals(that.name)) return false;\n+        return type.equals(that.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = refType.hashCode();\n+        result = 31 * result + name.hashCode();\n+        result = 31 * result + type.hashCode();\n+        return result;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodDescImpl.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor.impl;\n+\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public final class MethodTypeDescImpl implements MethodTypeDesc {\n+    final TypeDesc rtype;\n+    final List<TypeDesc> ptypes;\n+\n+    public MethodTypeDescImpl(TypeDesc rtype, List<TypeDesc> ptypes) {\n+        this.rtype = rtype;\n+        this.ptypes = List.copyOf(ptypes);\n+    }\n+\n+    @Override\n+    public TypeDesc returnType() {\n+        return rtype;\n+    }\n+\n+    @Override\n+    public List<TypeDesc> parameters() {\n+        return ptypes;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return ptypes.stream().map(TypeDesc::toString)\n+                .collect(joining(\", \", \"(\", \")\")) + rtype.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        MethodTypeDescImpl that = (MethodTypeDescImpl) o;\n+\n+        if (!rtype.equals(that.rtype)) return false;\n+        return ptypes.equals(that.ptypes);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = rtype.hashCode();\n+        result = 31 * result + ptypes.hashCode();\n+        return result;\n+    }\n+\n+    \/\/ Conversions\n+\n+    @Override\n+    public MethodTypeDesc erase() {\n+        return new MethodTypeDescImpl(rtype.rawType(), ptypes.stream().map(TypeDesc::rawType).toList());\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return ptypes.stream()\n+                .map(TypeDesc::toNominalDescriptorString)\n+                .collect(joining(\"\", \"(\", \")\")) +\n+                rtype.toNominalDescriptorString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/MethodTypeDescImpl.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor.impl;\n+\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.RecordTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public final class RecordTypeDescImpl implements RecordTypeDesc {\n+    final TypeDesc recordType;\n+    final List<ComponentDesc> components;\n+\n+    public RecordTypeDescImpl(TypeDesc recordType, List<ComponentDesc> components) {\n+        this.recordType = recordType;\n+        this.components = List.copyOf(components);\n+    }\n+\n+    @Override\n+    public TypeDesc recordType() {\n+        return recordType;\n+    }\n+\n+    @Override\n+    public List<ComponentDesc> components() {\n+        return components;\n+    }\n+\n+    @Override\n+    public MethodDesc methodForComponent(int i) {\n+        if (i < 0 || i >= components.size()) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+\n+        ComponentDesc c = components.get(i);\n+        return MethodDesc.method(recordType, c.name(), c.type());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return components.stream()\n+                .map(c -> c.type().toString() + \" \" + c.name())\n+                .collect(joining(\", \", \"(\", \")\")) +\n+                recordType.toString();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/RecordTypeDescImpl.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.descriptor.impl;\n+\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public final class TypeDescImpl implements TypeDesc {\n+    \/\/ Fully qualified name\n+    public final String type;\n+\n+    public final int dims;\n+\n+    public final List<TypeDesc> typeArguments;\n+\n+    public TypeDescImpl(String type) {\n+        this(type, 0, List.of());\n+    }\n+\n+    public TypeDescImpl(String type, int dim) {\n+        this(type, dim, List.of());\n+    }\n+\n+    public TypeDescImpl(String type, int dims, List<TypeDesc> typeArguments) {\n+        this.type = type;\n+        this.dims = dims;\n+        this.typeArguments = List.copyOf(typeArguments);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (dims == 0 && typeArguments.isEmpty()) {\n+            return type;\n+        } else if (typeArguments.isEmpty()) {\n+            return type + \"[]\".repeat(dims);\n+        } else {\n+            String params = typeArguments.stream().map(TypeDesc::toString).collect(Collectors.joining(\", \", \"<\", \">\"));\n+            return type + params + \"[]\".repeat(dims);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        TypeDescImpl typeDesc = (TypeDescImpl) o;\n+\n+        if (dims != typeDesc.dims) return false;\n+        if (!type.equals(typeDesc.type)) return false;\n+        return typeArguments.equals(typeDesc.typeArguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = type.hashCode();\n+        result = 31 * result + dims;\n+        result = 31 * result + typeArguments.hashCode();\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return dims != 0;\n+    }\n+\n+    @Override\n+    public int dimensions() {\n+        return dims;\n+    }\n+\n+    @Override\n+    public TypeDesc componentType() {\n+        if (!isArray()) {\n+            return null;\n+        }\n+\n+        return new TypeDescImpl(type, dims - 1, List.of());\n+    }\n+\n+    @Override\n+    public TypeDescImpl rawType() {\n+        return new TypeDescImpl(type, dims);\n+    }\n+\n+    @Override\n+    public boolean hasTypeArguments() {\n+        return !typeArguments.isEmpty();\n+    }\n+\n+    @Override\n+    public List<TypeDesc> typeArguments() {\n+        return typeArguments;\n+    }\n+\n+    \/\/ Conversions\n+\n+    @Override\n+    public TypeDesc toBasicType() {\n+        if (isArray()) {\n+            return TypeDesc.J_L_OBJECT;\n+        }\n+\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind == null) {\n+            return TypeDesc.J_L_OBJECT;\n+        } else {\n+            return switch (bytecodeKind) {\n+                case 'V' -> TypeDesc.VOID;\n+                case 'J' -> TypeDesc.LONG;\n+                case 'F' -> TypeDesc.FLOAT;\n+                case 'D' -> TypeDesc.DOUBLE;\n+                default -> TypeDesc.INT;\n+            };\n+        }\n+    }\n+\n+    @Override\n+    public String toClassName() {\n+        if (isArray()) {\n+            throw new IllegalStateException(\"Array type cannot be converted to class name: \" + type);\n+        }\n+\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind != null) {\n+            throw new IllegalStateException(\"Invalid class: \" + type);\n+        }\n+\n+        return type;\n+    }\n+\n+    @Override\n+    public String toInternalName() {\n+        if (isArray()) {\n+            throw new IllegalArgumentException(\"Array type cannot be converted to class descriptor\");\n+        }\n+\n+        return toClassDescriptor(type);\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        if (!isArray()) {\n+            return toBytecodeDescriptor(type);\n+        }\n+\n+        String arraySignature = \"[\".repeat(dims);\n+        return arraySignature + toBytecodeDescriptor(type);\n+    }\n+\n+    static String toBytecodeDescriptor(String type) {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind != null) {\n+            return bytecodeKind.toString();\n+        }\n+\n+        if (type.equals(\"null\")) {\n+            type = Object.class.getName();\n+        }\n+\n+        return \"L\" + type.replace('.', '\/') + \";\";\n+    }\n+\n+    static String toClassDescriptor(String type) {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        if (bytecodeKind != null) {\n+            throw new IllegalArgumentException(\"Primitive type has no class descriptor\");\n+        }\n+\n+        return type.replace('.', '\/');\n+    }\n+\n+    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n+\n+    static {\n+        PRIMITIVE_TYPE_MAP = Map.of(\n+                \"boolean\", 'Z',\n+                \"byte\", 'B',\n+                \"short\", 'S',\n+                \"char\", 'C',\n+                \"int\", 'I',\n+                \"long\", 'J',\n+                \"float\", 'F',\n+                \"double\", 'D',\n+                \"void\", 'V'\n+        );\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/impl\/TypeDescImpl.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Descriptors for code models.\n+ *\/\n+package java.lang.reflect.code.descriptor;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/descriptor\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.impl;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Value;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public final class GlobalValueBlockNaming {\n+    final Map<Value, String> gvn;\n+    final Map<Block, String> gbn;\n+    int valueOrdinal = 0;\n+    int blockOrdinal = 0;\n+\n+    public GlobalValueBlockNaming() {\n+        this.gvn = new HashMap<>();\n+        this.gbn = new HashMap<>();\n+    }\n+\n+    public String getValueName(Value _v) {\n+        return gvn.computeIfAbsent(_v, v -> String.valueOf(valueOrdinal++));\n+    }\n+\n+    public String getBlockName(Block _b) {\n+        return gbn.computeIfAbsent(_b, b -> \"block_\" + blockOrdinal++);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/impl\/GlobalValueBlockNaming.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,314 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.impl;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.function.Consumer;\n+\n+public final class OpWriter {\n+\n+    static class AttributeMapper {\n+        static String toString(Object value) {\n+            return value == Op.NULL_ATTRIBUTE_VALUE\n+                    ? \"null\"\n+                    : \"\\\"\" + quote(value.toString()) + \"\\\"\";\n+        }\n+    }\n+\n+    \/\/ Copied from com.sun.tools.javac.util.Convert\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        return switch (ch) {\n+            case '\\b' -> \"\\\\b\";\n+            case '\\f' -> \"\\\\f\";\n+            case '\\n' -> \"\\\\n\";\n+            case '\\r' -> \"\\\\r\";\n+            case '\\t' -> \"\\\\t\";\n+            case '\\'' -> \"\\\\'\";\n+            case '\\\"' -> \"\\\\\\\"\";\n+            case '\\\\' -> \"\\\\\\\\\";\n+            default -> (isPrintableAscii(ch))\n+                    ? String.valueOf(ch)\n+                    : String.format(\"\\\\u%04x\", (int) ch);\n+        };\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+    static final class IndentWriter extends Writer {\n+        static final int INDENT = 2;\n+\n+        final Writer w;\n+        int indent;\n+        boolean writeIndent = true;\n+\n+        IndentWriter(Writer w) {\n+            this(w, 0);\n+        }\n+\n+        IndentWriter(Writer w, int indent) {\n+            this.w = w;\n+            this.indent = indent;\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) throws IOException {\n+            if (writeIndent) {\n+                w.write(\" \".repeat(indent));\n+                writeIndent = false;\n+            }\n+            w.write(cbuf, off, len);\n+            if (len > 0 && cbuf[off + len - 1] == '\\n') {\n+                writeIndent = true;\n+            }\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            w.flush();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            w.close();\n+        }\n+\n+        void in() {\n+            in(INDENT);\n+        }\n+\n+        void in(int i) {\n+            indent += i;\n+        }\n+\n+        void out() {\n+            out(INDENT);\n+        }\n+\n+        void out(int i) {\n+            indent -= i;\n+        }\n+    }\n+\n+    public static void writeTo(Writer w, Op op) {\n+        OpWriter ow = new OpWriter(w);\n+        ow.writeOp(op);\n+        ow.write(\"\\n\");\n+        try {\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    final java.lang.reflect.code.impl.GlobalValueBlockNaming gn;\n+    final IndentWriter w;\n+\n+    public OpWriter(Writer w) {\n+        this(w, new java.lang.reflect.code.impl.GlobalValueBlockNaming());\n+    }\n+\n+    public OpWriter(Writer w, GlobalValueBlockNaming gn) {\n+        this.gn = gn;\n+        this.w = new IndentWriter(w);\n+    }\n+\n+    public void writeOp(Op op) {\n+        write(op.opName());\n+\n+        if (!op.operands().isEmpty()) {\n+            write(\" \");\n+            writeSpaceSeparatedList(op.operands(), this::writeValueUse);\n+        }\n+\n+        if (!op.successors().isEmpty()) {\n+            write(\" \");\n+            writeSpaceSeparatedList(op.successors(), this::writeSuccessor);\n+        }\n+\n+        if (!op.attributes().isEmpty()) {\n+            write(\" \");\n+            writeSpaceSeparatedList(op.attributes().entrySet(), e -> writeAttribute(e.getKey(), e.getValue()));\n+        }\n+\n+        if (!op.bodies().isEmpty()) {\n+            int nBodies = op.bodies().size();\n+            if (nBodies == 1) {\n+                write(\" \");\n+            } else {\n+                write(\"\\n\");\n+                w.in();\n+                w.in();\n+            }\n+            boolean first = true;\n+            for (Body body : op.bodies()) {\n+                if (!first) {\n+                    write(\"\\n\");\n+                }\n+                writeBody(body);\n+                first = false;\n+            }\n+            if (nBodies > 1) {\n+                w.out();\n+                w.out();\n+            }\n+        }\n+\n+        write(\";\");\n+    }\n+\n+    void writeSuccessor(Block.Reference successor) {\n+        writeBlockName(successor.targetBlock());\n+        if (!successor.arguments().isEmpty()) {\n+            write(\"(\");\n+            writeCommaSeparatedList(successor.arguments(), this::writeValueUse);\n+            write(\")\");\n+        }\n+    }\n+\n+    void writeAttribute(String name, Object value) {\n+        write(\"@\");\n+        if (!name.isEmpty()) {\n+            write(name);\n+            write(\"=\");\n+        }\n+        write(AttributeMapper.toString(value));\n+    }\n+\n+    void writeBody(Body body) {\n+        Block eb = body.entryBlock();\n+        write(\"(\");\n+        writeCommaSeparatedList(eb.parameters(), this::writeValueDeclaration);\n+        write(\")\");\n+        write(body.descriptor().returnType().toString());\n+        write(\" -> {\\n\");\n+        w.in();\n+        boolean isEntryBlock = true;\n+        for (Block b : body.blocks()) {\n+            if (!isEntryBlock) {\n+                write(\"\\n\");\n+            }\n+            writeBlock(b, isEntryBlock);\n+            isEntryBlock = false;\n+        }\n+        w.out();\n+        write(\"}\");\n+    }\n+\n+    void writeBlock(Block block, boolean isEntryBlock) {\n+        if (!isEntryBlock) {\n+            writeBlockName(block);\n+            if (!block.parameters().isEmpty()) {\n+                write(\"(\");\n+                writeCommaSeparatedList(block.parameters(), this::writeValueDeclaration);\n+                write(\")\");\n+            }\n+            write(\":\\n\");\n+        }\n+        w.in();\n+        for (Op op : block.ops()) {\n+            Op.Result opr = op.result();\n+            if (!opr.type().equals(TypeDesc.VOID)) {\n+                writeValueDeclaration(opr);\n+                write(\" = \");\n+            }\n+            writeOp(op);\n+            write(\"\\n\");\n+        }\n+        w.out();\n+    }\n+\n+    void writeBlockName(Block b) {\n+        writeBlockName(gn.getBlockName(b));\n+    }\n+\n+    void writeBlockName(String s) {\n+        write(\"^\");\n+        write(s);\n+    }\n+\n+    void writeValueUse(Value v) {\n+        write(\"%\");\n+        write(gn.getValueName(v));\n+    }\n+\n+    void writeValueDeclaration(Value v) {\n+        write(\"%\");\n+        write(gn.getValueName(v));\n+        write(\" : \");\n+        write(v.type().toString());\n+    }\n+\n+    <T> void writeSpaceSeparatedList(Iterable<T> l, Consumer<T> c) {\n+        writeSeparatedList(\" \", l, c);\n+    }\n+\n+    public <T> void writeCommaSeparatedList(Iterable<T> l, Consumer<T> c) {\n+        writeSeparatedList(\", \", l, c);\n+    }\n+\n+    <T> void writeSeparatedList(String separator, Iterable<T> l, Consumer<T> c) {\n+        boolean first = true;\n+        for (T t : l) {\n+            if (!first) {\n+                write(separator);\n+            }\n+            c.accept(t);\n+            first = false;\n+        }\n+    }\n+\n+    public void write(String s) {\n+        try {\n+            w.write(s);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/impl\/OpWriter.java","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"},{"patch":"@@ -0,0 +1,646 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.interpreter;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.code.*;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+public final class Interpreter {\n+    private Interpreter() {\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class InterpreterException extends RuntimeException {\n+        public InterpreterException(Throwable cause) {\n+            super(cause);\n+        }\n+    }\n+\n+    static InterpreterException interpreterException(Throwable cause) {\n+        return new InterpreterException(cause);\n+    }\n+\n+    record BlockContext(Block b, Map<Value, Object> values) {\n+    }\n+\n+    static final class OpContext {\n+        final Deque<BlockContext> stack = new ArrayDeque<>();\n+        final Deque<ExceptionRegionRecord> erStack = new ArrayDeque<>();\n+\n+        Object getValue(Value v) {\n+            \/\/ @@@ Only dominating values are accessible\n+            BlockContext bc = findContext(v);\n+            if (bc != null) {\n+                return bc.values.get(v);\n+            } else {\n+                throw interpreterException(new IllegalArgumentException(\"Undefined value: \" + v));\n+            }\n+        }\n+\n+        Object setValue(Value v, Object o) {\n+            BlockContext bc = findContext(v);\n+            if (bc != null) {\n+                throw interpreterException(new IllegalArgumentException(\"Value already defined: \" + v));\n+            }\n+            stack.peek().values.put(v, o);\n+            return o;\n+        }\n+\n+        BlockContext findContext(Value v) {\n+            Optional<BlockContext> ob = stack.stream().filter(b -> b.values.containsKey(v)).findFirst();\n+            return ob.orElse(null);\n+        }\n+\n+        boolean contains(Block.Reference s) {\n+            Block sb = s.targetBlock();\n+            return stack.stream().anyMatch(bc -> bc.b.equals(sb));\n+        }\n+\n+        void successor(Block.Reference sb) {\n+            List<Object> sbValues = sb.arguments().stream().map(this::getValue).toList();\n+\n+            Block b = sb.targetBlock();\n+            Map<Value, Object> bValues = new HashMap<>();\n+            for (int i = 0; i < sbValues.size(); i++) {\n+                bValues.put(b.parameters().get(i), sbValues.get(i));\n+            }\n+\n+            if (contains(sb)) {\n+                \/\/ if block is already dominating pop back up from the back branch to the block\n+                \/\/ before the successor block\n+                while (!stack.peek().b.equals(sb.targetBlock())) {\n+                    stack.pop();\n+                }\n+                stack.pop();\n+            }\n+            stack.push(new BlockContext(b, bValues));\n+        }\n+\n+        void successor(Block b, Map<Value, Object> bValues) {\n+            stack.push(new BlockContext(b, bValues));\n+        }\n+\n+        void popTo(BlockContext bc) {\n+            while (!stack.peek().equals(bc)) {\n+                stack.pop();\n+            }\n+        }\n+\n+        void pushExceptionRegion(ExceptionRegionRecord erb) {\n+            erStack.push(erb);\n+        }\n+\n+        void popExceptionRegion(CoreOps.ExceptionRegionEnter ers) {\n+            if (erStack.peek().ers != ers) {\n+                \/\/ @@@ Use internal exception type\n+                throw interpreterException(new IllegalStateException(\"Mismatched exception regions\"));\n+            }\n+            erStack.pop();\n+        }\n+\n+        Block exception(MethodHandles.Lookup l, Throwable e) {\n+            \/\/ Find the first matching exception region\n+            \/\/ with a catch block whose argument type is assignable-compatible to the throwable\n+            ExceptionRegionRecord er;\n+            Block cb = null;\n+            while ((er = erStack.poll()) != null &&\n+                    (cb = er.match(l, e)) == null) {\n+            }\n+\n+            if (er == null) {\n+                return null;\n+            }\n+\n+            \/\/ Pop the block context to the block defining the start of the exception region\n+            popTo(er.mark);\n+            return cb;\n+        }\n+    }\n+\n+    static final class VarBox\n+            implements CoreOps.Var<Object> {\n+        Object value;\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        VarBox(Object value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    record ClosureRecord(CoreOps.ClosureOp op,\n+                         Map<Value, Object> capturedValues)\n+            implements CoreOps.Closure {\n+    }\n+\n+    record TupleRecord(List<Object> components)\n+            implements CoreOps.Tuple {\n+        Object getComponent(int index) {\n+            return components.get(index);\n+        }\n+\n+        TupleRecord with(int index, Object value) {\n+            List<Object> copy = new ArrayList<>(components);\n+            copy.set(index, value);\n+            return new TupleRecord(copy);\n+        }\n+    }\n+\n+    record ExceptionRegionRecord(BlockContext mark, CoreOps.ExceptionRegionEnter ers)\n+            implements CoreOps.ExceptionRegion {\n+        Block match(MethodHandles.Lookup l, Throwable e) {\n+            for (Block.Reference catchBlock : ers.catchBlocks()) {\n+                Block target = catchBlock.targetBlock();\n+                List<Block.Parameter> args = target.parameters();\n+                if (args.size() != 1) {\n+                    throw interpreterException(new IllegalStateException(\"Catch block must have one argument\"));\n+                }\n+                TypeDesc et = args.get(0).type();\n+                if (et.rawType().equals(CoreOps.Var.VAR_TYPE)) {\n+                    et = et.typeArguments().get(0);\n+                }\n+                if (resolveToClass(l, et).isInstance(e)) {\n+                    return target;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(T op,\n+                  Object... args) {\n+        return invoke(MethodHandles.publicLookup(), op, args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  Object... args) {\n+        return invoke(l, op, new ArrayList<>(Arrays.asList(args)));\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  Map<Value, Object> capturedValues,\n+                  Object... args) {\n+        return invoke(l, op, capturedValues, new ArrayList<>(Arrays.asList(args)));\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(T op,\n+                  List<Object> args) {\n+        return invoke(MethodHandles.publicLookup(), op, args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(T op,\n+                  Map<Value, Object> capturedValues,\n+                  List<Object> args) {\n+        return invoke(MethodHandles.publicLookup(), op, capturedValues, args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  List<Object> args) {\n+        return invoke(l, op, Map.of(), args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T invokableOp,\n+                  Map<Value, Object> capturedValues,\n+                  List<Object> args) {\n+        OpContext oc = new OpContext();\n+\n+        Body r = invokableOp.bodies().get(0);\n+        Block first = r.entryBlock();\n+\n+        if (args.size() != first.parameters().size()) {\n+            throw interpreterException(new IllegalArgumentException(\"Incorrect number of arguments\"));\n+        }\n+        Map<Value, Object> values = new HashMap<>();\n+        for (int i = 0; i < first.parameters().size(); i++) {\n+            values.put(first.parameters().get(i), args.get(i));\n+        }\n+\n+        \/\/ Note that first block cannot have any successors so the queue will have at least one entry\n+        oc.stack.push(new BlockContext(first, values));\n+        capturedValues.forEach(oc::setValue);\n+        while (true) {\n+            BlockContext bc = oc.stack.peek();\n+\n+            \/\/ Execute all but the terminating operation\n+            int nops = bc.b.ops().size();\n+            try {\n+                for (int i = 0; i < nops - 1; i++) {\n+                    Op op = bc.b.ops().get(i);\n+                    assert !(op instanceof Op.Terminating) : op.opName();\n+\n+                    Object result = exec(l, oc, op);\n+                    oc.setValue(op.result(), result);\n+                }\n+            } catch (InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                processThrowable(oc, l, t);\n+                continue;\n+            }\n+\n+            \/\/ Execute the terminating operation\n+            Op to = bc.b.terminatingOp();\n+            if (to instanceof CoreOps.ConditionalBranchOp cb) {\n+                boolean p;\n+                Object bop = oc.getValue(cb.predicate());\n+                if (bop instanceof Boolean bp) {\n+                    p = bp;\n+                } else if (bop instanceof Integer ip) {\n+                    \/\/ @@@ This is required when lifting up from bytecode, since boolean values\n+                    \/\/ are erased to int values, abd the bytecode lifting implementation is not currently\n+                    \/\/ sophisticated enough to recover the type information\n+                    p = ip != 0;\n+                } else {\n+                    throw interpreterException(\n+                            new UnsupportedOperationException(\"Unsupported type input to operation: \" + cb));\n+                }\n+                Block.Reference sb = p ? cb.trueBranch() : cb.falseBranch();\n+                oc.successor(sb);\n+            } else if (to instanceof CoreOps.BranchOp b) {\n+                Block.Reference sb = b.branch();\n+\n+                oc.successor(sb);\n+            } else if (to instanceof CoreOps.ThrowOp _throw) {\n+                Throwable t = (Throwable) oc.getValue(_throw.argument());\n+                processThrowable(oc, l, t);\n+            } else if (to instanceof CoreOps.ReturnOp ret) {\n+                Value rv = ret.returnValue();\n+\n+                return rv == null ? null : oc.getValue(rv);\n+            } else if (to instanceof CoreOps.ExceptionRegionEnter ers) {\n+                var er = new ExceptionRegionRecord(oc.stack.peek(), ers);\n+                oc.setValue(ers.result(), er);\n+\n+                oc.pushExceptionRegion(er);\n+\n+                oc.successor(ers.start());\n+            } else if (to instanceof CoreOps.ExceptionRegionExit ere) {\n+                oc.popExceptionRegion(ere.regionStart());\n+\n+                oc.successor(ere.end());\n+            } else {\n+                throw interpreterException(\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+            }\n+        }\n+    }\n+\n+    static void processThrowable(OpContext oc, MethodHandles.Lookup l, Throwable t) {\n+        \/\/ Find a matching catch block\n+        Block cb = oc.exception(l, t);\n+        if (cb == null) {\n+            \/\/ If there is no matching catch bock then rethrow back to the caller\n+            throw erase(t);\n+        }\n+\n+        \/\/ Add a new block context to the catch block with the exception as the argument\n+        Map<Value, Object> bValues = new HashMap<>();\n+        Block.Parameter eArg = cb.parameters().get(0);\n+        if (eArg.type().rawType().equals(CoreOps.Var.VAR_TYPE)) {\n+            bValues.put(eArg, new VarBox(t));\n+        } else {\n+            bValues.put(eArg, t);\n+        }\n+        oc.successor(cb, bValues);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static Object exec(MethodHandles.Lookup l, OpContext oc, Op o) {\n+        if (o instanceof CoreOps.ConstantOp co) {\n+            if (co.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                return resolveToClass(l, (TypeDesc) co.value());\n+            } else {\n+                return co.value();\n+            }\n+        } else if (o instanceof CoreOps.FuncCallOp fco) {\n+            String name = fco.funcName();\n+\n+            \/\/ Find top-level op\n+            Op top = fco;\n+            while (top.ancestorBody() != null) {\n+                top = top.ancestorBody().parentOp();\n+            }\n+\n+            \/\/ Ensure top-level op is a module and function name\n+            \/\/ is in the module's function table\n+            if (top instanceof CoreOps.ModuleOp mop) {\n+                CoreOps.FuncOp funcOp = mop.functionTable().get(name);\n+                if (funcOp == null) {\n+                    throw interpreterException(\n+                            new IllegalStateException\n+                                    (\"Function \" + name + \" cannot be resolved: not in module's function table\"));\n+                }\n+\n+                Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+                return Interpreter.invoke(funcOp, values);\n+            } else {\n+                throw interpreterException(\n+                        new IllegalStateException(\n+                                \"Function \" + name + \" cannot be resolved: top level op is not a module\"));\n+            }\n+        } else if (o instanceof CoreOps.InvokeOp co) {\n+            MethodHandle mh;\n+            if (co.hasReceiver()) {\n+                mh = methodHandle(l, co.invokeDescriptor());\n+            } else {\n+                mh = methodStaticHandle(l, co.invokeDescriptor());\n+            }\n+            MethodType target = resolveToMethodType(l, o.descriptor());\n+            mh = mh.asType(target).asFixedArity();\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            return invoke(mh, values);\n+        } else if (o instanceof CoreOps.NewOp no) {\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            TypeDesc nType = no.constructorDescriptor().returnType();\n+            if (nType.dimensions() > 0) {\n+                if (values.length > nType.dimensions()) {\n+                    throw interpreterException(new IllegalArgumentException(\"Bad constructor NewOp: \" + no));\n+                }\n+                int[] lengths = Stream.of(values).mapToInt(v -> (int) v).toArray();\n+                for (int length : lengths) {\n+                    nType = nType.componentType();\n+                }\n+                return Array.newInstance(resolveToClass(l, nType), lengths);\n+            } else {\n+                MethodHandle mh = constructorHandle(l, no.constructorDescriptor());\n+                return invoke(mh, values);\n+            }\n+        } else if (o instanceof CoreOps.QuotedOp qo) {\n+            Map<Value, Object> capturedValues = qo.capturedValues().stream()\n+                    .collect(toMap(v -> v, oc::getValue));\n+            return new Quoted(qo.quotedOp(), capturedValues);\n+        } else if (o instanceof CoreOps.LambdaOp lo) {\n+            Map<Value, Object> capturedValues = lo.capturedValues().stream()\n+                    .collect(toMap(v -> v, oc::getValue));\n+            Class<?> fi = resolveToClass(l, lo.functionalInterface());\n+\n+            MethodHandle fProxy = INVOKE_LAMBDA_MH.bindTo(l).bindTo(lo).bindTo(capturedValues)\n+                    .asCollector(Object[].class, lo.body().entryBlock().parameters().size());\n+            Object fiInstance = MethodHandleProxies.asInterfaceInstance(fi, fProxy);\n+\n+            \/\/ If a quotable lambda proxy again to implement Quotable\n+            if (Quotable.class.isAssignableFrom(fi)) {\n+                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi},\n+                        (proxy, method, args) -> {\n+                            if (method.getDeclaringClass() == Quotable.class) {\n+                                \/\/ Implement Quotable::quoted\n+                                return new Quoted(lo, capturedValues);\n+                            } else {\n+                                \/\/ Delegate to FI instance\n+                                return method.invoke(fiInstance, args);\n+                            }\n+                        });\n+            } else {\n+                return fiInstance;\n+            }\n+        } else if (o instanceof CoreOps.ClosureOp co) {\n+            Map<Value, Object> capturedValues = co.capturedValues().stream()\n+                    .collect(toMap(v -> v, oc::getValue));\n+            return new ClosureRecord(co, capturedValues);\n+        } else if (o instanceof CoreOps.ClosureCallOp cco) {\n+            List<Object> values = o.operands().stream().map(oc::getValue).toList();\n+            ClosureRecord cr = (ClosureRecord) values.get(0);\n+\n+            return Interpreter.invoke(l, cr.op(), cr.capturedValues, values.subList(1, values.size()));\n+        } else if (o instanceof CoreOps.VarOp vo) {\n+            return new VarBox(oc.getValue(o.operands().get(0)));\n+        } else if (o instanceof CoreOps.VarAccessOp.VarLoadOp vlo) {\n+            \/\/ Cast to CoreOps.Var, since the instance may have originated as an external instance\n+            \/\/ via a captured value map\n+            CoreOps.Var<?> vb = (CoreOps.Var<?>) oc.getValue(o.operands().get(0));\n+            return vb.value();\n+        } else if (o instanceof CoreOps.VarAccessOp.VarStoreOp vso) {\n+            VarBox vb = (VarBox) oc.getValue(o.operands().get(0));\n+            vb.value = oc.getValue(o.operands().get(1));\n+            return null;\n+        } else if (o instanceof CoreOps.TupleOp to) {\n+            List<Object> values = o.operands().stream().map(oc::getValue).toList();\n+            return new TupleRecord(values);\n+        } else if (o instanceof CoreOps.TupleLoadOp tlo) {\n+            TupleRecord tb = (TupleRecord) oc.getValue(o.operands().get(0));\n+            return tb.getComponent(tlo.index());\n+        } else if (o instanceof CoreOps.TupleWithOp two) {\n+            TupleRecord tb = (TupleRecord) oc.getValue(o.operands().get(0));\n+            return tb.with(two.index(), oc.getValue(o.operands().get(1)));\n+        } else if (o instanceof CoreOps.FieldAccessOp.FieldLoadOp fo) {\n+            if (fo.operands().isEmpty()) {\n+                VarHandle vh = fieldStaticHandle(l, fo.fieldDescriptor());\n+                return vh.get();\n+            } else {\n+                Object v = oc.getValue(o.operands().get(0));\n+                VarHandle vh = fieldHandle(l, fo.fieldDescriptor());\n+                return vh.get(v);\n+            }\n+        } else if (o instanceof CoreOps.FieldAccessOp.FieldStoreOp fo) {\n+            if (fo.operands().size() == 1) {\n+                Object v = oc.getValue(o.operands().get(0));\n+                VarHandle vh = fieldStaticHandle(l, fo.fieldDescriptor());\n+                vh.set(v);\n+            } else {\n+                Object r = oc.getValue(o.operands().get(0));\n+                Object v = oc.getValue(o.operands().get(1));\n+                VarHandle vh = fieldHandle(l, fo.fieldDescriptor());\n+                vh.set(r, v);\n+            }\n+            return null;\n+        } else if (o instanceof CoreOps.InstanceOfOp io) {\n+            Object v = oc.getValue(o.operands().get(0));\n+            return isInstance(l, io.type(), v);\n+        } else if (o instanceof CoreOps.CastOp co) {\n+            Object v = oc.getValue(o.operands().get(0));\n+            return cast(l, co.type(), v);\n+        } else if (o instanceof CoreOps.ArrayLengthOp) {\n+            Object a = oc.getValue(o.operands().get(0));\n+            return Array.getLength(a);\n+        } else if (o instanceof CoreOps.ArrayAccessOp.ArrayLoadOp) {\n+            Object a = oc.getValue(o.operands().get(0));\n+            Object index = oc.getValue(o.operands().get(1));\n+            return Array.get(a, (int) index);\n+        } else if (o instanceof CoreOps.ArrayAccessOp.ArrayStoreOp) {\n+            Object a = oc.getValue(o.operands().get(0));\n+            Object index = oc.getValue(o.operands().get(1));\n+            Object v = oc.getValue(o.operands().get(2));\n+            Array.set(a, (int) index, v);\n+            return null;\n+        } else if (o instanceof CoreOps.ArithmeticOperation || o instanceof CoreOps.TestOperation) {\n+            MethodHandle mh = opHandle(o.opName(), o.descriptor());\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            return invoke(mh, values);\n+        } else if (o instanceof CoreOps.ConvOp) {\n+            MethodHandle mh = opHandle(o.opName() + \"_\" + o.descriptor().returnType(), o.descriptor());\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            return invoke(mh, values);\n+        } else {\n+            throw interpreterException(\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+        }\n+    }\n+\n+    static final MethodHandle INVOKE_LAMBDA_MH;\n+    static {\n+        try {\n+            INVOKE_LAMBDA_MH = MethodHandles.lookup().findStatic(Interpreter.class, \"invokeLambda\",\n+                    MethodType.methodType(Object.class, MethodHandles.Lookup.class,\n+                            CoreOps.LambdaOp.class, Map.class, Object[].class));\n+        } catch (Throwable t) {\n+            throw new InternalError(t);\n+        }\n+    }\n+\n+    static Object invokeLambda(MethodHandles.Lookup l, CoreOps.LambdaOp op, Map<Value, Object> capturedValues, Object[] args) {\n+        return invoke(l, op, capturedValues, args);\n+    }\n+\n+    static MethodHandle opHandle(String opName, MethodTypeDesc d) {\n+        MethodType mt = resolveToMethodType(MethodHandles.lookup(), d).erase();\n+        try {\n+            return MethodHandles.lookup().findStatic(InvokableLeafOps.class, opName, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodDesc d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n+    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodDesc d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n+    static MethodHandle constructorHandle(MethodHandles.Lookup l, MethodTypeDesc d) {\n+        MethodType mt = resolveToMethodType(l, d);\n+\n+        if (mt.returnType().isArray()) {\n+            if (mt.parameterCount() != 1 || mt.parameterType(0) != int.class) {\n+                throw interpreterException(new IllegalArgumentException(\"Bad constructor descriptor: \" + d));\n+            }\n+            return MethodHandles.arrayConstructor(mt.returnType());\n+        } else {\n+            try {\n+                return l.findConstructor(mt.returnType(), mt.changeReturnType(void.class));\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw interpreterException(e);\n+            }\n+        }\n+    }\n+\n+    static VarHandle fieldStaticHandle(MethodHandles.Lookup l, FieldDesc d) {\n+        return resolveToVarHandle(l, d);\n+    }\n+\n+    static VarHandle fieldHandle(MethodHandles.Lookup l, FieldDesc d) {\n+        return resolveToVarHandle(l, d);\n+    }\n+\n+    static Object isInstance(MethodHandles.Lookup l, TypeDesc d, Object v) {\n+        Class<?> c = resolveToClass(l, d);\n+        return c.isInstance(v);\n+    }\n+\n+    static Object cast(MethodHandles.Lookup l, TypeDesc d, Object v) {\n+        Class<?> c = resolveToClass(l, d);\n+        return c.cast(v);\n+    }\n+\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodDesc d) {\n+        try {\n+            return d.resolve(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    static VarHandle resolveToVarHandle(MethodHandles.Lookup l, FieldDesc d) {\n+        try {\n+            return d.resolve(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    public static MethodType resolveToMethodType(MethodHandles.Lookup l, MethodTypeDesc d) {\n+        try {\n+            return d.resolve(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    public static Class<?> resolveToClass(MethodHandles.Lookup l, TypeDesc d) {\n+        try {\n+            return d.resolve(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    static Object invoke(MethodHandle m, Object... args) {\n+        try {\n+            return m.invokeWithArguments(args);\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw erase(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":646,"deletions":0,"binary":false,"changes":646,"status":"added"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.interpreter;\n+\n+final class InvokableLeafOps {\n+\n+    public static String add(String a, String b) {\n+        return a.concat(b);\n+    }\n+\n+\n+    public static boolean eq(Object a, Object b) {\n+        return a == b;\n+    }\n+\n+    public static boolean neq(Object a, Object b) {\n+        return a != b;\n+    }\n+\n+\n+    public static boolean not(boolean l) {\n+        return !l;\n+    }\n+\n+    \/\/ int\n+\n+    public static int neg(int l) {\n+        return -l;\n+    }\n+\n+    public static int add(int l, int r) {\n+        return l + r;\n+    }\n+\n+    public static int sub(int l, int r) {\n+        return l - r;\n+    }\n+\n+    public static int mul(int l, int r) {\n+        return l * r;\n+    }\n+\n+    public static int div(int l, int r) {\n+        return l \/ r;\n+    }\n+\n+    public static int mod(int l, int r) {\n+        return l % r;\n+    }\n+\n+    public static int or(int l, int r) {\n+        return l | r;\n+    }\n+\n+    public static boolean eq(int l, int r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(int l, int r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(int l, int r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(int l, int r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(int l, int r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(int l, int r) {\n+        return l <= r;\n+    }\n+\n+   \/\/ long\n+\n+    public static long neg(long l) {\n+        return -l;\n+    }\n+\n+    public static long add(long l, long r) {\n+        return l + r;\n+    }\n+\n+    public static long sub(long l, long r) {\n+        return l - r;\n+    }\n+\n+    public static long mul(long l, long r) {\n+        return l * r;\n+    }\n+\n+    public static long div(long l, long r) {\n+        return l \/ r;\n+    }\n+\n+    public static long mod(long l, long r) {\n+        return l % r;\n+    }\n+\n+    public static long or(long l, long r) {\n+        return l | r;\n+    }\n+\n+    public static boolean eq(long l, long r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(long l, long r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(long l, long r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(long l, long r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(long l, long r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(long l, long r) {\n+        return l <= r;\n+    }\n+\n+\n+\n+    \/\/ float\n+\n+    static float neg(float l) {\n+        return -l;\n+    }\n+\n+    static float add(float l, float r) {\n+        return l + r;\n+    }\n+\n+    static float sub(float l, float r) {\n+        return l - r;\n+    }\n+\n+    static float mul(float l, float r) {\n+        return l * r;\n+    }\n+\n+    static float div(float l, float r) {\n+        return l \/ r;\n+    }\n+\n+    public static boolean eq(float l, float r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(float l, float r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(float l, float r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(float l, float r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(float l, float r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(float l, float r) {\n+        return l <= r;\n+    }\n+\n+\n+\n+    \/\/ double\n+\n+    static double neg(double l) {\n+        return -l;\n+    }\n+\n+    static double add(double l, double r) {\n+        return l + r;\n+    }\n+\n+    static double sub(double l, double r) {\n+        return l - r;\n+    }\n+\n+    static double mul(double l, double r) {\n+        return l * r;\n+    }\n+\n+    static double div(double l, double r) {\n+        return l \/ r;\n+    }\n+\n+\n+    \/\/ Primitive conversions\n+\n+    \/\/ double conversion\n+    static double conv_double(double i) {\n+        return i;\n+    }\n+    static float conv_float(double i) {\n+        return (float) i;\n+    }\n+    static long conv_long(double i) {\n+        return (long) i;\n+    }\n+    static int conv_int(double i) {\n+        return (int) i;\n+    }\n+    static short conv_short(double i) {\n+        return (short) i;\n+    }\n+    static char conv_char(double i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(double i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ float conversion\n+    static double conv_double(float i) {\n+        return i;\n+    }\n+    static float conv_float(float i) {\n+        return i;\n+    }\n+    static long conv_long(float i) {\n+        return (long) i;\n+    }\n+    static int conv_int(float i) {\n+        return (int) i;\n+    }\n+    static short conv_short(float i) {\n+        return (short) i;\n+    }\n+    static char conv_char(float i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(float i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ long conversion\n+    static double conv_double(long i) {\n+        return (double) i;\n+    }\n+    static float conv_float(long i) {\n+        return (float) i;\n+    }\n+    static long conv_long(long i) {\n+        return i;\n+    }\n+    static int conv_int(long i) {\n+        return (int) i;\n+    }\n+    static short conv_short(long i) {\n+        return (short) i;\n+    }\n+    static char conv_char(long i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(long i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ int conversion\n+    static double conv_double(int i) {\n+        return (double) i;\n+    }\n+    static float conv_float(int i) {\n+        return (float) i;\n+    }\n+    static long conv_long(int i) {\n+        return i;\n+    }\n+    static int conv_int(int i) {\n+        return i;\n+    }\n+    static short conv_short(int i) {\n+        return (short) i;\n+    }\n+    static char conv_char(int i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(int i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ short conversion\n+    static double conv_double(short i) {\n+        return i;\n+    }\n+    static float conv_float(short i) {\n+        return i;\n+    }\n+    static long conv_long(short i) {\n+        return i;\n+    }\n+    static int conv_int(short i) {\n+        return i;\n+    }\n+    static short conv_short(short i) {\n+        return i;\n+    }\n+    static char conv_char(short i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(short i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ char conversion\n+    static double conv_double(char i) {\n+        return i;\n+    }\n+    static float conv_float(char i) {\n+        return i;\n+    }\n+    static long conv_long(char i) {\n+        return i;\n+    }\n+    static int conv_int(char i) {\n+        return i;\n+    }\n+    static short conv_short(char i) {\n+        return (short) i;\n+    }\n+    static char conv_char(char i) {\n+        return i;\n+    }\n+    static byte conv_byte(char i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ byte conversion\n+    static double conv_double(byte i) {\n+        return i;\n+    }\n+    static float conv_float(byte i) {\n+        return i;\n+    }\n+    static long conv_long(byte i) {\n+        return i;\n+    }\n+    static int conv_int(byte i) {\n+        return i;\n+    }\n+    static short conv_short(byte i) {\n+        return i;\n+    }\n+    static char conv_char(byte i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(byte i) {\n+        return i;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for interpreting code models.\n+ *\/\n+package java.lang.reflect.code.interpreter;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,3583 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The set of core operations. A code model, produced by the Java compiler from Java program source and lowered to\n+ * consist only of core operations, represents the same Java program and preserves the program meaning as defined by\n+ * the Java Language Specification.\n+ *\/\n+public final class CoreOps {\n+\n+    \/\/ Split string to ensure the name does not get rewritten\n+    \/\/ when the script copies this source to the jdk.compiler module\n+    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n+\n+    static final String CoreOps_CLASS_NAME = PACKAGE_NAME + \".\" + CoreOps.class.getSimpleName();\n+\n+    private CoreOps() {\n+    }\n+\n+    \/**\n+     * The function operation, that can model a Java method.\n+     *\/\n+    @OpDeclaration(FuncOp.NAME)\n+    public static final class FuncOp extends OpWithDefinition implements Op.Invokable, Op.Isolated, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final String funcName;\n+            final MethodTypeDesc funcDescriptor;\n+\n+            Builder(Body.Builder ancestorBody, String funcName, MethodTypeDesc funcDescriptor) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcName = funcName;\n+                this.funcDescriptor = funcDescriptor;\n+            }\n+\n+            public FuncOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcDescriptor);\n+                c.accept(body.entryBlock());\n+                return new FuncOp(funcName, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"func\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final Body body;\n+\n+        public static FuncOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new FuncOp(def, funcName);\n+        }\n+\n+        FuncOp(OpDefinition def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        FuncOp(FuncOp that, CopyContext cc, OpTransformer oa) {\n+            this(that, that.funcName, cc, oa);\n+        }\n+\n+        FuncOp(FuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.funcName = funcName;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, cc, ot);\n+        }\n+\n+        public FuncOp transform(OpTransformer ot) {\n+            return new FuncOp(this, CopyContext.create(), ot);\n+        }\n+\n+        public FuncOp transform(String funcName, OpTransformer ot) {\n+            return new FuncOp(this, funcName, CopyContext.create(), ot);\n+        }\n+\n+        FuncOp(String funcName, Body.Builder bodyBuilder) {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of());\n+\n+            this.funcName = funcName;\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        @Override\n+        public MethodTypeDesc funcDescriptor() {\n+            return body.descriptor();\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            \/\/ and copy directly without lowering descendant operations\n+            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The function call operation, that models a call to a function, by name, declared in the module op that is also an\n+     * ancestor of this operation.\n+     *\/\n+    \/\/ @@@ stack effects equivalent to the call operation as if the function were a Java method?\n+    @OpDeclaration(FuncCallOp.NAME)\n+    public static final class FuncCallOp extends OpWithDefinition {\n+        public static final String NAME = \"func.call\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+\n+        public static FuncCallOp create(OpDefinition def) {\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+\n+            return new FuncCallOp(def, funcName);\n+        }\n+\n+        FuncCallOp(OpDefinition def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+        }\n+\n+        FuncCallOp(FuncCallOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.funcName = that.funcName;\n+        }\n+\n+        @Override\n+        public FuncCallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncCallOp(this, cc);\n+        }\n+\n+        FuncCallOp(String funcName, TypeDesc resultType, List<Value> args) {\n+            super(NAME, resultType, args);\n+\n+            this.funcName = funcName;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+    }\n+\n+    \/**\n+     * The module operation, modeling a collection of functions,\n+     * and creating a symbol table of function name to function\n+     *\/\n+    @OpDeclaration(ModuleOp.NAME)\n+    public static final class ModuleOp extends OpWithDefinition implements Op.Isolated {\n+\n+        public static final String NAME = \"module\";\n+\n+        final Map<String, FuncOp> table;\n+        final Body body;\n+\n+        public static ModuleOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            return new ModuleOp(def);\n+        }\n+\n+        ModuleOp(OpDefinition def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        ModuleOp(ModuleOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        static Map<String, FuncOp> createTable(Body body) {\n+            Map<String, FuncOp> table = new HashMap<>();\n+            for (var op : body.entryBlock().ops()) {\n+                if (op instanceof FuncOp fop) {\n+                    table.put(fop.funcName(), fop);\n+                } else {\n+                    throw new IllegalArgumentException(\"Bad operation in module: \" + op);\n+                }\n+            }\n+            return Collections.unmodifiableMap(table);\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc, ot);\n+        }\n+\n+        public ModuleOp transform(OpTransformer ot) {\n+            return new ModuleOp(this, CopyContext.create(), ot);\n+        }\n+\n+        ModuleOp(List<FuncOp> functions) {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of());\n+\n+            Body.Builder bodyC = Body.Builder.of(null, MethodTypeDesc.VOID);\n+            Block.Builder entryBlock = bodyC.entryBlock();\n+            Map<String, FuncOp> table = new HashMap<>();\n+            for (FuncOp f : functions) {\n+                entryBlock.op(f);\n+                table.put(f.funcName(), f);\n+            }\n+            this.table = Collections.unmodifiableMap(table);\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Map<String, FuncOp> functionTable() {\n+            return table;\n+        }\n+    }\n+\n+    \/**\n+     * The quoted operation, that models the quoting of an operation.\n+     *\/\n+    @OpDeclaration(QuotedOp.NAME)\n+    public static final class QuotedOp extends OpWithDefinition implements Op.Nested, Op.Lowerable, Op.Pure {\n+        public static final String NAME = \"quoted\";\n+\n+        \/\/ Type description must be the same in the java.base and jdk.compiler module\n+        static final String Quoted_CLASS_NAME = PACKAGE_NAME +\n+                \".\" + Quoted.class.getSimpleName();\n+        public static final TypeDesc QUOTED_TYPE = new TypeDescImpl(Quoted_CLASS_NAME);\n+\n+        final Body quotedBody;\n+\n+        final Op quotedOp;\n+\n+        public QuotedOp(OpDefinition def) {\n+            super(def);\n+\n+            this.quotedBody = def.bodyDefinitions().get(0).build(this);\n+\n+            if (quotedBody.entryBlock().terminatingOp() instanceof YieldOp brk &&\n+                    brk.yieldValue() instanceof Result quotedOpResult) {\n+                this.quotedOp = quotedOpResult.op();\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        QuotedOp(QuotedOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.quotedBody = that.quotedBody.transform(cc, ot).build(this);\n+            this.quotedOp = that.quotedOp;\n+        }\n+\n+        @Override\n+        public QuotedOp transform(CopyContext cc, OpTransformer ot) {\n+            return new QuotedOp(this, cc, ot);\n+        }\n+\n+        QuotedOp(Body.Builder bodyC) {\n+            super(NAME, QUOTED_TYPE,\n+                    List.of());\n+\n+            this.quotedBody = bodyC.build(this);\n+            if (quotedBody.blocks().size() > 1) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!(quotedBody.entryBlock().terminatingOp() instanceof YieldOp yop)) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!(yop.yieldValue() instanceof Result r)) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.quotedOp = r.op();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(quotedBody);\n+        }\n+\n+        public Op quotedOp() {\n+            return quotedOp;\n+        }\n+\n+        \/\/ Returns the set of values used in but declared outside the lambda's body\n+        public List<Value> capturedValues() {\n+            Set<Value> cvs = new LinkedHashSet<>();\n+\n+            capturedValues(cvs, new ArrayDeque<>(), quotedBody);\n+            return new ArrayList<>(cvs);\n+        }\n+\n+        void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n+            bodyStack.push(body);\n+\n+            for (Block b : body.blocks()) {\n+                for (Op op : b.ops()) {\n+                    for (Body childBody : op.bodies()) {\n+                        capturedValues(capturedValues, bodyStack, childBody);\n+                    }\n+\n+                    for (Value a : op.operands()) {\n+                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                            capturedValues.add(a);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            bodyStack.pop();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            \/\/ and copy directly without lowering descendant operations\n+            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The lambda operation, that can model a Java lambda expression.\n+     *\/\n+    @OpDeclaration(LambdaOp.NAME)\n+    public static final class LambdaOp extends OpWithDefinition implements Op.Invokable, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final MethodTypeDesc functionalDescriptor;\n+            final TypeDesc functionalInterface;\n+\n+            Builder(Body.Builder ancestorBody, MethodTypeDesc functionalDescriptor, TypeDesc functionalInterface) {\n+                this.ancestorBody = ancestorBody;\n+                this.functionalDescriptor = functionalDescriptor;\n+                this.functionalInterface = functionalInterface;\n+            }\n+\n+            public LambdaOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, functionalDescriptor);\n+                c.accept(body.entryBlock());\n+                return new LambdaOp(functionalInterface, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"lambda\";\n+\n+        final TypeDesc functionalInterface;\n+        final Body body;\n+\n+        public LambdaOp(OpDefinition def) {\n+            super(def);\n+\n+            this.functionalInterface = def.resultType();\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        LambdaOp(LambdaOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.functionalInterface = that.functionalInterface;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public LambdaOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LambdaOp(this, cc, ot);\n+        }\n+\n+        LambdaOp(TypeDesc functionalInterface, Body.Builder bodyC) {\n+            super(NAME, functionalInterface,\n+                    List.of());\n+\n+            this.functionalInterface = functionalInterface;\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public MethodTypeDesc funcDescriptor() {\n+            return body.descriptor();\n+        }\n+\n+        public TypeDesc functionalInterface() {\n+            return functionalInterface;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        \/\/ Returns the set of values used in but declared outside the lambda's body\n+        public List<Value> capturedValues() {\n+            Set<Value> cvs = new LinkedHashSet<>();\n+            Body body = body();\n+\n+            capturedValues(cvs, new ArrayDeque<>(), body);\n+            return new ArrayList<>(cvs);\n+        }\n+\n+        void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n+            bodyStack.push(body);\n+\n+            for (Block b : body.blocks()) {\n+                for (Op op : b.ops()) {\n+                    for (Body childBody : op.bodies()) {\n+                        capturedValues(capturedValues, bodyStack, childBody);\n+                    }\n+\n+                    for (Value a : op.operands()) {\n+                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                            capturedValues.add(a);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            bodyStack.pop();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, (block, op) -> {\n+                if (op instanceof Op.Lowerable lop) {\n+                    return lop.lower(block);\n+                } else {\n+                    block.op(op);\n+                    return block;\n+                }\n+            });\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * A synthetic closure type, that is the operation result-type of an closure operation.\n+     *\/\n+    \/\/ @@@: Maybe drop and move the constants elsewhere\n+    public interface Closure {\n+        \/\/ Type description must be the same in the java.base and jdk.compiler module\n+        TypeDesc CLOSURE_TYPE = new TypeDescImpl(CoreOps_CLASS_NAME +\n+                \"$\" + Closure.class.getSimpleName());\n+\n+        static TypeDesc type(TypeDesc... types) {\n+            return TypeDesc.type(\n+                    CLOSURE_TYPE,\n+                    types);\n+        }\n+\n+        static TypeDesc type(List<TypeDesc> types) {\n+            return TypeDesc.type(\n+                    CLOSURE_TYPE,\n+                    types);\n+        }\n+    }\n+\n+    \/**\n+     * The closure operation, that can model a structured Java lambda expression\n+     * that has no target type (a functional interface).\n+     *\/\n+    @OpDeclaration(ClosureOp.NAME)\n+    public static final class ClosureOp extends OpWithDefinition implements Op.Invokable, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final MethodTypeDesc functionalDescriptor;\n+\n+            Builder(Body.Builder ancestorBody, MethodTypeDesc functionalDescriptor) {\n+                this.ancestorBody = ancestorBody;\n+                this.functionalDescriptor = functionalDescriptor;\n+            }\n+\n+            public ClosureOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, functionalDescriptor);\n+                c.accept(body.entryBlock());\n+                return new ClosureOp(body);\n+            }\n+        }\n+\n+        public static final String NAME = \"closure\";\n+\n+        final Body body;\n+\n+        public ClosureOp(OpDefinition def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        ClosureOp(ClosureOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public ClosureOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ClosureOp(this, cc, ot);\n+        }\n+\n+        ClosureOp(Body.Builder bodyC) {\n+            super(NAME, closureType(bodyC.descriptor()),\n+                    List.of());\n+\n+            this.body = bodyC.build(this);\n+        }\n+\n+        static TypeDesc closureType(MethodTypeDesc functionalDescriptor) {\n+            List<TypeDesc> l = new ArrayList<>();\n+            l.add(functionalDescriptor.returnType());\n+            l.addAll(functionalDescriptor.parameters());\n+            return Closure.type(l);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public MethodTypeDesc funcDescriptor() {\n+            return body.descriptor();\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        \/\/ Returns the set of values used in but declared outside the lambda's body\n+        public List<Value> capturedValues() {\n+            Set<Value> cvs = new LinkedHashSet<>();\n+            Body body = body();\n+\n+            capturedValues(cvs, new ArrayDeque<>(), body);\n+            return new ArrayList<>(cvs);\n+        }\n+\n+        void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n+            bodyStack.push(body);\n+\n+            for (Block b : body.blocks()) {\n+                for (Op op : b.ops()) {\n+                    for (Body childBody : op.bodies()) {\n+                        capturedValues(capturedValues, bodyStack, childBody);\n+                    }\n+\n+                    for (Value a : op.operands()) {\n+                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                            capturedValues.add(a);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            bodyStack.pop();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, (block, op) -> {\n+                if (op instanceof Op.Lowerable lop) {\n+                    return lop.lower(block);\n+                } else {\n+                    block.op(op);\n+                    return block;\n+                }\n+            });\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The closure call operation, that models a call to a closure, by reference\n+     *\n+     *\/\n+\/\/  @@@ stack effects equivalent to the invocation of an SAM of on an instance of an anonymous functional interface\n+\/\/  that is the target of the closures lambda expression.\n+    @OpDeclaration(ClosureCallOp.NAME)\n+    public static final class ClosureCallOp extends OpWithDefinition {\n+        public static final String NAME = \"closure.call\";\n+\n+        public ClosureCallOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ClosureCallOp(ClosureCallOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ClosureCallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ClosureCallOp(this, cc);\n+        }\n+\n+        ClosureCallOp(List<Value> args) {\n+            super(NAME, resultType(args), args);\n+        }\n+\n+        static TypeDesc resultType(List<Value> args) {\n+            if (args.isEmpty()) {\n+                throw new IllegalArgumentException(\n+                        \"Operation must have one or more operands: \" + args.size());\n+            }\n+            TypeDesc t = args.get(0).type();\n+\n+            if (t.typeArguments().isEmpty()) {\n+                throw new IllegalArgumentException(\n+                        \"Operation result type must have one or more parameters: \" + t.typeArguments().size());\n+            }\n+            if (t.typeArguments().size() != args.size()) {\n+                throw new IllegalArgumentException();\n+            }\n+            return t.typeArguments().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * The terminating return operation, that can model the Java language return statement.\n+     * <p>\n+     * This operation exits an isolated body.\n+     *\/\n+    @OpDeclaration(ReturnOp.NAME)\n+    public static final class ReturnOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"return\";\n+\n+        public ReturnOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+\n+        ReturnOp() {\n+            super(NAME, TypeDesc.VOID, List.of());\n+        }\n+\n+        ReturnOp(Value operand) {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of(operand));\n+        }\n+\n+        public Value returnValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The terminating throw operation, that can model the Java language throw statement.\n+     *\/\n+    @OpDeclaration(ThrowOp.NAME)\n+    public static final class ThrowOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"throw\";\n+\n+        public ThrowOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+        }\n+\n+        ThrowOp(ThrowOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ThrowOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ThrowOp(this, cc);\n+        }\n+\n+        ThrowOp(Value e) {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of(e));\n+        }\n+\n+        public Value argument() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * The terminating unreachable operation.\n+     * <p>\n+     * This operation models termination that is unreachable.\n+     *\/\n+    @OpDeclaration(UnreachableOp.NAME)\n+    public static class UnreachableOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"unreachable\";\n+\n+        public UnreachableOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must zero operands \" + def.name());\n+            }\n+        }\n+\n+        UnreachableOp(UnreachableOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public UnreachableOp transform(CopyContext cc, OpTransformer ot) {\n+            return new UnreachableOp(this, cc);\n+        }\n+\n+        UnreachableOp() {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of());\n+        }\n+    }\n+\n+    \/**\n+     * The terminating yield operation.\n+     * <p>\n+     * This operation models exits from its parent body, yielding at most one value (zero value for yielding unit\n+     * or void)\n+     *\/\n+    @OpDeclaration(YieldOp.NAME)\n+    public static class YieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"yield\";\n+\n+        public YieldOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        YieldOp(YieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public YieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new YieldOp(this, cc);\n+        }\n+\n+        YieldOp() {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of());\n+        }\n+\n+        YieldOp(List<Value> operands) {\n+            super(NAME, TypeDesc.VOID, operands);\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The terminating unconditional branch operation.\n+     * <p>\n+     * This operation accepts a successor to the next block to branch to.\n+     *\/\n+    @OpDeclaration(BranchOp.NAME)\n+    public static class BranchOp extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"branch\";\n+\n+        final Block.Reference b;\n+\n+        public BranchOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty() || def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero arguments and one successor\" + def.name());\n+            }\n+\n+            this.b = def.successors().get(0);\n+        }\n+\n+        BranchOp(BranchOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.b = cc.getSuccessorOrCreate(that.b);\n+        }\n+\n+        @Override\n+        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BranchOp(this, cc);\n+        }\n+\n+        BranchOp(Block.Reference successor) {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of());\n+\n+            this.b = successor;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(b);\n+        }\n+\n+        public Block.Reference branch() {\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating conditional branch operation.\n+     * <p>\n+     * This operation accepts a boolean operand and two successors, the true successor and false successor.\n+     * When the operand is true the  true successor is selected, otherwise the false successor is selected.\n+     * The selected successor refers to the next block to branch to.\n+     *\/\n+    @OpDeclaration(ConditionalBranchOp.NAME)\n+    public static class ConditionalBranchOp extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"cbranch\";\n+\n+        final Block.Reference t;\n+        final Block.Reference f;\n+\n+        public ConditionalBranchOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1 || def.successors().size() != 2) {\n+                throw new IllegalArgumentException(\"Operation must one operand and two successors\" + def.name());\n+            }\n+\n+            this.t = def.successors().get(0);\n+            this.f = def.successors().get(1);\n+        }\n+\n+        ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.t = cc.getSuccessorOrCreate(that.t);\n+            this.f = cc.getSuccessorOrCreate(that.f);\n+        }\n+\n+        @Override\n+        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConditionalBranchOp(this, cc);\n+        }\n+\n+        ConditionalBranchOp(Value p, Block.Reference t, Block.Reference f) {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of(p));\n+\n+            this.t = t;\n+            this.f = f;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(t, f);\n+        }\n+\n+        public Value predicate() {\n+            return operands().get(0);\n+        }\n+\n+        public Block.Reference trueBranch() {\n+            return t;\n+        }\n+\n+        public Block.Reference falseBranch() {\n+            return f;\n+        }\n+    }\n+\n+    \/**\n+     * The constant operation, that can model Java language literal and constant expressions.\n+     *\/\n+    @OpDeclaration(ConstantOp.NAME)\n+    public static class ConstantOp extends OpWithDefinition implements Op.Pure {\n+        public static final String NAME = \"constant\";\n+\n+        public static final String ATTRIBUTE_CONSTANT_VALUE = NAME + \".value\";\n+\n+        final Object value;\n+\n+        public static ConstantOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have zero operands\");\n+            }\n+\n+            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE,true,\n+                    v -> processConstantValue(def.resultType(), v));\n+            return new ConstantOp(def, value);\n+        }\n+\n+        static Object processConstantValue(TypeDesc t, Object value) {\n+            if (t.equals(TypeDesc.BOOLEAN)) {\n+                if (value instanceof String s) {\n+                    return Boolean.valueOf(s);\n+                } else if (value instanceof Boolean) {\n+                    return value;\n+                }\n+            } else if (t.equals(TypeDesc.BYTE)) {\n+                if (value instanceof String s) {\n+                    return Byte.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.byteValue();\n+                }\n+            } else if (t.equals(TypeDesc.SHORT)) {\n+                if (value instanceof String s) {\n+                    return Short.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.shortValue();\n+                }\n+            } else if (t.equals(TypeDesc.CHAR)) {\n+                if (value instanceof String s) {\n+                    return s.charAt(0);\n+                } else if (value instanceof Character) {\n+                    return value;\n+                }\n+            } else if (t.equals(TypeDesc.INT)) {\n+                if (value instanceof String s) {\n+                    return Integer.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.intValue();\n+                }\n+            } else if (t.equals(TypeDesc.LONG)) {\n+                if (value instanceof String s) {\n+                    return Long.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.longValue();\n+                }\n+            } else if (t.equals(TypeDesc.FLOAT)) {\n+                if (value instanceof String s) {\n+                    return Float.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.floatValue();\n+                }\n+            } else if (t.equals(TypeDesc.DOUBLE)) {\n+                if (value instanceof String s) {\n+                    return Double.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.doubleValue();\n+                }\n+            } else if (t.equals(TypeDesc.J_L_STRING)) {\n+                return value == NULL_ATTRIBUTE_VALUE ? null :\n+                        value.toString();\n+            } else if (t.equals(TypeDesc.J_L_CLASS)) {\n+                return value == NULL_ATTRIBUTE_VALUE ? null :\n+                        TypeDesc.ofNominalDescriptor(ClassDesc.of(value.toString()));\n+            } else if (value == NULL_ATTRIBUTE_VALUE) {\n+                return null; \/\/ null constant\n+            }\n+\n+            throw new UnsupportedOperationException(\"Unsupported constant type and value: \" + t + \" \" + value);\n+        }\n+\n+        ConstantOp(OpDefinition def, Object value) {\n+            super(def);\n+\n+            this.value = value;\n+        }\n+\n+        ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        ConstantOp(TypeDesc type, Object value) {\n+            super(NAME, type, List.of());\n+\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", value == null ? NULL_ATTRIBUTE_VALUE : value);\n+            return attrs;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+    }\n+\n+    \/\/ @@@: Might be useful for pattern matching, but seems unused for now\n+\n+    \/**\n+     * An operation characteristic indicating the operation's behavior may be emulated using Java reflection.\n+     * A descriptor is derived from or declared by the operation that can be resolved at runtime to\n+     * an instance of a reflective handle or member. That handle or member can be operated on to\n+     * emulate the operation's behavior, specifically as bytecode behavior.\n+     *\/\n+    public sealed interface ReflectiveOp {\n+    }\n+\n+    \/**\n+     * The invoke operation, that can model Java language method invocation expressions.\n+     *\/\n+    @OpDeclaration(InvokeOp.NAME)\n+    public static final class InvokeOp extends OpWithDefinition implements ReflectiveOp {\n+        public static final String NAME = \"invoke\";\n+        public static final String ATTRIBUTE_INVOKE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final MethodDesc invokeDescriptor;\n+\n+        public static InvokeOp create(OpDefinition def) {\n+            MethodDesc invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n+                    true, v -> switch(v) {\n+                        case String s -> MethodDesc.ofString(s);\n+                        case MethodDesc md -> md;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n+                    });\n+\n+            return new InvokeOp(def, invokeDescriptor);\n+        }\n+\n+        InvokeOp(OpDefinition def, MethodDesc invokeDescriptor) {\n+            super(def);\n+\n+            this.invokeDescriptor = invokeDescriptor;\n+        }\n+\n+        InvokeOp(InvokeOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.invokeDescriptor = that.invokeDescriptor;\n+        }\n+\n+        @Override\n+        public InvokeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InvokeOp(this, cc);\n+        }\n+\n+        InvokeOp(MethodDesc invokeDescriptor, List<Value> args) {\n+            this(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+        }\n+\n+        InvokeOp(TypeDesc resultType, MethodDesc invokeDescriptor, List<Value> args) {\n+            super(NAME, resultType, args);\n+\n+            this.invokeDescriptor = invokeDescriptor;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", invokeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public MethodDesc invokeDescriptor() {\n+            return invokeDescriptor;\n+        }\n+\n+        public boolean hasReceiver() {\n+            return operands().size() != invokeDescriptor().type().parameters().size();\n+        }\n+    }\n+\n+    \/**\n+     * The conversion operation, that can model Java language implicit and explicit\n+     * conversions such as widening and narrowing.\n+     *\/\n+    @OpDeclaration(ConvOp.NAME)\n+    public static final class ConvOp extends OpWithDefinition implements Op.Pure {\n+        public static final String NAME = \"conv\";\n+\n+        public ConvOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ConvOp(ConvOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvOp(this, cc);\n+        }\n+\n+        ConvOp(TypeDesc resultType, Value arg) {\n+            super(NAME, resultType, List.of(arg));\n+        }\n+    }\n+\n+    \/**\n+     * The new operation, that can models Java language instance creation expressions.\n+     *\/\n+    @OpDeclaration(NewOp.NAME)\n+    public static final class NewOp extends OpWithDefinition implements ReflectiveOp {\n+        public static final String NAME = \"new\";\n+        public static final String ATTRIBUTE_NEW_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final MethodTypeDesc constructorDescriptor;\n+\n+        public static NewOp create(OpDefinition def) {\n+            MethodTypeDesc constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,true,\n+                    v -> switch(v) {\n+                        case String s -> MethodTypeDesc.ofString(s);\n+                        case MethodTypeDesc mtd -> mtd;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported new descriptor value:\" + v);\n+                    });\n+            return new NewOp(def, constructorDescriptor);\n+        }\n+\n+        NewOp(OpDefinition def, MethodTypeDesc constructorDescriptor) {\n+            super(def);\n+\n+            this.constructorDescriptor = constructorDescriptor;\n+        }\n+\n+        NewOp(NewOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.constructorDescriptor = that.constructorDescriptor;\n+        }\n+\n+        @Override\n+        public NewOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NewOp(this, cc);\n+        }\n+\n+        NewOp(MethodTypeDesc constructorDescriptor, List<Value> args) {\n+            this(constructorDescriptor.returnType(), constructorDescriptor, args);\n+        }\n+\n+        NewOp(TypeDesc resultType, MethodTypeDesc constructorDescriptor, List<Value> args) {\n+            super(NAME, resultType, args);\n+\n+            this.constructorDescriptor = constructorDescriptor;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", constructorDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeDesc type() {\n+            return descriptor().returnType();\n+        }\n+\n+        public MethodTypeDesc constructorDescriptor() {\n+            return constructorDescriptor;\n+        }\n+    }\n+\n+    \/**\n+     * An operation that performs access.\n+     *\/\n+    public sealed interface AccessOp {\n+    }\n+\n+    \/**\n+     * A field access operation, that can model Java langauge field access expressions.\n+     *\/\n+    public abstract static sealed class FieldAccessOp extends OpWithDefinition implements AccessOp, ReflectiveOp {\n+        public static final String ATTRIBUTE_FIELD_DESCRIPTOR = \"field.descriptor\";\n+\n+        final FieldDesc fieldDescriptor;\n+\n+        FieldAccessOp(OpDefinition def, FieldDesc fieldDescriptor) {\n+            super(def);\n+\n+            this.fieldDescriptor = fieldDescriptor;\n+        }\n+\n+        FieldAccessOp(FieldAccessOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.fieldDescriptor = that.fieldDescriptor;\n+        }\n+\n+        FieldAccessOp(String name, TypeDesc resultType, List<Value> operands,\n+                      FieldDesc fieldDescriptor) {\n+            super(name, resultType, operands);\n+\n+            this.fieldDescriptor = fieldDescriptor;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", fieldDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public final FieldDesc fieldDescriptor() {\n+            return fieldDescriptor;\n+        }\n+\n+        \/**\n+         * The field load operation, that can model Java language field access expressions combined with load access to\n+         * field instance variables.\n+         *\/\n+        @OpDeclaration(FieldLoadOp.NAME)\n+        public static final class FieldLoadOp extends FieldAccessOp implements Op.Pure {\n+            public static final String NAME = \"field.load\";\n+\n+            public static FieldLoadOp create(OpDefinition def) {\n+                if (def.operands().size() > 1) {\n+                    throw new IllegalArgumentException(\"Operation must accept zero or one operand\");\n+                }\n+\n+                FieldDesc fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n+                        v -> switch(v) {\n+                            case String s -> FieldDesc.ofString(s);\n+                            case FieldDesc fd -> fd;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                        });\n+                return new FieldLoadOp(def, fieldDescriptor);\n+            }\n+\n+            FieldLoadOp(OpDefinition opdef, FieldDesc fieldDescriptor) {\n+                super(opdef, fieldDescriptor);\n+            }\n+\n+            FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new FieldLoadOp(this, cc);\n+            }\n+\n+            \/\/ instance\n+            FieldLoadOp(FieldDesc descriptor, Value receiver) {\n+                super(NAME, descriptor.type(),\n+                        List.of(receiver), descriptor);\n+            }\n+\n+            \/\/ static\n+            FieldLoadOp(FieldDesc descriptor) {\n+                super(NAME, descriptor.type(),\n+                        List.of(), descriptor);\n+            }\n+        }\n+\n+        \/**\n+         * The field store operation, that can model Java language field access expressions combined with store access\n+         * to field instance variables.\n+         *\/\n+        @OpDeclaration(FieldStoreOp.NAME)\n+        public static final class FieldStoreOp extends FieldAccessOp {\n+            public static final String NAME = \"field.store\";\n+\n+            public static FieldStoreOp create(OpDefinition def) {\n+                if (def.operands().size() > 2) {\n+                    throw new IllegalArgumentException(\"Operation must accept one or two operands\");\n+                }\n+\n+                FieldDesc fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n+                        v -> switch(v) {\n+                            case String s -> FieldDesc.ofString(s);\n+                            case FieldDesc fd -> fd;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                        });\n+                return new FieldStoreOp(def, fieldDescriptor);\n+            }\n+\n+            FieldStoreOp(OpDefinition opdef, FieldDesc fieldDescriptor) {\n+                super(opdef, fieldDescriptor);\n+            }\n+\n+            FieldStoreOp(FieldStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public FieldStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new FieldStoreOp(this, cc);\n+            }\n+\n+            \/\/ instance\n+            FieldStoreOp(FieldDesc descriptor, Value receiver, Value v) {\n+                super(NAME, TypeDesc.VOID,\n+                        List.of(receiver, v), descriptor);\n+            }\n+\n+            \/\/ static\n+            FieldStoreOp(FieldDesc descriptor, Value v) {\n+                super(NAME, TypeDesc.VOID,\n+                        List.of(v), descriptor);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The array length operation, that can model Java language field access expressions to the length field of an\n+     * array.\n+     *\/\n+    @OpDeclaration(ArrayLengthOp.NAME)\n+    public static final class ArrayLengthOp extends OpWithDefinition implements ReflectiveOp {\n+        public static final String NAME = \"array.length\";\n+\n+        public ArrayLengthOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthOp(this, cc);\n+        }\n+\n+        ArrayLengthOp(Value array) {\n+            super(NAME, TypeDesc.INT, List.of(array));\n+        }\n+    }\n+\n+    \/**\n+     * The array access operation, that can model Java language array access expressions.\n+     *\/\n+    public abstract static sealed class ArrayAccessOp extends OpWithDefinition implements AccessOp, ReflectiveOp {\n+        ArrayAccessOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2 && def.operands().size() != 3) {\n+                throw new IllegalArgumentException(\"Operation must have 2 or 3 operands\");\n+            }\n+        }\n+\n+        ArrayAccessOp(ArrayAccessOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        ArrayAccessOp(ArrayAccessOp that, List<Value> operands) {\n+            super(that.opName(), resultType(operands.get(0), operands.size() == 2 ? null : operands.get(2)), operands);\n+        }\n+\n+        ArrayAccessOp(String name,\n+                      Value array, Value index, Value v) {\n+            super(name, resultType(array, v), operands(array, index, v));\n+        }\n+\n+        static List<Value> operands(Value array, Value index, Value v) {\n+            return v == null\n+                    ? List.of(array, index)\n+                    : List.of(array, index, v);\n+        }\n+\n+        static TypeDesc resultType(Value array, Value v) {\n+            TypeDesc arrayType = array.type();\n+            if (!arrayType.isArray()) {\n+                throw new IllegalArgumentException(\"Type is not an array type: \" + arrayType);\n+            }\n+\n+            \/\/ @@@ restrict to indexes of int?\n+            TypeDesc componentType = arrayType.componentType();\n+            if (v == null) {\n+                return componentType;\n+            } else {\n+                return TypeDesc.VOID;\n+            }\n+        }\n+\n+        \/**\n+         * The array load operation, that can model Java language array expressions combined with load access to the\n+         * components of an array.\n+         *\/\n+        @OpDeclaration(ArrayLoadOp.NAME)\n+        public static final class ArrayLoadOp extends ArrayAccessOp implements Op.Pure {\n+            public static final String NAME = \"array.load\";\n+\n+            public ArrayLoadOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            ArrayLoadOp(ArrayLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public ArrayLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new ArrayLoadOp(this, cc);\n+            }\n+\n+            ArrayLoadOp(Value array, Value index) {\n+                super(NAME, array, index, null);\n+            }\n+        }\n+\n+        \/**\n+         * The array store operation, that can model Java language array expressions combined with store access to the\n+         * components of an array.\n+         *\/\n+        @OpDeclaration(ArrayStoreOp.NAME)\n+        public static final class ArrayStoreOp extends ArrayAccessOp {\n+            public static final String NAME = \"array.store\";\n+\n+            public ArrayStoreOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            ArrayStoreOp(ArrayStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public ArrayStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new ArrayStoreOp(this, cc);\n+            }\n+\n+            ArrayStoreOp(Value array, Value index, Value v) {\n+                super(NAME, array, index, v);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The instanceof operation, that can model Java language instanceof expressions when the instanceof keyword is a\n+     * type comparison operator.\n+     *\/\n+    @OpDeclaration(InstanceOfOp.NAME)\n+    public static final class InstanceOfOp extends OpWithDefinition implements Op.Pure, ReflectiveOp {\n+        public static final String NAME = \"instanceof\";\n+        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final TypeDesc typeDescriptor;\n+\n+        public static InstanceOfOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+\n+            TypeDesc typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+                    v -> switch(v) {\n+                        case String s -> TypeDesc.ofString(s);\n+                        case TypeDesc td -> td;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n+                    });\n+            return new InstanceOfOp(def, typeDescriptor);\n+        }\n+\n+        InstanceOfOp(OpDefinition def, TypeDesc typeDescriptor) {\n+            super(def);\n+\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        InstanceOfOp(InstanceOfOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.typeDescriptor = that.typeDescriptor;\n+        }\n+\n+        @Override\n+        public InstanceOfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InstanceOfOp(this, cc);\n+        }\n+\n+        InstanceOfOp(TypeDesc t, Value v) {\n+            super(NAME, TypeDesc.BOOLEAN,\n+                    List.of(v));\n+\n+            this.typeDescriptor = t;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", typeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeDesc type() {\n+            return typeDescriptor;\n+        }\n+    }\n+\n+    \/**\n+     * The cast operation, that can model Java language cast expressions.\n+     *\/\n+    @OpDeclaration(CastOp.NAME)\n+    public static final class CastOp extends OpWithDefinition implements Op.Pure, ReflectiveOp {\n+        public static final String NAME = \"cast\";\n+        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final TypeDesc typeDescriptor;\n+\n+        public static CastOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+\n+            TypeDesc typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+                    v -> switch(v) {\n+                        case String s -> TypeDesc.ofString(s);\n+                        case TypeDesc td -> td;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n+                    });\n+            return new CastOp(def, typeDescriptor);\n+        }\n+\n+        CastOp(OpDefinition def, TypeDesc typeDescriptor) {\n+            super(def);\n+\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        CastOp(CastOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.typeDescriptor = that.typeDescriptor;\n+        }\n+\n+        @Override\n+        public CastOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CastOp(this, cc);\n+        }\n+\n+        CastOp(TypeDesc resultType, TypeDesc t, Value v) {\n+            super(NAME, resultType,\n+                    List.of(v));\n+\n+            this.typeDescriptor = t;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", typeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeDesc type() {\n+            return typeDescriptor;\n+        }\n+    }\n+\n+\n+    \/\/ Synthetic\/hidden type that is the result of a VarOp operation\n+    \/\/ and is an operand of VarLoad and VarStore operation\n+    \/\/ Instances should never leak out when interpreting an expression\n+    \/\/ or executing a compiled (to bytecode) expression\n+\n+    \/**\n+     * A synthetic var type that can model a Java language local variable\n+     * @param <T> the type of the var's value.\n+     *\/\n+    public interface Var<T> {\n+        \/**\n+         * The type descriptor of the var type.\n+         *\/\n+        TypeDesc VAR_TYPE = new TypeDescImpl(\"Var\");\n+\n+        \/**\n+         * {@return the value of a var}\n+         *\/\n+        T value();\n+\n+        \/**\n+         * {@return the parameterized type of a var}\n+         * @param type the value's type.\n+         *\/\n+        static TypeDesc type(TypeDesc type) {\n+            return TypeDesc.type(VAR_TYPE, type);\n+        }\n+\n+        \/**\n+         * Constructs an instance of a var.\n+         * @param value the initial value of the var.\n+         * @return the var\n+         * @param <T> the type of the var's value.\n+         *\/\n+        static <T> Var<T> of(T value) {\n+            return () -> value;\n+        }\n+    }\n+\n+    \/**\n+     * The variable operation, that can model declarations of Java language local variables, method parameters, or\n+     * lambda parameters.\n+     *\/\n+    @OpDeclaration(VarOp.NAME)\n+    public static final class VarOp extends OpWithDefinition {\n+        public static final String NAME = \"var\";\n+        public static final String ATTRIBUTE_NAME = NAME + \".name\";\n+\n+        final String name;\n+\n+        public static VarOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            String name = def.extractAttributeValue(ATTRIBUTE_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported var name value:\" + v);\n+                    });\n+            return new VarOp(def, name);\n+        }\n+\n+        VarOp(OpDefinition def, String name) {\n+            super(def);\n+\n+            this.name = name;\n+        }\n+\n+        VarOp(VarOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.name = that.name;\n+        }\n+\n+        @Override\n+        public VarOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VarOp(this, cc);\n+        }\n+\n+        VarOp(String varName, TypeDesc type, Value init) {\n+            super(NAME, Var.type(type), List.of(init));\n+\n+            this.name = varName;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            if (name == null) {\n+                return super.attributes();\n+            }\n+\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", name);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public String varName() {\n+            return name;\n+        }\n+\n+        public TypeDesc varType() {\n+            return descriptor().parameters().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * The var access operation, that can model access to Java language local variables, method parameters, or\n+     * lambda parameters.\n+     *\/\n+    public abstract static sealed class VarAccessOp extends OpWithDefinition implements AccessOp {\n+        VarAccessOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        VarAccessOp(String name, TypeDesc resultType, List<Value> operands) {\n+            super(name, resultType, operands);\n+        }\n+\n+        public VarOp varOp() {\n+            \/\/ @@@ At a high-level a Var value occur as a BlockArgument.\n+            \/\/ Lowering should remove such cases and the var definition should emerge\n+            \/\/ @@@ This method is used when transforming to pure SSA\n+            Result variable = (Result) operands().get(0);\n+            return (VarOp) variable.op();\n+        }\n+\n+        static Value checkIsVarOp(Value varValue) {\n+            if (!varValue.type().rawType().equals(Var.VAR_TYPE)) {\n+                throw new IllegalArgumentException(\"Value is of type Var: \" + varValue);\n+            }\n+            return varValue;\n+        }\n+\n+        \/**\n+         * The variable load operation, that models a reading variable.\n+         *\/\n+        @OpDeclaration(VarLoadOp.NAME)\n+        public static final class VarLoadOp extends VarAccessOp {\n+            public static final String NAME = \"var.load\";\n+\n+            public VarLoadOp(OpDefinition opdef) {\n+                super(opdef);\n+\n+                if (opdef.operands().size() != 1) {\n+                    throw new IllegalArgumentException(\"Operation must have one operand\");\n+                }\n+                checkIsVarOp(opdef.operands().get(0));\n+            }\n+\n+            VarLoadOp(VarLoadOp that, CopyContext cc) {\n+                this(cc.getValues(that.operands()));\n+            }\n+\n+            VarLoadOp(List<Value> varValue) {\n+                super(NAME, getresultType(checkIsVarOp(varValue.get(0))), varValue);\n+            }\n+\n+            @Override\n+            public VarLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new VarLoadOp(this, cc);\n+            }\n+\n+            \/\/ (Variable)VarType\n+            VarLoadOp(Value varValue) {\n+                super(NAME, getresultType(checkIsVarOp(varValue)), List.of(varValue));\n+            }\n+\n+            static TypeDesc getresultType(Value varValue) {\n+                TypeDesc varType = varValue.type();\n+\n+                if (!varType.rawType().equals(Var.VAR_TYPE)) {\n+                    throw new IllegalArgumentException(\n+                            \"Var value type is not of the Var type: \" + varType);\n+                }\n+\n+                if (!varType.hasTypeArguments()) {\n+                    throw new IllegalArgumentException(\n+                            \"Var value type is not parameterized with its value types: \" + varType);\n+                }\n+\n+                return varType.typeArguments().get(0);\n+            }\n+        }\n+\n+        \/**\n+         * The variable store operation, that can model a variable assignment.\n+         *\/\n+        @OpDeclaration(VarStoreOp.NAME)\n+        public static final class VarStoreOp extends VarAccessOp {\n+            public static final String NAME = \"var.store\";\n+\n+            public VarStoreOp(OpDefinition opdef) {\n+                super(opdef);\n+\n+                if (opdef.operands().size() != 2) {\n+                    throw new IllegalArgumentException(\"Operation must have two operands\");\n+                }\n+                checkIsVarOp(opdef.operands().get(0));\n+            }\n+\n+            VarStoreOp(VarStoreOp that, CopyContext cc) {\n+                this(cc.getValues(that.operands()));\n+            }\n+\n+            VarStoreOp(List<Value> values) {\n+                super(NAME, getresultType(checkIsVarOp(values.get(0))),\n+                        values);\n+            }\n+\n+            @Override\n+            public VarStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new VarStoreOp(this, cc);\n+            }\n+\n+            \/\/ (Variable, VarType)void\n+            VarStoreOp(Value varValue, Value v) {\n+                super(NAME, getresultType(checkIsVarOp(varValue)),\n+                        List.of(varValue, v));\n+            }\n+\n+            static TypeDesc getresultType(Value varValue) {\n+                TypeDesc varType = varValue.type();\n+\n+                if (!varType.rawType().equals(Var.VAR_TYPE)) {\n+                    throw new IllegalArgumentException(\n+                            \"Var value type is not of the Var type: \" + varType);\n+                }\n+\n+                if (!varType.hasTypeArguments()) {\n+                    throw new IllegalArgumentException(\n+                            \"Var value type is not parameterized with its value types: \" + varType);\n+                }\n+\n+                return TypeDesc.VOID;\n+            }\n+        }\n+    }\n+\n+    \/\/ Synthetic\/hidden type that is the result of a TupleOp operation\n+\n+    \/**\n+     * A synthetic tuple type.\n+     *\/\n+    public interface Tuple {\n+        TypeDesc TUPLE_TYPE = new TypeDescImpl(CoreOps_CLASS_NAME +\n+                \"$\" + Tuple.class.getSimpleName());\n+\n+        static TypeDesc typeFromValues(Value... values) {\n+            return type(Stream.of(values).map(Value::type).toArray(TypeDesc[]::new));\n+        }\n+\n+        static TypeDesc typeFromValues(List<? extends Value> values) {\n+            return type(values.stream().map(Value::type).toArray(TypeDesc[]::new));\n+        }\n+\n+        static TypeDesc type(TypeDesc... types) {\n+            return TypeDesc.type(\n+                    TUPLE_TYPE,\n+                    types);\n+        }\n+\n+        static TypeDesc type(List<TypeDesc> types) {\n+            return TypeDesc.type(\n+                    TUPLE_TYPE,\n+                    types);\n+        }\n+    }\n+\n+    \/\/ Tuple operations, for modelling return with multiple values\n+\n+    \/**\n+     * The tuple operation. A tuple contain a fixed set of values accessible by their component index.\n+     *\/\n+    @OpDeclaration(TupleOp.NAME)\n+    public static final class TupleOp extends OpWithDefinition {\n+        public static final String NAME = \"tuple\";\n+\n+        public TupleOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        TupleOp(TupleOp that, CopyContext cc) {\n+            this(cc.getValues(that.operands()));\n+        }\n+\n+        @Override\n+        public TupleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleOp(this, cc);\n+        }\n+\n+        TupleOp(List<? extends Value> componentValues) {\n+            super(NAME, Tuple.typeFromValues(componentValues), componentValues);\n+        }\n+    }\n+\n+    \/**\n+     * The tuple component load operation, that access the component of a tuple at a given, constant, component index.\n+     *\/\n+    @OpDeclaration(TupleLoadOp.NAME)\n+    public static final class TupleLoadOp extends OpWithDefinition {\n+        public static final String NAME = \"tuple.load\";\n+        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n+\n+        final int index;\n+\n+        public static TupleLoadOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n+                    });\n+            return new TupleLoadOp(def, index);\n+        }\n+\n+        TupleLoadOp(OpDefinition def, int index) {\n+            super(def);\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        TupleLoadOp(TupleLoadOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        TupleLoadOp(TupleLoadOp that, List<Value> values) {\n+            super(NAME, getresultType(values.get(0), that.index), values);\n+\n+            this.index = that.index;\n+        }\n+\n+        @Override\n+        public TupleLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleLoadOp(this, cc);\n+        }\n+\n+        TupleLoadOp(Value tupleValue, int index) {\n+            super(NAME, getresultType(tupleValue, index), List.of(tupleValue));\n+\n+            this.index = index;\n+        }\n+\n+        static TypeDesc getresultType(Value tupleValue, int index) {\n+            TypeDesc tupleType = tupleValue.type();\n+\n+            if (!tupleType.rawType().equals(Tuple.TUPLE_TYPE)) {\n+                throw new IllegalArgumentException(\n+                        \"Tuple value type is not of the Tuple type: \" + tupleType);\n+            }\n+\n+            if (!tupleType.hasTypeArguments()) {\n+                throw new IllegalArgumentException(\n+                        \"Tuple value type is not parameterized with component types: \" + tupleType);\n+            }\n+\n+            List<TypeDesc> tupleComponentTypes = tupleType.typeArguments();\n+            if (index < 0 || index >= tupleComponentTypes.size()) {\n+                throw new IllegalArgumentException(\n+                        \"Tuple component index out of range:: \" + index);\n+            }\n+\n+            return tupleComponentTypes.get(index);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", index);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int index() {\n+            return index;\n+        }\n+    }\n+\n+    \/**\n+     * The tuple component load operation, that access the component of a tuple at a given, constant, component index.\n+     *\/\n+    @OpDeclaration(TupleWithOp.NAME)\n+    public static final class TupleWithOp extends OpWithDefinition {\n+        public static final String NAME = \"tuple.with\";\n+        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n+\n+        final int index;\n+\n+        public static TupleWithOp create(OpDefinition def) {\n+            if (def.operands().size() != 2) {\n+                throw new IllegalStateException(\"Operation must have two operands\");\n+            }\n+\n+            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n+                    });\n+            return new TupleWithOp(def, index);\n+        }\n+\n+        TupleWithOp(OpDefinition def, int index) {\n+            super(def);\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        TupleWithOp(TupleWithOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        TupleWithOp(TupleWithOp that, List<Value> values) {\n+            super(NAME, getresultType(values.get(0), that.index, values.get(1)), values);\n+\n+            this.index = that.index;\n+        }\n+\n+        @Override\n+        public TupleWithOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleWithOp(this, cc);\n+        }\n+\n+        TupleWithOp(Value tupleValue, int index, Value value) {\n+            super(NAME, getresultType(tupleValue, index, value), List.of(tupleValue, value));\n+\n+            this.index = index;\n+        }\n+\n+        static TypeDesc getresultType(Value tupleValue, int index, Value value) {\n+            TypeDesc tupleType = tupleValue.type();\n+\n+            if (!tupleType.rawType().equals(Tuple.TUPLE_TYPE)) {\n+                throw new IllegalArgumentException(\n+                        \"Tuple value type is not of the Tuple type: \" + tupleType);\n+            }\n+\n+            if (!tupleType.hasTypeArguments()) {\n+                throw new IllegalArgumentException(\n+                        \"Tuple value type is not parameterized with component types: \" + tupleType);\n+            }\n+\n+            List<TypeDesc> tupleComponentTypes = new ArrayList<>(tupleType.typeArguments());\n+            if (index < 0 || index >= tupleComponentTypes.size()) {\n+                throw new IllegalArgumentException(\n+                        \"Tuple component index out of range:: \" + index);\n+            }\n+\n+            tupleComponentTypes.set(index, value.type());\n+            return Tuple.type(tupleComponentTypes);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", index);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int index() {\n+            return index;\n+        }\n+    }\n+\n+    \/\/ @@@ Sealed\n+    \/\/ Synthetic\/hidden type that is the result type of an ExceptionRegionStart operation\n+    \/\/ and is an operand of an ExceptionRegionEnd operation\n+\n+    \/**\n+     * A synthetic exception region type, that is the operation result-type of an exception region\n+     * start operation.\n+     *\/\n+    \/\/ @@@: Maybe drop and move the constants elsewhere\n+    public interface ExceptionRegion {\n+        TypeDesc EXCEPTION_REGION_TYPE = new TypeDescImpl(\"ExceptionRegion\");\n+    }\n+\n+    \/**\n+     * The exception region start operation.\n+     *\/\n+    @OpDeclaration(ExceptionRegionEnter.NAME)\n+    public static final class ExceptionRegionEnter extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"exception.region.enter\";\n+\n+        \/\/ First successor is the non-exceptional successor whose target indicates\n+        \/\/ the first block in the exception region.\n+        \/\/ One or more subsequent successors target the exception catching blocks\n+        \/\/ each of which have one block argument whose type is an exception type.\n+        final List<Block.Reference> s;\n+\n+        public ExceptionRegionEnter(OpDefinition def) {\n+            super(def);\n+\n+            if (def.successors().size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n+            }\n+\n+            this.s = List.copyOf(def.successors());\n+        }\n+\n+        ExceptionRegionEnter(ExceptionRegionEnter that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+        }\n+\n+        @Override\n+        public ExceptionRegionEnter transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionRegionEnter(this, cc);\n+        }\n+\n+        ExceptionRegionEnter(List<Block.Reference> s) {\n+            super(NAME, ExceptionRegion.EXCEPTION_REGION_TYPE, List.of());\n+\n+            if (s.size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            }\n+\n+            this.s = List.copyOf(s);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return s;\n+        }\n+\n+        public Block.Reference start() {\n+            return s.get(0);\n+        }\n+\n+        public List<Block.Reference> catchBlocks() {\n+            return s.subList(1, s.size());\n+        }\n+    }\n+\n+    \/**\n+     * The exception region end operation.\n+     *\/\n+    @OpDeclaration(ExceptionRegionExit.NAME)\n+    public static final class ExceptionRegionExit extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"exception.region.exit\";\n+\n+        final Block.Reference end;\n+\n+        public ExceptionRegionExit(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\" + def.name());\n+            }\n+\n+            if (def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one successor\" + def.name());\n+            }\n+\n+            this.end = def.successors().get(0);\n+        }\n+\n+        ExceptionRegionExit(ExceptionRegionExit that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.end = cc.getSuccessorOrCreate(that.end);\n+        }\n+\n+        @Override\n+        public ExceptionRegionExit transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionRegionExit(this, cc);\n+        }\n+\n+        ExceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+            super(NAME, TypeDesc.VOID, checkValue(exceptionRegion));\n+\n+            this.end = end;\n+        }\n+\n+        static List<Value> checkValue(Value er) {\n+            if (!(er instanceof Result or && or.op() instanceof ExceptionRegionEnter)) {\n+                throw new IllegalArgumentException(\n+                        \"Operand not the result of an exception.region.start operation: \" + er);\n+            }\n+\n+            return List.of(er);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(end);\n+        }\n+\n+        public Block.Reference end() {\n+            return end;\n+        }\n+\n+        public ExceptionRegionEnter regionStart() {\n+            if (operands().get(0) instanceof Result or &&\n+                    or.op() instanceof ExceptionRegionEnter ers) {\n+                return ers;\n+            }\n+            throw new InternalError(\"Should not reach here\");\n+        }\n+\n+    }\n+\n+    \/\/\n+    \/\/ Arithmetic ops\n+\n+    \/**\n+     * The arithmetic operation.\n+     *\/\n+    public static abstract class ArithmeticOperation extends OpWithDefinition implements Op.Pure {\n+        protected ArithmeticOperation(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n+            }\n+        }\n+\n+        protected ArithmeticOperation(ArithmeticOperation that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected ArithmeticOperation(String name, TypeDesc resultType, List<Value> operands) {\n+            super(name, resultType, operands);\n+        }\n+    }\n+\n+    \/**\n+     * The test operation.\n+     *\/\n+    public static abstract class TestOperation extends OpWithDefinition implements Op.Pure {\n+        protected TestOperation(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n+            }\n+        }\n+\n+        protected TestOperation(TestOperation that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected TestOperation(String name, TypeDesc resultType, List<Value> operands) {\n+            super(name, resultType, operands);\n+        }\n+    }\n+\n+    \/**\n+     * The binary arithmetic operation.\n+     *\/\n+    public static abstract class BinaryOp extends ArithmeticOperation {\n+        protected BinaryOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected BinaryOp(BinaryOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected BinaryOp(String name, TypeDesc resultType, Value lhs, Value rhs) {\n+            super(name, resultType, List.of(lhs, rhs));\n+        }\n+    }\n+\n+    \/**\n+     * The unary arithmetic operation.\n+     *\/\n+    public static abstract class UnaryOp extends ArithmeticOperation {\n+        protected UnaryOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected UnaryOp(UnaryOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected UnaryOp(String name, TypeDesc resultType, Value v) {\n+            super(name, resultType, List.of(v));\n+        }\n+    }\n+\n+    \/**\n+     * The unary test operation.\n+     *\/\n+    public static abstract class UnaryTestOp extends TestOperation {\n+        protected UnaryTestOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected UnaryTestOp(UnaryTestOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected UnaryTestOp(String name, Value v) {\n+            super(name, TypeDesc.BOOLEAN, List.of(v));\n+        }\n+    }\n+\n+    \/**\n+     * The binary test operation.\n+     *\/\n+    public static abstract class BinaryTestOp extends TestOperation {\n+        protected BinaryTestOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected BinaryTestOp(BinaryTestOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected BinaryTestOp(String name, Value lhs, Value rhs) {\n+            super(name, TypeDesc.BOOLEAN, List.of(lhs, rhs));\n+        }\n+    }\n+\n+    \/**\n+     * The add operation, that can model the Java language binary {@code +} operator for numeric types\n+     *\/\n+    @OpDeclaration(AddOp.NAME)\n+    public static final class AddOp extends BinaryOp {\n+        public static final String NAME = \"add\";\n+\n+        public AddOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        AddOp(AddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AddOp(this, cc);\n+        }\n+\n+        AddOp(TypeDesc resultType, Value lhs, Value rhs) {\n+            super(NAME, resultType, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The sub operation, that can model the Java language binary {@code -} operator for numeric types\n+     *\/\n+    @OpDeclaration(SubOp.NAME)\n+    public static final class SubOp extends BinaryOp {\n+        public static final String NAME = \"sub\";\n+\n+        public SubOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        SubOp(SubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SubOp(this, cc);\n+        }\n+\n+        SubOp(TypeDesc resultType, Value lhs, Value rhs) {\n+            super(NAME, resultType, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The mul operation, that can model the Java language binary {@code *} operator for numeric types\n+     *\/\n+    @OpDeclaration(MulOp.NAME)\n+    public static final class MulOp extends BinaryOp {\n+        public static final String NAME = \"mul\";\n+\n+        public MulOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        MulOp(MulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MulOp(this, cc);\n+        }\n+\n+        MulOp(TypeDesc resultType, Value lhs, Value rhs) {\n+            super(NAME, resultType, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The dic operation, that can model the Java language binary {@code \/} operator for numeric types\n+     *\/\n+    @OpDeclaration(DivOp.NAME)\n+    public static final class DivOp extends BinaryOp {\n+        public static final String NAME = \"div\";\n+\n+        public DivOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        DivOp(DivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DivOp(this, cc);\n+        }\n+\n+        DivOp(TypeDesc resultType, Value lhs, Value rhs) {\n+            super(NAME, resultType, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The div operation, that can model the Java language binary {@code %} operator for numeric types\n+     *\/\n+    @OpDeclaration(ModOp.NAME)\n+    public static final class ModOp extends BinaryOp {\n+        public static final String NAME = \"mod\";\n+\n+        public ModOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        ModOp(ModOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ModOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModOp(this, cc);\n+        }\n+\n+        ModOp(TypeDesc resultType, Value lhs, Value rhs) {\n+            super(NAME, resultType, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The neg operation, that can model the Java language unary {@code -} operator for numeric types\n+     *\/\n+    @OpDeclaration(NegOp.NAME)\n+    public static final class NegOp extends UnaryOp {\n+        public static final String NAME = \"neg\";\n+\n+        public NegOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        NegOp(NegOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NegOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NegOp(this, cc);\n+        }\n+\n+        NegOp(TypeDesc resultType, Value v) {\n+            super(NAME, resultType, v);\n+        }\n+    }\n+\n+    \/**\n+     * The not operation, that can model the Java language unary {@code !} operator for boolean types\n+     *\/\n+    @OpDeclaration(NotOp.NAME)\n+    public static final class NotOp extends UnaryOp {\n+        public static final String NAME = \"not\";\n+\n+        public NotOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        NotOp(NotOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NotOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NotOp(this, cc);\n+        }\n+\n+        NotOp(TypeDesc resultType, Value v) {\n+            super(NAME, resultType, v);\n+        }\n+    }\n+\n+    \/**\n+     * The equals operation, that can model the Java language equality {@code ==} operator for numeric, boolean\n+     * and reference types\n+     *\/\n+    @OpDeclaration(EqOp.NAME)\n+    public static final class EqOp extends BinaryTestOp {\n+        public static final String NAME = \"eq\";\n+\n+        public EqOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        EqOp(EqOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public EqOp transform(CopyContext cc, OpTransformer ot) {\n+            return new EqOp(this, cc);\n+        }\n+\n+        EqOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The not equals operation, that can model the Java language equality {@code !=} operator for numeric, boolean\n+     * and reference types\n+     *\/\n+    @OpDeclaration(NeqOp.NAME)\n+    public static final class NeqOp extends BinaryTestOp {\n+        public static final String NAME = \"neq\";\n+\n+        public NeqOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        NeqOp(NeqOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NeqOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NeqOp(this, cc);\n+        }\n+\n+        NeqOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The greater than operation, that can model the Java language relational {@code >} operator for numeric types\n+     *\/\n+    @OpDeclaration(GtOp.NAME)\n+    public static final class GtOp extends BinaryTestOp {\n+        public static final String NAME = \"gt\";\n+\n+        public GtOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        GtOp(GtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GtOp(this, cc);\n+        }\n+\n+        GtOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The greater than or equal to operation, that can model the Java language relational {@code >=} operator for\n+     * numeric types\n+     *\/\n+    @OpDeclaration(GeOp.NAME)\n+    public static final class GeOp extends BinaryTestOp {\n+        public static final String NAME = \"ge\";\n+\n+        public GeOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        GeOp(GeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GeOp(this, cc);\n+        }\n+\n+        GeOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The less than operation, that can model the Java language relational {@code <} operator for\n+     * numeric types\n+     *\/\n+    @OpDeclaration(LtOp.NAME)\n+    public static final class LtOp extends BinaryTestOp {\n+        public static final String NAME = \"lt\";\n+\n+        public LtOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LtOp(LtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LtOp(this, cc);\n+        }\n+\n+        LtOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The less than or equal to operation, that can model the Java language relational {@code <=} operator for\n+     * numeric types\n+     *\/\n+    @OpDeclaration(LeOp.NAME)\n+    public static final class LeOp extends BinaryTestOp {\n+        public static final String NAME = \"le\";\n+\n+        public LeOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LeOp(LeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LeOp(this, cc);\n+        }\n+\n+        LeOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+\n+    \/**\n+     * A factory for core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(CoreOps.class);\n+\n+    \/**\n+     * Creates a function operation builder\n+     * @param funcName the function name\n+     * @param funcDescriptor the function descriptor\n+     * @return the function operation builder\n+     *\/\n+    public static FuncOp.Builder func(String funcName, MethodTypeDesc funcDescriptor) {\n+        return new FuncOp.Builder(null, funcName, funcDescriptor);\n+    }\n+\n+    \/**\n+     * Creates a function operation\n+     * @param funcName the function name\n+     * @param body the function body\n+     * @return the function operation\n+     *\/\n+    public static FuncOp func(String funcName, Body.Builder body) {\n+        return new FuncOp(funcName, body);\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     * @param funcName the name of the function operation\n+     * @param funcDescriptor the function descriptor\n+     * @param args the function argments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, MethodTypeDesc funcDescriptor, Value... args) {\n+        return funcCall(funcName, funcDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     * @param funcName the name of the function operation\n+     * @param funcDescriptor the function descriptor\n+     * @param args the function argments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, MethodTypeDesc funcDescriptor, List<Value> args) {\n+        return new FuncCallOp(funcName, funcDescriptor.returnType(), args);\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     * @param func the target function\n+     * @param args the function argments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(FuncOp func, Value... args) {\n+        return funcCall(func, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     * @param func the target function\n+     * @param args the function argments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(FuncOp func, List<Value> args) {\n+        return new FuncCallOp(func.funcName(), func.funcDescriptor().returnType(), args);\n+    }\n+\n+    \/**\n+     * Creates a module operation.\n+     * @param functions the functions of the module operation\n+     * @return the module operation\n+     *\/\n+    public static ModuleOp module(FuncOp... functions) {\n+        return module(List.of(functions));\n+    }\n+\n+    \/**\n+     * Creates a module operation.\n+     * @param functions the functions of the module operation\n+     * @return the module operation\n+     *\/\n+    public static ModuleOp module(List<FuncOp> functions) {\n+        return new ModuleOp(List.copyOf(functions));\n+    }\n+\n+    \/**\n+     * Creates a quoted operation.\n+     * @param ancestorBody the ancestor of the body of the quoted operation\n+     * @param opFunc a function that accepts the body of the quoted operation and returns the operation to be quoted\n+     * @return the quoted operation\n+     *\/\n+    public static QuotedOp quoted(Body.Builder ancestorBody,\n+                                  Function<Block.Builder, Op> opFunc) {\n+        Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+        Block.Builder block = body.entryBlock();\n+        block.op(_yield(\n+                block.op(opFunc.apply(block))));\n+        return new QuotedOp(body);\n+    }\n+\n+    \/**\n+     * Creates a quoted operation.\n+     * @param body quoted operation body\n+     * @return the quoted operation\n+     *\/\n+    public static QuotedOp quoted(Body.Builder body) {\n+        return new QuotedOp(body);\n+    }\n+\n+    \/**\n+     * Creates a lambda operation.\n+     * @param ancestorBody the ancestor of the body of the lambda operation\n+     * @param functionalDescriptor the lambda operation's functional descriptor\n+     * @param functionalInterface the lambda operation's functional interface\n+     * @return the lambda operation\n+     *\/\n+    public static LambdaOp.Builder lambda(Body.Builder ancestorBody,\n+                                          MethodTypeDesc functionalDescriptor, TypeDesc functionalInterface) {\n+        return new LambdaOp.Builder(ancestorBody, functionalDescriptor, functionalInterface);\n+    }\n+\n+    \/**\n+     * Creates a lambda operation.\n+     * @param functionalInterface the lambda operation's functional interface\n+     * @param body the body of the lambda operation\n+     * @return the lambda operation\n+     *\/\n+    public static LambdaOp lambda(TypeDesc functionalInterface, Body.Builder body) {\n+        return new LambdaOp(functionalInterface, body);\n+    }\n+\n+    \/**\n+     * Creates a closure operation.\n+     * @param ancestorBody the ancestor of the body of the closure operation\n+     * @param functionalDescriptor the closure operation's functional descriptor\n+     * @return the closure operation\n+     *\/\n+    public static ClosureOp.Builder closure(Body.Builder ancestorBody,\n+                                            MethodTypeDesc functionalDescriptor) {\n+        return new ClosureOp.Builder(ancestorBody, functionalDescriptor);\n+    }\n+\n+    \/**\n+     * Creates a closure operation.\n+     * @param body the body of the closure operation\n+     * @return the closure operation\n+     *\/\n+    public static ClosureOp closure(Body.Builder body) {\n+        return new ClosureOp(body);\n+    }\n+\n+    \/**\n+     * Creates a closure call operation.\n+     * @param args the closure arguments. The first argument is the closure operation to be called\n+     * @return the closure call operation\n+     *\/\n+    \/\/ @@@: Is this the right signature?\n+    public static ClosureCallOp closureCall(Value... args) {\n+        return closureCall(List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a closure call operation.\n+     * @param args the closure arguments. The first argument is the closure operation to be called\n+     * @return the closure call operation\n+     *\/\n+    \/\/ @@@: Is this the right signature?\n+    public static ClosureCallOp closureCall(List<Value> args) {\n+        return new ClosureCallOp(args);\n+    }\n+\n+    \/**\n+     * Creates an exception region enter operation\n+     * @param start the exception region block\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region enter operation\n+     *\/\n+    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, Block.Reference... catchers) {\n+        return exceptionRegionEnter(start, List.of(catchers));\n+    }\n+\n+    \/**\n+     * Creates an exception region enter operation\n+     * @param start the exception region block\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region enter operation\n+     *\/\n+    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, List<Block.Reference> catchers) {\n+        List<Block.Reference> s = new ArrayList<>();\n+        s.add(start);\n+        s.addAll(catchers);\n+        return new ExceptionRegionEnter(s);\n+    }\n+\n+    \/**\n+     * Creates an exception region exit operation\n+     * @param exceptionRegion the exception region to be exited\n+     * @param end the block to which control is transferred after the exception region is exited\n+     * @return the exception region exit operation\n+     *\/\n+    public static ExceptionRegionExit exceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+        return new ExceptionRegionExit(exceptionRegion, end);\n+    }\n+\n+    \/**\n+     * Creates a return operation.\n+     * @return the return operation\n+     *\/\n+    public static ReturnOp _return() {\n+        return new ReturnOp();\n+    }\n+\n+    \/**\n+     * Creates a return operation.\n+     * @param returnValue the return value\n+     * @return the return operation\n+     *\/\n+    public static ReturnOp _return(Value returnValue) {\n+        return new ReturnOp(returnValue);\n+    }\n+\n+    \/**\n+     * Creates a throw operation.\n+     * @param exceptionValue the thrown value\n+     * @return the throw operation\n+     *\/\n+    public static ThrowOp _throw(Value exceptionValue) {\n+        return new ThrowOp(exceptionValue);\n+    }\n+\n+    \/**\n+     * Creates an unreachable operation.\n+     * @return the unreachable operation\n+     *\/\n+    public static UnreachableOp unreachable() {\n+        return new UnreachableOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @return the yield operation\n+     *\/\n+    public static YieldOp _yield() {\n+        return new YieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @param yieldValue the yielded value\n+     * @return the yield operation\n+     *\/\n+    public static YieldOp _yield(Value yieldValue) {\n+        return new YieldOp(List.of(yieldValue));\n+    }\n+\n+    \/**\n+     * Creates an unconditional break operation.\n+     * @param target the jump target\n+     * @return the unconditional break operation\n+     *\/\n+    public static BranchOp branch(Block.Reference target) {\n+        return new BranchOp(target);\n+    }\n+\n+    \/**\n+     * Creates a conditional break operation.\n+     * @param condValue the test value of the conditional break operation\n+     * @param trueTarget the jump target when the test value evaluates to true\n+     * @param falseTarget the jump target when the test value evaluates to false\n+     * @return the conditional break operation\n+     *\/\n+    public static ConditionalBranchOp conditionalBranch(Value condValue,\n+                                                        Block.Reference trueTarget, Block.Reference falseTarget) {\n+        return new ConditionalBranchOp(condValue, trueTarget, falseTarget);\n+    }\n+\n+    \/**\n+     * Creates a constant operation.\n+     * @param type the constant type\n+     * @param value the constant value\n+     * @return the constant operation\n+     *\/\n+    public static ConstantOp constant(TypeDesc type, Object value) {\n+        return new ConstantOp(type, value);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(MethodDesc invokeDescriptor, Value... args) {\n+        return new InvokeOp(invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(MethodDesc invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param returnType the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(TypeDesc returnType, MethodDesc invokeDescriptor, Value... args) {\n+        return new InvokeOp(returnType, invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param returnType the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(TypeDesc returnType, MethodDesc invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(returnType, invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates a conversion operation.\n+     *\n+     * @param to the conversion target type\n+     * @param from the value to be converted\n+     * @return the conversion operation\n+     *\/\n+    public static ConvOp conv(TypeDesc to, Value from) {\n+        return new ConvOp(to, from);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(MethodTypeDesc constructorDescriptor, Value... args) {\n+        return _new(constructorDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(MethodTypeDesc constructorDescriptor, List<Value> args) {\n+        return new NewOp(constructorDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType the instance type\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeDesc returnType, MethodTypeDesc constructorDescriptor,\n+                             Value... args) {\n+        return _new(returnType, constructorDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType the instance type\n+     * @param constructorDescriptor the constructor descriptor\n+     * @param args the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeDesc returnType, MethodTypeDesc constructorDescriptor,\n+                             List<Value> args) {\n+        return new NewOp(returnType, constructorDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an array creation operation.\n+     *\n+     * @param arrayType the array type\n+     * @param length the array size\n+     * @return the array creation operation\n+     *\/\n+    public static NewOp newArray(TypeDesc arrayType, Value length) {\n+        return _new(MethodTypeDesc.methodType(arrayType, TypeDesc.INT), length);\n+    }\n+\n+    \/\/ @@@ Add field load\/store overload with explicit fieldType\n+\n+    \/**\n+     * Creates a field load operation to a non-static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param receiver the receiver value\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldDesc descriptor, Value receiver) {\n+        return new FieldAccessOp.FieldLoadOp(descriptor, receiver);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldDesc descriptor) {\n+        return new FieldAccessOp.FieldLoadOp(descriptor);\n+    }\n+\n+    \/**\n+     * Creates a field store operation to a non-static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param receiver the receiver value\n+     * @param v the value to store\n+     * @return the field store operation\n+     *\/\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldDesc descriptor, Value receiver, Value v) {\n+        return new FieldAccessOp.FieldStoreOp(descriptor, receiver, v);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param v the value to store\n+     * @return the field store operation\n+     *\/\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldDesc descriptor, Value v) {\n+        return new FieldAccessOp.FieldStoreOp(descriptor, v);\n+    }\n+\n+    \/**\n+     * Creates an array length operation.\n+     *\n+     * @param array the array value\n+     * @return the array length operation\n+     *\/\n+    public static ArrayLengthOp arrayLength(Value array) {\n+        return new ArrayLengthOp(array);\n+    }\n+\n+    \/**\n+     * Creates an array load operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @return the array load operation\n+     *\/\n+    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index) {\n+        return new ArrayAccessOp.ArrayLoadOp(array, index);\n+    }\n+\n+    \/**\n+     * Creates an array store operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @param v the value to store\n+     * @return the array store operation\n+     *\/\n+    public static ArrayAccessOp.ArrayStoreOp arrayStoreOp(Value array, Value index, Value v) {\n+        return new ArrayAccessOp.ArrayStoreOp(array, index, v);\n+    }\n+\n+    \/**\n+     * Creates an instanceof operation.\n+     *\n+     * @param t the type descriptor of the type to test against\n+     * @param v the value to test\n+     * @return the instanceof operation\n+     *\/\n+    public static InstanceOfOp instanceOf(TypeDesc t, Value v) {\n+        return new InstanceOfOp(t, v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param t the type descriptor of the type to cast to\n+     * @param v the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeDesc t, Value v) {\n+        return new CastOp(t, t, v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param t the type descriptor of the type to cast to\n+     * @param v the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeDesc resultType, TypeDesc t, Value v) {\n+        return new CastOp(resultType, t, v);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(Value init) {\n+        return var(null, init.type(), init);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param type the type of the var's value\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(TypeDesc type, Value init) {\n+        return var(null, type, init);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, Value init) {\n+        return var(name, init.type(), init);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param type the type of the var's value\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeDesc type, Value init) {\n+        return new VarOp(name, type, init);\n+    }\n+\n+    \/**\n+     * Creates a var load operation.\n+     *\n+     * @param varValue the var value\n+     * @return the var load operation\n+     *\/\n+    public static VarAccessOp.VarLoadOp varLoad(Value varValue) {\n+        return new VarAccessOp.VarLoadOp(varValue);\n+    }\n+\n+    \/**\n+     * Creates a var store operation.\n+     *\n+     * @param varValue the var value\n+     * @param v the value to store in the var\n+     * @return the var store operation\n+     *\/\n+    public static VarAccessOp.VarStoreOp varStore(Value varValue, Value v) {\n+        return new VarAccessOp.VarStoreOp(varValue, v);\n+    }\n+\n+    \/**\n+     * Creates a tuple operation.\n+     *\n+     * @param componentValues the values of tuple (in order)\n+     * @return the tuple operation\n+     *\/\n+    public static TupleOp tuple(Value... componentValues) {\n+        return tuple(List.of(componentValues));\n+    }\n+\n+    \/**\n+     * Creates a tuple operation.\n+     *\n+     * @param componentValues the values of tuple (in order)\n+     * @return the tuple operation\n+     *\/\n+    public static TupleOp tuple(List<? extends Value> componentValues) {\n+        return new TupleOp(componentValues);\n+    }\n+\n+    \/**\n+     * Creates a tuple load operation.\n+     *\n+     * @param tuple the tuple value\n+     * @param index the component index value\n+     * @return the tuple load operation\n+     *\/\n+    public static TupleLoadOp tupleLoad(Value tuple, int index) {\n+        return new TupleLoadOp(tuple, index);\n+    }\n+\n+    \/**\n+     * Creates a tuple with operation.\n+     *\n+     * @param tuple the tuple value\n+     * @param index the component index value\n+     * @param value the component value\n+     * @return the tuple with operation\n+     *\/\n+    public static TupleWithOp tupleWith(Value tuple, int index, Value value) {\n+        return new TupleWithOp(tuple, index, value);\n+    }\n+\n+    \/\/\n+    \/\/ Arithmetic ops\n+\n+    \/**\n+     * Creates an add operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the add operation\n+     *\/\n+    public static BinaryOp add(Value lhs, Value rhs) {\n+        return add(lhs.type(), lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates an add operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the add operation\n+     *\/\n+    public static BinaryOp add(TypeDesc resultType, Value lhs, Value rhs) {\n+        return new AddOp(resultType, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a sub operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the sub operation\n+     *\/\n+    public static BinaryOp sub(Value lhs, Value rhs) {\n+        return sub(lhs.type(), lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a sub operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the sub operation\n+     *\/\n+    public static BinaryOp sub(TypeDesc resultType, Value lhs, Value rhs) {\n+        return new SubOp(resultType, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mul operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mul operation\n+     *\/\n+    public static BinaryOp mul(Value lhs, Value rhs) {\n+        return mul(lhs.type(), lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mul operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mul operation\n+     *\/\n+    public static BinaryOp mul(TypeDesc resultType, Value lhs, Value rhs) {\n+        return new MulOp(resultType, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a div operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the div operation\n+     *\/\n+    public static BinaryOp div(Value lhs, Value rhs) {\n+        return div(lhs.type(), lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a div operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the div operation\n+     *\/\n+    public static BinaryOp div(TypeDesc resultType, Value lhs, Value rhs) {\n+        return new DivOp(resultType, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mod operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mod operation\n+     *\/\n+    public static BinaryOp mod(Value lhs, Value rhs) {\n+        return mod(lhs.type(), lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mod operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mod operation\n+     *\/\n+    public static BinaryOp mod(TypeDesc resultType, Value lhs, Value rhs) {\n+        return new ModOp(resultType, lhs, rhs);\n+    }\n+\n+\n+    \/**\n+     * Creates a neg operation.\n+     *\n+     * @param v the operand\n+     * @return the neg operation\n+     *\/\n+    public static UnaryOp neg(Value v) {\n+        return neg(v.type(), v);\n+    }\n+\n+    \/**\n+     * Creates a neg operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param v the operand\n+     * @return the neg operation\n+     *\/\n+    public static UnaryOp neg(TypeDesc resultType, Value v) {\n+        return new NegOp(resultType, v);\n+    }\n+\n+    \/**\n+     * Creates a not operation.\n+     *\n+     * @param v the operand\n+     * @return the not operation\n+     *\/\n+    public static UnaryOp not(Value v) {\n+        return not(v.type(), v);\n+    }\n+\n+    \/**\n+     * Creates a not operation.\n+     *\n+     * @param resultType the operation's result type\n+     * @param v the operand\n+     * @return the not operation\n+     *\/\n+    public static UnaryOp not(TypeDesc resultType, Value v) {\n+        return new NotOp(resultType, v);\n+    }\n+\n+\n+    \/**\n+     * Creates an equals comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the equals comparison operation\n+     *\/\n+    public static BinaryTestOp eq(Value lhs, Value rhs) {\n+        return new EqOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a not equals comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the not equals comparison operation\n+     *\/\n+    public static BinaryTestOp neq(Value lhs, Value rhs) {\n+        return new NeqOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a greater than comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the greater than comparison operation\n+     *\/\n+    public static BinaryTestOp gt(Value lhs, Value rhs) {\n+        return new GtOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a greater than or equals to comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the greater than or equals to comparison operation\n+     *\/\n+    public static BinaryTestOp ge(Value lhs, Value rhs) {\n+        return new GeOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a less than comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the less than comparison operation\n+     *\/\n+    public static BinaryTestOp lt(Value lhs, Value rhs) {\n+        return new LtOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a less than or equals to comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the less than or equals to comparison operation\n+     *\/\n+    public static BinaryTestOp le(Value lhs, Value rhs) {\n+        return new LeOp(lhs, rhs);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":3583,"deletions":0,"binary":false,"changes":3583,"status":"added"},{"patch":"@@ -0,0 +1,3026 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.RecordTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.Tuple;\n+import static java.lang.reflect.code.op.CoreOps.YieldOp;\n+import static java.lang.reflect.code.op.CoreOps._throw;\n+import static java.lang.reflect.code.op.CoreOps._yield;\n+import static java.lang.reflect.code.op.CoreOps.add;\n+import static java.lang.reflect.code.op.CoreOps.arrayLength;\n+import static java.lang.reflect.code.op.CoreOps.arrayLoadOp;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+import static java.lang.reflect.code.op.CoreOps.invoke;\n+import static java.lang.reflect.code.op.CoreOps.conditionalBranch;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.exceptionRegionEnter;\n+import static java.lang.reflect.code.op.CoreOps.exceptionRegionExit;\n+import static java.lang.reflect.code.op.CoreOps.lt;\n+import static java.lang.reflect.code.descriptor.TypeDesc.*;\n+\n+\/**\n+ * The set of extended operations. A code model, produced by the Java compiler from Java program source, may consist of\n+ * extended operations and core operations. Such a model represents the same Java program and preserves the program\n+ * meaning as defined by the Java Language Specification\n+ * <p>\n+ * Extended operations model specific Java language constructs, often those with structured control flow and nested\n+ * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n+ * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n+ * that are not explicitly lowerable.\n+ * <p>\n+ * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n+ * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n+ * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n+ *\/\n+public class ExtendedOps {\n+    \/\/ Split string to ensure the name does not get rewritten\n+    \/\/ when the script copies this source to the jdk.compiler module\n+    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n+\n+    static final String ExtendedOps_CLASS_NAME = PACKAGE_NAME + \".\" + ExtendedOps.class.getSimpleName();\n+\n+    ExtendedOps() {\n+    }\n+\n+    \/**\n+     * The label operation, that can model Java language statements with label identifiers.\n+     *\/\n+    public static sealed abstract class JavaLabelOp extends OpWithDefinition implements Op.Lowerable, Op.BodyTerminating {\n+        JavaLabelOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        JavaLabelOp(JavaLabelOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        JavaLabelOp(String name, Value label) {\n+            super(name, TypeDesc.VOID, checkLabel(label));\n+        }\n+\n+        static List<Value> checkLabel(Value label) {\n+            return label == null ? List.of() : List.of(label);\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            \/*\n+                A break statement with no label attempts to transfer control to the\n+                innermost enclosing switch, while, do, or for statement; this enclosing statement,\n+                which is called the break target, then immediately completes normally.\n+\n+                A break statement with label Identifier attempts to transfer control to the\n+                enclosing labeled statement (14.7) that has the same Identifier as its label;\n+                this enclosing statement, which is called the break target, then immediately completes normally.\n+                In this case, the break target need not be a switch, while, do, or for statement.\n+             *\/\n+\n+            \/\/ No label\n+            \/\/ Get innermost enclosing loop operation\n+            \/\/ @@@ expand to support innermost enclosing switch operation\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing loop\");\n+                }\n+            } while (!(op instanceof Op.Loop));\n+            \/\/ } while (!(op instanceof Op.Loop lop));\n+            \/\/ error: variable lop might not have been initialized\n+            Op.Loop lop = (Op.Loop) op;\n+            return lop.loopBody() == b ? op : null;\n+        }\n+\n+        boolean isUnlabeled() {\n+            return operands().isEmpty();\n+        }\n+\n+        Op target() {\n+            \/\/ If unlabeled then find the nearest enclosing op\n+            \/\/ Otherwise obtain the label target\n+            if (isUnlabeled()) {\n+                return innerMostEnclosingTarget();\n+            }\n+\n+            Value value = operands().get(0);\n+            if (value instanceof Result r && r.op().ancestorBody().parentOp() instanceof JavaLabeledOp lop) {\n+                return lop.target();\n+            } else {\n+                throw new IllegalStateException(\"Bad label value: \" + value + \" \" + ((Result) value).op());\n+            }\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language break statements with label identifiers.\n+     *\/\n+    @OpDeclaration(JavaBreakOp.NAME)\n+    public static final class JavaBreakOp extends JavaLabelOp {\n+        public static final String NAME = \"java.break\";\n+\n+        public JavaBreakOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaBreakOp(JavaBreakOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaBreakOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBreakOp(this, cc);\n+        }\n+\n+        JavaBreakOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language continue statements with label identifiers.\n+     *\/\n+    @OpDeclaration(JavaContinueOp.NAME)\n+    public static final class JavaContinueOp extends JavaLabelOp {\n+        public static final String NAME = \"java.continue\";\n+\n+        public JavaContinueOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaContinueOp(JavaContinueOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaContinueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaContinueOp(this, cc);\n+        }\n+\n+        JavaContinueOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+    }\n+\n+    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+    }\n+\n+    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n+\n+    static BranchTarget getBranchTarget(CopyContext cc, Op op) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Op, BranchTarget> m = (Map<Op, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(op);\n+        }\n+\n+        return null;\n+    }\n+\n+    static void setBranchTarget(CopyContext cc, Op label, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Op, BranchTarget> x = (Map<Op, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(label, t);\n+    }\n+\n+    \/**\n+     * The yield operation, that can model Java language yield statements.\n+     *\/\n+    @OpDeclaration(JavaYieldOp.NAME)\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"java.yield\";\n+\n+        public JavaYieldOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaYieldOp(JavaYieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaYieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaYieldOp(this, cc);\n+        }\n+\n+        JavaYieldOp() {\n+            super(NAME, TypeDesc.VOID,\n+                    List.of());\n+        }\n+\n+        JavaYieldOp(Value operand) {\n+            super(NAME, TypeDesc.VOID, List.of(operand));\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The block operation, that can model Java language blocks.\n+     *\/\n+    @OpDeclaration(JavaBlockOp.NAME)\n+    \/\/ @@@ Support synchronized attribute\n+    public static final class JavaBlockOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.block\";\n+\n+        final Body body;\n+\n+        public JavaBlockOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaBlockOp(JavaBlockOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaBlockOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBlockOp(this, cc, ot);\n+        }\n+\n+        \/\/ @@@ Support non-void result type\n+        JavaBlockOp(Body.Builder bodyC) {\n+            super(NAME, TypeDesc.VOID, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            }\n+            if (!body.descriptor().parameters().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.descriptor());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The labeled operation, that can model Java language labeled statements.\n+     *\/\n+    @OpDeclaration(JavaLabeledOp.NAME)\n+    public static final class JavaLabeledOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.labeled\";\n+\n+        final Body body;\n+\n+        public JavaLabeledOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaLabeledOp(JavaLabeledOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaLabeledOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaLabeledOp(this, cc, ot);\n+        }\n+\n+        JavaLabeledOp(Body.Builder bodyC) {\n+            super(NAME, TypeDesc.VOID, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            }\n+            if (!body.descriptor().parameters().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.descriptor());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Op label() {\n+            return body.entryBlock().firstOp();\n+        }\n+\n+        public Op target() {\n+            return body.entryBlock().nextOp(label());\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            AtomicBoolean first = new AtomicBoolean();\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                \/\/ Drop first operation that corresponds to the label\n+                if (!first.get()) {\n+                    first.set(true);\n+                    return block;\n+                }\n+\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The if operation, that can model Java language if, if-then, and if-then-else statements.\n+     *\/\n+    @OpDeclaration(JavaIfOp.NAME)\n+    public static final class JavaIfOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        static final MethodTypeDesc PREDICATE_TYPE = MethodTypeDesc.methodType(BOOLEAN);\n+\n+        static final MethodTypeDesc ACTION_TYPE = MethodTypeDesc.VOID;\n+\n+        public static class IfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            IfBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+            }\n+\n+            public ThenBuilder _if(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ThenBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ThenBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ElseIfBuilder then(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+\n+            public ElseIfBuilder then() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ElseIfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ElseIfBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ThenBuilder elseif(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+\n+            public JavaIfOp _else(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+\n+            public JavaIfOp _else() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.if\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaIfOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaIfOp(JavaIfOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaIfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaIfOp(this, cc, ot);\n+        }\n+\n+        JavaIfOp(List<Body.Builder> bodyCs) {\n+            super(NAME, VOID, List.of());\n+\n+            \/\/ Normalize by adding an empty else action\n+            \/\/ @@@ Is this needed?\n+            if (bodyCs.size() % 2 == 0) {\n+                bodyCs = new ArrayList<>(bodyCs);\n+                Body.Builder end = Body.Builder.of(bodyCs.get(0).ancestorBody(),\n+                        MethodTypeDesc.VOID);\n+                end.entryBlock().op(_yield());\n+                bodyCs.add(end);\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+\n+            if (bodies.size() < 2) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body action;\n+                if (i == bodies.size() - 1) {\n+                    action = bodies.get(i);\n+                } else {\n+                    action = bodies.get(i + 1);\n+                    Body fromPred = bodies.get(i);\n+                    if (!fromPred.descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.descriptor());\n+                    }\n+                }\n+                if (!action.descriptor().equals(MethodTypeDesc.VOID)) {\n+                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.descriptor());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Create predicate and action blocks\n+            List<Block.Builder> builders = new ArrayList<>();\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                if (i == bodies.size() - 1) {\n+                    builders.add(b.block());\n+                } else {\n+                    builders.add(i == 0 ? b : b.block());\n+                    builders.add(b.block());\n+                }\n+            }\n+\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body actionBody;\n+                Block.Builder action;\n+                if (i == bodies.size() - 1) {\n+                    actionBody = bodies.get(i);\n+                    action = builders.get(i);\n+                } else {\n+                    Body predBody = bodies.get(i);\n+                    actionBody = bodies.get(i + 1);\n+\n+                    Block.Builder pred = builders.get(i);\n+                    action = builders.get(i + 1);\n+                    Block.Builder next = builders.get(i + 2);\n+\n+                    pred.transformBody(predBody, List.of(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yo) {\n+                            block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                                    action.successor(), next.successor()));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+\n+                action.transformBody(actionBody, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The switch expression operation, that can model Java language switch expressions.\n+     *\/\n+    @OpDeclaration(JavaSwitchExpressionOp.NAME)\n+    public static final class JavaSwitchExpressionOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.switch.expression\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaSwitchExpressionOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchExpressionOp(TypeDesc type, Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, type, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case expression or statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements\/expression body has no parameters and returns the result whose type is the result of\n+            \/\/ the switch expression\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+\n+            \/\/\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * The switch fall-through operation, that can model fall-through to the next statement in the switch block after\n+     * the last statement of the current switch label.\n+     *\/\n+    @OpDeclaration(JavaSwitchFallthroughOp.NAME)\n+    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"java.switch.fallthrough\";\n+\n+        public JavaSwitchFallthroughOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaSwitchFallthroughOp(JavaSwitchFallthroughOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaSwitchFallthroughOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchFallthroughOp(this, cc);\n+        }\n+\n+        JavaSwitchFallthroughOp() {\n+            super(NAME, TypeDesc.VOID, List.of());\n+        }\n+    }\n+\n+    \/**\n+     * The for operation, that can model a Java language for statement.\n+     *\/\n+    @OpDeclaration(JavaForOp.NAME)\n+    public static final class JavaForOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static final class InitBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<TypeDesc> initTypes;\n+\n+            InitBuilder(Body.Builder ancestorBody,\n+                        List<TypeDesc> initTypes) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes.stream().map(CoreOps.Var::type).toList();\n+            }\n+\n+            public JavaForOp.CondBuilder init(Consumer<Block.Builder> c) {\n+                Body.Builder init = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(Tuple.type(initTypes)));\n+                c.accept(init.entryBlock());\n+\n+                return new CondBuilder(ancestorBody, initTypes, init);\n+            }\n+        }\n+\n+        public static final class CondBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<TypeDesc> initTypes;\n+            final Body.Builder init;\n+\n+            public CondBuilder(Body.Builder ancestorBody,\n+                               List<TypeDesc> initTypes,\n+                               Body.Builder init) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+            }\n+\n+            public JavaForOp.UpdateBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder cond = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(BOOLEAN, initTypes));\n+                c.accept(cond.entryBlock());\n+\n+                return new UpdateBuilder(ancestorBody, initTypes, init, cond);\n+            }\n+        }\n+\n+        public static final class UpdateBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<TypeDesc> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+\n+            public UpdateBuilder(Body.Builder ancestorBody,\n+                                 List<TypeDesc> initTypes,\n+                                 Body.Builder init, Body.Builder cond) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+            }\n+\n+            public JavaForOp.BodyBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder update = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(VOID, initTypes));\n+                c.accept(update.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, initTypes, init, cond, update);\n+            }\n+\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<TypeDesc> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+            final Body.Builder update;\n+\n+            public BodyBuilder(Body.Builder ancestorBody,\n+                               List<TypeDesc> initTypes,\n+                               Body.Builder init, Body.Builder cond, Body.Builder update) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+                this.update = update;\n+            }\n+\n+            public JavaForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(VOID, initTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaForOp(init, cond, update, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.for\";\n+\n+        final Body init;\n+        final Body cond;\n+        final Body update;\n+        final Body body;\n+\n+        public static JavaForOp create(OpDefinition def) {\n+            return new JavaForOp(def);\n+        }\n+\n+        public JavaForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.init = def.bodyDefinitions().get(0).build(this);\n+            this.cond = def.bodyDefinitions().get(1).build(this);\n+            this.update = def.bodyDefinitions().get(2).build(this);\n+            this.body = def.bodyDefinitions().get(3).build(this);\n+        }\n+\n+        JavaForOp(JavaForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.cond = that.cond.transform(cc, ot).build(this);\n+            this.update = that.update.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaForOp(this, cc, ot);\n+        }\n+\n+        JavaForOp(Body.Builder initC,\n+                  Body.Builder condC,\n+                  Body.Builder updateC,\n+                  Body.Builder bodyC) {\n+            super(NAME, VOID, List.of());\n+\n+            this.init = initC.build(this);\n+\n+            this.cond = condC.build(this);\n+\n+            this.update = updateC.build(this);\n+            if (!update.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Update should return void: \" + update.descriptor());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(init, cond, update, body);\n+        }\n+\n+        public Body init() {\n+            return init;\n+        }\n+\n+        public Body cond() {\n+            return cond;\n+        }\n+\n+        public Body update() {\n+            return update;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder update = b.block();\n+            Block.Builder exit = b.block();\n+\n+            List<Value> initValues = new ArrayList<>();\n+            \/\/ @@@ Init body has one yield operation yielding\n+            \/\/  void, a single variable, or a tuple of one or more variables\n+            b.transformBody(init, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.TupleOp) {\n+                    \/\/ Drop Tuple if a yielded\n+                    boolean isResult = op.result().uses().size() == 1 &&\n+                            op.result().uses().stream().allMatch(r -> r.op() instanceof YieldOp);\n+                    if (!isResult) {\n+                        block.op(op);\n+                    }\n+                } else if (op instanceof YieldOp yop) {\n+                    if (yop.yieldValue() == null) {\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    } else if (yop.yieldValue() instanceof Result or) {\n+                        if (or.op() instanceof CoreOps.TupleOp top) {\n+                            initValues.addAll(block.context().getValues(top.operands()));\n+                        } else {\n+                            initValues.addAll(block.context().getValues(yop.operands()));\n+                        }\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    }\n+\n+                    throw new IllegalStateException(\"Bad yield operation\");\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(cond, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+            body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            update.transformBody(this.update, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(header.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The enhanced for operation, that can model a Java language enhanced for statement.\n+     *\/\n+    @OpDeclaration(JavaEnhancedForOp.NAME)\n+    public static final class JavaEnhancedForOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static final class ExpressionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeDesc iterableType;\n+            final TypeDesc elementType;\n+\n+            ExpressionBuilder(Body.Builder ancestorBody,\n+                              TypeDesc iterableType, TypeDesc elementType) {\n+                this.ancestorBody = ancestorBody;\n+                this.iterableType = iterableType;\n+                this.elementType = elementType;\n+            }\n+\n+            public DefinitionBuilder expression(Consumer<Block.Builder> c) {\n+                Body.Builder expression = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(iterableType));\n+                c.accept(expression.entryBlock());\n+\n+                return new DefinitionBuilder(ancestorBody, elementType, expression);\n+            }\n+        }\n+\n+        public static final class DefinitionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeDesc elementType;\n+            final Body.Builder expression;\n+\n+            DefinitionBuilder(Body.Builder ancestorBody,\n+                              TypeDesc elementType, Body.Builder expression) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+            }\n+\n+            public BodyBuilder definition(Consumer<Block.Builder> c) {\n+                return definition(elementType, c);\n+            }\n+\n+            public BodyBuilder definition(TypeDesc bodyElementType, Consumer<Block.Builder> c) {\n+                Body.Builder definition = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(bodyElementType, elementType));\n+                c.accept(definition.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, elementType, expression, definition);\n+            }\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeDesc elementType;\n+            final Body.Builder expression;\n+            final Body.Builder definition;\n+\n+            BodyBuilder(Body.Builder ancestorBody,\n+                        TypeDesc elementType, Body.Builder expression, Body.Builder definition) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+                this.definition = definition;\n+            }\n+\n+            public JavaEnhancedForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(VOID, elementType));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaEnhancedForOp(expression, definition, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.enhancedFor\";\n+\n+        final Body expression;\n+        final Body init;\n+        final Body body;\n+\n+        public static JavaEnhancedForOp create(OpDefinition def) {\n+            return new JavaEnhancedForOp(def);\n+        }\n+\n+        public JavaEnhancedForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expression = def.bodyDefinitions().get(0).build(this);\n+            this.init = def.bodyDefinitions().get(1).build(this);\n+            this.body = def.bodyDefinitions().get(2).build(this);\n+        }\n+\n+        JavaEnhancedForOp(JavaEnhancedForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expression = that.expression.transform(cc, ot).build(this);\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaEnhancedForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaEnhancedForOp(this, cc, ot);\n+        }\n+\n+        JavaEnhancedForOp(Body.Builder expressionC, Body.Builder initC, Body.Builder bodyC) {\n+            super(NAME, VOID, List.of());\n+\n+            this.expression = expressionC.build(this);\n+            if (expression.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.descriptor());\n+            }\n+            if (!expression.descriptor().parameters().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.descriptor());\n+            }\n+\n+            this.init = initC.build(this);\n+            if (init.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.descriptor());\n+            }\n+            if (init.descriptor().parameters().size() != 1) {\n+                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.descriptor());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.descriptor());\n+            }\n+            if (body.descriptor().parameters().size() != 1) {\n+                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.descriptor());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(expression, init, body);\n+        }\n+\n+        public Body expression() {\n+            return expression;\n+        }\n+\n+        public Body initialization() {\n+            return init;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        static final MethodDesc ITERABLE_ITERATOR = MethodDesc.method(Iterable.class, \"iterator\", Iterator.class);\n+        static final MethodDesc ITERATOR_HAS_NEXT = MethodDesc.method(Iterator.class, \"hasNext\", boolean.class);\n+        static final MethodDesc ITERATOR_NEXT = MethodDesc.method(Iterator.class, \"next\", Object.class);\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            TypeDesc elementType = init.entryBlock().parameters().get(0).type();\n+            boolean isArray = expression.descriptor().returnType().isArray();\n+\n+            Block.Builder preHeader = b.block(expression.descriptor().returnType());\n+            Block.Builder header = b.block(isArray ? List.of(TypeDesc.INT) : List.of());\n+            Block.Builder init = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yop) {\n+                    Value loopSource = block.context().getValue(yop.yieldValue());\n+                    block.op(branch(preHeader.successor(loopSource)));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            if (isArray) {\n+                Value array = preHeader.parameters().get(0);\n+                Value arrayLength = preHeader.op(arrayLength(array));\n+                Value i = preHeader.op(constant(TypeDesc.INT, 0));\n+                preHeader.op(branch(header.successor(i)));\n+\n+                i = header.parameters().get(0);\n+                Value p = header.op(lt(i, arrayLength));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(arrayLoadOp(array, i));\n+                List<Value> initValues = new ArrayList<>();\n+                \/\/ @@@ Init body has one yield operation yielding a single variable\n+                init.transformBody(this.init, List.of(e), (block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                });\n+\n+                Block.Builder update = b.block();\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                i = update.op(add(i, update.op(constant(TypeDesc.INT, 1))));\n+                update.op(branch(header.successor(i)));\n+            } else {\n+                TypeDesc iterable = TypeDesc.type(TypeDesc.type(Iterator.class), elementType);\n+                Value iterator = preHeader.op(CoreOps.invoke(iterable, ITERABLE_ITERATOR, preHeader.parameters().get(0)));\n+                preHeader.op(branch(header.successor()));\n+\n+                Value p = header.op(CoreOps.invoke(ITERATOR_HAS_NEXT, iterator));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(CoreOps.invoke(elementType, ITERATOR_NEXT, iterator));\n+                List<Value> initValues = new ArrayList<>();\n+                init.transformBody(this.init, List.of(e), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The while operation, that can model a Java language while statement.\n+     *\/\n+    @OpDeclaration(JavaWhileOp.NAME)\n+    public static final class JavaWhileOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            PredicateBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaWhileOp.BodyBuilder predicate(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp.BodyBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder predicate;\n+\n+            BodyBuilder(Body.Builder ancestorBody, Body.Builder predicate) {\n+                this.ancestorBody = ancestorBody;\n+                this.predicate = predicate;\n+            }\n+\n+            public JavaWhileOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp(List.of(predicate, body));\n+            }\n+        }\n+\n+        private static final String NAME = \"java.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaWhileOp(OpDefinition def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, VOID, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(Body.Builder predicate, Body.Builder body) {\n+            super(NAME, VOID, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(predicate, body).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            \/\/ @@@ This will change with pattern bindings\n+            if (!bodies.get(0).descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).descriptor());\n+            }\n+            if (!bodies.get(1).descriptor().equals(MethodTypeDesc.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + MethodTypeDesc.methodType(VOID) +\n+                                \" but is \" + bodies.get(1).descriptor());\n+            }\n+        }\n+\n+        JavaWhileOp(JavaWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(header.successor()));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The do-while operation, that can model a Java language do statement.\n+     *\/\n+    \/\/ @@@ Unify JavaDoWhileOp and JavaWhileOp with common abstract superclass\n+    @OpDeclaration(JavaDoWhileOp.NAME)\n+    public static final class JavaDoWhileOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder body;\n+\n+            PredicateBuilder(Body.Builder ancestorBody, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.body = body;\n+            }\n+\n+            public JavaDoWhileOp predicate(Consumer<Block.Builder> c) {\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                c.accept(predicate.entryBlock());\n+\n+                return new JavaDoWhileOp(List.of(body, predicate));\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            BodyBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaDoWhileOp.PredicateBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaDoWhileOp.PredicateBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        private static final String NAME = \"java.do.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaDoWhileOp(OpDefinition def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, VOID, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(Body.Builder body, Body.Builder predicate) {\n+            super(NAME, VOID, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(body, predicate).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            if (!bodies.get(0).descriptor().equals(MethodTypeDesc.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + MethodTypeDesc.methodType(VOID) +\n+                                \" but is \" + bodies.get(1).descriptor());\n+            }\n+            if (!bodies.get(1).descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + MethodTypeDesc.methodType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).descriptor());\n+            }\n+        }\n+\n+        JavaDoWhileOp(JavaDoWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaDoWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaDoWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder body = b.block();\n+            Block.Builder header = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(body.successor()));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and-or operation, that can model Java language condition-or or conditional-and expressions.\n+     *\/\n+    public static sealed abstract class JavaConditionalOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        final List<Body> bodies;\n+\n+        public JavaConditionalOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(JavaConditionalOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(String name, List<Body.Builder> bodyCs) {\n+            super(name, BOOLEAN, List.of());\n+\n+            if (bodyCs.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            for (Body b : bodies) {\n+                if (!b.descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.descriptor());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        static Block.Builder lower(Block.Builder startBlock, OpTransformer opT, JavaConditionalOp cop) {\n+            List<Body> bodies = cop.bodies();\n+\n+            Block.Builder exit = startBlock.block();\n+            TypeDesc oprType = cop.result().type();\n+            Block.Parameter arg = exit.parameter(oprType);\n+            startBlock.context().mapValue(cop.result(), arg);\n+\n+            \/\/ Transform bodies in reverse order\n+            \/\/ This makes available the blocks to be referenced as successors in prior blocks\n+\n+            Block.Builder pred = null;\n+            for (int i = bodies.size() - 1; i >= 0; i--) {\n+                OpTransformer opt;\n+                if (i == bodies.size() - 1) {\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOps.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            block.op(branch(exit.successor(p)));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                } else {\n+                    Block.Builder nextPred = pred;\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOps.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            if (cop instanceof JavaConditionalAndOp) {\n+                                block.op(conditionalBranch(p, nextPred.successor(), exit.successor(p)));\n+                            } else {\n+                                block.op(conditionalBranch(p, exit.successor(p), nextPred.successor()));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                }\n+\n+                Body fromPred = bodies.get(i);\n+                if (i == 0) {\n+                    startBlock.transformBody(fromPred, List.of(), opt);\n+                } else {\n+                    pred = startBlock.block(fromPred.descriptor().parameters());\n+                    pred.transformBody(fromPred, pred.parameters(), opT.andThen(opt));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and operation, that can model Java language conditional-and expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalAndOp.NAME)\n+    public static final class JavaConditionalAndOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                and(lhs);\n+                and(rhs);\n+            }\n+\n+            public Builder and(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalAndOp build() {\n+                return new JavaConditionalAndOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cand\";\n+\n+        public JavaConditionalAndOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalAndOp(JavaConditionalAndOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalAndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalAndOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalAndOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-or operation, that can model Java language conditional-or expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalOrOp.NAME)\n+    public static final class JavaConditionalOrOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                or(lhs);\n+                or(rhs);\n+            }\n+\n+            public Builder or(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalOrOp build() {\n+                return new JavaConditionalOrOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cor\";\n+\n+        public JavaConditionalOrOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalOrOp(JavaConditionalOrOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalOrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalOrOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalOrOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional operation, that can model Java language conditional operator {@code ?} expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalExpressionOp.NAME)\n+    public static final class JavaConditionalExpressionOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        public static final String NAME = \"java.cexpression\";\n+\n+        \/\/ {cond, truepart, falsepart}\n+        final List<Body> bodies;\n+\n+        public JavaConditionalExpressionOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaConditionalExpressionOp(JavaConditionalExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaConditionalExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalExpressionOp(TypeDesc expressionType, List<Body.Builder> bodyCs) {\n+            super(NAME, expressionType, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+\n+            if (bodies.size() < 3) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+\n+            Body cond = bodies.get(0);\n+            if (!cond.descriptor().equals(MethodTypeDesc.methodType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.descriptor());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block(resultType());\n+            exit.context().mapValue(result(), exit.parameters().get(0));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            List<Block.Builder> builders = List.of(b.block(), b.block());\n+            b.transformBody(bodies.get(0), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            builders.get(0).successor(), builders.get(1).successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            for (int i = 0; i < 2; i++) {\n+                builders.get(i).transformBody(bodies.get(i + 1), List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+    }\n+\n+    \/**\n+     * The try operation, that can model Java language try statements.\n+     *\/\n+    @OpDeclaration(JavaTryOp.NAME)\n+    public static final class JavaTryOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<TypeDesc> resourceTypes;\n+            final Body.Builder resources;\n+\n+            BodyBuilder(Body.Builder ancestorBody, List<TypeDesc> resourceTypes, Body.Builder resources) {\n+                this.ancestorBody = ancestorBody;\n+                this.resourceTypes = resourceTypes;\n+                this.resources = resources;\n+            }\n+\n+            public CatchBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, MethodTypeDesc.methodType(VOID, resourceTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new CatchBuilder(ancestorBody, resources, body);\n+            }\n+        }\n+\n+        public static final class CatchBuilder {\n+            final Body.Builder ancestorBody;\n+            final Body.Builder resources;\n+            final Body.Builder body;\n+            final List<Body.Builder> catchers;\n+\n+            CatchBuilder(Body.Builder ancestorBody, Body.Builder resources, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.resources = resources;\n+                this.body = body;\n+                this.catchers = new ArrayList<>();\n+            }\n+\n+            \/\/ @@@ multi-catch\n+            public CatchBuilder _catch(TypeDesc exceptionType, Consumer<Block.Builder> c) {\n+                Body.Builder _catch = Body.Builder.of(ancestorBody,\n+                        MethodTypeDesc.methodType(TypeDesc.VOID, exceptionType));\n+                c.accept(_catch.entryBlock());\n+                catchers.add(_catch);\n+\n+                return this;\n+            }\n+\n+            public JavaTryOp _finally(Consumer<Block.Builder> c) {\n+                Body.Builder _finally = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+                c.accept(_finally.entryBlock());\n+\n+                return new JavaTryOp(resources, body, catchers, _finally);\n+            }\n+\n+            public JavaTryOp noFinalizer() {\n+                return new JavaTryOp(resources, body, catchers, null);\n+            }\n+        }\n+\n+        static final String NAME = \"java.try\";\n+\n+        final Body resources;\n+        final Body body;\n+        final List<Body> catchers;\n+        final Body finalizer;\n+\n+        public static JavaTryOp create(OpDefinition def) {\n+            return new JavaTryOp(def);\n+        }\n+\n+        public JavaTryOp(OpDefinition def) {\n+            super(def);\n+\n+            List<Body> bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n+            Body first = bodies.get(0);\n+            if (first.descriptor().returnType().equals(VOID)) {\n+                this.resources = null;\n+                this.body = first;\n+            } else {\n+                this.resources = first;\n+                this.body = bodies.get(1);\n+            }\n+\n+            Body last = bodies.get(bodies.size() - 1);\n+            if (last.descriptor().parameters().isEmpty()) {\n+                this.finalizer = last;\n+            } else {\n+                this.finalizer = null;\n+            }\n+            this.catchers = bodies.subList(\n+                    resources == null ? 1 : 2,\n+                    bodies.size() - (finalizer == null ? 0 : 1));\n+        }\n+\n+        JavaTryOp(JavaTryOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            if (that.resources != null) {\n+                this.resources = that.resources.transform(cc, ot).build(this);\n+            } else {\n+                this.resources = null;\n+            }\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.catchers = that.catchers.stream()\n+                    .map(b -> b.transform(cc, ot).build(this))\n+                    .toList();\n+            if (that.finalizer != null) {\n+                this.finalizer = that.finalizer.transform(cc, ot).build(this);\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public JavaTryOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaTryOp(this, cc, ot);\n+        }\n+\n+        JavaTryOp(Body.Builder resourcesC,\n+                  Body.Builder bodyC,\n+                  List<Body.Builder> catchersC,\n+                  Body.Builder finalizerC) {\n+            super(NAME, VOID, List.of());\n+\n+            if (resourcesC != null) {\n+                this.resources = resourcesC.build(this);\n+                if (resources.descriptor().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.descriptor());\n+                }\n+                if (!resources.descriptor().parameters().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.descriptor());\n+                }\n+            } else {\n+                this.resources = null;\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.descriptor().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Try should return void: \" + body.descriptor());\n+            }\n+\n+            this.catchers = catchersC.stream().map(c -> c.build(this)).toList();\n+            for (Body _catch : catchers) {\n+                if (!_catch.descriptor().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.descriptor());\n+                }\n+                if (_catch.descriptor().parameters().size() != 1) {\n+                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.descriptor());\n+                }\n+            }\n+\n+            if (finalizerC != null) {\n+                this.finalizer = finalizerC.build(this);\n+                if (!finalizer.descriptor().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.descriptor());\n+                }\n+                if (!finalizer.descriptor().parameters().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.descriptor());\n+                }\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            ArrayList<Body> bodies = new ArrayList<>();\n+            if (resources != null) {\n+                bodies.add(resources);\n+            }\n+            bodies.add(body);\n+            bodies.addAll(catchers);\n+            if (finalizer != null) {\n+                bodies.add(finalizer);\n+            }\n+            return bodies;\n+        }\n+\n+        public Body resources() {\n+            return resources;\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public List<Body> catchers() {\n+            return catchers;\n+        }\n+\n+        public Body finalizer() {\n+            return finalizer;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            if (resources != null) {\n+                throw new UnsupportedOperationException(\"Lowering of try-with-resources is unsupported\");\n+            }\n+\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Simple case with no catch and finally bodies\n+            if (catchers.isEmpty() && finalizer == null) {\n+                b.transformBody(body, List.of(), (block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                });\n+                return exit;\n+            }\n+\n+            Block.Builder tryRegionEnter = b.block();\n+            Block.Builder tryRegionExit = b.block();\n+\n+            \/\/ Construct the catcher block builders\n+            List<Block.Builder> catchers = catchers().stream()\n+                    .map(catcher -> b.block())\n+                    .toList();\n+            Block.Builder catcherFinally = null;\n+            if (finalizer != null) {\n+                catcherFinally = b.block();\n+                catchers = new ArrayList<>(catchers);\n+                catchers.add(catcherFinally);\n+            }\n+\n+            \/\/ Enter the try exception region\n+            Result tryExceptionRegion = b.op(exceptionRegionEnter(tryRegionEnter.successor(), catchers.stream()\n+                    .map(Block.Builder::successor)\n+                    .toList()));\n+\n+            OpTransformer tryExitTransformer;\n+            if (finalizer != null) {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    if (op instanceof CoreOps.ReturnOp) {\n+                        return inlineFinalizer(block, tryExceptionRegion, opT);\n+                    } else if (op instanceof ExtendedOps.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                        return inlineFinalizer(block, tryExceptionRegion, opT);\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            } else {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    \/\/ @@@ break and continue\n+                    \/\/ when target break\/continue is enclosing the try\n+                    if (op instanceof CoreOps.ReturnOp) {\n+                        Block.Builder tryRegionReturnExit = block.block();\n+                        block.op(exceptionRegionExit(tryExceptionRegion, tryRegionReturnExit.successor()));\n+                        return tryRegionReturnExit;\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            }\n+            \/\/ Inline the try body\n+            AtomicBoolean hasTryRegionExit = new AtomicBoolean();\n+            tryRegionEnter.transformBody(body, List.of(), tryExitTransformer.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    hasTryRegionExit.set(true);\n+                    block.op(branch(tryRegionExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, tryExitTransformer);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            Block.Builder finallyEnter = null;\n+            if (finalizer != null) {\n+                finallyEnter = b.block();\n+                if (hasTryRegionExit.get()) {\n+                    \/\/ Exit the try exception region\n+                    tryRegionExit.op(exceptionRegionExit(tryExceptionRegion, finallyEnter.successor()));\n+                }\n+            } else if (hasTryRegionExit.get()) {\n+                \/\/ Exit the try exception region\n+                tryRegionExit.op(exceptionRegionExit(tryExceptionRegion, exit.successor()));\n+            }\n+\n+            \/\/ Inline the catch bodies\n+            for (int i = 0; i < this.catchers.size(); i++) {\n+                Block.Builder catcher = catchers.get(i);\n+                Body catcherBody = this.catchers.get(i);\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcher.parameter(catcherBody.descriptor().parameters().get(0));\n+\n+                if (finalizer != null) {\n+                    Block.Builder catchRegionEnter = b.block();\n+                    Block.Builder catchRegionExit = b.block();\n+\n+                    \/\/ Enter the catch exception region\n+                    Result catchExceptionRegion = catcher.op(\n+                            exceptionRegionEnter(catchRegionEnter.successor(), catcherFinally.successor()));\n+\n+                    OpTransformer catchExitTransformer = opT.compose((block, op) -> {\n+                        if (op instanceof CoreOps.ReturnOp) {\n+                            return inlineFinalizer(block, catchExceptionRegion, opT);\n+                        } else if (op instanceof ExtendedOps.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                            return inlineFinalizer(block, catchExceptionRegion, opT);\n+                        } else {\n+                            return block;\n+                        }\n+                    });\n+                    \/\/ Inline the catch body\n+                    AtomicBoolean hasCatchRegionExit = new AtomicBoolean();\n+                    catchRegionEnter.transformBody(catcherBody, List.of(t), catchExitTransformer.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            hasCatchRegionExit.set(true);\n+                            block.op(branch(catchRegionExit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, catchExitTransformer);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+\n+                    \/\/ Exit the catch exception region\n+                    if (hasCatchRegionExit.get()) {\n+                        hasTryRegionExit.set(true);\n+                        catchRegionExit.op(exceptionRegionExit(catchExceptionRegion, finallyEnter.successor()));\n+                    }\n+                } else {\n+                    \/\/ Inline the catch body\n+                    catcher.transformBody(catcherBody, List.of(t), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            block.op(branch(exit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, opT);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            if (finalizer != null && hasTryRegionExit.get()) {\n+                \/\/ Inline the finally body\n+                finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            \/\/ Inline the finally body as a catcher of Throwable and adjusting to throw\n+            if (finalizer != null) {\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcherFinally.parameter(TypeDesc.type(Throwable.class));\n+\n+                catcherFinally.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(_throw(t));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+            return exit;\n+        }\n+\n+        boolean ifExitFromTry(JavaLabelOp lop) {\n+            Op target = lop.target();\n+            return ifAncestorOp(target, this);\n+        }\n+\n+        static boolean ifAncestorOp(Op ancestor, Op op) {\n+            while (op.ancestorBody() != null) {\n+                op = op.ancestorBody().parentOp();\n+                if (op == ancestor) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        Block.Builder inlineFinalizer(Block.Builder block1, Value exceptionRegion, OpTransformer opT) {\n+            Block.Builder finallyEnter = block1.block();\n+            Block.Builder finallyExit = block1.block();\n+\n+            block1.op(exceptionRegionExit(exceptionRegion, finallyEnter.successor()));\n+\n+            \/\/ Inline the finally body\n+            finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block2, op2) -> {\n+                if (op2 instanceof YieldOp) {\n+                    block2.op(branch(finallyExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op2 instanceof Lowerable lop2) {\n+                        block2 = lop2.lower(block2, opT);\n+                    } else {\n+                        block2.op(op2);\n+                    }\n+                }\n+                return block2;\n+            }));\n+\n+            return finallyExit;\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    static final String Pattern_CLASS_NAME = ExtendedOps_CLASS_NAME + \"$\" + Pattern.class.getSimpleName();\n+\n+    \/\/ Reified pattern nodes\n+\n+    \/**\n+     * Synthetic pattern types\n+     *\/\n+    public sealed interface Pattern {\n+\n+        \/**\n+         * Synthetic binding pattern type.\n+         *\n+         * @param <T> the type of values that are bound\n+         *\/\n+        final class Binding<T> implements Pattern {\n+            Binding() {\n+            }\n+        }\n+\n+        \/**\n+         * Synthetic record pattern type.\n+         *\n+         * @param <T> the type of records that are bound\n+         *\/\n+        final class Record<T> implements Pattern {\n+            Record() {\n+            }\n+        }\n+\n+        TypeDesc PATTERN_BINDING_TYPE = new TypeDescImpl(Pattern_CLASS_NAME +\n+                \"$\" + Binding.class.getSimpleName());\n+        TypeDesc PATTERN_RECORD_TYPE = new TypeDescImpl(Pattern_CLASS_NAME +\n+                \"$\" + Pattern.Record.class.getSimpleName());\n+\n+        static TypeDesc bindingType(TypeDesc t) {\n+            return TypeDesc.type(PATTERN_BINDING_TYPE, t);\n+        }\n+\n+        static TypeDesc recordType(TypeDesc t) {\n+            return TypeDesc.type(PATTERN_RECORD_TYPE, t);\n+        }\n+\n+        static TypeDesc targetType(TypeDesc t) {\n+            return t.typeArguments().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * Pattern operations.\n+     *\/\n+    public static final class PatternOps {\n+        PatternOps() {\n+        }\n+\n+        \/**\n+         * The pattern operation.\n+         *\/\n+        public static sealed abstract class PatternOp extends OpWithDefinition implements Op.Pure {\n+            PatternOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            PatternOp(PatternOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            PatternOp(String name, TypeDesc returnType, List<Value> operands) {\n+                super(name, returnType, operands);\n+            }\n+        }\n+\n+        \/**\n+         * The binding pattern operation, that can model Java language type patterns.\n+         *\/\n+        @OpDeclaration(BindingPatternOp.NAME)\n+        public static final class BindingPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.binding\";\n+\n+            public static final String ATTRIBUTE_BINDING_NAME = NAME + \".binding.name\";\n+\n+            final String bindingName;\n+\n+            public static BindingPatternOp create(OpDefinition def) {\n+                String name = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n+                        v -> switch (v) {\n+                            case String s -> s;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported pattern binding name value:\" + v);\n+                        });\n+                return new BindingPatternOp(def, name);\n+            }\n+\n+            BindingPatternOp(OpDefinition def, String bindingName) {\n+                super(def);\n+\n+                this.bindingName = bindingName;\n+            }\n+\n+            BindingPatternOp(BindingPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.bindingName = that.bindingName;\n+            }\n+\n+            @Override\n+            public BindingPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new BindingPatternOp(this, cc);\n+            }\n+\n+            BindingPatternOp(TypeDesc targetType, String bindingName) {\n+                super(NAME, Pattern.bindingType(targetType), List.of());\n+\n+                this.bindingName = bindingName;\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+                attrs.put(\"\", bindingName);\n+                return attrs;\n+            }\n+\n+            public String bindingName() {\n+                return bindingName;\n+            }\n+\n+            public TypeDesc targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+        }\n+\n+        \/**\n+         * The record pattern operation, that can model Java language record patterns.\n+         *\/\n+        @OpDeclaration(RecordPatternOp.NAME)\n+        public static final class RecordPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.record\";\n+\n+            public static final String ATTRIBUTE_RECORD_DESCRIPTOR = NAME + \".descriptor\";\n+\n+            final RecordTypeDesc recordDescriptor;\n+\n+            public static RecordPatternOp create(OpDefinition def) {\n+                RecordTypeDesc recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR,true,\n+                        v -> switch (v) {\n+                            case String s -> RecordTypeDesc.ofString(s);\n+                            case RecordTypeDesc rtd -> rtd;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported record type descriptor value:\" + v);\n+                        });\n+\n+                return new RecordPatternOp(def, recordDescriptor);\n+            }\n+\n+            RecordPatternOp(OpDefinition def, RecordTypeDesc recordDescriptor) {\n+                super(def);\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            RecordPatternOp(RecordPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.recordDescriptor = that.recordDescriptor;\n+            }\n+\n+            @Override\n+            public RecordPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new RecordPatternOp(this, cc);\n+            }\n+\n+            RecordPatternOp(RecordTypeDesc recordDescriptor, List<Value> nestedPatterns) {\n+                \/\/ The type of each value is a subtype of Pattern\n+                \/\/ The number of values corresponds to the number of components of the record\n+                super(NAME, Pattern.recordType(recordDescriptor.recordType()), List.copyOf(nestedPatterns));\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> m = new HashMap<>(super.attributes());\n+                m.put(\"\", recordDescriptor);\n+                return Collections.unmodifiableMap(m);\n+            }\n+\n+            public RecordTypeDesc recordDescriptor() {\n+                return recordDescriptor;\n+            }\n+\n+            public TypeDesc targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+        }\n+\n+        \/**\n+         * The match operation, that can model Java language pattern matching.\n+         *\/\n+        @OpDeclaration(MatchOp.NAME)\n+        public static final class MatchOp extends OpWithDefinition implements Op.Isolated, Op.Lowerable {\n+            public static final String NAME = \"pattern.match\";\n+\n+            final Body pattern;\n+            final Body match;\n+\n+            public MatchOp(OpDefinition def) {\n+                super(def);\n+\n+                this.pattern = def.bodyDefinitions().get(0).build(this);\n+                this.match = def.bodyDefinitions().get(1).build(this);\n+            }\n+\n+            MatchOp(MatchOp that, CopyContext cc, OpTransformer ot) {\n+                super(that, cc);\n+\n+                this.pattern = that.pattern.transform(cc, ot).build(this);\n+                this.match = that.match.transform(cc, ot).build(this);\n+            }\n+\n+            @Override\n+            public MatchOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MatchOp(this, cc, ot);\n+            }\n+\n+            MatchOp(Value target, Body.Builder patternC, Body.Builder matchC) {\n+                super(NAME, BOOLEAN,\n+                        List.of(target));\n+\n+                this.pattern = patternC.build(this);\n+                this.match = matchC.build(this);\n+            }\n+\n+            @Override\n+            public List<Body> bodies() {\n+                return List.of(pattern, match);\n+            }\n+\n+            public Body pattern() {\n+                return pattern;\n+            }\n+\n+            public Body match() {\n+                return match;\n+            }\n+\n+            public Value target() {\n+                return operands().get(0);\n+            }\n+\n+            @Override\n+            public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+                \/\/ No match block\n+                Block.Builder endNoMatchBlock = b.block();\n+                \/\/ Match block\n+                Block.Builder endMatchBlock = b.block();\n+                \/\/ End block\n+                Block.Builder endBlock = b.block();\n+                Block.Parameter matchResult = endBlock.parameter(resultType());\n+                \/\/ Map match operation result\n+                b.context().mapValue(result(), matchResult);\n+\n+                List<Value> patternValues = new ArrayList<>();\n+                Op patternYieldOp = pattern.entryBlock().terminatingOp();\n+                Op.Result rootPatternValue = (Op.Result) patternYieldOp.operands().get(0);\n+                Block.Builder currentBlock = lower(endNoMatchBlock, b,\n+                        patternValues,\n+                        rootPatternValue.op(),\n+                        b.context().getValue(target()));\n+                currentBlock.op(branch(endMatchBlock.successor()));\n+\n+                \/\/ No match block\n+                \/\/ Pass false\n+                endNoMatchBlock.op(branch(endBlock.successor(\n+                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n+\n+                \/\/ Match block\n+                \/\/ Lower match body and pass true\n+                endMatchBlock.transformBody(match, patternValues, opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(endBlock.successor(\n+                                block.op(constant(BOOLEAN, true)))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                return endBlock;\n+            }\n+\n+            static Block.Builder lower(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       Op pattern, Value target) {\n+                if (pattern instanceof ExtendedOps.PatternOps.RecordPatternOp rp) {\n+                    return lowerRecordPattern(endNoMatchBlock, currentBlock, bindings, rp, target);\n+                } else if (pattern instanceof ExtendedOps.PatternOps.BindingPatternOp bp) {\n+                    return lowerBindingPattern(endNoMatchBlock, currentBlock, bindings, bp, target);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unknown pattern op: \" + pattern);\n+                }\n+            }\n+\n+            static Block.Builder lowerRecordPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       ExtendedOps.PatternOps.RecordPatternOp rpOp, Value target) {\n+                TypeDesc targetType = rpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                Op.Result isInstance = currentBlock.op(CoreOps.instanceOf(targetType, target));\n+                currentBlock.op(conditionalBranch(isInstance, nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(CoreOps.cast(targetType, target));\n+\n+                \/\/ Access component values of record and match on each as nested target\n+                List<Value> dArgs = rpOp.operands();\n+                for (int i = 0; i < dArgs.size(); i++) {\n+                    Op.Result nestedPattern = (Op.Result) dArgs.get(i);\n+                    \/\/ @@@ Handle exceptions?\n+                    Value nestedTarget = currentBlock.op(CoreOps.invoke(rpOp.recordDescriptor().methodForComponent(i), target));\n+\n+                    currentBlock = lower(endNoMatchBlock, currentBlock, bindings, nestedPattern.op(), nestedTarget);\n+                }\n+\n+                return currentBlock;\n+            }\n+\n+            static Block.Builder lowerBindingPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       ExtendedOps.PatternOps.BindingPatternOp bpOp, Value target) {\n+                TypeDesc targetType = bpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                currentBlock.op(conditionalBranch(currentBlock.op(CoreOps.instanceOf(targetType, target)),\n+                        nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(CoreOps.cast(targetType, target));\n+                bindings.add(target);\n+\n+                return currentBlock;\n+            }\n+        }\n+    }\n+\n+\n+    \/**\n+     * A factory for extended and core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = CoreOps.FACTORY.andThen(OpFactory.OP_FACTORY.get(ExtendedOps.class));\n+\n+\n+    \/**\n+     * Creates a continue operation.\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue() {\n+        return _continue(null);\n+    }\n+\n+    \/**\n+     * Creates a continue operation.\n+     * @param label the value associated with where to continue from\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue(Value label) {\n+        return new JavaContinueOp(label);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break() {\n+        return _break(null);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     * @param label the value associated with where to continue from\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break(Value label) {\n+        return new JavaBreakOp(label);\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield() {\n+        return new JavaYieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @param operand the value to yield\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield(Value operand) {\n+        return new JavaYieldOp(operand);\n+    }\n+\n+    \/**\n+     * Creates a block operation.\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaBlockOp block(Body.Builder body) {\n+        return new JavaBlockOp(body);\n+    }\n+\n+    \/**\n+     * Creates a labeled operation.\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaLabeledOp labeled(Body.Builder body) {\n+        return new JavaLabeledOp(body);\n+    }\n+\n+    \/**\n+     * Creates an if operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the if operation builder\n+     *\/\n+    public static JavaIfOp.IfBuilder _if(Body.Builder ancestorBody) {\n+        return new JavaIfOp.IfBuilder(ancestorBody);\n+    }\n+\n+    \/\/ Pairs of\n+    \/\/   predicate ()boolean, body ()void\n+    \/\/ And one optional body ()void at the end\n+\n+    \/**\n+     * Creates an if operation.\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the if operation\n+     *\/\n+    public static JavaIfOp _if(List<Body.Builder> bodies) {\n+        return new JavaIfOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     * @param type the result type of the expression\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(TypeDesc type, Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchExpressionOp(type, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch fallthrough operation.\n+     * @return the switch fallthrough operation\n+     *\/\n+    public static JavaSwitchFallthroughOp switchFallthroughOp() {\n+        return new JavaSwitchFallthroughOp();\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param initTypes the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeDesc... initTypes) {\n+        return _for(ancestorBody, List.of(initTypes));\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param initTypes the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<TypeDesc> initTypes) {\n+        return new JavaForOp.InitBuilder(ancestorBody, initTypes);\n+    }\n+\n+\n+    \/**\n+     * Creates a for operation.\n+     * @param init the init body builder of the operation to be built and become its child\n+     * @param cond the cond body builder of the operation to be built and become its child\n+     * @param update the update body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the for operation\n+     *\/\n+    \/\/ init ()Tuple<Var<T1>, Var<T2>, ..., Var<TN>>, or init ()void\n+    \/\/ cond (Var<T1>, Var<T2>, ..., Var<TN>)boolean\n+    \/\/ update (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    \/\/ body (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    public static JavaForOp _for(Body.Builder init,\n+                                 Body.Builder cond,\n+                                 Body.Builder update,\n+                                 Body.Builder body) {\n+        return new JavaForOp(init, cond, update, body);\n+    }\n+\n+    \/**\n+     * Creates an enhanced for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param iterableType the iterable type\n+     * @param elementType the element type\n+     * @return the enhanced for operation builder\n+     *\/\n+    public static JavaEnhancedForOp.ExpressionBuilder enhancedFor(Body.Builder ancestorBody,\n+                                                                  TypeDesc iterableType, TypeDesc elementType) {\n+        return new JavaEnhancedForOp.ExpressionBuilder(ancestorBody, iterableType, elementType);\n+    }\n+\n+    \/\/ expression ()I<E>\n+    \/\/ init (E )Var<T>\n+    \/\/ body (Var<T> )void\n+\n+    \/**\n+     * Creates an enhanced for operation.\n+     * @param expression the expression body builder of the operation to be built and become its child\n+     * @param init the init body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the enhanced for operation\n+     *\/\n+    public static JavaEnhancedForOp enhancedFor(Body.Builder expression,\n+                                                Body.Builder init,\n+                                                Body.Builder body) {\n+        return new JavaEnhancedForOp(expression, init, body);\n+    }\n+\n+    \/**\n+     * Creates a while operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the while operation builder\n+     *\/\n+    public static JavaWhileOp.PredicateBuilder _while(Body.Builder ancestorBody) {\n+        return new JavaWhileOp.PredicateBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a while operation.\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the while operation\n+     *\/\n+    \/\/ predicate, ()boolean, may be null for predicate returning true\n+    \/\/ body, ()void\n+    public static JavaWhileOp _while(Body.Builder predicate, Body.Builder body) {\n+        return new JavaWhileOp(predicate, body);\n+    }\n+\n+    \/**\n+     * Creates a do operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the do operation builder\n+     *\/\n+    public static JavaDoWhileOp.BodyBuilder doWhile(Body.Builder ancestorBody) {\n+        return new JavaDoWhileOp.BodyBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a do operation.\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the do operation\n+     *\/\n+    public static JavaDoWhileOp doWhile(Body.Builder body, Body.Builder predicate) {\n+        return new JavaDoWhileOp(body, predicate);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param lhs a consumer that builds the left-hand side body\n+     * @param rhs a consumer that builds the right-hand side body\n+     * @return the conditional-and operation builder\n+     *\/\n+    public static JavaConditionalAndOp.Builder conditionalAnd(Body.Builder ancestorBody,\n+                                                              Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalAndOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param lhs a consumer that builds the left-hand side body\n+     * @param rhs a consumer that builds the right-hand side body\n+     * @return the conditional-or operation builder\n+     *\/\n+    public static JavaConditionalOrOp.Builder conditionalOr(Body.Builder ancestorBody,\n+                                                            Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalOrOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-and operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalAndOp conditionalAnd(List<Body.Builder> bodies) {\n+        return new JavaConditionalAndOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-or operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalOrOp conditionalOr(List<Body.Builder> bodies) {\n+        return new JavaConditionalOrOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(TypeDesc expressionType, List<Body.Builder> bodies) {\n+        return new JavaConditionalExpressionOp(expressionType, bodies);\n+    }\n+\n+    \/**\n+     * Creates try operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param c a consumer that builds the try body\n+     * @return the try operation builder\n+     *\/\n+    public static JavaTryOp.CatchBuilder _try(Body.Builder ancestorBody, Consumer<Block.Builder> c) {\n+        Body.Builder _try = Body.Builder.of(ancestorBody, MethodTypeDesc.VOID);\n+        c.accept(_try.entryBlock());\n+        return new JavaTryOp.CatchBuilder(ancestorBody, null, _try);\n+    }\n+\n+    \/**\n+     * Creates try-with-resources operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param c a consumer that builds the resources body\n+     * @return the try-with-resources operation builder\n+     *\/\n+    public static JavaTryOp.BodyBuilder tryWithResources(Body.Builder ancestorBody,\n+                                                         List<TypeDesc> resourceTypes, Consumer<Block.Builder> c) {\n+        resourceTypes = resourceTypes.stream().map(CoreOps.Var::type).toList();\n+        Body.Builder resources = Body.Builder.of(ancestorBody,\n+                MethodTypeDesc.methodType(Tuple.type(resourceTypes)));\n+        c.accept(resources.entryBlock());\n+        return new JavaTryOp.BodyBuilder(ancestorBody, resourceTypes, resources);\n+    }\n+\n+    \/\/ resources ()Tuple<Var<R1>, Var<R2>, ..., Var<RN>>, or null\n+    \/\/ try (Var<R1>, Var<R2>, ..., Var<RN>)void, or try ()void\n+    \/\/ catch (E )void, where E <: Throwable\n+    \/\/ finally ()void, or null\n+\n+    \/**\n+     * Creates a try or try-with-resources operation.\n+     * @param resources the try body builder of the operation to be built and become its child,\n+     *                  may be null\n+     * @param body the try body builder of the operation to be built and become its child\n+     * @param catchers the catch body builders of the operation to be built and become its children\n+     * @param finalizer the finalizer body builder of the operation to be built and become its child\n+     * @return the try or try-with-resources operation\n+     *\/\n+    public static JavaTryOp _try(Body.Builder resources,\n+                                 Body.Builder body,\n+                                 List<Body.Builder> catchers,\n+                                 Body.Builder finalizer) {\n+        return new JavaTryOp(resources, body, catchers, finalizer);\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    \/**\n+     * Creates a pattern match operation.\n+     * @param target the target value\n+     * @param pattern the pattern body builder of the operation to be built and become its child\n+     * @param match the match body builder of the operation to be built and become its child\n+     * @return the pattern match operation\n+     *\/\n+    public static PatternOps.MatchOp match(Value target,\n+                                           Body.Builder pattern, Body.Builder match) {\n+        return new PatternOps.MatchOp(target, pattern, match);\n+    }\n+\n+    \/**\n+     * Creates a pattern binding operation.\n+     * @param type the type of value to be bound\n+     * @param bindingName the binding name\n+     * @return the pattern binding operation\n+     *\/\n+    public static PatternOps.BindingPatternOp bindingPattern(TypeDesc type, String bindingName) {\n+        return new PatternOps.BindingPatternOp(type, bindingName);\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeDesc recordDescriptor, Value... nestedPatterns) {\n+        return recordPattern(recordDescriptor, List.of(nestedPatterns));\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeDesc recordDescriptor, List<Value> nestedPatterns) {\n+        return new PatternOps.RecordPatternOp(recordDescriptor, nestedPatterns);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":3026,"deletions":0,"binary":false,"changes":3026,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.code.Op;\n+\n+\/**\n+ * An operation declaration annotation.\n+ * <p>\n+ * This annotation may be declared on a concrete class implementing an {@link Op operation} whose name is a constant\n+ * that can be declared as this attribute's value.\n+ * <p>\n+ * Tooling can process declarations of this annotation to build a factory for constructing operations from their name.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface OpDeclaration {\n+    \/**\n+     * {@return the operation name}\n+     *\/\n+    String value();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpDeclaration.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * An operation in generic form that is utilized to construct a concrete subclass of {@code Op},\n+ * such as a subclass of {@link OpWithDefinition}, associated with the operation name.\n+ *\n+ * @param name            the operation name\n+ * @param operands        the list of operands\n+ * @param successors      the list of successors\n+ * @param resultType      the operation result type\n+ * @param attributes      the attribute map, modifiable\n+ * @param bodyDefinitions the list of body builders for building the bodies\n+ * @apiNote Deserializers of operations may utilize this record to construct operations,\n+ * thereby separating the specifics of deserializing from construction.\n+ *\/\n+public record OpDefinition(String name,\n+                           List<Value> operands,\n+                           List<Block.Reference> successors,\n+                           TypeDesc resultType,\n+                           Map<String, Object> attributes,\n+                           List<Body.Builder> bodyDefinitions) {\n+\n+    \/**\n+     * Removes an attribute value from the attributes map, converts the value by applying it\n+     * to mapping function, and returns the result.\n+     *\n+     * <p>If the attribute is a default attribute then this method first attempts to\n+     * remove the attribute whose name is the empty string, otherwise if there is no such\n+     * attribute present or the attribute is not a default attribute then this method\n+     * attempts to remove the attribute with the given name.\n+     *\n+     * <p>On successful removal of the attribute its value is converted by applying the value\n+     * to the mapping function.\n+     *\n+     * @param name the attribute name.\n+     * @param isDefault true if the attribute is a default attribute\n+     * @return the converted attribute value\n+     * @param <T> the converted attribute value type\n+     * @throws IllegalArgumentException if there is no attribute present\n+     *\/\n+    public <T> T extractAttributeValue(String name, boolean isDefault, Function<Object, T> mapper) {\n+        Object value = attributes.remove(isDefault ? \"\" : name);\n+        if (value == null) {\n+            if (!isDefault) {\n+                throw new IllegalArgumentException(\"Required attribute not present: \"\n+                        + name);\n+            }\n+\n+            value = attributes.remove(name);\n+        }\n+\n+        return mapper.apply(value);\n+    }\n+\n+    \/**\n+     * Copies an operation to its operation definition.\n+     *\n+     * @param cc the copy context\n+     * @param op the operation\n+     * @return the copied operation definition.\n+     *\/\n+    public static OpDefinition fromOp(CopyContext cc, Op op) {\n+        return new OpDefinition(\n+                op.opName(),\n+                cc.getValues(op.operands()),\n+                op.successors().stream().map(cc::getSuccessorOrCreate).toList(),\n+                op.resultType(),\n+                new HashMap<>(op.attributes()),\n+                op.bodies().stream().map(b -> b.copy(cc)).toList()\n+        );\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpDefinition.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Op;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * An operation factory for constructing an {@link Op operation} from its {@link OpDefinition operation definition}.\n+ *\/\n+@FunctionalInterface\n+public interface OpFactory {\n+    \/**\n+     * A class value for lazily computing an operation factory for {@link Op operation} classes\n+     * annotated with {@link OpDeclaration} and enclosed within a given class to compute over.\n+     * <p>\n+     * Each enclosed class annotated with {@code OpDeclaration} must declare a public static method named {@code create}\n+     * with one parameter type of {@link OpDefinition} and return type that is the concrete class type.\n+     * Alternatively, the concrete class must declare public constructor with one parameter type of\n+     * {@link OpDefinition}.\n+     *\/\n+    ClassValue<OpFactory> OP_FACTORY = new ClassValue<>() {\n+        @Override\n+        protected OpFactory computeValue(Class<?> c) {\n+            \/\/ @@@ See https:\/\/bugs.openjdk.org\/browse\/JDK-8321207\n+            final Map<String, Class<? extends Op>> opMapping = createOpMapping(c);\n+\n+            return def -> {\n+                var opClass = opMapping.get(def.name());\n+                if (opClass == null) {\n+                    return null;\n+                }\n+\n+                return constructOp(opClass, def);\n+            };\n+        }\n+    };\n+\n+    \/**\n+     * Constructs an {@link Op operation} from its operation definition.\n+     * <p>\n+     * If there is no mapping from the operation definition's name to a concrete\n+     * class of an {@code Op} then this method returns null.\n+     *\n+     * @param def the operation definition\n+     * @return the operation, otherwise null\n+     *\/\n+    Op constructOp(OpDefinition def);\n+\n+    \/**\n+     * Constructs an {@link Op operation} from its operation definition.\n+     * <p>\n+     * If there is no mapping from the operation definition's name to a concrete\n+     * class of an {@code Op} then this method throws UnsupportedOperationException.\n+     *\n+     * @param def the operation definition\n+     * @return the operation, otherwise null\n+     * @throws UnsupportedOperationException if there is no mapping from the operation definition's\n+     *                                       name to a concrete class of an {@code Op}\n+     *\/\n+    default Op constructOpOrFail(OpDefinition def) {\n+        Op op = constructOp(def);\n+        if (op == null) {\n+            throw new UnsupportedOperationException(\"Unsupported operation: \" + def.name());\n+        }\n+\n+        return op;\n+    }\n+\n+    \/**\n+     * Compose this operation factory with another operation factory.\n+     * <p>\n+     * If there is no mapping in this operation factory then the result\n+     * of the other operation factory is returned.\n+     *\n+     * @param after the other operation factory.\n+     * @return the composed operation factory.\n+     *\/\n+    default OpFactory andThen(OpFactory after) {\n+        return def -> {\n+            Op op = constructOp(def);\n+            return op != null ? op : after.constructOp(def);\n+        };\n+    }\n+\n+    private static Map<String, Class<? extends Op>> createOpMapping(Class<?> opClasses) {\n+        Map<String, Class<? extends Op>> mapping = new HashMap<>();\n+        for (Class<?> opClass : opClasses.getNestMembers()) {\n+            if (opClass.isAnnotationPresent(OpDeclaration.class)) {\n+                if (!Modifier.isPublic(opClass.getModifiers())) {\n+                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(opClass)) {\n+                    throw new InternalError(\"Operation class is not assignable to Op: \" + opClass);\n+                }\n+\n+                MethodHandle handle = getOpConstructorMethodHandle(opClass);\n+                if (handle == null) {\n+                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(handle.type().returnType())) {\n+                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n+                }\n+\n+                String opName = opClass.getAnnotation(OpDeclaration.class).value();\n+                @SuppressWarnings(\"unchecked\")\n+                var opClassCast = (Class<Op>) opClass;\n+                mapping.put(opName, opClassCast);\n+            }\n+        }\n+        return mapping;\n+    }\n+\n+    private static MethodHandle getOpConstructorMethodHandle(Class<?> opClass) {\n+        Method method = null;\n+        try {\n+            method = opClass.getMethod(\"create\", OpDefinition.class);\n+        } catch (NoSuchMethodException e) {\n+        }\n+\n+        if (method != null) {\n+            if (!Modifier.isStatic(method.getModifiers())) {\n+                throw new InternalError(\"Operation constructor is not a static method: \" + method);\n+            }\n+\n+            try {\n+\/*__return MethodHandles.lookup().unreflect(method);__*\/                return MethodHandles.publicLookup().unreflect(method);\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                        method);\n+            }\n+        }\n+\n+        Constructor<?> constructor;\n+        try {\n+            constructor = opClass.getConstructor(OpDefinition.class);\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+\n+        try {\n+\/*__return MethodHandles.lookup().unreflectConstructor(constructor);__*\/            return MethodHandles.publicLookup().unreflectConstructor(constructor);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                    constructor);\n+        }\n+    }\n+\n+    private static Op constructOp(Class<? extends Op> opClass, OpDefinition opDef) {\n+        class Enclosed {\n+            private static final ClassValue<Function<OpDefinition, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n+                @Override\n+                protected Function<OpDefinition, Op> computeValue(Class<?> opClass) {\n+                    final MethodHandle opConstructorMH = getOpConstructorMethodHandle(opClass);\n+                    assert opConstructorMH != null;\n+\n+                    return operationDefinition -> {\n+                        try {\n+                            return (Op) opConstructorMH.invoke(operationDefinition);\n+                        } catch (RuntimeException | Error e) {\n+                            throw e;\n+                        } catch (Throwable t) {\n+                            throw new RuntimeException(t);\n+                        }\n+                    };\n+                }\n+            };\n+        }\n+        return Enclosed.OP_CONSTRUCTOR.get(opClass).apply(opDef);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpFactory.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * An operation that may be constructed with an operation {@link OpDefinition definition}.\n+ *\/\n+public abstract class OpWithDefinition extends Op {\n+    final Map<String, Object> attributes;\n+\n+    \/**\n+     * Constructs an operation by copying given operation.\n+     *\n+     * @param that the operation to copy.\n+     * @param cc   the copy context.\n+     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n+     * values computed, in order, by mapping the operation's operands using the copy context.\n+     *\/\n+    protected OpWithDefinition(Op that, CopyContext cc) {\n+        super(that, cc);\n+\n+        this.attributes = Map.of();\n+    }\n+\n+    \/**\n+     * Constructs an operation with a name, operation result type, and list of operands.\n+     *\n+     * @param name       the operation name.\n+     * @param resultType the operation result type.\n+     * @param operands   the list of operands, a copy of the list is performed if required.\n+     *\/\n+    protected OpWithDefinition(String name, TypeDesc resultType, List<? extends Value> operands) {\n+        super(name, resultType, operands);\n+\n+        this.attributes = Map.of();\n+    }\n+\n+    \/**\n+     * Constructs an operation from its operation definition.\n+     *\n+     * @param def the operation definition.\n+     * @implSpec This implementation invokes the {@link Op#Op(String, TypeDesc, List) constructor}\n+     * accepting the non-optional components of the operation definition, {@code name}, {@code resultType},\n+     * and {@code operands}:\n+     * <pre> {@code\n+     *  this(def.name(), def.resultType(), def.operands());\n+     * }<\/pre>\n+     * If the attributes component of the operation definition is copied as if by {@code Map.copyOf}.\n+     *\/\n+    protected OpWithDefinition(OpDefinition def) {\n+        super(def.name(), def.resultType(), def.operands());\n+\n+        this.attributes = Map.copyOf(def.attributes());\n+    }\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        return attributes;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpWithDefinition.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for operations declared in code models that can represent Java programs.\n+ *\/\n+package java.lang.reflect.code.op;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for a code metamodel that is used to quote Java code as code models, build code models, and transform code models.\n+ *\/\n+package java.lang.reflect.code;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,599 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.OpDefinition;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.parser.impl.DescParser;\n+import java.lang.reflect.code.parser.impl.Lexer;\n+import java.lang.reflect.code.parser.impl.Scanner;\n+import java.lang.reflect.code.parser.impl.Tokens;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * A parser of serialized code models and descriptors from their textual form.\n+ * <p>\n+ * The syntactic grammar of a code mode is specified in the grammar notation, and is a subset of the grammar,\n+ * specified by the JLS, see section 2.4. (Except that we cannot express non-terminal symbols in italic type.)\n+ * <p>\n+ * {@snippet lang=text :\n+ * Operation:\n+ *   [Value =] Name {Operands} {Successors} {Attributes} {Bodies} ;\n+ *\n+ * Operands:\n+ *   ValueIdentifier {ValueIdentifier}\n+ *\n+ * Successors:\n+ *   Successor {Successor}\n+ *\n+ * Successor:\n+ *   BlockIdentifier\n+ *   BlockIdentifier ()\n+ *   BlockIdentifier ( ValueIdentifier {, ValueIdentifier} )\n+ *\n+ * Attributes:\n+ *   Attribute {Attribute}\n+ *\n+ * Attribute:\n+ *   @ AttributeValue\n+ *   @ Name = AttributeValue\n+ *\n+ * AttributeValue:\n+ *   Name\n+ *   StringLiteral\n+ *   NullLiteral\n+ *\n+ * Bodies:\n+ *   Body {Body}\n+ *\n+ * Body:\n+ *   BlockIdentifier ( ) Type -> { Operations {Block} }\n+ *   BlockIdentifier ( Value {, Value} ) Type -> { Operations {Block} }\n+ *\n+ * Operations:\n+ *   Operation {Operation}\n+ *\n+ * Block:\n+ *   BlockIdentifier : Operations\n+ *   BlockIdentifier ( ) : Operations\n+ *   BlockIdentifier ( Value {, Value} ) : Operations\n+ *\n+ * BlockIdentifier:\n+ *   ^ Identifier\n+ *\n+ * Value:\n+ *   ValueIdentifier : Type\n+ *\n+ * ValueIdentifier:\n+ *   % JavaLetterOrDigit {JavaLetterOrDigit}\n+ *\n+ * Name:\n+ *   Identifier\n+ *   Name . Identifier\n+ *\n+ * Type:\n+ *   same as in section 4.1 of JLS but without any annotations\n+ *\n+ * Identifier:\n+ *   same as in section 3 of JLS\n+ *\n+ * JavaLetterOrDigit:\n+ *   same as in section 3 of JLS\n+ *\n+ * StringLiteral:\n+ *   same as in section 3 of JLS\n+ *\n+ * NullLiteral:\n+ *   same as in section 3 of JLS\n+ * }\n+ *\/\n+public final class OpParser {\n+\n+    \/**\n+     * Parse a code model from its serialized textual form obtained from an input stream.\n+     *\n+     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param in the input stream\n+     * @return the list of operations\n+     * @throws IOException if parsing fails\n+     *\/\n+    public static List<Op> fromStream(OpFactory opFactory, InputStream in) throws IOException {\n+        String s = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        return fromString(opFactory, s);\n+    }\n+\n+    \/**\n+     * Parse a code model from its serialized textual form obtained from an input string.\n+     *\n+     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param in the input string\n+     * @return the list of operations\n+     *\/\n+    public static List<Op> fromString(OpFactory opFactory, String in) {\n+        return parse(opFactory, in);\n+    }\n+\n+    \/**\n+     * Parse a code model, modeling a method, from its serialized textual form obtained from an input string.\n+     *\n+     * @param in the input string\n+     * @return the func operation\n+     *\/\n+    public static Op fromStringOfFuncOp(String in) {\n+        Op op = fromString(ExtendedOps.FACTORY, in).get(0);\n+        if (!(op instanceof CoreOps.FuncOp)) {\n+            throw new IllegalArgumentException(\"Op is not a FuncOp: \" + op);\n+        }\n+        return op;\n+    }\n+\n+    static List<Op> parse(OpFactory opFactory, String in) {\n+        Lexer lexer = Scanner.factory().newScanner(in);\n+        lexer.nextToken();\n+\n+        List<OpNode> opNodes = new OpParser(opFactory, lexer).parseNodes();\n+\n+        Context c = new Context(opFactory);\n+        return opNodes.stream().map(n -> nodeToOp(n, TypeDesc.VOID, c, null)).toList();\n+    }\n+\n+\n+    static final class Context {\n+        final Context parent;\n+        final OpFactory opFactory;\n+        final Map<String, Value> valueMap;\n+        final Map<String, Block.Builder> blockMap;\n+\n+        Context(Context that, boolean isolated) {\n+            this.parent = that;\n+            this.opFactory = that.opFactory;\n+            this.valueMap = isolated ? new HashMap<>() : new HashMap<>(that.valueMap);\n+            this.blockMap = new HashMap<>();\n+        }\n+\n+        Context(OpFactory opFactory) {\n+            this.parent = null;\n+            this.opFactory = opFactory;\n+            this.valueMap = new HashMap<>();\n+            this.blockMap = new HashMap<>();\n+        }\n+\n+        Context fork(boolean isolated) {\n+            return new Context(this, isolated);\n+        }\n+\n+        void putValue(String name, Value opr) {\n+            valueMap.put(name, opr);\n+        }\n+\n+        Value getValue(String name) {\n+            Value value = valueMap.get(name);\n+            if (value == null) {\n+                \/\/ @@@ location\n+                throw new IllegalArgumentException(\"Undeclared value referenced: \" + name);\n+            }\n+\n+            return value;\n+        }\n+\n+        void putBlock(String name, Block.Builder bm) {\n+            blockMap.put(name, bm);\n+        }\n+\n+        Block.Builder getBlock(String name) {\n+            Block.Builder block = blockMap.get(name);\n+            if (block == null) {\n+                \/\/ @@@ location\n+                throw new IllegalArgumentException(\"Undeclared block referenced: \" + name);\n+            }\n+\n+            return block;\n+        }\n+    }\n+\n+    static Op nodeToOp(OpNode opNode, TypeDesc rtype, Context c, Body.Builder ancestorBody) {\n+        OpDefinition opdef = nodeToOpDef(opNode, rtype, c, ancestorBody);\n+        return c.opFactory.constructOpOrFail(opdef);\n+    }\n+\n+    static OpDefinition nodeToOpDef(OpNode opNode, TypeDesc rtype, Context c, Body.Builder ancestorBody) {\n+        String operationName = opNode.name;\n+        List<Value> operands = opNode.operands.stream().map(c::getValue).toList();\n+        List<Block.Reference> successors = opNode.successors.stream()\n+                .map(n -> nodeToSuccessor(n, c)).toList();\n+        List<Body.Builder> bodies = opNode.bodies.stream()\n+                .map(n -> nodeToBody(n, c.fork(false), ancestorBody)).toList();\n+        return new OpDefinition(operationName,\n+                operands,\n+                successors,\n+                rtype,\n+                opNode.attributes,\n+                bodies);\n+    }\n+\n+    static Body.Builder nodeToBody(BodyNode n, Context c, Body.Builder ancestorBody) {\n+        Body.Builder body = Body.Builder.of(ancestorBody,\n+                \/\/ Create descriptor with just the return type and add parameters afterward\n+                MethodTypeDesc.methodType(n.rtype));\n+        Block.Builder eb = body.entryBlock();\n+\n+        \/\/ Create blocks upfront for forward referencing successors\n+        for (int i = 0; i < n.blocks.size(); i++) {\n+            BlockNode bn = n.blocks.get(i);\n+            Block.Builder b;\n+            if (i == 0) {\n+                b = body.entryBlock();\n+            } else {\n+                b = eb.block();\n+                c.putBlock(bn.name, b);\n+            }\n+\n+            for (ValueNode a : bn.parameters) {\n+                Block.Parameter v = b.parameter(a.type);\n+                c.putValue(a.name, v);\n+            }\n+        }\n+\n+        \/\/ Create operations\n+        for (int i = 0; i < n.blocks.size(); i++) {\n+            BlockNode bn = n.blocks.get(i);\n+            Block.Builder b;\n+            if (i == 0) {\n+                b = body.entryBlock();\n+            } else {\n+                b = c.getBlock(n.blocks.get(i).name);\n+            }\n+\n+            for (OpNode on : bn.ops) {\n+                ValueNode r = on.result;\n+                if (r != null) {\n+                    Op.Result v = b.op(nodeToOp(on, r.type, c, body));\n+                    c.putValue(r.name, v);\n+                } else {\n+                    b.op(nodeToOp(on, TypeDesc.VOID, c, body));\n+                }\n+            }\n+        }\n+\n+        return body;\n+    }\n+\n+    static Block.Reference nodeToSuccessor(SuccessorNode n, Context c) {\n+        return c.getBlock(n.blockName).successor(n.arguments().stream().map(c::getValue).toList());\n+    }\n+\n+    \/\/ @@@ Add tokens to access position of nodes on error\n+\n+    record OpNode(ValueNode result,\n+                  String name,\n+                  List<String> operands,\n+                  List<SuccessorNode> successors,\n+                  Map<String, Object> attributes,\n+                  List<BodyNode> bodies) {\n+    }\n+\n+    record SuccessorNode(String blockName,\n+                         List<String> arguments) {\n+    }\n+\n+    record BodyNode(TypeDesc rtype,\n+                    List<BlockNode> blocks) {\n+    }\n+\n+    record BlockNode(String name,\n+                     List<ValueNode> parameters,\n+                     List<OpNode> ops) {\n+    }\n+\n+    record ValueNode(String name,\n+                     TypeDesc type) {\n+    }\n+\n+    final OpFactory opFactory;\n+    final Lexer lexer;\n+\n+    OpParser(OpFactory opFactory, Lexer lexer) {\n+        this.opFactory = opFactory;\n+        this.lexer = lexer;\n+    }\n+\n+    List<OpNode> parseNodes() {\n+        List<OpNode> ops = new ArrayList<>();\n+        while (lexer.token().kind != Tokens.TokenKind.EOF) {\n+            ops.add(parseOperation());\n+        }\n+        return ops;\n+    }\n+\n+    OpNode parseOperation() {\n+        ValueNode operationResult;\n+        if (lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER)) {\n+            operationResult = parseValueNode();\n+            lexer.accept(Tokens.TokenKind.EQ);\n+        } else {\n+            operationResult = null;\n+        }\n+\n+        String operationName = parseName();\n+\n+        \/\/ Operands\n+        final List<String> operands;\n+        if (lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER)) {\n+            operands = parseOperands();\n+        } else {\n+            operands = List.of();\n+        }\n+\n+        \/\/ Successors\n+        \/\/ ^name(%x, %d)\n+        final List<SuccessorNode> successors;\n+        if (lexer.is(Tokens.TokenKind.CARET)) {\n+            successors = parseSuccessors();\n+        } else {\n+            successors = List.of();\n+        }\n+\n+        \/\/ Attributes\n+        final Map<String, Object> attributes;\n+        if (lexer.is(Tokens.TokenKind.MONKEYS_AT)) {\n+            attributes = parseAttributes();\n+        } else {\n+            attributes = Map.of();\n+        }\n+\n+        \/\/ Bodies\n+        List<BodyNode> bodies;\n+        if (lexer.is(Tokens.TokenKind.CARET) || lexer.is(Tokens.TokenKind.LPAREN)) {\n+            bodies = parseBodies();\n+        } else {\n+            bodies = List.of();\n+        }\n+\n+        lexer.accept(Tokens.TokenKind.SEMI);\n+\n+        return new OpNode(operationResult, operationName, operands, successors, attributes, bodies);\n+    }\n+\n+    Map<String, Object> parseAttributes() {\n+        Map<String, Object> attributes = new HashMap<>();\n+        while (lexer.acceptIf(Tokens.TokenKind.MONKEYS_AT)) {\n+            String attributeName;\n+            if (lexer.is(Tokens.TokenKind.IDENTIFIER)) {\n+                attributeName = parseName();\n+                lexer.accept(Tokens.TokenKind.EQ);\n+            } else {\n+                attributeName = \"\";\n+            }\n+            Object attributeValue = parseAttributeValue();\n+            attributes.put(attributeName, attributeValue);\n+        }\n+        return attributes;\n+    }\n+\n+    Object parseAttributeValue() {\n+        if (lexer.is(Tokens.TokenKind.IDENTIFIER)) {\n+            return parseName();\n+        }\n+\n+        Object value = parseLiteral(lexer.token());\n+        lexer.nextToken();\n+\n+        return value;\n+    }\n+\n+    Object parseLiteral(Tokens.Token t) {\n+        return switch (t.kind) {\n+            case STRINGLITERAL -> t.stringVal();\n+            case NULL -> Op.NULL_ATTRIBUTE_VALUE;\n+            default -> throw lexer.unexpected();\n+        };\n+    }\n+\n+    List<String> parseOperands() {\n+        List<String> operands = new ArrayList<>();\n+        while (lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER)) {\n+            operands.add(lexer.token().name().substring(1));\n+            lexer.nextToken();\n+        }\n+        return operands;\n+    }\n+\n+    List<SuccessorNode> parseSuccessors() {\n+        List<SuccessorNode> successors = new ArrayList<>();\n+\n+        while (lexer.is(Tokens.TokenKind.CARET) && !isBody()) {\n+            lexer.nextToken();\n+            successors.add(parseSuccessor());\n+        }\n+\n+        return successors;\n+    }\n+\n+    \/\/ Lookahead from \"^\" to determine if Body\n+    boolean isBody() {\n+        assert lexer.is(Tokens.TokenKind.CARET);\n+\n+        int pos = 1;\n+        lexer.token(pos++);\n+        assert lexer.token(1).kind == Tokens.TokenKind.IDENTIFIER;\n+\n+        if (lexer.token(pos++).kind != Tokens.TokenKind.LPAREN) {\n+            return false;\n+        }\n+\n+        Tokens.Token t;\n+        while ((t = lexer.token(pos++)).kind != Tokens.TokenKind.RPAREN) {\n+            if (t.kind == Tokens.TokenKind.EOF) {\n+                return false;\n+            } else if (t.kind == Tokens.TokenKind.COLON) {\n+                \/\/ Encountered Value\n+                return true;\n+            }\n+        }\n+\n+        \/\/ Encountered return type\n+        return lexer.token(pos++).kind == Tokens.TokenKind.IDENTIFIER;\n+    }\n+\n+    SuccessorNode parseSuccessor() {\n+        String blockName = lexer.accept(Tokens.TokenKind.IDENTIFIER).name();\n+\n+        List<String> arguments = new ArrayList<>();\n+        if (lexer.acceptIf(Tokens.TokenKind.LPAREN) && !lexer.acceptIf(Tokens.TokenKind.RPAREN)) {\n+            do {\n+                arguments.add(lexer.accept(Tokens.TokenKind.VALUE_IDENTIFIER).name().substring(1));\n+            } while (lexer.acceptIf(Tokens.TokenKind.COMMA));\n+            lexer.accept(Tokens.TokenKind.RPAREN);\n+        }\n+\n+        return new SuccessorNode(blockName, arguments);\n+    }\n+\n+    List<BodyNode> parseBodies() {\n+        List<BodyNode> bodies = new ArrayList<>();\n+        while (lexer.is(Tokens.TokenKind.CARET) || lexer.is(Tokens.TokenKind.LPAREN)) {\n+            BodyNode body = parseBody();\n+            bodies.add(body);\n+        }\n+        return bodies;\n+    }\n+\n+    BodyNode parseBody() {\n+        \/\/ Body name\n+        final String bodyName;\n+        if (lexer.acceptIf(Tokens.TokenKind.CARET)) {\n+            bodyName = lexer.accept(Tokens.TokenKind.IDENTIFIER).name();\n+        } else {\n+            bodyName = null;\n+        }\n+\n+        \/\/ Entry block header\n+        List<ValueNode> arguments = parseBlockHeaderArguments(true);\n+        \/\/ Body return type\n+        TypeDesc rtype = parseTypeDesc();\n+\n+        lexer.accept(Tokens.TokenKind.ARROW);\n+        lexer.accept(Tokens.TokenKind.LBRACE);\n+\n+        List<BlockNode> blocks = parseBlocks(bodyName, arguments);\n+\n+        lexer.accept(Tokens.TokenKind.RBRACE);\n+\n+        return new BodyNode(rtype, blocks);\n+    }\n+\n+    List<ValueNode> parseBlockHeaderArguments(boolean isEntryBlock) {\n+        boolean parseArguments;\n+        if (isEntryBlock) {\n+            lexer.accept(Tokens.TokenKind.LPAREN);\n+            parseArguments = true;\n+        } else {\n+            parseArguments = lexer.acceptIf(Tokens.TokenKind.LPAREN);\n+        }\n+        if (!parseArguments || lexer.acceptIf(Tokens.TokenKind.RPAREN)) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<ValueNode> arguments = new ArrayList<>();\n+        do {\n+            arguments.add(parseValueNode());\n+        } while (lexer.acceptIf(Tokens.TokenKind.COMMA));\n+        lexer.accept(Tokens.TokenKind.RPAREN);\n+\n+        return arguments;\n+    }\n+\n+    ValueNode parseValueNode() {\n+        String valueName = lexer.accept(Tokens.TokenKind.VALUE_IDENTIFIER).name().substring(1);\n+\n+        lexer.accept(Tokens.TokenKind.COLON);\n+\n+        TypeDesc type = parseTypeDesc();\n+\n+        return new ValueNode(valueName, type);\n+    }\n+\n+    List<BlockNode> parseBlocks(String entryBlockName, List<ValueNode> entryBlockArguments) {\n+        List<BlockNode> blocks = new ArrayList<>();\n+\n+        \/\/ Entry block ops\n+        BlockNode entryBlock = new BlockNode(entryBlockName, entryBlockArguments, parseOperations());\n+        blocks.add(entryBlock);\n+\n+        \/\/ Subsequent blocks\n+        while (lexer.acceptIf(Tokens.TokenKind.CARET)) {\n+            String blockName = lexer.accept(Tokens.TokenKind.IDENTIFIER).name();\n+            List<ValueNode> blockArguments = parseBlockHeaderArguments(false);\n+\n+            lexer.accept(Tokens.TokenKind.COLON);\n+\n+            BlockNode block = new BlockNode(blockName, blockArguments, parseOperations());\n+            blocks.add(block);\n+        }\n+\n+        return blocks;\n+    }\n+\n+    List<OpNode> parseOperations() {\n+        List<OpNode> ops = new ArrayList<>();\n+        while (lexer.is(Tokens.TokenKind.MONKEYS_AT) || lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER) || lexer.is(Tokens.TokenKind.IDENTIFIER)) {\n+            OpNode op = parseOperation();\n+            ops.add(op);\n+        }\n+        return ops;\n+    }\n+\n+    String parseName() {\n+        Tokens.Token t = lexer.accept(Tokens.TokenKind.IDENTIFIER);\n+        StringBuilder name = new StringBuilder();\n+        name.append(t.name());\n+        while (lexer.acceptIf(Tokens.TokenKind.DOT)) {\n+            name.append(Tokens.TokenKind.DOT.name);\n+            t = lexer.accept(Tokens.TokenKind.IDENTIFIER);\n+            name.append(t.name());\n+        }\n+        return name.toString();\n+    }\n+\n+    TypeDesc parseTypeDesc() {\n+        return DescParser.parseTypeDesc(lexer);\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":599,"deletions":0,"binary":false,"changes":599,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.descriptor.*;\n+import java.lang.reflect.code.descriptor.impl.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public final class DescParser {\n+    private DescParser() {}\n+\n+    \/**\n+     * Parse a type descriptor from its serialized textual form.\n+     * @param desc the serialized type descriptor\n+     * @return the type descriptor\n+     *\/\n+    public static TypeDesc parseTypeDesc(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseTypeDesc(s);\n+    }\n+\n+    \/**\n+     * Parse a method type descriptor from its serialized textual form.\n+     * @param desc the serialized method type descriptor\n+     * @return the method type descriptor\n+     *\/\n+    public static MethodTypeDesc parseMethodTypeDesc(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseMethodTypeDesc(s);\n+    }\n+\n+    \/**\n+     * Parse a method descriptor from its serialized textual form.\n+     *\n+     * @param desc the serialized method descriptor\n+     * @return the method descriptor\n+     *\/\n+    public static MethodDesc parseMethodDesc(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseMethodDesc(s);\n+    }\n+\n+    \/**\n+     * Parse a field descriptor from its serialized textual form.\n+     *\n+     * @param desc the serialized field descriptor\n+     * @return the field descriptor\n+     *\/\n+    public static FieldDesc parseFieldDesc(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseFieldDesc(s);\n+    }\n+\n+    \/**\n+     * Parse a record type descriptor from its serialized textual form.\n+     *\n+     * @param desc the serialized record type descriptor\n+     * @return the record type descriptor\n+     *\/\n+    public static RecordTypeDesc parseRecordTypeDesc(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseRecordTypeDesc(s);\n+    }\n+\n+    public static TypeDesc parseTypeDesc(Lexer l) {\n+        \/\/ Type\n+        \/\/ @@@ Extract string directly from start position of first identifier\n+        \/\/     and end position of last identifier.\n+        Tokens.Token t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+        StringBuilder type = new StringBuilder();\n+        type.append(t.name());\n+        while (l.acceptIf(Tokens.TokenKind.DOT)) {\n+            type.append(Tokens.TokenKind.DOT.name);\n+            t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+            type.append(t.name());\n+        }\n+\n+        \/\/ Type parameters\n+        List<TypeDesc> ptypes;\n+        if (l.token().kind == Tokens.TokenKind.LT) {\n+            ptypes = new ArrayList<>();\n+            do {\n+                l.nextToken();\n+                TypeDesc pt = parseTypeDesc(l);\n+                ptypes.add(pt);\n+            } while (l.token().kind == Tokens.TokenKind.COMMA);\n+            l.accept(Tokens.TokenKind.GT);\n+        } else {\n+            ptypes = List.of();\n+        }\n+\n+        \/\/ @@@ Enclosed\/inner classes, separated by $ which may also be parameterized\n+\n+        \/\/ Array\n+        int dims = 0;\n+        while (l.acceptIf(Tokens.TokenKind.LBRACKET)) {\n+            l.accept(Tokens.TokenKind.RBRACKET);\n+            dims++;\n+        }\n+\n+        return new TypeDescImpl(type.toString(), dims, ptypes);\n+    }\n+\n+    static MethodTypeDesc parseMethodTypeDesc(Lexer l) {\n+        List<TypeDesc> ptypes = new ArrayList<>();\n+        l.accept(Tokens.TokenKind.LPAREN);\n+        if (l.token().kind != Tokens.TokenKind.RPAREN) {\n+            ptypes.add(parseTypeDesc(l));\n+            while (l.acceptIf(Tokens.TokenKind.COMMA)) {\n+                ptypes.add(parseTypeDesc(l));\n+            }\n+        }\n+        l.accept(Tokens.TokenKind.RPAREN);\n+        TypeDesc rtype = parseTypeDesc(l);\n+        return new MethodTypeDescImpl(rtype, ptypes);\n+    }\n+\n+    static MethodDescImpl parseMethodDesc(Lexer l) {\n+        TypeDesc refType = parseTypeDesc(l);\n+\n+        l.accept(Tokens.TokenKind.COLCOL);\n+\n+        String methodName;\n+        if (l.acceptIf(Tokens.TokenKind.LT)) {\n+            \/\/ Special name such as \"<new>\"\n+            Tokens.Token t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+            l.accept(Tokens.TokenKind.GT);\n+            methodName = \"<\" + t.name() + \">\";\n+        } else {\n+            methodName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n+        }\n+\n+        MethodTypeDesc mtype = parseMethodTypeDesc(l);\n+\n+        return new MethodDescImpl(refType, methodName, mtype);\n+    }\n+\n+    static FieldDescImpl parseFieldDesc(Lexer l) {\n+        TypeDesc refType = parseTypeDesc(l);\n+\n+        l.accept(Tokens.TokenKind.COLCOL);\n+\n+        String fieldName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n+\n+        MethodTypeDesc mtype = parseMethodTypeDesc(l);\n+        if (mtype.parameters().size() != 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new FieldDescImpl(refType, fieldName, mtype.returnType());\n+    }\n+\n+    static RecordTypeDesc parseRecordTypeDesc(Lexer l) {\n+        List<RecordTypeDesc.ComponentDesc> components = new ArrayList<>();\n+        l.accept(Tokens.TokenKind.LPAREN);\n+        if (l.token().kind != Tokens.TokenKind.RPAREN) {\n+            do {\n+                TypeDesc componentType = parseTypeDesc(l);\n+                String componentName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n+\n+                components.add(new RecordTypeDesc.ComponentDesc(componentType, componentName));\n+            } while(l.acceptIf(Tokens.TokenKind.COMMA));\n+        }\n+        l.accept(Tokens.TokenKind.RPAREN);\n+        TypeDesc recordType = parseTypeDesc(l);\n+        return new RecordTypeDescImpl(recordType, components);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+final class Errors {\n+\n+    private Errors() {\n+    }\n+\n+    static final class Error {\n+        String s;\n+\n+        Error(String s) {\n+            this.s = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return s;\n+        }\n+    }\n+\n+    static final Error IllegalUnicodeEsc = new Error(\"illegal unicode escape\");\n+    static final Error IllegalNonasciiDigit = new Error(\"illegal non-ASCII digit\");\n+    static final Error IllegalEscChar = new Error(\"illegal escape character\");\n+    static final Error IllegalUnderscore = new Error(\"illegal underscore\");\n+    static final Error IllegalLineEndInCharLit = new Error(\"illegal line end in character literal\");\n+    static final Error IllegalDot = new Error(\"illegal '.'\");\n+    static final Error MalformedFpLit = new Error(\"malformed floating-point literal\");\n+    static final Error InvalidHexNumber = new Error(\"hexadecimal numbers must contain at least one hexadecimal digit\");\n+    static final Error InvalidBinaryNumber = new Error(\"binary numbers must contain at least one binary digit\");\n+    static final Error EmptyCharLit = new Error(\"empty character literal\");\n+    static final Error UnclosedStrLit = new Error(\"unclosed string literal\");\n+    static final Error UnclosedComment = new Error(\"unclosed comment\");\n+    static final Error UnclosedCharLit = new Error(\"unclosed character literal\");\n+\n+    static Error IllegalChar(String c) {\n+        return new Error(\"unmappable character for encoding \" + c);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Errors.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,1124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode\n+ * escape sequences into a token sequence.\n+ *\/\n+final class JavaBasedTokenizer extends UnicodeReader {\n+    \/**\n+     * If true then prints token information after each nextToken().\n+     *\/\n+    private static final boolean scannerDebug = false;\n+\n+    \/**\n+     * Sentinel for non-value.\n+     *\/\n+    private static final int NOT_FOUND = -1;\n+\n+    \/**\n+     * The log to be used for error reporting. Copied from scanner factory.\n+     *\/\n+    private final Log log;\n+\n+    \/**\n+     * The token factory. Copied from scanner factory.\n+     *\/\n+    private final Tokens tokens;\n+\n+    \/**\n+     * The token kind, set by nextToken().\n+     *\/\n+    Tokens.TokenKind tk;\n+\n+    \/**\n+     * The token's radix, set by nextToken().\n+     *\/\n+    int radix;\n+\n+    \/**\n+     * The token's name, set by nextToken().\n+     *\/\n+    String name;\n+\n+    \/**\n+     * The position where a lexical error occurred;\n+     *\/\n+    int errPos = Position.NOPOS;\n+\n+    \/**\n+     * true if contains escape sequences, set by nextToken().\n+     *\/\n+    boolean hasEscapeSequences;\n+\n+    \/**\n+     * Buffer for building literals, used by nextToken().\n+     *\/\n+    StringBuilder sb;\n+\n+    \/**\n+     * Construct a Java token scanner from the input character array.\n+     *\n+     * @param fac    the factory which created this Scanner\n+     * @param array  the input character array.\n+     * @param length The length of the meaningful content in the array.\n+     *\/\n+    JavaBasedTokenizer(Scanner.Factory fac, char[] array, int length) {\n+        super(fac, array, length);\n+        this.log = fac.log;\n+        this.tokens = fac.tokens;\n+        this.sb = new StringBuilder(256);\n+    }\n+\n+    \/**\n+     * Report an error at the given position using the provided arguments.\n+     *\n+     * @param pos position in input buffer.\n+     * @param key error key to report.\n+     *\/\n+    void lexError(int pos, Errors.Error key) {\n+        tk = Tokens.TokenKind.ERROR;\n+        errPos = pos;\n+        log.error(pos, key);\n+    }\n+\n+    \/**\n+     * Add a character to the literal buffer.\n+     *\n+     * @param ch character to add.\n+     *\/\n+    void put(char ch) {\n+        sb.append(ch);\n+    }\n+\n+    \/**\n+     * Add a codepoint to the literal buffer.\n+     *\n+     * @param codePoint codepoint to add.\n+     *\/\n+    void putCodePoint(int codePoint) {\n+        sb.appendCodePoint(codePoint);\n+    }\n+\n+    \/**\n+     * Add current character or codepoint to the literal buffer.\n+     *\/\n+    void put() {\n+        if (isSurrogate()) {\n+            putCodePoint(getCodepoint());\n+        } else {\n+            put(get());\n+        }\n+    }\n+\n+    \/**\n+     * Add a string to the literal buffer.\n+     *\/\n+    void put(String string) {\n+        sb.append(string);\n+    }\n+\n+    \/**\n+     * Add current character or codepoint to the literal buffer then return next character.\n+     *\/\n+    char putThenNext() {\n+        put();\n+\n+        return next();\n+    }\n+\n+    \/**\n+     * If the specified character ch matches the current character then add current character\n+     * to the literal buffer and then advance.\n+     *\n+     * @param ch character to match.\n+     * @return true if ch matches current character.\n+     *\/\n+    boolean acceptThenPut(char ch) {\n+        if (is(ch)) {\n+            put(get());\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * If either ch1 or ch2 matches the current character then add current character\n+     * to the literal buffer and then advance.\n+     *\n+     * @param ch1 first character to match.\n+     * @param ch2 second character to match.\n+     * @return true if either ch1 or ch2 matches current character.\n+     *\/\n+    boolean acceptOneOfThenPut(char ch1, char ch2) {\n+        if (isOneOf(ch1, ch2)) {\n+            put(get());\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Test if the current character is a line terminator.\n+     *\n+     * @return true if current character is a line terminator.\n+     *\/\n+    private boolean isEOLN() {\n+        return isOneOf('\\n', '\\r');\n+    }\n+\n+    \/**\n+     * Processes the current character and places in the literal buffer. If the current\n+     * character is a backslash then the next character is validated as a proper\n+     * escape character. Conversion of escape sequences takes place at end of nextToken().\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanLitChar(int pos) {\n+        if (acceptThenPut('\\\\')) {\n+            hasEscapeSequences = true;\n+\n+            switch (get()) {\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    char leadch = get();\n+                    putThenNext();\n+\n+                    if (inRange('0', '7')) {\n+                        putThenNext();\n+\n+                        if (leadch <= '3' && inRange('0', '7')) {\n+                            putThenNext();\n+                        }\n+                    }\n+                    break;\n+\n+                case 'b':\n+                case 't':\n+                case 'n':\n+                case 'f':\n+                case 'r':\n+                case '\\'':\n+                case '\\\"':\n+                case '\\\\':\n+                    putThenNext();\n+                    break;\n+\n+                case '\\n':\n+                case '\\r':\n+                    lexError(position(), Errors.IllegalEscChar);\n+                    break;\n+\n+                default:\n+                    lexError(position(), Errors.IllegalEscChar);\n+                    break;\n+            }\n+        } else {\n+            putThenNext();\n+        }\n+    }\n+\n+    \/**\n+     * Scan a string literal.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanString(int pos) {\n+        \/\/ Assume the best.\n+        tk = Tokens.TokenKind.STRINGLITERAL;\n+        \/\/ Skip first quote.\n+        next();\n+\n+        \/\/ While characters are available.\n+        while (isAvailable()) {\n+            if (accept('\\\"')) {\n+                return;\n+            }\n+\n+            if (isEOLN()) {\n+                \/\/ Line terminator in string literal is an error.\n+                \/\/ Fall out to unclosed string literal error.\n+                break;\n+            } else {\n+                \/\/ Add character to string buffer.\n+                scanLitChar(pos);\n+            }\n+        }\n+\n+        lexError(pos, Errors.UnclosedStrLit);\n+    }\n+\n+    \/**\n+     * Scan sequence of digits.\n+     *\n+     * @param pos        position of the first character in literal.\n+     * @param digitRadix radix of numeric literal.\n+     *\/\n+    private void scanDigits(int pos, int digitRadix) {\n+        int leadingUnderscorePos = is('_') ? position() : NOT_FOUND;\n+        int trailingUnderscorePos;\n+\n+        do {\n+            if (!is('_')) {\n+                put();\n+                trailingUnderscorePos = NOT_FOUND;\n+            } else {\n+                trailingUnderscorePos = position();\n+            }\n+\n+            next();\n+        } while (digit(pos, digitRadix) >= 0 || is('_'));\n+\n+        if (leadingUnderscorePos != NOT_FOUND) {\n+            lexError(leadingUnderscorePos, Errors.IllegalUnderscore);\n+        } else if (trailingUnderscorePos != NOT_FOUND) {\n+            lexError(trailingUnderscorePos, Errors.IllegalUnderscore);\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part of hexadecimal floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanHexExponentAndSuffix(int pos) {\n+        if (acceptOneOfThenPut('p', 'P')) {\n+            skipIllegalUnderscores();\n+            acceptOneOfThenPut('+', '-');\n+            skipIllegalUnderscores();\n+\n+            if (digit(pos, 10) >= 0) {\n+                scanDigits(pos, 10);\n+            } else {\n+                lexError(pos, Errors.MalformedFpLit);\n+            }\n+        } else {\n+            lexError(pos, Errors.MalformedFpLit);\n+        }\n+\n+        if (acceptOneOfThenPut('f', 'F')) {\n+            tk = Tokens.TokenKind.FLOATLITERAL;\n+            radix = 16;\n+        } else {\n+            acceptOneOfThenPut('d', 'D');\n+            tk = Tokens.TokenKind.DOUBLELITERAL;\n+            radix = 16;\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part of floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanFraction(int pos) {\n+        skipIllegalUnderscores();\n+\n+        if (digit(pos, 10) >= 0) {\n+            scanDigits(pos, 10);\n+        }\n+\n+        int index = sb.length();\n+\n+        if (acceptOneOfThenPut('e', 'E')) {\n+            skipIllegalUnderscores();\n+            acceptOneOfThenPut('+', '-');\n+            skipIllegalUnderscores();\n+\n+            if (digit(pos, 10) >= 0) {\n+                scanDigits(pos, 10);\n+                return;\n+            }\n+\n+            lexError(pos, Errors.MalformedFpLit);\n+            sb.setLength(index);\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part and 'd' or 'f' suffix of floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanFractionAndSuffix(int pos) {\n+        radix = 10;\n+        scanFraction(pos);\n+\n+        if (acceptOneOfThenPut('f', 'F')) {\n+            tk = Tokens.TokenKind.FLOATLITERAL;\n+        } else {\n+            acceptOneOfThenPut('d', 'D');\n+            tk = Tokens.TokenKind.DOUBLELITERAL;\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part and 'd' or 'f' suffix of hexadecimal floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanHexFractionAndSuffix(int pos, boolean seendigit) {\n+        radix = 16;\n+        assert is('.');\n+        putThenNext();\n+        skipIllegalUnderscores();\n+\n+        if (digit(pos, 16) >= 0) {\n+            seendigit = true;\n+            scanDigits(pos, 16);\n+        }\n+\n+        if (!seendigit)\n+            lexError(pos, Errors.InvalidHexNumber);\n+        else\n+            scanHexExponentAndSuffix(pos);\n+    }\n+\n+    \/**\n+     * Skip over underscores and report as a error if found.\n+     *\/\n+    private void skipIllegalUnderscores() {\n+        if (is('_')) {\n+            lexError(position(), Errors.IllegalUnderscore);\n+            skip('_');\n+        }\n+    }\n+\n+    \/**\n+     * Read a number. (Spec. 3.10)\n+     *\n+     * @param pos   position of the first character in literal.\n+     * @param radix the radix of the number; one of 2, 8, 10, 16.\n+     *\/\n+    private void scanNumber(int pos, int radix) {\n+        \/\/ for octal, allow base-10 digit in case it's a float literal\n+        this.radix = radix;\n+        int digitRadix = (radix == 8 ? 10 : radix);\n+        int firstDigit = digit(pos, Math.max(10, digitRadix));\n+        boolean seendigit = firstDigit >= 0;\n+        boolean seenValidDigit = firstDigit >= 0 && firstDigit < digitRadix;\n+\n+        if (seendigit) {\n+            scanDigits(pos, digitRadix);\n+        }\n+\n+        if (radix == 16 && is('.')) {\n+            scanHexFractionAndSuffix(pos, seendigit);\n+        } else if (seendigit && radix == 16 && isOneOf('p', 'P')) {\n+            scanHexExponentAndSuffix(pos);\n+        } else if (digitRadix == 10 && is('.')) {\n+            putThenNext();\n+            scanFractionAndSuffix(pos);\n+        } else if (digitRadix == 10 && isOneOf('e', 'E', 'f', 'F', 'd', 'D')) {\n+            scanFractionAndSuffix(pos);\n+        } else {\n+            if (!seenValidDigit) {\n+                switch (radix) {\n+                    case 2:\n+                        lexError(pos, Errors.InvalidBinaryNumber);\n+                        break;\n+                    case 16:\n+                        lexError(pos, Errors.InvalidHexNumber);\n+                        break;\n+                }\n+            }\n+            \/\/ If it is not a floating point literal,\n+            \/\/ the octal number should be rescanned correctly.\n+            if (radix == 8) {\n+                sb.setLength(0);\n+                reset(pos);\n+                scanDigits(pos, 8);\n+            }\n+\n+            if (acceptOneOf('l', 'L')) {\n+                tk = Tokens.TokenKind.LONGLITERAL;\n+            } else {\n+                tk = Tokens.TokenKind.INTLITERAL;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Determines if the sequence in the literal buffer is a token (keyword, operator.)\n+     *\/\n+    private void checkIdent(Tokens.TokenKind identifier) {\n+        name = sb.toString();\n+        tk = tokens.lookupKind(name, identifier);\n+    }\n+\n+    \/**\n+     * Read an identifier. (Spec. 3.8)\n+     *\/\n+    private void scanIdent() {\n+        scanIdent(Tokens.TokenKind.IDENTIFIER);\n+    }\n+\n+    \/**\n+     * Read an identifier. (Spec. 3.8)\n+     *\/\n+    private void scanIdent(Tokens.TokenKind identifier) {\n+        putThenNext();\n+\n+        do {\n+            switch (get()) {\n+                case 'A':\n+                case 'B':\n+                case 'C':\n+                case 'D':\n+                case 'E':\n+                case 'F':\n+                case 'G':\n+                case 'H':\n+                case 'I':\n+                case 'J':\n+                case 'K':\n+                case 'L':\n+                case 'M':\n+                case 'N':\n+                case 'O':\n+                case 'P':\n+                case 'Q':\n+                case 'R':\n+                case 'S':\n+                case 'T':\n+                case 'U':\n+                case 'V':\n+                case 'W':\n+                case 'X':\n+                case 'Y':\n+                case 'Z':\n+                case 'a':\n+                case 'b':\n+                case 'c':\n+                case 'd':\n+                case 'e':\n+                case 'f':\n+                case 'g':\n+                case 'h':\n+                case 'i':\n+                case 'j':\n+                case 'k':\n+                case 'l':\n+                case 'm':\n+                case 'n':\n+                case 'o':\n+                case 'p':\n+                case 'q':\n+                case 'r':\n+                case 's':\n+                case 't':\n+                case 'u':\n+                case 'v':\n+                case 'w':\n+                case 'x':\n+                case 'y':\n+                case 'z':\n+                case '$':\n+                case '_':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    break;\n+\n+                case '\\u0000':\n+                case '\\u0001':\n+                case '\\u0002':\n+                case '\\u0003':\n+                case '\\u0004':\n+                case '\\u0005':\n+                case '\\u0006':\n+                case '\\u0007':\n+                case '\\u0008':\n+                case '\\u000E':\n+                case '\\u000F':\n+                case '\\u0010':\n+                case '\\u0011':\n+                case '\\u0012':\n+                case '\\u0013':\n+                case '\\u0014':\n+                case '\\u0015':\n+                case '\\u0016':\n+                case '\\u0017':\n+                case '\\u0018':\n+                case '\\u0019':\n+                case '\\u001B':\n+                case '\\u007F':\n+                    next();\n+                    continue;\n+\n+                case '\\u001A': \/\/ EOI is also a legal identifier part\n+                    if (isAvailable()) {\n+                        next();\n+                        continue;\n+                    }\n+\n+                    checkIdent(identifier);\n+                    return;\n+\n+                default:\n+                    boolean isJavaIdentifierPart;\n+\n+                    if (isASCII()) {\n+                        \/\/ all ASCII range chars already handled, above\n+                        isJavaIdentifierPart = false;\n+                    } else {\n+                        if (Character.isIdentifierIgnorable(get())) {\n+                            next();\n+                            continue;\n+                        }\n+\n+                        isJavaIdentifierPart = isSurrogate()\n+                                ? Character.isJavaIdentifierPart(getCodepoint())\n+                                : Character.isJavaIdentifierPart(get());\n+                    }\n+\n+                    if (!isJavaIdentifierPart) {\n+                        checkIdent(identifier);\n+                        return;\n+                    }\n+            }\n+\n+            putThenNext();\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Read token (main entrypoint.)\n+     *\/\n+    public Tokens.Token readToken() {\n+        sb.setLength(0);\n+        name = null;\n+        radix = 0;\n+        hasEscapeSequences = false;\n+\n+        int pos = 0;\n+        List<Tokens.Comment> comments = null;\n+\n+        try {\n+            loop:\n+            while (true) {\n+                pos = position();\n+\n+                switch (get()) {\n+                    case ' ':  \/\/ (Spec 3.6)\n+                    case '\\t': \/\/ (Spec 3.6)\n+                    case '\\f': \/\/ (Spec 3.6)\n+                        skipWhitespace();\n+                        processWhiteSpace(pos, position());\n+                        break;\n+\n+                    case '\\n': \/\/ (Spec 3.4)\n+                        next();\n+                        processLineTerminator(pos, position());\n+                        break;\n+\n+                    case '\\r': \/\/ (Spec 3.4)\n+                        next();\n+                        accept('\\n');\n+                        processLineTerminator(pos, position());\n+                        break;\n+\n+                    case 'A':\n+                    case 'B':\n+                    case 'C':\n+                    case 'D':\n+                    case 'E':\n+                    case 'F':\n+                    case 'G':\n+                    case 'H':\n+                    case 'I':\n+                    case 'J':\n+                    case 'K':\n+                    case 'L':\n+                    case 'M':\n+                    case 'N':\n+                    case 'O':\n+                    case 'P':\n+                    case 'Q':\n+                    case 'R':\n+                    case 'S':\n+                    case 'T':\n+                    case 'U':\n+                    case 'V':\n+                    case 'W':\n+                    case 'X':\n+                    case 'Y':\n+                    case 'Z':\n+                    case 'a':\n+                    case 'b':\n+                    case 'c':\n+                    case 'd':\n+                    case 'e':\n+                    case 'f':\n+                    case 'g':\n+                    case 'h':\n+                    case 'i':\n+                    case 'j':\n+                    case 'k':\n+                    case 'l':\n+                    case 'm':\n+                    case 'n':\n+                    case 'o':\n+                    case 'p':\n+                    case 'q':\n+                    case 'r':\n+                    case 's':\n+                    case 't':\n+                    case 'u':\n+                    case 'v':\n+                    case 'w':\n+                    case 'x':\n+                    case 'y':\n+                    case 'z':\n+                    case '$':\n+                    case '_': \/\/ (Spec. 3.8)\n+                        scanIdent();\n+                        break loop;\n+\n+                    case '%':\n+                        scanIdent(Tokens.TokenKind.VALUE_IDENTIFIER);\n+                        break loop;\n+\n+                    case '0': \/\/ (Spec. 3.10)\n+                        next();\n+\n+                        if (acceptOneOf('x', 'X')) {\n+                            skipIllegalUnderscores();\n+                            scanNumber(pos, 16);\n+                        } else if (acceptOneOf('b', 'B')) {\n+                            skipIllegalUnderscores();\n+                            scanNumber(pos, 2);\n+                        } else {\n+                            put('0');\n+\n+                            if (is('_')) {\n+                                int savePos = position();\n+                                skip('_');\n+\n+                                if (digit(pos, 10) < 0) {\n+                                    lexError(savePos, Errors.IllegalUnderscore);\n+                                }\n+                            }\n+\n+                            scanNumber(pos, 8);\n+                        }\n+                        break loop;\n+\n+                    case '1':\n+                    case '2':\n+                    case '3':\n+                    case '4':\n+                    case '5':\n+                    case '6':\n+                    case '7':\n+                    case '8':\n+                    case '9':  \/\/ (Spec. 3.10)\n+                        scanNumber(pos, 10);\n+                        break loop;\n+\n+                    case '.': \/\/ (Spec. 3.12)\n+                        next();\n+                        int savePos = position();\n+\n+                        if (accept('.')) {\n+                            lexError(savePos, Errors.IllegalDot);\n+                        } else if (digit(pos, 10) >= 0) {\n+                            put('.');\n+                            scanFractionAndSuffix(pos); \/\/ (Spec. 3.10)\n+                        } else {\n+                            tk = Tokens.TokenKind.DOT;\n+                        }\n+                        break loop;\n+\n+                    case ',': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.COMMA;\n+                        break loop;\n+\n+                    case '(': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.LPAREN;\n+                        break loop;\n+\n+                    case ')': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.RPAREN;\n+                        break loop;\n+\n+                    case '[': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.LBRACKET;\n+                        break loop;\n+\n+                    case ']': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.RBRACKET;\n+                        break loop;\n+\n+                    case '{': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.LBRACE;\n+                        break loop;\n+\n+                    case '}': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.RBRACE;\n+                        break loop;\n+\n+                    case '?':\n+                        next();\n+                        tk = Tokens.TokenKind.QUES;\n+                        break loop;\n+\n+                    case ';':\n+                        next();\n+                        tk = Tokens.TokenKind.SEMI;\n+                        break loop;\n+\n+                    case ':':\n+                        next();\n+                        if (accept(':')) {\n+                            tk = Tokens.TokenKind.COLCOL;\n+                        } else {\n+                            tk = Tokens.TokenKind.COLON;\n+                        }\n+                        break loop;\n+\n+                    case '&':\n+                        next();\n+                        tk = Tokens.TokenKind.AMP;\n+                        break loop;\n+\n+                    case '@':\n+                        next();\n+                        tk = Tokens.TokenKind.MONKEYS_AT;\n+                        break loop;\n+\n+                    case '^':\n+                        next();\n+                        tk = Tokens.TokenKind.CARET;\n+                        break loop;\n+\n+                    case '=':\n+                        next();\n+                        tk = Tokens.TokenKind.EQ;\n+                        break loop;\n+\n+                    case '<':\n+                        next();\n+                        tk = Tokens.TokenKind.LT;\n+                        break loop;\n+\n+                    case '>':\n+                        next();\n+                        tk = Tokens.TokenKind.GT;\n+                        break loop;\n+\n+                    case '+':\n+                        next();\n+                        tk = Tokens.TokenKind.PLUS;\n+                        break loop;\n+\n+                    case '-':\n+                        next();\n+                        if (accept('>')) {\n+                            tk = Tokens.TokenKind.ARROW;\n+                        } else {\n+                            tk = Tokens.TokenKind.SUB;\n+                        }\n+                        break loop;\n+\n+                    case '\/':\n+                        next();\n+\n+                        if (accept('\/')) { \/\/ (Spec. 3.7)\n+                            skipToEOLN();\n+\n+                            if (isAvailable()) {\n+                                comments = appendComment(comments, processComment(pos, position(), Tokens.Comment.CommentStyle.LINE));\n+                            }\n+                            break;\n+                        } else if (accept('*')) { \/\/ (Spec. 3.7)\n+                            while (isAvailable()) {\n+                                if (accept('*')) {\n+                                    if (is('\/')) {\n+                                        break;\n+                                    }\n+                                } else {\n+                                    next();\n+                                }\n+                            }\n+\n+                            if (accept('\/')) {\n+                                comments = appendComment(comments, processComment(pos, position(), Tokens.Comment.CommentStyle.BLOCK));\n+\n+                                break;\n+                            } else {\n+                                lexError(pos, Errors.UnclosedComment);\n+\n+                                break loop;\n+                            }\n+                        } else {\n+                            lexError(pos, Errors.UnclosedComment);\n+                        }\n+                        break loop;\n+\n+                    case '\\'': \/\/ (Spec. 3.10)\n+                        next();\n+\n+                        if (accept('\\'')) {\n+                            lexError(pos, Errors.EmptyCharLit);\n+                        } else {\n+                            if (isEOLN()) {\n+                                lexError(pos, Errors.IllegalLineEndInCharLit);\n+                            }\n+\n+                            scanLitChar(pos);\n+\n+                            if (accept('\\'')) {\n+                                tk = Tokens.TokenKind.CHARLITERAL;\n+                            } else {\n+                                lexError(pos, Errors.UnclosedCharLit);\n+                            }\n+                        }\n+                        break loop;\n+\n+                    case '\\\"': \/\/ (Spec. 3.10)\n+                        scanString(pos);\n+                        break loop;\n+\n+                    default:\n+                        boolean isJavaIdentifierStart;\n+\n+                        if (isASCII()) {\n+                            \/\/ all ASCII range chars already handled, above\n+                            isJavaIdentifierStart = false;\n+                        } else {\n+                            isJavaIdentifierStart = isSurrogate()\n+                                    ? Character.isJavaIdentifierStart(getCodepoint())\n+                                    : Character.isJavaIdentifierStart(get());\n+                        }\n+\n+                        if (isJavaIdentifierStart) {\n+                            scanIdent();\n+                        } else if (digit(pos, 10) >= 0) {\n+                            scanNumber(pos, 10);\n+                        } else if (is((char) EOI) || !isAvailable()) {\n+                            tk = Tokens.TokenKind.EOF;\n+                            pos = position();\n+                        } else {\n+                            String arg;\n+\n+                            if (isSurrogate()) {\n+                                int codePoint = getCodepoint();\n+                                char hi = Character.highSurrogate(codePoint);\n+                                char lo = Character.lowSurrogate(codePoint);\n+                                arg = String.format(\"\\\\u%04x\\\\u%04x\", (int) hi, (int) lo);\n+                            } else {\n+                                char ch = get();\n+                                arg = (32 < ch && ch < 127) ? String.format(\"%s\", ch) :\n+                                        String.format(\"\\\\u%04x\", (int) ch);\n+                            }\n+\n+                            lexError(pos, Errors.IllegalChar(arg));\n+                            next();\n+                        }\n+                        break loop;\n+                }\n+            }\n+\n+            int endPos = position();\n+\n+            if (tk.tag == Tokens.Token.Tag.DEFAULT) {\n+                return new Tokens.Token(tk, pos, endPos, comments);\n+            } else if (tk.tag == Tokens.Token.Tag.NAMED) {\n+                return new Tokens.NamedToken(tk, pos, endPos, name, comments);\n+            } else {\n+                \/\/ Get characters from string buffer.\n+                String string = sb.toString();\n+\n+                \/\/ Translate escape sequences if present.\n+                if (hasEscapeSequences) {\n+                    try {\n+                        string = string.translateEscapes();\n+                    } catch (Exception ex) {\n+                        \/\/ Error already reported, just use untranslated string.\n+                    }\n+                }\n+\n+                if (tk.tag == Tokens.Token.Tag.STRING) {\n+                    \/\/ Build string token.\n+                    return new Tokens.StringToken(tk, pos, endPos, string, comments);\n+                } else {\n+                    \/\/ Build numeric token.\n+                    return new Tokens.NumericToken(tk, pos, endPos, string, radix, comments);\n+                }\n+            }\n+        } finally {\n+            int endPos = position();\n+\n+            if (scannerDebug) {\n+                System.out.println(\"nextToken(\" + pos\n+                        + \",\" + endPos + \")=|\" +\n+                        new String(getRawCharacters(pos, endPos))\n+                        + \"| \" + tk.name());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Appends a comment to the list of comments preceding the current token.\n+     *\n+     * @param comments existing list of comments.\n+     * @param comment  comment to append.\n+     * @return new list with comment prepended to the existing list.\n+     *\/\n+    List<Tokens.Comment> appendComment(List<Tokens.Comment> comments, Tokens.Comment comment) {\n+        if (comments == null) {\n+            comments = new ArrayList<>();\n+        }\n+        \/\/ prepend\n+        comments.add(0, comment);\n+        return comments;\n+    }\n+\n+    \/**\n+     * Return the position where a lexical error occurred.\n+     *\n+     * @return position in the input buffer of where the error occurred.\n+     *\/\n+    public int errPos() {\n+        return errPos;\n+    }\n+\n+    \/**\n+     * Set the position where a lexical error occurred.\n+     *\n+     * @param pos position in the input buffer of where the error occurred.\n+     *\/\n+    public void errPos(int pos) {\n+        errPos = pos;\n+    }\n+\n+    \/**\n+     * Called when a complete comment has been scanned. pos and endPos\n+     * will mark the comment boundary.\n+     *\n+     * @param pos    position of the opening \/ in the input buffer.\n+     * @param endPos position + 1 of the closing \/ in the input buffer.\n+     * @param style  style of comment.\n+     * @return the constructed BasicComment.\n+     *\/\n+    Tokens.Comment processComment(int pos, int endPos, Tokens.Comment.CommentStyle style) {\n+        if (scannerDebug) {\n+            System.out.println(\"processComment(\" + pos\n+                    + \",\" + endPos + \",\" + style + \")=|\"\n+                    + new String(getRawCharacters(pos, endPos))\n+                    + \"|\");\n+        }\n+\n+        char[] buf = getRawCharacters(pos, endPos);\n+        return new BasicComment(style, new String(buf));\n+    }\n+\n+    \/**\n+     * Called when a complete whitespace run has been scanned. pos and endPos\n+     * will mark the whitespace boundary.\n+     * <p>\n+     * (Spec 3.6)\n+     *\n+     * @param pos    position in input buffer of first whitespace character.\n+     * @param endPos position + 1 in input buffer of last whitespace character.\n+     *\/\n+    void processWhiteSpace(int pos, int endPos) {\n+        if (scannerDebug) {\n+            System.out.println(\"processWhitespace(\" + pos\n+                    + \",\" + endPos + \")=|\" +\n+                    new String(getRawCharacters(pos, endPos))\n+                    + \"|\");\n+        }\n+    }\n+\n+    \/**\n+     * Called when a line terminator has been processed.\n+     *\n+     * @param pos    position in input buffer of first character in sequence.\n+     * @param endPos position + 1 in input buffer of last character in sequence.\n+     *\/\n+    void processLineTerminator(int pos, int endPos) {\n+        if (scannerDebug) {\n+            System.out.println(\"processTerminator(\" + pos\n+                    + \",\" + endPos + \")=|\" +\n+                    new String(getRawCharacters(pos, endPos))\n+                    + \"|\");\n+        }\n+    }\n+\n+    \/**\n+     * Build a map for translating between line numbers and positions in the input.\n+     *\n+     * @return a LineMap\n+     *\/\n+    public Position.LineMap getLineMap() {\n+        return Position.makeLineMap(getRawCharacters(), length(), false);\n+    }\n+\n+    \/**\n+     * Scan a documentation comment; determine if a deprecated tag is present.\n+     * Called once the initial \/, * have been skipped, positioned at the second *\n+     * (which is treated as the beginning of the first line).\n+     * Stops positioned at the closing '\/'.\n+     *\n+     * @param style Style of comment\n+     *              LINE starting with \/\/\n+     *              BLOCK starting with \/*\n+     *\/\n+    record BasicComment(Tokens.Comment.CommentStyle style, String text) implements Tokens.Comment {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/JavaBasedTokenizer.java","additions":1124,"deletions":0,"binary":false,"changes":1124,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.parser.impl.Position.LineMap;\n+\n+\/**\n+ * The lexical analyzer maps an input stream consisting of ASCII\n+ * characters and Unicode escapes into a token sequence.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public sealed interface Lexer permits Scanner {\n+\n+    \/**\n+     * Consume the next token.\n+     *\/\n+    void nextToken();\n+\n+    \/**\n+     * Return current token.\n+     *\/\n+    Tokens.Token token();\n+\n+    \/**\n+     * Return token with given lookahead.\n+     *\/\n+    Tokens.Token token(int lookahead);\n+\n+    \/**\n+     * Return the last character position of the previous token.\n+     *\/\n+    Tokens.Token prevToken();\n+\n+    \/**\n+     * Return the position where a lexical error occurred;\n+     *\/\n+    int errPos();\n+\n+    \/**\n+     * Set the position where a lexical error occurred;\n+     *\/\n+    void errPos(int pos);\n+\n+    \/**\n+     * Build a map for translating between line numbers and\n+     * positions in the input.\n+     *\n+     * @return a LineMap\n+     *\/\n+    LineMap getLineMap();\n+\n+    default boolean is(Tokens.TokenKind tk) {\n+        Tokens.Token t = token();\n+        if (t.kind == tk) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    default Tokens.Token accept(Tokens.TokenKind tk) {\n+        Tokens.Token t = token();\n+        if (t.kind == tk) {\n+            nextToken();\n+            return t;\n+        } else {\n+            \/\/ @@@ Exception\n+            LineMap lineMap = getLineMap();\n+            int lineNumber = lineMap.getLineNumber(t.pos);\n+            int columnNumber = lineMap.getColumnNumber(t.pos);\n+            throw new IllegalArgumentException(\"Expected \" + tk + \" but observed \" + t.kind +\n+                    \" \" + lineNumber + \":\" + columnNumber);\n+        }\n+    }\n+\n+    default boolean acceptIf(Tokens.TokenKind tk) {\n+        Tokens.Token t = token();\n+        if (t.kind == tk) {\n+            nextToken();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    default RuntimeException unexpected() {\n+        Tokens.Token t = token();\n+        LineMap lineMap = getLineMap();\n+        int lineNumber = lineMap.getLineNumber(t.pos);\n+        int columnNumber = lineMap.getColumnNumber(t.pos);\n+        return new IllegalArgumentException(\"Unexpected token \" + t.kind +\n+                \" \" + lineNumber + \":\" + columnNumber);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Lexer.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+final class Log {\n+    Log() {\n+    }\n+\n+    public void error(int pos, Errors.Error errorKey) {\n+        \/\/ @@@ Exception\n+        throw new IllegalStateException(\"Lexer error: \" + errorKey.toString() + \" :\" + pos);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Log.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.BitSet;\n+\n+\/**\n+ * A class that defines source code positions as simple character\n+ * offsets from the beginning of the file. The first character\n+ * is at position 0.\n+ * <p>\n+ * Support is also provided for (line,column) coordinates, but tab\n+ * expansion is optional and no Unicode escape translation is considered.\n+ * The first character is at location (1,1).\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Position {\n+    static final int NOPOS = -1;\n+\n+    static final int FIRSTPOS = 0;\n+    static final int FIRSTLINE = 1;\n+    static final int FIRSTCOLUMN = 1;\n+\n+    static final int LINESHIFT = 10;\n+    static final int MAXCOLUMN = (1 << LINESHIFT) - 1;\n+    static final int MAXLINE = (1 << (Integer.SIZE - LINESHIFT)) - 1;\n+\n+    static final int MAXPOS = Integer.MAX_VALUE;\n+\n+    \/**\n+     * This is class is not supposed to be instantiated.\n+     *\/\n+    private Position() {\n+    }\n+\n+    \/**\n+     * A two-way map between line\/column numbers and positions,\n+     * derived from a scan done at creation time.  Tab expansion is\n+     * optionally supported via a character map.  Text content\n+     * is not retained.\n+     * <p>\n+     * Notes:  The first character position FIRSTPOS is at\n+     * (FIRSTLINE,FIRSTCOLUMN).  No account is taken of Unicode escapes.\n+     *\n+     * @param src        Source characters\n+     * @param max        Number of characters to read\n+     * @param expandTabs If true, expand tabs when calculating columns\n+     *\/\n+    static LineMap makeLineMap(char[] src, int max, boolean expandTabs) {\n+        LineMapImpl lineMap = expandTabs ?\n+                new LineTabMapImpl(max) : new LineMapImpl();\n+        lineMap.build(src, max);\n+        return lineMap;\n+    }\n+\n+    \/**\n+     * Encode line and column numbers in an integer as:\n+     * {@code line-number << LINESHIFT + column-number }.\n+     * {@link Position#NOPOS} represents an undefined position.\n+     *\n+     * @param line number of line (first is 1)\n+     * @param col  number of character on line (first is 1)\n+     * @return an encoded position or {@link Position#NOPOS}\n+     * if the line or column number is too big to\n+     * represent in the encoded format\n+     * @throws IllegalArgumentException if line or col is less than 1\n+     *\/\n+    static int encodePosition(int line, int col) {\n+        if (line < 1)\n+            throw new IllegalArgumentException(\"line must be greater than 0\");\n+        if (col < 1)\n+            throw new IllegalArgumentException(\"column must be greater than 0\");\n+\n+        if (line > MAXLINE || col > MAXCOLUMN) {\n+            return NOPOS;\n+        }\n+        return (line << LINESHIFT) + col;\n+    }\n+\n+    public interface LineMap {\n+        \/**\n+         * Finds the start position of a line.\n+         *\n+         * @param line line number (beginning at 1)\n+         * @return position of first character in line\n+         * @throws IndexOutOfBoundsException if {@code lineNumber < 1}\n+         *                                   if {@code lineNumber > no. of lines}\n+         *\/\n+        long getStartPosition(long line);\n+\n+        \/**\n+         * Finds the position corresponding to a (line,column).\n+         *\n+         * @param line   line number (beginning at 1)\n+         * @param column tab-expanded column number (beginning 1)\n+         * @return position of character\n+         * @throws IndexOutOfBoundsException if {@code line < 1}\n+         *                                   if {@code line > no. of lines}\n+         *\/\n+        long getPosition(long line, long column);\n+\n+        \/**\n+         * Finds the line containing a position; a line termination\n+         * character is on the line it terminates.\n+         *\n+         * @param pos character offset of the position\n+         * @return the line number of pos (first line is 1)\n+         *\/\n+        long getLineNumber(long pos);\n+\n+        \/**\n+         * Finds the column for a character position.\n+         * Tab characters preceding the position on the same line\n+         * will be expanded when calculating the column number.\n+         *\n+         * @param pos character offset of the position\n+         * @return the tab-expanded column number of pos (first column is 1)\n+         *\/\n+        long getColumnNumber(long pos);\n+\n+        \/**\n+         * Find the start position of a line.\n+         *\n+         * @param line number of line (first is 1)\n+         * @return position of first character in line\n+         * @throws ArrayIndexOutOfBoundsException if {@code lineNumber < 1}\n+         *                                        if {@code lineNumber > no. of lines}\n+         *\/\n+        int getStartPosition(int line);\n+\n+        \/**\n+         * Find the position corresponding to a (line,column).\n+         *\n+         * @param line   number of line (first is 1)\n+         * @param column number of character on line (first is 1)\n+         * @return position of character\n+         * @throws ArrayIndexOutOfBoundsException if {@code line < 1}\n+         *                                        if {@code line > no. of lines}\n+         *\/\n+        int getPosition(int line, int column);\n+\n+        \/**\n+         * Find the line containing a position; a line termination\n+         * character is on the line it terminates.\n+         *\n+         * @param pos character offset of the position\n+         * @return the line number on which pos occurs (first line is 1)\n+         *\/\n+        int getLineNumber(int pos);\n+\n+        \/**\n+         * Find the column for a character position.\n+         * Note:  this method does not handle tab expansion.\n+         * If tab expansion is needed, use a LineTabMap instead.\n+         *\n+         * @param pos character offset of the position\n+         * @return the column number at which pos occurs\n+         *\/\n+        int getColumnNumber(int pos);\n+    }\n+\n+    static class LineMapImpl implements LineMap {\n+        int[] startPosition; \/\/ start position of each line\n+\n+        LineMapImpl() {\n+        }\n+\n+        void build(char[] src, int max) {\n+            int c = 0;\n+            int i = 0;\n+            int[] linebuf = new int[max];\n+            while (i < max) {\n+                linebuf[c++] = i;\n+                do {\n+                    char ch = src[i];\n+                    if (ch == '\\r' || ch == '\\n') {\n+                        if (ch == '\\r' && (i + 1) < max && src[i + 1] == '\\n')\n+                            i += 2;\n+                        else\n+                            ++i;\n+                        break;\n+                    } else if (ch == '\\t')\n+                        setTabPosition(i);\n+                } while (++i < max);\n+            }\n+            this.startPosition = new int[c];\n+            System.arraycopy(linebuf, 0, startPosition, 0, c);\n+        }\n+\n+        @Override\n+        public int getStartPosition(int line) {\n+            return startPosition[line - FIRSTLINE];\n+        }\n+\n+        @Override\n+        public long getStartPosition(long line) {\n+            return getStartPosition(longToInt(line));\n+        }\n+\n+        @Override\n+        public int getPosition(int line, int column) {\n+            return startPosition[line - FIRSTLINE] + column - FIRSTCOLUMN;\n+        }\n+\n+        @Override\n+        public long getPosition(long line, long column) {\n+            return getPosition(longToInt(line), longToInt(column));\n+        }\n+\n+        \/\/ Cache of last line number lookup\n+        private int lastPosition = Position.FIRSTPOS;\n+        private int lastLine = Position.FIRSTLINE;\n+\n+        @Override\n+        public int getLineNumber(int pos) {\n+            if (pos == lastPosition) {\n+                return lastLine;\n+            }\n+            lastPosition = pos;\n+\n+            int low = 0;\n+            int high = startPosition.length - 1;\n+            while (low <= high) {\n+                int mid = (low + high) >> 1;\n+                int midVal = startPosition[mid];\n+\n+                if (midVal < pos)\n+                    low = mid + 1;\n+                else if (midVal > pos)\n+                    high = mid - 1;\n+                else {\n+                    lastLine = mid + 1; \/\/ pos is at beginning of this line\n+                    return lastLine;\n+                }\n+            }\n+            lastLine = low;\n+            return lastLine;  \/\/ pos is on this line\n+        }\n+\n+        @Override\n+        public long getLineNumber(long pos) {\n+            return getLineNumber(longToInt(pos));\n+        }\n+\n+        @Override\n+        public int getColumnNumber(int pos) {\n+            return pos - startPosition[getLineNumber(pos) - FIRSTLINE] + FIRSTCOLUMN;\n+        }\n+\n+        @Override\n+        public long getColumnNumber(long pos) {\n+            return getColumnNumber(longToInt(pos));\n+        }\n+\n+        static int longToInt(long longValue) {\n+            int intValue = (int) longValue;\n+            if (intValue != longValue)\n+                throw new IndexOutOfBoundsException();\n+            return intValue;\n+        }\n+\n+        void setTabPosition(int offset) {\n+        }\n+    }\n+\n+    \/**\n+     * A LineMap that handles tab expansion correctly.  The cost is\n+     * an additional bit per character in the source array.\n+     *\/\n+    static class LineTabMapImpl extends LineMapImpl {\n+        private final BitSet tabMap;       \/\/ bits set for tab positions.\n+\n+        LineTabMapImpl(int max) {\n+            super();\n+            tabMap = new BitSet(max);\n+        }\n+\n+        @Override\n+        void setTabPosition(int offset) {\n+            tabMap.set(offset);\n+        }\n+\n+        @Override\n+        public int getColumnNumber(int pos) {\n+            int lineStart = startPosition[getLineNumber(pos) - FIRSTLINE];\n+            int column = 0;\n+            for (int bp = lineStart; bp < pos; bp++) {\n+                if (tabMap.get(bp))\n+                    column = tabulate(column);\n+                else\n+                    column++;\n+            }\n+            return column + FIRSTCOLUMN;\n+        }\n+\n+        @Override\n+        public int getPosition(int line, int column) {\n+            int pos = startPosition[line - FIRSTLINE];\n+            column -= FIRSTCOLUMN;\n+            int col = 0;\n+            while (col < column) {\n+                pos++;\n+                if (tabMap.get(pos))\n+                    col = tabulate(col);\n+                else\n+                    col++;\n+            }\n+            return pos;\n+        }\n+    }\n+\n+    \/**\n+     * Tabulator column increment.\n+     *\/\n+    static final int TabInc = 8;\n+\n+    \/**\n+     * Bump column to the next tab.\n+     *\/\n+    static int tabulate(int column) {\n+        return (column \/ TabInc * TabInc) + TabInc;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Position.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.parser.impl.Position.LineMap;\n+\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.parser.impl.Tokens.DUMMY;\n+import static java.lang.reflect.code.parser.impl.Tokens.Token;\n+\n+\/**\n+ * The lexical analyzer maps an input stream consisting of\n+ * ASCII characters and Unicode escapes into a token sequence.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Scanner implements Lexer {\n+\n+    private final Tokens tokens;\n+\n+    \/**\n+     * The token, set by nextToken().\n+     *\/\n+    private Token token;\n+\n+    \/**\n+     * The previous token, set by nextToken().\n+     *\/\n+    private Token prevToken;\n+\n+    \/**\n+     * Buffer of saved tokens (used during lookahead)\n+     *\/\n+    private final List<Token> savedTokens = new ArrayList<>();\n+\n+    private final JavaBasedTokenizer tokenizer;\n+\n+    Scanner(Factory fac, char[] buf, int inputLength) {\n+        this(fac, new JavaBasedTokenizer(fac, buf, inputLength));\n+    }\n+\n+    Scanner(Factory fac, JavaBasedTokenizer tokenizer) {\n+        this.tokenizer = tokenizer;\n+        tokens = fac.tokens;\n+        token = prevToken = DUMMY;\n+    }\n+\n+    public Token token() {\n+        return token(0);\n+    }\n+\n+    public Token token(int lookahead) {\n+        if (lookahead == 0) {\n+            return token;\n+        } else {\n+            ensureLookahead(lookahead);\n+            return savedTokens.get(lookahead - 1);\n+        }\n+    }\n+\n+    \/\/where\n+    private void ensureLookahead(int lookahead) {\n+        for (int i = savedTokens.size(); i < lookahead; i++) {\n+            savedTokens.add(tokenizer.readToken());\n+        }\n+    }\n+\n+    public Token prevToken() {\n+        return prevToken;\n+    }\n+\n+    public void nextToken() {\n+        prevToken = token;\n+        if (!savedTokens.isEmpty()) {\n+            token = savedTokens.remove(0);\n+        } else {\n+            token = tokenizer.readToken();\n+        }\n+    }\n+\n+    public LineMap getLineMap() {\n+        return tokenizer.getLineMap();\n+    }\n+\n+    public int errPos() {\n+        return tokenizer.errPos();\n+    }\n+\n+    public void errPos(int pos) {\n+        tokenizer.errPos(pos);\n+    }\n+\n+    public static final class Factory {\n+        final Log log;\n+        final Tokens tokens;\n+\n+        \/**\n+         * Create a new scanner factory.\n+         *\/\n+        Factory() {\n+            this.log = new Log();\n+            this.tokens = new Tokens();\n+        }\n+\n+        public Scanner newScanner(CharSequence input) {\n+            if (input instanceof CharBuffer charBuffer) {\n+                return newScanner(toArray(charBuffer), charBuffer.limit());\n+            } else {\n+                char[] array = input.toString().toCharArray();\n+                return newScanner(array, array.length);\n+            }\n+        }\n+\n+        public Scanner newScanner(char[] input, int inputLength) {\n+            return new Scanner(this, input, inputLength);\n+        }\n+\n+        static char[] toArray(CharBuffer buffer) {\n+            if (buffer.hasArray())\n+                return buffer.compact().flip().array();\n+            else\n+                return buffer.toString().toCharArray();\n+        }\n+\n+        static final Factory INSTANCE = new Factory();\n+    }\n+\n+    public static Factory factory() {\n+        return Factory.INSTANCE;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Scanner.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * A class that defines codes\/utilities for Java source tokens\n+ * returned from lexical analysis.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Tokens {\n+\n+    \/**\n+     * Keyword array. Maps name indices to Token.\n+     *\/\n+    private final Map<String, TokenKind> keywords = new HashMap<>();\n+\n+    Tokens() {\n+        for (TokenKind t : TokenKind.values()) {\n+            if (t.name != null) {\n+                keywords.put(t.name, t);\n+            }\n+        }\n+    }\n+\n+    TokenKind lookupKind(String name, TokenKind identifier) {\n+        TokenKind t = keywords.get(name);\n+        return (t != null) ? t : identifier;\n+    }\n+\n+    \/**\n+     * This enum defines all tokens used by the javac scanner. A token is\n+     * optionally associated with a name.\n+     *\/\n+    public enum TokenKind implements Predicate<TokenKind> {\n+        EOF(),\n+        ERROR(),\n+        IDENTIFIER(Token.Tag.NAMED),\n+        VALUE_IDENTIFIER(Token.Tag.NAMED),\n+        EXTENDS(\"extends\", Token.Tag.NAMED),\n+        SUPER(\"super\", Token.Tag.NAMED),\n+        INTLITERAL(Token.Tag.NUMERIC),\n+        LONGLITERAL(Token.Tag.NUMERIC),\n+        FLOATLITERAL(Token.Tag.NUMERIC),\n+        DOUBLELITERAL(Token.Tag.NUMERIC),\n+        CHARLITERAL(Token.Tag.NUMERIC),\n+        STRINGLITERAL(Token.Tag.STRING),\n+        TRUE(\"true\", Token.Tag.NAMED),\n+        FALSE(\"false\", Token.Tag.NAMED),\n+        NULL(\"null\", Token.Tag.NAMED),\n+        UNDERSCORE(\"_\", Token.Tag.NAMED),\n+        ARROW(\"->\"),\n+        LPAREN(\"(\"),\n+        RPAREN(\")\"),\n+        LBRACE(\"{\"),\n+        RBRACE(\"}\"),\n+        LBRACKET(\"[\"),\n+        RBRACKET(\"]\"),\n+        COMMA(\",\"),\n+        DOT(\".\"),\n+        EQ(\"=\"),\n+        GT(\">\"),\n+        LT(\"<\"),\n+        QUES(\"?\"),\n+        COLON(\":\"),\n+        COLCOL(\"::\"),\n+        SEMI(\";\"),\n+        PLUS(\"+\"),\n+        SUB(\"-\"),\n+        AMP(\"&\"),\n+        CARET(\"^\"),\n+        MONKEYS_AT(\"@\"),\n+        CUSTOM;\n+\n+        public final String name;\n+        public final Token.Tag tag;\n+\n+        TokenKind() {\n+            this(null, Token.Tag.DEFAULT);\n+        }\n+\n+        TokenKind(String name) {\n+            this(name, Token.Tag.DEFAULT);\n+        }\n+\n+        TokenKind(Token.Tag tag) {\n+            this(null, tag);\n+        }\n+\n+        TokenKind(String name, Token.Tag tag) {\n+            this.name = name;\n+            this.tag = tag;\n+        }\n+\n+        public String toString() {\n+            return switch (this) {\n+                case IDENTIFIER -> \"token.identifier\";\n+                case VALUE_IDENTIFIER -> \"token.value-identifier\";\n+                case CHARLITERAL -> \"token.character\";\n+                case STRINGLITERAL -> \"token.string\";\n+                case INTLITERAL -> \"token.integer\";\n+                case LONGLITERAL -> \"token.long-integer\";\n+                case FLOATLITERAL -> \"token.float\";\n+                case DOUBLELITERAL -> \"token.double\";\n+                case ERROR -> \"token.bad-symbol\";\n+                case EOF -> \"token.end-of-input\";\n+                case DOT, COMMA, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE -> \"'\" + name + \"'\";\n+                default -> name;\n+            };\n+        }\n+\n+        @Override\n+        public boolean test(TokenKind that) {\n+            return this == that;\n+        }\n+    }\n+\n+    public interface Comment {\n+\n+        enum CommentStyle {\n+            LINE,\n+            BLOCK,\n+        }\n+\n+        String text();\n+\n+        CommentStyle style();\n+    }\n+\n+    \/**\n+     * This is the class representing a javac token. Each token has several fields\n+     * that are set by the javac lexer (i.e. start\/end position, string value, etc).\n+     *\/\n+    public static class Token {\n+\n+        \/**\n+         * tags constants\n+         **\/\n+        public enum Tag {\n+            DEFAULT,\n+            NAMED,\n+            STRING,\n+            NUMERIC\n+        }\n+\n+        \/**\n+         * The token kind\n+         *\/\n+        public final TokenKind kind;\n+\n+        \/**\n+         * The start position of this token\n+         *\/\n+        public final int pos;\n+\n+        \/**\n+         * The end position of this token\n+         *\/\n+        public final int endPos;\n+\n+        \/**\n+         * Comment reader associated with this token\n+         *\/\n+        public final List<Comment> comments;\n+\n+        Token(TokenKind kind, int pos, int endPos, List<Comment> comments) {\n+            this.kind = kind;\n+            this.pos = pos;\n+            this.endPos = endPos;\n+            this.comments = comments == null ? null : List.copyOf(comments);\n+            checkKind();\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.DEFAULT) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.DEFAULT);\n+            }\n+        }\n+\n+        public String name() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public String stringVal() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int radix() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static final class NamedToken extends Token {\n+        \/**\n+         * The name of this token\n+         *\/\n+        public final String name;\n+\n+        NamedToken(TokenKind kind, int pos, int endPos, String name, List<Comment> comments) {\n+            super(kind, pos, endPos, comments);\n+            this.name = name;\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.NAMED) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.NAMED);\n+            }\n+        }\n+\n+        @Override\n+        public String name() {\n+            return name;\n+        }\n+    }\n+\n+    static class StringToken extends Token {\n+        \/**\n+         * The string value of this token\n+         *\/\n+        public final String stringVal;\n+\n+        StringToken(TokenKind kind, int pos, int endPos, String stringVal, List<Comment> comments) {\n+            super(kind, pos, endPos, comments);\n+            this.stringVal = stringVal;\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.STRING) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.STRING);\n+            }\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            return stringVal;\n+        }\n+    }\n+\n+    static final class NumericToken extends StringToken {\n+        \/**\n+         * The 'radix' value of this token\n+         *\/\n+        public final int radix;\n+\n+        NumericToken(TokenKind kind, int pos, int endPos, String stringVal, int radix, List<Comment> comments) {\n+            super(kind, pos, endPos, stringVal, comments);\n+            this.radix = radix;\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.NUMERIC) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.NUMERIC);\n+            }\n+        }\n+\n+        @Override\n+        public int radix() {\n+            return radix;\n+        }\n+    }\n+\n+    public static final Token DUMMY =\n+            new Token(TokenKind.ERROR, 0, 0, null);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Tokens.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -0,0 +1,564 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * The unicode character reader used by the javac\/javadoc lexer\/tokenizer, returns characters\n+ * one by one as contained in the input stream, handling unicode escape sequences accordingly.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b><\/p>\n+ *\/\n+sealed class UnicodeReader permits JavaBasedTokenizer {\n+    \/**\n+     * End of input character.  Used as a sentinel to denote the\n+     * character one beyond the last defined character in a\n+     * source file.\n+     *\/\n+    static final byte EOI = 0x1A;\n+\n+    \/**\n+     * Buffer containing characters from source file. May contain extraneous characters\n+     * beyond this.length.\n+     *\/\n+    private final char[] buffer;\n+\n+    \/**\n+     * Length of meaningful content in buffer.\n+     *\/\n+    private final int length;\n+\n+    \/**\n+     * Character buffer index of character currently being observed.\n+     *\/\n+    private int position;\n+\n+    \/**\n+     * Number of characters combined to provide character currently being observed. Typically\n+     * one, but may be more when combinations of surrogate pairs and unicode escape sequences\n+     * are read.\n+     *\/\n+    private int width;\n+\n+    \/**\n+     * Character currently being observed. If a surrogate pair is read then will be the high\n+     * member of the pair.\n+     *\/\n+    private char character;\n+\n+    \/**\n+     * Codepoint of character currently being observed. Typically equivalent to the character\n+     * but will have a value greater that 0xFFFF when a surrogate pair.\n+     *\/\n+    private int codepoint;\n+\n+    \/**\n+     * true if the last character was a backslash. This is used to handle the special case\n+     * when a backslash precedes an unicode escape. In that case, the second backslash\n+     * is treated as a backslash and not part of an unicode escape.\n+     *\/\n+    private boolean wasBackslash;\n+\n+    \/**\n+     * true if the last character was derived from an unicode escape sequence.\n+     *\/\n+    private boolean wasUnicodeEscape;\n+\n+    \/**\n+     * Log for error reporting.\n+     *\/\n+    private final Log log;\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param sf     scan factory.\n+     * @param array  array containing contents of source.\n+     * @param length length of meaningful content in buffer.\n+     *\/\n+    UnicodeReader(Scanner.Factory sf, char[] array, int length) {\n+        this.buffer = array;\n+        this.length = length;\n+        this.position = 0;\n+        this.width = 0;\n+        this.character = '\\0';\n+        this.codepoint = 0;\n+        this.wasBackslash = false;\n+        this.wasUnicodeEscape = false;\n+        this.log = sf.log;\n+\n+        nextCodePoint();\n+    }\n+\n+    \/**\n+     * Returns the length of the buffer. This is length of meaningful content in buffer and\n+     * not the length of the buffer array.\n+     *\n+     * @return length of the buffer.\n+     *\/\n+    protected int length() {\n+        return length;\n+    }\n+\n+    \/**\n+     * Return true if current position is within the meaningful part of the buffer.\n+     *\n+     * @return true if current position is within the meaningful part of the buffer.\n+     *\/\n+    protected boolean isAvailable() {\n+        return position < length;\n+    }\n+\n+    \/**\n+     * Fetches the next 16-bit character from the buffer and places it in this.character.\n+     *\/\n+    private void nextCodeUnit() {\n+        \/\/ Index of next character in buffer.\n+        int index = position + width;\n+\n+        \/\/ If past end of buffer.\n+        if (length <= index) {\n+            \/\/ End of file is marked with EOI.\n+            character = EOI;\n+        } else {\n+            \/\/ Next character in buffer.\n+            character = buffer[index];\n+            \/\/ Increment length of codepoint.\n+            width++;\n+        }\n+    }\n+\n+    \/**\n+     * Fetches the next 16-bit character from the buffer. If an unicode escape\n+     * is detected then converts the unicode escape to a character.\n+     *\/\n+    private void nextUnicodeInputCharacter() {\n+        \/\/ Position to next codepoint.\n+        position += width;\n+        \/\/ Codepoint has no characters yet.\n+        width = 0;\n+\n+        \/\/ Fetch next character.\n+        nextCodeUnit();\n+\n+        if (character == '\\\\' && (!wasBackslash || wasUnicodeEscape)) {\n+            \/\/ Is a backslash and may be an unicode escape.\n+            switch (unicodeEscape()) {\n+                case BACKSLASH -> {\n+                    wasUnicodeEscape = false;\n+                    wasBackslash = !wasBackslash;\n+                }\n+                case VALID_ESCAPE -> {\n+                    wasUnicodeEscape = true;\n+                    wasBackslash = character == '\\\\' && !wasBackslash;\n+                }\n+                case BROKEN_ESCAPE -> nextUnicodeInputCharacter(); \/\/skip broken unicode escapes\n+            }\n+        } else {\n+            wasBackslash = false;\n+            wasUnicodeEscape = false;\n+        }\n+\n+        \/\/ Codepoint and character match if not surrogate.\n+        codepoint = (int) character;\n+    }\n+\n+    \/**\n+     * Fetches the nextcode point from the buffer. If an unicode escape is recognized\n+     * then converts unicode escape to a character. If two characters are a surrogate pair\n+     * then converts to a codepoint.\n+     *\/\n+    private void nextCodePoint() {\n+        \/\/ Next unicode character.\n+        nextUnicodeInputCharacter();\n+\n+        \/\/ Return early if ASCII or not a surrogate pair.\n+        if (isASCII() || !Character.isHighSurrogate(character)) {\n+            return;\n+        }\n+\n+        \/\/ Capture high surrogate and position.\n+        char hi = character;\n+        int savePosition = position;\n+        int saveWidth = width;\n+\n+        \/\/ Get potential low surrogate.\n+        nextUnicodeInputCharacter();\n+        char lo = character;\n+\n+        if (Character.isLowSurrogate(lo)) {\n+            \/\/ Start codepoint at start of high surrogate.\n+            position = savePosition;\n+            width += saveWidth;\n+            \/\/ Compute codepoint.\n+            codepoint = Character.toCodePoint(hi, lo);\n+        } else {\n+            \/\/ Restore to treat high surrogate as just a character.\n+            position = savePosition;\n+            width = saveWidth;\n+            character = hi;\n+            codepoint = (int) hi;\n+            \/\/ Could potential report an error here (old code did not.)\n+        }\n+    }\n+\n+    \/**\n+     * Converts an unicode escape into a character.\n+     *\n+     * @return true if was an unicode escape.\n+     *\/\n+    private UnicodeEscapeResult unicodeEscape() {\n+        \/\/ Start of unicode escape (past backslash.)\n+        int start = position + width;\n+\n+        \/\/ Default to backslash result, unless proven otherwise.\n+        character = '\\\\';\n+        width = 1;\n+\n+        \/\/ Skip multiple 'u'.\n+        int index;\n+        for (index = start; index < length; index++) {\n+            if (buffer[index] != 'u') {\n+                break;\n+            }\n+        }\n+\n+        \/\/ Needs to have been at least one u.\n+        if (index == start) {\n+            return UnicodeEscapeResult.BACKSLASH;\n+        }\n+\n+        int code = 0;\n+\n+        for (int i = 0; i < 4; i++) {\n+            \/\/ Translate and merge digit.\n+            int digit = index < length ? Character.digit(buffer[index], 16) : -1;\n+            code = code << 4 | digit;\n+\n+            \/\/ If invalid digit.\n+            if (code < 0) {\n+                break;\n+            }\n+\n+            \/\/ On to next character.\n+            index++;\n+        }\n+\n+        \/\/ Skip digits even if error.\n+        width = index - position;\n+\n+        \/\/ If all digits are good.\n+        if (code >= 0) {\n+            character = (char) code;\n+            return UnicodeEscapeResult.VALID_ESCAPE;\n+        } else {\n+            log.error(index, Errors.IllegalUnicodeEsc);\n+            return UnicodeEscapeResult.BROKEN_ESCAPE;\n+        }\n+    }\n+\n+    private enum UnicodeEscapeResult {\n+        BACKSLASH,\n+        VALID_ESCAPE,\n+        BROKEN_ESCAPE\n+    }\n+\n+    \/**\n+     * Return the current position in the character buffer.\n+     *\n+     * @return current position in the character buffer.\n+     *\/\n+    protected int position() {\n+        return position;\n+    }\n+\n+\n+    \/**\n+     * Reset the reader to the specified position.\n+     * Warning: Do not use when previous character was an ASCII or unicode backslash.\n+     *\n+     * @param pos\n+     *\/\n+    protected void reset(int pos) {\n+        position = pos;\n+        width = 0;\n+        wasBackslash = false;\n+        wasUnicodeEscape = false;\n+        nextCodePoint();\n+    }\n+\n+    \/**\n+     * Return the current character in at the current position.\n+     *\n+     * @return current character in at the current position.\n+     *\/\n+    protected char get() {\n+        return character;\n+    }\n+\n+    \/**\n+     * Return the current codepoint in at the current position.\n+     *\n+     * @return current codepoint in at the current position.\n+     *\/\n+    protected int getCodepoint() {\n+        return codepoint;\n+    }\n+\n+    \/**\n+     * Returns true if the current codepoint is a surrogate.\n+     *\n+     * @return true if the current codepoint is a surrogate.\n+     *\/\n+    protected boolean isSurrogate() {\n+        return 0xFFFF < codepoint;\n+    }\n+\n+    \/**\n+     * Returns true if the current character is ASCII.\n+     *\n+     * @return true if the current character is ASCII.\n+     *\/\n+    protected boolean isASCII() {\n+        return character <= 0x7F;\n+    }\n+\n+    \/**\n+     * Advances the current character to the next character.\n+     *\n+     * @return next character.\n+     *\/\n+    protected char next() {\n+        nextCodePoint();\n+\n+        return character;\n+    }\n+\n+    \/**\n+     * Compare character. Returns true if a match.\n+     *\n+     * @param ch character to match.\n+     * @return true if a match.\n+     *\/\n+    protected boolean is(char ch) {\n+        return character == ch;\n+    }\n+\n+    \/**\n+     * Match one of the arguments. Returns true if a match.\n+     *\/\n+    protected boolean isOneOf(char ch1, char ch2) {\n+        return is(ch1) || is(ch2);\n+    }\n+\n+    protected boolean isOneOf(char ch1, char ch2, char ch3) {\n+        return is(ch1) || is(ch2) || is(ch3);\n+    }\n+\n+    protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {\n+        return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);\n+    }\n+\n+    \/**\n+     * Tests to see if current character is in the range of lo to hi characters (inclusive).\n+     *\n+     * @param lo lowest character in range.\n+     * @param hi highest character in range.\n+     * @return true if the current character is in range.\n+     *\/\n+    protected boolean inRange(char lo, char hi) {\n+        return lo <= character && character <= hi;\n+    }\n+\n+    \/**\n+     * Compare character and advance if a match. Returns true if a match.\n+     *\n+     * @param ch character to match.\n+     * @return true if a match.\n+     *\/\n+    protected boolean accept(char ch) {\n+        if (is(ch)) {\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Match one of the arguments and advance if a match. Returns true if a match.\n+     *\/\n+    protected boolean acceptOneOf(char ch1, char ch2) {\n+        if (isOneOf(ch1, ch2)) {\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    protected boolean acceptOneOf(char ch1, char ch2, char ch3) {\n+        if (isOneOf(ch1, ch2, ch3)) {\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Skip over all occurrences of character.\n+     *\n+     * @param ch character to accept.\n+     *\/\n+    protected void skip(char ch) {\n+        while (accept(ch)) {\n+            \/\/ next\n+        }\n+    }\n+\n+    \/**\n+     * Skip over ASCII white space characters.\n+     *\/\n+    protected void skipWhitespace() {\n+        while (acceptOneOf(' ', '\\t', '\\f')) {\n+            \/\/ next\n+        }\n+    }\n+\n+    \/**\n+     * Skip to end of line.\n+     *\/\n+    protected void skipToEOLN() {\n+        while (isAvailable()) {\n+            if (isOneOf('\\r', '\\n')) {\n+                break;\n+            }\n+\n+            next();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Compare string and advance if a match. Returns true if a match.\n+     * Warning: Do not use when previous character was a backslash\n+     * (confuses state of wasBackslash.)\n+     *\n+     * @param string string to match character for character.\n+     * @return true if a match.\n+     *\/\n+    protected boolean accept(String string) {\n+        \/\/ Quick test.\n+        if (string.length() == 0 || !is(string.charAt(0))) {\n+            return false;\n+        }\n+\n+        \/\/ Be prepared to retreat if not a match.\n+        int savedPosition = position;\n+\n+        nextCodePoint();\n+\n+        \/\/ Check each character.\n+        for (int i = 1; i < string.length(); i++) {\n+            if (!is(string.charAt(i))) {\n+                \/\/ Restart if not a match.\n+                reset(savedPosition);\n+\n+                return false;\n+            }\n+\n+            nextCodePoint();\n+        }\n+\n+        return true;\n+    }\n+\n+    \/**\n+     * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not\n+     * advance character.\n+     *\n+     * @param pos        starting position.\n+     * @param digitRadix base of number being converted.\n+     * @return value of digit.\n+     *\/\n+    protected int digit(int pos, int digitRadix) {\n+        int result;\n+\n+        \/\/ Just an ASCII digit.\n+        if (inRange('0', '9')) {\n+            \/\/ Fast common case.\n+            result = character - '0';\n+\n+            return result < digitRadix ? result : -1;\n+        }\n+\n+        \/\/ Handle other digits.\n+        result = isSurrogate() ? Character.digit(codepoint, digitRadix) :\n+                Character.digit(character, digitRadix);\n+\n+        if (result >= 0 && !isASCII()) {\n+            log.error(position(), Errors.IllegalNonasciiDigit);\n+            character = \"0123456789abcdef\".charAt(result);\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the input buffer. Unicode escape sequences are not translated.\n+     *\n+     * @return the input buffer.\n+     *\/\n+    public char[] getRawCharacters() {\n+        return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);\n+    }\n+\n+    \/**\n+     * Returns a copy of a character array subset of the input buffer.\n+     * The returned array begins at the {@code beginIndex} and\n+     * extends to the character at index {@code endIndex - 1}.\n+     * Thus the length of the substring is {@code endIndex-beginIndex}.\n+     * This behavior is like\n+     * {@code String.substring(beginIndex, endIndex)}.\n+     * Unicode escape sequences are not translated.\n+     *\n+     * @param beginIndex the beginning index, inclusive.\n+     * @param endIndex   the ending index, exclusive.\n+     * @throws ArrayIndexOutOfBoundsException if either offset is outside of the\n+     *                                        array bounds\n+     *\/\n+    public char[] getRawCharacters(int beginIndex, int endIndex) {\n+        return Arrays.copyOfRange(buffer, beginIndex, endIndex);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/UnicodeReader.java","additions":564,"deletions":0,"binary":false,"changes":564,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for parsing code models.\n+ *\/\n+package java.lang.reflect.code.parser;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * Enables code reflection for a method annotated with this annotation.\n+ *\/\n+@Target({ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CodeReflection {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/CodeReflection.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,7 @@\n+    exports java.lang.reflect.code;\n+    exports java.lang.reflect.code.analysis;\n+    exports java.lang.reflect.code.bytecode;\n+    exports java.lang.reflect.code.descriptor;\n+    exports java.lang.reflect.code.interpreter;\n+    exports java.lang.reflect.code.op;\n+    exports java.lang.reflect.code.parser;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -953,0 +954,16 @@\n+\n+    \/**\n+     * Returns the code model of provided executable element (if any).\n+     * <p>\n+     * If the executable element has a code model then it will be an instance of\n+     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n+     * Note: due to circular dependencies we cannot refer to the type explicitly.\n+     *\n+     * @implSpec The default implementation unconditionally returns an empty optional.\n+     * @param e the executable element.\n+     * @return the code model of the provided executable element (if any).\n+     * @since 99\n+     *\/\n+    default Optional<Object> getBody(ExecutableElement e) {\n+        return Optional.empty();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,401 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.dot;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Value;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class DotGenerator {\n+\n+    final Writer w;\n+\n+    interface NodeProperty {\n+        String key();\n+\n+        String value();\n+\n+        default String toText() {\n+            return key() + \"=\" + value();\n+        }\n+    }\n+\n+    static NodeProperty property(String key, String value) {\n+        return new NodeProperty() {\n+            @Override\n+            public String key() {\n+                return key;\n+            }\n+\n+            @Override\n+            public String value() {\n+                return value;\n+            }\n+        };\n+    }\n+\n+    static String properties(List<? extends NodeProperty> properties) {\n+        return properties.stream().map(NodeProperty::toText).collect(Collectors.joining(\" \", \"[\", \"]\"));\n+    }\n+\n+    static NodeProperty label(String name) {\n+        return new NodeProperty() {\n+            @Override\n+            public String key() {\n+                return \"label\";\n+            }\n+\n+            @Override\n+            public String value() {\n+                return \"\\\"\" + name + \"\\\"\";\n+            }\n+        };\n+    }\n+\n+    enum Shape implements NodeProperty {\n+        BOX(\"box\"),\n+        ELLIPSE(\"ellipse\"),\n+        HEXAGONE(\"hexagon\"),\n+        INVERTED_TRAPEZIUM(\"invtrapezium\");\n+\n+        final String value;\n+\n+        Shape(String value) {\n+            this.value = value;\n+        }\n+\n+\n+        @Override\n+        public String key() {\n+            return \"shape\";\n+        }\n+\n+        @Override\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private DotGenerator(Writer w) {\n+        this.w = w;\n+    }\n+\n+    void digraph() {\n+        write(\"digraph G {\\n\");\n+    }\n+\n+    void node(Object o, String properties) {\n+        write(\"%s %s;\\n\", System.identityHashCode(o), properties);\n+    }\n+\n+    void node(Object o, NodeProperty... properties) {\n+        node(o, List.of(properties));\n+    }\n+\n+    void node(Object o, List<? extends NodeProperty> properties) {\n+        node(o, properties(properties));\n+    }\n+\n+    void edge(Object from, Object to) {\n+        write(\"%s -> %s;\\n\", System.identityHashCode(from), System.identityHashCode(to));\n+    }\n+\n+    void write(String format, Object... args) {\n+        write(w, format, args);\n+    }\n+\n+    void end() {\n+        write(w, \"}\\n\");\n+        try {\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    static void write(Writer w, String format, Object... args) {\n+        try {\n+            w.write(String.format(format, args));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Generates the representation tree for a given operation.\n+     *\n+     * @param op the operation\n+     * @param w  the writer to write the sr.dot file\n+     *\/\n+    public static void representationTree(Op op, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        op.traverse(null, (t, codeElement) -> switch (codeElement) {\n+            case Body b -> {\n+                dg.node(b, label(\"\"), Shape.HEXAGONE, property(\"style\", \"filled\"));\n+\n+                dg.edge(b.parentOp(), b);\n+\n+                yield null;\n+            }\n+            case Block b -> {\n+                dg.node(b, label(\"\"), Shape.BOX);\n+\n+                dg.edge(b.parentBody(), b);\n+\n+                yield null;\n+            }\n+            case Op o -> {\n+                List<NodeProperty> ps;\n+                if (o instanceof Op.Terminating) {\n+                    ps = List.of(label(o.opName()), Shape.ELLIPSE, property(\"style\", \"filled\"));\n+                } else {\n+                    ps = List.of(label(o.opName()), Shape.ELLIPSE);\n+                }\n+                dg.node(o, ps);\n+                if (o.parentBlock() != null) {\n+                    dg.edge(o.parentBlock(), o);\n+                }\n+\n+                yield null;\n+            }\n+        });\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body graph (CFG) for a given body.\n+     *\n+     * @param body the body\n+     * @param w    the writer to write the sr.dot file\n+     *\/\n+    public static void bodyGraph(Body body, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        Block eb = body.entryBlock();\n+        Deque<Block> stack = new ArrayDeque<>();\n+        Set<Block> visited = new HashSet<>();\n+        stack.push(eb);\n+        while (!stack.isEmpty()) {\n+            Block b = stack.pop();\n+            if (!visited.add(b)) {\n+                continue;\n+            }\n+\n+            dg.node(b, label(\"\"), Shape.BOX);\n+\n+            List<Block.Reference> successors = b.terminatingOp().successors();\n+            for (Block.Reference s : successors) {\n+                dg.edge(b, s.targetBlock());\n+\n+                stack.push(s.targetBlock());\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body dominator tree for a given body.\n+     *\n+     * @param body the body\n+     * @param w    the writer to write the sr.dot file\n+     *\/\n+    public static void bodyDominatorTree(Body body, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        Block eb = body.entryBlock();\n+        Map<Block, Block> idoms = body.immediateDominators();\n+\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block child = e.getKey();\n+            Block parent = e.getValue();\n+\n+            dg.node(child, label(\"\"), Shape.BOX);\n+\n+            if (child != eb) {\n+                dg.edge(parent, child);\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body dominator tree for a given body, with the dominance\n+     * frontier set presented for each block.\n+     * <p>\n+     * The dominance frontier of a block, b say, is the set of blocks where the b's\n+     * dominance stops.\n+     *\n+     * @param body the body\n+     * @param w    the writer to write the sr.dot file\n+     *\/\n+    public static void bodyDominanceFrontierTree(Body body, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        Block eb = body.entryBlock();\n+        Map<Block, Block> idoms = body.immediateDominators();\n+        Map<Block, Set<Block>> df = body.dominanceFrontier();\n+\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block child = e.getKey();\n+            Block parent = e.getValue();\n+\n+            Set<Block> frontiers = df.get(child);\n+\n+            String s = frontiers == null || frontiers.isEmpty()\n+                    ? \"[-]\"\n+                    : frontiers.stream().map(b -> String.valueOf(b.index())).collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            dg.node(child, label(\"\" + \"\\n\" + s), Shape.BOX);\n+\n+            if (child != eb) {\n+                dg.edge(parent, child);\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body data dependence dag for a given body.\n+     *\n+     * @param body  the body\n+     * @param names a map of block arguments to names\n+     * @param w     the writer to write the sr.dot file\n+     *\/\n+    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names, Writer w) {\n+        dataDependenceGraph(body, names, false, w);\n+    }\n+\n+    \/**\n+     * Generates a body data dependence graph for a given body.\n+     *\n+     * @param body              the body\n+     * @param names             a map of block arguments to names\n+     * @param traverseblockArgs true if a graph is produced, otherwise a DAG\n+     * @param w                 the writer to write the sr.dot file\n+     *\/\n+    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names,\n+                                           boolean traverseblockArgs, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        record Edge(Value from, Value to) {\n+        }\n+\n+        Set<Value> visted = new HashSet<>();\n+        Set<Edge> vistedEdges = new HashSet<>();\n+        Deque<Value> stack = new ArrayDeque<>(getValues(body));\n+        while (!stack.isEmpty()) {\n+            Value v = stack.pop();\n+            if (!visted.add(v)) {\n+                continue;\n+            }\n+\n+            if (v instanceof Op.Result or) {\n+                if (!or.op().operands().isEmpty() || !(or.op() instanceof Op.Terminating)) {\n+                    dg.node(v, label(or.op().opName()), Shape.INVERTED_TRAPEZIUM);\n+                }\n+            } else if (v instanceof Block.Parameter ba) {\n+                String n = names.get(v);\n+                if (n != null) {\n+                    dg.node(v, label(n), Shape.INVERTED_TRAPEZIUM,\n+                            property(\"style\", \"filled\"));\n+                } else {\n+                    Block b = ba.declaringBlock();\n+                    dg.node(v, label(\"(\" + b.parameters().indexOf(ba) + \")\"), Shape.BOX,\n+                            property(\"style\", \"filled\"));\n+                }\n+            }\n+\n+            Set<Op.Result> uses = v.uses();\n+            stack.addAll(uses);\n+            for (Op.Result use : uses) {\n+                if (traverseblockArgs && use.op() instanceof Op.Terminating) {\n+                    for (Block.Reference s : use.op().successors()) {\n+                        int i = s.arguments().indexOf(v);\n+                        if (i != -1) {\n+                            Block.Parameter ba = s.targetBlock().parameters().get(i);\n+\n+                            if (vistedEdges.add(new Edge(v, ba))) {\n+                                dg.edge(v, ba);\n+                            }\n+                            stack.add(ba);\n+                        }\n+                    }\n+                }\n+\n+                if (use.op().operands().contains(v)) {\n+                    if (vistedEdges.add(new Edge(v, use))) {\n+                        dg.edge(v, use);\n+                    }\n+                }\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    static List<Value> getValues(Body r) {\n+        return r.traverse(new ArrayList<>(), (values, codeElement) -> switch (codeElement) {\n+            case Block b -> {\n+                values.addAll(b.parameters());\n+                yield values;\n+            }\n+            case Op o -> {\n+                values.add(o.result());\n+                yield values;\n+            }\n+            default -> values;\n+        });\n+    }\n+\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotGenerator.java","additions":401,"deletions":0,"binary":false,"changes":401,"status":"added"},{"patch":"@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.dot;\n+\n+import jdk.code.tools.renderer.CommonRenderer;\n+\n+import java.io.Writer;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.util.*;\n+\n+\/**\n+ * Created by gfrost\n+ * http:\/\/www.graphviz.org\/Documentation\/dotguide.pdf\n+ *\/\n+public class DotRenderer extends CommonRenderer<DotRenderer> {\n+    public DotRenderer() {\n+        super();\n+    }\n+\n+    static String sysident(Object o) {\n+        return Integer.toString(System.identityHashCode(o));\n+    }\n+\n+    DotRenderer end() {\n+        return out().cbrace().nl();\n+    }\n+\n+    public DotRenderer start(String name) {\n+        return append(\"digraph\").space().append(name).obrace().in().nl();\n+    }\n+\n+    public DotRenderer rankdir(String s) {\n+        return append(\"rankdir\").equal().append(s).semicolon().nl();\n+    }\n+\n+    public DotRenderer concentrate() {\n+        return append(\"concentrate=true\").nl();\n+    }\n+\n+    public DotRenderer newrank() {\n+        return append(\"newrank=true\").nl();\n+    }\n+\n+    public DotRenderer edgesFirst() {\n+        return append(\"outputorder=edgesfirst\").nl();\n+    }\n+\n+\n+    public <T extends CommonRenderer<T>> DotRenderer graph(NestedRendererSAM<GraphRenderer> nb) {\n+\n+        nb.build(new GraphRenderer(this)).end();\n+        return self();\n+    }\n+\n+\n+    public static class GraphRenderer extends CommonRenderer<GraphRenderer> {\n+        public GraphRenderer(DotRenderer dotRenderer) {\n+            super(dotRenderer);\n+        }\n+\n+        GraphRenderer end() {\n+            return self();\n+        }\n+\n+        public GraphRenderer node(String name, String shape, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, shape)).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer node(String name, String shape) {\n+            return node(name, shape, (n) -> n);\n+        }\n+\n+        public GraphRenderer record(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"record\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer record(String name) {\n+            return record(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer ellipse(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"ellipse\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer ellipse(String name) {\n+            return ellipse(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer ellipse(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"ellipse\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer ellipse(Object o) {\n+            return ellipse(o, (n) -> n);\n+        }\n+\n+        public GraphRenderer circle(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"circle\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer circle(String name) {\n+            return circle(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer invertedtrapezium(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"invtrapezium\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer invertedtrapezium(String name) {\n+            return invertedtrapezium(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer invertedtrapezium(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"invtrapezium\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer invertedtrapezium(Object o) {\n+            return invertedtrapezium(o, (n) -> n);\n+        }\n+\n+        public GraphRenderer box(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"box\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer box(String name) {\n+            return box(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer box(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"box\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer box(Object o) {\n+            return box(o, (n) -> n);\n+        }\n+\n+        public GraphRenderer hexagon(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"hexagon\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer hexagon(String name) {\n+            return hexagon(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer hexagon(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"hexagon\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer hexagon(Object o) {\n+            return hexagon(o, (n) -> n);\n+        }\n+\n+        public static class NodeRenderer extends CommonRenderer<NodeRenderer> {\n+            NodeRenderer(GraphRenderer graphRenderer, String name, String shape) {\n+                super(graphRenderer);\n+                append(name).osbrace().append(\"shape\").equal().oquot().append(shape).cquot().space();\n+                \/\/ append(name).osbrace().append(\"shape\").equal().append(shape).space();\n+                \/\/   append(name).osbrace();\/\/.append(\"shape\").equal().append(shape).space();\n+            }\n+\n+            public NodeRenderer end() {\n+                return csbrace().semicolon().nl();\n+            }\n+\n+            NodeRenderer label(String label, NestedRendererSAM<LabelRenderer> sam) {\n+                LabelRenderer renderer = new LabelRenderer(this, label);\n+                sam.build(renderer).end();\n+                return self();\n+            }\n+\n+            NodeRenderer label(NestedRendererSAM<LabelRenderer> sam) {\n+                LabelRenderer renderer = new LabelRenderer(this, \"\");\n+                sam.build(renderer).end();\n+                return self();\n+            }\n+\n+            NodeRenderer label(String label) {\n+                return label(label, (l) -> l);\n+            }\n+\n+\n+            public NodeRenderer color(String color) {\n+                return append(\"color\").equal().oquot().append(color).cquot().space();\n+            }\n+\n+            public NodeRenderer style(String style) {\n+                return append(\"style\").equal().oquot().append(style).cquot().space();\n+            }\n+\n+            public static class LabelRenderer extends CommonRenderer<LabelRenderer> {\n+                int count = 0;\n+\n+                LabelRenderer(NodeRenderer nodeRenderer, String label) {\n+                    super(nodeRenderer);\n+                    append(\"label\").equal().oquot().append(label);\n+                }\n+\n+                public LabelRenderer end() {\n+                    return cquot().space();\n+                }\n+\n+                LabelRenderer port(String label, String text) {\n+                    if (count > 0) {\n+                        pipe();\n+                    }\n+                    count++;\n+                    return lt().append(label).gt().append(text);\n+                }\n+\n+                LabelRenderer label(String label, String text) {\n+                    if (count > 0) {\n+                        pipe();\n+                    }\n+                    count++;\n+                    return append(text);\n+                }\n+\n+                LabelRenderer box(NestedRendererSAM<BoxRenderer> sam) {\n+                    sam.build(new BoxRenderer(this)).end();\n+                    count = 0;\n+                    return self();\n+                }\n+\n+                static class BoxRenderer extends CommonRenderer<BoxRenderer> {\n+                    int count = 0;\n+\n+                    BoxRenderer(LabelRenderer labelRenderer) {\n+                        super(labelRenderer);\n+                        pipe().obrace();\n+                    }\n+\n+                    BoxRenderer(BoxRenderer boxRenderer) {\n+                        super(boxRenderer);\n+                        pipe().obrace();\n+                    }\n+\n+                    BoxRenderer end() {\n+                        return cbrace().pipe();\n+                    }\n+\n+                    BoxRenderer port(String label, String text) {\n+                        if (count > 0) {\n+                            pipe();\n+                        }\n+                        count++;\n+                        return lt().append(label).gt().append(text);\n+                    }\n+\n+                    BoxRenderer label(String text) {\n+                        if (count > 0) {\n+                            pipe();\n+                        }\n+                        count++;\n+                        return append(text);\n+                    }\n+\n+                    BoxRenderer box(NestedRendererSAM<BoxRenderer> sam) {\n+                        sam.build(new BoxRenderer(this)).end();\n+                        count = 0;\n+                        return self();\n+                    }\n+                }\n+            }\n+        }\n+\n+        public GraphRenderer edge(String from, String to, NestedRendererSAM<EdgeRenderer> sam) {\n+            sam.build(new EdgeRenderer(this, from, to)).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer edge(String from, String to) {\n+            return edge(from, to, (n) -> n);\n+        }\n+\n+        public GraphRenderer edge(Object from, Object to, NestedRendererSAM<EdgeRenderer> sam) {\n+            sam.build(new EdgeRenderer(this, sysident(from), sysident(to))).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer edge(Object from, Object to) {\n+            return edge(from, to, (n) -> n);\n+        }\n+\n+        public static class EdgeRenderer extends CommonRenderer<EdgeRenderer> {\n+            EdgeRenderer(GraphRenderer graphRenderer, String from, String to) {\n+                super(graphRenderer);\n+                append(from).rarrow().append(to).osbrace();\n+            }\n+\n+            public EdgeRenderer end() {\n+                return csbrace().semicolon().nl().self();\n+            }\n+\n+            EdgeRenderer label(String label, NestedRendererSAM<LabelRenderer> sam) {\n+                LabelRenderer renderer = new LabelRenderer(this, label);\n+                sam.build(renderer).end();\n+                return self();\n+            }\n+\n+\n+            EdgeRenderer label(String label) {\n+                return label(label, (l) -> l);\n+            }\n+\n+            public static class LabelRenderer extends CommonRenderer<LabelRenderer> {\n+\n+                LabelRenderer(EdgeRenderer edgeRenderer, String label) {\n+                    super(edgeRenderer);\n+                    append(\"label\").equal().oquot().append(label);\n+                }\n+\n+                public LabelRenderer end() {\n+                    return cquot().space();\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    public static void representationTree(Op op, Writer w) {\n+        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n+            op.traverse(null, (t, codeElement) -> switch (codeElement) {\n+                case Body b -> {\n+                    g.hexagon(b, (n) -> n.label(\"\").style(\"filled\"));\n+                    g.edge(b.parentOp(), b);\n+                    yield null;\n+                }\n+                case Block b -> {\n+                    g.box(b, (n) -> n.label(\"\"));\n+                    g.edge(b.parentBody(), b);\n+                    yield null;\n+                }\n+                case Op o -> {\n+                    if (o instanceof Op.Terminating) {\n+                        g.ellipse(o, (n) -> n.label(o.opName()).style(\"filled\"));\n+                    } else {\n+                        g.ellipse(o, (n) -> n.label(o.opName()));\n+                    }\n+                    if (o.parentBlock() != null) {\n+                        g.edge(o.parentBlock(), o);\n+                    }\n+                    yield null;\n+                }\n+            });\n+            return g;\n+        }).end();\n+\n+    }\n+\n+    public static void bodyGraph(Body body, Writer w) {\n+        Block eb = body.entryBlock();\n+        Deque<Block> stack = new ArrayDeque<>();\n+        Set<Block> visited = new HashSet<>();\n+        stack.push(eb);\n+        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n+            while (!stack.isEmpty()) {\n+                Block b = stack.pop();\n+                if (!visited.add(b)) {\n+                    continue;\n+                }\n+\n+                g.box(b, (box) -> box.label(\"\"));\n+\n+                List<Block.Reference> successors = b.terminatingOp().successors();\n+                for (Block.Reference s : successors) {\n+                    g.edge(b, s.targetBlock());\n+\n+                    stack.push(s.targetBlock());\n+                }\n+            }\n+            return g;\n+        }).end();\n+\n+    }\n+\n+    public static void bodyDominatorTree(Body body, Writer w) {\n+        Block eb = body.entryBlock();\n+        Map<Block, Block> idoms = body.immediateDominators();\n+\n+        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n+            for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+                Block child = e.getKey();\n+                Block parent = e.getValue();\n+\n+                g.box(child, (b) -> b.label(\"\"));\n+\n+                if (child != eb) {\n+                    g.edge(parent, child);\n+                }\n+            }\n+            return g;\n+        }).end();\n+    }\n+\n+    \/**\n+     * Generates a body data dependence graph for a given body.\n+     *\n+     * @param body              the body\n+     * @param names             a map of block arguments to names\n+     * @param traverseblockArgs true if a graph is produced, otherwise a DAG\n+     * @param w                 the writer to write the sr.dot file\n+     *\/\n+    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names,\n+                                           boolean traverseblockArgs, Writer w) {\n+\n+\n+        record Edge(Value from, Value to) {\n+        }\n+        new DotRenderer().writer(w).start(\"SR\").graph((g) -> {\n+            Set<Value> visted = new HashSet<>();\n+            Set<Edge> vistedEdges = new HashSet<>();\n+            Deque<Value> stack = new ArrayDeque<>(getValues(body));\n+            while (!stack.isEmpty()) {\n+                Value v = stack.pop();\n+                if (!visted.add(v)) {\n+                    continue;\n+                }\n+\n+                if (v instanceof Op.Result or) {\n+                    if (!or.op().operands().isEmpty() || !(or.op() instanceof Op.Terminating)) {\n+                        g.invertedtrapezium(v, (node) -> node.label(or.op().opName()));\n+                    }\n+                } else if (v instanceof Block.Parameter ba) {\n+                    String n = names.get(v);\n+                    if (n != null) {\n+                        g.invertedtrapezium(v, (node) -> node.label(n).style(\"filled\"));\n+                    } else {\n+                        Block b = ba.declaringBlock();\n+\n+                        g.box(v, (node) -> node.label(\"(\" + b.parameters().indexOf(ba) + \")\").style(\"filled\"));\n+                    }\n+                }\n+\n+                Set<Op.Result> uses = v.uses();\n+                stack.addAll(uses);\n+                for (Op.Result use : uses) {\n+                    if (traverseblockArgs && use.op() instanceof Op.Terminating) {\n+                        for (Block.Reference s : use.op().successors()) {\n+                            int i = s.arguments().indexOf(v);\n+                            if (i != -1) {\n+                                Block.Parameter ba = s.targetBlock().parameters().get(i);\n+\n+                                if (vistedEdges.add(new Edge(v, ba))) {\n+                                    g.edge(v, ba);\n+                                }\n+                                stack.add(ba);\n+                            }\n+                        }\n+                    }\n+\n+                    if (use.op().operands().contains(v)) {\n+                        if (vistedEdges.add(new Edge(v, use))) {\n+                            g.edge(v, use);\n+                        }\n+                    }\n+                }\n+            }\n+            return g;\n+        }).end();\n+    }\n+\n+    private static List<Value> getValues(Body r) {\n+        return r.traverse(new ArrayList<>(), (values, codeElement) -> switch (codeElement) {\n+            case Block b -> {\n+                values.addAll(b.parameters());\n+                yield values;\n+            }\n+            case Op op -> {\n+                values.add(op.result());\n+                yield values;\n+            }\n+            default -> values;\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotRenderer.java","additions":512,"deletions":0,"binary":false,"changes":512,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.dot;\n+\n+import jdk.code.tools.renderer.ProcessRunner;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Created by gfrost\n+ * http:\/\/graphviz.org\/Documentation.php\n+ * http:\/\/graphviz.org\/content\/arrow-shapes\n+ * http:\/\/graphviz.org\/content\/rootNode-shapes\n+ * http:\/\/graphviz.org\/content\/attrs\n+ * http:\/\/www.graphviz.org\/Documentation\/dotguide.pdf\n+ *\/\n+public final class DotViewer {\n+    private DotViewer() {\n+    }\n+\n+    \/\/ Look at Path.of() ..... ;)  I think I may have reimplemented it\n+    static String[] svgViewers = new String[]{\n+            System.getenv(\"SVG_VIEWER_PATH\"),\n+            System.getProperty(\"SVG_VIEWER_PATH\"),\n+            \"\/usr\/bin\/google-chrome\",\n+            \"\/snap\/chromium\/1466\/usr\/lib\/chromium-browser\/chrome\",\n+            \"\/usr\/bin\/gpicview\",\n+            \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\",\n+            \"\/usr\/bin\/xdg-open\"\n+    };\n+    static String[] dotLocations = new String[]{\n+            System.getenv(\"DOT_PATH\"),\n+            System.getProperty(\"DOT_PATH\"),\n+            \"\/usr\/bin\/dot\",\n+            \"\/usr\/local\/bin\/dot\" \/\/ mac\n+    };\n+\n+    static String getLocation(String[] possibles) {\n+        for (String s : possibles) {\n+            if (s != null && !s.equals(\"\")) {\n+                File file = new File(s);\n+                if (file.exists() && file.canExecute()) {\n+                    return s;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static void view(String dotSource) {\n+\n+        String dot = getLocation(dotLocations);\n+        System.out.println(dotSource);\n+        String svgViewer = getLocation(svgViewers);\n+\n+        if (dot != null && svgViewer != null) {\n+            try {\n+                File tempFile = File.createTempFile(\"ast\", \".svg\");\n+                ProcessRunner.run(dot)\n+                        .opt(\"-Tsvg\")\n+                        .opt(\"-o\").file(tempFile)\n+                        .temp(\"ast\", \"dot\", dotSource)\n+                        .go(false);\n+                ProcessRunner.run(svgViewer)\n+                        .file(tempFile)\n+                        .go(false);\n+\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();\n+            }\n+        }\n+\n+    }\n+\n+    public static void viewNoWait(String dotSource) {\n+        String dot = getLocation(dotLocations);\n+        String svgViewer = getLocation(svgViewers);\n+\n+        if (dot != null && svgViewer != null) {\n+            try {\n+                File tempDotFile = File.createTempFile(\"ast\", \"dot\");\n+                FileWriter tempDotFileWriter = new FileWriter(tempDotFile);\n+                tempDotFileWriter.append(dotSource);\n+                tempDotFileWriter.close();\n+                File tempPngFile = File.createTempFile(\"ast\", \"svg\");\n+                List<String> dotCommand = new ArrayList<>();\n+                dotCommand.add(dot);\n+                dotCommand.add(\"-Tsvg\");\n+                dotCommand.add(\"-o\");\n+                dotCommand.add(tempPngFile.getAbsolutePath());\n+                dotCommand.add(tempDotFile.getAbsolutePath());\n+\n+                ProcessBuilder dotBuilder = new ProcessBuilder(dotCommand);\n+                Process dotProcess = dotBuilder.start();\n+                dotProcess.waitFor();\n+\n+                List<String> fehCommand = new ArrayList<>();\n+                fehCommand.add(svgViewer);\n+                \/\/  fehCommand.add(\"-t\");\n+                fehCommand.add(tempPngFile.getAbsolutePath());\n+                ProcessBuilder fehBuilder = new ProcessBuilder(fehCommand);\n+                Process fehProcess = fehBuilder.start();\n+\n+            } catch (IOException | InterruptedException ioe) {\n+                ioe.printStackTrace();\n+            }\n+        } else if (dot == null) {\n+            System.out.println(\"Sorry can't find \/usr\/bin\/dot (sudo apt-get install graphviz)\");\n+        } else {\n+            System.out.println(\"Sorry can't find a suitable SVG Viewer\");\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        \/\/ https:\/\/renenyffenegger.ch\/notes\/tools\/Graphviz\/examples\/index\n+\n+        StringWriter dotw = new StringWriter();\n+        \/\/ http:\/\/magjac.com\/graphviz-visual-editor\/\n+        new DotRenderer().writer(dotw).start(\"mine\").graph(\n+                (g) -> g\n+                        .box(\"A\",\n+                                (box) -> box\n+                                        .label(\"Snarlywang\")\n+                                        .color(\"lightyellow\")\n+                                        .style(\"filled\")\n+                        )\n+                        .record(\"B\",\n+                                (record) -> record\n+                                        .color(\"lightgreen\")\n+                                        .style(\"filled\")\n+                                        .label((label) -> label\n+                                                .port(\"left\", \"left\")\n+                                                .box(\n+                                                        (vertical) -> vertical\n+                                                                .port(\"top\", \"top\")\n+                                                                .label(\"center\")\n+                                                                .port(\"bottom\", \"bottom\")\n+                                                )\n+                                                .port(\"right\", \"right\")\n+                                        )\n+                        )\n+                        .edge(\"A\", \"B:top:nw\", (e) -> e.label(\"1\"))\n+                        .edge(\"A\", \"B:bottom:se\", (e) -> e.label(\"2\"))\n+                        .edge(\"A\", \"B:left:w\", (e) -> e.label(\"3\"))\n+                        .edge(\"A\", \"B:right:e\", (e) -> e.label(\"4\"))\n+        ).end();\n+        DotViewer.view(dotw.toString());\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotViewer.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.StringWriter;\n+\n+public final class CStyleRenderer extends CommonRenderer<CStyleRenderer> {\n+    public CStyleRenderer() {\n+        super();\n+    }\n+\n+    public CStyleRenderer func(String identifier, TextRenderer.NestedRendererSAM<CStyleRenderer> args,\n+                               TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n+        return keyword(\"func\").space().identifier(identifier).parenthesized(args).braced(body).nl();\n+    }\n+\n+    public CStyleRenderer forLoop(TextRenderer.NestedRendererSAM<CStyleRenderer> init, TextRenderer.NestedRendererSAM<CStyleRenderer> cond,\n+                                  TextRenderer.NestedRendererSAM<CStyleRenderer> mutator, TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n+        return forKeyword().oparen().nest(init).semicolon().space().nest(cond).semicolon().space().\n+                nest(mutator).cparen().braced(body).nl();\n+    }\n+\n+    public CStyleRenderer whileLoop(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n+        return whileKeyword().oparen().nest(cond).cparen().braced(body).nl();\n+    }\n+\n+    public CStyleRenderer ifCondRaw(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody) {\n+        return ifKeyword().oparen().nest(cond).cparen().braced(thenBody);\n+    }\n+\n+    public CStyleRenderer ifCond(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody) {\n+        return ifCondRaw(cond, thenBody).nl();\n+    }\n+\n+    public CStyleRenderer ifCond(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody,\n+                                 TextRenderer.NestedRendererSAM<CStyleRenderer> elseBody) {\n+        return ifCondRaw(cond, thenBody).elseKeyword().braced(elseBody).nl();\n+    }\n+\n+    public CStyleRenderer var(Class<?> clazz, String name) {\n+        return type(clazz.getName()).space().identifier(name);\n+    }\n+\n+    public CStyleRenderer assign(String identifier) {\n+        return identifier(identifier).equal();\n+    }\n+\n+    static public void main(String[] args) {\n+        StringWriter writer = new StringWriter();\n+        CStyleRenderer renderer = new CStyleRenderer().writer(writer).colorize();\n+        renderer.lineComment(\"A new function\");\n+        renderer.func(\"funcName\",\n+                (as) -> as.var(int.class, \"name\").comma().space()\n+                        .var(int.class, \"name2\"),\n+                (fb) -> fb.lineComment(\"Inside body of func\")\n+                        .append(\"here;\\nis;\\nsome text\").semicolon().nl()\n+                        .forLoop(\n+                                (in) -> in.var(int.class, \"a\").equal().decLiteral(0),\n+                                (cc) -> cc.identifier(\"a\").op(\"<\").decLiteral(10),\n+                                (mu) -> mu.assign(\"a\").identifier(\"a\").op(\"+\").decLiteral(1),\n+                                (lb) -> lb.lineComment(\"in loop\")\n+                                        .ifCond(\n+                                                (cc) -> cc.identifier(\"a\").op(\">\").decLiteral(2),\n+                                                (th) -> th.lineComment(\"positive\"),\n+                                                (el) -> el.lineComment(\"not so much \")\n+                                        )\n+                        )\n+                        .nl()\n+        ).nl();\n+        System.out.println(writer);\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/CStyleRenderer.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public class CommonRenderer<T extends CommonRenderer<T>> extends TextRenderer<T> {\n+\n+    public CommonRenderer() {\n+    }\n+\n+    public CommonRenderer(TextRenderer<?> renderer) {\n+        super(renderer);\n+    }\n+\n+    public T semicolon() {\n+        return op(\";\");\n+    }\n+\n+    public T comma() {\n+        return op(\",\");\n+    }\n+\n+    public T commaSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T commaSeparator() {\n+        if (!first()) {\n+            comma().space();\n+        }\n+        return self();\n+    }\n+\n+    public T commaSpaceSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T commaSpaceSeparator() {\n+        if (!first()) {\n+            comma().space();\n+        }\n+        return self();\n+    }\n+\n+    public T spaceSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T spaceSeparator() {\n+        if (!first()) {\n+            space();\n+        }\n+        return self();\n+    }\n+\n+    public T newlineSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T newlineSeparator() {\n+        if (!first()) {\n+            nl();\n+        }\n+        return self();\n+    }\n+\n+    public T semicolonSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T semicolonSeparator() {\n+        if (!first()) {\n+            semicolon();\n+        }\n+        return self();\n+    }\n+\n+    public T semicolonSpaceSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T semicolonSpaceSeparator() {\n+        if (!first()) {\n+            semicolon().space();\n+        }\n+        return self();\n+    }\n+\n+    public T dot() {\n+        return op(\".\");\n+    }\n+\n+\n+    public T equal() {\n+        return op(\"=\");\n+    }\n+\n+\n+    public T plusplus() {\n+        return op(\"++\");\n+    }\n+\n+\n+    public T minusminus() {\n+        return op(\"--\");\n+    }\n+\n+    public T lineComment(String line) {\n+        return op(\"\/\/\").space().comment(line).nl();\n+    }\n+\n+\n+    public T blockComment(String block) {\n+        return op(\"\/*\").nl().comment(block).nl().op(\"*\/\").nl();\n+    }\n+\n+    public T newKeyword() {\n+        return keyword(\"new\");\n+    }\n+\n+\n+    public T staticKeyword() {\n+        return keyword(\"static\");\n+    }\n+\n+\n+    public T constKeyword() {\n+        return keyword(\"const\");\n+    }\n+\n+    public T ifKeyword() {\n+        return keyword(\"if\");\n+\n+    }\n+\n+\n+    public T whileKeyword() {\n+        return keyword(\"while\");\n+    }\n+\n+\n+    public T breakKeyword() {\n+        return keyword(\"break\");\n+\n+    }\n+\n+\n+    public T continueKeyword() {\n+        return keyword(\"continue\");\n+    }\n+\n+\n+    public T query() {\n+        return op(\"?\");\n+    }\n+\n+\n+    public T colon() {\n+        return op(\":\");\n+    }\n+\n+\n+    public T nullKeyword() {\n+        return keyword(\"null\");\n+\n+    }\n+\n+\n+    public T elseKeyword() {\n+        return keyword(\"else\");\n+    }\n+\n+\n+    public T returnKeyword() {\n+        return keyword(\"return\");\n+    }\n+\n+\n+    public T switchKeyword() {\n+        return keyword(\"switch\");\n+    }\n+\n+\n+    public T caseKeyword() {\n+        return keyword(\"case\");\n+    }\n+\n+\n+    public T defaultKeyword() {\n+        return keyword(\"default\");\n+    }\n+\n+    public T doKeyword() {\n+        return keyword(\"do\");\n+    }\n+\n+    public T forKeyword() {\n+        return keyword(\"for\");\n+    }\n+\n+    public T ampersand() {\n+        return op(\"&\");\n+    }\n+\n+    public T braced(NestedRendererSAM<T> nb) {\n+        return nb.build(obrace().nl().in()).out().cbrace().self();\n+    }\n+\n+    public T osbrace() {\n+        return open(\"[\");\n+    }\n+\n+\n+    public T csbrace() {\n+        return close(\"]\");\n+    }\n+\n+\n+    public T parenthesized(NestedRendererSAM<T> nb) {\n+        return nb.build(oparen().in()).out().cparen().self();\n+    }\n+\n+    public T underscore() {\n+        return op(\"_\");\n+    }\n+\n+    public T oparen() {\n+        return open(\"(\");\n+    }\n+\n+    public T cparen() {\n+        return close(\")\");\n+    }\n+\n+    public T obrace() {\n+        return open(\"{\");\n+    }\n+\n+    public T cbrace() {\n+        return close(\"}\");\n+    }\n+\n+    public T at() {\n+        return op(\"@\").self();\n+    }\n+\n+    public T caret() {\n+        return op(\"^\").self();\n+    }\n+\n+    public T percent() {\n+        return op(\"%\").self();\n+    }\n+\n+    public T pipe() {\n+        return op(\"|\").self();\n+    }\n+\n+    public T rarrow() {\n+        return op(\"->\").self();\n+    }\n+\n+    public T larrow() {\n+        return op(\"<-\").self();\n+    }\n+\n+    public T lt() {\n+        return op(\"<\").self();\n+    }\n+\n+    public T gt() {\n+        return op(\">\").self();\n+    }\n+\n+    public T asterisk() {\n+        return op(\"*\").self();\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/CommonRenderer.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public final class Diff {\n+    private Diff() {\n+    }\n+\n+    public static void annotate(File file, int line, int col, String msg) {\n+        List<String> lines = getLines(file);\n+        for (int i = Math.max(line - 2, 0); i < (line - 1); i++) {\n+            System.out.printf(\"    %2d:%s\\n\", i + 1, lines.get(i));\n+        }\n+        String text = lines.get(line - 1);\n+        System.out.printf(\" -> %2d:%s\\n      \", line, text);\n+        for (int i = 0; i < col; i++) {\n+            System.out.print(\" \");\n+        }\n+        System.out.println(\"^ \" + msg);\n+        for (int i = line; i < Math.min(line + 2, lines.size() - 1); i++) {\n+            System.out.printf(\"    %2d:%s\\n\", i + 1, lines.get(i));\n+        }\n+\n+    }\n+\n+    static List<String> getLines(File file) {\n+        List<String> lines = new ArrayList<>();\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n+            for (String line = br.readLine(); line != null; line = br.readLine()) {\n+                lines.add(line);\n+            }\n+            br.close();\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return lines;\n+    }\n+\n+    public static class DiffResult {\n+        String lhs;\n+        String rhs;\n+        public String result;\n+        public int exitStatus;\n+\n+        public DiffResult(String lhs, String rhs, String result, int exitStatus) {\n+            this.lhs = lhs;\n+            this.rhs = rhs;\n+            this.result = result;\n+            this.exitStatus = exitStatus;\n+        }\n+    }\n+\n+    public static DiffResult diff(String lhs, String rhs, int width) {\n+        try {\n+            File lhsFile = File.createTempFile(\"lhs\", \"txt\");\n+            FileWriter lhsw = new FileWriter(lhsFile);\n+            lhsw.append(lhs);\n+            lhsw.close();\n+            File rhsFile = File.createTempFile(\"rhs\", \"txt\");\n+            FileWriter rhsw = new FileWriter(rhsFile);\n+            rhsw.append(rhs);\n+            rhsw.close();\n+\n+            List<String> command = new ArrayList<>();\n+            command.add(\"sdiff\");\n+            command.add(\"--expand-tabs\");\n+            command.add(\"--ignore-all-space\");\n+            command.add(\"--width=\" + width);\n+            command.add(\"--ignore-blank-lines\");\n+            command.add(lhsFile.getAbsolutePath());\n+            command.add(rhsFile.getAbsolutePath());\n+\n+            ProcessBuilder builder = new ProcessBuilder(command);\n+            final Process process = builder.start();\n+            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n+            StringBuilder out = new StringBuilder();\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                if (line.contains(\"|\")) {\n+                    out.append(TerminalColors.Color.RED.colorize(line)).append(\"\\n\");\n+                } else {\n+                    out.append(TerminalColors.Color.GREEN.colorize(line)).append(\"\\n\");\n+                }\n+\n+            }\n+            process.waitFor();\n+            br.close();\n+            lhsFile.delete();\n+            rhsFile.delete();\n+            return new DiffResult(lhs, rhs, out.toString(), process.exitValue());\n+        } catch (IOException | InterruptedException ioe) {\n+            ioe.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+\n+    public static File write(File file, String text) {\n+        try {\n+            PrintWriter pw = new PrintWriter(file);\n+            pw.append(text);\n+            pw.append(\"\\n\");\n+            pw.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return file;\n+    }\n+\n+\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/Diff.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Value;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public final class GlobalValueBlockNaming {\n+    final Map<Value, String> gvn;\n+    final Map<Block, String> gbn;\n+    int valueOrdinal = 0;\n+    int blockOrdinal = 0;\n+\n+    GlobalValueBlockNaming() {\n+        this.gvn = new HashMap<>();\n+        this.gbn = new HashMap<>();\n+    }\n+\n+    String getValueName(Value _v) {\n+        return gvn.computeIfAbsent(_v, v -> String.valueOf(valueOrdinal++));\n+    }\n+\n+    String getBlockName(Block _b) {\n+        return gbn.computeIfAbsent(_b, b -> \"block_\" + blockOrdinal++);\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/GlobalValueBlockNaming.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public class ProcessRunner {\n+\n+    static public ProcessRunner run(String prog) {\n+        return new ProcessRunner(prog);\n+    }\n+\n+    static public ProcessRunner run(File file) {\n+        return new ProcessRunner(file);\n+    }\n+\n+    List<String> args = new ArrayList<>();\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public ProcessRunner(String prog) {\n+        opt(prog);\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public ProcessRunner(File prog) {\n+        file(prog);\n+    }\n+\n+    public ProcessRunner opt(String... argsToAdd) {\n+        for (String s : argsToAdd) {\n+            args.add(s);\n+        }\n+        return this;\n+    }\n+\n+    public ProcessRunner fileOpt(String opt, File file) {\n+        return opt(opt).file(file);\n+    }\n+\n+    public ProcessRunner dirOpt(String opt, File dir) {\n+        dir.mkdir();\n+        return fileOpt(opt, dir);\n+    }\n+\n+    public ProcessRunner file(File file) {\n+        opt(file.getAbsolutePath());\n+        return this;\n+    }\n+\n+    public ProcessRunner files(File[] files) {\n+        for (File f : files) {\n+            file(f);\n+        }\n+        return this;\n+    }\n+\n+    public void files(List<File> rsFiles) {\n+        files(rsFiles.toArray(new File[0]));\n+    }\n+\n+    public static class Result {\n+        public Result() {\n+        }\n+\n+        public void scan(Pattern pattern, Scanner scanner) {\n+            for (List<String> list : streams) { \/\/stdout then stderr\n+                for (String text : list) {\n+                    Matcher matcher;\n+                    if ((matcher = pattern.matcher(text)).matches()) {\n+                        scanner.process(matcher);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public interface Scanner {\n+            void process(Matcher m);\n+        }\n+\n+        public int status = -1;\n+        public boolean ok = false;\n+        public String commandLine = \"\";\n+\n+        public List<String> stdout = new ArrayList<>();\n+        public List<String> stderr = new ArrayList<>();\n+        public List<List<String>> streams = List.of(stdout, stderr);\n+    }\n+\n+\n+    public Result go(boolean verbose) {\n+        Result result = new Result();\n+\n+        StringBuilder commandBuilder = new StringBuilder();\n+\n+        for (String arg : args) {\n+            commandBuilder.append(arg + \" \");\n+            if (verbose) {\n+                System.out.print(arg + \" \");\n+            }\n+        }\n+\n+        result.commandLine = commandBuilder.toString();\n+        ProcessBuilder processBuilder = new ProcessBuilder(args);\n+        try {\n+            Process process = processBuilder.start();\n+            Thread stdout = new StreamReader(\"OUT\", process.getErrorStream(), result.stdout, verbose).thread;\n+            Thread stderr = new StreamReader(\"ERR\", process.getInputStream(), result.stderr, verbose).thread;\n+            result.status = process.waitFor();\n+            stdout.join();\n+            stderr.join();\n+            result.ok = result.status == 0;\n+        } catch (IOException | InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        return result;\n+    }\n+\n+    public ProcessRunner temp(String prefix, String suffix, String text) {\n+        try {\n+            File tempFile = File.createTempFile(prefix, suffix);\n+            FileWriter tempDotFileWriter = new FileWriter(tempFile);\n+            tempDotFileWriter.append(text);\n+            tempDotFileWriter.close();\n+            file(tempFile);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return this;\n+    }\n+\n+\n+    static class StreamReader {\n+        Thread thread;\n+\n+        StreamReader(final String prefix, InputStream is, final List<String> out, final boolean verbose) {\n+            final BufferedReader br = new BufferedReader(new InputStreamReader(is));\n+            thread = new Thread(() -> {\n+                try {\n+                    for (String string = br.readLine(); string != null; string = br.readLine()) {\n+                        if (verbose) {\n+                            System.out.println(prefix + \":\" + string);\n+                        }\n+                        out.add(string);\n+                    }\n+                    br.close();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            thread.start();\n+\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/ProcessRunner.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public final class SRRenderer extends CommonRenderer<SRRenderer> {\n+\n+    static class AttributeMapper {\n+        static String toString(Object value) {\n+            if (value instanceof Integer i && i >= 0) {\n+                return Integer.toString(i);\n+            } else if (value == null) {\n+                return \"null\";\n+            } else {\n+                return \"\\\"\" + quote(value.toString()) + \"\\\"\";\n+            }\n+        }\n+    }\n+\n+    \/\/ Copied from com.sun.tools.javac.util.Convert\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        switch (ch) {\n+            case '\\b':  return \"\\\\b\";\n+            case '\\f':  return \"\\\\f\";\n+            case '\\n':  return \"\\\\n\";\n+            case '\\r':  return \"\\\\r\";\n+            case '\\t':  return \"\\\\t\";\n+            case '\\'':  return \"\\\\'\";\n+            case '\\\"':  return \"\\\\\\\"\";\n+            case '\\\\':  return \"\\\\\\\\\";\n+            default:\n+                return (isPrintableAscii(ch))\n+                        ? String.valueOf(ch)\n+                        : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+    SRRenderer() {\n+        super();\n+    }\n+\n+    SRRenderer caretLabelTarget(String name) {\n+        return caret().labelTarget(name).self();\n+    }\n+\n+    SRRenderer atIdentifier(String name) {\n+        return at().identifier(name).self();\n+    }\n+\n+    SRRenderer percentLiteral(String name) {\n+        return percent().literal(name).self();\n+    }\n+\n+    SRRenderer spaceColonSpace() {\n+        return space().colon().space();\n+    }\n+\n+    SRRenderer spaceEqualSpace() {\n+        return space().equal().space();\n+    }\n+\n+    public void write(Op op) {\n+        GlobalValueBlockNaming gn = new GlobalValueBlockNaming();\n+        write(gn, op);\n+        nl();\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Block.Reference successor) {\n+        caretLabelTarget(gn.getBlockName(successor.targetBlock()));\n+        if (!successor.arguments().isEmpty()) {\n+            oparen().commaSeparatedList();\n+            for (var a : successor.arguments()) {\n+                commaSeparator();\n+                percentLiteral(gn.getValueName(a));\n+            }\n+            cparen();\n+        }\n+\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Op op) {\n+        keyword(op.opName());\n+        if (!op.operands().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (var v : op.operands()) {\n+                spaceSeparator();\n+                percentLiteral(gn.getValueName(v));\n+            }\n+        }\n+        if (!op.successors().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (Block.Reference sb : op.successors()) {\n+                spaceSeparator();\n+                write(gn, sb);\n+            }\n+        }\n+\n+        if (!op.attributes().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (var e : op.attributes().entrySet()) {\n+                spaceSeparator();\n+                String name = e.getKey();\n+                if (!name.isEmpty()) {\n+                    atIdentifier(name).equal().identifier(AttributeMapper.toString(e.getValue()));\n+                } else {\n+                    atIdentifier(AttributeMapper.toString(e.getValue()));\n+                }\n+            }\n+        }\n+\n+        if (!op.bodies().isEmpty()) {\n+            int nBodies = op.bodies().size();\n+            if (nBodies == 1) {\n+                space();\n+            } else {\n+                nl().in().in();\n+            }\n+            \/\/ @@@ separated list state does not nest as state.first gets overwritten\n+            boolean first = true;\n+            for (Body body : op.bodies()) {\n+                if (!first) {\n+                    nl();\n+                }\n+                write(gn, body);\n+                first = false;\n+            }\n+            if (nBodies > 1) {\n+                out().out();\n+            }\n+        }\n+\n+        semicolon();\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Block block, boolean isEntryBlock) {\n+        if (!isEntryBlock) {\n+            caretLabelTarget(gn.getBlockName(block));\n+            if (!block.parameters().isEmpty()) {\n+                oparen().commaSpaceSeparatedList();\n+                for (var v : block.parameters()) {\n+                    commaSpaceSeparator();\n+                    writeValueDecl(gn, v);\n+                }\n+                cparen();\n+            }\n+            colon().nl();\n+        }\n+        in();\n+        for (Op op : block.ops()) {\n+            Op.Result or = op.result();\n+            if (!or.type().equals(TypeDesc.VOID)) {\n+                writeValueDecl(gn, or);\n+                spaceEqualSpace();\n+            }\n+            write(gn, op);\n+            nl();\n+        }\n+        out();\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Body body) {\n+        Block eb = body.entryBlock();\n+        oparen().commaSpaceSeparatedList();\n+        for (var v : eb.parameters()) {\n+            commaSpaceSeparator();\n+            writeValueDecl(gn, v);\n+        }\n+        cparen().type(body.descriptor().returnType().toString()).space().rarrow().space().obrace().nl();\n+        in();\n+        boolean isEntryBlock = true;\n+        for (Block b : body.blocks()) {\n+            if (!isEntryBlock) {\n+                nl();\n+            }\n+            write(gn, b, isEntryBlock);\n+            isEntryBlock = false;\n+        }\n+        out();\n+        cbrace();\n+    }\n+\n+    public void writeValueDecl(GlobalValueBlockNaming gn, Value v) {\n+        percentLiteral(gn.getValueName(v)).spaceColonSpace().type(v.type().toString());\n+    }\n+\n+    \/\/ @@@ Not used\n+    public void write(GlobalValueBlockNaming gn, CoreOps.FuncOp fRep) {\n+        this.append(fRep.opName());\/\/ w.write(name);\n+        if (!fRep.operands().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (var v : fRep.operands()) {\n+                spaceSeparator();\n+                percentLiteral(gn.getValueName(v));\n+            }\n+        }\n+        if (!fRep.successors().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (Block.Reference sb : fRep.successors()) {\n+                spaceSeparator();\n+                write(gn, sb);\n+            }\n+        }\n+        if (!fRep.attributes().isEmpty()) {\n+            space();\n+            for (var e : fRep.attributes().entrySet()) {\n+                String name = e.getKey();\n+                String value = AttributeMapper.toString(e.getValue());\n+                op(\"@\");\n+                if (name.isEmpty()) {\n+                    literal(value);\n+                } else {\n+                    identifier(name).equal().literal(value);\n+                }\n+            }\n+        }\n+        if (!fRep.bodies().isEmpty()) {\n+            space().newlineSeparatedList();\n+            for (Body body : fRep.bodies()) {\n+                newlineSeparator();\n+                write(gn, body);\n+            }\n+        }\n+\n+    }\n+\n+    public static void write(Writer writer, Op op) {\n+        new SRRenderer().writer(writer).write(op);\n+    }\n+\n+    public static void write(OutputStream out, Op op) {\n+        write(new OutputStreamWriter(out, StandardCharsets.UTF_8), op);\n+    }\n+\n+    public static String stringify(Op op) {\n+        StringWriter sw = new StringWriter();\n+        write(sw, op);\n+        return sw.toString();\n+    }\n+\n+    public static String colorize(TextRenderer.TokenColorMap tokenColorMap, Op op) {\n+        StringWriter sw = new StringWriter();\n+        new SRRenderer().writer(sw).colorize(tokenColorMap).write(op);\n+        return sw.toString();\n+    }\n+\n+    public static String colorize(Op op) {\n+        return colorize(new TextRenderer.TokenColorMap(), op);\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/SRRenderer.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+package jdk.code.tools.renderer;\n+\n+\n+public final class TerminalColors {\n+    private TerminalColors() {\n+    }\n+\n+    public interface Colorizer {\n+        String colorize(String text);\n+    }\n+\n+    public enum Color implements Colorizer {\n+        \/\/ https:\/\/www.lihaoyi.com\/post\/BuildyourownCommandLinewithANSIescapecodes.html#8-colors\n+        NONE(\"0\"),\n+        BLACK(\"38;5;0\"), DARKGREEN(\"38;5;22\"), DARKBLUE(\"38;5;27\"),\n+        GREY(\"38;5;247\"), RED(\"38;5;1\"), GREEN(\"38;5;77\"), YELLOW(\"38;5;185\"),\n+        BLUE(\"38;5;31\"), WHITE(\"38;5;251\"), ORANGE(\"38;5;208\"), PURPLE(\"38;5;133\");\n+        final String escSequence;\n+\n+        Color(String seq) {\n+            escSequence = \"\\u001b[\" + seq + \"m\";\n+        }\n+\n+        public String colorize(String string) {\n+            return (this == NONE) ? string : escSequence + string + NONE.escSequence;\n+        }\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/TerminalColors.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.util.Map;\n+\n+public class TextRenderer<T extends TextRenderer<T>> {\n+\n+    public interface NestedRendererSAM<T> {\n+        T build(T nb);\n+    }\n+\n+    public enum TokenType {\n+        WHITESPACE, OP, TYPE, CONTROL, LITERAL, COMMENT, KEYWORD, IDENTIFIER, LABELTARGET, NONE\n+    }\n+\n+    public static class TokenColorMap {\n+\n+\n+        private final Map<TokenType, TerminalColors.Colorizer> map;\n+\n+        public TokenColorMap(Map<TokenType, TerminalColors.Colorizer> map) {\n+            this.map = map;\n+        }\n+\n+        public TokenColorMap() {\n+            this(Map.of(\n+                    TokenType.NONE, TerminalColors.Color.WHITE,\n+                    TokenType.IDENTIFIER, TerminalColors.Color.YELLOW,\n+                    TokenType.LABELTARGET, TerminalColors.Color.BLUE,\n+                    TokenType.TYPE, TerminalColors.Color.WHITE,\n+                    TokenType.COMMENT, TerminalColors.Color.GREEN,\n+                    TokenType.KEYWORD, TerminalColors.Color.ORANGE,\n+                    TokenType.CONTROL, TerminalColors.Color.GREY,\n+                    TokenType.LITERAL, TerminalColors.Color.GREEN,\n+                    TokenType.OP, TerminalColors.Color.WHITE,\n+                    TokenType.WHITESPACE, TerminalColors.Color.WHITE));\n+        }\n+\n+        public String colorize(TokenType tokenType, String string) {\n+            if (map.containsKey(tokenType)) {\n+                return map.get(tokenType).colorize(string);\n+            } else {\n+                return string;\n+            }\n+        }\n+    }\n+\n+    public static class State {\n+        public Writer writer;\n+        public int indent;\n+        public TokenColorMap tokenColorMap = null;\n+        public boolean isFirst = false;\n+\n+        public boolean newLined = false;\n+\n+        State() {\n+            this.writer = null;\n+            this.indent = 0;\n+            this.tokenColorMap = null;\n+            this.isFirst = false;\n+            this.newLined = true;\n+        }\n+    }\n+\n+    public T writer(Writer writer) {\n+        this.state.writer = writer;\n+        return self();\n+    }\n+\n+    public T colorize(TokenColorMap tokenColorMap) {\n+        this.state.tokenColorMap = tokenColorMap;\n+        return self();\n+    }\n+\n+    public T colorize() {\n+        return colorize(new TokenColorMap());\n+    }\n+\n+    public State state;\n+\n+    protected TextRenderer() {\n+        this.state = new State();\n+    }\n+\n+    protected TextRenderer(TextRenderer<?> renderer) {\n+        this.state = renderer.state;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T self() {\n+        return (T) this;\n+    }\n+\n+\n+    public boolean first() {\n+        var was = state.isFirst;\n+        state.isFirst = false;\n+        return was;\n+    }\n+\n+    public T startList() {\n+        state.isFirst = true;\n+        return self();\n+    }\n+\n+    public T append(String text) {\n+        try {\n+            \/\/ While we do expect appends text to be simple tokens. We can handle newlines.\n+            var lines = text.split(\"\\n\");\n+            for (int i = 0; i < lines.length - 1; i++) {\n+                state.writer.append(\" \".repeat(state.indent) + lines[i] + \"\\n\");\n+                state.newLined = true;\n+            }\n+            if (state.newLined) {\n+                state.writer.append(\" \".repeat(state.indent));\n+            }\n+            state.writer.append(lines[lines.length - 1]);\n+            state.newLined = false;\n+            return self();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    public T identifier(String ident) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.IDENTIFIER, ident));\n+        } else {\n+            return append(ident);\n+        }\n+    }\n+\n+    public T type(String typeName) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.TYPE, typeName));\n+        } else {\n+            return append(typeName);\n+        }\n+    }\n+\n+    public T keyword(String keyword) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.KEYWORD, keyword));\n+        } else {\n+            return append(keyword);\n+        }\n+    }\n+\n+    public T literal(String literal) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.LITERAL, literal));\n+        } else {\n+            return append(literal);\n+        }\n+    }\n+\n+    public T ws(String whitespace) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.WHITESPACE, whitespace));\n+        } else {\n+            return append(whitespace);\n+        }\n+    }\n+\n+    public T op(String op) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.OP, op));\n+        } else {\n+            return append(op);\n+        }\n+    }\n+\n+    public T control(String control) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.CONTROL, control));\n+        } else {\n+            return append(control);\n+        }\n+    }\n+\n+    public T labelTarget(String labelTarget) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.LABELTARGET, labelTarget));\n+        } else {\n+            return append(labelTarget);\n+        }\n+    }\n+\n+    public T comment(String comment) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.COMMENT, comment));\n+        } else {\n+            return append(comment);\n+        }\n+    }\n+\n+    public T strLiteral(String s) {\n+        return oquot().literal(s).cquot();\n+    }\n+\n+    public T oquot() {\n+        return literal(\"\\\"\");\n+    }\n+\n+    public T cquot() {\n+        return literal(\"\\\"\");\n+    }\n+\n+    public T decLiteral(int i) {\n+        return literal(String.format(\"%d\", i));\n+    }\n+\n+    public T hexLiteral(int i) {\n+        return literal(String.format(\"%x\", i));\n+    }\n+\n+    public T in() {\n+        state.indent += 2;\n+        return self();\n+    }\n+\n+    public T out() {\n+        state.indent -= 2;\n+        return self();\n+    }\n+\n+    public T flush() {\n+        try {\n+            state.writer.flush();\n+            return self();\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    public T nl() {\n+        try {\n+            \/\/ note we go directly to the underlying writer!\n+            state.writer.append(\"\\n\");\n+            state.newLined = true;\n+            return flush().self();\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    public T space() {\n+        return ws(\" \");\n+    }\n+\n+    public T nest(NestedRendererSAM<T> nb) {\n+        return nb.build(self());\n+    }\n+\n+    public T open(String op) {\n+        control(op);\n+        return self();\n+    }\n+\n+    public T close(String op) {\n+        control(op);\n+        return self();\n+    }\n+}\n+\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/TextRenderer.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Tools module for code reflection, providing useful ancillary functionality\n+ * that may not be necessary in the java.base module.\n+ *\n+ *\/\n+module jdk.code.tools {\n+    exports jdk.code.tools.dot;\n+    exports jdk.code.tools.renderer;\n+}\n+\n","filename":"src\/jdk.code.tools\/share\/classes\/module-info.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,0 +258,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -250,0 +251,12 @@\n+    \/\/ For code reflection\n+    public final Type codeReflectionType;\n+    public final Type quotedType;\n+    public final Type quotableType;\n+    public final Type closureOpType;\n+    public final Type lambdaOpType;\n+    public final Type opInterpreterType;\n+    public final Type opParserType;\n+    public final Type opType;\n+    public final MethodSymbol opInterpreterInvoke;\n+    public final MethodSymbol opParserFromString;\n+\n@@ -632,0 +645,19 @@\n+        \/\/ For code reflection\n+        codeReflectionType = enterClass(\"java.lang.runtime.CodeReflection\");\n+        quotedType = enterClass(\"java.lang.reflect.code.Quoted\");\n+        quotableType = enterClass(\"java.lang.reflect.code.Quotable\");\n+        closureOpType = enterClass(\"java.lang.reflect.code.op.CoreOps$ClosureOp\");\n+        lambdaOpType = enterClass(\"java.lang.reflect.code.op.CoreOps$LambdaOp\");\n+        opInterpreterType = enterClass(\"java.lang.reflect.code.interpreter.Interpreter\");\n+        opType = enterClass(\"java.lang.reflect.code.Op\");\n+        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n+                names.fromString(\"invoke\"),\n+                new MethodType(List.of(opType, new ArrayType(objectType, arrayClass)), objectType,\n+                        List.nil(), methodClass),\n+                opInterpreterType.tsym);\n+        opParserType = enterClass(\"java.lang.reflect.code.parser.OpParser\");\n+        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"fromStringOfFuncOp\"),\n+                new MethodType(List.of(stringType), opType,\n+                        List.nil(), methodClass),\n+                opParserType.tsym);\n@@ -638,0 +670,2 @@\n+        synthesizeEmptyInterfaceIfMissing(quotedType);\n+        synthesizeEmptyInterfaceIfMissing(quotableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5279,0 +5279,6 @@\n+\n+    \/\/ code reflection\n+\n+    public boolean isQuoted(Type type) {\n+        return type.tsym == syms.quotedType.tsym;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import com.sun.tools.javac.code.Types;\n@@ -107,0 +108,2 @@\n+    private final Types types;\n+\n@@ -131,0 +134,1 @@\n+        types = Types.instance(context);\n@@ -562,11 +566,16 @@\n-            try {\n-                \/\/compute target-type; this logic could be shared with Attr\n-                TargetInfo targetInfo = attr.getTargetInfo(speculativeTree, resultInfo, argtypes());\n-                Type lambdaType = targetInfo.descriptor;\n-                Type currentTarget = targetInfo.target;\n-                \/\/check compatibility\n-                checkLambdaCompatible(lambdaType, resultInfo);\n-                return currentTarget;\n-            } catch (FunctionDescriptorLookupError ex) {\n-                resultInfo.checkContext.report(null, ex.getDiagnostic());\n-                return null; \/\/cannot get here\n+            if (types.isQuoted(resultInfo.pt)) {\n+                \/\/ quoted lambda - always correct\n+                return resultInfo.pt;\n+            } else {\n+                try {\n+                    \/\/compute target-type; this logic could be shared with Attr\n+                    TargetInfo targetInfo = attr.getTargetInfo(speculativeTree, resultInfo, argtypes());\n+                    Type lambdaType = targetInfo.descriptor;\n+                    Type currentTarget = targetInfo.target;\n+                    \/\/check compatibility\n+                    checkLambdaCompatible(lambdaType, resultInfo);\n+                    return currentTarget;\n+                } catch (FunctionDescriptorLookupError ex) {\n+                    resultInfo.checkContext.report(null, ex.getDiagnostic());\n+                    return null; \/\/cannot get here\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -64,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -433,0 +439,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3108,0 +3127,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3251,0 +3278,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":121,"deletions":1,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -837,1 +837,1 @@\n-                if (!inferenceContext.inferencevars.contains(pt)) {\n+                if (!types.isQuoted(pt) && !inferenceContext.inferencevars.contains(pt)) {\n@@ -1229,1 +1229,1 @@\n-            if (!types.isFunctionalInterface(pt)) {\n+            if (types.isQuoted(pt) || !types.isFunctionalInterface(pt)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -442,0 +445,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                syntheticInits.append(capturedArg);\n+            }\n+        }\n+\n@@ -523,0 +532,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                indy_args = indy_args.append(capturedArg);\n+            }\n+        }\n+\n@@ -924,0 +939,1 @@\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n@@ -1143,0 +1159,1 @@\n+                    t.tsym != syms.quotableType.tsym &&\n@@ -1149,0 +1166,1 @@\n+            flags |= context.isQuotable() ? FLAG_QUOTABLE : 0;\n@@ -1171,0 +1189,4 @@\n+            if (context.isQuotable()) {\n+                VarSymbol reflectField = (VarSymbol)tree.codeReflectionInfo.quotedField();\n+                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+            }\n@@ -1865,0 +1887,1 @@\n+                        isQuotable() ||\n@@ -1875,0 +1898,4 @@\n+\n+            boolean isQuotable() {\n+                return tree.codeReflectionInfo != null;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,2513 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.DeferredAttr.FilterScanner;\n+import com.sun.tools.javac.jvm.Gen;\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCArrayAccess;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression.CodeReflectionInfo;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewArray;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n+import jdk.internal.java.lang.reflect.code.Block;\n+import jdk.internal.java.lang.reflect.code.Body;\n+import jdk.internal.java.lang.reflect.code.op.CoreOps;\n+import jdk.internal.java.lang.reflect.code.op.CoreOps.Var;\n+import jdk.internal.java.lang.reflect.code.op.ExtendedOps;\n+import jdk.internal.java.lang.reflect.code.Op;\n+import jdk.internal.java.lang.reflect.code.Value;\n+import jdk.internal.java.lang.reflect.code.descriptor.FieldDesc;\n+import jdk.internal.java.lang.reflect.code.descriptor.MethodDesc;\n+import jdk.internal.java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import jdk.internal.java.lang.reflect.code.descriptor.RecordTypeDesc;\n+import jdk.internal.java.lang.reflect.code.descriptor.TypeDesc;\n+import jdk.internal.java.lang.reflect.code.descriptor.impl.TypeDescImpl;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.type.TypeKind;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static jdk.internal.java.lang.reflect.code.descriptor.TypeDesc.*;\n+\n+\/**\n+ * This a tree translator that adds the code model to all method declaration marked\n+ * with the {@code CodeReflection} annotation. The model is expressed using the code\n+ * reflection API (see jdk.internal.java.lang.reflect.code).\n+ *\/\n+public class ReflectMethods extends TreeTranslator {\n+    protected static final Context.Key<ReflectMethods> reflectMethodsKey = new Context.Key<>();\n+\n+    public static ReflectMethods instance(Context context) {\n+        ReflectMethods instance = context.get(reflectMethodsKey);\n+        if (instance == null)\n+            instance = new ReflectMethods(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Gen gen;\n+    private final Log log;\n+    private final boolean dumpIR;\n+\n+    \/\/ @@@ Separate out mutable state\n+    private TreeMaker make;\n+    private ListBuffer<JCTree> classOps;\n+    \/\/ Also used by BodyScanner\n+    private Symbol.ClassSymbol currentClassSym;\n+    private int lambdaCount;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ReflectMethods(Context context) {\n+        context.put(reflectMethodsKey, this);\n+        Options options = Options.instance(context);\n+        dumpIR = options.isSet(\"dumpIR\");\n+        names = Names.instance(context);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        gen = Gen.instance(context);\n+        log = Log.instance(context);\n+    }\n+\n+    \/\/ Cannot compute within constructor due to circular dependencies on bootstrap compilation\n+    \/\/ syms.objectType == null\n+    private Map<TypeDesc, Type> primitiveAndBoxTypeMap;\n+    public Map<TypeDesc, Type> primitiveAndBoxTypeMap() {\n+        Map<TypeDesc, Type> m = primitiveAndBoxTypeMap;\n+        if (m == null) {\n+            m = primitiveAndBoxTypeMap = Map.ofEntries(\n+                    Map.entry(BOOLEAN, syms.booleanType),\n+                    Map.entry(BYTE, syms.byteType),\n+                    Map.entry(SHORT, syms.shortType),\n+                    Map.entry(CHAR, syms.charType),\n+                    Map.entry(INT, syms.intType),\n+                    Map.entry(LONG, syms.longType),\n+                    Map.entry(FLOAT, syms.floatType),\n+                    Map.entry(DOUBLE, syms.doubleType),\n+                    Map.entry(J_L_OBJECT, syms.objectType),\n+                    Map.entry(J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n+                    Map.entry(J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n+                    Map.entry(J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n+                    Map.entry(J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n+                    Map.entry(J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n+                    Map.entry(J_L_LONG, types.boxedTypeOrType(syms.longType)),\n+                    Map.entry(J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n+                    Map.entry(J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n+            );\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (tree.sym.attribute(syms.codeReflectionType.tsym) != null) {\n+            \/\/ if the method is annotated, scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanMethod();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                classOps.add(opFieldDecl(tree.name, tree.getModifiers().flags, funcOp));\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the method body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n+            }\n+        }\n+        super.visitMethodDef(tree);\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ListBuffer<JCTree> prevClassOps = classOps;\n+        Symbol.ClassSymbol prevClassSym = currentClassSym;\n+        int prevLambdaCount = lambdaCount;\n+        try {\n+            lambdaCount = 0;\n+            currentClassSym = tree.sym;\n+            classOps = new ListBuffer<>();\n+            super.visitClassDef(tree);\n+            tree.defs = tree.defs.prependList(classOps.toList());\n+        } finally {\n+            lambdaCount = prevLambdaCount;\n+            classOps = prevClassOps;\n+            currentClassSym = prevClassSym;\n+            result = tree;\n+        }\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree, kind);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, null);\n+\n+                switch (kind) {\n+                    case QUOTED_STRUCTURAL -> {\n+                        JCIdent opFieldId = make.Ident(opField.sym);\n+                        ListBuffer<JCExpression> interpreterArgs = new ListBuffer<>();\n+                        JCMethodInvocation parsedOp = make.App(make.Ident(syms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n+                        interpreterArgs.append(parsedOp);\n+                        \/\/ append captured vars\n+                        interpreterArgs.appendList(capturedArgs.toList());\n+\n+                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(syms.opInterpreterInvoke), interpreterArgs.toList());\n+                        interpreterInvoke.varargsElement = syms.objectType;\n+                        super.visitLambda(tree);\n+                        result = interpreterInvoke;\n+                    }\n+                    case QUOTABLE -> {\n+                        \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                        tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                        super.visitLambda(tree);\n+                    }\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitLambda(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        Assert.check(kind != FunctionalExpressionKind.QUOTED_STRUCTURAL,\n+                \"structural quoting not supported for method references\");\n+        MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+        JCVariableDecl recvDecl = memberReferenceToLambda.receiverVar();\n+        JCLambda lambdaTree = memberReferenceToLambda.lambda();\n+\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(lambdaTree, kind);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, recvDecl);\n+                tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                super.visitReference(tree);\n+                if (recvDecl != null) {\n+                    result = copyReferenceWithReceiverVar(tree, recvDecl);\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+\n+    ListBuffer<JCExpression> quotedCapturedArgs(DiagnosticPosition pos, BodyScanner bodyScanner, JCVariableDecl recvDecl) {\n+        ListBuffer<JCExpression> capturedArgs = new ListBuffer<>();\n+        for (Symbol capturedSym : bodyScanner.stack.localToOp.keySet()) {\n+            if (capturedSym.kind == Kind.TYP) {\n+                \/\/ captured this\n+                capturedArgs.add(make.at(pos).This(capturedSym.type));\n+            } else if (recvDecl != null && capturedSym == recvDecl.sym) {\n+                \/\/ captured method reference receiver\n+                capturedArgs.add(make.at(pos).Ident(recvDecl.sym));\n+            } else if (capturedSym.kind == Kind.VAR) {\n+                \/\/ captured var\n+                capturedArgs.add(make.at(pos).Ident(capturedSym));\n+            } else {\n+                throw new AssertionError(\"Unexpected captured symbol: \" + capturedSym);\n+            }\n+        }\n+        return capturedArgs;\n+    }\n+\n+    \/*\n+     * Creates a let expression of the kind:\n+     * let $recv in $recv::memberRef\n+     *\n+     * This is required to make sure that LambdaToMethod doesn't end up emitting the\n+     * code for capturing the bound method reference receiver twice.\n+     *\/\n+    JCExpression copyReferenceWithReceiverVar(JCMemberReference ref, JCVariableDecl recvDecl) {\n+        JCMemberReference newRef = make.at(ref).Reference(ref.mode, ref.name, make.Ident(recvDecl.sym), ref.typeargs);\n+        newRef.type = ref.type;\n+        newRef.target = ref.target;\n+        newRef.refPolyKind = ref.refPolyKind;\n+        newRef.referentType = ref.referentType;\n+        newRef.kind = ref.kind;\n+        newRef.varargsElement = ref.varargsElement;\n+        newRef.ownerAccessible = ref.ownerAccessible;\n+        newRef.sym = ref.sym;\n+        newRef.codeReflectionInfo = ref.codeReflectionInfo;\n+        return make.at(ref).LetExpr(recvDecl, newRef).setType(newRef.type);\n+    }\n+\n+    Name lambdaName() {\n+        return names.fromString(\"lambda\").append('$', names.fromString(String.valueOf(lambdaCount++)));\n+    }\n+\n+    private JCVariableDecl opFieldDecl(Name prefix, long flags, CoreOps.FuncOp op) {\n+        VarSymbol opFieldSym = new VarSymbol(flags | Flags.STATIC | Flags.FINAL | Flags.SYNTHETIC,\n+                prefix.append('$', names.fromString(\"op\")),\n+                syms.stringType,\n+                currentClassSym);\n+\n+        currentClassSym.members().enter(opFieldSym);\n+        JCLiteral opText = make.Literal(op.toText());\n+        JCVariableDecl opFieldTree = make.VarDef(opFieldSym, opText);\n+        return opFieldTree;\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        \/\/ note that this method does NOT support recursion.\n+        this.make = make;\n+        JCTree res = translate(cdef);\n+        return res;\n+    }\n+\n+    public CoreOps.FuncOp getMethodBody(Symbol.ClassSymbol classSym, JCMethodDecl methodDecl, JCBlock attributedBody, TreeMaker make) {\n+        \/\/ if the method is annotated, scan it\n+        \/\/ Called from JavacElements::getBody\n+        try {\n+            this.make = make;\n+            currentClassSym = classSym;\n+            BodyScanner bodyScanner = new BodyScanner(methodDecl, attributedBody);\n+            return bodyScanner.scanMethod();\n+        } finally {\n+            currentClassSym = null;\n+            this.make = null;\n+        }\n+    }\n+\n+    static class BodyStack {\n+        final BodyStack parent;\n+\n+        \/\/ Tree associated with body\n+        final JCTree tree;\n+\n+        \/\/ Body to add blocks\n+        final Body.Builder body;\n+        \/\/ Current block to add operations\n+        Block.Builder block;\n+\n+        \/\/ Map of symbols (method arguments and local variables) to varOp values\n+        final Map<Symbol, Value> localToOp;\n+\n+        \/\/ Label\n+        Map.Entry<String, Op.Result> label;\n+\n+        BodyStack(BodyStack parent, JCTree tree, MethodTypeDesc bodyType) {\n+            this.parent = parent;\n+\n+            this.tree = tree;\n+\n+            this.body = Body.Builder.of(parent != null ? parent.body : null, bodyType);\n+            this.block = body.entryBlock();\n+\n+            this.localToOp = new LinkedHashMap<>(); \/\/ order is important for captured values\n+        }\n+\n+        public void setLabel(String labelName, Op.Result labelValue) {\n+            if (label != null) {\n+                throw new IllegalStateException(\"Label already defined: \" + labelName);\n+            }\n+            label = Map.entry(labelName, labelValue);\n+        }\n+    }\n+\n+    class BodyScanner extends FilterScanner {\n+        private final JCTree body;\n+        private final Name name;\n+        private final BodyStack top;\n+        private BodyStack stack;\n+        private Op lastOp;\n+        private Value result;\n+        private Type pt = Type.noType;\n+        private boolean isQuoted;\n+        private Type bodyTarget;\n+\n+        \/\/ Only few AST nodes supported for now\n+        private static final Set<JCTree.Tag> SUPPORTED_TAGS =\n+                Set.of(Tag.VARDEF,\n+                        Tag.RETURN, Tag.THROW, Tag.BREAK, Tag.CONTINUE,\n+                        Tag.PLUS, Tag.MINUS, Tag.MUL, Tag.DIV, Tag.MOD,\n+                        Tag.NEG, Tag.NOT,\n+                        Tag.PLUS_ASG, Tag.MINUS_ASG, Tag.MUL_ASG, Tag.DIV_ASG, Tag.MOD_ASG,\n+                        Tag.POSTINC, Tag.PREINC, Tag.POSTDEC, Tag.PREDEC,\n+                        Tag.EQ, Tag.NE, Tag.LT, Tag.LE, Tag.GT, Tag.GE,\n+                        Tag.AND, Tag.OR,\n+                        Tag.LITERAL, Tag.IDENT, Tag.TYPEIDENT, Tag.ASSIGN, Tag.EXEC, Tag.PARENS,\n+                        Tag.SELECT, Tag.INDEXED, Tag.APPLY,\n+                        Tag.TYPECAST, Tag.TYPETEST,\n+                        Tag.NEWCLASS, Tag.NEWARRAY, Tag.LAMBDA, Tag.REFERENCE,\n+                        Tag.BLOCK, Tag.IF, Tag.WHILELOOP, Tag.DOLOOP, Tag.FOREACHLOOP, Tag.FORLOOP, Tag.TRY,\n+                        Tag.SWITCH_EXPRESSION, Tag.YIELD,\n+                        Tag.CONDEXPR,\n+                        Tag.LABELLED,\n+                        Tag.SKIP);\n+\n+        BodyScanner(JCMethodDecl tree) {\n+            this(tree, tree.body);\n+        }\n+\n+        BodyScanner(JCMethodDecl tree, JCBlock body) {\n+            super(SUPPORTED_TAGS);\n+            this.body = body;\n+            this.name = tree.name;\n+            this.isQuoted = false;\n+\n+            List<TypeDesc> parameters = new ArrayList<>();\n+            int blockArgOffset = 0;\n+            \/\/ Instance methods model \"this\" as an additional argument occurring\n+            \/\/ before all other arguments.\n+            \/\/ @@@ Inner classes.\n+            \/\/ We need to capture all \"this\", in nested order, as arguments.\n+            if (!tree.getModifiers().getFlags().contains(Modifier.STATIC)) {\n+                parameters.add(typeToDesc(tree.sym.owner.type));\n+                blockArgOffset++;\n+            }\n+            tree.sym.type.getParameterTypes().stream().map(this::typeToDesc).forEach(parameters::add);\n+\n+            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToDesc(tree.sym.type.getReturnType()), parameters);\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+\n+            \/\/ @@@ this as local variable? (it can never be stored to)\n+            for (int i = 0 ; i < tree.params.size() ; i++) {\n+                Op.Result paramOp = append(CoreOps.var(\n+                        tree.params.get(i).name.toString(),\n+                        top.block.parameters().get(blockArgOffset + i)));\n+                top.localToOp.put(tree.params.get(i).sym, paramOp);\n+            }\n+\n+            bodyTarget = tree.sym.type.getReturnType();\n+        }\n+\n+        BodyScanner(JCLambda tree, FunctionalExpressionKind kind) {\n+            super(SUPPORTED_TAGS);\n+            assert kind != FunctionalExpressionKind.NOT_QUOTED;\n+\n+            this.body = tree;\n+            this.name = names.fromString(\"quotedLambda\");\n+            this.isQuoted = true;\n+\n+            com.sun.tools.javac.util.List<Type> nil = com.sun.tools.javac.util.List.nil();\n+            Type quotedOpType = kind == FunctionalExpressionKind.QUOTABLE\n+                    ? syms.lambdaOpType\n+                    : syms.closureOpType;\n+            Type quotedReturnType = new ClassType(null,\n+                    com.sun.tools.javac.util.List.of(quotedOpType), syms.quotedType.tsym);\n+            MethodType mtype = new MethodType(nil, quotedReturnType, nil, syms.methodClass);\n+            MethodTypeDesc mtDesc = MethodTypeDesc.methodType(typeToDesc(mtype.restype),\n+                    mtype.getParameterTypes().map(this::typeToDesc));\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+\n+            bodyTarget = tree.target.getReturnType();\n+        }\n+\n+        void pushBody(JCTree tree, MethodTypeDesc bodyType) {\n+            stack = new BodyStack(stack, tree, bodyType);\n+            lastOp = null; \/\/ reset\n+        }\n+\n+        void popBody() {\n+            stack = stack.parent;\n+        }\n+\n+        Value varOpValue(Symbol sym) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                Value v = s.localToOp.get(sym);\n+                if (v != null) {\n+                    return v;\n+                }\n+                s = s.parent;\n+            }\n+            if (isQuoted) {\n+                return capturedOpValue(sym);\n+            } else {\n+                throw new NoSuchElementException(sym.toString());\n+            }\n+        }\n+\n+        Value capturedOpValue(Symbol sym) {\n+            var capturedVar = top.localToOp.get(sym);\n+            if (capturedVar == null) {\n+                var capturedArg = top.block.parameter(typeToDesc(sym.type));\n+                capturedVar = top.block.op(CoreOps.var(sym.name.toString(), capturedArg));\n+                top.localToOp.put(sym, capturedVar);\n+            }\n+            return capturedVar;\n+        }\n+\n+        Value thisValue() { \/\/ @@@: outer this?\n+            if (isQuoted) {\n+                \/\/ capture this - add captured class symbol to the stack top local mappings\n+                var capturedThis = top.localToOp.get(currentClassSym);\n+                if (capturedThis == null) {\n+                    capturedThis = top.block.parameter(typeToDesc(currentClassSym.type));\n+                    top.localToOp.put(currentClassSym, capturedThis);\n+                }\n+                return capturedThis;\n+            } else {\n+                return top.block.parameters().get(0);\n+            }\n+        }\n+\n+        Value getLabel(String labelName) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                if (s.label != null && s.label.getKey().equals(labelName)) {\n+                    return s.label.getValue();\n+                }\n+                s = s.parent;\n+            }\n+            throw new NoSuchElementException(labelName);\n+        }\n+\n+        private Op.Result append(Op op) {\n+            return append(op, stack);\n+        }\n+\n+        private Op.Result append(Op op, BodyStack stack) {\n+            lastOp = op;\n+            return stack.block.apply(op);\n+        }\n+\n+        private <O extends Op & Op.Terminating> void appendTerminating(Supplier<O> sop) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                append(sop.get());\n+            }\n+        }\n+\n+        public Value toValue(JCTree tree) {\n+            return toValue(tree, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree tree, Type target) {\n+            result = null; \/\/ reset\n+            Type prevPt = pt;\n+            try {\n+                pt = target;\n+                scan(tree);\n+                return result != null ?\n+                        coerce(result, tree.type, target) :\n+                        null;\n+            } finally {\n+                pt = prevPt;\n+            }\n+        }\n+\n+        Value coerce(Value sourceValue, Type sourceType, Type targetType) {\n+            if (sourceType.isReference() && targetType.isReference() &&\n+                    !types.isSubtype(types.erasure(sourceType), types.erasure(targetType))) {\n+                return append(CoreOps.cast(typeToDesc(targetType), sourceValue));\n+            } else {\n+                return convert(sourceValue, targetType);\n+            }\n+        }\n+\n+        Value boxIfNeeded(Value exprVal) {\n+            Type source = descToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.boxedTypeOrType(source));\n+        }\n+\n+        Value unboxIfNeeded(Value exprVal) {\n+            Type source = descToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.unboxedTypeOrType(source));\n+        }\n+\n+        Value convert(Value exprVal, Type target) {\n+            Type source = descToType(exprVal.type());\n+            boolean sourcePrimitive = source.isPrimitive();\n+            boolean targetPrimitive = target.isPrimitive();\n+            if (target.hasTag(NONE)) {\n+                return exprVal;\n+            } else if (sourcePrimitive == targetPrimitive) {\n+                if (!sourcePrimitive || types.isSameType(source, target)) {\n+                    return exprVal;\n+                } else {\n+                    \/\/ implicit primitive conversion\n+                    return append(CoreOps.conv(typeToDesc(target), exprVal));\n+                }\n+            } else if (sourcePrimitive) {\n+                \/\/ we need to box\n+                Type unboxedTarget = types.unboxedType(target);\n+                if (!unboxedTarget.hasTag(NONE)) {\n+                    \/\/ non-Object target\n+                    return box(exprVal, target);\n+                } else {\n+                    \/\/ Object target\n+                    return box(exprVal, types.boxedClass(source).type);\n+                }\n+            } else {\n+                \/\/ we need to unbox\n+                return unbox(exprVal, source, target, types.unboxedType(source));\n+            }\n+        }\n+\n+        Value box(Value valueExpr, Type box) {\n+            MethodDesc boxMethod = MethodDesc.method(typeToDesc(box), names.valueOf.toString(),\n+                    MethodTypeDesc.methodType(typeToDesc(box), typeToDesc(types.unboxedType(box))));\n+            return append(CoreOps.invoke(boxMethod, valueExpr));\n+        }\n+\n+        Value unbox(Value valueExpr, Type box, Type primitive, Type unboxedType) {\n+            if (unboxedType.hasTag(NONE)) {\n+                \/\/ Object target, first downcast to correct wrapper type\n+                unboxedType = primitive;\n+                valueExpr = append(CoreOps.cast(typeToDesc(types.boxedClass(unboxedType).type), valueExpr));\n+            }\n+            MethodDesc unboxMethod = MethodDesc.method(typeToDesc(box),\n+                    unboxedType.tsym.name.append(names.Value).toString(),\n+                    MethodTypeDesc.methodType(typeToDesc(unboxedType), typeToDesc(box)));\n+            return append(CoreOps.invoke(unboxMethod, valueExpr));\n+        }\n+\n+        @Override\n+        void skip(JCTree tree) {\n+            \/\/ this method is called for unsupported AST nodes (see 'SUPPORTED_TAGS')\n+            throw unsupported(tree);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            Value initOp;\n+            if (tree.init != null) {\n+                initOp = toValue(tree.init, tree.type);\n+            } else {\n+                initOp = append(defaultValue(tree.type));\n+            }\n+            result = append(CoreOps.var(tree.name.toString(), typeToDesc(tree.type), initOp));\n+            stack.localToOp.put(tree.sym, result);\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            \/\/ Consume top node that applies to write access\n+            JCTree lhs = TreeInfo.skipParens(tree.lhs);\n+            Type target = tree.lhs.type;\n+            switch (lhs.getTag()) {\n+                case IDENT: {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+                            append(CoreOps.varStore(varOp, result));\n+                        }\n+                        case FIELD -> {\n+                            FieldDesc fd = symbolToFieldDesc(sym, symbolSiteType(sym));\n+                            if (sym.isStatic()) {\n+                                append(CoreOps.fieldStore(fd, result));\n+                            } else {\n+                                append(CoreOps.fieldStore(fd, thisValue(), result));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(tree);\n+                        }\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldDesc fd = symbolToFieldDesc(sym, assign.selected.type);\n+                    if (sym.isStatic()) {\n+                        append(CoreOps.fieldStore(fd, result));\n+                    } else {\n+                        append(CoreOps.fieldStore(fd, receiver, result));\n+                    }\n+                    break;\n+                }\n+                case INDEXED: {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    append(CoreOps.arrayStoreOp(array, index, result));\n+                    break;\n+                }\n+                default:\n+                    throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssignop(JCTree.JCAssignOp tree) {\n+            \/\/ Capture applying rhs and operation\n+            Function<Value, Value> scanRhs = (lhs) -> {\n+                Type unboxedType = types.unboxedTypeOrType(tree.type);\n+                TypeDesc resultType = typeToDesc(unboxedType);\n+                Value rhs = toValue(tree.rhs, unboxedType);\n+                lhs = unboxIfNeeded(lhs);\n+\n+                Value assignOpResult = switch (tree.getTag()) {\n+\n+                    \/\/ Arithmetic operations\n+                    case PLUS_ASG -> append(CoreOps.add(resultType, lhs, rhs));\n+                    case MINUS_ASG -> append(CoreOps.sub(resultType, lhs, rhs));\n+                    case MUL_ASG -> append(CoreOps.mul(resultType, lhs, rhs));\n+                    case DIV_ASG -> append(CoreOps.div(resultType, lhs, rhs));\n+                    case MOD_ASG -> append(CoreOps.mod(resultType, lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+                return result = convert(assignOpResult, tree.type);\n+            };\n+\n+            applyCompoundAssign(tree.lhs, scanRhs);\n+        }\n+\n+        void applyCompoundAssign(JCTree.JCExpression lhs, Function<Value, Value> scanRhs) {\n+            \/\/ Consume top node that applies to access\n+            lhs = TreeInfo.skipParens(lhs);\n+            switch (lhs.getTag()) {\n+                case IDENT -> {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+\n+                            Op.Result lhsOpValue = append(CoreOps.varLoad(varOp));\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            append(CoreOps.varStore(varOp, r));\n+                        }\n+                        case FIELD -> {\n+                            FieldDesc fd = symbolToFieldDesc(sym, symbolSiteType(sym));\n+\n+                            Op.Result lhsOpValue;\n+                            if (sym.isStatic()) {\n+                                lhsOpValue = append(CoreOps.fieldLoad(fd));\n+                            } else {\n+                                lhsOpValue = append(CoreOps.fieldLoad(fd, thisValue()));\n+                            }\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            if (sym.isStatic()) {\n+                                append(CoreOps.fieldStore(fd, r));\n+                            } else {\n+                                append(CoreOps.fieldStore(fd, thisValue(), r));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(lhs);\n+                        }\n+                    }\n+                }\n+                case SELECT -> {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldDesc fd = symbolToFieldDesc(sym, assign.selected.type);\n+\n+                    Op.Result lhsOpValue;\n+                    if (sym.isStatic()) {\n+                        lhsOpValue = append(CoreOps.fieldLoad(fd));\n+                    } else {\n+                        lhsOpValue = append(CoreOps.fieldLoad(fd, receiver));\n+                    }\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    if (sym.isStatic()) {\n+                        append(CoreOps.fieldStore(fd, r));\n+                    } else {\n+                        append(CoreOps.fieldStore(fd, receiver, r));\n+                    }\n+                }\n+                case INDEXED -> {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    Op.Result lhsOpValue = append(CoreOps.arrayLoadOp(array, index));\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    append(CoreOps.arrayStoreOp(array, index, r));\n+                }\n+                default -> throw unsupported(lhs);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            \/\/ Visited only for read access\n+\n+            Symbol sym = tree.sym;\n+            switch (sym.getKind()) {\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER -> {\n+                    Value varOp = varOpValue(sym);\n+                    if (varOp.type().rawType().equals(Var.VAR_TYPE)) {\n+                        \/\/ regular var\n+                        result = append(CoreOps.varLoad(varOp));\n+                    } else {\n+                        \/\/ captured value\n+                        result = varOp;\n+                    }\n+                }\n+                case FIELD, ENUM_CONSTANT -> {\n+                    if (sym.name.equals(names._this)) {\n+                        result = thisValue();\n+                    } else {\n+                        FieldDesc fd = symbolToFieldDesc(sym, symbolSiteType(sym));\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOps.fieldLoad(fd));\n+                        } else {\n+                            result = append(CoreOps.fieldLoad(fd, thisValue()));\n+                        }\n+                    }\n+                }\n+                case INTERFACE, CLASS, ENUM -> {\n+                    result = null;\n+                }\n+                default -> {\n+                    \/\/ @@@ Cannot reach here?\n+                    throw unsupported(tree);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeIdent(JCTree.JCPrimitiveTypeTree tree) {\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Type qualifierTarget = qualifierTarget(tree);\n+            \/\/ @@@: might cause redundant load if accessed symbol is static but the qualifier is not a type\n+            Value receiver = toValue(tree.selected);\n+\n+            if (tree.name.equals(names._class)) {\n+                result = append(CoreOps.constant(TypeDesc.J_L_CLASS, typeToDesc(tree.selected.type)));\n+            } else if (types.isArray(tree.selected.type)) {\n+                if (tree.sym.equals(syms.lengthVar)) {\n+                    result = append(CoreOps.arrayLength(receiver));\n+                } else {\n+                    \/\/ Should not reach here\n+                    throw unsupported(tree);\n+                }\n+            } else {\n+                Symbol sym = tree.sym;\n+                switch (sym.getKind()) {\n+                    case FIELD, ENUM_CONSTANT -> {\n+                        FieldDesc fd = symbolToFieldDesc(sym, qualifierTarget.hasTag(NONE) ?\n+                                tree.selected.type : qualifierTarget);\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOps.fieldLoad(fd));\n+                        } else {\n+                            result = append(CoreOps.fieldLoad(fd, receiver));\n+                        }\n+                    }\n+                    case INTERFACE, CLASS, ENUM -> {\n+                        result = null;\n+                    }\n+                    default -> {\n+                        \/\/ @@@ Cannot reach here?\n+                        throw unsupported(tree);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitIndexed(JCArrayAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Value array = toValue(tree.indexed);\n+\n+            Value index = toValue(tree.index);\n+\n+            result = append(CoreOps.arrayLoadOp(array, index));\n+        }\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            \/\/ @@@ Symbol.externalType, for use with inner classes\n+\n+            \/\/ @@@ this.xyz(...) calls in a constructor\n+\n+            \/\/ @@@ super.xyz(...) calls\n+            \/\/ Modeling with a call operation would result in the receiver type differing from that\n+            \/\/ in the method descriptor, perhaps that is sufficient?\n+\n+            JCTree meth = TreeInfo.skipParens(tree.meth);\n+            switch (meth.getTag()) {\n+                case IDENT: {\n+                    JCIdent access = (JCIdent) meth;\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    if (!sym.isStatic()) {\n+                        args.add(thisValue());\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodDesc md = symbolToErasedMethodDesc(sym, symbolSiteType(sym));\n+                    Value res = append(CoreOps.invoke(typeToDesc(meth.type.getReturnType()), md, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess access = (JCFieldAccess) meth;\n+\n+                    Type qualifierTarget = qualifierTarget(access);\n+                    Value receiver = toValue(access.selected, qualifierTarget);\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    if (!sym.isStatic()) {\n+                        args.add(receiver);\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodDesc md = symbolToErasedMethodDesc(sym, qualifierTarget.hasTag(NONE) ?\n+                            access.selected.type : qualifierTarget);\n+                    Value res = append(CoreOps.invoke(typeToDesc(meth.type.getReturnType()), md, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                default:\n+                    unsupported(meth);\n+            }\n+        }\n+\n+        List<Value> scanMethodArguments(List<JCExpression> args, Type methodType, Type varargsElement) {\n+            ListBuffer<Value> argValues = new ListBuffer<>();\n+            com.sun.tools.javac.util.List<Type> targetTypes = methodType.getParameterTypes();\n+            if (varargsElement != null) {\n+                targetTypes = targetTypes.reverse().tail;\n+                for (int i = 0 ; i < args.size() - (methodType.getParameterTypes().size() - 1) ; i++) {\n+                    targetTypes = targetTypes.prepend(varargsElement);\n+                }\n+                targetTypes = targetTypes.reverse();\n+            }\n+\n+            for (JCTree.JCExpression arg : args) {\n+                argValues.add(toValue(arg, targetTypes.head));\n+                targetTypes = targetTypes.tail;\n+            }\n+            return argValues.toList();\n+        }\n+\n+        @Override\n+        public void visitReference(JCTree.JCMemberReference tree) {\n+            MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+            JCVariableDecl recv = memberReferenceToLambda.receiverVar();\n+            if (recv != null) {\n+                scan(recv);\n+            }\n+            scan(memberReferenceToLambda.lambda());\n+        }\n+\n+        Type qualifierTarget(JCFieldAccess tree) {\n+            Type selectedType = types.skipTypeVars(tree.selected.type, true);\n+            return selectedType.isCompound() ?\n+                    tree.sym.owner.type :\n+                    Type.noType;\n+        }\n+\n+        @Override\n+        public void visitTypeCast(JCTree.JCTypeCast tree) {\n+            Value v = toValue(tree.expr);\n+\n+            Type expressionType = tree.expr.type;\n+            Type type = tree.type;\n+            if (expressionType.isPrimitive() && type.isPrimitive()) {\n+                if (expressionType.equals(type)) {\n+                    \/\/ Redundant cast\n+                    result = v;\n+                } else {\n+                    result = append(CoreOps.conv(typeToDesc(type), v));\n+                }\n+            } else if (expressionType.isPrimitive() || type.isPrimitive()) {\n+                result = convert(v, tree.type);\n+            } else if (!expressionType.hasTag(BOT) &&\n+                    types.isAssignable(expressionType, type)) {\n+                \/\/ Redundant cast\n+                result = v;\n+            } else {\n+                \/\/ Reference cast\n+                TypeDesc descriptor = typeToDesc(types.erasure(type));\n+                result = append(CoreOps.cast(typeToDesc(type), descriptor, v));\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeTest(JCTree.JCInstanceOf tree) {\n+            Value target = toValue(tree.expr);\n+\n+            if (tree.pattern.getTag() != Tag.IDENT) {\n+                result = scanPattern(tree.getPattern(), target);\n+            } else {\n+                result = append(CoreOps.instanceOf(typeToDesc(tree.pattern.type), target));\n+            }\n+        }\n+\n+        Value scanPattern(JCTree.JCPattern pattern, Value target) {\n+            \/\/ Type of pattern\n+            TypeDesc patternType;\n+            if (pattern instanceof JCTree.JCBindingPattern p) {\n+                patternType = ExtendedOps.Pattern.bindingType(typeToDesc(p.type));\n+            } else if (pattern instanceof JCTree.JCRecordPattern p) {\n+                patternType = ExtendedOps.Pattern.recordType(typeToDesc(p.record.type));\n+            } else {\n+                throw unsupported(pattern);\n+            }\n+\n+            \/\/ Push pattern body\n+            pushBody(pattern, MethodTypeDesc.methodType(patternType));\n+\n+            \/\/ @@@ Assumes just pattern nodes, likely will change when method patterns are supported\n+            \/\/     that have expressions for any arguments (which perhaps in turn may have pattern expressions)\n+            List<JCVariableDecl> variables = new ArrayList<>();\n+            class PatternScanner extends FilterScanner {\n+\n+                private Value result;\n+\n+                public PatternScanner() {\n+                    super(Set.of(Tag.BINDINGPATTERN, Tag.RECORDPATTERN));\n+                }\n+\n+                @Override\n+                public void visitBindingPattern(JCTree.JCBindingPattern binding) {\n+                    JCVariableDecl var = binding.var;\n+                    variables.add(var);\n+\n+                    result = append(ExtendedOps.bindingPattern(typeToDesc(var.type), var.name.toString()));\n+                }\n+\n+                @Override\n+                public void visitRecordPattern(JCTree.JCRecordPattern record) {\n+                    \/\/ @@@ Is always Identifier to record?\n+                    \/\/ scan(record.deconstructor);\n+\n+                    List<Value> nestedValues = new ArrayList<>();\n+                    for (JCTree.JCPattern jcPattern : record.nested) {\n+                        nestedValues.add(toValue(jcPattern));\n+                    }\n+\n+                    result = append(ExtendedOps.recordPattern(symbolToRecordTypeDesc(record.record), nestedValues));\n+                }\n+\n+                Value toValue(JCTree tree) {\n+                    result = null;\n+                    scan(tree);\n+                    return result;\n+                }\n+            }\n+            \/\/ Scan pattern\n+            Value patternValue = new PatternScanner().toValue(pattern);\n+            append(CoreOps._yield(patternValue));\n+            Body.Builder patternBody = stack.body;\n+\n+            \/\/ Pop body\n+            popBody();\n+\n+            \/\/ Find nearest ancestor body stack element associated with a statement tree\n+            \/\/ @@@ Strengthen check of tree?\n+            BodyStack _variablesStack = stack;\n+            while (!(_variablesStack.tree instanceof JCTree.JCStatement)) {\n+                _variablesStack = _variablesStack.parent;\n+            }\n+            BodyStack variablesStack = _variablesStack;\n+\n+            \/\/ Create pattern var ops for pattern variables using the\n+            \/\/ builder associated with the nearest statement tree\n+            for (JCVariableDecl jcVar : variables) {\n+                Value init = variablesStack.block.op(defaultValue(jcVar.type));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToDesc(jcVar.type), init));\n+                variablesStack.localToOp.put(jcVar.sym, op);\n+            }\n+\n+            \/\/ Create pattern descriptor\n+            List<TypeDesc> patternDescParams = variables.stream().map(var -> typeToDesc(var.type)).toList();\n+            MethodTypeDesc patternDesc = MethodTypeDesc.methodType(VOID, patternDescParams);\n+\n+            \/\/ Create the match body, assigning pattern values to pattern variables\n+            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), patternDesc);\n+            Block.Builder matchBuilder = matchBody.entryBlock();\n+            for (int i = 0; i < variables.size(); i++) {\n+                Value v = matchBuilder.parameters().get(i);\n+                Value var = variablesStack.localToOp.get(variables.get(i).sym);\n+                matchBuilder.op(CoreOps.varStore(var, v));\n+            }\n+            matchBuilder.op(CoreOps._yield());\n+\n+            \/\/ Create the match operation\n+            return append(ExtendedOps.match(target, patternBody, matchBody));\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCTree.JCNewClass tree) {\n+            \/\/ @@@ Support anonymous classes\n+            if (tree.def != null) {\n+                throw unsupported(tree);\n+            }\n+\n+            Type type = tree.type;\n+            Type outer = type.getEnclosingType();\n+            List<Value> args = new ArrayList<>();\n+            if (!outer.hasTag(TypeTag.NONE)) {\n+                \/\/ Obtain outer value for inner class, and add as first argument\n+                JCTree.JCExpression encl = tree.encl;\n+                Value outerInstance;\n+                if (encl == null) {\n+                    outerInstance = thisValue();\n+                } else {\n+                    outerInstance = toValue(tree.encl);\n+                }\n+                args.add(outerInstance);\n+            }\n+\n+            \/\/ Create erased method type descriptor for constructor, where\n+            \/\/ the return type declares the class to instantiate\n+            \/\/ @@@ require symbol site type?\n+            MethodDesc methodDesc = symbolToErasedMethodDesc(tree.constructor);\n+            MethodTypeDesc constructorDesc = MethodTypeDesc.methodType(\n+                    symbolToErasedDesc(tree.constructor.owner),\n+                    methodDesc.type().parameters());\n+\n+            args.addAll(scanMethodArguments(tree.args, tree.constructorType, tree.varargsElement));\n+\n+            result = append(CoreOps._new(typeToDesc(type), constructorDesc, args));\n+        }\n+\n+        @Override\n+        public void visitNewArray(JCTree.JCNewArray tree) {\n+            if (tree.elems != null) {\n+                int length = tree.elems.size();\n+                Op.Result a = append(CoreOps.newArray(\n+                        typeToDesc(tree.type),\n+                        append(CoreOps.constant(TypeDesc.INT, length))));\n+                int i = 0;\n+                for (JCExpression elem : tree.elems) {\n+                    Value element = toValue(elem, types.elemtype(tree.type));\n+                    append(CoreOps.arrayStoreOp(\n+                            a,\n+                            append(CoreOps.constant(TypeDesc.INT, i)),\n+                            element));\n+                    i++;\n+                }\n+\n+                result = a;\n+            } else {\n+                List<Value> indexes = new ArrayList<>();\n+                for (JCTree.JCExpression dim : tree.dims) {\n+                    indexes.add(toValue(dim));\n+                }\n+\n+                TypeDesc arrayType = typeToDesc(tree.type);\n+                MethodTypeDesc descriptor = MethodTypeDesc.methodType(arrayType,\n+                        indexes.stream().map(Value::type).toList());\n+                result = append(CoreOps._new(arrayType, descriptor, indexes));\n+            }\n+        }\n+\n+        @Override\n+        public void visitLambda(JCTree.JCLambda tree) {\n+            FunctionalExpressionKind kind = functionalKind(tree);\n+            final MethodTypeDesc lambdaType = switch (kind) {\n+                case QUOTED_STRUCTURAL -> typeToMethodTypeDesc(tree.target);\n+                default -> typeToMethodTypeDesc(types.findDescriptorType(tree.target));\n+            };\n+\n+            \/\/ Push quoted body\n+            \/\/ We can either be explicitly quoted or a structural quoted expression\n+            \/\/ within some larger reflected code\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                pushBody(tree.body, MethodTypeDesc.VOID);\n+            }\n+\n+            \/\/ Push lambda body\n+            pushBody(tree.body, lambdaType);\n+\n+            \/\/ Map lambda parameters to varOp values\n+            for (int i = 0; i < tree.params.size(); i++) {\n+                JCVariableDecl p = tree.params.get(i);\n+                Op.Result paramOp = append(CoreOps.var(\n+                        p.name.toString(),\n+                        stack.block.parameters().get(i)));\n+                stack.localToOp.put(p.sym, paramOp);\n+            }\n+\n+            \/\/ Scan the lambda body\n+            if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION) {\n+                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                if (!tree.body.type.hasTag(TypeTag.VOID)) {\n+                    append(CoreOps._return(exprVal));\n+                } else {\n+                    appendTerminating(CoreOps::_return);\n+                }\n+            } else {\n+                Type prevBodyTarget = bodyTarget;\n+                try {\n+                    bodyTarget = tree.getDescriptorType(types).getReturnType();\n+                    toValue(tree.body);\n+                    \/\/ @@@ Check if unreachable\n+                    appendTerminating(CoreOps::_return);\n+                } finally {\n+                    bodyTarget = prevBodyTarget;\n+                }\n+            }\n+\n+            Op lambdaOp = switch (kind) {\n+                case QUOTED_STRUCTURAL -> {\n+                    yield CoreOps.closure(stack.body);\n+                }\n+                case QUOTABLE, NOT_QUOTED -> {\n+                    \/\/ Get the functional interface type\n+                    TypeDesc fiType = typeToDesc(tree.target);\n+                    \/\/ build functional lambda\n+                    yield CoreOps.lambda(fiType, stack.body);\n+                }\n+            };\n+\n+            \/\/ Pop lambda body\n+            popBody();\n+\n+            Value lambdaResult = append(lambdaOp);\n+\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                append(CoreOps._yield(lambdaResult));\n+                CoreOps.QuotedOp quotedOp = CoreOps.quoted(stack.body);\n+\n+                \/\/ Pop quoted body\n+                popBody();\n+\n+                lambdaResult = append(quotedOp);\n+            }\n+\n+            result = lambdaResult;\n+        }\n+\n+        @Override\n+        public void visitIf(JCTree.JCIf tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            boolean first = true;\n+            while (tree != null) {\n+                \/\/ @@@ cond.type can be boolean or Boolean\n+                JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+                \/\/ Push if condition\n+                pushBody(cond,\n+                        MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                Value last = toValue(cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(last));\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if condition\n+                popBody();\n+\n+                \/\/ Push if body\n+                pushBody(tree.thenpart, MethodTypeDesc.VOID);\n+\n+                scan(tree.thenpart);\n+                appendTerminating(CoreOps::_yield);\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if body\n+                popBody();\n+\n+                JCTree.JCStatement elsepart = tree.elsepart;\n+                if (elsepart == null) {\n+                    tree = null;\n+                }\n+                else if (elsepart.getTag() == Tag.BLOCK) {\n+                    \/\/ Push else body\n+                    pushBody(elsepart, MethodTypeDesc.VOID);\n+\n+                    scan(elsepart);\n+                    appendTerminating(CoreOps::_yield);\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop else body\n+                    popBody();\n+\n+                    tree = null;\n+                } else if (elsepart.getTag() == Tag.IF) {\n+                    tree = (JCTree.JCIf) elsepart;\n+                }\n+                first = false;\n+            }\n+\n+            append(ExtendedOps._if(bodies));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSwitchExpression(JCTree.JCSwitchExpression tree) {\n+            Value target = toValue(tree.selector);\n+\n+            MethodTypeDesc caseLabelType = MethodTypeDesc.methodType(BOOLEAN, target.type());\n+            Type switchType = adaptBottom(tree.type);\n+            MethodTypeDesc actionType = MethodTypeDesc.methodType(typeToDesc(switchType));\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, MethodTypeDesc.methodType(BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOps._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, MethodTypeDesc.methodType(BOOLEAN));\n+                        append(CoreOps._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOps.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOps._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ @@@ Conversion of localTarget\n+                        if (ccl.expr.type.isPrimitive()) {\n+                            localResult = append(CoreOps.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOps.invoke(\n+                                    MethodDesc.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, MethodTypeDesc.methodType(BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            \/\/ @@@ Conversion of localTarget\n+                            final Value labelResult;\n+                            if (ccl.expr.type.isPrimitive()) {\n+                                labelResult = append(CoreOps.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOps.invoke(\n+                                        MethodDesc.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOps._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOps.conditionalAnd(clBodies));\n+                    }\n+\n+                    append(CoreOps._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, MethodTypeDesc.VOID);\n+\n+                    append(CoreOps._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        Type yieldType = adaptBottom(tree.type);\n+                        if (c.body instanceof JCExpression) {\n+                            \/\/ Yield the boolean result of the condition\n+                            Value bodyVal = toValue(c.body, yieldType);\n+                            append(CoreOps._yield(bodyVal));\n+                        } else {\n+                            \/\/ Otherwise there is a yield statement\n+                            Type prevBodyTarget = bodyTarget;\n+                            try {\n+                                bodyTarget = yieldType;\n+                                Value bodyVal = toValue(c.body);\n+                            } finally {\n+                                bodyTarget = prevBodyTarget;\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally\n+                                ? ExtendedOps::switchFallthroughOp\n+                                : CoreOps::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            result = append(ExtendedOps.switchExpression(actionType.returnType(), target, bodies));\n+        }\n+\n+        @Override\n+        public void visitYield(JCTree.JCYield tree) {\n+            Value retVal = toValue(tree.value, bodyTarget);\n+            if (retVal == null) {\n+                result = append(ExtendedOps.java_yield());\n+            } else {\n+                result = append(ExtendedOps.java_yield(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            \/\/ @@@ cond.type can be boolean or Boolean\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while condition\n+            pushBody(cond, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, MethodTypeDesc.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            append(ExtendedOps._while(condition, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            \/\/ @@@ cond.type can be boolean or Boolean\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, MethodTypeDesc.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            \/\/ Push while condition\n+            pushBody(cond, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            append(ExtendedOps.doWhile(body, condition));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+            \/\/ Push expression\n+            pushBody(tree.expr, MethodTypeDesc.methodType(typeToDesc(tree.expr.type)));\n+            Value last = toValue(tree.expr);\n+            \/\/ Yield the Iterable result of the expression\n+            append(CoreOps._yield(last));\n+            Body.Builder expression = stack.body;\n+\n+            \/\/ Pop expression\n+            popBody();\n+\n+            JCVariableDecl var = tree.getVariable();\n+            TypeDesc eType = typeToDesc(var.type);\n+            TypeDesc varEType = CoreOps.Var.type(typeToDesc(var.type));\n+\n+            \/\/ Push init\n+            \/\/ @@@ When lhs assignment is a pattern we embed the pattern match into the init body and\n+            \/\/ return the bound variables\n+            pushBody(var, MethodTypeDesc.methodType(varEType, eType));\n+            Op.Result varEResult = append(CoreOps.var(var.name.toString(), stack.block.parameters().get(0)));\n+            append(CoreOps._yield(varEResult));\n+            Body.Builder init = stack.body;\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, MethodTypeDesc.methodType(VOID, varEType));\n+            stack.localToOp.put(var.sym, stack.block.parameters().get(0));\n+\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+            \/\/ Pop body\n+            popBody();\n+\n+            append(ExtendedOps.enhancedFor(expression, init, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForLoop(JCTree.JCForLoop tree) {\n+            class VarDefScanner extends FilterScanner {\n+                final List<JCVariableDecl> decls;\n+\n+                public VarDefScanner() {\n+                    super(Set.of(Tag.VARDEF));\n+                    this.decls = new ArrayList<>();\n+                }\n+\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    decls.add(tree);\n+                }\n+\n+                void mapVarsToBlockArguments() {\n+                    for (int i = 0; i < decls.size(); i++) {\n+                        stack.localToOp.put(decls.get(i).sym, stack.block.parameters().get(i));\n+                    }\n+                }\n+\n+                List<TypeDesc> varTypes() {\n+                    return decls.stream()\n+                            .map(t -> CoreOps.Var.type(typeToDesc(t.type)))\n+                            .toList();\n+                }\n+\n+                List<Value> varValues() {\n+                    return decls.stream()\n+                            .map(t -> stack.localToOp.get(t.sym))\n+                            .toList();\n+                }\n+            }\n+\n+            \/\/ Scan local variable declarations\n+            VarDefScanner vds = new VarDefScanner();\n+            vds.scan(tree.init);\n+            List<TypeDesc> varTypes = vds.varTypes();\n+\n+            \/\/ Push init\n+            if (varTypes.size() > 1) {\n+                pushBody(null, MethodTypeDesc.methodType(CoreOps.Tuple.type(varTypes)));\n+                scan(tree.init);\n+\n+                \/\/ Capture all local variable declarations in tuple\n+                append(CoreOps._yield(append(CoreOps.tuple(vds.varValues()))));\n+            } else if (varTypes.size() == 1) {\n+                pushBody(null, MethodTypeDesc.methodType(varTypes.get(0)));\n+                scan(tree.init);\n+\n+                append(CoreOps._yield(vds.varValues().get(0)));\n+            } else {\n+                pushBody(null, MethodTypeDesc.VOID);\n+                scan(tree.init);\n+\n+                append(CoreOps._yield());\n+            }\n+            Body.Builder init = stack.body;\n+\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push cond\n+            pushBody(tree.cond, MethodTypeDesc.methodType(TypeDesc.BOOLEAN, varTypes));\n+            if (tree.cond != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                Value last = toValue(tree.cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(last));\n+            } else {\n+                append(CoreOps._yield(append(CoreOps.constant(BOOLEAN, true))));\n+            }\n+            Body.Builder cond = stack.body;\n+\n+            \/\/ Pop cond\n+            popBody();\n+\n+            \/\/ Push update\n+            \/\/ @@@ tree.step is a List<JCStatement>\n+            pushBody(null, MethodTypeDesc.methodType(TypeDesc.VOID, varTypes));\n+            if (!tree.step.isEmpty()) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.step);\n+            }\n+            append(CoreOps._yield());\n+            Body.Builder update = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, MethodTypeDesc.methodType(TypeDesc.VOID, varTypes));\n+            if (tree.body != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.body);\n+            }\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            append(ExtendedOps._for(init, cond, update, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitConditional(JCTree.JCConditional tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+            Value condVal = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            JCTree.JCExpression truepart = TreeInfo.skipParens(tree.truepart);\n+\n+            Type condType = adaptBottom(tree.type);\n+            Type trueType = condType(tree, truepart.type);\n+\n+            \/\/ Push true body\n+            pushBody(truepart,\n+                    MethodTypeDesc.methodType(typeToDesc(trueType)));\n+\n+            Value trueVal = toValue(truepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOps._yield(trueVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop true body\n+            popBody();\n+\n+            JCTree.JCExpression falsepart = TreeInfo.skipParens(tree.falsepart);\n+\n+            Type falseType = condType(tree, falsepart.type);\n+\n+            \/\/ Push false body\n+            pushBody(falsepart,\n+                    MethodTypeDesc.methodType(typeToDesc(falseType)));\n+\n+            Value falseVal = toValue(falsepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOps._yield(falseVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop false body\n+            popBody();\n+\n+            result = append(ExtendedOps.conditionalExpression(typeToDesc(condType), bodies));\n+        }\n+\n+        private Type condType(JCExpression tree, Type type) {\n+            if (type.hasTag(BOT)) {\n+                return adaptBottom(tree.type);\n+            } else {\n+                return type;\n+            }\n+        }\n+\n+        private Type adaptBottom(Type type) {\n+            return type.hasTag(BOT) ?\n+                    (pt.hasTag(NONE) ? syms.objectType : pt) :\n+                    type;\n+        }\n+\n+        @Override\n+        public void visitBlock(JCTree.JCBlock tree) {\n+            if (stack.tree == tree) {\n+                \/\/ Block is associated with the visit of a parent structure\n+                scan(tree.stats);\n+            } else {\n+                \/\/ Otherwise, independent block structure\n+                \/\/ @@@ Support synchronized blocks\n+                \/\/ Push block\n+                pushBody(tree, MethodTypeDesc.VOID);\n+                scan(tree.stats);\n+                appendTerminating(CoreOps::_yield);\n+                Body.Builder body = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+\n+                append(ExtendedOps.block(body));\n+            }\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n+            \/\/ Push block\n+            pushBody(tree, MethodTypeDesc.VOID);\n+            \/\/ Create constant for label\n+            String labelName = tree.label.toString();\n+            Op.Result label = append(CoreOps.constant(TypeDesc.J_L_STRING, labelName));\n+            \/\/ Set label on body stack\n+            stack.setLabel(labelName, label);\n+            scan(tree.body);\n+            appendTerminating(CoreOps::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            result = append(ExtendedOps.labeled(body));\n+        }\n+\n+        @Override\n+        public void visitTry(JCTree.JCTry tree) {\n+            List<JCVariableDecl> rVariableDecls = new ArrayList<>();\n+            List<TypeDesc> rTypes = new ArrayList<>();\n+            Body.Builder resources;\n+            if (!tree.resources.isEmpty()) {\n+                \/\/ Resources body returns a tuple that contains the resource variables\/values\n+                \/\/ in order of declaration\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCVariableDecl vdecl) {\n+                        rVariableDecls.add(vdecl);\n+                        rTypes.add(CoreOps.Var.type(typeToDesc(vdecl.type)));\n+                    } else {\n+                        rTypes.add(typeToDesc(resource.type));\n+                    }\n+                }\n+\n+                \/\/ Push resources body\n+                pushBody(null, MethodTypeDesc.methodType(CoreOps.Tuple.type(rTypes)));\n+\n+                List<Value> rValues = new ArrayList<>();\n+                for (JCTree resource : tree.resources) {\n+                    rValues.add(toValue(resource));\n+                }\n+\n+                append(CoreOps._yield(append(CoreOps.tuple(rValues))));\n+                resources = stack.body;\n+\n+                \/\/ Pop resources body\n+                popBody();\n+            } else {\n+                resources = null;\n+            }\n+\n+            \/\/ Push body\n+            \/\/ Try body accepts the resource variables (in order of declaration).\n+            List<TypeDesc> rVarTypes = rTypes.stream().filter(t -> t.rawType().equals(CoreOps.Var.VAR_TYPE)).toList();\n+            pushBody(tree.body, MethodTypeDesc.methodType(VOID, rVarTypes));\n+            for (int i = 0; i < rVariableDecls.size(); i++) {\n+                stack.localToOp.put(rVariableDecls.get(i).sym, stack.block.parameters().get(i));\n+            }\n+            scan(tree.body);\n+            appendTerminating(CoreOps::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            List<Body.Builder> catchers = new ArrayList<>();\n+            for (JCTree.JCCatch catcher : tree.catchers) {\n+                \/\/ @@@ Support union types, how to express that plus lub?\n+                if (catcher.param.type.isUnion()) {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Push body\n+                pushBody(catcher.body, MethodTypeDesc.methodType(VOID, typeToDesc(catcher.param.type)));\n+                Op.Result exVariable = append(CoreOps.var(\n+                        catcher.param.name.toString(),\n+                        stack.block.parameters().get(0)));\n+                stack.localToOp.put(catcher.param.sym, exVariable);\n+                scan(catcher.body);\n+                appendTerminating(CoreOps::_yield);\n+                catchers.add(stack.body);\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+\n+            Body.Builder finalizer;\n+            if (tree.finalizer != null) {\n+                \/\/ Push body\n+                pushBody(tree.finalizer, MethodTypeDesc.VOID);\n+                scan(tree.finalizer);\n+                appendTerminating(CoreOps::_yield);\n+                finalizer = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+            else {\n+                finalizer = null;\n+            }\n+\n+            result = append(ExtendedOps._try(resources, body, catchers, finalizer));\n+        }\n+\n+        @Override\n+        public void visitUnary(JCTree.JCUnary tree) {\n+            Tag tag = tree.getTag();\n+            switch (tag) {\n+                case POSTINC, POSTDEC, PREINC, PREDEC -> {\n+                    \/\/ Capture applying rhs and operation\n+                    Function<Value, Value> scanRhs = (lhs) -> {\n+                        Value one = append(numericOneValue(tree.type));\n+                        Value unboxedLhs = unboxIfNeeded(lhs);\n+\n+                        Value unboxedLhsPlusOne = switch (tree.getTag()) {\n+                            \/\/ Arithmetic operations\n+                            case POSTINC, PREINC -> append(CoreOps.add(unboxedLhs, one));\n+                            case POSTDEC, PREDEC -> append(CoreOps.sub(unboxedLhs, one));\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        Value lhsPlusOne = convert(unboxedLhsPlusOne, tree.type);\n+\n+                        \/\/ Assign expression result\n+                        result =  switch (tree.getTag()) {\n+                            case POSTINC, POSTDEC -> lhs;\n+                            case PREINC, PREDEC -> lhsPlusOne;\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        return lhsPlusOne;\n+                    };\n+\n+                    applyCompoundAssign(tree.arg, scanRhs);\n+                }\n+                case NEG -> {\n+                    Value rhs = toValue(tree.arg);\n+                    result = append(CoreOps.neg(typeToDesc(tree.type), rhs));\n+                }\n+                case NOT -> {\n+                    Value rhs = toValue(tree.arg);\n+                    result = append(CoreOps.not(rhs));\n+                }\n+                default -> throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitBinary(JCBinary tree) {\n+            Tag tag = tree.getTag();\n+            if (tag == Tag.AND || tag == Tag.OR) {\n+                \/\/ Logical operations\n+                \/\/ @@@ Flatten nested sequences\n+\n+                \/\/ Push lhs\n+                pushBody(tree.lhs, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                Value lhs = toValue(tree.lhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(lhs));\n+                Body.Builder bodyLhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                \/\/ Push rhs\n+                pushBody(tree.rhs, MethodTypeDesc.methodType(TypeDesc.BOOLEAN));\n+                Value rhs = toValue(tree.rhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(rhs));\n+                Body.Builder bodyRhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                List<Body.Builder> bodies = List.of(bodyLhs, bodyRhs);\n+                result = append(tag == Tag.AND\n+                        ? ExtendedOps.conditionalAnd(bodies)\n+                        : ExtendedOps.conditionalOr(bodies));\n+            } else {\n+                TypeDesc resultType = typeToDesc(tree.type);\n+                Type opType = tree.operator.type.getParameterTypes().get(0);\n+                Value lhs = toValue(tree.lhs, opType);\n+                Value rhs = toValue(tree.rhs, opType);\n+\n+                result = switch (tag) {\n+                    \/\/ Arithmetic operations\n+                    case PLUS -> append(CoreOps.add(resultType, lhs, rhs));\n+                    case MINUS -> append(CoreOps.sub(resultType, lhs, rhs));\n+                    case MUL -> append(CoreOps.mul(resultType, lhs, rhs));\n+                    case DIV -> append(CoreOps.div(resultType, lhs, rhs));\n+                    case MOD -> append(CoreOps.mod(resultType, lhs, rhs));\n+\n+                    \/\/ Test operations\n+                    case EQ -> append(CoreOps.eq(lhs, rhs));\n+                    case NE -> append(CoreOps.neq(lhs, rhs));\n+                    \/\/\n+                    case LT -> append(CoreOps.lt(lhs, rhs));\n+                    case LE -> append(CoreOps.le(lhs, rhs));\n+                    case GT -> append(CoreOps.gt(lhs, rhs));\n+                    case GE -> append(CoreOps.ge(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void visitLiteral(JCLiteral tree) {\n+            Object value = switch (tree.type.getTag()) {\n+                case BOOLEAN -> tree.value instanceof Integer i && i == 1;\n+                case CHAR -> (char) (int) tree.value;\n+                default -> tree.value;\n+            };\n+            Type constantType = adaptBottom(tree.type);\n+            result = append(CoreOps.constant(typeToDesc(constantType), value));\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            Value retVal = toValue(tree.expr, bodyTarget);\n+            if (retVal == null) {\n+                result = append(CoreOps._return());\n+            } else {\n+                result = append(CoreOps._return(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitThrow(JCTree.JCThrow tree) {\n+            Value throwVal = toValue(tree.expr);\n+            result = append(CoreOps._throw(throwVal));\n+        }\n+\n+        @Override\n+        public void visitBreak(JCTree.JCBreak tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOps._break(label));\n+        }\n+\n+        @Override\n+        public void visitContinue(JCTree.JCContinue tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOps._continue(label));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ do nothing\n+        }\n+\n+        UnsupportedASTException unsupported(JCTree tree) {\n+            return new UnsupportedASTException(tree);\n+        }\n+\n+        CoreOps.FuncOp scanMethod() {\n+            scan(body);\n+            \/\/ @@@ Check if unreachable\n+            appendTerminating(CoreOps::_return);\n+            return CoreOps.func(name.toString(), stack.body);\n+        }\n+\n+        CoreOps.FuncOp scanLambda() {\n+            scan(body);\n+            append(CoreOps._return(result));\n+            return CoreOps.func(name.toString(), stack.body);\n+        }\n+\n+        TypeDesc symbolToDesc(Symbol s) {\n+            return typeToDesc(s.type);\n+        }\n+\n+        TypeDesc symbolToErasedDesc(Symbol s) {\n+            return typeToDesc(s.erasure(types));\n+        }\n+\n+        TypeDesc typeToDesc(Type t) {\n+            t = normalizeType(t);\n+            return switch (t.getTag()) {\n+                case VOID -> TypeDesc.VOID;\n+                case CHAR -> TypeDesc.CHAR;\n+                case BOOLEAN -> TypeDesc.BOOLEAN;\n+                case BYTE -> TypeDesc.BYTE;\n+                case SHORT -> TypeDesc.SHORT;\n+                case INT -> TypeDesc.INT;\n+                case FLOAT -> TypeDesc.FLOAT;\n+                case LONG -> TypeDesc.LONG;\n+                case DOUBLE -> TypeDesc.DOUBLE;\n+                case ARRAY -> {\n+                    int dims = 1;\n+                    Type et = ((ArrayType)t).elemtype;\n+                    while (et.getKind() == TypeKind.ARRAY) {\n+                        et = ((ArrayType) et).elemtype;\n+                        dims++;\n+                    }\n+\n+                    TypeDesc etd = typeToDesc(et);\n+                    yield new TypeDescImpl(etd.rawType().toString(), dims, etd.typeArguments());\n+                }\n+                case CLASS -> {\n+                    \/\/ @@@ Need to clean this up, probably does not work inner generic classes\n+                    \/\/ whose enclosing class is also generic\n+                    List<TypeDesc> typeArguments;\n+                    if (t.getTypeArguments().nonEmpty()) {\n+                        typeArguments = new ArrayList<>();\n+                        for (Type ta : t.getTypeArguments()) {\n+                            typeArguments.add(typeToDesc(ta));\n+                        }\n+                    } else {\n+                        typeArguments = List.of();\n+                    }\n+\n+                    \/\/ Use flat name to ensure demarcation of nested classes\n+                    yield new TypeDescImpl(t.tsym.flatName().toString(), 0, typeArguments);\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n+                }\n+            };\n+        }\n+\n+        Type symbolSiteType(Symbol s) {\n+            boolean isMember = s.owner == syms.predefClass ||\n+                    s.isMemberOf(currentClassSym, types);\n+            return isMember ? currentClassSym.type : s.owner.type;\n+        }\n+\n+        FieldDesc symbolToFieldDesc(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in descriptor, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToFieldDesc(gen.binaryQualifier(s, site));\n+        }\n+\n+        FieldDesc symbolToFieldDesc(Symbol s) {\n+            return FieldDesc.field(\n+                    typeToDesc(s.owner.type),\n+                    s.name.toString(),\n+                    typeToDesc(s.type));\n+        }\n+\n+        MethodDesc symbolToMethodDesc(Symbol s) {\n+            return MethodDesc.method(\n+                    typeToDesc(s.owner.type),\n+                    s.name.toString(),\n+                    typeToDesc(s.type.getReturnType()),\n+                    s.type.getParameterTypes().stream().map(this::typeToDesc).toArray(TypeDesc[]::new));\n+        }\n+\n+        MethodDesc symbolToErasedMethodDesc(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in descriptor, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedMethodDesc(gen.binaryQualifier(s, site));\n+        }\n+\n+        MethodDesc symbolToErasedMethodDesc(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return MethodDesc.method(\n+                    typeToDesc(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToDesc(erasedType.getReturnType()),\n+                    erasedType.getParameterTypes().stream().map(this::typeToDesc).toArray(TypeDesc[]::new));\n+        }\n+\n+        MethodTypeDesc symbolToMethodTypeDesc(Symbol s) {\n+            return typeToMethodTypeDesc(s.type);\n+        }\n+\n+        MethodTypeDesc typeToMethodTypeDesc(Type t) {\n+            return MethodTypeDesc.methodType(\n+                    typeToDesc(t.getReturnType()),\n+                    t.getParameterTypes().stream().map(this::typeToDesc).toArray(TypeDesc[]::new));\n+        }\n+\n+        RecordTypeDesc symbolToRecordTypeDesc(Symbol.ClassSymbol s) {\n+            TypeDesc recordType = typeToDesc(s.type);\n+            List<RecordTypeDesc.ComponentDesc> components = s.getRecordComponents().stream()\n+                    .map(rc -> new RecordTypeDesc.ComponentDesc(typeToDesc(rc.type), rc.name.toString()))\n+                    .toList();\n+            return RecordTypeDesc.recordType(recordType, components);\n+        }\n+\n+        Op defaultValue(Type t) {\n+            return switch (t.getTag()) {\n+                case CHAR -> CoreOps.constant(typeToDesc(t), (char)0);\n+                case BOOLEAN -> CoreOps.constant(typeToDesc(t), false);\n+                case SHORT -> CoreOps.constant(typeToDesc(t), (short)0);\n+                case INT -> CoreOps.constant(typeToDesc(t), 0);\n+                case FLOAT -> CoreOps.constant(typeToDesc(t), 0f);\n+                case LONG -> CoreOps.constant(typeToDesc(t), 0L);\n+                case DOUBLE -> CoreOps.constant(typeToDesc(t), 0d);\n+                default -> CoreOps.constant(typeToDesc(t), null);\n+            };\n+        }\n+\n+        Op numericOneValue(Type t) {\n+            return switch (t.getTag()) {\n+                case CHAR -> CoreOps.constant(typeToDesc(t), (char)1);\n+                case SHORT -> CoreOps.constant(typeToDesc(t), (short)1);\n+                case INT -> CoreOps.constant(typeToDesc(t), 1);\n+                case FLOAT -> CoreOps.constant(typeToDesc(t), 1f);\n+                case LONG -> CoreOps.constant(typeToDesc(t), 1L);\n+                case DOUBLE -> CoreOps.constant(typeToDesc(t), 1d);\n+                case CLASS -> numericOneValue(types.unboxedType(t));\n+                default -> throw new UnsupportedOperationException(t.toString());\n+            };\n+        }\n+\n+        Type normalizeType(Type t) {\n+            return switch (t.getTag()) {\n+                case METHOD -> new MethodType(t.getParameterTypes().map(this::normalizeType),\n+                        normalizeType(t.getReturnType()), t.getThrownTypes().map(this::normalizeType),\n+                        syms.methodClass);\n+                default -> checkDenotableInTypeDesc(t) ? t : types.erasure(t);\n+            };\n+        }\n+\n+        Type descToType(TypeDesc desc) {\n+            return primitiveAndBoxTypeMap().getOrDefault(desc, Type.noType);\n+        }\n+\n+        public boolean checkDenotableInTypeDesc(Type t) {\n+            return denotableChecker.visit(t, null);\n+        }\n+        \/\/ where\n+\n+        \/**\n+         * A type visitor that descends into the given type looking for types that are non-denotable\n+         * in IR type descriptors. Examples of such types are: type-variables (regular or captured),\n+         * wildcard type argument, intersection types, union types. The visit methods return false\n+         * as soon as a non-denotable type is encountered and true otherwise. (see {@link Check#checkDenotable(Type)}.\n+         *\/\n+        private static final Types.SimpleVisitor<Boolean, Void> denotableChecker = new Types.SimpleVisitor<>() {\n+            @Override\n+            public Boolean visitType(Type t, Void s) {\n+                return true;\n+            }\n+            @Override\n+            public Boolean visitClassType(ClassType t, Void s) {\n+                if (t.isUnion() || t.isIntersection()) {\n+                    \/\/ union an intersections cannot be denoted in IR type descriptors\n+                    return false;\n+                }\n+                \/\/ @@@ What about enclosing types?\n+                for (Type targ : t.getTypeArguments()) {\n+                    \/\/ propagate into type arguments\n+                    if (!visit(targ, s)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Void s) {\n+                \/\/ type variables cannot be denoted in IR type descriptors\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Void s) {\n+                \/\/ wildcards cannot de denoted in IR type descriptors\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Void s) {\n+                \/\/ propagate into element type\n+                return visit(t.elemtype, s);\n+            }\n+        };\n+\n+    }\n+\n+    \/**\n+     * An exception thrown when an unsupported AST node is found when building a method IR.\n+     *\/\n+    static class UnsupportedASTException extends RuntimeException {\n+\n+        private static final long serialVersionUID = 0;\n+        transient final JCTree tree;\n+\n+        public UnsupportedASTException(JCTree tree) {\n+            this.tree = tree;\n+        }\n+    }\n+\n+    enum FunctionalExpressionKind {\n+        QUOTED_STRUCTURAL(true), \/\/ this is transitional\n+        QUOTABLE(true),\n+        NOT_QUOTED(false);\n+\n+        final boolean isQuoted;\n+\n+        FunctionalExpressionKind(boolean isQuoted) {\n+            this.isQuoted = isQuoted;\n+        }\n+    }\n+\n+    FunctionalExpressionKind functionalKind(JCFunctionalExpression functionalExpression) {\n+        if (functionalExpression.target.hasTag(TypeTag.METHOD)) {\n+            return FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+        } else if (types.asSuper(functionalExpression.target, syms.quotableType.tsym) != null) {\n+            return FunctionalExpressionKind.QUOTABLE;\n+        } else {\n+            return FunctionalExpressionKind.NOT_QUOTED;\n+        }\n+    }\n+\n+    \/*\n+     * Converts a method reference which cannot be used directly into a lambda.\n+     * This code has been derived from LambdaToMethod::MemberReferenceToLambda. The main\n+     * difference is that, while that code concerns with translation strategy, boxing\n+     * conversion and type erasure, this version does not and, as such, can remain\n+     * at a higher level. Note that this code needs to create a synthetic variable\n+     * declaration in case of a bounded method reference whose receiver expression\n+     * is other than 'this'\/'super' (this is done to prevent the receiver expression\n+     * from being computed twice).\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final Symbol owner;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private JCVariableDecl receiverVar = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree, Symbol currentClass) {\n+            this.tree = tree;\n+            this.owner = new MethodSymbol(0, names.lambda, tree.target, currentClass);\n+            if (tree.kind == ReferenceKind.BOUND && !isThisOrSuper(tree.getQualifierExpression())) {\n+                \/\/ true bound method reference, hoist receiver expression out\n+                Type recvType = types.asSuper(tree.getQualifierExpression().type, tree.sym.owner);\n+                VarSymbol vsym = makeSyntheticVar(\"rec$\", recvType);\n+                receiverVar = make.VarDef(vsym, tree.getQualifierExpression());\n+            }\n+        }\n+\n+        JCVariableDecl receiverVar() {\n+            return receiverVar;\n+        }\n+\n+        JCLambda lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                return slam;\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            com.sun.tools.javac.util.List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+            VarSymbol receiverParam = null;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    if (receiverVar != null) {\n+                        receiverParam = receiverVar.sym;\n+                    }\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    receiverParam = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+            }\n+            for (int i = 0; descPTypes.nonEmpty(); ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                descPTypes = descPTypes.tail;\n+            }\n+\n+            return receiverParam;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol receiverParam) {\n+            JCExpression qualifier = receiverParam != null ?\n+                    make.at(tree.pos).Ident(receiverParam) :\n+                    tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCMethodInvocation apply = make.Apply(com.sun.tools.javac.util.List.nil(), select, args.toList()).\n+                    setType(tree.referentType.getReturnType());\n+\n+            apply.varargsElement = tree.varargsElement;\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            Type expectedType = tree.referentType.getReturnType().hasTag(TypeTag.VOID) ?\n+                    tree.expr.type : tree.referentType.getReturnType();\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(expectedType)),\n+                        com.sun.tools.javac.util.List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCExpression newType = make.Type(types.erasure(expectedType));\n+                if (expectedType.tsym.type.getTypeArguments().nonEmpty()) {\n+                    newType = make.TypeApply(newType, com.sun.tools.javac.util.List.nil());\n+                }\n+                JCNewClass newClass = make.NewClass(null,\n+                        com.sun.tools.javac.util.List.nil(),\n+                        newType,\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.referentType;\n+                newClass.type = expectedType;\n+                newClass.varargsElement = tree.varargsElement;\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol makeSyntheticVar(String name, Type type) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), type, owner);\n+            vsym.pos = tree.pos;\n+            return vsym;\n+        }\n+\n+        private VarSymbol addParameter(String name, Type type, boolean genArg) {\n+            VarSymbol vsym = makeSyntheticVar(name, type);\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+\n+        boolean isThisOrSuper(JCExpression expression) {\n+            return TreeInfo.isThisQualifier(expression) || TreeInfo.isSuperQualifier(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":2513,"deletions":0,"binary":false,"changes":2513,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1620,0 +1620,4 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                env.tree = ReflectMethods.instance(context).translateTopLevelClass(env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -46,0 +47,1 @@\n+import com.sun.source.tree.Tree;\n@@ -47,0 +49,1 @@\n+import com.sun.tools.javac.api.JavacScope;\n@@ -48,0 +51,1 @@\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -59,0 +63,1 @@\n+import com.sun.tools.javac.comp.Attr;\n@@ -62,0 +67,1 @@\n+import com.sun.tools.javac.comp.ReflectMethods;\n@@ -67,0 +73,1 @@\n+import com.sun.tools.javac.tree.TreeMaker;\n@@ -74,1 +81,1 @@\n-import com.sun.tools.javac.comp.Attr;\n+\n@@ -77,1 +84,0 @@\n-import com.sun.tools.javac.comp.Resolve.RecoveryLoadClass;\n@@ -79,0 +85,2 @@\n+import jdk.internal.java.lang.reflect.code.op.CoreOps;\n+\n@@ -97,0 +105,1 @@\n+    private final JavacTrees javacTrees;\n@@ -99,0 +108,1 @@\n+    private final ReflectMethods reflectMethods;\n@@ -101,0 +111,1 @@\n+    private final TreeMaker make;\n@@ -121,0 +132,2 @@\n+        javacTrees = JavacTrees.instance(context);\n+        reflectMethods = ReflectMethods.instance(context);\n@@ -124,0 +137,1 @@\n+        make = TreeMaker.instance(context);\n@@ -796,0 +810,32 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public Optional<Object> getBody(ExecutableElement e) {\n+        if (e.getModifiers().contains(Modifier.ABSTRACT) ||\n+                e.getModifiers().contains(Modifier.NATIVE)) {\n+            return Optional.empty();\n+        }\n+\n+        CoreOps.FuncOp funcOp;\n+        try {\n+            JCMethodDecl methodTree = (JCMethodDecl)getTree(e);\n+            JavacScope scope = javacTrees.getScope(javacTrees.getPath(e));\n+            ClassSymbol enclosingClass = (ClassSymbol) scope.getEnclosingClass();\n+            funcOp = attr.runWithAttributedMethod(scope.getEnv(), methodTree,\n+                    attribBlock -> reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make));\n+        } catch (RuntimeException ex) {  \/\/ ReflectMethods.UnsupportedASTException\n+            \/\/ some other error occurred when attempting to attribute the method\n+            \/\/ @@@ better report of error\n+            ex.printStackTrace();\n+            return Optional.empty();\n+        }\n+\n+        \/\/ Reparse using API in java.base\n+        try {\n+            String opString = funcOp.toText();\n+            Class<?> opParserClass = Class.forName(\"java.lang.reflect.code.parser.OpParser\");\n+            Method fromStringMethod = opParserClass.getDeclaredMethod(\"fromStringOfFuncOp\", String.class);\n+            return Optional.of(fromStringMethod.invoke(null, opString));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1406,0 +1406,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4093,0 +4101,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.code.Type.MethodType;\n@@ -760,1 +761,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -769,0 +771,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public CodeReflectionInfo codeReflectionInfo;\n@@ -771,1 +775,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -773,0 +784,2 @@\n+\n+        public record CodeReflectionInfo(Symbol quotedField, List<JCExpression> capturedArgs) { }\n@@ -1964,1 +1977,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2603,1 +2616,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @summary Test symbolic access of method\n+ * @run testng TreeAccessTest\n+ *\/\n+\n+public class TreeAccessTest {\n+\n+    @CodeReflection\n+    public int m(String s) {\n+        return s.length();\n+    }\n+\n+    @Test\n+    void testTreeAccess() throws Exception {\n+        Method m = TreeAccessTest.class.getDeclaredMethod(\"m\", String.class);\n+\n+        Optional<CoreOps.FuncOp> tree = m.getCodeModel();\n+        Assert.assertTrue(tree.isPresent());\n+\n+        CoreOps.FuncOp methodTree = tree.get();\n+\n+        String expectedTree = \"\"\"\n+                func @\"m\" (%0 : TreeAccessTest, %1 : java.lang.String)int -> {\n+                      %2 : Var<java.lang.String> = var %1 @\"s\";\n+                      %3 : java.lang.String = var.load %2;\n+                      %4 : int = invoke %3 @\"java.lang.String::length()int\";\n+                      return %4;\n+                };\n+                \"\"\";\n+\n+        Assert.assertEquals(canonicalizeDescription(methodTree.toText()), canonicalizeDescription(expectedTree));\n+    }\n+\n+    static String canonicalizeDescription(String d) {\n+        return OpParser.fromString(ExtendedOps.FACTORY, d).get(0).toText();\n+    }\n+\n+    @Test\n+    public int n(String s) {\n+        return s.length();\n+    }\n+\n+    @Test\n+    void testNoTree() throws Exception {\n+        Method m = TreeAccessTest.class.getDeclaredMethod(\"n\", String.class);\n+\n+        Optional<CoreOps.FuncOp> tree = m.getCodeModel();\n+        Assert.assertTrue(tree.isEmpty());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/cr\/TreeAccessTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCreation\n+ *\/\n+\n+public class TestArrayCreation {\n+    @CodeReflection\n+    public static String[] f() {\n+        return new String[10];\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f2() {\n+        return new String[10][];\n+    }\n+\n+    @Test\n+    public void testf2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f2());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f3() {\n+        return new String[10][10];\n+    }\n+\n+    @Test\n+    public void testf3() {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f3());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestBinops\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestBinops {\n+\n+    @CodeReflection\n+    public static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @Test\n+    public void testNot() {\n+        CoreOps.FuncOp f = getFuncOp(\"not\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, true), not(true));\n+        Assert.assertEquals(Interpreter.invoke(f, false), not(false));\n+    }\n+\n+    @CodeReflection\n+    public static int mod(int a, int b) {\n+        return a % b;\n+    }\n+\n+    @Test\n+    public void testMod() {\n+        CoreOps.FuncOp f = getFuncOp(\"mod\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), mod(10, 3));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBinops.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestBlockOp\n+ *\/\n+\n+public class TestBlockOp {\n+\n+    @CodeReflection\n+    public static int f() {\n+        int i = 0;\n+\n+        {\n+            i++;\n+        }\n+\n+        {\n+            i += 2;\n+        }\n+\n+        return i;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBlockOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestBreakContinue\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.BitSet;\n+import java.util.Optional;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+public class TestBreakContinue {\n+\n+    @CodeReflection\n+    public static BitSet forLoopBreakContinue(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        for (int i = 0; i < 8; i++) {\n+            b.set(i);\n+            int r = f.applyAsInt(i);\n+            if (r == 0) {\n+                continue;\n+            } else if (r == 1) {\n+                break;\n+            }\n+            b.set(i * 2);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testForLoopBreakContinue() {\n+        CoreOps.FuncOp f = getFuncOp(\"forLoopBreakContinue\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        IntUnaryOperator o = i -> {\n+            if (i <= 3) return -1;\n+            if (i <= 5) return 0;\n+            return 1;\n+        };\n+        Assert.assertEquals(Interpreter.invoke(lf, o), forLoopBreakContinue(o));\n+    }\n+\n+    @CodeReflection\n+    public static BitSet nestedForLoopBreakContinue(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        for (int j = 0; j < 8; j++) {\n+            b.set(j);\n+            int r = f.applyAsInt(j);\n+            if (r == 0) {\n+                continue;\n+            } else if (r == 1) {\n+                break;\n+            }\n+            for (int i = 8; i < 16; i++) {\n+                b.set(i);\n+                r = f.applyAsInt(i);\n+                if (r == 2) {\n+                    continue;\n+                } else if (r == 3) {\n+                    break;\n+                }\n+                b.set(i * 2);\n+            }\n+            b.set(j * 2);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testNestedForLoopBreakContinue() {\n+        CoreOps.FuncOp f = getFuncOp(\"nestedForLoopBreakContinue\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int r = -1; r < 4; r++) {\n+            int fr = r;\n+            IntUnaryOperator o = i -> fr;\n+            Assert.assertEquals(Interpreter.invoke(lf, o), nestedForLoopBreakContinue(o));\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static BitSet forLoopLabeledBreakContinue(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        outer: for (int j = 0; j < 8; j++) {\n+            b.set(j);\n+            int r = f.applyAsInt(j);\n+            if (r == 0) {\n+                continue outer;\n+            } else if (r == 1) {\n+                break outer;\n+            }\n+            inner: for (int i = 8; i < 16; i++) {\n+                b.set(i);\n+                r = f.applyAsInt(i);\n+                if (r == 2) {\n+                    continue inner;\n+                } else if (r == 3) {\n+                    break inner;\n+                } else if (r == 4) {\n+                    continue outer;\n+                } else if (r == 5) {\n+                    break outer;\n+                }\n+                b.set(i * 2);\n+            }\n+            b.set(j * 2);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testForLoopLabeledBreakContinue() {\n+        CoreOps.FuncOp f = getFuncOp(\"forLoopLabeledBreakContinue\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int r = -1; r < 6; r++) {\n+            int fr = r;\n+            IntUnaryOperator o = i -> fr;\n+            Assert.assertEquals(Interpreter.invoke(lf, o), forLoopLabeledBreakContinue(o));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static BitSet blockBreak(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        a: b: {\n+            b.set(1);\n+            if (f.applyAsInt(1) != 0) {\n+                break a;\n+            }\n+            b.set(2);\n+            if (f.applyAsInt(2) != 0) {\n+                break b;\n+            }\n+            b.set(3);\n+            c: {\n+                b.set(4);\n+                if (f.applyAsInt(4) != 0) {\n+                    break a;\n+                }\n+                b.set(5);\n+                if (f.applyAsInt(5) != 0) {\n+                    break b;\n+                }\n+                b.set(6);\n+                if (f.applyAsInt(6) != 0) {\n+                    break c;\n+                }\n+                b.set(7);\n+            }\n+            b.set(8);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testBlockBreak() {\n+        CoreOps.FuncOp f = getFuncOp(\"blockBreak\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int i = 0; i < 7; i++) {\n+            int fi = i;\n+            IntUnaryOperator o = v -> v == fi ? 1 : 0;\n+            Assert.assertEquals(Interpreter.invoke(lf, o), blockBreak(o));\n+        }\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBreakContinue.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.util.function.IntBinaryOperator;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.VOID;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+\n+\/*\n+ * @test\n+ * @run testng TestBuild\n+ *\/\n+\n+public class TestBuild {\n+\n+    public LambdaOp f() {\n+        IntBinaryOperator ibo = (IntBinaryOperator & Quotable) (a, b) -> a + b;\n+        Quotable iboq = (Quotable) ibo;\n+        return SSA.transform((LambdaOp) iboq.quoted().op());\n+    }\n+\n+    @Test\n+    public void testBoundValueAsOperand() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var block = body.entryBlock();\n+\n+        var a = f.body().entryBlock().parameters().get(0);\n+        var b = f.body().entryBlock().parameters().get(1);\n+        \/\/ Passing bound values as operands to a new unbound operation\n+        var addop = add(a, b);\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> block.op(addop));\n+    }\n+\n+    @Test\n+    public void testBoundValueAsHeaderArgument() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var block = body.entryBlock();\n+        var anotherBlock = block.block(INT, INT);\n+\n+        var a = f.body().entryBlock().parameters().get(0);\n+        var b = f.body().entryBlock().parameters().get(1);\n+        \/\/ Passing bound values as header arguments of a header\n+        \/\/ that is the successor of a terminal operation\n+        var brop = branch(anotherBlock.successor(a, b));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> block.op(brop));\n+    }\n+\n+    @Test\n+    public void testUnmappedBoundValue() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var block = body.entryBlock();\n+\n+        var freturnOp = f.body().entryBlock().terminatingOp();\n+        \/\/ Unmapped bound value that is operand of the bound return op\n+        Assert.assertThrows(IllegalArgumentException.class, () -> block.op(freturnOp));\n+    }\n+\n+    @Test\n+    public void testMappingToBoundValue() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var block = body.entryBlock();\n+\n+        var result = f.body().entryBlock().firstOp().result();\n+        \/\/ Mapping to a bound value\n+        Assert.assertThrows(IllegalArgumentException.class, () -> block.context().mapValue(result, result));\n+    }\n+\n+    @Test\n+    public void testMappedBoundValue() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.funcDescriptor());\n+        var block = body.entryBlock();\n+\n+        var a = block.parameters().get(0);\n+        var b = block.parameters().get(1);\n+        var result = block.op(add(a, b));\n+        \/\/ Map the bound value used as the operand to the bound return op to\n+        \/\/ the above value\n+        block.context().mapValue(f.body().entryBlock().firstOp().result(), result);\n+\n+        var freturnOp = f.body().entryBlock().terminatingOp();\n+        \/\/ No error since values (operands) are mapped\n+        block.op(freturnOp);\n+    }\n+\n+    @Test\n+    public void testPartiallyConstructedValueAccess() {\n+        var body = Body.Builder.of(null, methodType(int.class, int.class, int.class));\n+        var block = body.entryBlock();\n+\n+        Block.Parameter a = block.parameters().get(0);\n+        Block.Parameter b = block.parameters().get(1);\n+        Op.Result result = block.op(add(a, b));\n+\n+        \/\/ Access the declaring block of values before the block and its body are\n+        \/\/ constructed\n+        Assert.assertThrows(IllegalStateException.class, a::declaringBlock);\n+        Assert.assertThrows(IllegalStateException.class, result::declaringBlock);\n+        \/\/ Access to parent block\/body of operation result before they are constructed\n+        Assert.assertThrows(IllegalStateException.class, result.op()::parentBlock);\n+        Assert.assertThrows(IllegalStateException.class, result.op()::ancestorBody);\n+        \/\/ Access to set of users before constructed\n+        Assert.assertThrows(IllegalStateException.class, a::uses);\n+\n+        block.op(_return(result));\n+\n+        var f = CoreOps.func(\"f\", body);\n+\n+        Assert.assertNotNull(a.declaringBlock());\n+        Assert.assertNotNull(result.declaringBlock());\n+        Assert.assertNotNull(result.op().parentBlock());\n+        Assert.assertNotNull(result.op().ancestorBody());\n+        Assert.assertNotNull(a.uses());\n+    }\n+\n+    @Test\n+    public void testPartiallyConstructedHeaderAccess() {\n+        var body = Body.Builder.of(null, methodType(int.class, int.class, int.class));\n+        var block = body.entryBlock();\n+        var anotherBlock = block.block(INT, INT);\n+\n+        var a = block.parameters().get(0);\n+        var b = block.parameters().get(1);\n+        Block.Reference successor = anotherBlock.successor(a, b);\n+        \/\/ Access to target block before constructed\n+        Assert.assertThrows(IllegalStateException.class, successor::targetBlock);\n+        block.op(branch(anotherBlock.successor(a, b)));\n+\n+        a = anotherBlock.parameters().get(0);\n+        b = anotherBlock.parameters().get(1);\n+        var result = anotherBlock.op(add(a, b));\n+        anotherBlock.op(_return(result));\n+\n+        var f = CoreOps.func(\"f\", body);\n+\n+        Assert.assertNotNull(successor.targetBlock());\n+    }\n+\n+    @Test\n+    public void testValueUseFromOtherModel() {\n+        var abody = Body.Builder.of(null, methodType(int.class, int.class, int.class));\n+        var ablock = abody.entryBlock();\n+        var aa = ablock.parameters().get(0);\n+        var ab = ablock.parameters().get(1);\n+\n+        var bbody = Body.Builder.of(null, abody.descriptor());\n+        var bblock = bbody.entryBlock();\n+\n+        \/\/ Operation uses values from another model\n+        var addOp = add(aa, ab);\n+        Assert.assertThrows(IllegalStateException.class, () -> bblock.op(addOp));\n+    }\n+\n+    @Test\n+    public void testHeaderFromOtherBody() {\n+        var abody = Body.Builder.of(null, VOID);\n+        var ablock = abody.entryBlock().block();\n+\n+        var bbody = Body.Builder.of(null, VOID);\n+        var bblock = bbody.entryBlock();\n+\n+        \/\/ Operation uses header with target block from another model\n+        var brOp = branch(ablock.successor());\n+        Assert.assertThrows(IllegalStateException.class, () -> bblock.op(brOp));\n+    }\n+\n+    @Test\n+    public void testHeaderFromEntryBlock() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        Assert.assertThrows(IllegalStateException.class, block::successor);\n+    }\n+\n+    @Test\n+    public void testBuiltBodyBuilder() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+        CoreOps.func(\"f\", body);\n+\n+        \/\/ Body is built\n+        Assert.assertThrows(IllegalStateException.class, () -> CoreOps.func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testBodyBuilderWithBuiltAncestor() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+        CoreOps.func(\"f\", body);\n+\n+        \/\/ ancestor body is built\n+        Assert.assertThrows(IllegalStateException.class, () -> Body.Builder.of(body, VOID));\n+    }\n+\n+    @Test\n+    public void testBodyBuilderWithUnbuiltChildren() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+\n+        Body.Builder.of(body, VOID);\n+\n+        \/\/ Great-grandchild body is not built\n+        Assert.assertThrows(IllegalStateException.class, () -> CoreOps.func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testMistmatchedBody() {\n+        var body1 = Body.Builder.of(null, VOID);\n+        var block1 = body1.entryBlock();\n+\n+        var anotherBody = Body.Builder.of(null, VOID);\n+\n+        var body2 = Body.Builder.of(anotherBody, VOID);\n+        var block2 = body2.entryBlock();\n+        block2.op(_return());\n+        var lambdaOp = lambda(type(Runnable.class), body2);\n+\n+        \/\/ Op's grandparent body is not parent body of block1\n+        Assert.assertThrows(IllegalStateException.class, () -> block1.op(lambdaOp));\n+    }\n+\n+    @Test\n+    public void testAppendAfterTerminatingOperation() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+\n+        \/\/ Append operation after terminating operation\n+        Assert.assertThrows(IllegalStateException.class, () -> block.op(_return()));\n+    }\n+\n+    @Test\n+    public void testNoTerminatingOperation() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(constant(INT, 0));\n+\n+        \/\/ No terminating operation\n+        Assert.assertThrows(IllegalStateException.class, () -> CoreOps.func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testEmptyBlocksElided() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+\n+        \/\/ Create empty blocks\n+        block.block();\n+        block.block();\n+        block.block();\n+\n+        FuncOp f = func(\"f\", body);\n+        Assert.assertEquals(f.body().blocks().size(), 1);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestClosureOps\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.add;\n+import static java.lang.reflect.code.op.CoreOps.invoke;\n+import static java.lang.reflect.code.op.CoreOps.closure;\n+import static java.lang.reflect.code.op.CoreOps.closureCall;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.op.CoreOps.quoted;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+\n+public class TestClosureOps {\n+\n+    static class Builder {\n+        static final MethodDesc ACCEPT_METHOD = MethodDesc.method(type(TestClosureOps.Builder.class), \"accept\",\n+                INT, CoreOps.QuotedOp.QUOTED_TYPE);\n+\n+        static int accept(Quoted c) {\n+            Assert.assertEquals(1, c.capturedValues().size());\n+            Assert.assertEquals(1, c.capturedValues().values().iterator().next());\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) c.op(),\n+                    c.capturedValues(), 42);\n+            return r;\n+        }\n+    }\n+\n+    @Test\n+    public void testQuotedWithCapture() {\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional descriptor = (int)int\n+                    \/\/ op descriptor = ()Quoted<ClosureOp>\n+                    CoreOps.QuotedOp qop = quoted(block.parentBody(), qblock -> {\n+                        return closure(qblock.parentBody(), methodType(int.class, int.class))\n+                                .body(cblock -> {\n+                                    Block.Parameter ci = cblock.parameters().get(0);\n+\n+                                    cblock.op(_return(\n+                                            \/\/ capture i from function's body\n+                                            cblock.op(add(i, ci))\n+                                    ));\n+                                });\n+                    });\n+                    Op.Result cquoted = block.op(qop);\n+\n+                    Op.Result or = block.op(CoreOps.invoke(TestClosureOps.Builder.ACCEPT_METHOD, cquoted));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testWithCapture() {\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional descriptor = (int)int\n+                    \/\/   captures i\n+                    CoreOps.ClosureOp closure = CoreOps.closure(block.parentBody(),\n+                            methodType(int.class, int.class))\n+                            .body(cblock -> {\n+                                Block.Parameter ci = cblock.parameters().get(0);\n+\n+                                cblock.op(_return(\n+                                        cblock.op(add(i, ci))));\n+                            });\n+                    Op.Result c = block.op(closure);\n+\n+                    Op.Result fortyTwo = block.op(constant(INT, 42));\n+                    Op.Result or = block.op(closureCall(c, fortyTwo));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testQuotableModel() {\n+        Quoted quoted = () -> {};\n+        Op qop = quoted.op();\n+        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Assert.assertTrue(top instanceof CoreOps.FuncOp);\n+\n+        CoreOps.FuncOp fop = (CoreOps.FuncOp) top;\n+        Assert.assertEquals(TypeDesc.type(Quoted.class, CoreOps.ClosureOp.class), fop.funcDescriptor().returnType());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestConditionalExpression\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestConditionalExpression {\n+    @CodeReflection\n+    public static int simpleExpression(boolean b, int x, int y) {\n+        return b ? x : y;\n+    }\n+\n+    @Test\n+    public void testSimpleExpression() {\n+        CoreOps.FuncOp f = getFuncOp(\"simpleExpression\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, true, 1, 2), simpleExpression(true, 1, 2));\n+        Assert.assertEquals(Interpreter.invoke(lf, false, 1, 2), simpleExpression(false, 1, 2));\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestConditionalExpression.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestConditionalOp\n+ *\/\n+\n+public class TestConditionalOp {\n+\n+    @CodeReflection\n+    static boolean f(boolean a, boolean b, boolean c, List<String> l) {\n+        return F.a(a, l) || (F.b(b, l) && F.c(c, l));\n+    }\n+\n+    static class F {\n+        static boolean a(boolean a, List<String> l) {\n+            l.add(\"a\");\n+            return a;\n+        }\n+\n+        static boolean b(boolean b, List<String> l) {\n+            l.add(\"b\");\n+            return b;\n+        }\n+\n+        static boolean c(boolean c, List<String> l) {\n+            l.add(\"c\");\n+            return c;\n+        }\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestConditionalOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int i = 0; i < 8; i++) {\n+            boolean a = (i & 1) != 0;\n+            boolean b = (i & 2) != 0;\n+            boolean c = (i & 4) != 0;\n+            List<String> la = new ArrayList<>();\n+            boolean ra = (boolean) Interpreter.invoke(MethodHandles.lookup(), lf, a, b, c, la);\n+\n+            List<String> le = new ArrayList<>();\n+            boolean re = f(a, b, c, le);\n+\n+            Assert.assertEquals(ra, re);\n+            Assert.assertEquals(la, le);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestConstants\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestConstants {\n+\n+    @CodeReflection\n+    public static boolean c_boolean() {\n+        return true;\n+    }\n+\n+    @CodeReflection\n+    public static boolean c_boolean_f() {\n+        return false;\n+    }\n+\n+    @CodeReflection\n+    public static byte c_byte() {\n+        return 42;\n+    }\n+\n+    @CodeReflection\n+    public static byte c_byte_neg() {\n+        return -42;\n+    }\n+\n+    @CodeReflection\n+    public static short c_short() {\n+        return 42;\n+    }\n+\n+    @CodeReflection\n+    public static short c_short_neg() {\n+        return -42;\n+    }\n+\n+    @CodeReflection\n+    public static char c_char() {\n+        return 'A';\n+    }\n+\n+    @CodeReflection\n+    public static int c_int() {\n+        return 42;\n+    }\n+\n+    @CodeReflection\n+    public static int c_int_neg() {\n+        return -42;\n+    }\n+\n+    @CodeReflection\n+    public static long c_long() {\n+        return 42L;\n+    }\n+\n+    @CodeReflection\n+    public static long c_long_neg() {\n+        return -42L;\n+    }\n+\n+    @CodeReflection\n+    public static float c_float() {\n+        return 1.0f;\n+    }\n+\n+    @CodeReflection\n+    public static float c_float_neg() {\n+        return -1.0f;\n+    }\n+\n+    @CodeReflection\n+    public static double c_double() {\n+        return 1.0;\n+    }\n+\n+    @CodeReflection\n+    public static double c_double_neg() {\n+        return -1.0;\n+    }\n+\n+    @CodeReflection\n+    public static String c_String() {\n+        String s = \"42\";\n+        s = null;\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static Class<?> c_Class() {\n+        return String.class;\n+    }\n+\n+    @CodeReflection\n+    public static Class<?> c_Class_primitive() {\n+        return float.class;\n+    }\n+\n+    @DataProvider\n+    static Object[][] provider() {\n+        return new Object[][] {\n+                { boolean.class },\n+                { byte.class },\n+                { short.class },\n+                { char.class },\n+                { int.class },\n+                { long.class },\n+                { float.class },\n+                { double.class },\n+                { String.class },\n+                { Class.class }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void testString(Class<?> c) throws Exception {\n+        String name = \"c_\" + c.getSimpleName();\n+        List<Method> ms = Stream.of(TestConstants.class.getDeclaredMethods())\n+                .filter(m -> m.getName().startsWith(name))\n+                .toList();\n+\n+        for (Method m : ms) {\n+            CoreOps.FuncOp f = m.getCodeModel().get();\n+\n+            f.writeTo(System.out);\n+\n+            Assert.assertEquals(Interpreter.invoke(f), m.invoke(null));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String compareNull(String s) {\n+        if (s == null) {\n+            return \"NULL\";\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    @Test\n+    public void testCompareNull() {\n+        CoreOps.FuncOp f = getFuncOp(\"compareNull\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), compareNull(null));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestConstants.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestCopy\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.OpDefinition;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+public class TestCopy {\n+\n+    @CodeReflection\n+    static int f(int i) {\n+        IntUnaryOperator f = j -> i + j;\n+        return f.applyAsInt(42);\n+    }\n+\n+    @Test\n+    public void testCopy() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        Op copy = f.copy();\n+\n+        Assert.assertEquals(f.toText(), copy.toText());\n+    }\n+\n+    @Test\n+    public void testCopyWithDefinition() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        OpDefinition odef = OpDefinition.fromOp(CopyContext.create(), f);\n+        Op copy = CoreOps.FACTORY.constructOp(odef);\n+\n+        Assert.assertEquals(f.toText(), copy.toText());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestCopy.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+import static java.lang.reflect.code.op.CoreOps.conditionalBranch;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+\n+\/*\n+ * @test\n+ * @run testng TestDominate\n+ *\/\n+\n+public class TestDominate {\n+\n+    @Test\n+    public void testIfElse() {\n+        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+            Block.Builder ifBlock = entry.block();\n+            Block.Builder elseBlock = entry.block();\n+            Block.Builder end = entry.block();\n+\n+            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            entry.op(conditionalBranch(p, ifBlock.successor(), elseBlock.successor()));\n+\n+            ifBlock.op(branch(end.successor()));\n+\n+            elseBlock.op(branch(end.successor()));\n+\n+            end.op(_return());\n+        });\n+\n+        boolean[][] bvs = new boolean[][]{\n+                {true, false, false, false},\n+                {true, true, false, false},\n+                {true, false, true, false},\n+                {true, false, false, true}\n+        };\n+\n+        test(f, bvs);\n+    }\n+\n+    @Test\n+    public void testForwardSuccessors() {\n+        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+            Block.Builder b1 = entry.block();\n+            Block.Builder b2 = entry.block();\n+            Block.Builder b3 = entry.block();\n+            Block.Builder b4 = entry.block();\n+            Block.Builder b5 = entry.block();\n+\n+            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            entry.op(conditionalBranch(p, b4.successor(), b2.successor()));\n+\n+            b4.op(conditionalBranch(p, b5.successor(), b3.successor()));\n+\n+            b2.op(conditionalBranch(p, b5.successor(), b1.successor()));\n+\n+            b5.op(_return());\n+\n+            b3.op(branch(b1.successor()));\n+\n+            b1.op(_return());\n+        });\n+\n+        f.writeTo(System.out);\n+        boolean[][] bvs = new boolean[][]{\n+                {true, false, false, false, false, false},\n+                {true, true, false, false, false, false},\n+                {true, true, true, false, false, false},\n+                {true, false, false, true, false, false},\n+                {true, false, false, false, true, false},\n+                {true, false, false, false, false, true},\n+        };\n+\n+        test(f, bvs);\n+    }\n+\n+    @Test\n+    public void testBackbranch() {\n+        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+            Block.Builder cond = entry.block();\n+            Block.Builder body = entry.block();\n+            Block.Builder update = entry.block();\n+            Block.Builder end = entry.block();\n+\n+            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            entry.op(branch(cond.successor()));\n+\n+            cond.op(conditionalBranch(p, body.successor(), end.successor()));\n+\n+            body.op(branch(update.successor()));\n+\n+            update.op(branch(cond.successor()));\n+\n+            end.op(_return());\n+\n+        });\n+\n+        boolean[][] bvs = new boolean[][]{\n+                {true, false, false, false, false},\n+                {true, true, false, false, false},\n+                {true, true, true, false, false},\n+                {true, true, true, true, false},\n+                {true, true, false, false, true},\n+        };\n+        test(f, bvs);\n+    }\n+\n+    static void test(CoreOps.FuncOp f, boolean[][] bvs) {\n+        Block[] bs = f.body().blocks().toArray(Block[]::new);\n+        for (int i = 0; i < bs.length; i++) {\n+            for (int j = 0; j < bs.length; j++) {\n+                Block x = bs[i];\n+                Block y = bs[j];\n+                Assert.assertEquals(y.isDominatedBy(x), bvs[j][i]);\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testImmediateDominators() {\n+        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+            Block.Builder b6 = entry.block();\n+            Block.Builder b5 = entry.block();\n+            Block.Builder b4 = entry.block();\n+            Block.Builder b3 = entry.block();\n+            Block.Builder b2 = entry.block();\n+            Block.Builder b1 = entry.block();\n+\n+            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+            entry.op(branch(b6.successor()));\n+\n+            b6.op(conditionalBranch(p, b5.successor(), b4.successor()));\n+\n+            b5.op(branch(b1.successor()));\n+\n+            b4.op(conditionalBranch(p, b2.successor(), b3.successor()));\n+\n+            b1.op(branch(b2.successor()));\n+\n+            b2.op(conditionalBranch(p, b1.successor(), b3.successor()));\n+\n+            b3.op(branch(b2.successor()));\n+        });\n+        f.writeTo(System.out);\n+        Map<Block, Block> idoms = f.body().immediateDominators();\n+        System.out.println(idoms);\n+\n+        Block entry = f.body().entryBlock();\n+        Block b6 = entry.successors().get(0).targetBlock();\n+\n+        for (Block b : f.body().blocks()) {\n+            if (b == entry || b == b6) {\n+                Assert.assertEquals(idoms.get(b), entry);\n+            } else {\n+                Assert.assertEquals(idoms.get(b), b6);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCytronExample() {\n+        CoreOps.FuncOp f = func(\"f\", MethodTypeDesc.VOID).body(entry -> {\n+            Block.Builder exit = entry.block();\n+            Block.Builder b12 = entry.block();\n+            Block.Builder b11 = entry.block();\n+            Block.Builder b10 = entry.block();\n+            Block.Builder b9 = entry.block();\n+            Block.Builder b8 = entry.block();\n+            Block.Builder b7 = entry.block();\n+            Block.Builder b6 = entry.block();\n+            Block.Builder b5 = entry.block();\n+            Block.Builder b4 = entry.block();\n+            Block.Builder b3 = entry.block();\n+            Block.Builder b2 = entry.block();\n+            Block.Builder b1 = entry.block();\n+\n+            Op.Result p = entry.op(constant(TypeDesc.BOOLEAN, true));\n+\n+            entry.op(conditionalBranch(p, exit.successor(), b1.successor()));\n+\n+            b1.op(branch(b2.successor()));\n+\n+            b2.op(conditionalBranch(p, b3.successor(), b7.successor()));\n+\n+            b3.op(conditionalBranch(p, b4.successor(), b5.successor()));\n+\n+            b4.op(branch(b6.successor()));\n+\n+            b5.op(branch(b6.successor()));\n+\n+            b6.op(branch(b8.successor()));\n+\n+            b7.op(branch(b8.successor()));\n+\n+            b8.op(branch(b9.successor()));\n+\n+            b9.op(conditionalBranch(p, b10.successor(), b11.successor()));\n+\n+            b10.op(branch(b11.successor()));\n+\n+            b11.op(conditionalBranch(p, b12.successor(), b9.successor()));\n+\n+            b12.op(conditionalBranch(p, exit.successor(), b2.successor()));\n+\n+            exit.op(_return());\n+        });\n+\n+        f.writeTo(System.out);\n+\n+        Map<Block, Block> idoms = f.body().immediateDominators();\n+        Node<String> domTree = buildDomTree(f.body().entryBlock(), idoms).transform(b -> Integer.toString(b.index()));\n+        Node<String> domTreeExpected =\n+                node(\"0\",\n+                        node(\"1\",\n+                                node(\"2\",\n+                                        node(\"7\"),\n+                                        node(\"8\",\n+                                                node(\"9\",\n+                                                        node(\"10\"),\n+                                                        node(\"11\",\n+                                                                node(\"12\")))),\n+                                        node(\"3\",\n+                                                node(\"4\"), node(\"5\"), node(\"6\")))),\n+                        node(\"13\"));\n+        Assert.assertEquals(domTree, domTreeExpected);\n+\n+\n+        Map<String, Set<String>> df = f.body().dominanceFrontier().entrySet().stream()\n+                .map(e -> Map.entry(Integer.toString(e.getKey().index()),\n+                        e.getValue().stream().map(b -> Integer.toString(b.index())).collect(Collectors.toSet())))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        Map<String, Set<String>> dfExpected = Map.ofEntries(\n+                Map.entry(\"1\", Set.of(\"13\")),\n+                Map.entry(\"2\", Set.of(\"13\", \"2\")),\n+                Map.entry(\"3\", Set.of(\"8\")),\n+                Map.entry(\"4\", Set.of(\"6\")),\n+                Map.entry(\"5\", Set.of(\"6\")),\n+                Map.entry(\"6\", Set.of(\"8\")),\n+                Map.entry(\"7\", Set.of(\"8\")),\n+                Map.entry(\"8\", Set.of(\"13\", \"2\")),\n+                Map.entry(\"9\", Set.of(\"13\", \"2\", \"9\")),\n+                Map.entry(\"10\", Set.of(\"11\")),\n+                Map.entry(\"11\", Set.of(\"13\", \"2\", \"9\")),\n+                Map.entry(\"12\", Set.of(\"13\", \"2\"))\n+        );\n+        Assert.assertEquals(df, dfExpected);\n+    }\n+\n+    static Node<Block> buildDomTree(Block entryBlock, Map<Block, Block> idoms) {\n+        Map<Block, Node<Block>> m = new HashMap<>();\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block id = e.getValue();\n+            Block b = e.getKey();\n+            if (b == entryBlock) {\n+                continue;\n+            }\n+\n+            Node<Block> parent = m.computeIfAbsent(id, _k -> new Node<>(_k, new HashSet<>()));\n+            Node<Block> child = m.computeIfAbsent(b, _k -> new Node<>(_k, new HashSet<>()));\n+            parent.children.add(child);\n+        }\n+        return m.get(entryBlock);\n+    }\n+\n+    @SafeVarargs\n+    static <T> Node<T> node(T t, Node<T>... children) {\n+        return new Node<>(t, Set.of(children));\n+    }\n+\n+    static <T> Node<T> node(T t, Set<Node<T>> children) {\n+        return new Node<>(t, children);\n+    }\n+\n+    record Node<T>(T t, Set<Node<T>> children) {\n+        <U> Node<U> transform(Function<T, U> f) {\n+            Set<Node<U>> mchildren = new HashSet<>();\n+            for (Node<T> nc : children) {\n+                mchildren.add(nc.transform(f));\n+            }\n+            return node(f.apply(t), mchildren);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestEnhancedForOp\n+ *\/\n+\n+public class TestEnhancedForOp {\n+\n+    @CodeReflection\n+    public static int f() {\n+        int j = 0;\n+        for (int i : List.of(1, 2, 3, 4)) {\n+            j += i;\n+        }\n+        return j;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestEnhancedForOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f());\n+    }\n+\n+\n+    @CodeReflection\n+    public static int array(int[] a) {\n+        int j = 0;\n+        for (int i : a) {\n+            j += i;\n+        }\n+        return j;\n+    }\n+\n+    @Test\n+    public void testArray() {\n+        CoreOps.FuncOp f = getFuncOp(\"array\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        int[] ia = new int[] {1, 2, 3, 4};\n+        Assert.assertEquals(Interpreter.invoke(lf, ia), array(ia));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestExceptionRegionOps\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps._throw;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+import static java.lang.reflect.code.op.CoreOps.invoke;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.exceptionRegionEnter;\n+import static java.lang.reflect.code.op.CoreOps.exceptionRegionExit;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.descriptor.TypeDesc.VOID;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+\n+public class TestExceptionRegionOps {\n+\n+    public void testF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchER1ISE = fblock.block(TypeDesc.type(IllegalStateException.class));\n+                    var catchER1IAE = fblock.block(TypeDesc.type(IllegalArgumentException.class));\n+                    var enterER1 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchER1ISE.successor(), catchER1IAE.successor()));\n+\n+                    \/\/ Start of exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er1, end.successor()));\n+                    });\n+\n+                    \/\/ First catch block for exception region\n+                    catchER1ISE.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Second catch for exception region\n+                    catchER1IAE.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testF);\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new NullPointerException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    public void testCatchThrowableF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (Throwable e) {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrowable() {\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchER1ISE = fblock.block(TypeDesc.type(IllegalStateException.class));\n+                    var catchER1T = fblock.block(TypeDesc.type(Throwable.class));\n+                    var enterER1 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchER1ISE.successor(), catchER1T.successor()));\n+\n+                    \/\/ Start of exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er1, end.successor()));\n+                    });\n+\n+                    \/\/ First catch block for exception region\n+                    catchER1ISE.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Second catch for exception region\n+                    catchER1T.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testCatchThrowableF);\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    public void testNestedF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            try {\n+                c.accept(1);\n+                c.accept(-1);\n+            } catch (IllegalStateException e) {\n+                c.accept(2);\n+                c.accept(-1);\n+            }\n+            c.accept(3);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            c.accept(4);\n+            c.accept(-1);\n+        }\n+        c.accept(5);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testNested() {\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchER1 = fblock.block(TypeDesc.type(IllegalArgumentException.class));\n+                    var catchER2 = fblock.block(TypeDesc.type(IllegalStateException.class));\n+                    var enterER1 = fblock.block();\n+                    var enterER2 = fblock.block();\n+                    var b3 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchER1.successor()));\n+\n+                    \/\/ Start of first exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                    });\n+                    var er2 = enterER1.op(exceptionRegionEnter(\n+                            enterER2.successor(),\n+                            catchER2.successor()));\n+\n+                    \/\/ Start of second exception region\n+                    enterER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of second exception region\n+                        b.op(exceptionRegionExit(er2, b3.successor()));\n+                    });\n+\n+                    \/\/ Catch block for second exception region\n+                    catchER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(b3.successor()));\n+                    });\n+\n+                    b3.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of first exception region\n+                        b.op(exceptionRegionExit(er1, end.successor()));\n+                    });\n+\n+                    \/\/ Catch block for first exception region\n+                    catchER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 4))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 5))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testNestedF);\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+            if (i == 4) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 5) throw new RuntimeException();\n+        });\n+    }\n+\n+    public void testCatchFinallyF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = func(\"f\", methodType(void.class, IntConsumer.class))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchRE = fblock.block(TypeDesc.type(IllegalStateException.class));\n+                    var catchAll = fblock.block(TypeDesc.type(Throwable.class));\n+                    var enterER1 = fblock.block();\n+                    var exitER1 = fblock.block();\n+                    var enterER2 = fblock.block();\n+                    var exitER2 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchRE.successor(), catchAll.successor()));\n+\n+                    \/\/ Start of exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er1, exitER1.successor()));\n+                    });\n+                    \/\/ Inline finally\n+                    exitER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Catch block for RuntimeException\n+                    var er2 = catchRE.op(exceptionRegionEnter(\n+                            enterER2.successor(),\n+                            catchAll.successor()));\n+                    \/\/ Start of exception region\n+                    enterER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er2, exitER2.successor()));\n+                    });\n+                    \/\/ Inline finally\n+                    exitER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Catch all block for finally\n+                    catchAll.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_throw(catchAll.parameters().get(0)));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testCatchFinallyF\n+                );\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+    }\n+\n+    static final MethodDesc INT_CONSUMER_ACCEPT_METHOD = MethodDesc.method(type(IntConsumer.class), \"accept\",\n+            VOID, INT);\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestForOp\n+ *\/\n+\n+public class TestForOp {\n+\n+    @CodeReflection\n+    public static int f() {\n+        int j = 0;\n+        for (int i = 0; i < 10; i++) {\n+            j += i;\n+        }\n+        return j;\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f());\n+    }\n+\n+    @CodeReflection\n+    public static int f2() {\n+        int k = 0;\n+        for (int i = 0, j = 0; i < 10; i++, j++) {\n+            k += i;\n+            k += j;\n+        }\n+        return k;\n+    }\n+\n+    @Test\n+    public void testf2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f2());\n+    }\n+\n+    @CodeReflection\n+    public static int f3() {\n+        int k = 0;\n+        int i = 0;\n+        int j = 0;\n+        for (i = 0, j = 0; i < 10; i++, j++) {\n+            k += i;\n+            k += j;\n+        }\n+        return k;\n+    }\n+\n+    @Test\n+    public void testf3() {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f3());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestForOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestIfOp\n+ *\/\n+\n+public class TestIfOp {\n+\n+    @CodeReflection\n+    public static String f(int i) {\n+        String s;\n+        if (i <= 1) {\n+            s = \"<=ONE\";\n+        } else if (i == 2) {\n+            s = \"TWO\";\n+        } else if (i == 3) {\n+            s = \"THREE\";\n+        } else if (i == 4) {\n+            s = \"FOUR\";\n+        } else {\n+            s = \">=FIVE\";\n+        }\n+        return s;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestIfOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int i = 0; i < 6; i++) {\n+            Assert.assertEquals(Interpreter.invoke(lf, i), f(i));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+\n+\/*\n+ * @test\n+ * @run testng TestInline\n+ *\/\n+\n+public class TestInline {\n+\n+    @Test\n+    public void testInline() {\n+        Quoted q = (int a, int b) -> a + b;\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    var cb = fblock.inline(cop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    Assert.assertEquals(fblock, cb);\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineVar() {\n+        Quoted q = (int a, int b) -> a + b;\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    Op.Result v = fblock.op(var(INT, fblock.op(constant(INT, 0))));\n+\n+                    var cb = fblock.inline(cop, List.of(i, fortyTwo), (b, value) -> {\n+                        b.op(varStore(v, value));\n+                    });\n+                    Assert.assertEquals(fblock, cb);\n+\n+                    fblock.op(_return(fblock.op(varLoad(v))));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+\n+    @Test\n+    public void testInlineLowerMultipleReturn() {\n+        Quoted q = (int a, int b) ->  {\n+            if (a < 10) {\n+                return a + b;\n+            }\n+            return a - b;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+        cop.writeTo(System.out);\n+        CoreOps.ClosureOp lcop = cop.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lcop.writeTo(System.out);\n+\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    var cb = fblock.inline(lcop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    Assert.assertNotEquals(fblock, cb);\n+                });\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineLowerMultipleReturnVar() {\n+        Quoted q = (int a, int b) ->  {\n+            if (a < 10) {\n+                return a + b;\n+            }\n+            return a - b;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+        cop.writeTo(System.out);\n+        CoreOps.ClosureOp lcop = cop.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lcop.writeTo(System.out);\n+\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    Op.Result v = fblock.op(var(INT, fblock.op(constant(INT, 0))));\n+\n+                    var cb = fblock.inline(lcop, List.of(i, fortyTwo), (b, value) -> {\n+                        b.op(varStore(v, value));\n+                    });\n+                    Assert.assertNotEquals(fblock, cb);\n+\n+                    cb.op(_return(cb.op(varLoad(v))));\n+                });\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineMultipleReturnLower() {\n+        Quoted q = (int a, int b) ->  {\n+            if (a < 10) {\n+                return a + b;\n+            }\n+            return a - b;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+        cop.writeTo(System.out);\n+\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    var cb = fblock.inline(cop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    Assert.assertEquals(fblock, cb);\n+                });\n+        f.writeTo(System.out);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineVoid() {\n+        Quoted q = (int[] a) -> {\n+            a[0] = 42;\n+            return;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int[].class, int.class))\n+                .body(fblock -> {\n+                    Block.Parameter a = fblock.parameters().get(0);\n+\n+                    var cb = fblock.inline(cop, List.of(a), Block.Builder.INLINE_RETURN);\n+                    Assert.assertEquals(fblock, cb);\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int[] a = new int[1];\n+        Interpreter.invoke(MethodHandles.lookup(), f, a);\n+        Assert.assertEquals(a[0], 42);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestLambdaOps\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.op.CoreOps.LambdaOp;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+\n+@Test\n+public class TestLambdaOps {\n+    static class Builder {\n+        static final MethodDesc ACCEPT_METHOD = MethodDesc.method(type(Builder.class), \"accept\",\n+                INT, CoreOps.QuotedOp.QUOTED_TYPE);\n+\n+        static int accept(Quoted l) {\n+            Assert.assertEquals(1, l.capturedValues().size());\n+            Assert.assertEquals(1, l.capturedValues().values().iterator().next());\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) l.op(),\n+                    l.capturedValues(), 42);\n+            return r;\n+        }\n+    }\n+\n+    @Test\n+    public void testQuotedWithCapture() {\n+        \/\/ functional descriptor = (int)int\n+        FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional descriptor = (int)int\n+                    \/\/ op descriptor = ()Quoted<LambdaOp>\n+                    QuotedOp qop = quoted(block.parentBody(), qblock -> {\n+                        return lambda(qblock.parentBody(),\n+                                methodType(int.class, int.class), type(IntUnaryOperator.class))\n+                                .body(lblock -> {\n+                                    Block.Parameter li = lblock.parameters().get(0);\n+\n+                                    lblock.op(_return(\n+                                            \/\/ capture i from function's body\n+                                            lblock.op(add(i, li))\n+                                    ));\n+                                });\n+                    });\n+                    Op.Result lquoted = block.op(qop);\n+\n+                    Op.Result or = block.op(invoke(Builder.ACCEPT_METHOD, lquoted));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    static final MethodDesc INT_UNARY_OPERATOR_METHOD = MethodDesc.method(\n+            IntUnaryOperator.class, \"applyAsInt\",\n+            int.class, int.class);\n+\n+    @Test\n+    public void testWithCapture() {\n+        \/\/ functional descriptor = (int)int\n+        FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional descriptor = (int)int\n+                    \/\/ op descriptor = ()IntUnaryOperator\n+                    \/\/   captures i\n+                    LambdaOp lambda = lambda(block.parentBody(),\n+                            methodType(int.class, int.class), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Block.Parameter li = lblock.parameters().get(0);\n+\n+                                lblock.op(_return(\n+                                        lblock.op(add(i, li))));\n+                            });\n+                    Op.Result fi = block.op(lambda);\n+\n+                    Op.Result fortyTwo = block.op(constant(INT, 42));\n+                    Op.Result or = block.op(invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    static int f(int i) {\n+        IntUnaryOperator fi = li -> {\n+            return i + li;\n+        };\n+\n+        int fortyTwo = 42;\n+        int or = fi.applyAsInt(fortyTwo);\n+        return or;\n+    }\n+\n+    @Test\n+    public void testQuotableModel() {\n+        Quotable quotable = (Runnable & Quotable) () -> {};\n+        Op qop = quotable.quoted().op();\n+        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Assert.assertTrue(top instanceof CoreOps.FuncOp);\n+\n+        CoreOps.FuncOp fop = (CoreOps.FuncOp) top;\n+        Assert.assertEquals(TypeDesc.type(Quoted.class, LambdaOp.class), fop.funcDescriptor().returnType());\n+    }\n+\n+    @FunctionalInterface\n+    public interface QuotableIntSupplier extends IntSupplier, Quotable {\n+    }\n+\n+    @CodeReflection\n+    static QuotableIntSupplier quote(int i) {\n+        QuotableIntSupplier s = () -> i;\n+        return s;\n+    }\n+\n+    @Test\n+    public void testQuote() {\n+        FuncOp g = getFuncOp(\"quote\");\n+        g.writeTo(System.out);\n+\n+        {\n+            QuotableIntSupplier op = (QuotableIntSupplier) Interpreter.invoke(MethodHandles.lookup(), g, 42);\n+            Assert.assertEquals(op.getAsInt(), 42);\n+\n+            Quoted q = op.quoted();\n+            q.op().writeTo(System.out);\n+            Assert.assertEquals(q.capturedValues().size(), 1);\n+            Assert.assertEquals(((Var<?>)q.capturedValues().values().iterator().next()).value(), 42);\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), q.capturedValues(), List.of());\n+            Assert.assertEquals(r, 42);\n+\n+            Map<Value, Object> cvs = Map.of(\n+                    q.capturedValues().keySet().iterator().next(),\n+                    CoreOps.Var.of(0)\n+            );\n+            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), cvs, List.of());\n+            Assert.assertEquals(r, 0);\n+        }\n+\n+        {\n+            QuotableIntSupplier op = quote(42);\n+            Assert.assertEquals(op.getAsInt(), 42);\n+\n+            Quoted q = op.quoted();\n+            q.op().writeTo(System.out);\n+            System.out.print(q.capturedValues().values());\n+            Assert.assertEquals(q.capturedValues().size(), 1);\n+            Assert.assertEquals(((Var<?>)q.capturedValues().values().iterator().next()).value(), 42);\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), q.capturedValues(), List.of());\n+            Assert.assertEquals(r, 42);\n+\n+            Map<Value, Object> cvs = Map.of(\n+                    q.capturedValues().keySet().iterator().next(),\n+                    CoreOps.Var.of(0)\n+            );\n+            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), cvs, List.of());\n+            Assert.assertEquals(r, 0);\n+        }\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestLambdaOps.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n+\/*\n+ * @test\n+ * @run testng TestLinq\n+ *\/\n+\n+public class TestLinq {\n+\n+    \/\/ Query interfaces\n+\n+    public interface Queryable {\n+        TypeDesc elementType();\n+\n+        \/\/ Queryable<T> -> Queryable<U>\n+        FuncOp expression();\n+\n+        QueryProvider provider();\n+\n+        \/\/ T -> boolean\n+        \/\/ Predicate<T>\n+        default Queryable where(Quoted f) {\n+            \/\/ @@@@ validate\n+            ClosureOp c = (ClosureOp) f.op();\n+            return insertQuery(elementType(), \"where\", c);\n+        }\n+\n+        \/\/ T -> R\n+        \/\/ Function<T, R>\n+        default Queryable select(Quoted f) {\n+            \/\/ @@@@ validate\n+            ClosureOp c = (ClosureOp) f.op();\n+            return insertQuery(c.funcDescriptor().returnType(), \"select\", c);\n+        }\n+\n+        private Queryable insertQuery(TypeDesc et, String name, ClosureOp c) {\n+            QueryProvider qp = provider();\n+\n+            FuncOp currentQueryExpression = expression();\n+            FuncOp nextQueryExpression = currentQueryExpression.transform((block, op) -> {\n+                if (op instanceof ReturnOp rop && rop.ancestorBody() == currentQueryExpression.body()) {\n+                    Value query = block.context().getValue(rop.returnValue());\n+\n+                    Op.Result quotedLambda = block.op(quoted(block.parentBody(), qblock -> c));\n+\n+                    MethodDesc md = method(qp.queryableType(), name,\n+                            methodType(qp.queryableType(), QuotedOp.QUOTED_TYPE));\n+                    Op.Result queryable = block.op(invoke(md, query, quotedLambda));\n+\n+                    block.op(_return(queryable));\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            });\n+\n+            return qp.createQuery(et, nextQueryExpression);\n+        }\n+\n+        \/\/ Iterate\n+        \/\/ Queryable -> Stream\n+        default QueryResult elements() {\n+            TypeDesc resultType = type(type(Stream.class), elementType());\n+            return insertQueryResult(\"elements\", resultType);\n+        }\n+\n+        \/\/ Count\n+        \/\/ Queryable -> Long\n+        default QueryResult count() {\n+            return insertQueryResult(\"count\", TypeDesc.LONG);\n+        }\n+\n+        private QueryResult insertQueryResult(String name, TypeDesc resultType) {\n+            QueryProvider qp = provider();\n+\n+            \/\/ Copy function expression, replacing return type\n+            FuncOp currentQueryExpression = expression();\n+            FuncOp nextQueryExpression = func(\"queryresult\",\n+                    methodType(qp.queryResultType(), currentQueryExpression.funcDescriptor().parameters()))\n+                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n+                        MethodDesc md = method(qp.queryableType(), name, methodType(qp.queryResultType()));\n+                        Op.Result queryResult = block.op(invoke(md, query));\n+\n+                        block.op(_return(queryResult));\n+                    }));\n+            return qp.createQueryResult(resultType, nextQueryExpression);\n+        }\n+    }\n+\n+    public interface QueryResult {\n+        TypeDesc resultType();\n+\n+        \/\/ Queryable -> QueryResult\n+        FuncOp expression();\n+\n+        Object execute();\n+    }\n+\n+    public interface QueryProvider {\n+        TypeDesc queryableType();\n+\n+        TypeDesc queryResultType();\n+\n+        Queryable createQuery(TypeDesc elementType, FuncOp expression);\n+\n+        QueryResult createQueryResult(TypeDesc resultType, FuncOp expression);\n+\n+        Queryable newQuery(TypeDesc elementType);\n+    }\n+\n+\n+    \/\/ Query implementation\n+\n+    public static final class TestQueryable implements Queryable {\n+        final TypeDesc elementType;\n+        final TestQueryProvider provider;\n+        final FuncOp expression;\n+\n+        TestQueryable(TypeDesc elementType, TestQueryProvider provider) {\n+            this.elementType = elementType;\n+            this.provider = provider;\n+\n+            \/\/ Initial expression is an identity function\n+            var funDescriptor = methodType(provider().queryableType(), provider().queryableType());\n+            this.expression = func(\"query\", funDescriptor)\n+                    .body(b -> b.op(_return(b.parameters().get(0))));\n+        }\n+\n+        TestQueryable(TypeDesc elementType, TestQueryProvider provider, FuncOp expression) {\n+            this.elementType = elementType;\n+            this.provider = provider;\n+            this.expression = expression;\n+        }\n+\n+        @Override\n+        public TypeDesc elementType() {\n+            return elementType;\n+        }\n+\n+        @Override\n+        public FuncOp expression() {\n+            return expression;\n+        }\n+\n+        @Override\n+        public QueryProvider provider() {\n+            return provider;\n+        }\n+    }\n+\n+    public record TestQueryResult(TypeDesc resultType, FuncOp expression) implements QueryResult {\n+        @Override\n+        public Object execute() {\n+            \/\/ @@@ Compile\/translate the expression and execute it\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static final class TestQueryProvider implements QueryProvider {\n+        final TypeDesc queryableType;\n+        final TypeDesc queryResultType;\n+\n+        TestQueryProvider() {\n+            this.queryableType = TypeDesc.type(Queryable.class);\n+            this.queryResultType = TypeDesc.type(QueryResult.class);\n+        }\n+\n+        @Override\n+        public TypeDesc queryableType() {\n+            return queryableType;\n+        }\n+\n+        @Override\n+        public TypeDesc queryResultType() {\n+            return queryResultType;\n+        }\n+\n+        @Override\n+        public TestQueryable createQuery(TypeDesc elementType, FuncOp expression) {\n+            return new TestQueryable(elementType, this, expression);\n+        }\n+\n+        @Override\n+        public QueryResult createQueryResult(TypeDesc resultType, FuncOp expression) {\n+            return new TestQueryResult(resultType, expression);\n+        }\n+\n+        @Override\n+        public Queryable newQuery(TypeDesc elementType) {\n+            return new TestQueryable(elementType, this);\n+        }\n+    }\n+\n+\n+    static class Customer {\n+        \/\/ 1st column\n+        String contactName;\n+        \/\/ 2nd column\n+        String phone;\n+        \/\/ 3rd column\n+        String city;\n+    }\n+\n+    @Test\n+    public void testSimpleQuery() {\n+        QueryProvider qp = new TestQueryProvider();\n+\n+        QueryResult qr = qp.newQuery(type(Customer.class))\n+                \/\/ c -> c.city.equals(\"London\")\n+                .where((Customer c) -> c.city.equals(\"London\"))\n+                \/\/ c -> c.contactName\n+                .select((Customer c) -> c.contactName).elements();\n+\n+        qr.expression().writeTo(System.out);\n+\n+        QueryResult qr2 = (QueryResult) Interpreter.invoke(MethodHandles.lookup(),\n+                qr.expression(), qp.newQuery(type(Customer.class)));\n+\n+        qr2.expression().writeTo(System.out);\n+\n+        Assert.assertEquals(qr.expression().toText(), qr2.expression().toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinq.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n+\/*\n+ * @test\n+ * @run testng TestLinqUsingQuotable\n+ *\/\n+\n+public class TestLinqUsingQuotable {\n+\n+    \/\/ Quotable functional interfaces\n+\n+    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+    }\n+\n+    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+    }\n+\n+\n+    \/\/ Query interfaces\n+\n+    public interface Queryable<T> {\n+        TypeDesc elementType();\n+\n+        \/\/ Queryable<T> -> Queryable<U>\n+        FuncOp expression();\n+\n+        QueryProvider provider();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default Queryable<T> where(QuotablePredicate<T> f) {\n+            LambdaOp l = (LambdaOp) f.quoted().op();\n+            return (Queryable<T>) insertQuery(elementType(), \"where\", l);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default <R> Queryable<R> select(QuotableFunction<T, R> f) {\n+            LambdaOp l = (LambdaOp) f.quoted().op();\n+            return (Queryable<R>) insertQuery(l.funcDescriptor().returnType(), \"select\", l);\n+        }\n+\n+        private Queryable<?> insertQuery(TypeDesc elementType, String methodName, LambdaOp lambdaOp) {\n+            QueryProvider qp = provider();\n+\n+            \/\/ Copy function expression, replacing return operation\n+            FuncOp currentQueryExpression = expression();\n+            TypeDesc queryableType = TypeDesc.type(qp.queryableType(), elementType);\n+            FuncOp nextQueryExpression = func(\"query\",\n+                    methodType(queryableType, currentQueryExpression.funcDescriptor().parameters()))\n+                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n+                        Op.Result fi = block.op(lambdaOp);\n+\n+                        MethodDesc md = method(qp.queryableType(), methodName,\n+                                methodType(qp.queryableType(), lambdaOp.functionalInterface()).erase());\n+                        Op.Result queryable = block.op(invoke(queryableType, md, query, fi));\n+\n+                        block.op(_return(queryable));\n+                    }));\n+\n+            return qp.createQuery(elementType, nextQueryExpression);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default QueryResult<Stream<T>> elements() {\n+            TypeDesc resultType = type(type(Stream.class), elementType());\n+            return (QueryResult<Stream<T>>) insertQueryResult(resultType, \"elements\");\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default QueryResult<Long> count() {\n+            return (QueryResult<Long>) insertQueryResult(TypeDesc.LONG, \"count\");\n+        }\n+\n+        private QueryResult<?> insertQueryResult(TypeDesc resultType, String methodName) {\n+            QueryProvider qp = provider();\n+\n+            \/\/ Copy function expression, replacing return operation\n+            FuncOp currentQueryExpression = expression();\n+            TypeDesc queryResultType = TypeDesc.type(qp.queryResultType(), resultType);\n+            FuncOp queryResultExpression = func(\"queryResult\",\n+                    methodType(queryResultType, currentQueryExpression.funcDescriptor().parameters()))\n+                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n+                        MethodDesc md = method(qp.queryableType(), methodName, methodType(qp.queryResultType()));\n+                        Op.Result queryResult = block.op(invoke(queryResultType, md, query));\n+\n+                        block.op(_return(queryResult));\n+                    }));\n+            return qp.createQueryResult(resultType, queryResultExpression);\n+        }\n+    }\n+\n+    public interface QueryResult<T> {\n+        TypeDesc resultType();\n+\n+        \/\/ Queryable<T> -> QueryResult<T>\n+        FuncOp expression();\n+\n+        Object execute();\n+    }\n+\n+    public interface QueryProvider {\n+        TypeDesc queryableType();\n+\n+        TypeDesc queryResultType();\n+\n+        Queryable<?> createQuery(TypeDesc elementType, FuncOp queryExpression);\n+\n+        QueryResult<?> createQueryResult(TypeDesc resultType, FuncOp expression);\n+\n+        <T> Queryable<T> newQuery(Class<T> elementType);\n+    }\n+\n+\n+    \/\/ Query implementation\n+\n+    public static final class TestQueryable<T> implements Queryable<T> {\n+        final TypeDesc elementType;\n+        final TestQueryProvider provider;\n+        final FuncOp expression;\n+\n+        TestQueryable(Class<T> tableClass, TestQueryProvider qp) {\n+            this.elementType = type(tableClass);\n+            this.provider = qp;\n+\n+            TypeDesc queryableType = TypeDesc.type(qp.queryableType(), elementType);\n+            \/\/ Initial expression is an identity function\n+            var funDescriptor = methodType(queryableType, queryableType);\n+            this.expression = func(\"query\", funDescriptor)\n+                    .body(b -> b.op(_return(b.parameters().get(0))));\n+        }\n+\n+        TestQueryable(TypeDesc elementType, TestQueryProvider provider, FuncOp expression) {\n+            this.elementType = elementType;\n+            this.provider = provider;\n+            this.expression = expression;\n+        }\n+\n+        @Override\n+        public TypeDesc elementType() {\n+            return elementType;\n+        }\n+\n+        @Override\n+        public FuncOp expression() {\n+            return expression;\n+        }\n+\n+        @Override\n+        public QueryProvider provider() {\n+            return provider;\n+        }\n+    }\n+\n+    public record TestQueryResult<T>(TypeDesc resultType, FuncOp expression) implements QueryResult<T> {\n+        @Override\n+        public Object execute() {\n+            \/\/ @@@ Compile\/translate the expression and execute it\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static final class TestQueryProvider implements QueryProvider {\n+        final TypeDesc queryableType;\n+        final TypeDesc queryResultType;\n+\n+        TestQueryProvider() {\n+            this.queryableType = TypeDesc.type(Queryable.class);\n+            this.queryResultType = TypeDesc.type(QueryResult.class);\n+        }\n+\n+        @Override\n+        public TypeDesc queryableType() {\n+            return queryableType;\n+        }\n+\n+        @Override\n+        public TypeDesc queryResultType() {\n+            return queryResultType;\n+        }\n+\n+        @Override\n+        public Queryable<?> createQuery(TypeDesc elementType, FuncOp expression) {\n+            return new TestQueryable<>(elementType, this, expression);\n+        }\n+\n+        @Override\n+        public QueryResult<?> createQueryResult(TypeDesc resultType, FuncOp expression) {\n+            return new TestQueryResult<>(resultType, expression);\n+        }\n+\n+        @Override\n+        public <T> Queryable<T> newQuery(Class<T> elementType) {\n+            return new TestQueryable<>(elementType, this);\n+        }\n+    }\n+\n+\n+    static class Customer {\n+        \/\/ 1st column\n+        String contactName;\n+        \/\/ 2nd column\n+        String phone;\n+        \/\/ 3rd column\n+        String city;\n+    }\n+\n+    @Test\n+    public void testSimpleQuery() {\n+        QueryProvider qp = new TestQueryProvider();\n+\n+        QueryResult<Stream<String>> qr = qp.newQuery(Customer.class)\n+                .where(c -> c.city.equals(\"London\"))\n+                .select(c -> c.contactName).elements();\n+\n+        qr.expression().writeTo(System.out);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QueryResult<Stream<String>> qr2 = (QueryResult<Stream<String>>) Interpreter.invoke(MethodHandles.lookup(),\n+                qr.expression(), qp.newQuery(Customer.class));\n+\n+        qr2.expression().writeTo(System.out);\n+\n+        Assert.assertEquals(qr.expression().toText(), qr2.expression().toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuotable.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestLiveness\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TestLiveness {\n+\n+    static final String F = \"\"\"\n+            func @\"f\" (%0 : int, %1 : int)int -> {\n+                %2 : int = add %0 %1;\n+                return %2;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testF() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, F).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of()));\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String IF_ELSE = \"\"\"\n+            func @\"ifelse\" (%0 : int, %1 : int, %2 : int)int -> {\n+                %3 : int = constant @\"10\";\n+                %4 : boolean = lt %2 %3;\n+                cbranch %4 ^block_0 ^block_1;\n+\n+              ^block_0:\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %0 %5;\n+                branch ^block_2(%6, %1);\n+\n+              ^block_1:\n+                %7 : int = constant @\"2\";\n+                %8 : int = add %1 %7;\n+                branch ^block_2(%0, %8);\n+\n+              ^block_2(%9 : int, %10 : int):\n+                %11 : int = add %9 %10;\n+                return %11;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testIfElse() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, IF_ELSE).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0, 1)),\n+                1, List.of(Set.of(0, 1), Set.of()),\n+                2, List.of(Set.of(0, 1), Set.of()),\n+                3, List.of(Set.of(), Set.of())\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String LOOP = \"\"\"\n+            func @\"loop\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : int = constant @\"0\";\n+                branch ^block_0(%1, %2);\n+\n+              ^block_0(%3 : int, %4 : int):\n+                %5 : boolean = lt %4 %0;\n+                cbranch %5 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %6 : int = add %3 %4;\n+                branch ^block_3;\n+\n+              ^block_3:\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %4 %7;\n+                branch ^block_0(%6, %8);\n+\n+              ^block_2:\n+                return %3;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testLoop() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, LOOP).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0)),\n+                1, List.of(Set.of(0), Set.of(0, 3, 4)),\n+                2, List.of(Set.of(0, 3, 4), Set.of(0, 4, 6)),\n+                3, List.of(Set.of(3), Set.of()),\n+                4, List.of(Set.of(0, 4, 6), Set.of(0))\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String IF_ELSE_NESTED = \"\"\"\n+            func @\"ifelseNested\" (%0 : int, %1 : int, %2 : int, %3 : int, %4 : int)int -> {\n+                %5 : int = constant @\"20\";\n+                %6 : boolean = lt %4 %5;\n+                cbranch %6 ^block_0 ^block_1;\n+\n+              ^block_0:\n+                %7 : int = constant @\"10\";\n+                %8 : boolean = lt %4 %7;\n+                cbranch %8 ^block_2 ^block_3;\n+\n+              ^block_2:\n+                %9 : int = constant @\"1\";\n+                %10 : int = add %0 %9;\n+                branch ^block_4(%10, %1);\n+\n+              ^block_3:\n+                %11 : int = constant @\"2\";\n+                %12 : int = add %1 %11;\n+                branch ^block_4(%0, %12);\n+\n+              ^block_4(%13 : int, %14 : int):\n+                %15 : int = constant @\"3\";\n+                %16 : int = add %2 %15;\n+                branch ^block_5(%13, %14, %16, %3);\n+\n+              ^block_1:\n+                %17 : int = constant @\"20\";\n+                %18 : boolean = gt %4 %17;\n+                cbranch %18 ^block_6 ^block_7;\n+\n+              ^block_6:\n+                %19 : int = constant @\"4\";\n+                %20 : int = add %0 %19;\n+                branch ^block_8(%20, %1);\n+\n+              ^block_7:\n+                %21 : int = constant @\"5\";\n+                %22 : int = add %1 %21;\n+                branch ^block_8(%0, %22);\n+\n+              ^block_8(%23 : int, %24 : int):\n+                %25 : int = constant @\"6\";\n+                %26 : int = add %3 %25;\n+                branch ^block_5(%23, %24, %2, %26);\n+\n+              ^block_5(%27 : int, %28 : int, %29 : int, %30 : int):\n+                %31 : int = add %27 %28;\n+                %32 : int = add %31 %29;\n+                %33 : int = add %32 %30;\n+                return %33;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testIfElseNested() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, IF_ELSE_NESTED).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0, 1, 2, 3, 4)),\n+                1, List.of(Set.of(0, 1, 2, 3, 4), Set.of(0, 1, 2, 3)),\n+                2, List.of(Set.of(0, 1, 2, 3, 4), Set.of(0, 1, 2, 3)),\n+                3, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                4, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                5, List.of(Set.of(2, 3), Set.of()),\n+                6, List.of(Set.of(), Set.of()),\n+                7, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                8, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                9, List.of(Set.of(2, 3), Set.of())\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String LOOP_NESTED = \"\"\"\n+            func @\"loopNested\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : int = constant @\"0\";\n+                branch ^block_0(%1, %2);\n+\n+              ^block_0(%3 : int, %4 : int):\n+                %5 : boolean = lt %4 %0;\n+                cbranch %5 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %6 : int = constant @\"0\";\n+                branch ^block_3(%3, %6);\n+\n+              ^block_3(%7 : int, %8 : int):\n+                %9 : boolean = lt %8 %0;\n+                cbranch %9 ^block_4 ^block_5;\n+\n+              ^block_4:\n+                %10 : int = add %7 %4;\n+                %11 : int = add %10 %8;\n+                branch ^block_6;\n+\n+              ^block_6:\n+                %12 : int = constant @\"1\";\n+                %13 : int = add %8 %12;\n+                branch ^block_3(%11, %13);\n+\n+              ^block_5:\n+                branch ^block_7;\n+\n+              ^block_7:\n+                %14 : int = constant @\"1\";\n+                %15 : int = add %4 %14;\n+                branch ^block_0(%7, %15);\n+\n+              ^block_2:\n+                return %3;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testLoopNested() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, LOOP_NESTED).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0)),\n+                1, List.of(Set.of(0), Set.of(0, 3, 4)),\n+                2, List.of(Set.of(0, 3, 4), Set.of(0, 4)),\n+                3, List.of(Set.of(3), Set.of()),\n+                4, List.of(Set.of(0, 4), Set.of(0, 4, 7, 8)),\n+                5, List.of(Set.of(0, 4, 7, 8), Set.of(0, 4, 8, 11)),\n+                6, List.of(Set.of(0, 4, 7), Set.of(0, 4, 7)),\n+                7, List.of(Set.of(0, 4, 8, 11), Set.of(0, 4)),\n+                8, List.of(Set.of(0, 4, 7), Set.of(0))\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static Map<Integer, List<Set<Integer>>> liveness(Op op) {\n+        Liveness l = new Liveness(op);\n+        System.out.println(l);\n+\n+        Map<Value, Integer> valueMap = valueNameMapping(op);\n+        Map<Block, Integer> blockMap = blockNameMapping(op);\n+\n+        return op.traverse(new HashMap<>(),\n+                CodeElement.blockVisitor((m, b) -> {\n+                    if (b.parentBody().parentOp() == op) {\n+                        Liveness.BlockInfo lbi = l.getLiveness(b);\n+                        m.put(blockMap.get(b),\n+                                List.of(\n+                                        lbi.liveIn().stream().map(valueMap::get).collect(Collectors.toSet()),\n+                                        lbi.liveOut().stream().map(valueMap::get).collect(Collectors.toSet())\n+                                ));\n+                    }\n+                    return m;\n+                }));\n+    }\n+\n+    static Map<Block, Integer> blockNameMapping(Op top) {\n+        AtomicInteger i = new AtomicInteger();\n+        return top.traverse(new HashMap<>(), CodeElement.blockVisitor((m, b) -> {\n+            if (b.parentBody().parentOp() != top) {\n+                return m;\n+            }\n+\n+            m.computeIfAbsent(b, _ -> i.getAndIncrement());\n+            for (Block.Reference s : b.successors()) {\n+                m.computeIfAbsent(s.targetBlock(), _ -> i.getAndIncrement());\n+            }\n+\n+            return m;\n+        }));\n+    }\n+\n+    static Map<Value, Integer> valueNameMapping(Op top) {\n+        AtomicInteger i = new AtomicInteger();\n+        return top.traverse(new HashMap<>(), (m, e) -> {\n+            switch (e) {\n+                case Block b -> {\n+                    for (Block.Parameter p : b.parameters()) {\n+                        m.put(p, i.getAndIncrement());\n+                    }\n+                }\n+                case Op op -> {\n+                    Op.Result r = op.result();\n+                    if (r != null && !r.type().equals(TypeDesc.VOID)) {\n+                        m.put(r, i.getAndIncrement());\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return m;\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.PrintStream;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.arrayStoreOp;\n+import static java.lang.reflect.code.op.CoreOps.invoke;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.fieldLoad;\n+import static java.lang.reflect.code.op.CoreOps.newArray;\n+import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.descriptor.TypeDesc.J_L_STRING;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLocalTransformationsAdaption\n+ *\/\n+\n+public class TestLocalTransformationsAdaption {\n+\n+    @CodeReflection\n+    static int f(int i) {\n+        IntBinaryOperator add = (a, b) -> {\n+            return add(a, b);\n+        };\n+\n+        try {\n+            IntUnaryOperator add42 = (a) -> {\n+                return add.applyAsInt(a, 42);\n+            };\n+\n+            int j = add42.applyAsInt(i);\n+\n+            IntBinaryOperator f = (a, b) -> {\n+                if (i < 0) {\n+                    throw new RuntimeException();\n+                }\n+\n+                IntUnaryOperator g = (c) -> {\n+                    return add(a, c);\n+                };\n+\n+                return g.applyAsInt(b);\n+            };\n+\n+            return f.applyAsInt(j, j);\n+        } catch (RuntimeException e) {\n+            throw new IndexOutOfBoundsException(i);\n+        }\n+    }\n+\n+    @Test\n+    public void testInvocation() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), f, 2);\n+        Assert.assertEquals(x, f(2));\n+\n+        try {\n+            Interpreter.invoke(MethodHandles.lookup(), f, -10);\n+            Assert.fail();\n+        } catch (Throwable e) {\n+            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testFuncEntryExit() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        AtomicBoolean first = new AtomicBoolean(true);\n+        CoreOps.FuncOp fc = f.transform((block, op) -> {\n+            if (first.get()) {\n+                printConstantString(block, \"ENTRY\");\n+                first.set(false);\n+            }\n+\n+            switch (op) {\n+                case CoreOps.ReturnOp returnOp when getNearestInvokeableAncestorOp(returnOp) instanceof CoreOps.FuncOp: {\n+                    printConstantString(block, \"EXIT\");\n+                    break;\n+                }\n+                case CoreOps.ThrowOp throwOp: {\n+                    printConstantString(block, \"EXIT\");\n+                    break;\n+                }\n+                default:\n+            }\n+\n+            block.apply(op);\n+\n+            return block;\n+        });\n+        fc.writeTo(System.out);\n+\n+        fc = fc.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        fc.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), fc, 2);\n+        Assert.assertEquals(x, f(2));\n+\n+        try {\n+            Interpreter.invoke(MethodHandles.lookup(), fc, -10);\n+            Assert.fail();\n+        } catch (Throwable e) {\n+            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n+        }\n+    }\n+\n+    static void printConstantString(Function<Op, Op.Result> opBuilder, String s) {\n+        Op.Result c = opBuilder.apply(constant(J_L_STRING, s));\n+        Value System_out = opBuilder.apply(fieldLoad(FieldDesc.field(System.class, \"out\", PrintStream.class)));\n+        opBuilder.apply(CoreOps.invoke(method(PrintStream.class, \"println\", void.class, String.class), System_out, c));\n+    }\n+\n+    static Op getNearestInvokeableAncestorOp(Op op) {\n+        do {\n+            op = op.ancestorBody().parentOp();\n+        } while (!(op instanceof Op.Invokable));\n+        return op;\n+    }\n+\n+\n+    @Test\n+    public void testReplaceCall() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp fc = f.transform((block, op) -> {\n+            switch (op) {\n+                case CoreOps.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(ADD_METHOD): {\n+                    \/\/ Get the adapted operands, and pass those to the new call method\n+                    List<Value> adaptedOperands = block.context().getValues(op.operands());\n+                    Op.Result adaptedResult = block.apply(CoreOps.invoke(ADD_WITH_PRINT_METHOD, adaptedOperands));\n+                    \/\/ Map the old call result to the new call result, so existing operations can be\n+                    \/\/ adapted to use the new result\n+                    block.context().mapValue(invokeOp.result(), adaptedResult);\n+                    break;\n+                }\n+                default: {\n+                    block.apply(op);\n+                }\n+            }\n+            return block;\n+        });\n+        fc.writeTo(System.out);\n+\n+        fc = fc.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        fc.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), fc, 2);\n+        Assert.assertEquals(x, f(2));\n+    }\n+\n+\n+    @Test\n+    public void testCallEntryExit() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp fc = f.transform((block, op) -> {\n+            switch (op) {\n+                case CoreOps.InvokeOp invokeOp: {\n+                    printCall(block.context(), invokeOp, block);\n+                    break;\n+                }\n+                default: {\n+                    block.apply(op);\n+                }\n+            }\n+            return block;\n+        });\n+        fc.writeTo(System.out);\n+\n+        fc = fc.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        fc.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), fc, 2);\n+        Assert.assertEquals(x, f(2));\n+    }\n+\n+    static void printCall(CopyContext cc, CoreOps.InvokeOp invokeOp, Function<Op, Op.Result> opBuilder) {\n+        List<Value> adaptedInvokeOperands = cc.getValues(invokeOp.operands());\n+\n+        String prefix = \"ENTER\";\n+\n+        Value arrayLength = opBuilder.apply(\n+                constant(INT, adaptedInvokeOperands.size()));\n+        Value formatArray = opBuilder.apply(\n+                newArray(TypeDesc.type(Object[].class), arrayLength));\n+\n+        Value indexZero = null;\n+        for (int i = 0; i < adaptedInvokeOperands.size(); i++) {\n+            Value operand = adaptedInvokeOperands.get(i);\n+\n+            Value index = opBuilder.apply(\n+                    constant(INT, i));\n+            if (i == 0) {\n+                indexZero = index;\n+            }\n+\n+            if (operand.type().equals(INT)) {\n+                operand = opBuilder.apply(\n+                        CoreOps.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), operand));\n+                \/\/ @@@ Other primitive types\n+            }\n+            opBuilder.apply(\n+                    arrayStoreOp(formatArray, index, operand));\n+        }\n+\n+        Op.Result formatString = opBuilder.apply(\n+                constant(J_L_STRING,\n+                        prefix + \": \" + invokeOp.invokeDescriptor() + \"(\" + formatString(adaptedInvokeOperands) + \")%n\"));\n+        Value System_out = opBuilder.apply(fieldLoad(FieldDesc.field(System.class, \"out\", PrintStream.class)));\n+        opBuilder.apply(\n+                CoreOps.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n+                        System_out, formatString, formatArray));\n+\n+        \/\/ Method call\n+\n+        Op.Result adaptedInvokeResult = opBuilder.apply(invokeOp);\n+\n+        \/\/ After method call\n+\n+        prefix = \"EXIT\";\n+\n+        if (adaptedInvokeResult.type().equals(INT)) {\n+            adaptedInvokeResult = opBuilder.apply(\n+                    CoreOps.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), adaptedInvokeResult));\n+            \/\/ @@@ Other primitive types\n+        }\n+        opBuilder.apply(\n+                arrayStoreOp(formatArray, indexZero, adaptedInvokeResult));\n+\n+        formatString = opBuilder.apply(\n+                constant(J_L_STRING,\n+                        prefix + \": \" + invokeOp.invokeDescriptor() + \" -> \" + formatString(adaptedInvokeResult.type()) + \"%n\"));\n+        opBuilder.apply(\n+                CoreOps.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n+                        System_out, formatString, formatArray));\n+    }\n+\n+    static String formatString(List<Value> vs) {\n+        return vs.stream().map(v -> formatString(v.type())).collect(Collectors.joining(\",\"));\n+    }\n+\n+    static String formatString(TypeDesc t) {\n+        if (t.equals(INT)) {\n+            return \"%d\";\n+        } else {\n+            return \"%s\";\n+        }\n+    }\n+\n+\n+    static final MethodDesc ADD_METHOD = MethodDesc.method(\n+            TestLocalTransformationsAdaption.class, \"add\",\n+            int.class, int.class, int.class);\n+\n+    static int add(int a, int b) {\n+        return a + b;\n+    }\n+\n+    static final MethodDesc ADD_WITH_PRINT_METHOD = MethodDesc.method(\n+            TestLocalTransformationsAdaption.class, \"addWithPrint\",\n+            int.class, int.class, int.class);\n+\n+    static int addWithPrint(int a, int b) {\n+        System.out.printf(\"Adding %d + %d%n\", a, b);\n+        return a + b;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestLocalTransformationsAdaption.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestPatterns\n+ * @enablePreview\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestPatterns {\n+\n+    interface Point {\n+    }\n+\n+    record ConcretePoint(int x, int y) implements Point {\n+    }\n+\n+    enum Color {RED, GREEN, BLUE}\n+\n+    record ColoredPoint(ConcretePoint p, Color c) implements Point {\n+    }\n+\n+    record Rectangle(Point upperLeft, Point lowerRight) {\n+    }\n+\n+\n+    @CodeReflection\n+    public static String recordPatterns(Object r) {\n+        if (r instanceof Rectangle(\n+                ColoredPoint(ConcretePoint p, Color c),\n+                ColoredPoint lr)) {\n+            return p.toString();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    @Test\n+    public void testRecordPatterns() {\n+        CoreOps.FuncOp f = getFuncOp(\"recordPatterns\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        {\n+            Rectangle r = new Rectangle(\n+                    new ColoredPoint(new ConcretePoint(1, 2), Color.RED),\n+                    new ColoredPoint(new ConcretePoint(3, 4), Color.BLUE));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+\n+        {\n+            Rectangle r = new Rectangle(\n+                    new ColoredPoint(new ConcretePoint(1, 2), Color.RED),\n+                    new ConcretePoint(3, 4));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+\n+        {\n+            Rectangle r = new Rectangle(\n+                    new ConcretePoint(1, 2),\n+                    new ConcretePoint(3, 4));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+\n+        {\n+            String r = \"\";;\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestPatterns.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestPrimitiveCast\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public class TestPrimitiveCast {\n+\n+    static final Function<Object, String> FROM_DOUBLE = v -> fromDouble((double) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromDouble(double v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_FLOAT = v -> fromFloat((float) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromFloat(float v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_LONG = v -> fromLong((long) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromLong(long v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_INT = v -> fromInt((int) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromInt(int v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_SHORT = v -> fromShort((short) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromShort(short v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_CHAR = v -> fromChar((char) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromChar(char v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_BYTE = v -> fromByte((byte) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromByte(byte v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    @DataProvider\n+    static Object[][] fromMethods() {\n+        return new Object[][] {\n+                { \"fromDouble\", Math.PI, FROM_DOUBLE},\n+                { \"fromDouble\", 65.1, FROM_DOUBLE},\n+                { \"fromFloat\", (float) Math.PI, FROM_FLOAT},\n+                { \"fromFloat\", 65.1f, FROM_FLOAT},\n+                { \"fromLong\", Long.MAX_VALUE, FROM_LONG},\n+                { \"fromInt\", Integer.MAX_VALUE, FROM_INT},\n+                { \"fromShort\", Short.MAX_VALUE, FROM_SHORT},\n+                { \"fromChar\", Character.MAX_VALUE, FROM_CHAR},\n+                { \"fromByte\", Byte.MAX_VALUE, FROM_BYTE},\n+        };\n+    };\n+\n+    @Test(dataProvider = \"fromMethods\")\n+    public void testFromDouble(String name, Object value, Function<Object, String> m) {\n+        CoreOps.FuncOp f = getFuncOp(name);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, value), m.apply(value));\n+    }\n+\n+\n+    static String collect(Object... values) {\n+        return Stream.of(values).map(Object::toString).collect(joining(\" \"));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestPrimitiveCast.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSSA\n+ *\/\n+\n+public class TestSSA {\n+\n+    @CodeReflection\n+    static int ifelse(int a, int b, int n) {\n+        if (n < 10) {\n+            a += 1;\n+        } else {\n+            b += 2;\n+        }\n+        return a + b;\n+    }\n+\n+    @Test\n+    public void testIfelse() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelse\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 1), ifelse(0, 0, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 11), ifelse(0, 0, 11));\n+    }\n+\n+    @CodeReflection\n+    static int ifelseNested(int a, int b, int c, int d, int n) {\n+        if (n < 20) {\n+            if (n < 10) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (n > 20) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @Test\n+    public void testIfelseNested() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelseNested\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        for (int i : new int[]{1, 11, 20, 21}) {\n+            Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 0, 0, i), ifelseNested(0, 0, 0, 0, i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + i;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testLoop() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"loop\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 10), loop(10));\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int n) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testNestedLoop() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"nestedLoop\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 10), nestedLoop(10));\n+    }\n+\n+    static CoreOps.FuncOp generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+        return lf;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSSA.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTry\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTry {\n+\n+    @CodeReflection\n+    public static void catching(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatching() {\n+        CoreOps.FuncOp f = getFuncOp(\"catching\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTry::catching);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new NullPointerException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchThrowable(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (Throwable e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrowable() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrowable\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTry::catchThrowable);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchNested(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            try {\n+                c.accept(1);\n+                c.accept(-1);\n+            } catch (IllegalStateException e) {\n+                consume(e);\n+                c.accept(2);\n+                c.accept(-1);\n+            }\n+            c.accept(3);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(4);\n+            c.accept(-1);\n+        }\n+        c.accept(5);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchNested() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchNested\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTry::catchNested);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+            if (i == 4) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 5) throw new RuntimeException();\n+        });\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static void consume(Throwable e) {\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinally\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTryFinally {\n+\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::tryCatchFinally\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            return;\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testTryReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryReturn\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::tryReturn\n+                );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchThrow(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+            throw e;\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrow() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrow\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::catchThrow\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void finallyReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+            return;\n+        }\n+    }\n+\n+    @Test\n+    public void finallyReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"finallyReturn\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::finallyReturn\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    static void test(Consumer<IntConsumer> test) {\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinallyNested\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTryFinallyNested {\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c, int i) {\n+        try {\n+            try {\n+                if (i == 0) {\n+                    return;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    return;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    return;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                return;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                return;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                return;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryCatchFinally(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea < 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryForLoop(IntConsumer c) {\n+        for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            try {\n+                if (i == 4) {\n+                    continue;\n+                } else if (i == 5) {\n+                    break;\n+                }\n+                c.accept(1);\n+            } finally {\n+                c.accept(2);\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testTryForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryForLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinallyNested::tryForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLabeledForLoop(IntConsumer c) {\n+        a: for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            b: {\n+                try {\n+                    if (i == 4) {\n+                        continue a;\n+                    } else if (i == 5) {\n+                        break b;\n+                    } else if (i == 6) {\n+                        break a;\n+                    }\n+                    c.accept(1);\n+                } finally {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            }\n+            c.accept(4);\n+        }\n+        c.accept(5);\n+    }\n+\n+    @Test\n+    public void testTryLabeledForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinallyNested::tryLabeledForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLambda(IntConsumer c, int i) {\n+        try {\n+            c.accept(0);\n+            Runnable r = () -> {\n+                if (i == 0) {\n+                    c.accept(1);\n+                    return;\n+                } else {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            };\n+            r.run();\n+            c.accept(4);\n+        } finally {\n+            c.accept(5);\n+        }\n+    }\n+\n+    @Test\n+    public void testTryLambda() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryLambda\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = 0; ra < 2; ra++) {\n+            final int fra = ra;\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryLambda(c, fra)\n+            );\n+            test.accept(i -> { });\n+        }\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinallyNested.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestUsesDependsOn\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+public class TestUsesDependsOn {\n+\n+    static final String OP = \"\"\"\n+            func @\"f\" (%0 : int, %1 : int)int -> {\n+                %2 : int = add %0 %1;\n+                %3 : boolean = lt %0 %1;\n+                %4 : void = cbranch %3 ^b1(%2, %2) ^b2(%0, %1);\n+\n+              ^b1(%5 : int, %6 : int):\n+                %7 : void = return %5;\n+\n+              ^b2(%8 : int, %9 : int):\n+                %10 : void = return %8;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testDependsOn() {\n+        Op f = OpParser.fromStringOfFuncOp(OP);\n+\n+        Map<String, List<String>> dependsUpon = computeValueMap(f, Value::dependsOn);\n+\n+        var expected = Map.ofEntries(\n+                Map.entry(\"0\", List.of()),\n+                Map.entry(\"1\", List.of()),\n+                Map.entry(\"2\", List.of(\"0\", \"1\")),\n+                Map.entry(\"3\", List.of(\"0\", \"1\")),\n+                Map.entry(\"4\", List.of(\"3\", \"2\", \"0\", \"1\")),\n+                Map.entry(\"5\", List.of()),\n+                Map.entry(\"6\", List.of()),\n+                Map.entry(\"7\", List.of(\"5\")),\n+                Map.entry(\"8\", List.of()),\n+                Map.entry(\"9\", List.of()),\n+                Map.entry(\"10\", List.of(\"8\"))\n+        );\n+\n+        Assert.assertEquals(dependsUpon, expected);\n+    }\n+\n+\n+    @Test\n+    public void testUses() {\n+        Op f = OpParser.fromStringOfFuncOp(OP);\n+        f.writeTo(System.out);\n+\n+        Map<String, List<String>> uses = computeValueMap(f, Value::uses);\n+\n+        var expected = Map.ofEntries(\n+                Map.entry(\"0\", List.of(\"2\", \"3\", \"4\")),\n+                Map.entry(\"1\", List.of(\"2\", \"3\", \"4\")),\n+                Map.entry(\"2\", List.of(\"4\")),\n+                Map.entry(\"3\", List.of(\"4\")),\n+                Map.entry(\"4\", List.of()),\n+                Map.entry(\"5\", List.of(\"7\")),\n+                Map.entry(\"6\", List.of()),\n+                Map.entry(\"7\", List.of()),\n+                Map.entry(\"8\", List.of(\"10\")),\n+                Map.entry(\"9\", List.of()),\n+                Map.entry(\"10\", List.of())\n+        );\n+        System.out.println(uses.toString());\n+        System.out.println(expected);\n+\n+        Assert.assertEquals(uses, expected);\n+    }\n+\n+    static Map<String, List<String>> computeValueMap(Op op, Function<Value, Set<? extends Value>> f) {\n+        AtomicInteger ai = new AtomicInteger();\n+\n+        Map<Value, String> valueNameMap = computeValues(op, new HashMap<>(), (v, m) -> {\n+            String name = Integer.toString(ai.getAndIncrement());\n+            m.put(v, name);\n+        });\n+\n+        return computeValues(op, new HashMap<>(), (v, m) -> {\n+            m.put(valueNameMap.get(v), f.apply(v).stream().map(valueNameMap::get).toList());\n+        });\n+    }\n+\n+    static <T> T computeValues(Op op, T t, BiConsumer<Value, T> c) {\n+        return op.traverse(t, (m, codeElement) -> {\n+            return switch (codeElement) {\n+                case Block b -> {\n+                    for (var a : b.parameters()) {\n+                        c.accept(a, m);\n+                    }\n+\n+                    yield m;\n+                }\n+                case Op o -> {\n+                    if (o.result() != null) {\n+                        c.accept(o.result(), m);\n+                    }\n+\n+                    yield m;\n+                }\n+                default -> m;\n+            };\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUsesDependsOn.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestWhileOp\n+ *\/\n+\n+public class TestWhileOp {\n+\n+    @CodeReflection\n+    public static int whileLoop() {\n+        int i = 0;\n+        while (i < 10) {\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+    @Test\n+    public void testWhileLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"whileLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), whileLoop());\n+    }\n+\n+    @CodeReflection\n+    public static int doWhileLoop() {\n+        int i = 0;\n+        do {\n+            i++;\n+        } while (i < 10);\n+        return i;\n+    }\n+\n+    @Test\n+    public void testDpWhileLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"doWhileLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), doWhileLoop());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestWhileOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public final class ActiveSet {\n+\n+    private ActiveSet() {\n+    }\n+\n+    \/\/ Create active value set, in order, starting from the given block parameter\n+    \/\/ following its users and following through block arguments\n+    \/\/ to block parameters, and so on until the graph is traversed.\n+\n+    public static Set<Value> activeSet(CoreOps.FuncOp f, Block.Parameter fv) {\n+        if (!f.body().blocks().get(0).parameters().contains(fv)) {\n+            throw new IllegalArgumentException(\"Arg is not defined by function\");\n+        }\n+        Deque<Value> q = new ArrayDeque<>();\n+        q.push(fv);\n+\n+        Set<Value> active = new TreeSet<>();\n+        while (!q.isEmpty()) {\n+            Value v = q.pop();\n+            if (active.contains(v)) {\n+                continue;\n+            }\n+            active.add(v);\n+\n+            \/\/ @@@ assume uses are declared in order?\n+            \/\/     if so can push to queue in reverse order\n+            for (Op.Result or : v.uses()) {\n+                q.push(or);\n+                Op op = or.op();\n+\n+                if (op instanceof Op.Terminating) {\n+                    for (Block.Reference s : op.successors()) {\n+                        for (int i = 0; i < s.arguments().size(); i++) {\n+                            if (v == s.arguments().get(i)) {\n+                                Block b = s.targetBlock();\n+                                Block.Parameter ba = b.parameters().get(i);\n+\n+                                \/\/ Processing of block arguments may result in out of order\n+                                \/\/ production of uses if two or more block arguments are added\n+                                \/\/ for the same successor argument\n+                                q.push(ba);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Ensure non-active block arguments of successors are added to the\n+        \/\/ active set for blocks with corresponding active parameters\n+        \/\/ Backtracking is not performed on the values as they are not strictly\n+        \/\/ active set but may be required for initialization purposes.\n+        Set<Value> bactive = new LinkedHashSet<>();\n+        for (Value v : active) {\n+            if (v instanceof Block.Parameter ba) {\n+                Block b = ba.declaringBlock();\n+                int i = b.parameters().indexOf(ba);\n+\n+                for (Block p : b.predecessors()) {\n+                    Op to = p.terminatingOp();\n+                    for (Block.Reference s : to.successors()) {\n+                        if (s.targetBlock() == b) {\n+                            Value arg = s.arguments().get(i);\n+                            if (!active.contains(arg)) {\n+                                bactive.add(arg);\n+                                bactive.add(to.result());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        active.addAll(bactive);\n+\n+        return active;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ActiveSet.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+\n+import static java.lang.reflect.code.op.CoreOps.sub;\n+import static java.lang.reflect.code.analysis.Patterns.*;\n+\n+public final class ExpressionElimination {\n+    private ExpressionElimination() {\n+    }\n+\n+    static final TypeDesc J_L_MATH = TypeDesc.type(Math.class);\n+\n+    static OpPattern negP(Pattern operand) {\n+        return opP(CoreOps.NegOp.class, operand);\n+    }\n+\n+    static OpPattern addP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.AddOp.class, lhs, rhs);\n+    }\n+\n+    static OpPattern mulP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.MulOp.class, lhs, rhs);\n+    }\n+\n+    public static <T extends Op> T eliminate(T f) {\n+        \/\/ Note expression elimination and other forms of analysis is simplified if first of all expressions\n+        \/\/ are normalized e.g. when they have an operand that is a constant expression\n+        \/\/ and the operation is associative such as add(0, x) -> add(x, 0)\n+\n+        var actions = multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n+                .pattern(mulP(_P(), valueP(constantP(0.0d))))\n+                .pattern(mulP(valueP(constantP(0.0d)), _P()))\n+                .pattern(addP(valueP(), constantP(0.0d)))\n+                .pattern(addP(constantP(0.0d), valueP()))\n+                .pattern(mulP(constantP(1.0d), valueP()))\n+                .pattern(mulP(valueP(), constantP(1.0d)))\n+                .target((ms, as) -> {\n+                    Value a = ms.matchedOperands().get(0);\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        cc.mapValue(ms.op().result(), cc.getValue(a));\n+                    });\n+                    return as;\n+                })\n+                \/\/ add(neg(x), y) -> sub(y, x)\n+                .pattern(addP(negP(valueP()), valueP()))\n+                .target((ms, as) -> {\n+                    Value x = ms.matchedOperands().get(0);\n+                    Value y = ms.matchedOperands().get(1);\n+\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        Op.Result r = block.op(sub(cc.getValue(y), cc.getValue(x)));\n+                        cc.mapValue(ms.op().result(), r);\n+                    });\n+                    return as;\n+                })\n+                .matchThenApply();\n+\n+        \/\/ Eliminate\n+        Op ef = f.transform(CopyContext.create(), (block, op) -> {\n+            BiConsumer<Block.Builder, Op> a = actions.get(op.result());\n+            if (a != null) {\n+                a.accept(block, op);\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+\n+        Predicate<Op> testPure = op -> {\n+            if (op instanceof Op.Pure) {\n+                return true;\n+            } else {\n+                return op instanceof CoreOps.InvokeOp c && c.invokeDescriptor().refType().equals(J_L_MATH);\n+            }\n+        };\n+\n+        while (true) {\n+            Set<Op> unused = matchUnusedPureOps(ef, testPure);\n+            if (unused.isEmpty()) {\n+                break;\n+            }\n+            \/\/ Remove unused ops\n+            ef = ef.transform(CopyContext.create(), (block, op) -> {\n+                if (!unused.contains(op)) {\n+                    block.op(op);\n+                }\n+                return block;\n+            });\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T t = (T) ef;\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ExpressionElimination.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.add;\n+import static java.lang.reflect.code.op.CoreOps.invoke;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.mul;\n+import static java.lang.reflect.code.op.CoreOps.neg;\n+import static java.lang.reflect.code.descriptor.TypeDesc.DOUBLE;\n+\n+public final class ForwardDifferentiation {\n+    final FuncOp f;\n+    final Block.Parameter ind;\n+    final TypeDesc indT;\n+\n+    final Set<Value> activeSet;\n+    final Map<Value, Value> diffValueMapping;\n+\n+    Value zero;\n+\n+    ForwardDifferentiation(FuncOp f, Block.Parameter ind) {\n+        this.f = f;\n+\n+        Block fb = f.body().entryBlock();\n+        int indI = fb.parameters().indexOf(ind);\n+        if (indI == -1) {\n+            throw new IllegalArgumentException(\"Independent argument not defined by function\");\n+        }\n+        this.ind = ind;\n+        this.indT = ind.type();\n+\n+        \/\/ Calculate the active set of dependent values for the independent value\n+        this.activeSet = ActiveSet.activeSet(f, ind);\n+        this.diffValueMapping = new HashMap<>();\n+    }\n+\n+    public static FuncOp diff(FuncOp f, Block.Parameter ind) {\n+        return new ForwardDifferentiation(f, ind).diff();\n+    }\n+\n+    FuncOp diff() {\n+        Block fb = f.body().entryBlock();\n+        int indI = fb.parameters().indexOf(ind);\n+        if (indI == -1) {\n+            throw new IllegalArgumentException(\"Independent argument not defined by function\");\n+        }\n+\n+        AtomicBoolean first = new AtomicBoolean(true);\n+        FuncOp cf = f.transform(\"d\" + f.funcName() + \"_darg\" + indI,\n+                (block, op) -> {\n+                    if (first.getAndSet(false)) {\n+                        processBlocks(block);\n+                    }\n+\n+                    if (activeSet.contains(op.result())) {\n+                        Value dor = diffOp(block, op);\n+                        diffValueMapping.put(op.result(), dor);\n+                    } else {\n+                        block.apply(op);\n+                    }\n+                    return block;\n+                });\n+\n+        return cf;\n+    }\n+\n+    void processBlocks(Block.Builder block) {\n+        \/\/ Define constants at start\n+        zero = block.op(constant(ind.type(), 0.0d));\n+        Value one = block.op(constant(ind.type(), 1.0d));\n+        diffValueMapping.put(ind, one);\n+\n+        \/\/ Append differential block arguments to blocks\n+        for (Value v : activeSet) {\n+            if (v instanceof Block.Parameter ba) {\n+                if (ba != ind) {\n+                    Block.Builder b = block.context().getBlock(ba.declaringBlock());\n+                    Block.Parameter dba = b.parameter(ba.type());\n+                    diffValueMapping.put(ba, dba);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    static final TypeDesc J_L_MATH = TypeDesc.type(Math.class);\n+    static final MethodTypeDesc D_D = MethodTypeDesc.methodType(DOUBLE, DOUBLE);\n+    static final MethodDesc J_L_MATH_SIN = MethodDesc.method(J_L_MATH, \"sin\", D_D);\n+    static final MethodDesc J_L_MATH_COS = MethodDesc.method(J_L_MATH, \"cos\", D_D);\n+\n+    Value diffOp(Block.Builder block, Op op) {\n+        return switch (op) {\n+            case CoreOps.NegOp _ -> {\n+                block.op(op);\n+\n+                \/\/ -diff(expr)\n+                Value a = op.operands().get(0);\n+                Value da = diffValueMapping.getOrDefault(a, zero);\n+\n+                yield block.op(neg(da));\n+            }\n+            case CoreOps.AddOp _ -> {\n+                block.op(op);\n+\n+                \/\/ diff(l) + diff(r)\n+                Value lhs = op.operands().get(0);\n+                Value rhs = op.operands().get(1);\n+                Value dlhs = diffValueMapping.getOrDefault(lhs, zero);\n+                Value drhs = diffValueMapping.getOrDefault(rhs, zero);\n+\n+                yield block.op(add(dlhs, drhs));\n+            }\n+            case CoreOps.MulOp _ -> {\n+                block.op(op);\n+\n+                \/\/ diff(l) * r + l * diff(r)\n+                Value lhs = op.operands().get(0);\n+                Value rhs = op.operands().get(1);\n+                Value dlhs = diffValueMapping.getOrDefault(lhs, zero);\n+                Value drhs = diffValueMapping.getOrDefault(rhs, zero);\n+\n+                Op.Result x1 = block.op(mul(dlhs, block.context().getValue(rhs)));\n+                Op.Result x2 = block.op(mul(block.context().getValue(lhs), drhs));\n+                yield block.op(add(x1, x2));\n+            }\n+            case CoreOps.ConstantOp _ -> {\n+                block.op(op);\n+                yield zero;\n+            }\n+            case CoreOps.InvokeOp c -> {\n+                MethodDesc md = c.invokeDescriptor();\n+                String operationName = null;\n+                if (md.refType().equals(J_L_MATH)) {\n+                    operationName = md.name();\n+                }\n+                if (\"sin\".equals(operationName)) {\n+                    block.op(op);\n+\n+                    \/\/ cos(expr) * diff(expr)\n+                    Value a = op.operands().get(0);\n+                    Value da = diffValueMapping.getOrDefault(a, zero);\n+\n+                    Op.Result cosx = block.op(invoke(J_L_MATH_COS, block.context().getValue(a)));\n+                    yield block.op(mul(cosx, da));\n+                } else {\n+                    throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+                }\n+            }\n+            case CoreOps.ReturnOp _ -> {\n+                \/\/ Replace\n+                Value a = op.operands().get(0);\n+                Value da = diffValueMapping.getOrDefault(a, zero);\n+\n+                yield block.op(_return(da));\n+            }\n+            case Op.BlockTerminating _ -> {\n+                op.successors().forEach(s -> adaptSuccessor(block.context(), s));\n+                yield block.op(op);\n+            }\n+            default -> throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+        };\n+    }\n+\n+    void adaptSuccessor(CopyContext cc, Block.Reference from) {\n+        List<Value> as = from.arguments().stream()\n+                .filter(activeSet::contains)\n+                .toList();\n+        if (!as.isEmpty()) {\n+            \/\/ Get the successor arguments\n+            List<Value> args = cc.getValues(from.arguments());\n+            \/\/ Append the differential value arguments, if any\n+            for (Value a : as) {\n+                Value da = diffValueMapping.get(a);\n+                args.add(da);\n+            }\n+\n+            \/\/ Map successor with appended arguments\n+            Block.Reference to = cc.getBlock(from.targetBlock()).successor(args);\n+            cc.mapSuccessor(from, to);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestForwardAutoDiff\n+ *\/\n+\n+public class TestForwardAutoDiff {\n+    static final double PI_4 = Math.PI \/ 4;\n+\n+    @Test\n+    public void testExpression() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        f = SSA.transform(f);\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 0.0, 1.0), f(0.0, 1.0));\n+        Assert.assertEquals(Interpreter.invoke(f, PI_4, PI_4), f(PI_4, PI_4));\n+\n+        Block.Parameter x = f.body().entryBlock().parameters().get(0);\n+        Block.Parameter y = f.body().entryBlock().parameters().get(1);\n+\n+        CoreOps.FuncOp dff_dx = ExpressionElimination.eliminate(ForwardDifferentiation.diff(f, x));\n+        dff_dx.writeTo(System.out);\n+        MethodHandle dff_dx_mh = generate(dff_dx);\n+        Assert.assertEquals((double) dff_dx_mh.invoke(0.0, 1.0), df_dx(0.0, 1.0));\n+        Assert.assertEquals((double) dff_dx_mh.invoke(PI_4, PI_4), df_dx(PI_4, PI_4));\n+\n+        CoreOps.FuncOp dff_dy = ExpressionElimination.eliminate(ForwardDifferentiation.diff(f, y));\n+        dff_dy.writeTo(System.out);\n+        MethodHandle dff_dy_mh = generate(dff_dy);\n+        Assert.assertEquals((double) dff_dy_mh.invoke(0.0, 1.0), df_dy(0.0, 1.0));\n+        Assert.assertEquals((double) dff_dy_mh.invoke(PI_4, PI_4), df_dy(PI_4, PI_4));\n+    }\n+\n+    @CodeReflection\n+    static double f(double x, double y) {\n+        return x * (-Math.sin(x * y) + y) * 4.0d;\n+    }\n+\n+    static double df_dx(double x, double y) {\n+        return (-Math.sin(x * y) + y - x * Math.cos(x * y) * y) * 4.0d;\n+    }\n+\n+    static double df_dy(double x, double y) {\n+        return x * (1 - Math.cos(x * y) * x) * 4.0d;\n+    }\n+\n+    @Test\n+    public void testControlFlow() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"fcf\");\n+        f.writeTo(System.out);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        f = SSA.transform(f);\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 2.0, 6), fcf(2.0, 6));\n+        Assert.assertEquals(Interpreter.invoke(f, 2.0, 5), fcf(2.0, 5));\n+        Assert.assertEquals(Interpreter.invoke(f, 2.0, 4), fcf(2.0, 4));\n+\n+        Block.Parameter x = f.body().entryBlock().parameters().get(0);\n+\n+        CoreOps.FuncOp df_dx = ForwardDifferentiation.diff(f, x);\n+        df_dx.writeTo(System.out);\n+        MethodHandle df_dx_mh = generate(df_dx);\n+\n+        Assert.assertEquals((double) df_dx_mh.invoke(2.0, 6), dfcf_dx(2.0, 6));\n+        Assert.assertEquals((double) df_dx_mh.invoke(2.0, 5), dfcf_dx(2.0, 5));\n+        Assert.assertEquals((double) df_dx_mh.invoke(2.0, 4), dfcf_dx(2.0, 4));\n+    }\n+\n+    @CodeReflection\n+    static double fcf(\/* independent *\/ double x, int y) {\n+        \/* dependent *\/\n+        double o = 1.0;\n+        for (int i = 0; i < y; i = i + 1) {\n+            if (i > 1) {\n+                if (i < 5) {\n+                    o = o * x;\n+                }\n+            }\n+        }\n+        return o;\n+    }\n+\n+    static double dfcf_dx(\/* independent *\/ double x, int y) {\n+        double d_o = 0.0;\n+        double o = 1.0;\n+        for (int i = 0; i < y; i = i + 1) {\n+            if (i > 1) {\n+                if (i < 5) {\n+                    d_o = d_o * x + o * 1.0;\n+                    o = o * x;\n+                }\n+            }\n+        }\n+        return d_o;\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(f);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestForwardAutoDiff.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCreation\n+ *\/\n+\n+public class TestArrayCreation {\n+    @CodeReflection\n+    public static String[] f() {\n+        return new String[10];\n+    }\n+\n+    @Test\n+    public void testf() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[]) mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f2() {\n+        return new String[10][];\n+    }\n+\n+    @Test\n+    public void testf2() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[][]) mh.invoke(), f2());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f3() {\n+        return new String[10][10];\n+    }\n+\n+    @Test\n+    public void testf3() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[][]) mh.invoke(), f3());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f4() {\n+        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n+    }\n+\n+    @Test\n+    public void testf4() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f4\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[][]) mh.invoke(), f4());\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestLiftArrayCreation\n+ *\/\n+\n+public class TestLiftArrayCreation {\n+    @CodeReflection\n+    public static String[] f() {\n+        return new String[10];\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        byte[] classdata = generate(f);\n+\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(fliftcore), f());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f2() {\n+        return new String[10][];\n+    }\n+\n+    @Test\n+    public void testf2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+        byte[] classdata = generate(f);\n+\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f2\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(fliftcore), f2());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f3() {\n+        return new String[10][5];\n+    }\n+\n+    @Test\n+    public void testf3() {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+        byte[] classdata = generate(f);\n+\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f3\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(fliftcore), f3());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f4() {\n+        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n+    }\n+\n+    @Test\n+    public void testf4() {\n+        CoreOps.FuncOp f = getFuncOp(\"f4\");\n+        byte[] classdata = generate(f);\n+\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f4\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(fliftcore), f4());\n+    }\n+\n+    static byte[] generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestLiftArrayCreation.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftArrayCreation.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.net.URL;\n+\n+\/*\n+ * @test\n+ * @run testng TestLiftControl\n+ *\/\n+\n+public class TestLiftControl {\n+\n+    static int ifelseCompare(int a, int b, int n) {\n+        if (n < 10) {\n+            a += 1;\n+        } else {\n+            b += 2;\n+        }\n+        return a + b;\n+    }\n+\n+    @Test\n+    public void testifElseCompare() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelseCompare\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 1), ifelseCompare(0, 0, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 11), ifelseCompare(0, 0, 11));\n+    }\n+\n+    \/\/ @@@ Cannot use boolean since it erases to int\n+    static int ifelseEquality(int v, int t1, int t1_1, int t2_1) {\n+        if (t1 != 0) {\n+            if (t1_1 != 0) {\n+                v += 1;\n+            } else {\n+                v += 2;\n+            }\n+        } else {\n+            if (t2_1 != 0) {\n+                v += 3;\n+            } else {\n+                v += 4;\n+            }\n+        }\n+        return v;\n+    }\n+\n+    @Test\n+    public void testIfelseEquality() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelseEquality\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 1, 0, 0), ifelseEquality(0, 1, 0, 0));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 1, 1, 0), ifelseEquality(0, 1, 1, 0));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 0, 1), ifelseEquality(0, 0, 0, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 0, 0), ifelseEquality(0, 0, 0, 0));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String method) {\n+        byte[] classdata = getClassdata();\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, method);\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+        CoreOps.FuncOp fliftcoreSSA = SSA.transform(fliftcore);\n+        fliftcoreSSA.writeTo(System.out);\n+        return fliftcoreSSA;\n+    }\n+\n+    static byte[] getClassdata() {\n+        URL resource = TestLiftControl.class.getClassLoader()\n+                .getResource(TestLiftControl.class.getName().replace('.', '\/') + \".class\");\n+        try {\n+            return resource.openStream().readAllBytes();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftControl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Proxy;\n+import java.net.URL;\n+import java.util.function.Function;\n+\n+\/*\n+ * @test\n+ * @run testng TestLiftExample\n+ *\/\n+\n+public class TestLiftExample {\n+\n+    public static <T, R> Function<T, R> proxy(Function<T, R> f) {\n+        @SuppressWarnings(\"unchecked\")\n+        Function<T, R> pf = (Function<T, R>) Proxy.newProxyInstance(\n+                TestLiftExample.class.getClassLoader(),\n+                new Class[]{Function.class},\n+                \/\/ @@@ Change to lambda\n+                handler(f));\n+        return pf;\n+    }\n+\n+    static InvocationHandler handler(Function<?, ?> f) {\n+        return (proxy, method, args) -> {\n+            if (method.getName().equals(\"apply\")) {\n+                int r = (int) method.invoke(f, args);\n+                return r + 1;\n+            } else {\n+                return method.invoke(f, args);\n+            }\n+        };\n+    }\n+\n+    @Test\n+    public void testF() throws Throwable {\n+        URL resource = TestLiftExample.class.getClassLoader().getResource(TestLiftExample.class.getName().replace('.', '\/') + \".class\");\n+        byte[] classdata = resource.openStream().readAllBytes();\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"proxy\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+        CoreOps.FuncOp fliftcoreSSA = SSA.transform(fliftcore);\n+        fliftcoreSSA.writeTo(System.out);\n+\n+        Function<Integer, Integer> f = i -> i;\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Integer> pf = (Function<Integer, Integer>) Interpreter.invoke(MethodHandles.lookup(),\n+                fliftcoreSSA, f);\n+\n+        Assert.assertEquals((int) pf.apply(1), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestLiftSimple\n+ *\/\n+\n+public class TestLiftSimple {\n+\n+    @CodeReflection\n+    static int f(int i, int j) {\n+        i = i + j;\n+        return i;\n+    }\n+\n+    @Test\n+    public void testF() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        byte[] classdata = generate(f);\n+\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(fliftcore, 1, 1), f(1, 1));\n+    }\n+\n+    @CodeReflection\n+    static int f2() {\n+        Class<?>[] ifaces = new Class[1];\n+        ifaces[0] = Function.class;\n+        return ifaces.length;\n+    }\n+\n+    @Test\n+    public void testF2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+        byte[] classdata = generate(f);\n+\n+        CoreOps.FuncOp flift = BytecodeLift.liftToBytecodeDialect(classdata, \"f2\");\n+        flift.writeTo(System.out);\n+        CoreOps.FuncOp fliftcore = BytecodeLift.liftToCoreDialect(flift);\n+        fliftcore.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(fliftcore), f2());\n+    }\n+\n+    static byte[] generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestLiftSimple.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftSimple.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestNew\n+ *\/\n+\n+public class TestNew {\n+\n+    record A(String s) {}\n+\n+    static String y(String in) {\n+        return in;\n+    }\n+\n+    @CodeReflection\n+    static A newWithArguments(String in) {\n+        String s = y(in);\n+        return new A(s);\n+    }\n+\n+    @Test\n+    public void testNewWithArguments() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"newWithArguments\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((A) mh.invoke(\"S\"), newWithArguments(\"S\"));\n+    }\n+\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestNew.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNew.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.IntBinaryOperator;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSimple\n+ *\/\n+\n+public class TestSimple {\n+\n+    @CodeReflection\n+    static int f(int i, int j) {\n+        i = i + j;\n+        return i;\n+    }\n+\n+    @Test\n+    public void testF() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals(f(1, 2), (int) mh.invoke(1, 2));\n+    }\n+\n+    @CodeReflection\n+    static int ifelse(int a, int b, int n) {\n+        if (n < 10) {\n+            a += 1;\n+        } else {\n+            b += 2;\n+        }\n+        return a + b;\n+    }\n+\n+    @Test\n+    public void testIfelse() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelse\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((int) mh.invoke(0, 0, 1), ifelse(0, 0, 1));\n+        Assert.assertEquals((int) mh.invoke(0, 0, 11), ifelse(0, 0, 11));\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + i;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testLoop() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"loop\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((int) mh.invoke(10), loop(10));\n+    }\n+\n+    @CodeReflection\n+    static int ifelseNested(int a, int b, int c, int d, int n) {\n+        if (n < 20) {\n+            if (n < 10) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (n > 20) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @Test\n+    public void testIfelseNested() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelseNested\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        for (int i : new int[]{1, 11, 20, 21}) {\n+            Assert.assertEquals((int) mh.invoke(0, 0, 0, 0, i), ifelseNested(0, 0, 0, 0, i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int n) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testNestedLoop() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"nestedLoop\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((int) mh.invoke(10), nestedLoop(10));\n+    }\n+\n+    @CodeReflection\n+    static int methodCallFieldAccess(int a, int b, IntBinaryOperator o) {\n+        int i = o.applyAsInt(a, b);\n+        System.out.println(i);\n+        return i;\n+    }\n+\n+    @Test\n+    public void testMethodCall() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"methodCallFieldAccess\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        int a = 1;\n+        int b = 1;\n+        IntBinaryOperator o = Integer::sum;\n+        Assert.assertEquals((int) mh.invoke(a, b, o), methodCallFieldAccess(a, b, o));\n+    }\n+\n+    @CodeReflection\n+    static Class<?>[] arrayCreationAndAccess() {\n+        Class<?>[] ca = new Class<?>[1];\n+        ca[0] = Function.class;\n+        return ca;\n+    }\n+\n+    @Test\n+    public void testArrayCreationAndAccess() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"arrayCreationAndAccess\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((Class<?>[]) mh.invoke(), arrayCreationAndAccess());\n+    }\n+\n+    @CodeReflection\n+    static int[] primitiveArrayCreationAndAccess() {\n+        int[] ia = new int[1];\n+        ia[0] = 42;\n+        return ia;\n+    }\n+\n+    @Test\n+    public void testPrimitiveArrayCreationAndAccess() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"primitiveArrayCreationAndAccess\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((int[]) mh.invoke(), primitiveArrayCreationAndAccess());\n+    }\n+\n+    @CodeReflection\n+    public static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @Test\n+    public void testNot() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"not\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((boolean) mh.invoke(true), not(true));\n+        Assert.assertEquals((boolean) mh.invoke(false), not(false));\n+    }\n+\n+    @CodeReflection\n+    public static int mod(int a, int b) {\n+        return a % b;\n+    }\n+\n+    @Test\n+    public void testMod() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"mod\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((int) mh.invoke(10, 3), mod(10, 3));\n+    }\n+\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSimple.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSlots\n+ *\/\n+\n+public class TestSlots {\n+    @CodeReflection\n+    static double f(double i, double j) {\n+        i = i + j;\n+\n+        double k = 4.0;\n+        k += i;\n+        return k;\n+    }\n+\n+    @Test\n+    public void testF() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals(f(1.0d, 2.0d), (double) mh.invoke(1.0d, 2.0d));\n+    }\n+\n+    @CodeReflection\n+    static double f2(double x, double y) {\n+        return x * (-Math.sin(x * y) + y) * 4.0d;\n+    }\n+\n+    @Test\n+    public void testF2() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals(f2(1.0d, 2.0d), (double) mh.invoke(1.0d, 2.0d));\n+    }\n+\n+    @CodeReflection\n+    static double f3(\/* independent *\/ double x, int y) {\n+        \/* dependent *\/\n+        double o = 1.0;\n+        for (int i = 0; i < y; i = i + 1) {\n+            if (i > 1) {\n+                if (i < 5) {\n+                    o = o * x;\n+                }\n+            }\n+        }\n+        return o;\n+    }\n+\n+    @Test\n+    public void testF3() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        for (int i = 0; i < 7; i++) {\n+            Assert.assertEquals(f3(2.0d, i), (double) mh.invoke(2.0d, i));\n+        }\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSlots.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestTry\n+ *\/\n+\n+public class TestTry {\n+\n+    @CodeReflection\n+    public static void catching(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatching() {\n+        CoreOps.FuncOp f = getFuncOp(\"catching\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTry::catching);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new NullPointerException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+    @CodeReflection\n+    public static void catchThrowable(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (Throwable e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrowable() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrowable\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTry::catchThrowable);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchNested(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            try {\n+                c.accept(1);\n+                c.accept(-1);\n+            } catch (IllegalStateException e) {\n+                consume(e);\n+                c.accept(2);\n+                c.accept(-1);\n+            }\n+            c.accept(3);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(4);\n+            c.accept(-1);\n+        }\n+        c.accept(5);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchNested() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchNested\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTry::catchNested);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+            if (i == 4) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 5) throw new RuntimeException();\n+        });\n+    }\n+\n+\n+    static void consume(Throwable e) {\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(MethodHandles.lookup(), lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n+        return c -> {\n+            try {\n+                mh.invoke(c);\n+            } catch (Throwable e) {\n+                throw erase(e);\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinally\n+ *\/\n+\n+public class TestTryFinally {\n+\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::tryCatchFinally\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            return;\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testTryReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryReturn\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::tryReturn\n+                );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchThrow(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+            throw e;\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrow() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrow\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::catchThrow\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void finallyReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+            return;\n+        }\n+    }\n+\n+    @Test\n+    public void finallyReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"finallyReturn\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::finallyReturn\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    static void test(Consumer<IntConsumer> test) {\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(MethodHandles.lookup(), lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n+        return c -> {\n+            try {\n+                mh.invoke(c);\n+            } catch (Throwable e) {\n+                throw erase(e);\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinallyNested\n+ *\/\n+\n+public class TestTryFinallyNested {\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c, int i) {\n+        try {\n+            try {\n+                if (i == 0) {\n+                    return;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    return;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    return;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                return;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                return;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                return;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> invoke(mh, c, fra),\n+                    c -> tryCatchFinally(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea < 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void tryForLoop(IntConsumer c) {\n+        for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            try {\n+                if (i == 4) {\n+                    continue;\n+                } else if (i == 5) {\n+                    break;\n+                }\n+                c.accept(1);\n+            } finally {\n+                c.accept(2);\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testTryForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryForLoop\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinallyNested::tryForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLabeledForLoop(IntConsumer c) {\n+        a: for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            b: {\n+                try {\n+                    if (i == 4) {\n+                        continue a;\n+                    } else if (i == 5) {\n+                        break b;\n+                    } else if (i == 6) {\n+                        break a;\n+                    }\n+                    c.accept(1);\n+                } finally {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            }\n+            c.accept(4);\n+        }\n+        c.accept(5);\n+    }\n+\n+    @Test\n+    public void testTryLabeledForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinallyNested::tryLabeledForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(MethodHandles.lookup(), lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n+        return c -> {\n+            try {\n+                mh.invoke(c);\n+            } catch (Throwable e) {\n+                throw erase(e);\n+            }\n+        };\n+    }\n+\n+    static void invoke(MethodHandle mh, IntConsumer c, int i) {\n+        try {\n+            mh.invoke(c, i);\n+        } catch (Throwable e) {\n+            throw erase(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLower;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestWhile\n+ *\/\n+\n+public class TestWhile {\n+\n+    @CodeReflection\n+    private static int fWhile(int i, int n) { int\n+        counter = 0;\n+        while (i < n && counter < 8) {\n+            counter++;\n+            if (counter == 5) {\n+                break;\n+            }\n+            i++;\n+        }\n+        return counter;\n+    }\n+\n+    @Test\n+    public void testWhile() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"fWhile\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((int) mh.invoke(1, 2), fWhile(1, 2));\n+        Assert.assertEquals((int) mh.invoke(1, 10), fWhile(1, 10));\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n+        bcf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestWhile.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestWhile.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.descriptor.*;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @run testng TestDescriptors\n+ *\/\n+\n+public class TestDescriptors {\n+\n+    @DataProvider\n+    public Object[][] TypeDescs() {\n+        return new Object[][]{\n+                {\"boolean\", \"Z\"},\n+                {\"byte\", \"B\"},\n+                {\"char\", \"C\"},\n+                {\"short\", \"S\"},\n+                {\"int\", \"I\"},\n+                {\"long\", \"J\"},\n+                {\"float\", \"F\"},\n+                {\"double\", \"D\"},\n+                {\"void\", \"V\"},\n+                {\"int[]\", \"[I\"},\n+                {\"int[][][][]\", \"[[[[I\"},\n+                {\"java.lang.String\", \"Ljava\/lang\/String;\"},\n+                {\"java.lang.String[][]\", \"[[Ljava\/lang\/String;\"},\n+                {\"a.b.C$D\", \"La\/b\/C$D;\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"TypeDescs\")\n+    public void testTypeDesc(String tds, String bcd) {\n+        TypeDesc td = TypeDesc.ofString(tds);\n+        Assert.assertEquals(td.toString(), tds);\n+        Assert.assertEquals(td.toNominalDescriptorString(), bcd);\n+        Assert.assertEquals(td, TypeDesc.ofNominalDescriptorString(bcd));\n+    }\n+\n+    @DataProvider\n+    public Object[][] classDescriptors() {\n+        return new Object[][]{\n+                {\"java.lang.String\", \"java.lang.String\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"classDescriptors\")\n+    public void classDescriptor(String tds, String bcd) {\n+        TypeDesc td = TypeDesc.ofString(tds);\n+        Assert.assertEquals(td.toString(), tds);\n+        Assert.assertEquals(td.toClassName(), bcd);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] basicTypeDescs() {\n+        return new Object[][]{\n+                {\"boolean\", \"int\"},\n+                {\"byte\", \"int\"},\n+                {\"char\", \"int\"},\n+                {\"short\", \"int\"},\n+                {\"int\", \"int\"},\n+                {\"long\", \"long\"},\n+                {\"float\", \"float\"},\n+                {\"double\", \"double\"},\n+                {\"void\", \"void\"},\n+                {\"int[]\", \"java.lang.Object\"},\n+                {\"int[][][][]\", \"java.lang.Object\"},\n+                {\"java.lang.String\", \"java.lang.Object\"},\n+                {\"java.lang.String[][]\", \"java.lang.Object\"},\n+                {\"a.b.C$D\", \"java.lang.Object\"},\n+                {\"java.util.List<T>\", \"java.lang.Object\"},\n+                {\"java.util.List<T>[]\", \"java.lang.Object\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"basicTypeDescs\")\n+    public void testBasicTypeDesc(String tds, String btds) {\n+        TypeDesc td = TypeDesc.ofString(tds);\n+        Assert.assertEquals(td.toString(), tds);\n+        Assert.assertEquals(td.toBasicType().toString(), btds);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] paramTypeDescs() {\n+        return new Object[][]{\n+                {\"java.util.List<T>\", \"T\"},\n+                {\"java.util.List<T>[]\", \"T\"},\n+                {\"java.util.List<java.util.function.Supplier<T>>\", \"java.util.function.Supplier<T>\"},\n+                {\"java.util.List<java.util.function.Supplier<T>>[][]\", \"java.util.function.Supplier<T>\"},\n+                {\"java.util.Map<K, V>\", \"K\", \"V\"},\n+                {\"ab<cd<S<T, V>, N>>\", \"cd<S<T, V>, N>\"},\n+                {\"java.util.Consumer<java.util.Function<String, Number>>\", \"java.util.Function<String, Number>\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"paramTypeDescs\")\n+    public void testParamTypeDesc(String tds, String... paramTypes) {\n+        TypeDesc td = TypeDesc.ofString(tds);\n+        Assert.assertEquals(td.toString(), tds);\n+\n+        Assert.assertTrue(td.hasTypeArguments());\n+        Assert.assertEquals(paramTypes.length, td.typeArguments().size());\n+\n+        Assert.assertEquals(td.typeArguments(), List.of(paramTypes).stream().map(TypeDesc::ofString).toList());\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] methodTypeDescriptors() {\n+        return new Object[][]{\n+                {\"()boolean\", \"()Z\"},\n+                {\"()void\", \"()V\"},\n+                {\"(int)int\", \"(I)I\"},\n+                {\"(int, int)int\", \"(II)I\"},\n+                {\"(java.lang.String)int\", \"(Ljava\/lang\/String;)I\"},\n+                {\"(java.lang.String, int)int\", \"(Ljava\/lang\/String;I)I\"},\n+                {\"(int, java.lang.String)int\", \"(ILjava\/lang\/String;)I\"},\n+                {\"(int, java.lang.String)java.lang.String\", \"(ILjava\/lang\/String;)Ljava\/lang\/String;\"},\n+                {\"(byte, short, int, long)boolean\", \"(BSIJ)Z\"},\n+                {\"(Func<String, Number>, Entry<List<String>, val>, int, long)void\", \"(LFunc;LEntry;IJ)V\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methodTypeDescriptors\")\n+    public void testMethodTypeDescriptor(String mtds, String bcd) {\n+        MethodTypeDesc mtd = MethodTypeDesc.ofString(mtds);\n+        Assert.assertEquals(mtd.toString(), mtds);\n+        Assert.assertEquals(mtd.toNominalDescriptorString(), bcd);\n+        Assert.assertEquals(mtd.erase(), MethodTypeDesc.ofNominalDescriptorString(bcd));\n+    }\n+\n+    @DataProvider\n+    public Object[][] methodDescriptors() {\n+        return new Object[][]{\n+                {\"a::b()void\", \"a\", \"b\"},\n+                {\"a.b::c(int)int\", \"a.b\", \"c\"},\n+                {\"a.b.c::d(int, int)int\", \"a.b.c\", \"d\"},\n+                {\"java.io.PrintStream::println(java.lang.String)void\", \"java.io.PrintStream\", \"println\"},\n+                {\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\", \"MethodReferenceTest$A\", \"m\"},\n+                {\"MethodReferenceTest$X::<new>(int)MethodReferenceTest$X\", \"MethodReferenceTest$X\", \"<new>\"},\n+                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methodDescriptors\")\n+    public void testMethodDescriptor(String mds, String refType, String name) {\n+        MethodDesc md = MethodDesc.ofString(mds);\n+        Assert.assertEquals(md.toString(), mds);\n+        Assert.assertEquals(md.refType().toString(), refType);\n+        Assert.assertEquals(md.name(), name);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] fieldDescriptors() {\n+        return new Object[][]{\n+                {\"a.b::c()int\", \"a.b\", \"c\", \"int\"},\n+                {\"a.b.c::d()int\", \"a.b.c\", \"d\", \"int\"},\n+                {\"java.lang.System::out()java.io.PrintStream\", \"java.lang.System\", \"out\", \"java.io.PrintStream\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"fieldDescriptors\")\n+    public void testFieldDescriptor(String fds, String refType, String name, String type) {\n+        FieldDesc fd = FieldDesc.ofString(fds);\n+        Assert.assertEquals(fd.toString(), fds);\n+        Assert.assertEquals(fd.refType().toString(), refType);\n+        Assert.assertEquals(fd.name(), name);\n+        Assert.assertEquals(fd.type().toString(), type);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] recordTypeDescriptors() {\n+        return new Object[][]{\n+                {\"()A\"},\n+                {\"(B b)A\"},\n+                {\"(B b, C c)A\"},\n+                {\"(p.Func<String, Number> f, Entry<List<String>, val> e, int i, long l)p.A<R>\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"recordTypeDescriptors\")\n+    public void testRecordTypeDescriptor(String rtds) {\n+        RecordTypeDesc mtd = RecordTypeDesc.ofString(rtds);\n+        Assert.assertEquals(mtd.toString(), rtds);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/descriptors\/TestDescriptors.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.HashMap;\n+import java.util.function.BiConsumer;\n+\n+import static java.lang.reflect.code.op.CoreOps.sub;\n+import static java.lang.reflect.code.analysis.Patterns.*;\n+\n+public final class ExpressionElimination {\n+    private ExpressionElimination() {\n+    }\n+\n+    static OpPattern negP(Pattern operand) {\n+        return opP(CoreOps.NegOp.class, operand);\n+    }\n+\n+    static OpPattern addP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.AddOp.class, lhs, rhs);\n+    }\n+\n+    static OpPattern mulP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.MulOp.class, lhs, rhs);\n+    }\n+\n+    public static <T extends Op> T eliminate(T f) {\n+        \/\/ Note expression elimination and other forms of analysis is simplified if first of all expressions\n+        \/\/ are normalized e.g. when they have an operand that is a constant expression\n+        \/\/ and the operation is associative such as add(0, x) -> add(x, 0)\n+\n+        var actions = multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n+                .pattern(mulP(_P(), valueP(constantP(0.0d))))\n+                .pattern(mulP(valueP(constantP(0.0d)), _P()))\n+                .pattern(addP(valueP(), constantP(0.0d)))\n+                .pattern(addP(constantP(0.0d), valueP()))\n+                .pattern(mulP(constantP(1.0d), valueP()))\n+                .pattern(mulP(valueP(), constantP(1.0d)))\n+                .target((ms, as) -> {\n+                    Value a = ms.matchedOperands().get(0);\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        cc.mapValue(ms.op().result(), cc.getValue(a));\n+                    });\n+                    return as;\n+                })\n+                \/\/ add(neg(x), y) -> sub(y, x)\n+                .pattern(addP(negP(valueP()), valueP()))\n+                .target((ms, as) -> {\n+                    Value x = ms.matchedOperands().get(0);\n+                    Value y = ms.matchedOperands().get(1);\n+\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        Op.Result r = block.op(sub(cc.getValue(y), cc.getValue(x)));\n+                        cc.mapValue(ms.op().result(), r);\n+                    });\n+                    return as;\n+                })\n+                .matchThenApply();\n+\n+        \/\/ Eliminate\n+        Op ef = f.transform(CopyContext.create(), (block, op) -> {\n+            BiConsumer<Block.Builder, Op> a = actions.get(op.result());\n+            if (a != null) {\n+                a.accept(block, op);\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+\n+        \/\/ Remove dead ops\n+        ef = ef.transform(CopyContext.create(), (block, op) -> {\n+            if (!(op instanceof Op.Pure) ||\n+                    !op.result().uses().isEmpty()) {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T t = (T) ef;\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/ExpressionElimination.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+\n+\/*\n+ * @test\n+ * @run testng TestExpressionElimination\n+ *\/\n+\n+public class TestExpressionElimination {\n+\n+    @Test\n+    public void testAddZero() {\n+        CoreOps.ClosureOp lf = generate((double a) -> a + 0.0);\n+\n+        Assert.assertEquals((double) Interpreter.invoke(lf, 1.0d), 1.0d);\n+    }\n+\n+    @Test\n+    public void testF() {\n+        CoreOps.ClosureOp lf = generate((double a, double b) -> -a + b);\n+\n+        Assert.assertEquals((double) Interpreter.invoke(lf, 1.0d, 1.0d), 0.0d);\n+    }\n+\n+    static CoreOps.ClosureOp generate(Quoted q) {\n+        return generateF((CoreOps.ClosureOp) q.op());\n+    }\n+\n+    static <T extends Op & Op.Invokable> T generateF(T f) {\n+        f.writeTo(System.out);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T lf = (T) f.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        lf = ExpressionElimination.eliminate(lf);\n+        lf.writeTo(System.out);\n+        return lf;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/java.lang.reflect.code.parser\n+ * @run testng TestParse\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.List;\n+import java.util.function.IntUnaryOperator;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.add;\n+import static java.lang.reflect.code.op.CoreOps.invoke;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.op.CoreOps.lambda;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.INT;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+\n+public class TestParse {\n+\n+    static final MethodDesc INT_UNARY_OPERATOR_METHOD = MethodDesc.method(\n+            IntUnaryOperator.class, \"applyAsInt\",\n+            int.class, int.class);\n+\n+    @Test\n+    public void testParseLambdaOp() {\n+        \/\/ functional descriptor = (int)int\n+        CoreOps.FuncOp f = func(\"f\", methodType(int.class, int.class))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional descriptor = (int)int\n+                    \/\/ op descriptor = ()IntUnaryOperator\n+                    \/\/   captures i\n+                    CoreOps.LambdaOp lambda = lambda(block.parentBody(),\n+                            methodType(int.class, int.class), type(IntUnaryOperator.class))\n+                            .body(lbody -> {\n+                                Block.Builder lblock = lbody.entryBlock();\n+                                Block.Parameter li = lblock.parameters().get(0);\n+\n+                                lblock.op(_return(\n+                                        lblock.op(add(i, li))));\n+                            });\n+\n+                    Op.Result fi = block.op(lambda);\n+                    Op.Result fortyTwo = block.op(constant(INT, 42));\n+                    Op.Result or = block.op(CoreOps.invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n+                    block.op(_return(or));\n+                });\n+\n+        List<Op> ops = OpParser.fromString(CoreOps.FACTORY, f.toText());\n+        assertTextEquals(f, ops.get(0));\n+    }\n+\n+\n+    static final String NAMED_BODY = \"\"\"\n+            func @\"test\" ^body1(%0 : int, %1 : int)int -> {\n+                %2 : int = constant @\"5\";\n+                %3 : int = constant @\"2\";\n+                branch ^b1(%2, %3);\n+\n+              ^b1(%0 : int, %1 : int):\n+                return %0;\n+            };\n+            \"\"\";\n+    @Test\n+    void testParseNamedBody() {\n+        Op opE = OpParser.fromString(CoreOps.FACTORY, NAMED_BODY).get(0);\n+        Op opA = OpParser.fromString(CoreOps.FACTORY, opE.toText()).get(0);\n+        assertTextEquals(opA, opE);\n+    }\n+\n+\n+    static final String ESCAPED_STRING = \"\"\"\n+            func @\"test\" ()String -> {\n+                %0 : java.lang.String = constant @\"\\\\b \\\\f \\\\n \\\\r \\\\t \\\\' \\\\\" \\\\\\\\\";\n+                return %0;\n+            };\n+            \"\"\";\n+    @Test\n+    void testEscapedString() {\n+        Op opE = OpParser.fromString(CoreOps.FACTORY, ESCAPED_STRING).get(0);\n+        Op opA = OpParser.fromString(CoreOps.FACTORY, opE.toText()).get(0);\n+        assertTextEquals(opA, opE);\n+\n+        CoreOps.ConstantOp cop = (CoreOps.ConstantOp) opE.bodies().get(0).entryBlock().firstOp();\n+        String v = (String) cop.value();\n+        Assert.assertEquals(v, \"\\b \\f \\n \\r \\t \\' \\\" \\\\\");\n+    }\n+\n+    static void assertTextEquals(Op a, Op b) {\n+        Assert.assertEquals(a.toText(), b.toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.parser.impl.Scanner;\n+import java.lang.reflect.code.parser.impl.Tokens;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.parser.impl.Tokens.TokenKind.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/java.lang.reflect.code.parser.impl\n+ * @run testng TestScanner\n+ *\/\n+\n+public class TestScanner {\n+\n+    @DataProvider\n+    Object[][] data() {\n+        return new Object[][] {\n+                {\"java.lang.Integer\", List.of(IDENTIFIER, DOT, IDENTIFIER, DOT, IDENTIFIER)},\n+                {\"java.lang.Integer\", List.of(\"java\", DOT, \"lang\", DOT, \"Integer\")},\n+                {\"a<a<a, a>,a<a, a>>\", List.of(\"a\", LT,\n+                        \"a\", LT, \"a\", COMMA, \"a\", GT,\n+                        COMMA,\n+                        \"a\", LT, \"a\", COMMA, \"a\", GT,\n+                        GT)},\n+                {\"_->(){}[],.=><?:;+-&^@\", List.of(\n+                        UNDERSCORE,\n+                        ARROW,\n+                        LPAREN,\n+                        RPAREN,\n+                        LBRACE,\n+                        RBRACE,\n+                        LBRACKET,\n+                        RBRACKET,\n+                        COMMA,\n+                        DOT,\n+                        EQ,\n+                        GT,\n+                        LT,\n+                        QUES,\n+                        COLON,\n+                        SEMI,\n+                        PLUS,\n+                        SUB,\n+                        AMP,\n+                        CARET,\n+                        MONKEYS_AT\n+                        )},\n+                {\"%1 %a %_1\", List.of(VALUE_IDENTIFIER, VALUE_IDENTIFIER, VALUE_IDENTIFIER)},\n+                {\"%1 %a %_1\", List.of(\"%1\", \"%a\", \"%_1\")},\n+                {\"\\\"abc\\\\n\\\"\", List.of(STRINGLITERAL)},\n+                {\"\\\"abc \\\\b \\\\f \\\\n \\\\r \\\\t \\\\' \\\\\\\" \\\\\\\\\\\"\", List.of(\"abc \\b \\f \\n \\r \\t \\' \\\" \\\\\")},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"data\")\n+    public void test(String content, List<Object> expectedTokens) {\n+        Scanner.Factory factory = Scanner.factory();\n+\n+        Scanner s = factory.newScanner(content);\n+        s.nextToken();\n+        List<Tokens.Token> actualTokens = new ArrayList<>();\n+        while (s.token().kind != EOF) {\n+            actualTokens.add(s.token());\n+            s.nextToken();\n+        }\n+\n+        Assert.assertEquals(actualTokens.size(), expectedTokens.size());\n+        for (int i = 0; i < expectedTokens.size(); i++) {\n+            Object e = expectedTokens.get(i);\n+            Tokens.Token a = actualTokens.get(i);\n+            if (e instanceof Tokens.TokenKind t) {\n+                Assert.assertEquals(a.kind, t);\n+            } else if (e instanceof String v) {\n+                String as = switch (a.kind.tag) {\n+                    case NAMED -> a.name();\n+                    case STRING, NUMERIC -> a.stringVal();\n+                    case DEFAULT -> a.kind.name;\n+                };\n+                Assert.assertEquals(as, v);\n+            } else {\n+                assert false;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestScanner.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps.JavaEnhancedForOp;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.op.ExtendedOps._continue;\n+import static java.lang.reflect.code.op.ExtendedOps.enhancedFor;\n+\n+public final class StreamFuser {\n+\n+    StreamFuser() {}\n+\n+    public static StreamExprBuilder fromList(TypeDesc elementType) {\n+        \/\/ java.util.List<E>\n+        TypeDesc listType = type(type(List.class), elementType);\n+        return new StreamExprBuilder(listType, elementType,\n+                (b, v) -> StreamExprBuilder.enhancedForLoop(b, elementType, v)::body);\n+    }\n+\n+    public static class StreamExprBuilder {\n+        static class StreamOp {\n+            final Quoted quotedClosure;\n+\n+            StreamOp(Quoted quotedClosure) {\n+                if (!(quotedClosure.op() instanceof CoreOps.ClosureOp)) {\n+                    throw new IllegalArgumentException(\"Quoted operation is not closure operation\");\n+                }\n+                this.quotedClosure = quotedClosure;\n+            }\n+\n+            CoreOps.ClosureOp op() {\n+                return (CoreOps.ClosureOp) quotedClosure.op();\n+            }\n+        }\n+\n+        static class MapStreamOp extends StreamOp {\n+            public MapStreamOp(Quoted quotedClosure) {\n+                super(quotedClosure);\n+                \/\/ @@@ Check closure signature\n+            }\n+        }\n+\n+        static class FlatMapStreamOp extends StreamOp {\n+            public FlatMapStreamOp(Quoted quotedClosure) {\n+                super(quotedClosure);\n+                \/\/ @@@ Check closure signature\n+            }\n+        }\n+\n+        static class FilterStreamOp extends StreamOp {\n+            public FilterStreamOp(Quoted quotedClosure) {\n+                super(quotedClosure);\n+                \/\/ @@@ Check closure signature\n+            }\n+        }\n+\n+        final TypeDesc sourceType;\n+        final TypeDesc sourceElementType;\n+        final BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier;\n+        final List<StreamOp> streamOps;\n+\n+        StreamExprBuilder(TypeDesc sourceType, TypeDesc sourceElementType,\n+                          BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier) {\n+            this.sourceType = sourceType;\n+            this.sourceElementType = sourceElementType;\n+            this.loopSupplier = loopSupplier;\n+            this.streamOps = new ArrayList<>();\n+        }\n+\n+        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, TypeDesc elementType,\n+                                                             Value iterable) {\n+            return enhancedFor(ancestorBody, iterable.type(), elementType)\n+                    .expression(b -> {\n+                        b.op(_yield(iterable));\n+                    })\n+                    .definition(b -> {\n+                        b.op(_yield(b.parameters().get(0)));\n+                    });\n+        }\n+\n+        public StreamExprBuilder map(Quoted f) {\n+            streamOps.add(new MapStreamOp(f));\n+            return this;\n+        }\n+\n+        public StreamExprBuilder flatMap(Quoted f) {\n+            streamOps.add(new FlatMapStreamOp(f));\n+            return this;\n+        }\n+\n+        public StreamExprBuilder filter(Quoted f) {\n+            streamOps.add(new FilterStreamOp(f));\n+            return this;\n+        }\n+\n+        void fuseIntermediateOperations(Block.Builder body, BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            fuseIntermediateOperation(0, body, body.parameters().get(0), null, terminalConsumer);\n+        }\n+\n+        void fuseIntermediateOperation(int i, Block.Builder body, Value element, Block.Builder continueBlock,\n+                                       BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            if (i == streamOps.size()) {\n+                terminalConsumer.accept(body, element);\n+                return;\n+            }\n+\n+            StreamOp sop = streamOps.get(i);\n+            if (sop instanceof MapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, value) -> {\n+                    fuseIntermediateOperation(i + 1, block, value, continueBlock, terminalConsumer);\n+                });\n+            } else if (sop instanceof FilterStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, p) -> {\n+                    Block.Builder _if = block.block();\n+                    Block.Builder _else = continueBlock;\n+                    if (continueBlock == null) {\n+                        _else = block.block();\n+                        _else.op(_continue());\n+                    }\n+\n+                    block.op(conditionalBranch(p, _if.successor(), _else.successor()));\n+\n+                    fuseIntermediateOperation(i + 1, _if, element, _else, terminalConsumer);\n+                });\n+            } else if (sop instanceof FlatMapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, iterable) -> {\n+                    JavaEnhancedForOp forOp = enhancedFor(block.parentBody(),\n+                            iterable.type(), iterable.type().typeArguments().get(0))\n+                            .expression(b -> {\n+                                b.op(_yield(iterable));\n+                            })\n+                            .definition(b -> {\n+                                b.op(_yield(b.parameters().get(0)));\n+                            })\n+                            .body(b -> {\n+                                fuseIntermediateOperation(i + 1,\n+                                        b,\n+                                        b.parameters().get(0),\n+                                        null, terminalConsumer);\n+                            });\n+\n+                    block.op(forOp);\n+                    block.op(_continue());\n+                });\n+            }\n+        }\n+\n+        public FuncOp forEach(Quoted quotedConsumer) {\n+            if (!(quotedConsumer.op() instanceof CoreOps.ClosureOp consumer)) {\n+                throw new IllegalArgumentException(\"Quoted consumer is not closure operation\");\n+            }\n+\n+            return func(\"fused.forEach\", MethodTypeDesc.methodType(TypeDesc.VOID, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        Op sourceLoop = loopSupplier.apply(b.parentBody(), source)\n+                                .apply(loopBlock -> {\n+                                    fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                        terminalBlock.inline(consumer, List.of(resultValue),\n+                                                (_, _) -> {\n+                                                });\n+                                        terminalBlock.op(_continue());\n+                                    });\n+\n+                                });\n+                        b.op(sourceLoop);\n+                        b.op(_return());\n+                    });\n+        }\n+\n+        \/\/ Supplier<C> supplier, BiConsumer<C, T> accumulator\n+        public FuncOp collect(Quoted quotedSupplier, Quoted quotedAccumulator) {\n+            if (!(quotedSupplier.op() instanceof CoreOps.ClosureOp supplier)) {\n+                throw new IllegalArgumentException(\"Quoted supplier is not closure operation\");\n+            }\n+            if (!(quotedAccumulator.op() instanceof CoreOps.ClosureOp accumulator)) {\n+                throw new IllegalArgumentException(\"Quoted accumulator is not closure operation\");\n+            }\n+\n+            TypeDesc collectType = supplier.funcDescriptor().returnType();\n+            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        b.inline(supplier, List.of(), (block, collect) -> {\n+                            Op sourceLoop = loopSupplier.apply(block.parentBody(), source)\n+                                    .apply(loopBlock -> {\n+                                        fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                            terminalBlock.inline(accumulator, List.of(collect, resultValue),\n+                                                    (_, _) -> {\n+                                                    });\n+                                            terminalBlock.op(_continue());\n+                                        });\n+                                    });\n+                            block.op(sourceLoop);\n+                            block.op(_return(collect));\n+                        });\n+                    });\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.descriptor.MethodTypeDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.ExtendedOps.JavaEnhancedForOp;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.*;\n+\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.op.ExtendedOps._continue;\n+import static java.lang.reflect.code.op.ExtendedOps.enhancedFor;\n+\n+public final class StreamFuserUsingQuotable {\n+\n+    \/\/ Quotable functional interfaces\n+\n+    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+    }\n+\n+    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+    }\n+\n+    public interface QuotableSupplier<T> extends Quotable, Supplier<T> {\n+    }\n+\n+    public interface QuotableConsumer<T> extends Quotable, Consumer<T> {\n+    }\n+\n+    public interface QuotableBiConsumer<T, U> extends Quotable, BiConsumer<T, U> {\n+    }\n+\n+\n+    StreamFuserUsingQuotable() {}\n+\n+    public static <T> StreamExprBuilder<T> fromList(Class<T> elementClass) {\n+        TypeDesc elementType = type(elementClass);\n+        \/\/ java.util.List<E>\n+        TypeDesc listType = type(type(List.class), elementType);\n+        return new StreamExprBuilder<>(listType, elementType,\n+                (b, v) -> StreamExprBuilder.enhancedForLoop(b, elementType, v)::body);\n+    }\n+\n+    public static class StreamExprBuilder<T> {\n+        static class StreamOp {\n+            final LambdaOp lambdaOp;\n+\n+            StreamOp(Quotable quotedLambda) {\n+                if (!(quotedLambda.quoted().op() instanceof LambdaOp lambdaOp)) {\n+                    throw new IllegalArgumentException(\"Quotable operation is not lambda operation\");\n+                }\n+                if (!(quotedLambda.quoted().capturedValues().isEmpty())) {\n+                    throw new IllegalArgumentException(\"Quotable operation captures values\");\n+                }\n+                this.lambdaOp = lambdaOp;\n+            }\n+\n+            LambdaOp op() {\n+                return lambdaOp;\n+            }\n+        }\n+\n+        static class MapStreamOp extends StreamOp {\n+            public MapStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n+            }\n+        }\n+\n+        static class FlatMapStreamOp extends StreamOp {\n+            public FlatMapStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n+            }\n+        }\n+\n+        static class FilterStreamOp extends StreamOp {\n+            public FilterStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n+            }\n+        }\n+\n+        final TypeDesc sourceType;\n+        final TypeDesc sourceElementType;\n+        final BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier;\n+        final List<StreamOp> streamOps;\n+\n+        StreamExprBuilder(TypeDesc sourceType, TypeDesc sourceElementType,\n+                          BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier) {\n+            this.sourceType = sourceType;\n+            this.sourceElementType = sourceElementType;\n+            this.loopSupplier = loopSupplier;\n+            this.streamOps = new ArrayList<>();\n+        }\n+\n+        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, TypeDesc elementType,\n+                                                             Value iterable) {\n+            return enhancedFor(ancestorBody, iterable.type(), elementType)\n+                    .expression(b -> {\n+                        b.op(_yield(iterable));\n+                    })\n+                    .definition(b -> {\n+                        b.op(_yield(b.parameters().get(0)));\n+                    });\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <R> StreamExprBuilder<R> map(QuotableFunction<T, R> f) {\n+            streamOps.add(new MapStreamOp(f));\n+            return (StreamExprBuilder<R>) this;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <R> StreamExprBuilder<R> flatMap(QuotableFunction<T, Iterable<R>> f) {\n+            streamOps.add(new FlatMapStreamOp(f));\n+            return (StreamExprBuilder<R>) this;\n+        }\n+\n+        public StreamExprBuilder<T> filter(QuotablePredicate<T> f) {\n+            streamOps.add(new FilterStreamOp(f));\n+            return this;\n+        }\n+\n+        void fuseIntermediateOperations(Block.Builder body, BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            fuseIntermediateOperation(0, body, body.parameters().get(0), null, terminalConsumer);\n+        }\n+\n+        void fuseIntermediateOperation(int i, Block.Builder body, Value element, Block.Builder continueBlock,\n+                                       BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            if (i == streamOps.size()) {\n+                terminalConsumer.accept(body, element);\n+                return;\n+            }\n+\n+            StreamOp sop = streamOps.get(i);\n+            if (sop instanceof MapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, value) -> {\n+                    fuseIntermediateOperation(i + 1, block, value, continueBlock, terminalConsumer);\n+                });\n+            } else if (sop instanceof FilterStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, p) -> {\n+                    Block.Builder _if = block.block();\n+                    Block.Builder _else = continueBlock;\n+                    if (continueBlock == null) {\n+                        _else = block.block();\n+                        _else.op(_continue());\n+                    }\n+\n+                    block.op(conditionalBranch(p, _if.successor(), _else.successor()));\n+\n+                    fuseIntermediateOperation(i + 1, _if, element, _else, terminalConsumer);\n+                });\n+            } else if (sop instanceof FlatMapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, iterable) -> {\n+                    JavaEnhancedForOp forOp = enhancedFor(block.parentBody(),\n+                            iterable.type(), iterable.type().typeArguments().get(0))\n+                            .expression(b -> {\n+                                b.op(_yield(iterable));\n+                            })\n+                            .definition(b -> {\n+                                b.op(_yield(b.parameters().get(0)));\n+                            })\n+                            .body(b -> {\n+                                fuseIntermediateOperation(i + 1,\n+                                        b,\n+                                        b.parameters().get(0),\n+                                        null, terminalConsumer);\n+                            });\n+\n+                    block.op(forOp);\n+                    block.op(_continue());\n+                });\n+            }\n+        }\n+\n+        public FuncOp forEach(QuotableConsumer<T> quotableConsumer) {\n+            if (!(quotableConsumer.quoted().op() instanceof LambdaOp consumer)) {\n+                throw new IllegalArgumentException(\"Quotable consumer is not lambda operation\");\n+            }\n+            if (!(quotableConsumer.quoted().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable consumer captures values\");\n+            }\n+\n+            return func(\"fused.forEach\", MethodTypeDesc.methodType(TypeDesc.VOID, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        Op sourceLoop = loopSupplier.apply(b.parentBody(), source)\n+                                .apply(loopBlock -> {\n+                                    fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                        terminalBlock.inline(consumer, List.of(resultValue),\n+                                                (_, _) -> {\n+                                                });\n+                                        terminalBlock.op(_continue());\n+                                    });\n+\n+                                });\n+                        b.op(sourceLoop);\n+                        b.op(_return());\n+                    });\n+        }\n+\n+        public <C> FuncOp collect(QuotableSupplier<C> quotableSupplier, QuotableBiConsumer<C, T> quotableAccumulator) {\n+            if (!(quotableSupplier.quoted().op() instanceof LambdaOp supplier)) {\n+                throw new IllegalArgumentException(\"Quotable supplier is not lambda operation\");\n+            }\n+            if (!(quotableSupplier.quoted().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable supplier captures values\");\n+            }\n+            if (!(quotableAccumulator.quoted().op() instanceof LambdaOp accumulator)) {\n+                throw new IllegalArgumentException(\"Quotable accumulator is not lambda operation\");\n+            }\n+            if (!(quotableAccumulator.quoted().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable accumulator captures values\");\n+            }\n+\n+            TypeDesc collectType = supplier.funcDescriptor().returnType();\n+            return func(\"fused.collect\", MethodTypeDesc.methodType(collectType, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        b.inline(supplier, List.of(), (block, collect) -> {\n+                            Op sourceLoop = loopSupplier.apply(block.parentBody(), source)\n+                                    .apply(loopBlock -> {\n+                                        fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                            terminalBlock.inline(accumulator, List.of(collect, resultValue),\n+                                                    (_, _) -> {\n+                                                    });\n+                                            terminalBlock.op(_continue());\n+                                        });\n+                                    });\n+                            block.op(sourceLoop);\n+                            block.op(_return(collect));\n+                        });\n+                    });\n+        }\n+\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestStream\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+\n+public class TestStream {\n+\n+    @Test\n+    public void testMapFilterForEach() {\n+        CoreOps.FuncOp f = StreamFuser.fromList(type(Integer.class))\n+                .map((Integer i) -> i.toString())\n+                .filter((String s) -> s.length() < 10)\n+                .map((String s) -> s.concat(\"_XXX\"))\n+                .filter((String s) -> s.length() < 10)\n+                .forEach((String s) -> System.out.println(s));\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Interpreter.invoke(lf, List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n+    }\n+\n+    @Test\n+    public void testMapFlatMapFilterCollect() {\n+        CoreOps.FuncOp f = StreamFuser.fromList(type(Integer.class))\n+                .map((Integer i) -> i.toString())\n+                .flatMap((String s) -> List.of(s, s))\n+                .filter((String s) -> s.length() < 10)\n+                .map((String s) -> s.concat(\"_XXX\"))\n+                .filter((String s) -> s.length() < 10)\n+                .collect(() -> new ArrayList<String>(), (List<String> l, String e) -> l.add(e));\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        List<Integer> source = List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 20);\n+\n+        List<String> expected = source.stream()\n+                .map(Object::toString)\n+                .flatMap(s -> Stream.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .toList();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> actual = (List<String>) Interpreter.invoke(lf, List.of(source));\n+\n+        Assert.assertEquals(expected, actual);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestStreamUsingQuotable\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class TestStreamUsingQuotable {\n+\n+    @Test\n+    public void testMapFilterForEach() {\n+        CoreOps.FuncOp f = StreamFuserUsingQuotable.fromList(Integer.class)\n+                .map(Object::toString)\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                \/\/ Cannot use method reference since it captures the result of the expression \"System.out\"\n+                .forEach(s -> System.out.println(s));\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Interpreter.invoke(lf, List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n+    }\n+\n+    @Test\n+    public void testMapFlatMapFilterCollect() {\n+        CoreOps.FuncOp f = StreamFuserUsingQuotable.fromList(Integer.class)\n+                .map(Object::toString)\n+                .flatMap(s -> List.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .collect(ArrayList::new, ArrayList::add);\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        List<Integer> source = List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 20);\n+\n+        List<String> expected = source.stream()\n+                .map(Object::toString)\n+                .flatMap(s -> Stream.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .toList();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> actual = (List<String>) Interpreter.invoke(lf, List.of(source));\n+\n+        Assert.assertEquals(expected, actual);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStreamUsingQuotable.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -214,0 +214,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with array access.\n+ * @build ArrayAccessTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ArrayAccessTest\n+ *\/\n+\n+public class ArrayAccessTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ArrayAccessTest, %1 : int[])int -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                return %5;\n+            };\n+            \"\"\")\n+    int test1(int[] ia) {\n+        return ia[0];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)int -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int = array.load %5 %8;\n+                return %9;\n+            };\n+            \"\"\")\n+    int test2(int[] ia, int i) {\n+        return ia[i + 1];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = constant @\"1\";\n+                array.store %3 %4 %5;\n+                return;\n+            };\n+            \"\"\")\n+    void test3(int[] ia) {\n+        ia[0] = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int = constant @\"1\";\n+                array.store %5 %8 %9;\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int[] ia, int i) {\n+        ia[i + 1] = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : ArrayAccessTest, %1 : int[][], %2 : int)int -> {\n+                %3 : Var<int[][]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[][] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int[] = array.load %5 %8;\n+                %10 : int = var.load %4;\n+                %11 : int = constant @\"2\";\n+                %12 : int = add %10 %11;\n+                %13 : int = array.load %9 %12;\n+                return %13;\n+            };\n+            \"\"\")\n+    int test5(int[][] ia, int i) {\n+        return ia[i + 1][i + 2];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : ArrayAccessTest, %1 : int[][], %2 : int)void -> {\n+                %3 : Var<int[][]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[][] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int[] = array.load %5 %8;\n+                %10 : int = var.load %4;\n+                %11 : int = constant @\"2\";\n+                %12 : int = add %10 %11;\n+                %13 : int = constant @\"1\";\n+                array.store %9 %12 %13;\n+                return;\n+            };\n+            \"\"\")\n+    void test6(int[][] ia, int i) {\n+        ia[i + 1][i + 2] = 1;\n+    }\n+\n+    int[] ia;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : ArrayAccessTest)int -> {\n+                %1 : int[] = field.load %0 @\"ArrayAccessTest::ia()int[]\";\n+                %2 : int = constant @\"0\";\n+                %3 : int = array.load %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test7() {\n+        return ia[0];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : ArrayAccessTest)int -> {\n+                %1 : int[] = field.load %0 @\"ArrayAccessTest::ia()int[]\";\n+                %2 : int = constant @\"0\";\n+                %3 : int = array.load %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test8() {\n+        return this.ia[0];\n+    }\n+\n+    static class A {\n+        int i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : ArrayAccessTest, %1 : ArrayAccessTest$A[])int -> {\n+                %2 : Var<ArrayAccessTest$A[]> = var %1 @\"aa\";\n+                %3 : ArrayAccessTest$A[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : ArrayAccessTest$A = array.load %3 %4;\n+                %6 : int = field.load %5 @\"ArrayAccessTest$A::i()int\";\n+                return %6;\n+            };\n+            \"\"\")\n+    int test9(A[] aa) {\n+        return aa[0].i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : ArrayAccessTest, %1 : ArrayAccessTest$A[])void -> {\n+                %2 : Var<ArrayAccessTest$A[]> = var %1 @\"aa\";\n+                %3 : ArrayAccessTest$A[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : ArrayAccessTest$A = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                field.store %5 %6 @\"ArrayAccessTest$A::i()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10(A[] aa) {\n+        aa[0].i = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                %7 : int = add %5 %6;\n+                array.store %3 %4 %7;\n+                return;\n+            };\n+            \"\"\")\n+    void test11(int[] ia) {\n+        ia[0] += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = constant @\"1\";\n+                %7 : int[] = var.load %3;\n+                %8 : int = var.load %4;\n+                %9 : int = constant @\"2\";\n+                %10 : int = add %8 %9;\n+                %11 : int = array.load %7 %10;\n+                %12 : int = constant @\"1\";\n+                %13 : int = add %11 %12;\n+                array.store %7 %10 %13;\n+                array.store %5 %6 %13;\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int[] ia, int i) {\n+        ia[1] = ia[i + 2] += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = constant @\"1\";\n+                %7 : int = array.load %5 %6;\n+                %8 : int[] = var.load %3;\n+                %9 : int = var.load %4;\n+                %10 : int = constant @\"2\";\n+                %11 : int = add %9 %10;\n+                %12 : int = array.load %8 %11;\n+                %13 : int = constant @\"1\";\n+                %14 : int = add %12 %13;\n+                array.store %8 %11 %14;\n+                %15 : int = add %7 %14;\n+                array.store %5 %6 %15;\n+                return;\n+            };\n+            \"\"\")\n+    void test13(int[] ia, int i) {\n+        ia[1] += ia[i + 2] += 1;\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                %7 : int = add %5 %6;\n+                array.store %3 %4 %7;\n+                %8 : Var<int> = var %5 @\"x\";\n+                %9 : int[] = var.load %2;\n+                %10 : int = constant @\"0\";\n+                %11 : int = array.load %9 %10;\n+                %12 : int = constant @\"1\";\n+                %13 : int = sub %11 %12;\n+                array.store %9 %10 %13;\n+                %14 : Var<int> = var %11 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14(int[] ia) {\n+        int x = ia[0]++;\n+        int y = ia[0]--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                %7 : int = add %5 %6;\n+                array.store %3 %4 %7;\n+                %8 : Var<int> = var %7 @\"x\";\n+                %9 : int[] = var.load %2;\n+                %10 : int = constant @\"0\";\n+                %11 : int = array.load %9 %10;\n+                %12 : int = constant @\"1\";\n+                %13 : int = sub %11 %12;\n+                array.store %9 %10 %13;\n+                %14 : Var<int> = var %13 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int[] ia) {\n+        int x = ++ia[0];\n+        int y = --ia[0];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : ArrayAccessTest, %1 : int[])int -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = array.length %3;\n+                %5 : int[] = var.load %2;\n+                %6 : int = invoke %5 @\"java.lang.Object::hashCode()int\";\n+                %7 : int = add %4 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test16(int[] ia) {\n+        return ia.length + ia.hashCode();\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ArrayAccessTest.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with binary operations.\n+ * @build BinopTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BinopTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class BinopTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"5\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = constant @\"4\";\n+                %4 : int = mul %2 %3;\n+                %5 : int = add %1 %4;\n+                %6 : int = constant @\"3\";\n+                %7 : int = sub %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test() {\n+        return 5 + 2 * 4 - 3;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = constant @\"3\";\n+                %4 : int = constant @\"4\";\n+                %5 : int = add %3 %4;\n+                %6 : int = add %2 %5;\n+                %7 : int = add %1 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test2() {\n+        return 1 + (2 + (3 + 4));\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = add %1 %2;\n+                %4 : int = constant @\"3\";\n+                %5 : int = add %3 %4;\n+                %6 : int = constant @\"4\";\n+                %7 : int = add %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test3() {\n+        return ((1 + 2) + 3) + 4;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BinopTest, %1 : int)int -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : int = var.load %2;\n+                %7 : int = constant @\"1\";\n+                %8 : int = mul %6 %7;\n+                var.store %2 %8;\n+                %9 : int = add %5 %8;\n+                %10 : int = var.load %2;\n+                %11 : int = constant @\"1\";\n+                %12 : int = div %10 %11;\n+                var.store %2 %12;\n+                %13 : int = add %9 %12;\n+                %14 : int = var.load %2;\n+                %15 : int = constant @\"1\";\n+                %16 : int = sub %14 %15;\n+                var.store %2 %16;\n+                %17 : int = add %13 %16;\n+                %18 : int = var.load %2;\n+                %19 : int = constant @\"1\";\n+                %20 : int = mod %18 %19;\n+                var.store %2 %20;\n+                %21 : int = add %17 %20;\n+                return %21;\n+            };\n+            \"\"\")\n+    int test4(int i) {\n+        return (i += 1) + (i *= 1) + (i \/= 1) + (i -= 1) + (i %= 1);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : BinopTest, %1 : int)boolean -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : boolean = eq %3 %4;\n+                %6 : boolean = not %5;\n+                return %6;\n+            };\n+            \"\"\")\n+    boolean test5(int i) {\n+        return !(i == 0);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"5\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = mod %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test6() {\n+        return 5 % 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : BinopTest, %1 : double)void -> {\n+                %2 : Var<double> = var %1 @\"d\";\n+                %3 : double = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : double = conv %4;\n+                %6 : double = add %3 %5;\n+                var.store %2 %6;\n+                %7 : long = constant @\"1\";\n+                %8 : double = conv %7;\n+                %9 : double = var.load %2;\n+                %10 : double = add %8 %9;\n+                var.store %2 %10;\n+                %11 : double = var.load %2;\n+                %12 : long = constant @\"1\";\n+                %13 : double = conv %12;\n+                %14 : double = sub %11 %13;\n+                var.store %2 %14;\n+                %15 : int = constant @\"1\";\n+                %16 : double = conv %15;\n+                %17 : double = var.load %2;\n+                %18 : double = sub %16 %17;\n+                var.store %2 %18;\n+                %19 : double = var.load %2;\n+                %20 : int = constant @\"1\";\n+                %21 : double = conv %20;\n+                %22 : double = mul %19 %21;\n+                var.store %2 %22;\n+                %23 : long = constant @\"1\";\n+                %24 : double = conv %23;\n+                %25 : double = var.load %2;\n+                %26 : double = mul %24 %25;\n+                var.store %2 %26;\n+                %27 : double = var.load %2;\n+                %28 : long = constant @\"1\";\n+                %29 : double = conv %28;\n+                %30 : double = div %27 %29;\n+                var.store %2 %30;\n+                %31 : int = constant @\"1\";\n+                %32 : double = conv %31;\n+                %33 : double = var.load %2;\n+                %34 : double = div %32 %33;\n+                var.store %2 %34;\n+                %35 : double = var.load %2;\n+                %36 : int = constant @\"1\";\n+                %37 : double = conv %36;\n+                %38 : double = mod %35 %37;\n+                var.store %2 %38;\n+                %39 : long = constant @\"1\";\n+                %40 : double = conv %39;\n+                %41 : double = var.load %2;\n+                %42 : double = mod %40 %41;\n+                var.store %2 %42;\n+                %43 : int = constant @\"-1\";\n+                %44 : double = conv %43;\n+                var.store %2 %44;\n+                return;\n+            };\n+            \"\"\")\n+    void test7(double d) {\n+        d = d + 1;\n+        d = 1L + d;\n+\n+        d = d - 1L;\n+        d = 1 - d;\n+\n+        d = d * 1;\n+        d = 1L * d;\n+\n+        d = d \/ 1L;\n+        d = 1 \/ d;\n+\n+        d = d % 1;\n+        d = 1L % d;\n+\n+        d = -1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : BinopTest, %1 : double)void -> {\n+                %2 : Var<double> = var %1 @\"d\";\n+                %3 : double = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : double = conv %4;\n+                %6 : double = add %3 %5;\n+                var.store %2 %6;\n+                %7 : double = var.load %2;\n+                %8 : long = constant @\"1\";\n+                %9 : double = conv %8;\n+                %10 : double = sub %7 %9;\n+                var.store %2 %10;\n+                %11 : double = var.load %2;\n+                %12 : int = constant @\"1\";\n+                %13 : double = conv %12;\n+                %14 : double = mul %11 %13;\n+                var.store %2 %14;\n+                %15 : double = var.load %2;\n+                %16 : long = constant @\"1\";\n+                %17 : double = conv %16;\n+                %18 : double = div %15 %17;\n+                var.store %2 %18;\n+                %19 : double = var.load %2;\n+                %20 : int = constant @\"1\";\n+                %21 : double = conv %20;\n+                %22 : double = mod %19 %21;\n+                var.store %2 %22;\n+                return;\n+            };\n+            \"\"\")\n+    void test8(double d) {\n+        d += 1;\n+\n+        d -= 1L;\n+\n+        d *= 1;\n+\n+        d \/= 1L;\n+\n+        d %= 1;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BinopTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with blocks.\n+ * @build BlockTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BlockTest\n+ *\/\n+\n+public class BlockTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : BlockTest)void -> {\n+                java.block ()void -> {\n+                    %1 : int = constant @\"0\";\n+                    %2 : Var<int> = var %1 @\"i\";\n+                    yield;\n+                };\n+                java.block ()void -> {\n+                    %3 : int = constant @\"1\";\n+                    %4 : Var<int> = var %3 @\"i\";\n+                    java.block ()void -> {\n+                        %5 : int = constant @\"2\";\n+                        %6 : Var<int> = var %5 @\"j\";\n+                        yield;\n+                    };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        {\n+            int i = 0;\n+        }\n+\n+        {\n+            int i = 1;\n+\n+            {\n+                int j = 2;\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BlockTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        java.block ()void -> {\n+                            %6 : int = var.load %2;\n+                            %7 : int = constant @\"1\";\n+                            %8 : int = add %6 %7;\n+                            var.store %2 %8;\n+                            yield;\n+                        };\n+                        yield;\n+                    }\n+                    ^else_if()boolean -> {\n+                        %9 : int = var.load %2;\n+                        %10 : int = constant @\"2\";\n+                        %11 : boolean = lt %9 %10;\n+                        yield %11;\n+                    }\n+                    ^then()void -> {\n+                        java.block ()void -> {\n+                            %12 : int = var.load %2;\n+                            %13 : int = constant @\"2\";\n+                            %14 : int = add %12 %13;\n+                            var.store %2 %14;\n+                            yield;\n+                        };\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        java.block ()void -> {\n+                            %15 : int = var.load %2;\n+                            %16 : int = constant @\"3\";\n+                            %17 : int = add %15 %16;\n+                            var.store %2 %17;\n+                            yield;\n+                        };\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int i) {\n+        if (i < 1) {\n+            {\n+                i += 1;\n+            }\n+        } else if (i < 2) {\n+            {\n+                i += 2;\n+            }\n+        } else {\n+            {\n+                i += 3;\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BlockTest)void -> {\n+                java.for\n+                    ^init()void -> {\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %1 : boolean = constant @\"true\";\n+                        yield %1;\n+                    }\n+                    ^update()void -> {\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        java.block ()void -> {\n+                            %2 : int = constant @\"0\";\n+                            %3 : Var<int> = var %2 @\"i\";\n+                            yield;\n+                        };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        for (;;) {\n+            {\n+                int i = 0;\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BlockTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                java.enhancedFor\n+                    ^expr()int[] -> {\n+                        %3 : int[] = var.load %2;\n+                        yield %3;\n+                    }\n+                    ^def(%4 : int)Var<int> -> {\n+                        %5 : Var<int> = var %4 @\"i\";\n+                        yield %5;\n+                    }\n+                    ^body(%6 : Var<int>)void -> {\n+                        java.block ()void -> {\n+                            %7 : int = var.load %6;\n+                            %8 : int = constant @\"1\";\n+                            %9 : int = add %7 %8;\n+                            var.store %6 %9;\n+                            yield;\n+                        };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int[] ia) {\n+        for (int i : ia) {\n+            {\n+                i++;\n+            }\n+        }\n+   }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : BlockTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"s\";\n+                    java.block ()void -> {\n+                        %4 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %5 : java.lang.String = var.load %3;\n+                        invoke %4 %5 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                    return;\n+                };\n+                %6 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+   void test5() {\n+        Consumer<String> c = s -> {\n+            {\n+                System.out.println(s);\n+            }\n+        };\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : BlockTest)void -> {\n+                 java.if\n+                     ()boolean -> {\n+                         %1 : boolean = constant @\"true\";\n+                         yield %1;\n+                     }\n+                     ^then()void -> {\n+                         java.block ()void -> {\n+                             return;\n+                         };\n+                         yield;\n+                     }\n+                     ^else()void -> {\n+                         yield;\n+                     };\n+                 java.if\n+                     ()boolean -> {\n+                         %2 : boolean = constant @\"true\";\n+                         yield %2;\n+                     }\n+                     ^then()void -> {\n+                         java.block ()void -> {\n+                             %3 : java.lang.RuntimeException = new @\"()java.lang.RuntimeException\";\n+                             throw %3;\n+                         };\n+                         yield;\n+                     }\n+                     ^else()void -> {\n+                         yield;\n+                     };\n+                 return;\n+             };\n+             \"\"\")\n+    void test6() {\n+        if (true) {\n+            {\n+                return;\n+            }\n+        }\n+\n+        if (true) {\n+            {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,653 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with boxing conversions.\n+ * @build BoxingConversionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BoxingConversionTest\n+ *\/\n+\n+public class BoxingConversionTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : BoxingConversionTest)void -> {\n+                  %1 : long = constant @\"1\";\n+                  %2 : java.lang.Long = invoke %1 @\"java.lang.Long::valueOf(long)java.lang.Long\";\n+                  %3 : Var<java.lang.Long> = var %2 @\"x\";\n+                  return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        Long x = 1L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BoxingConversionTest, %1 : java.lang.Long)void -> {\n+                %2 : Var<java.lang.Long> = var %1 @\"L\";\n+                %3 : java.lang.Long = var.load %2;\n+                %4 : long = invoke %3 @\"java.lang.Long::longValue(java.lang.Long)long\";\n+                %5 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(Long L) {\n+        long l = L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BoxingConversionTest)void -> {\n+                %1 : long = constant @\"0\";\n+                %2 : java.lang.Long = invoke %1 @\"java.lang.Long::valueOf(long)java.lang.Long\";\n+                %3 : Var<java.lang.Object> = var %2 @\"o\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        Object o = 0L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BoxingConversionTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.lang.Long = cast %3 @\"java.lang.Long\";\n+                %5 : long = invoke %4 @\"java.lang.Object::longValue(java.lang.Object)long\";\n+                %6 : Var<long> = var %5 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4(Object o) {\n+        long l = (long)o;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : BoxingConversionTest, %1 : java.lang.Integer)void -> {\n+                %2 : Var<java.lang.Integer> = var %1 @\"i2\";\n+                %3 : java.lang.Integer = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = invoke %3 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                %6 : int = add %5 %4;\n+                %7 : java.lang.Integer = invoke %6 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                var.store %2 %7;\n+                return;\n+            };\n+            \"\"\")\n+    void test5(Integer i2) {\n+        i2++;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : BoxingConversionTest, %1 : java.lang.Integer)void -> {\n+                %2 : Var<java.lang.Integer> = var %1 @\"i2\";\n+                %3 : java.lang.Integer = var.load %2;\n+                %4 : int = constant @\"3\";\n+                %5 : int = invoke %3 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                %6 : int = add %5 %4;\n+                %7 : java.lang.Integer = invoke %6 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                var.store %2 %7;\n+                return;\n+            };\n+            \"\"\")\n+    void test6(Integer i2) {\n+        i2 += 3;\n+    }\n+\n+    static class Box {\n+        Integer i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : BoxingConversionTest)void -> {\n+                %1 : BoxingConversionTest$Box = new @\"()BoxingConversionTest$Box\";\n+                %2 : java.lang.Integer = field.load %1 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                %3 : int = constant @\"1\";\n+                %4 : int = invoke %2 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                %5 : int = add %4 %3;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                field.store %1 %6 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        new Box().i++;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : BoxingConversionTest)void -> {\n+                %1 : BoxingConversionTest$Box = new @\"()BoxingConversionTest$Box\";\n+                %2 : java.lang.Integer = field.load %1 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                %3 : int = constant @\"3\";\n+                %4 : int = invoke %2 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                %5 : int = add %4 %3;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                field.store %1 %6 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        new Box().i += 3;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : BoxingConversionTest, %1 : int[], %2 : java.lang.Integer)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = constant @\"0\";\n+                %7 : int = array.load %5 %6;\n+                %8 : java.lang.Integer = var.load %4;\n+                %9 : int = invoke %8 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                %10 : int = add %7 %9;\n+                array.store %5 %6 %10;\n+                return;\n+            };\n+            \"\"\")\n+    void test9(int[] ia, Integer i) {\n+        ia[0] += i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : BoxingConversionTest, %1 : boolean, %2 : java.lang.Integer)void -> {\n+                %3 : Var<boolean> = var %1 @\"cond\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = java.cexpression\n+                    ^cond()boolean -> {\n+                        %6 : boolean = var.load %3;\n+                        yield %6;\n+                    }\n+                    ^truepart()java.lang.Integer -> {\n+                        %7 : java.lang.Integer = var.load %4;\n+                        %8 : int = invoke %7 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                        yield %8;\n+                    }\n+                    ^falsepart()int -> {\n+                        %9 : int = constant @\"2\";\n+                        yield %9;\n+                    };\n+                %10 : Var<int> = var %5 @\"res\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10(boolean cond, Integer I) {\n+        int res = cond ? I : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : BoxingConversionTest, %1 : boolean, %2 : java.lang.Integer)void -> {\n+                %3 : Var<boolean> = var %1 @\"cond\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = java.cexpression\n+                    ^cond()boolean -> {\n+                        %6 : boolean = var.load %3;\n+                        yield %6;\n+                    }\n+                    ^truepart()int -> {\n+                        %7 : int = constant @\"2\";\n+                        yield %7;\n+                    }\n+                    ^falsepart()java.lang.Integer -> {\n+                        %8 : java.lang.Integer = var.load %4;\n+                        %9 : int = invoke %8 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                        yield %9;\n+                    };\n+                %10 : Var<int> = var %5 @\"res\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(boolean cond, Integer I) {\n+        int res = cond ? 2 : I;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : BoxingConversionTest, %1 : boolean)void -> {\n+                 %2 : Var<boolean> = var %1 @\"cond\";\n+                 %3 : int = java.cexpression\n+                     ^cond()boolean -> {\n+                         %4 : boolean = var.load %2;\n+                         yield %4;\n+                     }\n+                     ^truepart()int -> {\n+                         %5 : int = constant @\"1\";\n+                         yield %5;\n+                     }\n+                     ^falsepart()int -> {\n+                         %6 : int = constant @\"2\";\n+                         yield %6;\n+                     };\n+                 %7 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                 %8 : Var<java.lang.Integer> = var %7 @\"x\";\n+                 return;\n+             };\n+             \"\"\")\n+    void test12(boolean cond) {\n+        Integer x = cond ? 1 : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : BoxingConversionTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : java.lang.Integer = invoke %2 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.Supplier<java.lang.Integer>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13() {\n+        Supplier<Integer> s = () -> { return 1; };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : BoxingConversionTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : java.lang.Integer = invoke %2 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.Supplier<java.lang.Integer>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14() {\n+        Supplier<Integer> s = () -> 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : java.lang.Integer = var.load %4;\n+                        %11 : int = invoke %10 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                        yield %11;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %12 : int = constant @\"0\";\n+                        yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> I;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : int = constant @\"1\";\n+                        yield %10;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %11 : java.lang.Integer = var.load %4;\n+                        %12 : int = invoke %11 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                        yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> 1;\n+            default -> I;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : java.lang.Integer = invoke %8 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        yield %11;\n+                    };\n+                %12 : Var<java.lang.Integer> = var %4 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17(int i) {\n+        Integer x = switch (i) {\n+            case 1 -> 1;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : java.lang.Integer = var.load %4;\n+                        %11 : int = invoke %10 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                        java.yield %11;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %12 : int = constant @\"0\";\n+                        java.yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> { yield I; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test19\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : int = constant @\"1\";\n+                        java.yield %10;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %11 : java.lang.Integer = var.load %4;\n+                        %12 : int = invoke %11 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                        java.yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test19(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield I; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : java.lang.Integer = invoke %8 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        java.yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        java.yield %11;\n+                    };\n+                %12 : Var<java.lang.Integer> = var %4 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test20(int i) {\n+        Integer x = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : java.lang.Integer = var.load %4;\n+                %7 : int = invoke %6 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                %8 : int = add %5 %7;\n+                %9 : Var<int> = var %8 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21(int i, Integer I) {\n+        int l = i + I;\n+    }\n+\n+    void m(Integer I) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test22\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                invoke %0 %4 @\"BoxingConversionTest::m(java.lang.Integer)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test22(int i) {\n+        m(i);\n+    }\n+\n+    void m(int i1, int i2, Integer... I) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test23\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                invoke %0 %3 %4 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test23(int i) {\n+        m(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test24\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                invoke %0 %3 %4 %6 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test24(int i) {\n+        m(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test25\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %7 : int = var.load %2;\n+                %8 : java.lang.Integer = invoke %7 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                invoke %0 %3 %4 %6 %8 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test25(int i) {\n+        m(i, i, i, i);\n+    }\n+\n+    static class Box2 {\n+        Box2(Integer I) { }\n+        Box2(int i1, int i2, Integer... Is) { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test26\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %5 : BoxingConversionTest$Box2 = new %4 @\"(java.lang.Integer)BoxingConversionTest$Box2\";\n+                return;\n+            };\n+            \"\"\")\n+    void test26(int i) {\n+        new Box2(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test27\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"(int, int, java.lang.Integer[])BoxingConversionTest$Box2\";\n+                return;\n+            };\n+            \"\"\")\n+    void test27(int i) {\n+        new Box2(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test28\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"(int, int, java.lang.Integer[])BoxingConversionTest$Box2\";\n+                return;\n+            };\n+            \"\"\")\n+    void test28(int i) {\n+        new Box2(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test29\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %7 : int = var.load %2;\n+                %8 : java.lang.Integer = invoke %7 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"(int, int, java.lang.Integer[])BoxingConversionTest$Box2\";\n+                return;\n+            };\n+            \"\"\")\n+    void test29(int i) {\n+        new Box2(i, i, i, i);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":653,"deletions":0,"binary":false,"changes":653,"status":"added"},{"patch":"@@ -0,0 +1,400 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with for loops.\n+ * @build BreakContinueTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BreakContinueTest\n+ *\/\n+\n+\n+public class BreakContinueTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : BreakContinueTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        java.if\n+                            ()boolean -> {\n+                                %12 : boolean = constant @\"true\";\n+                                yield %12;\n+                            }\n+                            ^then()void -> {\n+                                java.continue;\n+                            }\n+                            ^else()void -> {\n+                                yield;\n+                            };\n+                        java.if\n+                            ()boolean -> {\n+                                %13 : boolean = constant @\"true\";\n+                                yield %13;\n+                            }\n+                            ^then()void -> {\n+                                java.break;\n+                            }\n+                            ^else()void -> {\n+                                yield;\n+                            };\n+                        java.for\n+                            ^init()Var<int> -> {\n+                                %14 : int = constant @\"0\";\n+                                %15 : Var<int> = var %14 @\"j\";\n+                                yield %15;\n+                            }\n+                            ^cond(%16 : Var<int>)boolean -> {\n+                                %17 : int = var.load %16;\n+                                %18 : int = constant @\"10\";\n+                                %19 : boolean = lt %17 %18;\n+                                yield %19;\n+                            }\n+                            ^update(%20 : Var<int>)void -> {\n+                                %21 : int = var.load %20;\n+                                %22 : int = constant @\"1\";\n+                                %23 : int = add %21 %22;\n+                                var.store %20 %23;\n+                                yield;\n+                            }\n+                            ^body(%24 : Var<int>)void -> {\n+                                java.if\n+                                    ()boolean -> {\n+                                        %25 : boolean = constant @\"true\";\n+                                        yield %25;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.continue;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                java.if\n+                                    ()boolean -> {\n+                                        %26 : boolean = constant @\"true\";\n+                                        yield %26;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.break;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                java.continue;\n+                            };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        for (int i = 0; i < 10; i++) {\n+            if (true) {\n+                continue;\n+            }\n+            if (true) {\n+                break;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+                if (true) {\n+                    continue;\n+                }\n+                if (true) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BreakContinueTest)void -> {\n+                java.labeled ()void -> {\n+                    %1 : java.lang.String = constant @\"outer\";\n+                    java.for\n+                        ^init()Var<int> -> {\n+                            %2 : int = constant @\"0\";\n+                            %3 : Var<int> = var %2 @\"i\";\n+                            yield %3;\n+                        }\n+                        ^cond(%4 : Var<int>)boolean -> {\n+                            %5 : int = var.load %4;\n+                            %6 : int = constant @\"10\";\n+                            %7 : boolean = lt %5 %6;\n+                            yield %7;\n+                        }\n+                        ^update(%8 : Var<int>)void -> {\n+                            %9 : int = var.load %8;\n+                            %10 : int = constant @\"1\";\n+                            %11 : int = add %9 %10;\n+                            var.store %8 %11;\n+                            yield;\n+                        }\n+                        ^body(%12 : Var<int>)void -> {\n+                            java.if\n+                                ()boolean -> {\n+                                    %13 : boolean = constant @\"true\";\n+                                    yield %13;\n+                                }\n+                                ^then()void -> {\n+                                    java.continue %1;\n+                                }\n+                                ^else()void -> {\n+                                    yield;\n+                                };\n+                            java.if\n+                                ()boolean -> {\n+                                    %14 : boolean = constant @\"true\";\n+                                    yield %14;\n+                                }\n+                                ^then()void -> {\n+                                    java.break %1;\n+                                }\n+                                ^else()void -> {\n+                                    yield;\n+                                };\n+                            java.labeled ()void -> {\n+                                %15 : java.lang.String = constant @\"inner\";\n+                                java.for\n+                                    ^init()Var<int> -> {\n+                                        %16 : int = constant @\"0\";\n+                                        %17 : Var<int> = var %16 @\"j\";\n+                                        yield %17;\n+                                    }\n+                                    ^cond(%18 : Var<int>)boolean -> {\n+                                        %19 : int = var.load %18;\n+                                        %20 : int = constant @\"10\";\n+                                        %21 : boolean = lt %19 %20;\n+                                        yield %21;\n+                                    }\n+                                    ^update(%22 : Var<int>)void -> {\n+                                        %23 : int = var.load %22;\n+                                        %24 : int = constant @\"1\";\n+                                        %25 : int = add %23 %24;\n+                                        var.store %22 %25;\n+                                        yield;\n+                                    }\n+                                    ^body(%26 : Var<int>)void -> {\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %27 : boolean = constant @\"true\";\n+                                                yield %27;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.continue;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %28 : boolean = constant @\"true\";\n+                                                yield %28;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.break;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %29 : boolean = constant @\"true\";\n+                                                yield %29;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.continue %1;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %30 : boolean = constant @\"true\";\n+                                                yield %30;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.break %1;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.continue;\n+                                    };\n+                                yield;\n+                            };\n+                            java.continue;\n+                        };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        outer:\n+        for (int i = 0; i < 10; i++) {\n+            if (true) {\n+                continue outer;\n+            }\n+            if (true) {\n+                break outer;\n+            }\n+            inner:\n+            for (int j = 0; j < 10; j++) {\n+                if (true) {\n+                    continue;\n+                }\n+                if (true) {\n+                    break;\n+                }\n+                if (true) {\n+                    continue outer;\n+                }\n+                if (true) {\n+                    break outer;\n+                }\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BreakContinueTest)void -> {\n+                java.labeled ()void -> {\n+                    %1 : java.lang.String = constant @\"b1\";\n+                    java.block ()void -> {\n+                        java.labeled ()void -> {\n+                            %2 : java.lang.String = constant @\"b2\";\n+                            java.block ()void -> {\n+                                java.if\n+                                    ()boolean -> {\n+                                        %3 : boolean = constant @\"true\";\n+                                        yield %3;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.break %1;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                java.if\n+                                    ()boolean -> {\n+                                        %4 : boolean = constant @\"true\";\n+                                        yield %4;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.break %2;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                yield;\n+                            };\n+                            yield;\n+                        };\n+                        yield;\n+                    };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        b1:\n+        {\n+            b2:\n+            {\n+                if (true) {\n+                    break b1;\n+                }\n+                if (true) {\n+                    break b2;\n+                }\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BreakContinueTest)void -> {\n+                java.labeled ()void -> {\n+                    %1 : java.lang.String = constant @\"b\";\n+                    java.break %1;\n+                };\n+                %2 : int = constant @\"0\";\n+                %3 : Var<int> = var %2 @\"i\";\n+                java.labeled ()void -> {\n+                    %4 : java.lang.String = constant @\"b\";\n+                    %5 : int = var.load %3;\n+                    %6 : int = constant @\"1\";\n+                    %7 : int = add %5 %6;\n+                    var.store %3 %7;\n+                    yield;\n+                };\n+                java.labeled ()void -> {\n+                    %8 : java.lang.String = constant @\"a\";\n+                    java.labeled ()void -> {\n+                        %9 : java.lang.String = constant @\"b\";\n+                        java.block ()void -> {\n+                            yield;\n+                        };\n+                        yield;\n+                    };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        b:\n+        break b;\n+\n+        int i = 0;\n+        b:\n+        i++;\n+\n+        a: b: {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BreakContinueTest.java","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with cast expressions.\n+ * @build CastInstanceOfTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester CastInstanceOfTest\n+ *\/\n+\n+public class CastInstanceOfTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : CastInstanceOfTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.lang.String = cast %3 @\"java.lang.String\";\n+                %5 : Var<java.lang.String> = var %4 @\"s\";\n+                %6 : java.lang.String = var.load %5;\n+                %7 : Var<java.lang.String> = var %6 @\"ss\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1(Object o) {\n+        String s = (String) o;\n+        String ss = (String) s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : CastInstanceOfTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.util.List<java.lang.String> = cast %3 @\"java.util.List\";\n+                %5 : Var<java.util.List<java.lang.String>> = var %4 @\"l\";\n+                %6 : java.util.List<java.lang.String> = var.load %5;\n+                %7 : Var<java.util.Collection<java.lang.String>> = var %6 @\"c1\";\n+                %8 : java.util.List<java.lang.String> = var.load %5;\n+                %9 : Var<java.util.Collection<java.lang.String>> = var %8 @\"c2\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(Object o) {\n+        List<String> l = (List<String>) o;\n+        Collection<String> c1 = (List<String>) l;\n+        Collection<String> c2 = (Collection) l;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : CastInstanceOfTest, %1 : java.util.List<java.lang.String>)void -> {\n+                %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+                %3 : java.util.List<java.lang.String> = var.load %2;\n+                %4 : Var<java.util.List> = var %3 @\"raw\";\n+                %5 : java.util.List = var.load %4;\n+                %6 : Var<java.util.List<java.lang.Number>> = var %5 @\"ln\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3(List<String> l) {\n+        List raw = l;\n+        List<Number> ln = raw;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : CastInstanceOfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                %5 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int i) {\n+        long l = (int) i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : CastInstanceOfTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : boolean = instanceof %3 @\"java.lang.String\";\n+                %5 : Var<boolean> = var %4 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5(Object o) {\n+        boolean b = o instanceof String;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : CastInstanceOfTest, %1 : java.util.List<java.lang.Object>)void -> {\n+                %2 : Var<java.util.List<java.lang.Object>> = var %1 @\"l\";\n+                %3 : java.util.List<java.lang.Object> = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : java.lang.Object = invoke %3 %4 @\"java.util.List::get(int)java.lang.Object\";\n+                %6 : boolean = instanceof %5 @\"java.lang.String\";\n+                %7 : Var<boolean> = var %6 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6(List<Object> l) {\n+        boolean b = l.get(0) instanceof String;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/CastInstanceOfTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @summary test that invoking Method::getCodeModel returns the same instance.\n+ * @run testng CodeModelSameInstanceTest\n+ *\/\n+public class CodeModelSameInstanceTest {\n+\n+    @CodeReflection\n+    static int add(int a, int b) {\n+        return a + b;\n+    }\n+\n+    @Test\n+    void test() {\n+        Optional<Method> om = Arrays.stream(this.getClass().getDeclaredMethods()).filter(m -> m.getName().equals(\"add\"))\n+                .findFirst();\n+        Method m = om.get();\n+        Object[] codeModels = IntStream.range(0, 1024).mapToObj(_ -> m.getCodeModel()).toArray();\n+        for (int i = 1; i < codeModels.length; i++) {\n+            Assert.assertSame(codeModels[i], codeModels[i-1]);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeModelSameInstanceTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.VOID;\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+\n+public class CodeReflectionTester {\n+\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: CodeReflectionTester <classname>\");\n+            System.exit(1);\n+        }\n+        Class<?> clazz = Class.forName(args[0]);\n+        for (Method m : clazz.getDeclaredMethods()) {\n+            check(m);\n+        }\n+        for (Field f : clazz.getDeclaredFields()) {\n+            check(f);\n+        }\n+    }\n+\n+    static void check(Method method) throws ReflectiveOperationException {\n+        if (!method.isAnnotationPresent(CodeReflection.class)) return;\n+        Field field = method.getDeclaringClass().getDeclaredField(method.getName() + \"$op\");\n+        String found = canonicalizeModel(method, (String)field.get(null));\n+        IR ir = method.getAnnotation(IR.class);\n+        if (ir == null) {\n+            throw new AssertionError(\"No @IR annotation found on reflective method\");\n+        }\n+        String expected = canonicalizeModel(method, ir.value());\n+        if (!found.equals(expected)) {\n+            throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+        }\n+    }\n+\n+    static void check(Field field) throws ReflectiveOperationException {\n+        IR ir = field.getAnnotation(IR.class);\n+        if (ir == null) return;\n+        if (field.getType().equals(Quoted.class)) {\n+            \/\/ transitional\n+            Quoted quoted = (Quoted)field.get(null);\n+            String found = getModelOfQuotedOp(quoted);\n+            String expected = canonicalizeModel(field, ir.value());\n+            if (!found.equals(expected)) {\n+                throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+            }\n+        } else if (Quotable.class.isAssignableFrom(field.getType())) {\n+            Quotable quotable = (Quotable) field.get(null);\n+            String found = getModelOfQuotedOp(quotable.quoted());\n+            String expected = canonicalizeModel(field, ir.value());\n+            if (!found.equals(expected)) {\n+                throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+            }\n+        } else {\n+            throw new AssertionError(\"Field annotated with @IR should be of a quotable type (Quoted\/Quotable)\");\n+        }\n+    }\n+\n+    \/\/ parses and then serializes\n+    static String canonicalizeModel(Member m, String d) {\n+        try {\n+            return OpParser.fromString(ExtendedOps.FACTORY, d).get(0).toText();\n+        } catch (Exception e) {\n+            throw new IllegalStateException(m.toString(), e);\n+        }\n+    }\n+\n+    static String getModelOfQuotedOp(Quoted quoted) {\n+        return func(\"f\", VOID).body(fblock -> {\n+            CopyContext cc = fblock.context();\n+            for (Value cv : quoted.capturedValues().keySet()) {\n+                Block.Parameter p = fblock.parameter(cv.type());\n+                cc.mapValue(cv, p);\n+            }\n+\n+            Op qOp = quoted.op();\n+            \/\/ Associate the quoted ops ancestor body's entry block\n+            \/\/ with the function's entry block, thereby ensuring that\n+            \/\/ captured values mapped to the function's parameters\n+            \/\/ are reachable\n+            cc.mapBlock(qOp.ancestorBody().entryBlock(), fblock);\n+            fblock.op(qOp);\n+\n+            fblock.op(_return());\n+        }).toText();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with conditional and\/or expressions.\n+ * @build ConditionalAndOrTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ConditionalAndOrTest\n+ *\/\n+\n+public class ConditionalAndOrTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ConditionalAndOrTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : boolean = java.cand\n+                    ()boolean -> {\n+                        %4 : int = var.load %2;\n+                        %5 : int = constant @\"1\";\n+                        %6 : boolean = gt %4 %5;\n+                        yield %6;\n+                    }\n+                    ()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"10\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    };\n+                %10 : Var<boolean> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1(int i) {\n+        boolean b = i > 1 && i < 10;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ConditionalAndOrTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : boolean = java.cor\n+                    ()boolean -> {\n+                        %4 : int = var.load %2;\n+                        %5 : int = constant @\"1\";\n+                        %6 : boolean = gt %4 %5;\n+                        yield %6;\n+                    }\n+                    ()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"10\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    };\n+                %10 : Var<boolean> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int i) {\n+        boolean b = i > 1 || i < 10;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ConditionalAndOrTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : boolean = java.cor\n+                    ()boolean -> {\n+                        %4 : boolean = java.cand\n+                            ()boolean -> {\n+                                %5 : int = var.load %2;\n+                                %6 : int = constant @\"1\";\n+                                %7 : boolean = gt %5 %6;\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : int = var.load %2;\n+                                %9 : int = constant @\"10\";\n+                                %10 : boolean = lt %8 %9;\n+                                yield %10;\n+                            };\n+                        yield %4;\n+                    }\n+                    ()boolean -> {\n+                        %11 : int = var.load %2;\n+                        %12 : int = constant @\"100\";\n+                        %13 : boolean = eq %11 %12;\n+                        yield %13;\n+                    };\n+                %14 : Var<boolean> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3(int i) {\n+        boolean b = i > 1 && i < 10 || i == 100;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalAndOrTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with conditional expressions.\n+ * @build ConditionalExpressionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ConditionalExpressionTest\n+ *\/\n+\n+public class ConditionalExpressionTest {\n+\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : int, %3 : int)void -> {\n+                %4 : Var<boolean> = var %1 @\"b\";\n+                %5 : Var<int> = var %2 @\"x\";\n+                %6 : Var<int> = var %3 @\"y\";\n+                %7 : int = java.cexpression\n+                    ^cond()boolean -> {\n+                        %8 : boolean = var.load %4;\n+                        yield %8;\n+                    }\n+                    ^truepart()int -> {\n+                        %9 : int = var.load %5;\n+                        yield %9;\n+                    }\n+                    ^falsepart()int -> {\n+                        %10 : int = var.load %6;\n+                        yield %10;\n+                    };\n+                %11 : Var<int> = var %7 @\"z\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test1(boolean b, int x, int y) {\n+        int z = b ? x : y;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : int, %3 : double)void -> {\n+                %4 : Var<boolean> = var %1 @\"b\";\n+                %5 : Var<int> = var %2 @\"x\";\n+                %6 : Var<double> = var %3 @\"y\";\n+                %7 : double = java.cexpression\n+                    ^cond()boolean -> {\n+                        %8 : boolean = var.load %4;\n+                        %9 : boolean = not %8;\n+                        yield %9;\n+                    }\n+                    ^truepart()int -> {\n+                        %10 : int = var.load %5;\n+                        %11 : double = conv %10;\n+                        yield %11;\n+                    }\n+                    ^falsepart()double -> {\n+                        %12 : double = var.load %6;\n+                        yield %12;\n+                    };\n+                %13 : Var<double> = var %7 @\"z\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test2(boolean b, int x, double y) {\n+        double z = !b ? x : y;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : int, %3 : double)void -> {\n+                %4 : Var<boolean> = var %1 @\"b\";\n+                %5 : Var<int> = var %2 @\"x\";\n+                %6 : Var<double> = var %3 @\"y\";\n+                %7 : java.util.function.Supplier<java.lang.Double> = java.cexpression\n+                    ^cond()boolean -> {\n+                        %8 : boolean = var.load %4;\n+                        yield %8;\n+                    }\n+                    ^truepart()java.util.function.Supplier<java.lang.Double> -> {\n+                        %9 : java.util.function.Supplier<java.lang.Double> = lambda ()java.lang.Double -> {\n+                            %10 : int = var.load %5;\n+                            %11 : double = conv %10;\n+                            %12 : java.lang.Double = invoke %11 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                            return %12;\n+                        };\n+                        yield %9;\n+                    }\n+                    ^falsepart()java.util.function.Supplier<java.lang.Double> -> {\n+                        %13 : java.util.function.Supplier<java.lang.Double> = lambda ()java.lang.Double -> {\n+                            %14 : double = var.load %6;\n+                            %15 : java.lang.Double = invoke %14 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                            return %15;\n+                        };\n+                        yield %13;\n+                    };\n+                %16 : Var<java.util.function.Supplier<java.lang.Double>> = var %7 @\"z\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test3(boolean b, int x, double y) {\n+        Supplier<Double> z = b ? () -> (double) x : () -> y;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : boolean, %3 : int, %4 : double, %5 : double)void -> {\n+                %6 : Var<boolean> = var %1 @\"b1\";\n+                %7 : Var<boolean> = var %2 @\"b2\";\n+                %8 : Var<int> = var %3 @\"x\";\n+                %9 : Var<double> = var %4 @\"y\";\n+                %10 : Var<double> = var %5 @\"z\";\n+                %11 : double = java.cexpression\n+                    ^cond()boolean -> {\n+                        %12 : boolean = var.load %6;\n+                        yield %12;\n+                    }\n+                    ^truepart()double -> {\n+                        %13 : double = java.cexpression\n+                            ^cond()boolean -> {\n+                                %14 : boolean = var.load %7;\n+                                yield %14;\n+                            }\n+                            ^truepart()int -> {\n+                                %15 : int = var.load %8;\n+                                %16 : double = conv %15;\n+                                yield %16;\n+                            }\n+                            ^falsepart()double -> {\n+                                %17 : double = var.load %9;\n+                                yield %17;\n+                            };\n+                        yield %13;\n+                    }\n+                    ^falsepart()double -> {\n+                        %18 : double = var.load %10;\n+                        yield %18;\n+                    };\n+                %19 : Var<double> = var %11 @\"r\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test4(boolean b1, boolean b2, int x, double y, double z) {\n+        double r = b1 ? (b2 ? x : y) : z;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalExpressionTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with constant values.\n+ * @build ConstantsTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ConstantsTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Function;\n+\n+public class ConstantsTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.String = constant @\"\";\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        String s = \"\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.String = constant @\"Hello World\";\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        String s = \"Hello World\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        String s = null;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"java.util.function.Function\";\n+                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test4() {\n+        Class<?> s = Function.class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : ConstantsTest)void -> {\n+                %1 : int = constant @\"42\";\n+                %2 : byte = conv %1;\n+                %3 : Var<byte> = var %2 @\"v\";\n+                %4 : int = constant @\"-42\";\n+                %5 : byte = conv %4;\n+                var.store %3 %5;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test5() {\n+        byte v = 42;\n+        v = -42;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : ConstantsTest)void -> {\n+                %1 : int = constant @\"42\";\n+                %2 : short = conv %1;\n+                %3 : Var<short> = var %2 @\"v\";\n+                %4 : int = constant @\"-42\";\n+                %5 : short = conv %4;\n+                var.store %3 %5;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test6() {\n+        short v = 42;\n+        v = -42;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : ConstantsTest)void -> {\n+                %1 : int = constant @\"42\";\n+                %2 : Var<int> = var %1 @\"v\";\n+                %3 : int = constant @\"-42\";\n+                var.store %2 %3;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test7() {\n+        int v = 42;\n+        v = -42;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : ConstantsTest)void -> {\n+                %1 : long = constant @\"42\";\n+                %2 : Var<long> = var %1 @\"v\";\n+                %3 : long = constant @\"-42\";\n+                var.store %2 %3;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test8() {\n+        long v = 42L;\n+        v = -42L;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : ConstantsTest)void -> {\n+                %1 : float = constant @\"42.0\";\n+                %2 : Var<float> = var %1 @\"v\";\n+                %3 : float = constant @\"42.0\";\n+                %4 : float = neg %3;\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test9() {\n+        float v = 42.0f;\n+        v = -42.0f;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : ConstantsTest)void -> {\n+                %1 : double = constant @\"42.0\";\n+                %2 : Var<double> = var %1 @\"v\";\n+                %3 : double = constant @\"42.0\";\n+                %4 : double = neg %3;\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test10() {\n+        double v = 42.0;\n+        v = -42.0;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : ConstantsTest)void -> {\n+                %1 : char = constant @\"a\";\n+                %2 : Var<char> = var %1 @\"v\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test11() {\n+        char v = 'a';\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : ConstantsTest)void -> {\n+                %1 : boolean = constant @\"true\";\n+                %2 : Var<boolean> = var %1 @\"b\";\n+                %3 : boolean = constant @\"false\";\n+                var.store %2 %3;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test12() {\n+        boolean b = true;\n+        b = false;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"float\";\n+                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test13() {\n+        Class<?> s = float.class;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConstantsTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for non-denotable types in IR type descriptors\n+ * @build DenotableTypesTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester DenotableTypesTest\n+ *\/\n+\n+public class DenotableTypesTest {\n+    static <X extends Number & Runnable> X m1(X x) { return null; }\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" ()void -> {\n+                %0 : java.lang.Number = constant @null;\n+                %1 : java.lang.Number = invoke %0 @\"DenotableTypesTest::m1(java.lang.Number)java.lang.Number\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test1() {\n+        m1(null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" ()void -> {\n+                %0 : int = constant @\"1\";\n+                %1 : java.lang.Integer = invoke %0 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %2 : double = constant @\"3.0\";\n+                %3 : java.lang.Double = invoke %2 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                %4 : java.util.List = invoke %1 %3 @\"java.util.List::of(java.lang.Object, java.lang.Object)java.util.List\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test2() {\n+        List.of(1, 3d); \/\/ infinite type! (List<Object & Serializable & Comparable<...>>)\n+    }\n+\n+    static <X extends Throwable> X m2(X x) throws X { return null; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" ()void -> {\n+                %0 : java.lang.RuntimeException = constant @null;\n+                %1 : java.lang.RuntimeException = invoke %0 @\"DenotableTypesTest::m2(java.lang.Throwable)java.lang.Throwable\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test3() { \/\/ @@@ cast?\n+        m2(null);\n+    }\n+\n+    interface A { }\n+    interface B { }\n+    static class C implements A, B { }\n+    static class D implements A, B { }\n+\n+    static <Z> Z pick(Z z1, Z z2) { return null; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" ()void -> {\n+                %0 : java.lang.Object = constant @null;\n+                %1 : DenotableTypesTest$C = cast %0 @\"DenotableTypesTest$C\";\n+                %2 : java.lang.Object = constant @null;\n+                %3 : DenotableTypesTest$D = cast %2 @\"DenotableTypesTest$D\";\n+                %4 : DenotableTypesTest$A = invoke %1 %3 @\"DenotableTypesTest::pick(java.lang.Object, java.lang.Object)java.lang.Object\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test4() { \/\/ @@@ cast?\n+        pick((C)null, (D)null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" ()void -> {\n+                  %0 : java.util.List = constant @null;\n+                  %1 : Var<java.util.List> = var %0 @\"l\";\n+                  %2 : java.util.List = var.load %1;\n+                  %3 : int = constant @\"0\";\n+                  %4 : java.lang.Number = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test5() { \/\/ @@@ cast?\n+        List<? extends Number> l = null;\n+        l.get(0);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" ()void -> {\n+                  %0 : java.util.List = constant @null;\n+                  %1 : Var<java.util.List> = var %0 @\"l\";\n+                  %2 : java.util.List = var.load %1;\n+                  %3 : int = constant @\"0\";\n+                  %4 : java.lang.Object = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test6() {\n+        List<? super Number> l = null;\n+        l.get(0);\n+    }\n+\n+    static void consume(Runnable r) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" ()void -> {\n+                %0 : java.lang.Object = constant @null;\n+                %1 : Var<java.lang.Object> = var %0 @\"x\";\n+                %2 : java.lang.Object = var.load %1;\n+                %3 : java.lang.Runnable = cast %2 @\"java.lang.Runnable\";\n+                invoke %3 @\"DenotableTypesTest::consume(java.lang.Runnable)void\";\n+                return;\n+            };\n+            \"\"\")\n+    static <X extends Object & Runnable> void test7() {\n+        X x = null;\n+        consume(x);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.constant.DirectMethodHandleDesc.Kind;\n+import static java.lang.constant.DirectMethodHandleDesc.Kind.VIRTUAL;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with enum access.\n+ * @build EnumAccessTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester EnumAccessTest\n+ *\/\n+\n+public class EnumAccessTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : EnumAccessTest)java.lang.constant.DirectMethodHandleDesc$Kind -> {\n+                %1 : java.lang.constant.DirectMethodHandleDesc$Kind = field.load @\"java.lang.constant.DirectMethodHandleDesc$Kind::VIRTUAL()java.lang.constant.DirectMethodHandleDesc$Kind\";\n+                return %1;\n+            };\n+            \"\"\")\n+    DirectMethodHandleDesc.Kind test1() {\n+        return DirectMethodHandleDesc.Kind.VIRTUAL;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : EnumAccessTest)java.lang.constant.DirectMethodHandleDesc$Kind -> {\n+                %1 : java.lang.constant.DirectMethodHandleDesc$Kind = field.load @\"java.lang.constant.DirectMethodHandleDesc$Kind::VIRTUAL()java.lang.constant.DirectMethodHandleDesc$Kind\";\n+                return %1;\n+            };\n+            \"\"\")\n+    DirectMethodHandleDesc.Kind test2() {\n+        return Kind.VIRTUAL;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : EnumAccessTest)java.lang.constant.DirectMethodHandleDesc$Kind -> {\n+                %1 : java.lang.constant.DirectMethodHandleDesc$Kind = field.load @\"java.lang.constant.DirectMethodHandleDesc$Kind::VIRTUAL()java.lang.constant.DirectMethodHandleDesc$Kind\";\n+                return %1;\n+            };\n+            \"\"\")\n+    DirectMethodHandleDesc.Kind test3() {\n+        return VIRTUAL;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/EnumAccessTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,638 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Spliterator;\n+import java.util.Spliterator.OfInt;\n+\n+import static java.lang.System.out;\n+import static java.util.Spliterator.OfInt.*;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with field access.\n+ * @build FieldAccessTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester FieldAccessTest\n+ *\/\n+\n+public class FieldAccessTest {\n+    static int s_f;\n+    int f;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %1 @\"FieldAccessTest::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                field.store %0 %2 @\"FieldAccessTest::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        s_f = 1;\n+        f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1_1\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %6 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1_1() {\n+        f += 1;\n+        s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %0 %1 @\"FieldAccessTest::f()int\";\n+                field.store %1 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        s_f = f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_1\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %0 %1 @\"FieldAccessTest::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2_1() {\n+        this.f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_2\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test2_2() {\n+        return this.f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %2 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %3 : int = add %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test3() {\n+        return s_f + f;\n+    }\n+\n+    static class A {\n+        B b;\n+    }\n+\n+    static class B {\n+        C c;\n+    }\n+\n+    static class C {\n+        int f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : FieldAccessTest, %1 : FieldAccessTest$A)void -> {\n+                %2 : Var<FieldAccessTest$A> = var %1 @\"a\";\n+                %3 : FieldAccessTest$A = var.load %2;\n+                %4 : FieldAccessTest$B = field.load %3 @\"FieldAccessTest$A::b()FieldAccessTest$B\";\n+                %5 : FieldAccessTest$C = field.load %4 @\"FieldAccessTest$B::c()FieldAccessTest$C\";\n+                %6 : int = constant @\"1\";\n+                field.store %5 %6 @\"FieldAccessTest$C::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4(A a) {\n+        a.b.c.f = 1;\n+    }\n+\n+    static class X {\n+        int f;\n+        static int s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load @\"FieldAccessTest$X::s_f()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test5() {\n+        return X.s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %1 @\"FieldAccessTest$X::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        X.s_f = 1;\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %6 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        f += 1;\n+        s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %6 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        this.f += 1;\n+        this.s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"FieldAccessTest$X::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %3 @\"FieldAccessTest$X::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9() {\n+        X.s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                field.store %3 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10() {\n+        s_f = f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : FieldAccessTest, %1 : FieldAccessTest$A)void -> {\n+                %2 : Var<FieldAccessTest$A> = var %1 @\"a\";\n+                %3 : FieldAccessTest$A = var.load %2;\n+                %4 : FieldAccessTest$B = field.load %3 @\"FieldAccessTest$A::b()FieldAccessTest$B\";\n+                %5 : FieldAccessTest$C = field.load %4 @\"FieldAccessTest$B::c()FieldAccessTest$C\";\n+                %6 : int = field.load %5 @\"FieldAccessTest$C::f()int\";\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                field.store %5 %8 @\"FieldAccessTest$C::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(A a) {\n+        a.b.c.f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %1 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %5 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test12() {\n+        int x = f++;\n+        int y = f--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %1 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %5 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13() {\n+        int x = this.f++;\n+        int y = this.f--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %3 @\"FieldAccessTest::s_f()int\";\n+                %4 : Var<int> = var %1 @\"x\";\n+                %5 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %7 @\"FieldAccessTest::s_f()int\";\n+                %8 : Var<int> = var %5 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14() {\n+        int x = s_f++;\n+        int y = s_f--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : FieldAccessTest, %1 : FieldAccessTest$X)void -> {\n+                %2 : Var<FieldAccessTest$X> = var %1 @\"h\";\n+                %3 : FieldAccessTest$X = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$X::f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %3 %6 @\"FieldAccessTest$X::f()int\";\n+                %7 : Var<int> = var %4 @\"x\";\n+                %8 : FieldAccessTest$X = var.load %2;\n+                %9 : int = field.load %8 @\"FieldAccessTest$X::f()int\";\n+                %10 : int = constant @\"1\";\n+                %11 : int = sub %9 %10;\n+                field.store %8 %11 @\"FieldAccessTest$X::f()int\";\n+                %12 : Var<int> = var %9 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(X h) {\n+        int x = h.f++;\n+        int y = h.f--;\n+    }\n+\n+\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %3 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16() {\n+        int x = ++f;\n+        int y = --f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %3 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17() {\n+        int x = ++this.f;\n+        int y = --this.f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %3 @\"FieldAccessTest::s_f()int\";\n+                %4 : Var<int> = var %3 @\"x\";\n+                %5 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %7 @\"FieldAccessTest::s_f()int\";\n+                %8 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18() {\n+        int x = ++s_f;\n+        int y = --s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test19\" (%0 : FieldAccessTest, %1 : FieldAccessTest$X)void -> {\n+                %2 : Var<FieldAccessTest$X> = var %1 @\"h\";\n+                %3 : FieldAccessTest$X = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$X::f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %3 %6 @\"FieldAccessTest$X::f()int\";\n+                %7 : Var<int> = var %6 @\"x\";\n+                %8 : FieldAccessTest$X = var.load %2;\n+                %9 : int = field.load %8 @\"FieldAccessTest$X::f()int\";\n+                %10 : int = constant @\"1\";\n+                %11 : int = sub %9 %10;\n+                field.store %8 %11 @\"FieldAccessTest$X::f()int\";\n+                %12 : Var<int> = var %11 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test19(X h) {\n+        int x = ++h.f;\n+        int y = --h.f;\n+    }\n+\n+    static class Y extends X {\n+        int yf;\n+        static int s_yf;\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test\" (%0 : FieldAccessTest$Y)void -> {\n+                    %1 : int = field.load %0 @\"FieldAccessTest$Y::f()int\";\n+                    %2 : Var<int> = var %1 @\"x\";\n+                    %3 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                    var.store %2 %3;\n+                    return;\n+                };\n+                \"\"\")\n+        void test() {\n+            int x = f;\n+            x = s_f;\n+        }\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test2\" (%0 : FieldAccessTest$Y)void -> {\n+                    %1 : int = constant @\"1\";\n+                    field.store %0 %1 @\"FieldAccessTest$Y::f()int\";\n+                    %2 : int = constant @\"1\";\n+                    field.store %2 @\"FieldAccessTest$Y::s_f()int\";\n+                    return;\n+                };\n+                \"\"\")\n+        void test2() {\n+            f = 1;\n+            s_f = 1;\n+        }\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test3\" (%0 : FieldAccessTest$Y)void -> {\n+                    %1 : int = field.load %0 @\"FieldAccessTest$Y::f()int\";\n+                    %2 : int = constant @\"1\";\n+                    %3 : int = add %1 %2;\n+                    field.store %0 %3 @\"FieldAccessTest$Y::f()int\";\n+                    %4 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                    %5 : int = constant @\"1\";\n+                    %6 : int = add %4 %5;\n+                    field.store %6 @\"FieldAccessTest$Y::s_f()int\";\n+                    return;\n+                };\n+                \"\"\")\n+        void test3() {\n+            f++;\n+            s_f++;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0 : FieldAccessTest, %1 : FieldAccessTest$Y)void -> {\n+                %2 : Var<FieldAccessTest$Y> = var %1 @\"y\";\n+                %3 : FieldAccessTest$Y = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$Y::f()int\";\n+                %5 : Var<int> = var %4 @\"x\";\n+                %6 : FieldAccessTest$Y = var.load %2;\n+                %7 : int = field.load %6 @\"FieldAccessTest$Y::yf()int\";\n+                var.store %5 %7;\n+                %8 : FieldAccessTest$Y = var.load %2;\n+                %9 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                var.store %5 %9;\n+                %10 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                var.store %5 %10;\n+                %11 : FieldAccessTest$Y = var.load %2;\n+                %12 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                var.store %5 %12;\n+                %13 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                var.store %5 %13;\n+                return;\n+            };\n+            \"\"\")\n+    void test20(Y y) {\n+        int x = y.f;\n+        x = y.yf;\n+        x = y.s_yf;\n+        x = Y.s_yf;\n+        x = y.s_f;\n+        x = Y.s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0 : FieldAccessTest, %1 : FieldAccessTest$Y)void -> {\n+                %2 : Var<FieldAccessTest$Y> = var %1 @\"y\";\n+                %3 : FieldAccessTest$Y = var.load %2;\n+                %4 : int = constant @\"1\";\n+                field.store %3 %4 @\"FieldAccessTest$Y::f()int\";\n+                %5 : FieldAccessTest$Y = var.load %2;\n+                %6 : int = constant @\"1\";\n+                field.store %5 %6 @\"FieldAccessTest$Y::yf()int\";\n+                %7 : FieldAccessTest$Y = var.load %2;\n+                %8 : int = constant @\"1\";\n+                field.store %8 @\"FieldAccessTest$Y::s_yf()int\";\n+                %9 : int = constant @\"1\";\n+                field.store %9 @\"FieldAccessTest$Y::s_yf()int\";\n+                %10 : FieldAccessTest$Y = var.load %2;\n+                %11 : int = constant @\"1\";\n+                field.store %11 @\"FieldAccessTest$Y::s_f()int\";\n+                %12 : int = constant @\"1\";\n+                field.store %12 @\"FieldAccessTest$Y::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21(Y y) {\n+        y.f = 1;\n+        y.yf = 1;\n+        y.s_yf = 1;\n+        Y.s_yf = 1;\n+        y.s_f = 1;\n+        Y.s_f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+          func @\"test22\" (%0 : FieldAccessTest, %1 : FieldAccessTest$Y)void -> {\n+                %2 : Var<FieldAccessTest$Y> = var %1 @\"y\";\n+                %3 : FieldAccessTest$Y = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$Y::f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %3 %6 @\"FieldAccessTest$Y::f()int\";\n+                %7 : FieldAccessTest$Y = var.load %2;\n+                %8 : int = field.load %7 @\"FieldAccessTest$Y::yf()int\";\n+                %9 : int = constant @\"1\";\n+                %10 : int = add %8 %9;\n+                field.store %7 %10 @\"FieldAccessTest$Y::yf()int\";\n+                %11 : FieldAccessTest$Y = var.load %2;\n+                %12 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                %13 : int = constant @\"1\";\n+                %14 : int = add %12 %13;\n+                field.store %14 @\"FieldAccessTest$Y::s_yf()int\";\n+                %15 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                %16 : int = constant @\"1\";\n+                %17 : int = add %15 %16;\n+                field.store %17 @\"FieldAccessTest$Y::s_yf()int\";\n+                %18 : FieldAccessTest$Y = var.load %2;\n+                %19 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                %20 : int = constant @\"1\";\n+                %21 : int = add %19 %20;\n+                field.store %21 @\"FieldAccessTest$Y::s_f()int\";\n+                %22 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                %23 : int = constant @\"1\";\n+                %24 : int = add %22 %23;\n+                field.store %24 @\"FieldAccessTest$Y::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test22(Y y) {\n+        y.f++;\n+        y.yf++;\n+        y.s_yf++;\n+        Y.s_yf++;\n+        y.s_f++;\n+        Y.s_f++;\n+    }\n+\n+    \/\/ @@@ Should propagate as constant value?\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test23\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"java.util.Spliterator$OfInt::CONCURRENT()int\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = field.load @\"java.util.Spliterator$OfInt::CONCURRENT()int\";\n+                var.store %2 %3;\n+                %4 : int = field.load @\"java.util.Spliterator$OfInt::CONCURRENT()int\";\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    void test23() {\n+        int x = Spliterator.OfInt.CONCURRENT;\n+        x = OfInt.CONCURRENT;\n+        x = CONCURRENT;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test24\" (%0 : FieldAccessTest)void -> {\n+                %1 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %2 : Var<java.io.PrintStream> = var %1 @\"ps\";\n+                return;\n+            };\n+            \"\"\")\n+    void test24() {\n+        PrintStream ps = out;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":638,"deletions":0,"binary":false,"changes":638,"status":"added"},{"patch":"@@ -0,0 +1,600 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with for loops.\n+ * @build ForLoopTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ForLoopTest\n+ *\/\n+\n+public class ForLoopTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ForLoopTest, %1 : java.util.List<java.util.List<java.lang.String>>)void -> {\n+              %2 : Var<java.util.List<java.util.List<java.lang.String>>> = var %1 @\"ll\";\n+              java.enhancedFor\n+                  ^expr()java.util.List<java.util.List<java.lang.String>> -> {\n+                      %3 : java.util.List<java.util.List<java.lang.String>> = var.load %2;\n+                      yield %3;\n+                  }\n+                  ^def(%4 : java.util.List<java.lang.String>)Var<java.util.List<java.lang.String>> -> {\n+                      %5 : Var<java.util.List<java.lang.String>> = var %4 @\"l\";\n+                      yield %5;\n+                  }\n+                  ^body(%6 : Var<java.util.List<java.lang.String>>)void -> {\n+                      java.enhancedFor\n+                          ^expr()java.util.List<java.lang.String> -> {\n+                              %7 : java.util.List<java.lang.String> = var.load %6;\n+                              yield %7;\n+                          }\n+                          ^def(%8 : java.lang.String)Var<java.lang.String> -> {\n+                              %9 : Var<java.lang.String> = var %8 @\"s\";\n+                              yield %9;\n+                          }\n+                          ^body(%10 : Var<java.lang.String>)void -> {\n+                              %11 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                              %12 : java.lang.String = var.load %10;\n+                              invoke %11 %12 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                              java.continue;\n+                          };\n+                      java.continue;\n+                  };\n+              return;\n+            };\n+            \"\"\")\n+    void test1(List<List<String>> ll) {\n+        for (List<String> l : ll) {\n+            for (String s : l) {\n+                System.out.println(s);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ForLoopTest, %1 : java.util.List<java.lang.String>)void -> {\n+                %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+                java.enhancedFor\n+                    ^expr()java.util.List<java.lang.String> -> {\n+                        %3 : java.util.List<java.lang.String> = var.load %2;\n+                        %4 : java.util.stream.Stream<java.lang.String> = invoke %3 @\"java.util.List::stream()java.util.stream.Stream\";\n+                        %5 : java.util.function.Predicate<java.lang.String> = lambda (%6 : java.lang.String)boolean -> {\n+                            %7 : Var<java.lang.String> = var %6 @\"s\";\n+                            %8 : java.lang.String = var.load %7;\n+                            %9 : int = invoke %8 @\"java.lang.String::length()int\";\n+                            %10 : int = constant @\"10\";\n+                            %11 : boolean = lt %9 %10;\n+                            return %11;\n+                        };\n+                        %12 : java.util.stream.Stream<java.lang.String> = invoke %4 %5 @\"java.util.stream.Stream::filter(java.util.function.Predicate)java.util.stream.Stream\";\n+                        %13 : java.util.List<java.lang.String> = invoke %12 @\"java.util.stream.Stream::toList()java.util.List\";\n+                        yield %13;\n+                    }\n+                    ^def(%14 : java.lang.String)Var<java.lang.String> -> {\n+                        %15 : Var<java.lang.String> = var %14 @\"s\";\n+                        yield %15;\n+                    }\n+                    ^body(%16 : Var<java.lang.String>)void -> {\n+                        %17 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %18 : java.lang.String = var.load %16;\n+                        invoke %17 %18 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2(List<String> l) {\n+        for (String s : l.stream().filter(s -> s.length() < 10).toList()) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_1\" (%0 : ForLoopTest, %1 : java.util.List<java.lang.String>)void -> {\n+              %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+              java.enhancedFor\n+                  ^expr()java.util.List<java.lang.String> -> {\n+                      %3 : java.util.List<java.lang.String> = var.load %2;\n+                      yield %3;\n+                  }\n+                  ^def(%4 : java.lang.String)Var<java.lang.String> -> {\n+                      %5 : Var<java.lang.String> = var %4 @\"s\";\n+                      yield %5;\n+                  }\n+                  ^body(%6 : Var<java.lang.String>)void -> {\n+                      java.continue;\n+                  };\n+              return;\n+            };\n+            \"\"\")\n+    void test2_1(List<String> l) {\n+        for (String s : l);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_2\" (%0 : ForLoopTest, %1 : java.util.List<java.lang.String>)java.lang.String -> {\n+              %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+              java.enhancedFor\n+                  ^expr()java.util.List<java.lang.String> -> {\n+                      %3 : java.util.List<java.lang.String> = var.load %2;\n+                      yield %3;\n+                  }\n+                  ^def(%4 : java.lang.String)Var<java.lang.String> -> {\n+                      %5 : Var<java.lang.String> = var %4 @\"s\";\n+                      yield %5;\n+                  }\n+                  ^body(%6 : Var<java.lang.String>)void -> {\n+                      %7 : java.lang.String = var.load %6;\n+                      return %7;\n+                  };\n+              %8 : java.lang.String = constant @\"\";\n+              return %8;\n+            };\n+            \"\"\")\n+    String test2_2(List<String> l) {\n+        for (String s : l) {\n+            return s;\n+        }\n+        return \"\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : int = var.load %11;\n+                        invoke %12 %13 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        for (int i = 0; i < 10; i++) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3_1\" (%0 : ForLoopTest)int -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        %12 : int = var.load %11;\n+                        return %12;\n+                    };\n+                %13 : int = constant @\"-1\";\n+                return %13;\n+            };\n+            \"\"\")\n+    int test3_1() {\n+        for (int i = 0; i < 10; i++) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : int = var.load %11;\n+                        invoke %12 %13 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        for (int i = 0; i < 10; i = i + 1)\n+            System.out.println(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        for (int i = 0; i < 10; i = i + 1);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : ForLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.for\n+                    ^init()void -> {\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"10\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^update()void -> {\n+                        %6 : int = var.load %2;\n+                        %7 : int = constant @\"1\";\n+                        %8 : int = add %6 %7;\n+                        var.store %2 %8;\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        %9 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %10 : int = var.load %2;\n+                        invoke %9 %10 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        int i = 0;\n+        for (; i < 10; i = i + 1) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : ForLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.for\n+                    ^init()void -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : int = add %3 %4;\n+                        var.store %2 %5;\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %6 : int = var.load %2;\n+                        %7 : int = constant @\"10\";\n+                        %8 : boolean = lt %6 %7;\n+                        yield %8;\n+                    }\n+                    ^update()void -> {\n+                        %9 : int = var.load %2;\n+                        %10 : int = constant @\"1\";\n+                        %11 : int = add %9 %10;\n+                        var.store %2 %11;\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : int = var.load %2;\n+                        invoke %12 %13 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        int i = 0;\n+        for (i = i + 1; i < 10; i = i + 1) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : boolean = constant @\"true\";\n+                        yield %4;\n+                    }\n+                    ^update(%5 : Var<int>)void -> {\n+                        %6 : int = var.load %5;\n+                        %7 : int = constant @\"1\";\n+                        %8 : int = add %6 %7;\n+                        var.store %5 %8;\n+                        yield;\n+                    }\n+                    ^body(%9 : Var<int>)void -> {\n+                        %10 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %11 : int = var.load %9;\n+                        invoke %10 %11 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        for (int i = 0; ; i = i + 1) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : boolean = constant @\"true\";\n+                        yield %4;\n+                    }\n+                    ^update(%5 : Var<int>)void -> {\n+                        yield;\n+                    }\n+                    ^body(%6 : Var<int>)void -> {\n+                        %7 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %8 : int = var.load %6;\n+                        invoke %7 %8 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test9() {\n+        for (int i = 0; ; ) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()void -> {\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %1 : boolean = constant @\"true\";\n+                        yield %1;\n+                    }\n+                    ^update()void -> {\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test10() {\n+        for (; ; ) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()java.lang.reflect.code.CoreOps$Tuple<Var<int>, Var<int>> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        %3 : int = constant @\"0\";\n+                        %4 : Var<int> = var %3 @\"j\";\n+                        %5 : java.lang.reflect.code.CoreOps$Tuple<Var<int>, Var<int>> = tuple %2 %4;\n+                        yield %5;\n+                    }\n+                    ^cond(%6 : Var<int>, %7 : Var<int>)boolean -> {\n+                        %8 : boolean = java.cand\n+                            ()boolean -> {\n+                                %9 : int = var.load %6;\n+                                %10 : int = constant @\"10\";\n+                                %11 : boolean = lt %9 %10;\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %12 : int = var.load %7;\n+                                %13 : int = constant @\"20\";\n+                                %14 : boolean = lt %12 %13;\n+                                yield %14;\n+                            };\n+                        yield %8;\n+                    }\n+                    ^update(%15 : Var<int>, %16 : Var<int>)void -> {\n+                        %17 : int = var.load %15;\n+                        %18 : int = constant @\"1\";\n+                        %19 : int = add %17 %18;\n+                        var.store %15 %19;\n+                        %20 : int = var.load %16;\n+                        %21 : int = constant @\"2\";\n+                        %22 : int = add %20 %21;\n+                        var.store %16 %22;\n+                        yield;\n+                    }\n+                    ^body(%23 : Var<int>, %24 : Var<int>)void -> {\n+                        %25 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %26 : int = var.load %23;\n+                        invoke %25 %26 @\"java.io.PrintStream::println(int)void\";\n+                        %27 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %28 : int = var.load %24;\n+                        invoke %27 %28 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test11() {\n+        for (int i = 0, j = 0; i < 10 && j < 20; i = i + 1, j = j + 2) {\n+            System.out.println(i);\n+            System.out.println(j);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : ForLoopTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"r\";\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %3 : int = constant @\"0\";\n+                        %4 : Var<int> = var %3 @\"i\";\n+                        yield %4;\n+                    }\n+                    ^cond(%5 : Var<int>)boolean -> {\n+                        %6 : int = var.load %5;\n+                        %7 : int = constant @\"10\";\n+                        %8 : boolean = lt %6 %7;\n+                        yield %8;\n+                    }\n+                    ^update(%9 : Var<int>)void -> {\n+                        %10 : int = var.load %9;\n+                        %11 : int = constant @\"1\";\n+                        %12 : int = add %10 %11;\n+                        var.store %9 %12;\n+                        yield;\n+                    }\n+                    ^body(%13 : Var<int>)void -> {\n+                        java.if\n+                            ()boolean -> {\n+                                %14 : int = var.load %2;\n+                                %15 : int = constant @\"0\";\n+                                %16 : boolean = eq %14 %15;\n+                                yield %16;\n+                            }\n+                            ^then()void -> {\n+                                java.break;\n+                            }\n+                            ^else_if()boolean -> {\n+                                %17 : int = var.load %2;\n+                                %18 : int = constant @\"1\";\n+                                %19 : boolean = eq %17 %18;\n+                                yield %19;\n+                            }\n+                            ^then()void -> {\n+                                java.continue;\n+                            }\n+                            ^else()void -> {\n+                                yield;\n+                            };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int r) {\n+        for (int i = 0; i < 10; i++) {\n+            if (r == 0) {\n+                break;\n+            } else if (r == 1) {\n+                continue;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":600,"deletions":0,"binary":false,"changes":600,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.*;\n+\n+@Target({ElementType.METHOD, ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface IR {\n+    String value();\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/IR.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with if statements.\n+ * @build IfTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester IfTest\n+ *\/\n+\n+public class IfTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        %7 : int = constant @\"2\";\n+                        var.store %2 %7;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        } else {\n+            i = 2;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else_if()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"2\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    }\n+                    ^then()void -> {\n+                        %10 : int = constant @\"2\";\n+                        var.store %2 %10;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        } else if (i < 2) {\n+            i = 2;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else_if()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"2\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    }\n+                    ^then()void -> {\n+                        %10 : int = constant @\"2\";\n+                        var.store %2 %10;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        %11 : int = constant @\"3\";\n+                        var.store %2 %11;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        } else if (i < 2) {\n+            i = 2;\n+        } else {\n+            i = 3;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : IfTest, %1 : int)int -> {\n+              %2 : Var<int> = var %1 @\"i\";\n+              java.if\n+                  ()boolean -> {\n+                      %3 : int = var.load %2;\n+                      %4 : int = constant @\"1\";\n+                      %5 : boolean = lt %3 %4;\n+                      yield %5;\n+                  }\n+                  ^then()void -> {\n+                      %6 : int = constant @\"1\";\n+                      return %6;\n+                  }\n+                  ^else_if()boolean -> {\n+                      %7 : int = var.load %2;\n+                      %8 : int = constant @\"2\";\n+                      %9 : boolean = lt %7 %8;\n+                      yield %9;\n+                  }\n+                  ^then()void -> {\n+                      %10 : int = constant @\"2\";\n+                      return %10;\n+                  }\n+                  ^else()void -> {\n+                      %11 : int = constant @\"3\";\n+                      return %11;\n+                  };\n+              return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    int test5(int i) {\n+        if (i < 1) {\n+            return 1;\n+        } else if (i < 2) {\n+            return 2;\n+        } else {\n+            return 3;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,570 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.LongSupplier;\n+\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with implicit conversions.\n+ * @enablePreview\n+ * @build ImplicitConversionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ImplicitConversionTest\n+ *\/\n+\n+public class ImplicitConversionTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0: ImplicitConversionTest)void -> {\n+                %1 : int = constant @\"1\";\n+                %2 : long = conv %1;\n+                %3 : Var<long> = var %2 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        long x = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0: ImplicitConversionTest)void -> {\n+                %1 : long = constant @\"0\";\n+                %2 : Var<long> = var %1 @\"x\";\n+                %3 : int = constant @\"1\";\n+                %4 : long = conv %3;\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        long x;\n+        x = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0: ImplicitConversionTest)void -> {\n+                %1 : long = constant @\"0\";\n+                %2 : Var<long> = var %1 @\"x\";\n+                %3 : long = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : long = conv %4;\n+                %6 : long = add %3 %5;\n+                var.store %2 %6;\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        long x = 0L;\n+        x += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0: ImplicitConversionTest, %1 : boolean)void -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : long = constant @\"0\";\n+                %4 : Var<long> = var %3 @\"x\";\n+                %5 : long = java.cexpression\n+                    ^cond()boolean -> {\n+                        %6 : boolean = var.load %2;\n+                        yield %6;\n+                    }\n+                    ^truepart()long -> {\n+                        %7 : long = constant @\"1\";\n+                        yield %7;\n+                    }\n+                    ^falsepart()int -> {\n+                        %8 : int = constant @\"2\";\n+                        %9 : long = conv %8;\n+                        yield %9;\n+                    };\n+                var.store %4 %5;\n+                return;\n+            };\n+            \"\"\")\n+    void test4(boolean cond) {\n+        long x;\n+        x = cond ? 1L : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test5\" (%0: ImplicitConversionTest, %1 : boolean)void -> {\n+               %2 : Var<boolean> = var %1 @\"cond\";\n+               %3 : long = constant @\"0\";\n+               %4 : Var<long> = var %3 @\"x\";\n+               %5 : long = java.cexpression\n+                   ^cond()boolean -> {\n+                       %6 : boolean = var.load %2;\n+                       yield %6;\n+                   }\n+                   ^truepart()int -> {\n+                       %7 : int = constant @\"1\";\n+                       %8 : long = conv %7;\n+                       yield %8;\n+                   }\n+                   ^falsepart()long -> {\n+                       %9 : long = constant @\"2\";\n+                       yield %9;\n+                   };\n+               var.store %4 %5;\n+               return;\n+           };\n+           \"\"\")\n+    void test5(boolean cond) {\n+        long x;\n+        x = cond ? 1 : 2L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test6\" (%0: ImplicitConversionTest, %1 : boolean)void -> {\n+               %2 : Var<boolean> = var %1 @\"cond\";\n+               %3 : long = constant @\"0\";\n+               %4 : Var<long> = var %3 @\"x\";\n+               %5 : int = java.cexpression\n+                   ^cond()boolean -> {\n+                       %6 : boolean = var.load %2;\n+                       yield %6;\n+                   }\n+                   ^truepart()int -> {\n+                       %7 : int = constant @\"1\";\n+                       yield %7;\n+                   }\n+                   ^falsepart()int -> {\n+                       %8 : int = constant @\"2\";\n+                       yield %8;\n+                   };\n+               %9 : long = conv %5;\n+               var.store %4 %9;\n+               return;\n+           };\n+           \"\"\")\n+    void test6(boolean cond) {\n+        long x;\n+        x = cond ? 1 : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0: ImplicitConversionTest)long -> {\n+                %1 : int = constant @\"1\";\n+                %2 : long = conv %1;\n+                return %2;\n+            };\n+            \"\"\")\n+    long test7() {\n+        return 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0: ImplicitConversionTest)void -> {\n+                %1 : java.util.function.LongSupplier = lambda ()long -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : long = conv %2;\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.LongSupplier> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        LongSupplier s = () -> { return 1; };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0: ImplicitConversionTest)void -> {\n+                %1 : java.util.function.LongSupplier = lambda ()long -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : long = conv %2;\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.LongSupplier> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9() {\n+        LongSupplier s = () -> 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : long = constant @\"1\";\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %9 : int = constant @\"0\";\n+                        %10 : long = conv %9;\n+                        yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10(int i) {\n+        long l = switch (i) {\n+            case 1 -> 1L;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : long = constant @\"0\";\n+                        yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(int i) {\n+        long l = switch (i) {\n+            case 1 -> 1;\n+            default -> 0L;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : long = conv %10;\n+                        yield %11;\n+                    };\n+                %12 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int i) {\n+        long l = switch (i) {\n+            case 1 -> 1;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : long = constant @\"1\";\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %9 : int = constant @\"0\";\n+                        %10 : long = conv %9;\n+                        java.yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13(int i) {\n+        long l = switch (i) {\n+            case 1 -> { yield 1L; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        java.yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : long = constant @\"0\";\n+                        java.yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14(int i) {\n+        long l = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield 0L; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        java.yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : long = conv %10;\n+                        java.yield %11;\n+                    };\n+                %12 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int i) {\n+        long l = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                %5 : long = constant @\"2\";\n+                %6 : long = add %4 %5;\n+                %7 : Var<long> = var %6 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16(int i) {\n+        long l = i + 2L;\n+    }\n+\n+    void m(long l) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                invoke %0 %4 @\"ImplicitConversionTest::m(long)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17(int i) {\n+        m(i);\n+    }\n+\n+    void m(int i1, int i2, long... l) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                invoke %0 %3 %4 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18(int i) {\n+        m(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test19\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : long = conv %5;\n+                invoke %0 %3 %4 %6 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                return;\n+           };\n+           \"\"\")\n+    void test19(int i) {\n+        m(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : long = conv %5;\n+                %7 : int = var.load %2;\n+                %8 : long = conv %7;\n+                invoke %0 %3 %4 %6 %8 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test20(int i) {\n+        m(i, i, i, i);\n+    }\n+\n+    static class Box {\n+        Box(long l) { }\n+        Box(int i1, int i2, long... longs) { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                %5 : ImplicitConversionTest$Box = new %4 @\"(long)ImplicitConversionTest$Box\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21(int i) {\n+        new Box(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test22\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : ImplicitConversionTest$Box = new %3 %4 @\"(int, int, long[])ImplicitConversionTest$Box\";\n+                return;\n+            };\n+            \"\"\")\n+    void test22(int i) {\n+        new Box(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test23\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+               %2 : Var<int> = var %1 @\"i\";\n+               %3 : int = var.load %2;\n+               %4 : int = var.load %2;\n+               %5 : int = var.load %2;\n+               %6 : long = conv %5;\n+               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"(int, int, long[])ImplicitConversionTest$Box\";\n+               return;\n+           };\n+           \"\"\")\n+    void test23(int i) {\n+        new Box(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test24\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : long = conv %5;\n+                %7 : int = var.load %2;\n+                %8 : long = conv %7;\n+                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"(int, int, long[])ImplicitConversionTest$Box\";\n+                return;\n+            };\n+            \"\"\")\n+    void test24(int i) {\n+        new Box(i, i, i, i);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":570,"deletions":0,"binary":false,"changes":570,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with intersection type conversions.\n+ * @build IntersectionTypeTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester IntersectionTypeTest\n+ *\/\n+\n+class IntersectionTypeTest {\n+    interface A {\n+        Object f_A = 5;\n+        void m_A();\n+    }\n+\n+    interface B {\n+        Object f_B = 5;\n+        void m_B();\n+    }\n+\n+    interface C {\n+        Object f_C = 5;\n+        void m_C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+              func @\"test1\" (%0 : IntersectionTypeTest$A)void -> {\n+                  %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n+                  %2 : IntersectionTypeTest$A = var.load %1;\n+                  invoke %2 @\"IntersectionTypeTest$A::m_A()void\";\n+                  %3 : IntersectionTypeTest$A = var.load %1;\n+                  %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                  invoke %4 @\"IntersectionTypeTest$B::m_B()void\";\n+                  %5 : IntersectionTypeTest$A = var.load %1;\n+                  %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                  invoke %6 @\"IntersectionTypeTest$C::m_C()void\";\n+                  return;\n+              };\n+            \"\"\")\n+    static <X extends A & B & C> void test1(X x) {\n+        x.m_A();\n+        x.m_B();\n+        x.m_C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : IntersectionTypeTest$A)void -> {\n+                %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n+                %2 : IntersectionTypeTest$A = var.load %1;\n+                %3 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n+                %4 : Var<java.lang.Object> = var %3 @\"oA\";\n+                %5 : IntersectionTypeTest$A = var.load %1;\n+                %6 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n+                %7 : Var<java.lang.Object> = var %6 @\"oB\";\n+                %8 : IntersectionTypeTest$A = var.load %1;\n+                %9 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n+                %10 : Var<java.lang.Object> = var %9 @\"oC\";\n+                return;\n+            };\n+            \"\"\")\n+    static <X extends A & B & C> void test2(X x) {\n+        Object oA = x.f_A;\n+        Object oB = x.f_B;\n+        Object oC = x.f_C;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : IntersectionTypeTest$A)void -> {\n+                %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n+                %2 : IntersectionTypeTest$A = var.load %1;\n+                %3 : Var<IntersectionTypeTest$A> = var %2 @\"rec$\";\n+                %4 : java.lang.Runnable = lambda ()void -> {\n+                    %5 : IntersectionTypeTest$A = var.load %3;\n+                    invoke %5 @\"IntersectionTypeTest$A::m_A()void\";\n+                    return;\n+                };\n+                %6 : Var<java.lang.Runnable> = var %4 @\"rA\";\n+                %7 : IntersectionTypeTest$A = var.load %1;\n+                %8 : IntersectionTypeTest$B = cast %7 @\"IntersectionTypeTest$B\";\n+                %9 : Var<IntersectionTypeTest$B> = var %8 @\"rec$\";\n+                %10 : java.lang.Runnable = lambda ()void -> {\n+                    %11 : IntersectionTypeTest$B = var.load %9;\n+                    invoke %11 @\"IntersectionTypeTest$B::m_B()void\";\n+                    return;\n+                };\n+                %12 : Var<java.lang.Runnable> = var %10 @\"rB\";\n+                %13 : IntersectionTypeTest$A = var.load %1;\n+                %14 : IntersectionTypeTest$C = cast %13 @\"IntersectionTypeTest$C\";\n+                %15 : Var<IntersectionTypeTest$C> = var %14 @\"rec$\";\n+                %16 : java.lang.Runnable = lambda ()void -> {\n+                    %17 : IntersectionTypeTest$C = var.load %15;\n+                    invoke %17 @\"IntersectionTypeTest$C::m_C()void\";\n+                    return;\n+                };\n+                %18 : Var<java.lang.Runnable> = var %16 @\"rC\";\n+                return;\n+            };\n+            \"\"\")\n+    static <X extends A & B & C> void test3(X x) {\n+        Runnable rA = x::m_A;\n+        Runnable rB = x::m_B;\n+        Runnable rC = x::m_C;\n+    }\n+\n+    static void g_A(A a) { }\n+    static void g_B(B a) { }\n+    static void g_C(C a) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+              func @\"test4\" (%0 : IntersectionTypeTest$A)void -> {\n+                  %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n+                  %2 : IntersectionTypeTest$A = var.load %1;\n+                  invoke %2 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                  %3 : IntersectionTypeTest$A = var.load %1;\n+                  %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                  invoke %4 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                  %5 : IntersectionTypeTest$A = var.load %1;\n+                  %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                  invoke %6 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                  return;\n+              };\n+            \"\"\")\n+    static <X extends A & B & C> void test4(X x) {\n+        g_A(x);\n+        g_B(x);\n+        g_C(x);\n+    }\n+\n+    static <X extends A & B & C> X makeIntersection(X x1, X x2) {\n+        return null;\n+    }\n+\n+    class E1 implements A, B, C {\n+        @Override\n+        public void m_A() { }\n+        @Override\n+        public void m_B() { }\n+        @Override\n+        public void m_C() { }\n+    }\n+\n+    class E2 implements A, B, C {\n+        @Override\n+        public void m_A() { }\n+        @Override\n+        public void m_B() { }\n+        @Override\n+        public void m_C() { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+              func @\"test5\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                  %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                  %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                  %4 : IntersectionTypeTest$E1 = var.load %2;\n+                  %5 : IntersectionTypeTest$E2 = var.load %3;\n+                  %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                  %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                  %8 : IntersectionTypeTest$A = var.load %7;\n+                  invoke %8 @\"IntersectionTypeTest$A::m_A()void\";\n+                  %9 : IntersectionTypeTest$A = var.load %7;\n+                  %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                  invoke %10 @\"IntersectionTypeTest$B::m_B()void\";\n+                  %11 : IntersectionTypeTest$A = var.load %7;\n+                  %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                  invoke %12 @\"IntersectionTypeTest$C::m_C()void\";\n+                  return;\n+              };\n+            \"\"\")\n+    static void test5(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        x.m_A();\n+        x.m_B();\n+        x.m_C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                %9 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n+                %10 : Var<java.lang.Object> = var %9 @\"oA\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n+                %13 : Var<java.lang.Object> = var %12 @\"oB\";\n+                %14 : IntersectionTypeTest$A = var.load %7;\n+                %15 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n+                %16 : Var<java.lang.Object> = var %15 @\"oC\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test6(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        Object oA = x.f_A;\n+        Object oB = x.f_B;\n+        Object oC = x.f_C;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                %9 : Var<IntersectionTypeTest$A> = var %8 @\"rec$\";\n+                %10 : java.lang.Runnable = lambda ()void -> {\n+                    %11 : IntersectionTypeTest$A = var.load %9;\n+                    invoke %11 @\"IntersectionTypeTest$A::m_A()void\";\n+                    return;\n+                };\n+                %12 : Var<java.lang.Runnable> = var %10 @\"rA\";\n+                %13 : IntersectionTypeTest$A = var.load %7;\n+                %14 : IntersectionTypeTest$B = cast %13 @\"IntersectionTypeTest$B\";\n+                %15 : Var<IntersectionTypeTest$B> = var %14 @\"rec$\";\n+                %16 : java.lang.Runnable = lambda ()void -> {\n+                    %17 : IntersectionTypeTest$B = var.load %15;\n+                    invoke %17 @\"IntersectionTypeTest$B::m_B()void\";\n+                    return;\n+                };\n+                %18 : Var<java.lang.Runnable> = var %16 @\"rB\";\n+                %19 : IntersectionTypeTest$A = var.load %7;\n+                %20 : IntersectionTypeTest$C = cast %19 @\"IntersectionTypeTest$C\";\n+                %21 : Var<IntersectionTypeTest$C> = var %20 @\"rec$\";\n+                %22 : java.lang.Runnable = lambda ()void -> {\n+                    %23 : IntersectionTypeTest$C = var.load %21;\n+                    invoke %23 @\"IntersectionTypeTest$C::m_C()void\";\n+                    return;\n+                };\n+                %24 : Var<java.lang.Runnable> = var %22 @\"rC\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test7(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        Runnable rA = x::m_A;\n+        Runnable rB = x::m_B;\n+        Runnable rC = x::m_C;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                invoke %8 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                %9 : IntersectionTypeTest$A = var.load %7;\n+                %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                invoke %10 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                invoke %12 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test8(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        g_A(x);\n+        g_B(x);\n+        g_C(x);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with lambda expressions.\n+ * @build LambdaTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester LambdaTest\n+ *\/\n+\n+public class LambdaTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"s\";\n+                    %4 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                    %5 : java.lang.String = var.load %3;\n+                    invoke %4 %5 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                    return;\n+                };\n+                %6 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                %7 : java.util.function.Consumer<java.lang.String> = var.load %6;\n+                %8 : java.lang.String = constant @\"Hello World\";\n+                invoke %7 %8 @\"java.util.function.Consumer::accept(java.lang.Object)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        Consumer<String> c = s -> {\n+            System.out.println(s);\n+        };\n+        c.accept(\"Hello World\");\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = constant @\"Hello World\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<java.lang.String>> = var %1 @\"c\";\n+                %4 : java.util.function.Supplier<java.lang.String> = var.load %3;\n+                %5 : java.lang.String = invoke %4 @\"java.util.function.Supplier::get()java.lang.Object\";\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        Supplier<String> c = () -> {\n+            return \"Hello World\";\n+        };\n+        String s = c.get();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = constant @\"Hello World\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        Supplier<String> c = () -> \"Hello World\";\n+    }\n+\n+    String s_f;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = field.load %0 @\"LambdaTest::s_f()java.lang.String\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        Supplier<String> c = () -> {\n+            return s_f;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : LambdaTest, %1 : int, %2 : int)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<int> = var %2 @\"j\";\n+                %5 : int = constant @\"3\";\n+                %6 : Var<int> = var %5 @\"k\";\n+                %7 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %8 : int = constant @\"4\";\n+                    %9 : Var<int> = var %8 @\"l\";\n+                    %10 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                        %11 : int = var.load %4;\n+                        %12 : int = var.load %6;\n+                        %13 : int = add %11 %12;\n+                        %14 : int = var.load %9;\n+                        %15 : int = add %13 %14;\n+                        %16 : Var<int> = var %15 @\"r\";\n+                        %17 : int = var.load %16;\n+                        %18 : java.lang.Integer = invoke %17 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        return %18;\n+                    };\n+                    %19 : Var<java.util.function.Supplier<java.lang.Integer>> = var %10 @\"sInner\";\n+                    %20 : int = var.load %3;\n+                    %21 : java.util.function.Supplier<java.lang.Integer> = var.load %19;\n+                    %22 : java.lang.Integer = invoke %21 @\"java.util.function.Supplier::get()java.lang.Object\";\n+                    %23 : int = invoke %22 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                    %24 : int = add %20 %23;\n+                    %25 : Var<int> = var %24 @\"r\";\n+                    %26 : int = var.load %25;\n+                    %27 : java.lang.Integer = invoke %26 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %27;\n+                };\n+                %28 : Var<java.util.function.Supplier<java.lang.Integer>> = var %7 @\"sOuter\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5(int i, int j) {\n+        int k = 3;\n+        Supplier<Integer> sOuter = () -> {\n+            int l = 4;\n+            Supplier<Integer> sInner = () -> {\n+                int r = j + k + l;\n+                return r;\n+            };\n+\n+            int r = i + sInner.get();\n+            return r;\n+        };\n+    }\n+\n+    int f;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %2 : int = field.load %0 @\"LambdaTest::f()int\";\n+                    %3 : java.lang.Integer = invoke %2 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.Supplier<java.lang.Integer>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        Supplier<Integer> s = () -> f;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with local variables.\n+ * @build LocalVarTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester LocalVarTest\n+ *\/\n+\n+public class LocalVarTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = constant @\"2\";\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = var.load %2;\n+                %6 : int = var.load %4;\n+                %7 : int = add %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test1() {\n+        int x = 1;\n+        int y = 2;\n+        return x + y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : LocalVarTest, %1 : int, %2 : int)int -> {\n+                %3 : Var<int> = var %1 @\"x\";\n+                %4 : Var<int> = var %2 @\"y\";\n+                %5 : int = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = add %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test2(int x, int y) {\n+        return x + y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = constant @\"0\";\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = constant @\"1\";\n+                var.store %2 %5;\n+                %6 : int = constant @\"2\";\n+                var.store %4 %6;\n+                %7 : int = var.load %2;\n+                %8 : int = var.load %4;\n+                %9 : int = add %7 %8;\n+                return %9;\n+            };\n+            \"\"\")\n+    int test3() {\n+        int x;\n+        int y;\n+        x = 1;\n+        y = 2;\n+        return x + y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                %6 : Var<int> = var %5 @\"y\";\n+                %7 : int = var.load %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test4() {\n+        int x = 1;\n+        int y = x + 1;\n+        return y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = var.load %2;\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = var.load %4;\n+                return %5;\n+            };\n+            \"\"\")\n+    int test5() {\n+        int x = 1;\n+        int y = x;\n+        return y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = constant @\"1\";\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = constant @\"1\";\n+                %6 : Var<int> = var %5 @\"z\";\n+                %7 : int = var.load %2;\n+                var.store %4 %7;\n+                var.store %6 %7;\n+                %8 : int = var.load %6;\n+                return %8;\n+            };\n+            \"\"\")\n+    int test6() {\n+        int x = 1;\n+        int y = 1;\n+        int z = 1;\n+        z = y = x;\n+        return z;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"2\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : Var<int> = var %5 @\"y\";\n+                %7 : int = var.load %6;\n+                %8 : int = constant @\"3\";\n+                %9 : int = add %7 %8;\n+                var.store %6 %9;\n+                %10 : int = var.load %2;\n+                %11 : int = constant @\"4\";\n+                %12 : int = add %10 %11;\n+                var.store %2 %12;\n+                %13 : int = add %9 %12;\n+                return %13;\n+            };\n+            \"\"\")\n+    int test7() {\n+        int x = 1;\n+        int y = x += 2;\n+        return (y += 3) + (x += 4);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : LocalVarTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : Var<int> = var %3 @\"x\";\n+                %7 : int = var.load %2;\n+                %8 : int = constant @\"1\";\n+                %9 : int = sub %7 %8;\n+                var.store %2 %9;\n+                %10 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8(int i) {\n+        int x = i++;\n+        int y = i--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : LocalVarTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : Var<int> = var %5 @\"x\";\n+                %7 : int = var.load %2;\n+                %8 : int = constant @\"1\";\n+                %9 : int = sub %7 %8;\n+                var.store %2 %9;\n+                %10 : Var<int> = var %9 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9(int i) {\n+        int x = ++i;\n+        int y = --i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalVarTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with method calls.\n+ * @build MethodCallTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester MethodCallTest\n+ *\/\n+\n+public class MethodCallTest {\n+\n+    void m() {\n+    }\n+\n+    int m_int() {\n+        return 0;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : MethodCallTest)void -> {\n+                invoke %0 @\"MethodCallTest::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : MethodCallTest)void -> {\n+                invoke %0 @\"MethodCallTest::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        this.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : MethodCallTest)int -> {\n+                %1 : int = invoke %0 @\"MethodCallTest::m_int()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test3() {\n+        return m_int();\n+    }\n+\n+\n+    static void ms() {\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : MethodCallTest)void -> {\n+                invoke @\"MethodCallTest::ms()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        ms();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4_1\" (%0 : MethodCallTest)void -> {\n+                invoke @\"MethodCallTest::ms()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4_1() {\n+        MethodCallTest.ms();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4_2\" (%0 : MethodCallTest)java.util.List<java.lang.String> -> {\n+                %1 : java.util.List<java.lang.String> = invoke @\"java.util.List::of()java.util.List\";\n+                return %1;\n+            };\n+            \"\"\")\n+    List<String> test4_2() {\n+        return List.of();\n+    }\n+\n+    String m(int i, String s, List<Number> l) {\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : MethodCallTest, %1 : java.util.List<java.lang.Number>)void -> {\n+                %2 : Var<java.util.List<java.lang.Number>> = var %1 @\"l\";\n+                %3 : int = constant @\"1\";\n+                %4 : java.lang.String = constant @\"1\";\n+                %5 : java.util.List<java.lang.Number> = var.load %2;\n+                %6 : java.lang.String = invoke %0 %3 %4 %5 @\"MethodCallTest::m(int, java.lang.String, java.util.List)java.lang.String\";\n+                %7 : Var<java.lang.String> = var %6 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5(List<Number> l) {\n+        String s = m(1, \"1\", l);\n+    }\n+\n+\n+    static class A {\n+        B b;\n+\n+        B m() {\n+            return null;\n+        }\n+    }\n+\n+    static class B {\n+        C m() {\n+            return null;\n+        }\n+    }\n+\n+    static class C {\n+        int m() {\n+            return 0;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : MethodCallTest, %1 : MethodCallTest$A)void -> {\n+                %2 : Var<MethodCallTest$A> = var %1 @\"a\";\n+                %3 : MethodCallTest$A = var.load %2;\n+                %4 : MethodCallTest$B = invoke %3 @\"MethodCallTest$A::m()MethodCallTest$B\";\n+                %5 : MethodCallTest$C = invoke %4 @\"MethodCallTest$B::m()MethodCallTest$C\";\n+                %6 : int = invoke %5 @\"MethodCallTest$C::m()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6(A a) {\n+        a.m().m().m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : MethodCallTest, %1 : MethodCallTest$A)void -> {\n+                %2 : Var<MethodCallTest$A> = var %1 @\"a\";\n+                %3 : MethodCallTest$A = var.load %2;\n+                %4 : MethodCallTest$B = field.load %3 @\"MethodCallTest$A::b()MethodCallTest$B\";\n+                %5 : MethodCallTest$C = invoke %4 @\"MethodCallTest$B::m()MethodCallTest$C\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7(A a) {\n+        a.b.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : MethodCallTest, %1 : java.lang.String)void -> {\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                %3 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %4 : java.lang.String = var.load %2;\n+                invoke %3 %4 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8(String s) {\n+        System.out.println(s);\n+    }\n+\n+    static class X {\n+        int x;\n+        void x() {}\n+\n+        static void sx() {}\n+    }\n+\n+    static class Y extends X {\n+        void y() {}\n+        static void sy() {}\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test\" (%0 : MethodCallTest$Y)void -> {\n+                    invoke %0 @\"MethodCallTest$Y::x()void\";\n+                    invoke %0 @\"MethodCallTest$Y::y()void\";\n+                    invoke @\"MethodCallTest$Y::sx()void\";\n+                    invoke @\"MethodCallTest$Y::sy()void\";\n+                    invoke @\"MethodCallTest$Y::sx()void\";\n+                    invoke @\"MethodCallTest$Y::sy()void\";\n+                    return;\n+                };\n+                \"\"\")\n+        void test() {\n+            x();\n+            y();\n+\n+            sx();\n+            sy();\n+\n+            Y.sx();\n+            Y.sy();\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : MethodCallTest$Y)void -> {\n+                %1 : Var<MethodCallTest$Y> = var %0 @\"y\";\n+                %2 : MethodCallTest$Y = var.load %1;\n+                invoke %2 @\"MethodCallTest$Y::x()void\";\n+                %3 : MethodCallTest$Y = var.load %1;\n+                invoke %3 @\"MethodCallTest$Y::y()void\";\n+                %4 : MethodCallTest$Y = var.load %1;\n+                invoke @\"MethodCallTest$Y::sx()void\";\n+                %5 : MethodCallTest$Y = var.load %1;\n+                invoke @\"MethodCallTest$Y::sy()void\";\n+                invoke @\"MethodCallTest$Y::sx()void\";\n+                invoke @\"MethodCallTest$Y::sy()void\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test9(Y y) {\n+        y.x();\n+        y.y();\n+\n+        y.sx();\n+        y.sy();\n+\n+        Y.sx();\n+        Y.sy();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : java.util.ArrayList<java.lang.String>)void -> {\n+                %1 : Var<java.util.ArrayList<java.lang.String>> = var %0 @\"al\";\n+                %2 : java.util.ArrayList<java.lang.String> = var.load %1;\n+                %3 : int = constant @\"0\";\n+                %4 : java.lang.String = invoke %2 %3 @\"java.util.ArrayList::get(int)java.lang.Object\";\n+                %5 : Var<java.lang.String> = var %4 @\"s\";\n+                %6 : java.util.ArrayList<java.lang.String> = var.load %1;\n+                %7 : Var<java.util.List<java.lang.String>> = var %6 @\"l\";\n+                %8 : java.util.List<java.lang.String> = var.load %7;\n+                %9 : int = constant @\"0\";\n+                %10 : java.lang.String = invoke %8 %9 @\"java.util.List::get(int)java.lang.Object\";\n+                var.store %5 %10;\n+                return;\n+            };\n+            \"\"\")\n+    static void test10(ArrayList<String> al) {\n+        String s = al.get(0);\n+        List<String> l = al;\n+        s = l.get(0);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodCallTest.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with method reference expressions.\n+ * @build MethodReferenceTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester MethodReferenceTest\n+ *\/\n+\n+public class MethodReferenceTest {\n+\n+    static void m_s(String s) {}\n+\n+    void m(String s) {}\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"x$0\";\n+                    %4 : java.lang.String = var.load %3;\n+                    invoke %4 @\"MethodReferenceTest::m_s(java.lang.String)void\";\n+                    return;\n+                };\n+                %5 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        Consumer<String> c = MethodReferenceTest::m_s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.BiConsumer<MethodReferenceTest, java.lang.String> = lambda (%2 : MethodReferenceTest, %3 : java.lang.String)void -> {\n+                    %4 : Var<MethodReferenceTest> = var %2 @\"rec$\";\n+                    %5 : Var<java.lang.String> = var %3 @\"x$0\";\n+                    %6 : MethodReferenceTest = var.load %4;\n+                    %7 : java.lang.String = var.load %5;\n+                    invoke %6 %7 @\"MethodReferenceTest::m(java.lang.String)void\";\n+                    return;\n+                };\n+                %8 : Var<java.util.function.BiConsumer<MethodReferenceTest, java.lang.String>> = var %1 @\"bc\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        BiConsumer<MethodReferenceTest, String> bc = MethodReferenceTest::m;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"x$0\";\n+                    %4 : java.lang.String = var.load %3;\n+                    invoke %0 %4 @\"MethodReferenceTest::m(java.lang.String)void\";\n+                    return;\n+                };\n+                %5 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        Consumer<String> c = this::m;\n+    }\n+\n+    class A<T> {\n+        T m(T t) { return t; }\n+    }\n+\n+    <T> A<T> a(T t) { return null; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.lang.String = constant @\"s\";\n+                %2 : MethodReferenceTest$A<java.lang.String> = invoke %0 %1 @\"MethodReferenceTest::a(java.lang.Object)MethodReferenceTest$A\";\n+                %3 : Var<MethodReferenceTest$A<java.lang.String>> = var %2 @\"rec$\";\n+                %4 : java.util.function.Function<java.lang.String, java.lang.String> = lambda (%5 : java.lang.String)java.lang.String -> {\n+                    %6 : Var<java.lang.String> = var %5 @\"x$0\";\n+                    %7 : MethodReferenceTest$A<java.lang.String> = var.load %3;\n+                    %8 : java.lang.String = var.load %6;\n+                    %9 : java.lang.String = invoke %7 %8 @\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\";\n+                    return %9;\n+                };\n+                %10 : Var<java.util.function.Function<java.lang.String, java.lang.String>> = var %4 @\"f\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        Function<String, String> f = a(\"s\")::m;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %2 : Var<java.io.PrintStream> = var %1 @\"rec$\";\n+                %3 : java.util.function.Consumer<java.lang.String> = lambda (%4 : java.lang.String)void -> {\n+                    %5 : Var<java.lang.String> = var %4 @\"x$0\";\n+                    %6 : java.io.PrintStream = var.load %2;\n+                    %7 : java.lang.String = var.load %5;\n+                    invoke %6 %7 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                    return;\n+                };\n+                %8 : Var<java.util.function.Consumer<java.lang.String>> = var %3 @\"c3\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        Consumer<String> c3 = System.out::println;\n+    }\n+\n+    static class X {\n+        X(int i) {}\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Function<java.lang.Integer, MethodReferenceTest$X> = lambda (%2 : java.lang.Integer)MethodReferenceTest$X -> {\n+                    %3 : Var<java.lang.Integer> = var %2 @\"x$0\";\n+                    %4 : java.lang.Integer = var.load %3;\n+                    %5 : int = invoke %4 @\"java.lang.Integer::intValue(java.lang.Integer)int\";\n+                    %6 : MethodReferenceTest$X = new %5 @\"(int)MethodReferenceTest$X\";\n+                    return %6;\n+                };\n+                %7 : Var<java.util.function.Function<java.lang.Integer, MethodReferenceTest$X>> = var %1 @\"xNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        Function<Integer, X> xNew = X::new;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Supplier<MethodReferenceTest$A<java.lang.String>> = lambda ()MethodReferenceTest$A<java.lang.String> -> {\n+                    %2 : MethodReferenceTest$A<java.lang.String> = new %0 @\"()MethodReferenceTest$A\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<MethodReferenceTest$A<java.lang.String>>> = var %1 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        Supplier<A<String>> aNew = A::new;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.IntFunction<MethodReferenceTest$A<java.lang.String>[]> = lambda (%2 : int)MethodReferenceTest$A<java.lang.String>[] -> {\n+                    %3 : Var<int> = var %2 @\"x$0\";\n+                    %4 : int = var.load %3;\n+                    %5 : MethodReferenceTest$A[] = new %4 @\"(int)MethodReferenceTest$A[]\";\n+                    return %5;\n+                };\n+                %6 : Var<java.util.function.IntFunction<MethodReferenceTest$A<java.lang.String>[]>> = var %1 @\"aNewArray\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        IntFunction<A<String>[]> aNewArray = A[]::new;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with constant values.\n+ * @build NewArrayTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester NewArrayTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Function;\n+\n+public class NewArrayTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : int[] = new %1 @\"(int)int[]\";\n+                %3 : Var<int[]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        int[] a = new int[10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : NewArrayTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"l\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"10\";\n+                %5 : int = add %3 %4;\n+                %6 : int[] = new %5 @\"(int)int[]\";\n+                %7 : Var<int[]> = var %6 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int l) {\n+        int[] a = new int[l + 10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : java.lang.String[] = new %1 @\"(int)java.lang.String[]\";\n+                %3 : Var<java.lang.String[]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        String[] a = new String[10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : java.lang.String[][] = new %1 @\"(int)java.lang.String[][]\";\n+                %3 : Var<java.lang.String[][]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        String[][] a = new String[10][];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : int = constant @\"10\";\n+                %3 : java.lang.String[][] = new %1 %2 @\"(int, int)java.lang.String[][]\";\n+                %4 : Var<java.lang.String[][]> = var %3 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        String[][] a = new String[10][10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"3\";\n+                %2 : java.lang.String[][] = new %1 @\"(int)java.lang.String[][]\";\n+                %3 : int = constant @\"2\";\n+                %4 : java.lang.String[] = new %3 @\"(int)java.lang.String[]\";\n+                %5 : java.lang.String = constant @\"one\";\n+                %6 : int = constant @\"0\";\n+                array.store %4 %6 %5;\n+                %7 : java.lang.String = constant @\"two\";\n+                %8 : int = constant @\"1\";\n+                array.store %4 %8 %7;\n+                %9 : int = constant @\"0\";\n+                array.store %2 %9 %4;\n+                %10 : int = constant @\"1\";\n+                %11 : java.lang.String[] = new %10 @\"(int)java.lang.String[]\";\n+                %12 : java.lang.String = constant @\"three\";\n+                %13 : int = constant @\"0\";\n+                array.store %11 %13 %12;\n+                %14 : int = constant @\"1\";\n+                array.store %2 %14 %11;\n+                %15 : java.lang.String[] = constant @null;\n+                %16 : int = constant @\"2\";\n+                array.store %2 %16 %15;\n+                %17 : Var<java.lang.String[][]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        String[][] a = { { \"one\", \"two\" }, { \"three\" }, null };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"3\";\n+                %2 : java.lang.String[][] = new %1 @\"(int)java.lang.String[][]\";\n+                %3 : int = constant @\"2\";\n+                %4 : java.lang.String[] = new %3 @\"(int)java.lang.String[]\";\n+                %5 : java.lang.String = constant @\"one\";\n+                %6 : int = constant @\"0\";\n+                array.store %4 %6 %5;\n+                %7 : java.lang.String = constant @\"two\";\n+                %8 : int = constant @\"1\";\n+                array.store %4 %8 %7;\n+                %9 : int = constant @\"0\";\n+                array.store %2 %9 %4;\n+                %10 : int = constant @\"1\";\n+                %11 : java.lang.String[] = new %10 @\"(int)java.lang.String[]\";\n+                %12 : java.lang.String = constant @\"three\";\n+                %13 : int = constant @\"0\";\n+                array.store %11 %13 %12;\n+                %14 : int = constant @\"1\";\n+                array.store %2 %14 %11;\n+                %15 : java.lang.String[] = constant @null;\n+                %16 : int = constant @\"2\";\n+                array.store %2 %16 %15;\n+                %17 : Var<java.lang.String[][]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        String[][] a = new String[][] { { \"one\", \"two\" }, { \"three\" }, null };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewArrayTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with new expressions.\n+ * @build NewTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester NewTest\n+ *\/\n+\n+public class NewTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test0\" (%0 : NewTest)void -> {\n+                %1 : java.lang.String = constant @\"1\";\n+                %2 : java.math.BigDecimal = new %1 @\"(java.lang.String)java.math.BigDecimal\";\n+                %3 : Var<java.math.BigDecimal> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test0() {\n+        BigDecimal a = new BigDecimal(\"1\");\n+    }\n+\n+    static class A {\n+        A() {}\n+\n+        A(int i, int j) {}\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : NewTest)void -> {\n+                %1 : NewTest$A = new @\"()NewTest$A\";\n+                %2 : Var<NewTest$A> = var %1 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        A a = new A();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : NewTest)void -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : NewTest$A = new %1 %2 @\"(int, int)NewTest$A\";\n+                %4 : Var<NewTest$A> = var %3 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        A a = new A(1, 2);\n+    }\n+\n+    class B {\n+        B() {}\n+\n+        B(int i, int j) {}\n+\n+        class C {\n+        }\n+    }\n+\n+    B f;\n+\n+    B b() { return f; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = new %0 @\"()NewTest$B\";\n+                %2 : Var<NewTest$B> = var %1 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        B b = new B();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : NewTest)void -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : NewTest$B = new %0 %1 %2 @\"(int, int)NewTest$B\";\n+                %4 : Var<NewTest$B> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        B b = new B(1, 2);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = new %0 @\"()NewTest$B\";\n+                %2 : Var<NewTest$B> = var %1 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        B b = this.new B();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = field.load %0 @\"NewTest::f()NewTest$B\";\n+                %2 : NewTest$B$C = new %1 @\"()NewTest$B$C\";\n+                %3 : Var<NewTest$B$C> = var %2 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        B.C c = f.new C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = invoke %0 @\"NewTest::b()NewTest$B\";\n+                %2 : NewTest$B$C = new %1 @\"()NewTest$B$C\";\n+                %3 : Var<NewTest$B$C> = var %2 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        B.C c = b().new C();\n+    }\n+\n+    static class AG<T> {\n+        AG(List<T> l) {}\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : NewTest, %1 : java.util.List<java.lang.String>)void -> {\n+                %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+                %3 : java.util.List<java.lang.String> = var.load %2;\n+                %4 : NewTest$AG<java.lang.String> = new %3 @\"(java.util.List)NewTest$AG\";\n+                %5 : Var<NewTest$AG<java.lang.String>> = var %4 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8(List<String> l) {\n+        AG<String> a = new AG<>(l);\n+    }\n+\n+    class BG<T> {\n+        BG(List<T> l) {}\n+\n+        class CG<U> {\n+            CG(List<U> l) {}\n+        }\n+    }\n+\n+    \/\/ @@@ This produces incorrect type descriptors for generic inner classes\n+    \/\/ the type argument for type BG is not preserved\n+\/\/    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : NewTest, %1 : java.util.List<java.lang.String>, %2 : java.util.List<java.lang.Number>)void -> {\n+                %3 : Var<java.util.List<java.lang.String>> = var %1 @\"l1\";\n+                %4 : Var<java.util.List<java.lang.Number>> = var %2 @\"l2\";\n+                %5 : java.util.List<java.lang.String> = var.load %3;\n+                %6 : NewTest$BG<java.lang.String> = new %0 %5 @\"(java.util.List)NewTest$BG\";\n+                %7 : java.util.List<java.lang.Number> = var.load %4;\n+                %8 : NewTest$BG$CG<java.lang.Number> = new %6 %7 @\"(java.util.List)NewTest$BG$CG\";\n+                %9 : Var<NewTest$BG$CG<java.lang.Number>> = var %8 @\"numberCG\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9(List<String> l1, List<Number> l2) {\n+        BG<String>.CG<Number> numberCG = new BG<String>(l1).new CG<Number>(l2);\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : NewTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : int[] = new %1 @\"(int)int[]\";\n+                %3 : Var<int[]> = var %2 @\"i\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10() {\n+        int[] i = new int[10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                %7 : int = var.load %2;\n+                %8 : int = constant @\"2\";\n+                %9 : int = add %7 %8;\n+                %10 : java.lang.String[][][] = new %3 %6 %9 @\"(int, int, int)java.lang.String[][][]\";\n+                %11 : Var<java.lang.String[][][]> = var %10 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(int i) {\n+        String[][][] s = new String[i][i + 1][i + 2];\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,516 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Supplier;\n+\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with null constants.\n+ * @enablePreview\n+ * @build NullTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester NullTest\n+ *\/\n+\n+public class NullTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        String s = null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : NullTest)void -> {\n+                %1 : java.lang.Object = constant @null;\n+                %2 : java.lang.String = cast %1 @\"java.lang.String\";\n+                %3 : Var<java.lang.String> = var %2 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        String s = (String)null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.String = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.String -> {\n+                        %5 : java.lang.String = constant @null;\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.String -> {\n+                        %6 : java.lang.String = constant @\"\";\n+                        yield %6;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    String test3(boolean cond) {\n+        return cond ? null : \"\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.String = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.String -> {\n+                        %5 : java.lang.String = constant @\"\";\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.String -> {\n+                        %6 : java.lang.String = constant @null;\n+                        yield %6;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    String test4(boolean cond) {\n+        return cond ? \"\" : null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.String = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.String -> {\n+                        %5 : java.lang.String = constant @null;\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.String -> {\n+                        %6 : java.lang.String = constant @null;\n+                        yield %6;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    String test5(boolean cond) {\n+        return cond ? null : null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.Object = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.Object -> {\n+                        %5 : java.lang.Object = constant @null;\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.Object -> {\n+                        %6 : java.lang.Object = constant @null;\n+                        yield %6;\n+                    };\n+                %7 : java.lang.String = cast %3 @\"java.lang.String\";\n+                return %7;\n+            };\n+            \"\"\")\n+    String test6(boolean cond) {\n+        return (String)(cond ? null : null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"\";\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test7(int cond) {\n+        return switch(cond) {\n+            case 1  -> \"\";\n+            default -> null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"\";\n+                        yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test8(int cond) {\n+        return switch(cond) {\n+            case 1  -> null;\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test9(int cond) {\n+        return switch(cond) {\n+            case 1  -> null;\n+            default -> null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Object = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %8 : java.lang.Object = constant @null;\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %9 : java.lang.Object = constant @null;\n+                        yield %9;\n+                    };\n+                %10 : java.lang.String = cast %4 @\"java.lang.String\";\n+                return %10;\n+            };\n+            \"\"\")\n+    String test10(int cond) {\n+        return (String)switch(cond) {\n+            case 1  -> null;\n+            default -> null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"\";\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        java.yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test11(int cond) {\n+        return switch(cond) {\n+            case 1  -> { yield \"\"; }\n+            default -> { yield null; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"\";\n+                        java.yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test12(int cond) {\n+        return switch(cond) {\n+            case 1  -> { yield null; }\n+            default -> { yield \"\"; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        java.yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test13(int cond) {\n+        return switch(cond) {\n+            case 1  -> { yield null; }\n+            default -> { yield null; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Object = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %8 : java.lang.Object = constant @null;\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %9 : java.lang.Object = constant @null;\n+                        java.yield %9;\n+                    };\n+                %10 : java.lang.String = cast %4 @\"java.lang.String\";\n+                return %10;\n+            };\n+            \"\"\")\n+    String test14(int cond) {\n+        return (String)switch(cond) {\n+            case 1  -> { yield null; }\n+            default -> { yield null; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : NullTest)java.util.function.Supplier<java.lang.String> -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = constant @null;\n+                    return %2;\n+                };\n+                return %1;\n+            };\n+            \"\"\")\n+    Supplier<String> test15() {\n+        return () -> null;\n+    }\n+\n+    static void m(String s, String... ss) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                invoke %1 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16() {\n+        m(null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String[] = constant @null;\n+                invoke %1 %2 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17() {\n+        m(null, null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String = constant @null;\n+                %3 : java.lang.String = constant @null;\n+                invoke %1 %2 %3 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18() {\n+        m(null, null, null);\n+    }\n+\n+    static class Box {\n+        Box(String s, String... ss) { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test19\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : NullTest$Box = new %1 @\"(java.lang.String, java.lang.String[])NullTest$Box\";\n+                return;\n+            };\n+            \"\"\")\n+    void test19() {\n+        new Box(null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String[] = constant @null;\n+                %3 : NullTest$Box = new %1 %2 @\"(java.lang.String, java.lang.String[])NullTest$Box\";\n+                return;\n+            };\n+            \"\"\")\n+    void test20() {\n+        new Box(null, null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String = constant @null;\n+                %3 : java.lang.String = constant @null;\n+                %4 : NullTest$Box = new %1 %2 %3 @\"(java.lang.String, java.lang.String[])NullTest$Box\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21() {\n+        new Box(null, null, null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":516,"deletions":0,"binary":false,"changes":516,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with patterns.\n+ * @enablePreview\n+ * @build PatternsTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester PatternsTest\n+ *\/\n+\n+public class PatternsTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.lang.String = constant @null;\n+                %5 : Var<java.lang.String> = var %4 @\"s\";\n+                %6 : boolean = pattern.match %3\n+                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                        %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                        yield %7;\n+                    }\n+                    ^match(%8 : java.lang.String)void -> {\n+                        var.store %5 %8;\n+                        yield;\n+                    };\n+                %9 : Var<boolean> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1(Object o) {\n+        boolean x = o instanceof String s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : PatternsTest, %1 : java.lang.Object)java.lang.String -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.if\n+                    ()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        yield %6;\n+                    }\n+                    ^then()void -> {\n+                        %9 : java.lang.String = var.load %4;\n+                        return %9;\n+                    }\n+                    ^else()void -> {\n+                        %10 : java.lang.String = constant @\"\";\n+                        return %10;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    String test2(Object o) {\n+        if (o instanceof String s) {\n+            return s;\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : PatternsTest, %1 : java.lang.Object)java.lang.String -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.if\n+                    ()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        %9 : boolean = not %6;\n+                        yield %9;\n+                    }\n+                    ^then()void -> {\n+                        %10 : java.lang.String = constant @\"\";\n+                        return %10;\n+                    }\n+                    ^else()void -> {\n+                        yield;\n+                    };\n+                %11 : java.lang.String = var.load %4;\n+                return %11;\n+            };\n+            \"\"\")\n+    String test3(Object o) {\n+        if (!(o instanceof String s)) {\n+            return \"\";\n+        }\n+        return s;\n+    }\n+\n+    interface Point {\n+    }\n+\n+    record ConcretePoint(int x, int y) implements Point {\n+    }\n+\n+    enum Color {RED, GREEN, BLUE}\n+\n+    record ColoredPoint(ConcretePoint p, Color c) implements Point {\n+    }\n+\n+    record Rectangle(Point upperLeft, Point lowerRight) {\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : PatternsTest, %1 : PatternsTest$Rectangle)void -> {\n+                %2 : Var<PatternsTest$Rectangle> = var %1 @\"r\";\n+                %3 : PatternsTest$ConcretePoint = constant @null;\n+                %4 : Var<PatternsTest$ConcretePoint> = var %3 @\"p\";\n+                %5 : PatternsTest$Color = constant @null;\n+                %6 : Var<PatternsTest$Color> = var %5 @\"c\";\n+                %7 : PatternsTest$ColoredPoint = constant @null;\n+                %8 : Var<PatternsTest$ColoredPoint> = var %7 @\"lr\";\n+                java.if\n+                    ()boolean -> {\n+                        %9 : PatternsTest$Rectangle = var.load %2;\n+                        %10 : boolean = pattern.match %9\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Record<PatternsTest$Rectangle> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<PatternsTest$ConcretePoint> = pattern.binding @\"p\";\n+                                %12 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<PatternsTest$Color> = pattern.binding @\"c\";\n+                                %13 : java.lang.reflect.code.ExtendedOps$Pattern$Record<PatternsTest$ColoredPoint> = pattern.record %11 %12 @\"(PatternsTest$ConcretePoint p, PatternsTest$Color c)PatternsTest$ColoredPoint\";\n+                                %14 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<PatternsTest$ColoredPoint> = pattern.binding @\"lr\";\n+                                %15 : java.lang.reflect.code.ExtendedOps$Pattern$Record<PatternsTest$Rectangle> = pattern.record %13 %14 @\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n+                                yield %15;\n+                            }\n+                            ^match(%16 : PatternsTest$ConcretePoint, %17 : PatternsTest$Color, %18 : PatternsTest$ColoredPoint)void -> {\n+                                var.store %4 %16;\n+                                var.store %6 %17;\n+                                var.store %8 %18;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ^then()void -> {\n+                        %19 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %20 : PatternsTest$ConcretePoint = var.load %4;\n+                        invoke %19 %20 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        %21 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %22 : PatternsTest$Color = var.load %6;\n+                        invoke %21 %22 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        %23 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %24 : PatternsTest$ColoredPoint = var.load %8;\n+                        invoke %23 %24 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        %25 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %26 : java.lang.String = constant @\"NO MATCH\";\n+                        invoke %25 %26 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4(Rectangle r) {\n+        if (r instanceof Rectangle(\n+                ColoredPoint(ConcretePoint p, Color c),\n+                ColoredPoint lr)){\n+            System.out.println(p);\n+            System.out.println(c);\n+            System.out.println(lr);\n+        }\n+        else {\n+            System.out.println(\"NO MATCH\");\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.while\n+                    ^cond()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        yield %6;\n+                    }\n+                    ^body()void -> {\n+                        %9 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %10 : java.lang.String = var.load %4;\n+                        invoke %9 %10 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test5(Object o) {\n+        while (o instanceof String s) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.do.while\n+                    ^body()void -> {\n+                        java.continue;\n+                    }\n+                    ^cond()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        %9 : boolean = not %6;\n+                        yield %9;\n+                    };\n+                %10 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %11 : java.lang.String = var.load %4;\n+                invoke %10 %11 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6(Object o) {\n+        do {\n+        } while (!(o instanceof String s));\n+        System.out.println(s);\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Number = constant @null;\n+                %4 : Var<java.lang.Number> = var %3 @\"n\";\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %5 : int = constant @\"0\";\n+                        %6 : Var<int> = var %5 @\"i\";\n+                        yield %6;\n+                    }\n+                    ^cond(%7 : Var<int>)boolean -> {\n+                        %8 : boolean = java.cand\n+                            ()boolean -> {\n+                                %9 : int = var.load %7;\n+                                %10 : int = constant @\"10\";\n+                                %11 : boolean = lt %9 %10;\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %12 : java.lang.Object = var.load %2;\n+                                %13 : boolean = pattern.match %12\n+                                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> -> {\n+                                        %14 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                        yield %14;\n+                                    }\n+                                    ^match(%15 : java.lang.Number)void -> {\n+                                        var.store %4 %15;\n+                                        yield;\n+                                    };\n+                                yield %13;\n+                            };\n+                        yield %8;\n+                    }\n+                    ^update(%16 : Var<int>)void -> {\n+                        %17 : int = var.load %16;\n+                        %18 : java.lang.Number = var.load %4;\n+                        %19 : int = invoke %18 @\"java.lang.Number::intValue()int\";\n+                        %20 : int = add %17 %19;\n+                        var.store %16 %20;\n+                        yield;\n+                    }\n+                    ^body(%21 : Var<int>)void -> {\n+                        %22 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %23 : java.lang.Number = var.load %4;\n+                        invoke %22 %23 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test7(Object o) {\n+        for (int i = 0;\n+             i < 10 && o instanceof Number n; i += n.intValue()) {\n+            System.out.println(n);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternsTest.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,301 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with primitive casts.\n+ * @build PrimitiveCastTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester PrimitiveCastTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class PrimitiveCastTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromDouble\" (%0 : PrimitiveCastTest, %1 : double)void -> {\n+                %2 : Var<double> = var %1 @\"v\";\n+                %3 : double = var.load %2;\n+                %4 : Var<double> = var %3 @\"d\";\n+                %5 : double = var.load %2;\n+                %6 : float = conv %5;\n+                %7 : Var<float> = var %6 @\"f\";\n+                %8 : double = var.load %2;\n+                %9 : long = conv %8;\n+                %10 : Var<long> = var %9 @\"l\";\n+                %11 : double = var.load %2;\n+                %12 : int = conv %11;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : double = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : double = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : double = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromDouble(double v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromFloat\" (%0 : PrimitiveCastTest, %1 : float)void -> {\n+                %2 : Var<float> = var %1 @\"v\";\n+                %3 : float = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : float = var.load %2;\n+                %7 : Var<float> = var %6 @\"f\";\n+                %8 : float = var.load %2;\n+                %9 : long = conv %8;\n+                %10 : Var<long> = var %9 @\"l\";\n+                %11 : float = var.load %2;\n+                %12 : int = conv %11;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : float = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : float = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : float = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromFloat(float v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromLong\" (%0 : PrimitiveCastTest, %1 : long)void -> {\n+                %2 : Var<long> = var %1 @\"v\";\n+                %3 : long = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : long = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : long = var.load %2;\n+                %10 : Var<long> = var %9 @\"l\";\n+                %11 : long = var.load %2;\n+                %12 : int = conv %11;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : long = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : long = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : long = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromLong(long v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromInt\" (%0 : PrimitiveCastTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"v\";\n+                %3 : int = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : int = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : int = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : int = var.load %2;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : int = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : int = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : int = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromInt(int v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromShort\" (%0 : PrimitiveCastTest, %1 : short)void -> {\n+                %2 : Var<short> = var %1 @\"v\";\n+                %3 : short = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : short = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : short = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : short = var.load %2;\n+                %13 : int = conv %12;\n+                %14 : Var<int> = var %13 @\"i\";\n+                %15 : short = var.load %2;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : short = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : short = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromShort(short v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromChar\" (%0 : PrimitiveCastTest, %1 : char)void -> {\n+                %2 : Var<char> = var %1 @\"v\";\n+                %3 : char = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : char = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : char = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : char = var.load %2;\n+                %13 : int = conv %12;\n+                %14 : Var<int> = var %13 @\"i\";\n+                %15 : char = var.load %2;\n+                %16 : short = conv %15;\n+                %17 : Var<short> = var %16 @\"s\";\n+                %18 : char = var.load %2;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : char = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromChar(char v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromByte\" (%0 : PrimitiveCastTest, %1 : byte)void -> {\n+                %2 : Var<byte> = var %1 @\"v\";\n+                %3 : byte = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : byte = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : byte = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : byte = var.load %2;\n+                %13 : int = conv %12;\n+                %14 : Var<int> = var %13 @\"i\";\n+                %15 : byte = var.load %2;\n+                %16 : short = conv %15;\n+                %17 : Var<short> = var %16 @\"s\";\n+                %18 : byte = var.load %2;\n+                %19 : char = conv %18;\n+                %20 : Var<char> = var %19 @\"c\";\n+                %21 : byte = var.load %2;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromByte(byte v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/PrimitiveCastTest.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with quotable lambdas.\n+ * @build QuotableIntersectionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester QuotableIntersectionTest\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+\n+public class QuotableIntersectionTest {\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_NO_PARAM_VOID = (Quotable & Runnable) () -> {\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda ()int -> {\n+                    %2 : int = constant @\"1\";\n+                    return %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_NO_PARAM_CONST = (Quotable & IntSupplier) () -> 1;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int -> {\n+                      %2 : Var<int> = var %1 @\"x\";\n+                      %3 : int = var.load %2;\n+                      return %3;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_ID = (Quotable & IntUnaryOperator) x -> x;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda (%1 : int, %2 : int)int -> {\n+                    %3 : Var<int> = var %1 @\"x\";\n+                    %4 : Var<int> = var %2 @\"y\";\n+                    %5 : int = var.load %3;\n+                    %6 : int = var.load %4;\n+                    %7 : int = add %5 %6;\n+                    return %7;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_PLUS = (Quotable & IntBinaryOperator) (x, y) -> x + y;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                    %1 : java.lang.AssertionError = new @\"()java.lang.AssertionError\";\n+                    throw %1;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_THROW_NO_PARAM = (Quotable & Runnable) () -> {\n+        throw new AssertionError();\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%1 : Var<int>)void -> {\n+                %2 : java.lang.reflect.code.Quotable = lambda (%4 : int)int -> {\n+                    %5 : Var<int> = var %4 @\"y\";\n+                    %6 : int = var.load %1;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_CAPTURE_PARAM = new Object() {\n+        Quotable captureContext(int x) {\n+            return (Quotable & IntUnaryOperator) y -> x + y;\n+        }\n+    }.captureContext(42);\n+\n+    static class Context {\n+        int x, y;\n+\n+        Quotable capture() {\n+            return (Quotable & IntUnaryOperator) z -> x + y + z;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableIntersectionTest$Context)void -> {\n+                %1 : java.lang.reflect.code.Quotable = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"z\";\n+                    %5 : int = field.load %0 @\"QuotableIntersectionTest$Context::x()int\";\n+                    %6 : int = field.load %0 @\"QuotableIntersectionTest$Context::y()int\";\n+                    %7 : int = add %5 %6;\n+                    %8 : int = var.load %4;\n+                    %9 : int = add %7 %8;\n+                    return %9;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_CAPTURE_FIELD = new Context().capture();\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureParam\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"x\";\n+                %2 : java.util.function.IntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"y\";\n+                    %5 : int = var.load %1;\n+                    %6 : int = var.load %4;\n+                    %7 : int = add %5 %6;\n+                    return %7;\n+                };\n+                %8 : Var<java.util.function.IntUnaryOperator> = var %2 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    static void captureParam(int x) {\n+        IntUnaryOperator op = (IntUnaryOperator & Quotable) y -> x + y;\n+    }\n+\n+    int x, y;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureField\" (%0 : QuotableIntersectionTest)void -> {\n+                %1 : java.util.function.IntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"z\";\n+                    %4 : int = field.load %0 @\"QuotableIntersectionTest::x()int\";\n+                    %5 : int = field.load %0 @\"QuotableIntersectionTest::y()int\";\n+                    %6 : int = add %4 %5;\n+                    %7 : int = var.load %3;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                %9 : Var<java.util.function.IntUnaryOperator> = var %1 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    void captureField() {\n+        IntUnaryOperator op = (IntUnaryOperator & Quotable) z -> x + y + z;\n+    }\n+\n+    static void m() {\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                      invoke @\"QuotableIntersectionTest::m()void\";\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_NO_PARAM_VOID_REF = (Quotable & Runnable) QuotableIntersectionTest::m;\n+\n+    static int g(int i) {\n+        return i;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int -> {\n+                      %2 : Var<int> = var %1 @\"x$0\";\n+                      %3 : int = var.load %2;\n+                      %4 : int = invoke %3 @\"QuotableIntersectionTest::g(int)int\";\n+                      return %4;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_INT_PARAM_INT_RET_REF = (Quotable & IntUnaryOperator) QuotableIntersectionTest::g;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int[] -> {\n+                    %2 : Var<int> = var %1 @\"x$0\";\n+                    %3 : int = var.load %2;\n+                    %4 : int[] = new %3 @\"(int)int[]\";\n+                    return %4;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_INT_PARAM_ARR_RET_REF = (Quotable & IntFunction<int[]>) int[]::new;\n+\n+    static class ContextRef {\n+        int g(int i) {\n+            return i;\n+        }\n+\n+        Quotable capture() {\n+            return (Quotable & IntUnaryOperator) this::g;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableIntersectionTest$ContextRef)void -> {\n+                %1 : java.lang.reflect.code.Quotable = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"x$0\";\n+                    %5 : int = var.load %4;\n+                    %6 : int = invoke %0 %5 @\"QuotableIntersectionTest$ContextRef::g(int)int\";\n+                    return %6;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with quotable lambdas.\n+ * @build QuotableSubtypeTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester QuotableSubtypeTest\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+\n+public class QuotableSubtypeTest {\n+\n+    interface QuotableRunnable extends Runnable, Quotable { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableRunnable = lambda ()void -> {\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableRunnable QUOTED_NO_PARAM_VOID = () -> { };\n+\n+    interface QuotableIntSupplier extends IntSupplier, Quotable { }\n+\n+    @IR(\"\"\"\n+           func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntSupplier = lambda ()int -> {\n+                    %2 : int = constant @\"1\";\n+                    return %2;\n+                };\n+                return;\n+           };\n+            \"\"\")\n+    static final QuotableIntSupplier QUOTED_NO_PARAM_CONST = () -> 1;\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"x\";\n+                    %4 : int = var.load %3;\n+                    return %4;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_ID = x -> x;\n+\n+    interface QuotableIntBinaryOperator extends IntBinaryOperator, Quotable { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntBinaryOperator = lambda (%2 : int, %3 : int)int -> {\n+                    %4 : Var<int> = var %2 @\"x\";\n+                    %5 : Var<int> = var %3 @\"y\";\n+                    %6 : int = var.load %4;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntBinaryOperator QUOTED_PLUS = (x, y) -> x + y;\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableRunnable = lambda ()void -> {\n+                    %2 : java.lang.AssertionError = new @\"()java.lang.AssertionError\";\n+                    throw %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableRunnable QUOTED_THROW_NO_PARAM = () -> { throw new AssertionError(); };\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%1 : Var<int>)void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%4 : int)int -> {\n+                    %5 : Var<int> = var %4 @\"y\";\n+                    %6 : int = var.load %1;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_CAPTURE_PARAM = new Object() {\n+        QuotableIntUnaryOperator captureContext(int x) {\n+            return y -> x + y;\n+        }\n+    }.captureContext(42);\n+\n+    static class Context {\n+        int x, y;\n+\n+        QuotableIntUnaryOperator capture() {\n+            return z -> x + y + z;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableSubtypeTest$Context)void -> {\n+                %1 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"z\";\n+                    %5 : int = field.load %0 @\"QuotableSubtypeTest$Context::x()int\";\n+                    %6 : int = field.load %0 @\"QuotableSubtypeTest$Context::y()int\";\n+                    %7 : int = add %5 %6;\n+                    %8 : int = var.load %4;\n+                    %9 : int = add %7 %8;\n+                    return %9;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_CAPTURE_FIELD = new Context().capture();\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureParam\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"x\";\n+                %2 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"y\";\n+                    %5 : int = var.load %1;\n+                    %6 : int = var.load %4;\n+                    %7 : int = add %5 %6;\n+                    return %7;\n+                };\n+                %8 : Var<QuotableSubtypeTest$QuotableIntUnaryOperator> = var %2 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    static void captureParam(int x) {\n+        QuotableIntUnaryOperator op = y -> x + y;\n+    }\n+\n+    int x, y;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureField\" (%0 : QuotableSubtypeTest)void -> {\n+                %1 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"z\";\n+                    %4 : int = field.load %0 @\"QuotableSubtypeTest::x()int\";\n+                    %5 : int = field.load %0 @\"QuotableSubtypeTest::y()int\";\n+                    %6 : int = add %4 %5;\n+                    %7 : int = var.load %3;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                %9 : Var<QuotableSubtypeTest$QuotableIntUnaryOperator> = var %1 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    void captureField() {\n+        QuotableIntUnaryOperator op = z -> x + y + z;\n+    }\n+\n+    static void m() { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableRunnable = lambda ()void -> {\n+                    invoke @\"QuotableSubtypeTest::m()void\";\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableRunnable QUOTED_NO_PARAM_VOID_REF = QuotableSubtypeTest::m;\n+\n+    static int g(int i) { return i; }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"x$0\";\n+                    %4 : int = var.load %3;\n+                    %5 : int = invoke %4 @\"QuotableSubtypeTest::g(int)int\";\n+                    return %5;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_INT_PARAM_INT_RET_REF = QuotableSubtypeTest::g;\n+\n+    interface QuotableIntFunction<A> extends Quotable, IntFunction<A> { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntFunction<int[]> = lambda (%2 : int)int[] -> {\n+                    %3 : Var<int> = var %2 @\"x$0\";\n+                    %4 : int = var.load %3;\n+                    %5 : int[] = new %4 @\"(int)int[]\";\n+                    return %5;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntFunction<int[]> QUOTED_INT_PARAM_ARR_RET_REF = int[]::new;\n+\n+    static class ContextRef {\n+        int g(int i) { return i; }\n+\n+        QuotableIntUnaryOperator capture() {\n+            return this::g;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableSubtypeTest$ContextRef)void -> {\n+                %1 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"x$0\";\n+                    %5 : int = var.load %4;\n+                    %6 : int = invoke %0 %5 @\"QuotableSubtypeTest$ContextRef::g(int)int\";\n+                    return %6;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Quotable;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @summary test that invoking Quotable#quoted returns the same instance\n+ * @run testng QuotedSameInstanceTest\n+ *\/\n+\n+public class QuotedSameInstanceTest {\n+\n+    private static final Quotable q1 = (Quotable & Runnable) () -> {\n+    };\n+\n+    @Test\n+    void testWithOneThread() {\n+        Assert.assertSame(q1.quoted(), q1.quoted());\n+    }\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n+    private static final QuotableIntUnaryOperator q2 = x -> x;\n+\n+    @Test\n+    void testWithMultiThreads() {\n+        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> q2.quoted()).toArray();\n+        for (int i = 1; i < quotedObjects.length; i++) {\n+            Assert.assertSame(quotedObjects[i], quotedObjects[i - 1]);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with quoted lambdas.\n+ * @build QuotedTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester QuotedTest\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+import java.lang.runtime.CodeReflection;\n+\n+public class QuotedTest {\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                 %0 : java.lang.reflect.code.CoreOps$Closure<void> = closure ()void -> {\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_NO_PARAM_VOID = () -> {\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int> = closure ()int -> {\n+                    %2 : int = constant @\"1\";\n+                    return %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_NO_PARAM_CONST = () -> 1;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"x\";\n+                    %4 : int = var.load %3;\n+                    return %4;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_ID = (int x) -> x;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int, int, int> = closure (%2 : int, %3 : int)int -> {\n+                    %4 : Var<int> = var %2 @\"x\";\n+                    %5 : Var<int> = var %3 @\"y\";\n+                    %6 : int = var.load %4;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_PLUS = (int x, int y) -> x + y;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<java.lang.Object> = closure ()java.lang.Object -> {\n+                    %2 : java.lang.AssertionError = new @\"()java.lang.AssertionError\";\n+                    throw %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_THROW_NO_PARAM = () -> {\n+        throw new AssertionError();\n+    };\n+\n+    \/\/ can we write out the root op then extract the closure ?\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%1: Var<int>)void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%4 : int)int -> {\n+                    %5 : Var<int> = var %4 @\"y\";\n+                    %6 : int = var.load %1;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_CAPTURE_PARAM = new Object() {\n+        Quoted captureContext(int x) {\n+            return (int y) -> x + y;\n+        }\n+    }.captureContext(42);\n+\n+    static class Context {\n+        int x, y;\n+\n+        Quoted capture() {\n+            return (int z) -> x + y + z;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotedTest$Context)void -> {\n+                %1 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"z\";\n+                    %5 : int = field.load %0 @\"QuotedTest$Context::x()int\";\n+                    %6 : int = field.load %0 @\"QuotedTest$Context::y()int\";\n+                    %7 : int = add %5 %6;\n+                    %8 : int = var.load %4;\n+                    %9 : int = add %7 %8;\n+                    return %9;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_CAPTURE_FIELD = new Context().capture();\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureParam\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"x\";\n+                %2 : java.lang.reflect.code.Quoted = quoted ()void -> {\n+                    %3 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%4 : int)int -> {\n+                        %5 : Var<int> = var %4 @\"y\";\n+                        %6 : int = var.load %1;\n+                        %7 : int = var.load %5;\n+                        %8 : int = add %6 %7;\n+                        return %8;\n+                    };\n+                    yield %3;\n+                };\n+                %9 : Var<java.lang.reflect.code.Quoted> = var %2 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    static void captureParam(int x) {\n+        Quoted op = (int y) -> x + y;\n+    }\n+\n+    int x, y;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureField\" (%0 : QuotedTest)void -> {\n+                %1 : java.lang.reflect.code.Quoted = quoted ()void -> {\n+                    %2 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%3 : int)int -> {\n+                        %4 : Var<int> = var %3 @\"z\";\n+                        %5 : int = field.load %0 @\"QuotedTest::x()int\";\n+                        %6 : int = field.load %0 @\"QuotedTest::y()int\";\n+                        %7 : int = add %5 %6;\n+                        %8 : int = var.load %4;\n+                        %9 : int = add %7 %8;\n+                        return %9;\n+                    };\n+                    yield %2;\n+                };\n+                %10 : Var<java.lang.reflect.code.Quoted> = var %1 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    void captureField() {\n+        Quoted op = (int z) -> x + y + z;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedTest.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,504 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with switch expressions.\n+ * @enablePreview\n+ * @build SwitchExpressionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SwitchExpressionTest\n+ *\/\n+\n+public class SwitchExpressionTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelRule\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %7 : java.lang.String = constant @\"FOO\";\n+                        yield %7;\n+                    }\n+                    ^constantCaseLabel(%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %11 : java.lang.String = constant @\"FOO\";\n+                        yield %11;\n+                    }\n+                    ^constantCaseLabel(%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        yield %15;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelRule(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"FOO\";\n+            case \"BAR\" -> \"FOO\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelsRule\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : boolean = java.cand\n+                            ()boolean -> {\n+                                %6 : java.lang.String = constant @\"FOO\";\n+                                %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : java.lang.String = constant @\"BAR\";\n+                                %9 : boolean = invoke %4 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : java.lang.String = constant @\"BAZ\";\n+                                %11 : boolean = invoke %4 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %11;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %12 : java.lang.String = constant @\"FOO\";\n+                        yield %12;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %13 : java.lang.String = constant @\"\";\n+                        java.yield %13;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelsRule(String r) {\n+        return switch (r) {\n+            case \"FOO\", \"BAR\", \"BAZ\" -> \"FOO\";\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelStatement\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %7 : java.lang.String = constant @\"FOO\";\n+                        java.yield %7;\n+                    }\n+                    ^constantCaseLabel(%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %11 : java.lang.String = constant @\"FOO\";\n+                        java.yield %11;\n+                    }\n+                    ^constantCaseLabel(%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        java.yield %15;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        java.yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelStatement(String r) {\n+        return switch (r) {\n+            case \"FOO\" : yield \"FOO\";\n+            case \"BAR\" : yield \"FOO\";\n+            case \"BAZ\" : yield \"FOO\";\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelsStatement\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : boolean = java.cand\n+                            ()boolean -> {\n+                                %6 : java.lang.String = constant @\"FOO\";\n+                                %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : java.lang.String = constant @\"BAR\";\n+                                %9 : boolean = invoke %4 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : java.lang.String = constant @\"BAZ\";\n+                                %11 : boolean = invoke %4 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %11;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %12 : java.lang.String = constant @\"FOO\";\n+                        java.yield %12;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        java.block ()void -> {\n+                            %13 : java.lang.String = constant @\"\";\n+                            java.yield %13;\n+                        };\n+                        unreachable;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelsStatement(String r) {\n+        return switch (r) {\n+            case \"FOO\", \"BAR\", \"BAZ\" : yield \"FOO\";\n+            default : { yield \"\"; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelStatements\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        java.block ()void -> {\n+                            %7 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                            %8 : java.lang.String = constant @\"FOO\";\n+                            invoke %7 %8 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                            yield;\n+                        };\n+                        java.block ()void -> {\n+                            %9 : java.lang.String = constant @\"FOO\";\n+                            java.yield %9;\n+                        };\n+                        unreachable;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %10 : java.lang.String = constant @\"\";\n+                        java.yield %10;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelStatements(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+                System.out.println(\"FOO\");\n+            }\n+            {\n+                yield \"FOO\";\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelFallthrough\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        java.block ()void -> {\n+                            %7 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                            %8 : java.lang.String = constant @\"FOO\";\n+                            invoke %7 %8 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                            yield;\n+                        };\n+                        java.switch.fallthrough;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %9 : java.lang.String = constant @\"\";\n+                        java.yield %9;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelFallthrough(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+                System.out.println(\"FOO\");\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    record A(Number n) {\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"patternCaseLabel\" (%0 : java.lang.Object)java.lang.Object -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"r\";\n+                %2 : java.lang.Object = var.load %1;\n+                %3 : java.lang.Number = constant @null;\n+                %4 : Var<java.lang.Number> = var %3 @\"n\";\n+                %5 : java.lang.String = constant @null;\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                %7 : java.lang.Object = java.switch.expression %2\n+                    ^patternCaseLabel(%8 : java.lang.Object)boolean -> {\n+                        %9 : boolean = pattern.match %8\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> -> {\n+                                %10 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                %11 : java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> = pattern.record %10 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                                yield %11;\n+                            }\n+                            ^match(%12 : java.lang.Number)void -> {\n+                                var.store %4 %12;\n+                                yield;\n+                            };\n+                        yield %9;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %13 : java.lang.Number = var.load %4;\n+                        java.yield %13;\n+                    }\n+                    ^patternCaseLabel(%14 : java.lang.Object)boolean -> {\n+                        %15 : boolean = pattern.match %14\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %16 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %16;\n+                            }\n+                            ^match(%17 : java.lang.String)void -> {\n+                                var.store %6 %17;\n+                                yield;\n+                            };\n+                        yield %15;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %18 : java.lang.String = var.load %6;\n+                        java.yield %18;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %19 : java.lang.String = constant @\"\";\n+                        java.yield %19;\n+                    };\n+                return %7;\n+            };\n+            \"\"\")\n+    public static Object patternCaseLabel(Object r) {\n+        return switch (r) {\n+            case A(Number n) -> {\n+                yield n;\n+            }\n+            case String s -> {\n+                yield s;\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"patternCaseLabelGuard\" (%0 : java.lang.Object)java.lang.Object -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"r\";\n+                %2 : java.lang.Object = var.load %1;\n+                %3 : java.lang.Number = constant @null;\n+                %4 : Var<java.lang.Number> = var %3 @\"n\";\n+                %5 : java.lang.String = constant @null;\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                %7 : java.lang.String = constant @null;\n+                %8 : Var<java.lang.String> = var %7 @\"s\";\n+                %9 : java.lang.Object = java.switch.expression %2\n+                    ^patternCaseLabel(%10 : java.lang.Object)boolean -> {\n+                        %11 : boolean = pattern.match %10\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> -> {\n+                                %12 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                %13 : java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> = pattern.record %12 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                                yield %13;\n+                            }\n+                            ^match(%14 : java.lang.Number)void -> {\n+                                var.store %4 %14;\n+                                yield;\n+                            };\n+                        yield %11;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %15 : java.lang.Number = var.load %4;\n+                        java.yield %15;\n+                    }\n+                    ^patternCaseLabel(%16 : java.lang.Object)boolean -> {\n+                        %17 : boolean = java.cand\n+                            ()boolean -> {\n+                                %18 : boolean = pattern.match %16\n+                                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                        %19 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                        yield %19;\n+                                    }\n+                                    ^match(%20 : java.lang.String)void -> {\n+                                        var.store %6 %20;\n+                                        yield;\n+                                    };\n+                                yield %18;\n+                            }\n+                            ()boolean -> {\n+                                %21 : java.lang.String = var.load %6;\n+                                %22 : int = invoke %21 @\"java.lang.String::length()int\";\n+                                %23 : int = constant @\"5\";\n+                                %24 : boolean = lt %22 %23;\n+                                yield %24;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %25 : java.lang.String = var.load %6;\n+                        java.yield %25;\n+                    }\n+                    ^patternCaseLabel(%26 : java.lang.Object)boolean -> {\n+                        %27 : boolean = java.cand\n+                            ()boolean -> {\n+                                %28 : boolean = pattern.match %26\n+                                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                        %29 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                        yield %29;\n+                                    }\n+                                    ^match(%30 : java.lang.String)void -> {\n+                                        var.store %8 %30;\n+                                        yield;\n+                                    };\n+                                yield %28;\n+                            }\n+                            ()boolean -> {\n+                                %31 : java.lang.String = var.load %8;\n+                                %32 : int = invoke %31 @\"java.lang.String::length()int\";\n+                                %33 : int = constant @\"10\";\n+                                %34 : boolean = lt %32 %33;\n+                                yield %34;\n+                            };\n+                        yield %27;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %35 : java.lang.String = var.load %8;\n+                        java.yield %35;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %36 : java.lang.String = constant @\"\";\n+                        java.yield %36;\n+                    };\n+                return %9;\n+            };\n+            \"\"\")\n+    public static Object patternCaseLabelGuard(Object r) {\n+        return switch (r) {\n+            case A(Number n) -> {\n+                yield n;\n+            }\n+            case String s when s.length() < 5 -> {\n+                yield s;\n+            }\n+            case String s when s.length() < 10 -> {\n+                yield s;\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest.java","additions":504,"deletions":0,"binary":false,"changes":504,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ * @summary Smoke test for accessing IR from annotation processors\n+ * @run main TestIRFromAnnotation\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.*;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class TestIRFromAnnotation {\n+\n+    public static void main(String... args) throws Exception {\n+        String testSrc = System.getProperty(\"test.src\");\n+        File baseDir = Path.of(testSrc).toFile();\n+        new TestIRFromAnnotation().run(baseDir);\n+    }\n+\n+    void run(File baseDir) throws Exception {\n+        for (File file : getAllFiles(List.of(baseDir))) {\n+            if (!file.exists() || !file.getName().endsWith(\".java\")) {\n+                continue;\n+            }\n+            analyze(file);\n+        }\n+    }\n+\n+    void analyze(File source) {\n+        try {\n+            JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+            JavaFileManager fileManager = compiler.getStandardFileManager(null, null, Charset.defaultCharset());\n+            JavacTask task = (JavacTask)compiler.getTask(null, fileManager, null,\n+                    List.of(\"-proc:only\",\n+                            \"--enable-preview\",\n+                            \"--source\", Integer.toString(SourceVersion.latest().runtimeVersion().feature())),\n+                    null, List.of(new SourceFile(source)));\n+            task.setProcessors(List.of(new Processor()));\n+            task.analyze();\n+        } catch (Throwable ex) {\n+            throw new AssertionError(\"Unexpected exception when analyzing: \" + source, ex);\n+        }\n+    }\n+\n+    File[] getAllFiles(List<File> roots) throws IOException {\n+        long now = System.currentTimeMillis();\n+        ArrayList<File> buf = new ArrayList<>();\n+        for (File file : roots) {\n+            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    buf.add(file.toFile());\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        long delta = System.currentTimeMillis() - now;\n+        System.err.println(\"All files = \" + buf.size() + \" \" + delta);\n+        return buf.toArray(new File[buf.size()]);\n+    }\n+\n+    static class SourceFile extends SimpleJavaFileObject {\n+\n+        private final File file;\n+        protected SourceFile(File file) {\n+            super(file.toURI(), Kind.SOURCE);\n+            this.file = file;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+            return Files.readString(file.toPath());\n+        }\n+    }\n+\n+    public static class Processor extends JavacTestingAbstractProcessor {\n+\n+        public boolean process(Set<? extends TypeElement> annotations,\n+                               RoundEnvironment roundEnvironment) {\n+            class Scan extends ElementScanner<Void,Void> {\n+                @Override\n+                public Void visitExecutable(ExecutableElement e, Void p) {\n+                    IR ir = e.getAnnotation(IR.class);\n+                    if (ir == null) {\n+                        return null; \/\/ skip\n+                    }\n+                    Optional<Object> body = elements.getBody(e);\n+                    if (!body.isPresent()) {\n+                        throw new AssertionError(String.format(\"No body found in method %s annotated with @IR\",\n+                                toMethodString(e)));\n+                    }\n+                    String actualOp = ((FuncOp)body.get()).toText();\n+                    String expectedOp = OpParser.fromString(ExtendedOps.FACTORY, ir.value()).get(0).toText();\n+                    if (!actualOp.equals(expectedOp)) {\n+                        throw new AssertionError(String.format(\"Bad IR found in %s:\\n%s\\nExpected:\\n%s\",\n+                                toMethodString(e), actualOp, expectedOp));\n+                    }\n+                    return null;\n+                }\n+            }\n+            Scan scan = new Scan();\n+            for (Element e : roundEnvironment.getRootElements()) {\n+                scan.scan(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    static String toMethodString(ExecutableElement e) {\n+        return e.getEnclosingElement() + \".\" + e;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with throw statements.\n+ * @build ThrowTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ThrowTest\n+ *\/\n+\n+public class ThrowTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ThrowTest)void -> {\n+                %1 : java.lang.RuntimeException = new @\"()java.lang.RuntimeException\";\n+                throw %1;\n+            };\n+            \"\"\")\n+    void test1() {\n+        throw new RuntimeException();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ThrowTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with try statements.\n+ * @build TryTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester TryTest\n+ *\/\n+\n+public class TryTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^catch(%4 : java.lang.Exception)void -> {\n+                        %5 : Var<java.lang.Exception> = var %4 @\"e\";\n+                        %6 : int = constant @\"2\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^finally()void -> {\n+                        %7 : int = constant @\"3\";\n+                        var.store %2 %7;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } catch (Exception e) {\n+            i = 2;\n+        } finally {\n+            i = 3;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^finally()void -> {\n+                        %4 : int = constant @\"3\";\n+                        var.store %2 %4;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } finally {\n+            i = 3;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^catch(%4 : java.lang.Exception)void -> {\n+                        %5 : Var<java.lang.Exception> = var %4 @\"e\";\n+                        %6 : java.lang.Exception = var.load %5;\n+                        invoke %6 @\"java.lang.Exception::printStackTrace()void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    static class A implements AutoCloseable {\n+        final B b;\n+\n+        public A() {\n+            this.b = null;\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+\n+        }\n+    }\n+\n+    static class B implements AutoCloseable {\n+        C c;\n+\n+        @Override\n+        public void close() throws Exception {\n+\n+        }\n+    }\n+\n+    static class C implements AutoCloseable {\n+        @Override\n+        public void close() throws Exception {\n+\n+        }\n+    }\n+\n+    A a() {\n+        return null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : TryTest)void -> {\n+                java.try\n+                    ^resources()java.lang.reflect.code.CoreOps$Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> -> {\n+                        %1 : TryTest$A = invoke %0 @\"TryTest::a()TryTest$A\";\n+                        %2 : Var<TryTest$A> = var %1 @\"a\";\n+                        %3 : TryTest$A = var.load %2;\n+                        %4 : TryTest$B = field.load %3 @\"TryTest$A::b()TryTest$B\";\n+                        %5 : TryTest$A = var.load %2;\n+                        %6 : TryTest$B = field.load %5 @\"TryTest$A::b()TryTest$B\";\n+                        %7 : TryTest$C = field.load %6 @\"TryTest$B::c()TryTest$C\";\n+                        %8 : Var<TryTest$C> = var %7 @\"c\";\n+                        %9 : java.lang.reflect.code.CoreOps$Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> = tuple %2 %4 %8;\n+                        yield %9;\n+                    }\n+                    (%10 : Var<TryTest$A>, %11 : Var<TryTest$C>)void -> {\n+                        %12 : TryTest$A = var.load %10;\n+                        %13 : Var<TryTest$A> = var %12 @\"_a\";\n+                        %14 : TryTest$C = var.load %11;\n+                        %15 : Var<TryTest$C> = var %14 @\"_c\";\n+                        yield;\n+                    }\n+                    ^catch(%16 : java.lang.Throwable)void -> {\n+                        %17 : Var<java.lang.Throwable> = var %16 @\"t\";\n+                        %18 : java.lang.Throwable = var.load %17;\n+                        invoke %18 @\"java.lang.Throwable::printStackTrace()void\";\n+                        yield;\n+                    }\n+                    ^finally()void -> {\n+                        %19 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %20 : java.lang.String = constant @\"F\";\n+                        invoke %19 %20 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4() throws Exception {\n+        try (A a = a(); a.b; C c = a.b.c) {\n+            A _a = a;\n+            C _c = c;\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        } finally {\n+            System.out.println(\"F\");\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^catch(%4 : java.lang.NullPointerException)void -> {\n+                        %5 : Var<java.lang.NullPointerException> = var %4 @\"e\";\n+                        %6 : int = constant @\"2\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^catch(%7 : java.lang.OutOfMemoryError)void -> {\n+                        %8 : Var<java.lang.OutOfMemoryError> = var %7 @\"e\";\n+                        %9 : int = constant @\"3\";\n+                        var.store %2 %9;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } catch (NullPointerException e) {\n+            i = 2;\n+        } catch (OutOfMemoryError e) {\n+            i = 3;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        return;\n+                    }\n+                    ^catch(%3 : java.lang.Exception)void -> {\n+                        %4 : Var<java.lang.Exception> = var %3 @\"e\";\n+                        %5 : java.lang.Exception = var.load %4;\n+                        throw %5;\n+                    }\n+                    ^finally()void -> {\n+                        return;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        int i = 0;\n+        try {\n+            return;\n+        } catch (Exception e) {\n+            throw e;\n+        } finally {\n+            return;\n+        }\n+     }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/TryTest.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with while loops.\n+ * @build WhileLoopTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester WhileLoopTest\n+ *\/\n+\n+public class WhileLoopTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : WhileLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.while\n+                    ^cond()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"10\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^body()void -> {\n+                        %6 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %7 : int = var.load %2;\n+                        invoke %6 %7 @\"java.io.PrintStream::println(int)void\";\n+                        %8 : int = var.load %2;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %2 %10;\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        int i = 0;\n+        while (i < 10) {\n+            System.out.println(i);\n+            i = i + 1;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : WhileLoopTest)int -> {\n+              %1 : int = constant @\"0\";\n+              %2 : Var<int> = var %1 @\"i\";\n+              java.while\n+                  ^cond()boolean -> {\n+                      %3 : int = var.load %2;\n+                      %4 : int = constant @\"10\";\n+                      %5 : boolean = lt %3 %4;\n+                      yield %5;\n+                  }\n+                  ^body()void -> {\n+                      %6 : int = var.load %2;\n+                      return %6;\n+                  };\n+              %7 : int = constant @\"-1\";\n+              return %7;\n+            };\n+            \"\"\")\n+    int test2() {\n+        int i = 0;\n+        while (i < 10) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : WhileLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.do.while\n+                    ^body()void -> {\n+                        %3 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %4 : int = var.load %2;\n+                        invoke %3 %4 @\"java.io.PrintStream::println(int)void\";\n+                        %5 : int = var.load %2;\n+                        %6 : int = constant @\"1\";\n+                        %7 : int = add %5 %6;\n+                        var.store %2 %7;\n+                        java.continue;\n+                    }\n+                    ^cond()boolean -> {\n+                        %8 : int = var.load %2;\n+                        %9 : int = constant @\"10\";\n+                        %10 : boolean = lt %8 %9;\n+                        yield %10;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        int i = 0;\n+        do {\n+            System.out.println(i);\n+            i = i + 1;\n+        } while (i < 10);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/WhileLoopTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestAssignment.out -XDrawDiagnostics TestAssignment.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+class TestAssignment {\n+    void test(boolean cond) {\n+        Quoted f_NoRet = () -> {};\n+        Quoted fiS_NoRet = (int i) -> \"\"; \/\/ ok (int->String)\n+        Quoted fiS_Ret = (int i) -> { return \"\"; }; \/\/ ok (int->String)\n+        Quoted fiV_NoRet = (int i) -> { }; \/\/ ok (int->V)\n+        Quoted fiV_Ret = (int i) -> { return; }; \/\/ ok (int->V)\n+        Quoted fiV_RetRet = (int i) -> { if (cond) return; else return; }; \/\/ ok (int->V)\n+        Quoted fiS_RetRet = (int i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ ok (int->String)\n+    }\n+\n+    void testImplicit(boolean cond) {\n+        Quoted fiS_NoRet = (i) -> \"\"; \/\/ error - no parameter types\n+        Quoted fiS_Ret = (i) -> { return \"\"; }; \/\/ error - no parameter types\n+        Quoted fiV_NoRet = (i) -> { }; \/\/ error - no parameter types\n+        Quoted fiV_Ret = (i) -> { return; }; \/\/ error - no parameter types\n+        Quoted fiV_RetRet = (i) -> { if (cond) return; else return; }; \/\/ error - no parameter types\n+        Quoted fiS_RetRet = (i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ error - no parameter types\n+    }\n+\n+    void testImplicitVar(boolean cond) {\n+        Quoted fiS_NoRet = (var i) -> \"\"; \/\/ error - no parameter types\n+        Quoted fiS_Ret = (var i) -> { return \"\"; }; \/\/ error - no parameter types\n+        Quoted fiV_NoRet = (var i) -> { }; \/\/ error - no parameter types\n+        Quoted fiV_Ret = (var i) -> { return; }; \/\/ error - no parameter types\n+        Quoted fiV_RetRet = (var i) -> { if (cond) return; else return; }; \/\/ error - no parameter types\n+        Quoted fiS_RetRet = (var i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ error - no parameter types\n+    }\n+\n+    void testBadInferredReturn(boolean cond) {\n+        Quoted fi_RetVRetS = (int i) -> { if (cond) return; else return \"\"; }; \/\/ error - only one branch returns\n+        Quoted fi_RetS = (int i) -> { if (cond) { return \"2\"; } }; \/\/ error - one return, but body completes normally\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+TestAssignment.java:43:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:44:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:45:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:46:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:47:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:48:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:52:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:53:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:54:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:55:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:56:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:57:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:61:41: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestAssignment.java:62:37: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.out","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for captured values in quotable lambdas.\n+ * @run testng TestCaptureQuotable\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.reflect.code.op.CoreOps.Var;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestCaptureQuotable {\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntParam(int x) {\n+        Quotable quotable = (Quotable & IntUnaryOperator)y -> x + y;\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(((Var)quoted.capturedValues().values().iterator().next()).value(), x);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntField(int x) {\n+        class Context {\n+            final int x;\n+\n+            Context(int x) {\n+                this.x = x;\n+            }\n+\n+            Quotable quotable() {\n+                return (Quotable & IntUnaryOperator) y -> x + y;\n+            }\n+        }\n+        Context context = new Context(x);\n+        Quotable quotable = context.quotable();\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(quoted.capturedValues().values().iterator().next(), context);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @DataProvider(name = \"ints\")\n+    public Object[][] ints() {\n+        return IntStream.range(0, 50)\n+                .mapToObj(i -> new Object[] { i })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureReferenceReceiver(int i) {\n+        int prevCount = Box.count;\n+        Quotable quotable = (Quotable & IntUnaryOperator)new Box(i)::add;\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(Box.count, prevCount + 1); \/\/ no duplicate receiver computation!\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(((Box)((Var)quoted.capturedValues().values().iterator().next()).value()).i, i);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, i + 1);\n+    }\n+\n+    record Box(int i) {\n+\n+        static int count = 0;\n+\n+        Box {\n+           count++; \/\/ keep track of side-effects\n+        }\n+\n+        int add(int i) {\n+            return i + this.i;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for captured values in quoted lambdas.\n+ * @run testng TestCaptureQuoted\n+ *\/\n+\n+import java.lang.reflect.code.op.CoreOps.Var;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.stream.IntStream;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestCaptureQuoted {\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntParam(int x) {\n+        Quoted quoted = (int y) -> x + y;\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(((Var)quoted.capturedValues().values().iterator().next()).value(), x);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntField(int x) {\n+        class Context {\n+            final int x;\n+\n+            Context(int x) {\n+                this.x = x;\n+            }\n+\n+            Quoted quoted() {\n+                return (int y) -> x + y;\n+            }\n+        }\n+        Context context = new Context(x);\n+        Quoted quoted = context.quoted();\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(quoted.capturedValues().values().iterator().next(), context);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @DataProvider(name = \"ints\")\n+    public Object[][] ints() {\n+        return IntStream.range(0, 50)\n+                .mapToObj(i -> new Object[] { i })\n+                .toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestGenericMethodCall.out -XDrawDiagnostics TestGenericMethodCall.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+public class TestGenericMethodCall {\n+    void test(boolean cond) {\n+        apply(Quoted.class, () -> {});\n+        apply(Quoted.class, (int i) -> \"\"); \/\/ ok (int->String)\n+        apply(Quoted.class, (int i) -> { return \"\"; }); \/\/ ok (int->String)\n+        apply(Quoted.class, (int i) -> { }); \/\/ ok (int->V)\n+        apply(Quoted.class, (int i) -> { return; }); \/\/ ok (int->V)\n+        apply(Quoted.class, (int i) -> { if (cond) return; else return; }); \/\/ ok (int->V)\n+        apply(Quoted.class, (int i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ ok (int->String)\n+    }\n+\n+    void testImplicit(boolean cond) {\n+        apply(Quoted.class, (i) -> \"\"); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testImplicitVar(boolean cond) {\n+        apply(Quoted.class, (var i) -> \"\"); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testBadInferredReturn(boolean cond) {\n+        apply(Quoted.class, (int i) -> { if (cond) return; else return \"\"; }); \/\/ error - only one branch returns\n+        apply(Quoted.class, (int i) -> { if (cond) { return \"2\"; } }); \/\/ error - one return, but body completes normally\n+    }\n+\n+    <Z> void apply(Class<Z> clazz, Z quoted) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+TestGenericMethodCall.java:43:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:44:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:45:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:46:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:47:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:48:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:52:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:53:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:54:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:55:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:56:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:57:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:61:40: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestGenericMethodCall.java:62:40: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.out","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestMethodCall.out -XDrawDiagnostics TestMethodCall.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+public class TestMethodCall {\n+    void test(boolean cond) {\n+        apply(() -> {});\n+        apply((int i) -> \"\"); \/\/ ok (int->String)\n+        apply((int i) -> { return \"\"; }); \/\/ ok (int->String)\n+        apply((int i) -> { }); \/\/ ok (int->V)\n+        apply((int i) -> { return; }); \/\/ ok (int->V)\n+        apply((int i) -> { if (cond) return; else return; }); \/\/ ok (int->V)\n+        apply((int i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ ok (int->String)\n+    }\n+\n+    void testImplicit(boolean cond) {\n+        apply((i) -> \"\"); \/\/ error - no parameter types\n+        apply((i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply((i) -> { }); \/\/ error - no parameter types\n+        apply((i) -> { return; }); \/\/ error - no parameter types\n+        apply((i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply((i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testImplicitVar(boolean cond) {\n+        apply((var i) -> \"\"); \/\/ error - no parameter types\n+        apply((var i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply((var i) -> { }); \/\/ error - no parameter types\n+        apply((var i) -> { return; }); \/\/ error - no parameter types\n+        apply((var i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply((var i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testBadInferredReturn(boolean cond) {\n+        apply((int i) -> { if (cond) return; else return \"\"; }); \/\/ error - only one branch returns\n+        apply((int i) -> { if (cond) { return \"2\"; } }); \/\/ error - one return, but body completes normally\n+    }\n+\n+    void apply(Quoted quoted) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+TestMethodCall.java:43:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:44:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:45:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:46:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:47:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:48:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:52:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:53:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:54:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:55:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:56:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:57:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:61:26: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestMethodCall.java:62:26: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.out","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestRecovery.out -XDrawDiagnostics TestRecovery.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+public class TestRecovery {\n+    void testRecoveryInAssignment() {\n+        Quoted res = (x) -> { System.out.println(nonExistent); };\n+    }\n+\n+    void testRecoveryInMethodCall() {\n+        apply((x) -> { System.out.println(nonExistent); });\n+    }\n+\n+    void testRecoveryInGenericMethodCall() {\n+        apply(Quoted.class, (x) -> { System.out.println(nonExistent); });\n+    }\n+\n+    void apply(Quoted quoted) { }\n+    <Z> void apply(Class<Z> clazz, Z quoted) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+TestRecovery.java:33:22: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:33:50: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:37:15: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:37:43: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:41:29: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:41:57: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"}]}