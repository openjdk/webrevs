{"files":[{"patch":"@@ -32,1 +32,0 @@\n-    void length(int i);\n@@ -37,1 +36,0 @@\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.buffer.BufferAllocator;\n@@ -33,1 +32,0 @@\n-import hat.ifacemapper.SegmentMapper;\n@@ -35,1 +33,2 @@\n-import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n@@ -43,2 +42,20 @@\n-        hat.buffer.S32Array s32Array  = hat.buffer.S32Array.create(accelerator, 100);\n-        System.out.println(\"Layout from schema \"+Buffer.getLayout(s32Array));\n+        hat.buffer.S32Array2D s32Array2D  = S32Array2D.create(accelerator, 100, 200);\n+        GroupLayout groupLayout = (GroupLayout) Buffer.getLayout(s32Array2D);\n+        System.out.println(\"Layout from buffer \"+groupLayout);\n+        BoundSchema<?> boundSchema = Buffer.getBoundSchema(s32Array2D);\n+        System.out.println(\"BoundSchema from buffer  \"+boundSchema);\n+\n+        BoundSchema.FieldLayout<?> fieldLayout =  boundSchema.rootBoundSchemaNode().getName(\"array\");\n+        long arrayOffset = fieldLayout.offset();\n+        MemoryLayout layout = fieldLayout.layout();\n+\n+        if (fieldLayout instanceof BoundSchema.ArrayFieldLayout arrayFieldLayout){\n+            System.out.println(\"isArray\");\n+            arrayFieldLayout.elementOffset(0);\n+            arrayFieldLayout.elementLayout(0);\n+            if (arrayFieldLayout instanceof BoundSchema.BoundArrayFieldLayout boundArrayFieldLayout){\n+                boundArrayFieldLayout.dimFields.forEach(dimLayout->{\n+                    System.out.println(dimLayout.field.name + \" \"+dimLayout.offset());\n+                });\n+            }\n+        }\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32ArrayTest.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -93,5 +93,0 @@\n-    @Override\n-    public void featureCount(int featureCount) {\n-        throw new IllegalStateException(\"featureCount(int featureCount) unimplemented \");\n-    }\n-\n@@ -108,5 +103,0 @@\n-    @Override\n-    public void stageCount(int stageCount) {\n-        throw new IllegalStateException(\"stageCount(int stageCount) unimplemented \");\n-    }\n-\n@@ -123,5 +113,0 @@\n-    @Override\n-    public void treeCount(int treeCount) {\n-        throw new IllegalStateException(\"void treeCount(int treeCount) unimplemented \");\n-    }\n-\n@@ -175,2 +160,1 @@\n-            \/\/ throw new IllegalStateException(\"Cascade.Feature.LinkOrValue left() unimplemented \");\n-        }\n+         }\n@@ -181,1 +165,0 @@\n-            \/\/throw new IllegalStateException(\"Cascade.Feature.LinkOrValue right() unimplemented \");\n@@ -224,1 +207,0 @@\n-                \/\/ throw new IllegalStateException(\"Anon anon() unimplemented \");\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/XMLHaarCascadeModel.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    void featureCount(int featureCount);\n+ \/\/  void featureCount(int featureCount);\n@@ -148,1 +148,1 @@\n-    void stageCount(int stageCount);\n+  \/\/  void stageCount(int stageCount);\n@@ -155,1 +155,1 @@\n-    void treeCount(int treeCount);\n+\/\/void treeCount(int treeCount);\n@@ -185,3 +185,0 @@\n-        instance.featureCount(features);\n-        instance.stageCount(stages);\n-        instance.treeCount(trees);\n@@ -200,3 +197,0 @@\n-        toCascade.featureCount(fromCascade.featureCount());\n-        toCascade.stageCount(fromCascade.stageCount());\n-        toCascade.treeCount(fromCascade.treeCount());\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    void length(int length);\n@@ -69,2 +68,1 @@\n-            .arrayLen(\"length\")\n-            .array(\"result\", array->array\n+            .arrayLen(\"length\").array(\"result\", array->array\n@@ -76,4 +74,1 @@\n-        var instance = schema.allocate(accelerator,length);\n-        instance.length(length);\n-        instance.atomicResultTableCount(0);\n-        return instance;\n+        return schema.allocate(accelerator,length);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ResultTable.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-    void length(int length);\n@@ -179,3 +178,1 @@\n-        var instance = schema.allocate(accelerator,length);\n-        instance.length(length);\n-        return instance;\n+        return schema.allocate(accelerator,length);\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/ScaleTable.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -217,1 +217,0 @@\n-    void argc(int argc);\n@@ -228,1 +227,0 @@\n-    void schemaLen(int schemaLen);\n@@ -235,3 +233,1 @@\n-            .arrayLen(\"argc\")\n-            .pad(12\/*(int)(16 - JAVA_INT.byteSize())*\/)\n-            .array(\"arg\", arg->arg\n+            .arrayLen(\"argc\").pad(12).array(\"arg\", arg->arg\n@@ -293,2 +289,5 @@\n-        argArray.argc(args.length);\n-        argArray.setSchemaBytes(schemaStr);\n+        byte[] schemaStrBytes = schemaStr.getBytes();\n+        for (int i = 0; i < schemaStrBytes.length; i++) {\n+            argArray.schemaBytes(i, schemaStrBytes[i]);\n+        }\n+        argArray.schemaBytes(schemaStrBytes.length, (byte) 0);\n@@ -336,10 +335,0 @@\n-    default void setSchemaBytes(String schemaStr) {\n-        byte[] schemaStrBytes = schemaStr.getBytes();\n-        schemaLen(schemaStrBytes.length);\n-        \/\/ TODO:we should be able to copy into the segment here ;)\n-        for (int i = 0; i < schemaStrBytes.length; i++) {\n-            schemaBytes(i, schemaStrBytes[i]);\n-        }\n-        schemaBytes(schemaStrBytes.length, (byte) 0);\n-    }\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n@@ -40,2 +39,0 @@\n-    void length(int i);\n-\n@@ -49,1 +46,0 @@\n-\n@@ -51,3 +47,1 @@\n-        var instance = schema.allocate(accelerator, length);\n-        instance.length(length);\n-        return instance;\n+        return schema.allocate(accelerator, length);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    void width(int i);\n@@ -41,1 +40,0 @@\n-    void height(int i);\n@@ -61,4 +59,1 @@\n-        var instance = schema.allocate(accelerator, width,height);\n-        instance.width(width);\n-        instance.height(height);\n-        return instance;\n+        return schema.allocate(accelerator, width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -9,2 +9,0 @@\n-    byte data(long idx);\n-    void data(long idx, byte v);\n@@ -12,1 +10,0 @@\n-    void width(int width);\n@@ -14,1 +11,3 @@\n-    void height(int height);\n+    byte data(long idx);\n+    void data(long idx, byte v);\n+\n@@ -20,4 +19,1 @@\n-        var instance = schema.allocate(accelerator,width,height);\n-        instance.width(width);\n-        instance.height(height);\n-        return instance;\n+        return schema.allocate(accelerator,width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S08x3RGBImage.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-    void length(int i);\n@@ -47,3 +46,1 @@\n-        var instance = schema.allocate(accelerator, length);\n-        instance.length(length);\n-        return instance;\n+        return schema.allocate(accelerator, length);\n@@ -58,1 +55,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-    void height(int i);\n@@ -41,2 +40,0 @@\n-    void width(int i);\n-\n@@ -44,1 +41,0 @@\n-\n@@ -50,1 +46,0 @@\n-\n@@ -54,0 +49,1 @@\n+\n@@ -55,1 +51,1 @@\n-            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n+            .arrayLen(\"width\",\"height\").array(\"array\"));\n@@ -58,4 +54,1 @@\n-        var instance = schema.allocate(accelerator, width,height);\n-        instance.width(width);\n-        instance.height(height);\n-        return instance;\n+        return schema.allocate(accelerator, width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,4 +33,0 @@\n-    int data(long idx);\n-\n-    void data(long idx, int v);\n-\n@@ -38,1 +34,0 @@\n-    void width(int width);\n@@ -40,1 +35,2 @@\n-    void height(int height);\n+    int data(long idx);\n+    void data(long idx, int v);\n@@ -44,2 +40,0 @@\n-\n-\n@@ -47,4 +41,1 @@\n-        var instance = schema.allocate(accelerator,width,height);\n-        instance.width(width);\n-        instance.height(height);\n-        return instance;\n+        return schema.allocate(accelerator,width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/S32RGBAImage.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-    short data(long idx);\n-    void data(long idx, short v);\n@@ -36,1 +34,0 @@\n-    void width(int width);\n@@ -38,1 +35,2 @@\n-    void height(int height);\n+    short data(long idx);\n+    void data(long idx, short v);\n@@ -41,1 +39,1 @@\n-            .arrayLen(\"width\", \"height\").stride(1).array(\"data\")\n+            .arrayLen(\"width\", \"height\").array(\"data\")\n@@ -45,4 +43,1 @@\n-        var instance = schema.allocate(accelerator,width,height);\n-        instance.width(width);\n-        instance.height(height);\n-        return instance;\n+        return schema.allocate(accelerator,width,height);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/U16GreyImage.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -13,0 +13,2 @@\n+import static hat.ifacemapper.BoundSchema.BoundSchemaNode.getBoundGroupLayout;\n+\n@@ -23,0 +25,1 @@\n+        public BoundSchemaNode<?> parent;\n@@ -25,0 +28,1 @@\n+        MemoryLayout.PathElement pathElement;\n@@ -26,1 +30,2 @@\n-        FieldLayout(T field, MemoryLayout layout) {\n+        FieldLayout(BoundSchemaNode<?> parent,T field, MemoryLayout layout) {\n+            this.parent = parent;\n@@ -29,0 +34,8 @@\n+            this.pathElement =  MemoryLayout.PathElement.groupElement(field.name);\n+        }\n+\n+        public long offset() {\n+            return parent.memoryLayouts.getLast().byteOffset(pathElement);\n+        }\n+        public MemoryLayout layout() {\n+            return parent.memoryLayouts.getLast().select(pathElement);\n@@ -36,2 +49,2 @@\n-        ArrayFieldLayout(Schema.FieldNode fieldControlledArray, MemoryLayout layout, int len) {\n-            super(fieldControlledArray, layout);\n+        ArrayFieldLayout(BoundSchemaNode<?> parent, Schema.FieldNode fieldControlledArray, MemoryLayout layout, int len) {\n+            super(parent, fieldControlledArray, layout);\n@@ -40,0 +53,7 @@\n+\n+        public long elementOffset(long idx) {\n+            return 0L;\n+        }\n+        public MemoryLayout elementLayout(long idx) {\n+            return null;\n+        }\n@@ -44,0 +64,2 @@\n+        public final List<FieldLayout<?>>dimFields;\n+\n@@ -45,2 +67,2 @@\n-        BoundArrayFieldLayout(Schema.FieldNode fieldControlledArray, MemoryLayout layout, int len, int idx) {\n-            super(fieldControlledArray, layout, len);\n+        BoundArrayFieldLayout(BoundSchemaNode<?> parent,Schema.FieldNode fieldControlledArray, MemoryLayout layout, int len, int idx) {\n+            super(parent, fieldControlledArray, layout, len);\n@@ -48,0 +70,12 @@\n+            this.dimFields = new ArrayList<>();\n+            if (field instanceof Schema.FieldNode.PrimitiveFieldControlledArray primitiveFieldControlledArray){\n+                 primitiveFieldControlledArray.arrayLenFields.forEach(f->{\n+                    dimFields.add(parent.getName(f.name));\n+                 });\n+            }else if (field instanceof Schema.FieldNode.IfaceFieldControlledArray ifaceFieldControlledArray){\n+                 ifaceFieldControlledArray.arrayLenFields.forEach(f->{\n+                     dimFields.add(parent.getName(f.name));\n+                 });\n+            }else{\n+                throw new IllegalStateException(\"not a bound field\");\n+            }\n@@ -54,1 +88,1 @@\n-        this.groupLayout = rootBoundSchemaNode.getBoundGroupLayout(schema.rootIfaceType);\n+        this.groupLayout = getBoundGroupLayout(rootBoundSchemaNode,schema.rootIfaceType);\n@@ -83,1 +117,1 @@\n-    FieldLayout<?> createFieldBinding(Schema.FieldNode fieldNode, MemoryLayout memoryLayout) {\n+    FieldLayout<?> createFieldBinding(BoundSchemaNode<?>parent, Schema.FieldNode fieldNode, MemoryLayout memoryLayout) {\n@@ -87,1 +121,1 @@\n-            var arraySizeBinding = new BoundArrayFieldLayout(fieldNode, memoryLayout, arrayLengths[idx], idx);\n+            var arraySizeBinding = new BoundArrayFieldLayout(parent,fieldNode, memoryLayout, arrayLengths[idx], idx);\n@@ -91,1 +125,1 @@\n-            return new ArrayFieldLayout(fieldNode, memoryLayout, ifaceMapableFixedArray.len);\n+            return new ArrayFieldLayout(parent,fieldNode, memoryLayout, ifaceMapableFixedArray.len);\n@@ -93,1 +127,1 @@\n-            return new ArrayFieldLayout(fieldNode, memoryLayout, primitiveFixedArray.len);\n+            return new ArrayFieldLayout(parent,fieldNode, memoryLayout, primitiveFixedArray.len);\n@@ -95,1 +129,1 @@\n-            return new FieldLayout<>(fieldNode, memoryLayout);\n+            return new FieldLayout<>(parent,fieldNode, memoryLayout);\n@@ -119,1 +153,1 @@\n-            return boundSchema.createFieldBinding(fieldNode, memoryLayout);\n+            return boundSchema.createFieldBinding(this,fieldNode, memoryLayout);\n@@ -137,1 +171,1 @@\n-        public FieldLayout<?> getBoundFieldChild(String fieldName) {\n+        public FieldLayout<?> getName(String fieldName) {\n@@ -139,0 +173,2 @@\n+\n+\n@@ -141,2 +177,2 @@\n-        private GroupLayout getBoundGroupLayout(Schema.IfaceType ifaceType) {\n-            BoundSchema.BoundSchemaNode<?> child = createChild(ifaceType);\n+        static GroupLayout getBoundGroupLayout(BoundSchemaNode child, Schema.IfaceType ifaceType) {\n+\n@@ -153,2 +189,4 @@\n-                            case Schema.FieldNode.IfaceField field ->\n-                                    child.getBoundGroupLayout(field.parent.getChild(field.ifaceType.iface));\n+                            case Schema.FieldNode.IfaceField field -> {\n+                                var fieldIfaceType = field.parent.getChild(field.ifaceType.iface);\n+                                yield getBoundGroupLayout(child.createChild(ifaceType), fieldIfaceType);\n+                            }\n@@ -158,1 +196,2 @@\n-                                var elementLayout = child.getBoundGroupLayout(field.parent.getChild(field.ifaceType.iface))\n+                                var fieldIfaceType = field.parent.getChild(field.ifaceType.iface);\n+                                var elementLayout = getBoundGroupLayout(child.createChild(ifaceType), fieldIfaceType)\n@@ -173,2 +212,2 @@\n-                                var elementLayout = child.getBoundGroupLayout(field.parent.getChild(field.ifaceType.iface))\n-\n+                                var fieldIfaceType = field.parent.getChild(field.ifaceType.iface);\n+                                var elementLayout = getBoundGroupLayout(child.createChild(ifaceType), fieldIfaceType)\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/BoundSchema.java","additions":59,"deletions":20,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -44,1 +44,25 @@\n-        return (T) boundSchema.allocate(accelerator.lookup, accelerator);\n+        T instance = (T)boundSchema.allocate(accelerator.lookup, accelerator);\n+        MemorySegment memorySegment = Buffer.getMemorySegment(instance);\n+        int[] count = new int[]{0};\n+        boundSchema.rootBoundSchemaNode().fieldLayouts.forEach(fieldLayout -> {\n+                if (fieldLayout instanceof BoundSchema.BoundArrayFieldLayout boundArrayFieldLayout) {\n+                    boundArrayFieldLayout.dimFields.forEach(dimLayout -> {\n+                        long dimOffset = dimLayout.offset();\n+                        int dim = boundLengths[count[0]++];\n+                        if (dimLayout.field instanceof FieldNode.ArrayLen arrayLen){\n+                            if (arrayLen.key.accessorType.equals(AccessorInfo.AccessorType.GETTER_AND_SETTER)){\n+                                throw new IllegalStateException(\"You have a bound array dim field \"+dimLayout.field.name+\" controlling size of \"+boundArrayFieldLayout.field.name+\"[] which has a setter \");\n+                            }\n+                            if (arrayLen.type == Long.TYPE){\n+                                memorySegment.set(ValueLayout.JAVA_LONG,dimOffset,dim);\n+                            }else if (arrayLen.type == Integer.TYPE){\n+                                memorySegment.set(ValueLayout.JAVA_INT,dimOffset,dim);\n+                            }else{\n+                                throw new IllegalArgumentException(\"Unsupported array length type: \" + arrayLen.type);\n+                            }\n+                        }\n+                    });\n+                }\n+        });\n+\n+        return instance;\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/Schema.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -82,3 +82,3 @@\n-        private final Cardinality cardinality;\n-        private final ValueType valueType;\n-        private final AccessorType accessorType;\n+        public final Cardinality cardinality;\n+        public final ValueType valueType;\n+        public final AccessorType accessorType;\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/accessor\/AccessorInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}