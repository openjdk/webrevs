{"files":[{"patch":"@@ -247,1 +247,0 @@\n-        ${CMAKE_SOURCE_DIR}\/backends\/opencl\/cpp\/opencl_shared.cpp\n@@ -256,2 +255,0 @@\n-        ${CMAKE_SOURCE_DIR}\/backends\/shared\/cpp\/shared.cpp\n-        ${CMAKE_SOURCE_DIR}\/backends\/opencl\/cpp\/opencl_shared.cpp\n@@ -261,0 +258,4 @@\n+     target_link_libraries(opencl_info\n+        opencl_backend\n+        \"-framework OpenCL\"\n+     )\n","filename":"hat\/CMakeLists.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+cmake-build-debug\n","filename":"hat\/backends\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"","filename":"hat\/backends\/.idea\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"hat\/intellij\/.idea\/.gitignore","status":"copied"},{"patch":"@@ -0,0 +1,2 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module classpath=\"CMake\" type=\"CPP_MODULE\" version=\"4\" \/>\n\\ No newline at end of file\n","filename":"hat\/backends\/.idea\/backends.iml","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"CMakePythonSetting\">\n+    <option name=\"pythonIntegrationState\" value=\"YES\" \/>\n+  <\/component>\n+  <component name=\"CMakeWorkspace\" PROJECT_DIR=\"$PROJECT_DIR$\" \/>\n+<\/project>\n\\ No newline at end of file\n","filename":"hat\/backends\/.idea\/misc.xml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"ProjectModuleManager\">\n+    <modules>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/.idea\/backends.iml\" filepath=\"$PROJECT_DIR$\/.idea\/backends.iml\" \/>\n+    <\/modules>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"hat\/backends\/.idea\/modules.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"VcsDirectoryMappings\">\n+    <mapping directory=\"$PROJECT_DIR$\/..\/..\" vcs=\"Git\" \/>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"hat\/backends\/.idea\/vcs.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+cmake_minimum_required(VERSION 3.28)\n+project(backends)\n+\n+set(CMAKE_CXX_STANDARD 14)\n+\n+find_package(OpenCL)\n+if(OPENCL_FOUND)\n+    message(\"OPENCL\")\n+    if (APPLE)\n+        include_directories(\n+                ${CMAKE_SOURCE_DIR}\/opencl\/shared\/include\n+                ${CMAKE_SOURCE_DIR}\/opencl\/include\n+                ${CMAKE_SOURCE_DIR}\/shared\/include\n+                \"-framework OpenCL\"\n+        )\n+        link_directories(\n+                ${CMAKE_BINARY_DIR}\n+        )\n+\n+        add_library(opencl_backend SHARED\n+                ${CMAKE_SOURCE_DIR}\/shared\/cpp\/shared.cpp\n+                ${CMAKE_SOURCE_DIR}\/opencl\/cpp\/opencl_backend.cpp\n+        )\n+\n+        target_link_libraries(opencl_backend\n+                \"-framework OpenCL\"\n+        )\n+\n+        add_executable(opencl_info\n+                ${CMAKE_SOURCE_DIR}\/opencl\/cpp\/info.cpp\n+        )\n+\n+        target_link_libraries(opencl_info\n+                opencl_backend\n+                \"-framework OpenCL\"\n+        )\n+        add_custom_target(backends DEPENDS opencl_info opencl_backend)\n+    else()\n+        message(\"OPENCL but not on APPLE\")\n+    endif()\n+\n+endif()\n","filename":"hat\/backends\/CMakeLists.txt","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -31,4 +31,5 @@\n-CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer( void *ptr, size_t sizeInBytes)\n-   : ptr(ptr),  sizeInBytes(sizeInBytes) {\n-    cuMemAlloc(&devicePtr,  (size_t)sizeInBytes);\n-   }\n+CudaBackend::CudaProgram::CudaKernel::CudaBuffer::CudaBuffer(void *ptr, size_t sizeInBytes)\n+        : ptr(ptr), sizeInBytes(sizeInBytes) {\n+    cuMemAlloc(&devicePtr, (size_t) sizeInBytes);\n+}\n+\n@@ -39,1 +40,2 @@\n-CudaBackend::CudaProgram::CudaKernel::CudaKernel(Backend::Program *program, CUfunction function):Backend::Program::Kernel(program),function(function){\n+CudaBackend::CudaProgram::CudaKernel::CudaKernel(Backend::Program *program, CUfunction function)\n+        : Backend::Program::Kernel(program), function(function) {\n@@ -41,2 +43,3 @@\n-CudaBackend::CudaProgram::CudaKernel::~CudaKernel(){\n-   \/\/ releaseCUfunction function\n+\n+CudaBackend::CudaProgram::CudaKernel::~CudaKernel() {\n+    \/\/ releaseCUfunction function\n@@ -44,27 +47,28 @@\n-long CudaBackend::CudaProgram::CudaKernel::ndrange( int range, void *argArray) {\n-   \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n-   ArgSled argSled((ArgArray_t*)argArray);\n-\n-   CudaBackend *backend = (CudaBackend*)program->backend;\n-   bool verbose = false;\n-   void *argslist[argSled.argc()];\n-   \/\/ #ifdef VERBOSE\n-   std::cerr << \"there are \"<<argSled.argc()<<\"args \"<<std::endl;\n-   \/\/ #endif\n-   for (int i = 0; i < argSled.argc(); i++) {\n-      Arg_t *arg = argSled.arg(i);\n-      if (arg->variant == '&'){\n-\n-           CudaBuffer *cudaBuffer =  new CudaBuffer(\n-                     (void*)arg->value.buffer.memorySegment,\n-                     (size_t)arg->value.buffer.sizeInBytes);\n-         \/\/std::cout << \"copying out!\"<<std::endl;\n-         checkCudaErrors(cuMemcpyHtoD(cudaBuffer->devicePtr, cudaBuffer->ptr, cudaBuffer->sizeInBytes));\n-         argslist[arg->idx] = (void*)&cudaBuffer->devicePtr;\n-         arg->value.buffer.vendorPtr = (void*)cudaBuffer;\n-      } else if (arg->variant == 'I') {\n-         argslist[arg->idx] = &arg->value.s32;\n-      } else if (arg->variant == 'F') {\n-         argslist[arg->idx] = &arg->value.f32;\n-      }\n-   }\n+\n+long CudaBackend::CudaProgram::CudaKernel::ndrange(int range, void *argArray) {\n+    \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n+    ArgSled argSled((ArgArray_t *) argArray);\n+\n+    CudaBackend *backend = (CudaBackend *) program->backend;\n+    bool verbose = false;\n+    void *argslist[argSled.argc()];\n+    \/\/ #ifdef VERBOSE\n+    std::cerr << \"there are \" << argSled.argc() << \"args \" << std::endl;\n+    \/\/ #endif\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n+        if (arg->variant == '&') {\n+\n+            CudaBuffer *cudaBuffer = new CudaBuffer(\n+                    (void *) arg->value.buffer.memorySegment,\n+                    (size_t) arg->value.buffer.sizeInBytes);\n+            \/\/std::cout << \"copying out!\"<<std::endl;\n+            checkCudaErrors(cuMemcpyHtoD(cudaBuffer->devicePtr, cudaBuffer->ptr, cudaBuffer->sizeInBytes));\n+            argslist[arg->idx] = (void *) &cudaBuffer->devicePtr;\n+            arg->value.buffer.vendorPtr = (void *) cudaBuffer;\n+        } else if (arg->variant == 'I') {\n+            argslist[arg->idx] = &arg->value.s32;\n+        } else if (arg->variant == 'F') {\n+            argslist[arg->idx] = &arg->value.f32;\n+        }\n+    }\n@@ -74,1 +78,1 @@\n-   std::cout << \"Running the kernel... range = \"<< range << \"range mod 512 \" << (range%512)<< std::endl;\n+    std::cout << \"Running the kernel... range = \"<< range << \"range mod 512 \" << (range%512)<< std::endl;\n@@ -77,2 +81,2 @@\n-   checkCudaErrors( cuLaunchKernel(function,\n-            range\/1024, 1, 1,\n+    checkCudaErrors(cuLaunchKernel(function,\n+            range \/ 1024, 1, 1,\n@@ -81,1 +85,1 @@\n-            argslist, 0) );\n+            argslist, 0));\n@@ -83,1 +87,1 @@\n-   \/\/cudaError_t t = cudaDeviceSynchronize();\n+    \/\/cudaError_t t = cudaDeviceSynchronize();\n@@ -86,1 +90,1 @@\n-   \/\/std::cout << \"Kernel complete...\"<<cudaGetErrorString(t)<<std::endl;\n+    \/\/std::cout << \"Kernel complete...\"<<cudaGetErrorString(t)<<std::endl;\n@@ -88,2 +92,2 @@\n-   for (int i = 0; i < argSled.argc(); i++) {\n-      Arg_t *arg = argSled.arg(i);\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n@@ -91,1 +95,1 @@\n-      std::cout << \"looking at ! \"<<arg->argc<<std::endl;\n+        std::cout << \"looking at ! \"<<arg->argc<<std::endl;\n@@ -93,21 +97,21 @@\n-      if (arg->variant == '&'){\n-         \/\/   if ((arg->access &ACCESS_WO || arg->access &ACCESS_RW)){\n-         \/\/#ifdef VERBOSE\n-         \/\/std::cout << \"copying back!\"<<std::endl;\n-         CudaBuffer *cudaBuffer = (CudaBuffer*)arg->value.buffer.vendorPtr;\n-         checkCudaErrors( cuMemcpyDtoH(cudaBuffer->ptr, cudaBuffer->devicePtr, cudaBuffer->sizeInBytes) );\n-         \/\/#endif\n-         \/\/arg->value.buffer.vendorPtr\n-         \/\/ checkCudaErrors( cuMemcpyDtoH(arg->_1d.ptr, arg->_1d.buf, arg->sizeInBytes) );\n-         \/\/hexdump(arg->_1d.ptr, sizeof(int) * arg->_1d.elements);\n-         \/\/       }else{\n-         \/\/#ifdef VERBOSE\n-         \/\/          std::cout << \"skipping copying back!\"<<std::endl;\n-         \/\/#endif\n-         \/\/       }\n-      }\n-   }\n-\n-   for (int i = 0; i < argSled.argc(); i++) {\n-      Arg_t *arg = argSled.arg(i);\n-      if (arg->variant == '&'){\n+        if (arg->variant == '&') {\n+            \/\/   if ((arg->access &ACCESS_WO || arg->access &ACCESS_RW)){\n+            \/\/#ifdef VERBOSE\n+            \/\/std::cout << \"copying back!\"<<std::endl;\n+            CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n+            checkCudaErrors(cuMemcpyDtoH(cudaBuffer->ptr, cudaBuffer->devicePtr, cudaBuffer->sizeInBytes));\n+            \/\/#endif\n+            \/\/arg->value.buffer.vendorPtr\n+            \/\/ checkCudaErrors( cuMemcpyDtoH(arg->_1d.ptr, arg->_1d.buf, arg->sizeInBytes) );\n+            \/\/hexdump(arg->_1d.ptr, sizeof(int) * arg->_1d.elements);\n+            \/\/       }else{\n+            \/\/#ifdef VERBOSE\n+            \/\/          std::cout << \"skipping copying back!\"<<std::endl;\n+            \/\/#endif\n+            \/\/       }\n+        }\n+    }\n+\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n+        if (arg->variant == '&') {\n@@ -115,1 +119,1 @@\n-         std::cout << \"releasing arg \"<<arg->argc<< \" \"<<std::endl;\n+            std::cout << \"releasing arg \"<<arg->argc<< \" \"<<std::endl;\n@@ -117,2 +121,2 @@\n-  CudaBuffer *cudaBuffer = (CudaBuffer*)arg->value.buffer.vendorPtr;\n-       \/\/  checkCudaErrors( cuMemcpyDtoH(cudaBuffer->ptr, cudaBuffer->devicePtr, cudaBuffer->sizeInBytes) );\n+            CudaBuffer *cudaBuffer = (CudaBuffer *) arg->value.buffer.vendorPtr;\n+            \/\/  checkCudaErrors( cuMemcpyDtoH(cudaBuffer->ptr, cudaBuffer->devicePtr, cudaBuffer->sizeInBytes) );\n@@ -120,3 +124,3 @@\n-         checkCudaErrors( cuMemFree(cudaBuffer->devicePtr));\n-         delete cudaBuffer;\n-      }else{\n+            checkCudaErrors(cuMemFree(cudaBuffer->devicePtr));\n+            delete cudaBuffer;\n+        } else {\n@@ -124,1 +128,1 @@\n-         std::cout << \"not releasing arg \"<<arg->idx<< \" \"<<std::endl;\n+            std::cout << \"not releasing arg \"<<arg->idx<< \" \"<<std::endl;\n@@ -126,2 +130,2 @@\n-      }\n-   }\n+        }\n+    }\n@@ -129,1 +133,1 @@\n-   return (long)0;\n+    return (long) 0;\n@@ -133,1 +137,2 @@\n-CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx,  CUmodule module):Backend::Program(backend, buildInfo), ptx(ptx), module(module){\n+CudaBackend::CudaProgram::CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule module)\n+        : Backend::Program(backend, buildInfo), ptx(ptx), module(module) {\n@@ -135,1 +140,2 @@\n-CudaBackend::CudaProgram::~CudaProgram(){\n+\n+CudaBackend::CudaProgram::~CudaProgram() {\n@@ -138,7 +144,8 @@\n-long CudaBackend::CudaProgram::getKernel(int nameLen, char *name){\n-   CUfunction function;\n-   std::cout << \"trying to get kernelFunction \" << name << std::endl;\n-   checkCudaErrors(\n-       cuModuleGetFunction(&function, module, name)\n-       );\n-   return (long)new CudaKernel(this, function);\n+\n+long CudaBackend::CudaProgram::getKernel(int nameLen, char *name) {\n+    CUfunction function;\n+    std::cout << \"trying to get kernelFunction \" << name << std::endl;\n+    checkCudaErrors(\n+            cuModuleGetFunction(&function, module, name)\n+    );\n+    return (long) new CudaKernel(this, function);\n@@ -146,2 +153,3 @@\n-bool CudaBackend::CudaProgram::programOK(){\n-   return true;\n+\n+bool CudaBackend::CudaProgram::programOK() {\n+    return true;\n@@ -149,0 +157,1 @@\n+\n@@ -150,1 +159,1 @@\n-   :Backend((Backend::Config*)cudaConfig, configSchemaLen, configSchema){\n+        : Backend((Backend::Config *) cudaConfig, configSchemaLen, configSchema) {\n@@ -152,13 +161,13 @@\n-      CUresult err = cuInit(0);\n-      int deviceCount = 0;\n-      if (err == CUDA_SUCCESS){\n-         checkCudaErrors(cuDeviceGetCount(&deviceCount));\n-      }\n-      checkCudaErrors(cuDeviceGet(&device, 0));\n-      checkCudaErrors(cuCtxCreate(&context, 0, device));\n-      std::cout <<\"created context\"<<std::endl;\n-   }\n-\n-CudaBackend::~CudaBackend(){\n-   std::cout <<\"freeing context\"<<std::endl;\n-   checkCudaErrors(cuCtxDestroy(context));\n+    CUresult err = cuInit(0);\n+    int deviceCount = 0;\n+    if (err == CUDA_SUCCESS) {\n+        checkCudaErrors(cuDeviceGetCount(&deviceCount));\n+    }\n+    checkCudaErrors(cuDeviceGet(&device, 0));\n+    checkCudaErrors(cuCtxCreate(&context, 0, device));\n+    std::cout << \"created context\" << std::endl;\n+}\n+\n+CudaBackend::~CudaBackend() {\n+    std::cout << \"freeing context\" << std::endl;\n+    checkCudaErrors(cuCtxDestroy(context));\n@@ -167,4 +176,4 @@\n-int CudaBackend::getMaxComputeUnits(){\n-   std::cout << \"getMaxComputeUnits()\"<<std::endl;\n-   int value = 1;\n-   return value;\n+int CudaBackend::getMaxComputeUnits() {\n+    std::cout << \"getMaxComputeUnits()\" << std::endl;\n+    int value = 1;\n+    return value;\n@@ -173,4 +182,4 @@\n-void CudaBackend::info(){\n-   char name[100];\n-   cuDeviceGetName(name, 100, device);\n-   std::cout << \"> Using device 0: \" <<  name << std::endl;\n+void CudaBackend::info() {\n+    char name[100];\n+    cuDeviceGetName(name, 100, device);\n+    std::cout << \"> Using device 0: \" << name << std::endl;\n@@ -178,5 +187,5 @@\n-   \/\/ get compute capabilities and the devicename\n-   int major = 0, minor = 0;\n-   checkCudaErrors(cuDeviceGetAttribute(&major, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, device));\n-   checkCudaErrors(cuDeviceGetAttribute(&minor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, device));\n-   std::cout << \"> GPU Device has major=\"<< major << \" minor=\" << minor << \" compute capability\" << std::endl;\n+    \/\/ get compute capabilities and the devicename\n+    int major = 0, minor = 0;\n+    checkCudaErrors(cuDeviceGetAttribute(&major, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, device));\n+    checkCudaErrors(cuDeviceGetAttribute(&minor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, device));\n+    std::cout << \"> GPU Device has major=\" << major << \" minor=\" << minor << \" compute capability\" << std::endl;\n@@ -184,3 +193,3 @@\n-   int warpSize;\n-   checkCudaErrors(cuDeviceGetAttribute(&warpSize, CU_DEVICE_ATTRIBUTE_WARP_SIZE, device));\n-   std::cout << \"> GPU Device has warpSize \"<< warpSize << std::endl;\n+    int warpSize;\n+    checkCudaErrors(cuDeviceGetAttribute(&warpSize, CU_DEVICE_ATTRIBUTE_WARP_SIZE, device));\n+    std::cout << \"> GPU Device has warpSize \" << warpSize << std::endl;\n@@ -188,3 +197,3 @@\n-   int threadsPerBlock;\n-   checkCudaErrors(cuDeviceGetAttribute(&threadsPerBlock, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, device));\n-   std::cout << \"> GPU Device has threadsPerBlock \"<< threadsPerBlock << std::endl;\n+    int threadsPerBlock;\n+    checkCudaErrors(cuDeviceGetAttribute(&threadsPerBlock, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, device));\n+    std::cout << \"> GPU Device has threadsPerBlock \" << threadsPerBlock << std::endl;\n@@ -192,3 +201,3 @@\n-   int cores;\n-   checkCudaErrors(cuDeviceGetAttribute(&cores, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, device));\n-   std::cout << \"> GPU Cores \"<< cores << std::endl;\n+    int cores;\n+    checkCudaErrors(cuDeviceGetAttribute(&cores, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, device));\n+    std::cout << \"> GPU Cores \" << cores << std::endl;\n@@ -196,5 +205,5 @@\n-   size_t     totalGlobalMem;\n-   checkCudaErrors( cuDeviceTotalMem(&totalGlobalMem, device) );\n-   std::cout << \"  Total amount of global memory:   \"<< (unsigned long long)totalGlobalMem << std::endl;\n-   std::cout << \"  64-bit Memory Address:           \" <<\n-      ((totalGlobalMem > (unsigned long long)4*1024*1024*1024L)?  \"YES\" : \"NO\") << std::endl;\n+    size_t totalGlobalMem;\n+    checkCudaErrors(cuDeviceTotalMem(&totalGlobalMem, device));\n+    std::cout << \"  Total amount of global memory:   \" << (unsigned long long) totalGlobalMem << std::endl;\n+    std::cout << \"  64-bit Memory Address:           \" <<\n+              ((totalGlobalMem > (unsigned long long) 4 * 1024 * 1024 * 1024L) ? \"YES\" : \"NO\") << std::endl;\n@@ -203,34 +212,35 @@\n-long CudaBackend::compileProgram(int len, char *source){\n-   Ptx *ptx  = Ptx::nvcc(source, len);\n-\n-   CUmodule module;\n- std::cout <<\"inside compileProgram\" << std::endl;\n- std::cout << \"cuda \" << source << std::endl;\n-   if (ptx->text != nullptr){\n-\n-      \/\/ContextDevice *contextDevice= (ContextDevice*) handle;\n-\n-      std::cout << \"ptx \" << ptx->text << std::endl;\n-\n-\n-      \/\/ in this branch we use compilation with parameters\n-      const unsigned int jitNumOptions = 2;\n-      CUjit_option *jitOptions = new CUjit_option[jitNumOptions];\n-      void **jitOptVals = new void*[jitNumOptions];\n-\n-      \/\/ set up size of compilation log buffer\n-      jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n-      int jitLogBufferSize = 1024;\n-      jitOptVals[0] = (void *)(size_t)jitLogBufferSize;\n-\n-      \/\/ set up pointer to the compilation log buffer\n-      jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n-      char *jitLogBuffer = new char[jitLogBufferSize];\n-      jitOptVals[1] = jitLogBuffer;\n-      int status = cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, (void **)jitOptVals);\n-      printf(\"> PTX JIT log:\\n%s\\n\", jitLogBuffer);\n-      delete ptx;\n-   }else{\n-      std::cout << \"no ptx content!\/\" << std::endl;\n-   }\n-   return (long) new CudaProgram(this, nullptr, ptx, module);\n+\n+long CudaBackend::compileProgram(int len, char *source) {\n+    Ptx *ptx = Ptx::nvcc(source, len);\n+\n+    CUmodule module;\n+    std::cout << \"inside compileProgram\" << std::endl;\n+    std::cout << \"cuda \" << source << std::endl;\n+    if (ptx->text != nullptr) {\n+\n+        \/\/ContextDevice *contextDevice= (ContextDevice*) handle;\n+\n+        std::cout << \"ptx \" << ptx->text << std::endl;\n+\n+\n+        \/\/ in this branch we use compilation with parameters\n+        const unsigned int jitNumOptions = 2;\n+        CUjit_option *jitOptions = new CUjit_option[jitNumOptions];\n+        void **jitOptVals = new void *[jitNumOptions];\n+\n+        \/\/ set up size of compilation log buffer\n+        jitOptions[0] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n+        int jitLogBufferSize = 1024;\n+        jitOptVals[0] = (void *) (size_t) jitLogBufferSize;\n+\n+        \/\/ set up pointer to the compilation log buffer\n+        jitOptions[1] = CU_JIT_INFO_LOG_BUFFER;\n+        char *jitLogBuffer = new char[jitLogBufferSize];\n+        jitOptVals[1] = jitLogBuffer;\n+        int status = cuModuleLoadDataEx(&module, ptx->text, jitNumOptions, jitOptions, (void **) jitOptVals);\n+        printf(\"> PTX JIT log:\\n%s\\n\", jitLogBuffer);\n+        delete ptx;\n+    } else {\n+        std::cout << \"no ptx content!\/\" << std::endl;\n+    }\n+    return (long) new CudaProgram(this, nullptr, ptx, module);\n@@ -239,3 +249,3 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema){\n-   \/\/ Dynamic cast?\n-   CudaBackend::CudaConfig *cudaConfig = (CudaBackend::CudaConfig*)config;\n+long getBackend(void *config, int configSchemaLen, char *configSchema) {\n+    \/\/ Dynamic cast?\n+    CudaBackend::CudaConfig *cudaConfig = (CudaBackend::CudaConfig *) config;\n@@ -243,1 +253,1 @@\n-   return (long)new CudaBackend(cudaConfig, configSchemaLen, configSchema);\n+    return (long) new CudaBackend(cudaConfig, configSchemaLen, configSchema);\n","filename":"hat\/backends\/cuda\/cpp\/cuda_backend.cpp","additions":174,"deletions":164,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-void __checkCudaErrors( CUresult err, const char *file, const int line ) {\n-   if( CUDA_SUCCESS != err) {\n-      std::cerr << \"CUDA Driver API error = \" << err << \" from file \"<< file << \" line \" <<  line  << std::endl;\n-      exit(-1);\n-   }\n+void __checkCudaErrors(CUresult err, const char *file, const int line) {\n+    if (CUDA_SUCCESS != err) {\n+        std::cerr << \"CUDA Driver API error = \" << err << \" from file \" << file << \" line \" << line << std::endl;\n+        exit(-1);\n+    }\n","filename":"hat\/backends\/cuda\/cpp\/cuda_shared.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,8 +28,9 @@\n-class ContextDevice{\n-   public:\n-      CUdevice device;\n-      CUcontext context;\n-      ContextDevice(){\n-         CUresult err = cuInit(0);\n-         int deviceCount = 0;\n-         if (err == CUDA_SUCCESS){\n+class ContextDevice {\n+public:\n+    CUdevice device;\n+    CUcontext context;\n+\n+    ContextDevice() {\n+        CUresult err = cuInit(0);\n+        int deviceCount = 0;\n+        if (err == CUDA_SUCCESS) {\n@@ -37,9 +38,10 @@\n-         }\n-         checkCudaErrors(cuDeviceGet(&device, 0));\n-         checkCudaErrors(cuCtxCreate(&context, 0, device));\n-         std::cout <<\"created context\"<<std::endl;\n-      }\n-      ~ContextDevice(){\n-         std::cout <<\"freeing context\"<<std::endl;\n-         checkCudaErrors(cuCtxDestroy(context));\n-      }\n+        }\n+        checkCudaErrors(cuDeviceGet(&device, 0));\n+        checkCudaErrors(cuCtxCreate(&context, 0, device));\n+        std::cout << \"created context\" << std::endl;\n+    }\n+\n+    ~ContextDevice() {\n+        std::cout << \"freeing context\" << std::endl;\n+        checkCudaErrors(cuCtxDestroy(context));\n+    }\n@@ -47,6 +49,0 @@\n-int main(int argc, char **argv){\n-   std::cout << \"CUDA info\" << std::endl;\n-   ContextDevice contextDevice;\n-   char name[100];\n-   cuDeviceGetName(name, 100, contextDevice.device);\n-   std::cout << \"> Using device 0: \" <<  name << std::endl;\n@@ -54,5 +50,12 @@\n-   \/\/ get compute capabilities and the devicename\n-   int major = 0, minor = 0;\n-   checkCudaErrors(cuDeviceGetAttribute(&major, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, contextDevice.device));\n-   checkCudaErrors(cuDeviceGetAttribute(&minor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, contextDevice.device));\n-   std::cout << \"> GPU Device has major=\"<< major << \" minor=\" << minor << \" compute capability\" << std::endl;\n+int main(int argc, char **argv) {\n+    std::cout << \"CUDA info\" << std::endl;\n+    ContextDevice contextDevice;\n+    char name[100];\n+    cuDeviceGetName(name, 100, contextDevice.device);\n+    std::cout << \"> Using device 0: \" << name << std::endl;\n+\n+    \/\/ get compute capabilities and the devicename\n+    int major = 0, minor = 0;\n+    checkCudaErrors(cuDeviceGetAttribute(&major, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, contextDevice.device));\n+    checkCudaErrors(cuDeviceGetAttribute(&minor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, contextDevice.device));\n+    std::cout << \"> GPU Device has major=\" << major << \" minor=\" << minor << \" compute capability\" << std::endl;\n@@ -60,3 +63,3 @@\n-   int warpSize;\n-   checkCudaErrors(cuDeviceGetAttribute(&warpSize, CU_DEVICE_ATTRIBUTE_WARP_SIZE, contextDevice.device));\n-   std::cout << \"> GPU Device has warpSize \"<< warpSize << std::endl;\n+    int warpSize;\n+    checkCudaErrors(cuDeviceGetAttribute(&warpSize, CU_DEVICE_ATTRIBUTE_WARP_SIZE, contextDevice.device));\n+    std::cout << \"> GPU Device has warpSize \" << warpSize << std::endl;\n@@ -64,3 +67,3 @@\n-   int threadsPerBlock;\n-   checkCudaErrors(cuDeviceGetAttribute(&threadsPerBlock, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, contextDevice.device));\n-   std::cout << \"> GPU Device has threadsPerBlock \"<< threadsPerBlock << std::endl;\n+    int threadsPerBlock;\n+    checkCudaErrors(cuDeviceGetAttribute(&threadsPerBlock, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, contextDevice.device));\n+    std::cout << \"> GPU Device has threadsPerBlock \" << threadsPerBlock << std::endl;\n@@ -68,3 +71,3 @@\n-   int cores;\n-   checkCudaErrors(cuDeviceGetAttribute(&cores, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, contextDevice.device));\n-   std::cout << \"> GPU Cores \"<< cores << std::endl;\n+    int cores;\n+    checkCudaErrors(cuDeviceGetAttribute(&cores, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, contextDevice.device));\n+    std::cout << \"> GPU Cores \" << cores << std::endl;\n@@ -72,5 +75,5 @@\n-   size_t     totalGlobalMem;\n-   checkCudaErrors( cuDeviceTotalMem(&totalGlobalMem, contextDevice.device) );\n-   std::cout << \"  Total amount of global memory:   \"<< (unsigned long long)totalGlobalMem << std::endl;\n-   std::cout << \"  64-bit Memory Address:           \" <<\n-      ((totalGlobalMem > (unsigned long long)4*1024*1024*1024L)?  \"YES\" : \"NO\") << std::endl;\n+    size_t totalGlobalMem;\n+    checkCudaErrors(cuDeviceTotalMem(&totalGlobalMem, contextDevice.device));\n+    std::cout << \"  Total amount of global memory:   \" << (unsigned long long) totalGlobalMem << std::endl;\n+    std::cout << \"  64-bit Memory Address:           \" <<\n+              ((totalGlobalMem > (unsigned long long) 4 * 1024 * 1024 * 1024L) ? \"YES\" : \"NO\") << std::endl;\n","filename":"hat\/backends\/cuda\/cpp\/info.cpp","additions":45,"deletions":42,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+\n@@ -27,52 +28,57 @@\n-struct Ptx{\n-   size_t len;\n-   char *text;\n-   Ptx(size_t len):len(len), text(len>0?new char[len]:nullptr){}\n-   Ptx(){\n-      if (len>0 && text != nullptr){\n-         delete[] text;\n-      }\n-   }\n-   static Ptx *nvcc(const char *cudaSource, size_t len){\n-      Ptx *ptx = nullptr;\n-      const char *cudaPath=\".\/tmp2.cu\";\n-      const char *ptxPath=\".\/tmp2.ptx\";\n-      const char *stderrPath=\".\/tmp2.stderr\";\n-      const char *stdoutPath=\".\/tmp2.stdout\";\n-      \/\/ we are going to fork exec nvcc\n-      int pid;\n-      if ((pid = fork()) ==  0){\n-         std::ofstream cuda;\n-         cuda.open(cudaPath);\n-         cuda.write(cudaSource, len);\n-         cuda.close();\n-\n-         const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n-         \/\/ const char *argv[]{\"nvcc\", \"-v\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n-         const char *argv[]{\"nvcc\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n-         \/\/ We are the child so exec nvcc.\n-         \/\/close(1); \/\/ stdout\n-         \/\/close(2); \/\/ stderr\n-         \/\/open(stderrPath, O_RDWR); \/\/ stdout\n-         \/\/open(stdoutPath, O_RDWR); \/\/ stderr\n-         execvp(path, (char* const *)argv);\n-      }else if (pid <0) {\n-         \/\/ fork failed.\n-         std::cerr << \"fork of nvcc failed\" << std::endl;\n-         std::exit(1);\n-      }else{\n-         std::cerr << \"fork suceeded\" << std::endl;\n-         std::ifstream ptxStream(ptxPath);\n-         ptxStream.seekg(0, ptxStream.end);\n-         size_t ptxLen = ptxStream.tellg();\n-         if (ptxLen > 0) {\n-            ptx = new Ptx(ptxLen+1);\n-            ptxStream.seekg(0, ptxStream.beg);\n-            ptxStream.read(ptx->text, ptx->len);\n-            ptx->text[ptx->len]='\\0';\n-         }\n-         ptxStream.close();\n-      }\n-      std::cout<< \"returning PTX\"<<std::endl;\n-      return ptx;\n-   }\n+\n+struct Ptx {\n+    size_t len;\n+    char *text;\n+\n+    Ptx(size_t len)\n+            : len(len), text(len > 0 ? new char[len] : nullptr) {}\n+\n+    Ptx() {\n+        if (len > 0 && text != nullptr) {\n+            delete[] text;\n+        }\n+    }\n+\n+    static Ptx *nvcc(const char *cudaSource, size_t len) {\n+        Ptx *ptx = nullptr;\n+        const char *cudaPath = \".\/tmp2.cu\";\n+        const char *ptxPath = \".\/tmp2.ptx\";\n+        const char *stderrPath = \".\/tmp2.stderr\";\n+        const char *stdoutPath = \".\/tmp2.stdout\";\n+        \/\/ we are going to fork exec nvcc\n+        int pid;\n+        if ((pid = fork()) == 0) {\n+            std::ofstream cuda;\n+            cuda.open(cudaPath);\n+            cuda.write(cudaSource, len);\n+            cuda.close();\n+\n+            const char *path = \"\/usr\/local\/cuda-12.2\/bin\/nvcc\";\n+            \/\/ const char *argv[]{\"nvcc\", \"-v\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n+            const char *argv[]{\"nvcc\", \"-ptx\", cudaPath, \"-o\", ptxPath, nullptr};\n+            \/\/ We are the child so exec nvcc.\n+            \/\/close(1); \/\/ stdout\n+            \/\/close(2); \/\/ stderr\n+            \/\/open(stderrPath, O_RDWR); \/\/ stdout\n+            \/\/open(stdoutPath, O_RDWR); \/\/ stderr\n+            execvp(path, (char *const *) argv);\n+        } else if (pid < 0) {\n+            \/\/ fork failed.\n+            std::cerr << \"fork of nvcc failed\" << std::endl;\n+            std::exit(1);\n+        } else {\n+            std::cerr << \"fork suceeded\" << std::endl;\n+            std::ifstream ptxStream(ptxPath);\n+            ptxStream.seekg(0, ptxStream.end);\n+            size_t ptxLen = ptxStream.tellg();\n+            if (ptxLen > 0) {\n+                ptx = new Ptx(ptxLen + 1);\n+                ptxStream.seekg(0, ptxStream.beg);\n+                ptxStream.read(ptx->text, ptx->len);\n+                ptx->text[ptx->len] = '\\0';\n+            }\n+            ptxStream.close();\n+        }\n+        std::cout << \"returning PTX\" << std::endl;\n+        return ptx;\n+    }\n@@ -80,15 +86,19 @@\n-class CudaBackend: public Backend{\n-   public:\n-      class CudaConfig: public Backend::Config{\n-         public:\n-            boolean gpu;\n-      };\n-      class CudaProgram : public Backend::Program{\n-         class CudaKernel : public Backend::Program::Kernel{\n-            class CudaBuffer{\n-               public:\n-                  void *ptr;\n-                  size_t sizeInBytes;\n-                  CUdeviceptr devicePtr;\n-                  CudaBuffer(void *ptr, size_t sizeInBytes);\n-                  virtual ~CudaBuffer();\n+\n+class CudaBackend : public Backend {\n+public:\n+    class CudaConfig : public Backend::Config {\n+    public:\n+        boolean gpu;\n+    };\n+\n+    class CudaProgram : public Backend::Program {\n+        class CudaKernel : public Backend::Program::Kernel {\n+            class CudaBuffer {\n+            public:\n+                void *ptr;\n+                size_t sizeInBytes;\n+                CUdeviceptr devicePtr;\n+\n+                CudaBuffer(void *ptr, size_t sizeInBytes);\n+\n+                virtual ~CudaBuffer();\n@@ -96,1 +106,2 @@\n-            private:\n+\n+        private:\n@@ -98,2 +109,3 @@\n-            public:\n-            CudaKernel(Backend::Program *program,  CUfunction function);\n+        public:\n+            CudaKernel(Backend::Program *program, CUfunction function);\n+\n@@ -101,25 +113,32 @@\n-            long ndrange( int range, void *argArray);\n-         };\n-\n-         private:\n-         CUmodule module;\n-         Ptx *ptx;\n-\n-         public:\n-         CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx,  CUmodule module);\n-         ~CudaProgram();\n-         long getKernel(int nameLen, char *name);\n-         bool programOK();\n-      };\n-   private:\n-      CUdevice device;\n-      CUcontext context;\n-   public:\n-\n-      CudaBackend(CudaConfig *config, int configSchemaLen, char *configSchema);\n-\n-      ~CudaBackend();\n-      int getMaxComputeUnits();\n-\n-      void info();\n-      long compileProgram(int len, char *source);\n+\n+            long ndrange(int range, void *argArray);\n+        };\n+\n+    private:\n+        CUmodule module;\n+        Ptx *ptx;\n+\n+    public:\n+        CudaProgram(Backend *backend, BuildInfo *buildInfo, Ptx *ptx, CUmodule module);\n+\n+        ~CudaProgram();\n+\n+        long getKernel(int nameLen, char *name);\n+\n+        bool programOK();\n+    };\n+\n+private:\n+    CUdevice device;\n+    CUcontext context;\n+public:\n+\n+    CudaBackend(CudaConfig *config, int configSchemaLen, char *configSchema);\n+\n+    ~CudaBackend();\n+\n+    int getMaxComputeUnits();\n+\n+    void info();\n+\n+    long compileProgram(int len, char *source);\n","filename":"hat\/backends\/cuda\/include\/cuda_backend.h","additions":114,"deletions":95,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\n@@ -52,0 +53,1 @@\n+\n@@ -55,0 +57,1 @@\n+\n@@ -56,0 +59,1 @@\n+\n@@ -61,1 +65,2 @@\n-extern  void __checkCudaErrors( CUresult err, const char *file, const int line );\n+\n+extern void __checkCudaErrors(CUresult err, const char *file, const int line);\n","filename":"hat\/backends\/cuda\/include\/cuda_shared.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-int main(){\n+int main() {\n@@ -29,1 +29,1 @@\n-   std::cout << \"inside MOCK info\" << std::endl;\n+    std::cout << \"inside MOCK info\" << std::endl;\n","filename":"hat\/backends\/mock\/cpp\/info.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,23 +27,31 @@\n-class MockBackend: public Backend{\n-   public:\n-      class MockConfig: public Backend::Config{\n-         public :\n-      };\n-      class MockProgram : public Backend::Program{\n-         class MockKernel : public Backend::Program::Kernel{\n-            public:\n-               MockKernel(Backend::Program *program):Backend::Program::Kernel(program){\n-               }\n-               ~MockKernel(){\n-               }\n-               long ndrange( int range, void *argArray) {\n-                  std::cout<<\"mock ndrange(\"<<range<<\") \"<< std::endl;\n-                  return 0;\n-               }\n-         };\n-         public:\n-         MockProgram(Backend *backend, BuildInfo *buildInfo ):Backend::Program(backend, buildInfo){\n-         }\n-         ~MockProgram(){\n-         }\n-         long getKernel(int nameLen, char *name){\n+class MockBackend : public Backend {\n+public:\n+    class MockConfig : public Backend::Config {\n+    public :\n+    };\n+\n+    class MockProgram : public Backend::Program {\n+        class MockKernel : public Backend::Program::Kernel {\n+        public:\n+            MockKernel(Backend::Program *program)\n+                    : Backend::Program::Kernel(program) {\n+            }\n+\n+            ~MockKernel() {\n+            }\n+\n+            long ndrange(int range, void *argArray) {\n+                std::cout << \"mock ndrange(\" << range << \") \" << std::endl;\n+                return 0;\n+            }\n+        };\n+\n+    public:\n+        MockProgram(Backend *backend, BuildInfo *buildInfo)\n+                : Backend::Program(backend, buildInfo) {\n+        }\n+\n+        ~MockProgram() {\n+        }\n+\n+        long getKernel(int nameLen, char *name) {\n@@ -51,2 +59,3 @@\n-         }\n-         bool programOK(){\n+        }\n+\n+        bool programOK() {\n@@ -54,2 +63,2 @@\n-         }\n-      };\n+        }\n+    };\n@@ -57,1 +66,1 @@\n-   public:\n+public:\n@@ -59,7 +68,8 @@\n-      MockBackend(MockConfig *mockConfig, int mockConfigSchemeLen, char *mockBackendSchema):Backend(mockConfig,mockConfigSchemeLen,mockBackendSchema) {\n-         if (mockConfig == nullptr){\n-            std::cout << \"mockConfig == null\"<< std::endl;\n-         }else{\n-            std::cout << \"mockConfig != null\" <<std::endl;\n-         }\n-      }\n+    MockBackend(MockConfig *mockConfig, int mockConfigSchemeLen, char *mockBackendSchema)\n+            : Backend(mockConfig, mockConfigSchemeLen, mockBackendSchema) {\n+        if (mockConfig == nullptr) {\n+            std::cout << \"mockConfig == null\" << std::endl;\n+        } else {\n+            std::cout << \"mockConfig != null\" << std::endl;\n+        }\n+    }\n@@ -67,2 +77,2 @@\n-      ~MockBackend() {\n-      }\n+    ~MockBackend() {\n+    }\n@@ -70,4 +80,4 @@\n-      int getMaxComputeUnits(){\n-         std::cout << \"mock getMaxComputeUnits()\"<<std::endl;\n-         return 0;\n-      }\n+    int getMaxComputeUnits() {\n+        std::cout << \"mock getMaxComputeUnits()\" << std::endl;\n+        return 0;\n+    }\n@@ -75,3 +85,3 @@\n-      void info(){\n-         std::cout << \"mock info()\"<<std::endl;\n-      }\n+    void info() {\n+        std::cout << \"mock info()\" << std::endl;\n+    }\n@@ -79,9 +89,9 @@\n-      long compileProgram(int len, char *source){\n-         std::cout << \"mock compileProgram()\"<<std::endl;\n-         size_t srcLen = ::strlen(source);\n-         char *src = new char[srcLen + 1];\n-         ::strncpy(src, source, srcLen);\n-         src[srcLen] = '\\0';\n-         std::cout << \"native compiling \" << src << std::endl;\n-         return (long) new MockProgram(this, new BuildInfo(src, nullptr,false));\n-      }\n+    long compileProgram(int len, char *source) {\n+        std::cout << \"mock compileProgram()\" << std::endl;\n+        size_t srcLen = ::strlen(source);\n+        char *src = new char[srcLen + 1];\n+        ::strncpy(src, source, srcLen);\n+        src[srcLen] = '\\0';\n+        std::cout << \"native compiling \" << src << std::endl;\n+        return (long) new MockProgram(this, new BuildInfo(src, nullptr, false));\n+    }\n@@ -90,3 +100,3 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema){\n-   MockBackend::MockConfig *mockConfig = (MockBackend::MockConfig*)config;\n-   return (long)new MockBackend(mockConfig,configSchemaLen,configSchema);\n+long getBackend(void *config, int configSchemaLen, char *configSchema) {\n+    MockBackend::MockConfig *mockConfig = (MockBackend::MockConfig *) config;\n+    return (long) new MockBackend(mockConfig, configSchemaLen, configSchema);\n","filename":"hat\/backends\/mock\/cpp\/mock_backend.cpp","additions":66,"deletions":56,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"opencl_shared.h\"\n+#include \"opencl_backend.h\"\n@@ -27,126 +27,0 @@\n-void info() {\n-   cl_int status = CL_SUCCESS;\n-   cl_uint platformc;\n-\n-   status = clGetPlatformIDs(0, NULL, &platformc);\n-   if (status != CL_SUCCESS) {\n-      fprintf(stderr, \"clGetPlatformIDs(0,NULL,&platformc) failed!\\n%s\\n\", error(status));\n-      exit(1);\n-   }\n-   fprintf(stderr, \"There %s %d platform%s\\n\", ((platformc == 1) ? \"is\" : \"are\"), platformc, ((platformc == 1) ? \"\" : \"s\"));\n-   cl_platform_id *platformIds = new cl_platform_id[platformc];\n-   status = clGetPlatformIDs(platformc, platformIds, NULL);\n-   if (status != CL_SUCCESS) {\n-      fprintf(stderr, \"clGetPlatformIDs(platformc,platformIds,NULL) failed!\\n%s\\n\", error(status));\n-      exit(1);\n-   }\n-   for (unsigned platformIdx = 0; platformIdx < platformc; ++platformIdx) {\n-      fprintf(stderr, \"platform %d{\\n\", platformIdx);\n-      char platformVersionName[512];\n-      status = clGetPlatformInfo(platformIds[platformIdx], CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName, NULL);\n-\n-      char platformVendorName[512];\n-      char platformName[512];\n-      status = clGetPlatformInfo(platformIds[platformIdx], CL_PLATFORM_VENDOR, sizeof(platformVendorName), platformVendorName, NULL);\n-      status = clGetPlatformInfo(platformIds[platformIdx], CL_PLATFORM_NAME, sizeof(platformName), platformName, NULL);\n-      fprintf(stderr, \"   CL_PLATFORM_VENDOR..\\\"%s\\\"\\n\", platformVendorName);\n-      fprintf(stderr, \"   CL_PLATFORM_VERSION.\\\"%s\\\"\\n\", platformVersionName);\n-      fprintf(stderr, \"   CL_PLATFORM_NAME....\\\"%s\\\"\\n\", platformName);\n-      cl_uint deviceIdc;\n-      cl_device_type requestedDeviceType = CL_DEVICE_TYPE_CPU | CL_DEVICE_TYPE_GPU;\n-      status = clGetDeviceIDs(platformIds[platformIdx], requestedDeviceType, 0, NULL, &deviceIdc);\n-      fprintf(stderr, \"   Platform %d has %d device%s{\\n\", platformIdx, deviceIdc, ((deviceIdc == 1) ? \"\" : \"s\"));\n-      if (status == CL_SUCCESS && deviceIdc > 0) {\n-         cl_device_id *deviceIds = new cl_device_id[deviceIdc];\n-         status = clGetDeviceIDs(platformIds[platformIdx], requestedDeviceType, deviceIdc, deviceIds, NULL);\n-         if (status == CL_SUCCESS) {\n-            for (unsigned deviceIdx = 0; deviceIdx < deviceIdc; deviceIdx++) {\n-               fprintf(stderr, \"      Device %d{\\n\", deviceIdx);\n-\n-               cl_device_type deviceType;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_TYPE..................... \");\n-               if (deviceType & CL_DEVICE_TYPE_DEFAULT) {\n-                  deviceType &= ~CL_DEVICE_TYPE_DEFAULT;\n-                  fprintf(stderr, \"Default \");\n-               }\n-               if (deviceType & CL_DEVICE_TYPE_CPU) {\n-                  deviceType &= ~CL_DEVICE_TYPE_CPU;\n-                  fprintf(stderr, \"CPU \");\n-               }\n-               if (deviceType & CL_DEVICE_TYPE_GPU) {\n-                  deviceType &= ~CL_DEVICE_TYPE_GPU;\n-                  fprintf(stderr, \"GPU \");\n-               }\n-               if (deviceType & CL_DEVICE_TYPE_ACCELERATOR) {\n-                  deviceType &= ~CL_DEVICE_TYPE_ACCELERATOR;\n-                  fprintf(stderr, \"Accelerator \");\n-               }\n-               fprintf(stderr, LongHexNewline, deviceType);\n-\n-               cl_uint maxComputeUnits;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(maxComputeUnits), &maxComputeUnits, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_MAX_COMPUTE_UNITS........ %u\\n\", maxComputeUnits);\n-\n-               cl_uint maxWorkItemDimensions;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions), &maxWorkItemDimensions, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. %u\\n\", maxWorkItemDimensions);\n-\n-               size_t *maxWorkItemSizes = new size_t[maxWorkItemDimensions];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n-               for (unsigned dimIdx = 0; dimIdx < maxWorkItemDimensions; dimIdx++) {\n-                  fprintf(stderr, \"             dim[%d] = %ld\\n\", dimIdx, maxWorkItemSizes[dimIdx]);\n-               }\n-\n-               size_t maxWorkGroupSize;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \" Size_tNewline, maxWorkGroupSize);\n-\n-               cl_ulong maxMemAllocSize;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(maxMemAllocSize), &maxMemAllocSize, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \" LongUnsignedNewline, maxMemAllocSize);\n-\n-               cl_ulong globalMemSize;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(globalMemSize), &globalMemSize, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \" LongUnsignedNewline, globalMemSize);\n-\n-               cl_ulong localMemSize;\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(localMemSize), &localMemSize, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_LOCAL_MEM_SIZE........... \" LongUnsignedNewline, localMemSize);\n-\n-\n-               char profile[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_PROFILE, sizeof(profile), &profile, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_PROFILE.................. %s\\n\", profile);\n-\n-               char deviceVersion[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_VERSION, sizeof(deviceVersion), &deviceVersion, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_VERSION.................. %s\\n\", deviceVersion);\n-\n-               char driverVersion[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DRIVER_VERSION, sizeof(driverVersion), &driverVersion, NULL);\n-               fprintf(stderr, \"         CL_DRIVER_VERSION.................. %s\\n\", driverVersion);\n-\n-               char cVersion[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_OPENCL_C_VERSION, sizeof(cVersion), &cVersion, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_OPENCL_C_VERSION......... %s\\n\", cVersion);\n-\n-               char name[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_NAME, sizeof(name), &name, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_NAME..................... %s\\n\", name);\n-               char extensions[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_EXTENSIONS, sizeof(extensions), &extensions, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_EXTENSIONS............... %s\\n\", extensions);\n-               char builtInKernels[2048];\n-               status = clGetDeviceInfo(deviceIds[deviceIdx], CL_DEVICE_BUILT_IN_KERNELS, sizeof(builtInKernels), &builtInKernels, NULL);\n-               fprintf(stderr, \"         CL_DEVICE_BUILT_IN_KERNELS......... %s\\n\", builtInKernels);\n-\n-               fprintf(stderr, \"      }\\n\");\n-            }\n-\n-         }\n-         fprintf(stderr, \"   }\\n\");\n-      }\n-      fprintf(stderr, \"}\\n\");\n-   }\n-}\n@@ -154,1 +28,2 @@\n-   info();\n+    OpenCLBackend backend;\n+    backend.info();\n","filename":"hat\/backends\/opencl\/cpp\/info.cpp","additions":3,"deletions":128,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -28,4 +28,5 @@\n-   : ptr(ptr),  sizeInBytes(sizeInBytes) {\n-      cl_int status;\n-      clMem = clCreateBuffer(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeInBytes, ptr, &status);\n-   }\n+        : ptr(ptr), sizeInBytes(sizeInBytes) {\n+    cl_int status;\n+    clMem = clCreateBuffer(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeInBytes, ptr, &status);\n+}\n+\n@@ -33,1 +34,1 @@\n-   clReleaseMemObject(clMem);\n+    clReleaseMemObject(clMem);\n@@ -36,1 +37,2 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLKernel(Backend::Program *program, cl_kernel kernel):Backend::Program::Kernel(program), kernel(kernel){\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::OpenCLKernel(Backend::Program *program, cl_kernel kernel)\n+        : Backend::Program::Kernel(program), kernel(kernel) {\n@@ -38,2 +40,3 @@\n-OpenCLBackend::OpenCLProgram::OpenCLKernel::~OpenCLKernel(){\n-   clReleaseKernel(kernel);\n+\n+OpenCLBackend::OpenCLProgram::OpenCLKernel::~OpenCLKernel() {\n+    clReleaseKernel(kernel);\n@@ -41,46 +44,47 @@\n-long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange( int range, void *argArray) {\n-   \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n-   ArgSled argSled((ArgArray_t*)argArray);\n-   cl_int status;\n-   OpenCLBackend *backend = (OpenCLBackend*)program->backend;\n-\n-   bool verbose = false;\n-\n-   \/\/ std::cout << \"allocing events \"<< ((argSled.argc()*3)+1)<< std::endl;\n-\n-   backend->allocEvents(argSled.argc() * 3 + 1);\n-\n-   for (int i = 0; i < argSled.argc(); i++) {\n-      Arg_t *arg = argSled.arg(i);\n-\n-      if (arg->variant == '&'){\n-         arg->value.buffer.vendorPtr =new OpenCLBuffer(backend->context,\n-               (void*)arg->value.buffer.memorySegment,\n-               (size_t)arg->value.buffer.sizeInBytes);\n-         OpenCLBuffer *clbuf = ((OpenCLBuffer*)arg->value.buffer.vendorPtr);\n-         if ((status = clEnqueueWriteBuffer(backend->command_queue, clbuf->clMem, CL_FALSE, 0, clbuf->sizeInBytes, clbuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n-                     &(backend->events[backend->eventc]))) !=\n-               CL_SUCCESS) {\n-            std::cerr << \"write failed!\" << error(status) << std::endl;\n-         }\n-         backend->eventc++;\n-         clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &((OpenCLBuffer*)arg->value.buffer.vendorPtr)->clMem);\n-\n-      } else if (arg->variant == 'I') {\n-         clSetKernelArg(kernel, arg->idx, sizeof(arg->value.s32), (void *) &arg->value.s32);\n-      } else if (arg->variant == 'F') {\n-         clSetKernelArg(kernel, arg->idx, sizeof(arg->value.f32), (void *) &arg->value.f32);\n-      }\n-   }\n-   size_t globalSize = range;\n-   size_t dims = 1;\n-   if ((status = clEnqueueNDRangeKernel(\n-               backend->command_queue,\n-               kernel,\n-               dims,\n-               nullptr,\n-               &globalSize,\n-               nullptr,\n-               backend->eventc,\n-               ((backend->eventc == 0) ? nullptr : backend->events),\n-               &(backend->events[backend->eventc]))) != CL_SUCCESS) {\n+\n+long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange(int range, void *argArray) {\n+    \/\/std::cout<<\"ndrange(\"<<range<<\") \"<< std::endl;\n+    ArgSled argSled((ArgArray_t *) argArray);\n+    cl_int status;\n+    OpenCLBackend *backend = (OpenCLBackend *) program->backend;\n+\n+    bool verbose = false;\n+\n+    \/\/ std::cout << \"allocing events \"<< ((argSled.argc()*3)+1)<< std::endl;\n+\n+    backend->allocEvents(argSled.argc() * 3 + 1);\n+\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n+\n+        if (arg->variant == '&') {\n+            arg->value.buffer.vendorPtr = new OpenCLBuffer(backend->context,\n+                    (void *) arg->value.buffer.memorySegment,\n+                    (size_t) arg->value.buffer.sizeInBytes);\n+            OpenCLBuffer *clbuf = ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n+            if ((status = clEnqueueWriteBuffer(backend->command_queue, clbuf->clMem, CL_FALSE, 0, clbuf->sizeInBytes, clbuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n+                    &(backend->events[backend->eventc]))) !=\n+                CL_SUCCESS) {\n+                std::cerr << \"write failed!\" << errorMsg(status) << std::endl;\n+            }\n+            backend->eventc++;\n+            clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &((OpenCLBuffer *) arg->value.buffer.vendorPtr)->clMem);\n+\n+        } else if (arg->variant == 'I') {\n+            clSetKernelArg(kernel, arg->idx, sizeof(arg->value.s32), (void *) &arg->value.s32);\n+        } else if (arg->variant == 'F') {\n+            clSetKernelArg(kernel, arg->idx, sizeof(arg->value.f32), (void *) &arg->value.f32);\n+        }\n+    }\n+    size_t globalSize = range;\n+    size_t dims = 1;\n+    if ((status = clEnqueueNDRangeKernel(\n+            backend->command_queue,\n+            kernel,\n+            dims,\n+            nullptr,\n+            &globalSize,\n+            nullptr,\n+            backend->eventc,\n+            ((backend->eventc == 0) ? nullptr : backend->events),\n+            &(backend->events[backend->eventc]))) != CL_SUCCESS) {\n@@ -88,1 +92,1 @@\n-      std::cout <<  \" globalSize=\" << globalSize << \" \" << error(status) << std::endl;\n+        std::cout <<  \" globalSize=\" << globalSize << \" \" << error(status) << std::endl;\n@@ -90,25 +94,25 @@\n-   }\n-   backend->eventc++;\n-   for (int i = 0; i < argSled.argc(); i++) {\n-      Arg_t *arg = argSled.arg(i);\n-\n-      if (arg->variant=='&'){\n-         OpenCLBuffer *clBuf = ((OpenCLBuffer*)arg->value.buffer.vendorPtr);\n-         if ((status = clEnqueueReadBuffer(backend->command_queue, clBuf->clMem, CL_FALSE, 0,\n-                     clBuf->sizeInBytes, clBuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n-                     &(backend->events[backend->eventc]))) !=\n-               CL_SUCCESS) {\n-            std::cout << \"read failed!\";\n-         }\n-         backend->eventc++;\n-      }\n-   }\n-   backend->waitForEvents();\n-   for (int i = 0; i < argSled.argc(); i++) {\n-      Arg_t *arg = argSled.arg(i);\n-      if (arg->variant == '&') {\n-         delete ((OpenCLBuffer*)arg->value.buffer.vendorPtr);\n-      }\n-   }\n-   backend->releaseEvents();\n-   return 0;\n+    }\n+    backend->eventc++;\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n+\n+        if (arg->variant == '&') {\n+            OpenCLBuffer *clBuf = ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n+            if ((status = clEnqueueReadBuffer(backend->command_queue, clBuf->clMem, CL_FALSE, 0,\n+                    clBuf->sizeInBytes, clBuf->ptr, backend->eventc, ((backend->eventc == 0) ? NULL : backend->events),\n+                    &(backend->events[backend->eventc]))) !=\n+                CL_SUCCESS) {\n+                std::cout << \"read failed!\";\n+            }\n+            backend->eventc++;\n+        }\n+    }\n+    backend->waitForEvents();\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_t *arg = argSled.arg(i);\n+        if (arg->variant == '&') {\n+            delete ((OpenCLBuffer *) arg->value.buffer.vendorPtr);\n+        }\n+    }\n+    backend->releaseEvents();\n+    return 0;\n@@ -118,1 +122,2 @@\n-OpenCLBackend::OpenCLProgram::OpenCLProgram(Backend *backend, BuildInfo *buildInfo,cl_program program):Backend::Program(backend, buildInfo), program(program){\n+OpenCLBackend::OpenCLProgram::OpenCLProgram(Backend *backend, BuildInfo *buildInfo, cl_program program)\n+        : Backend::Program(backend, buildInfo), program(program) {\n@@ -120,2 +125,3 @@\n-OpenCLBackend::OpenCLProgram::~OpenCLProgram(){\n-   clReleaseProgram(program);\n+\n+OpenCLBackend::OpenCLProgram::~OpenCLProgram() {\n+    clReleaseProgram(program);\n@@ -123,4 +129,5 @@\n-long OpenCLBackend::OpenCLProgram::getKernel(int nameLen, char *name){\n-   cl_int status;\n-   cl_kernel kernel = clCreateKernel(program, name, &status);\n-   return (long) new OpenCLKernel(this, kernel);\n+\n+long OpenCLBackend::OpenCLProgram::getKernel(int nameLen, char *name) {\n+    cl_int status;\n+    cl_kernel kernel = clCreateKernel(program, name, &status);\n+    return (long) new OpenCLKernel(this, kernel);\n@@ -128,2 +135,3 @@\n-bool OpenCLBackend::OpenCLProgram::programOK(){\n-   return true;\n+\n+bool OpenCLBackend::OpenCLProgram::programOK() {\n+    return true;\n@@ -131,0 +139,1 @@\n+\n@@ -132,24 +141,24 @@\n-   :Backend((Backend::Config*)openclConfig, configSchemaLen, configSchema), eventMax(0), events(nullptr), eventc(0) {\n-\n-      if (openclConfig == nullptr){\n-         std::cout << \"openclConfig == null\"<< std::endl;\n-      }else{\n-         std::cout << \"openclConfig->gpu\" <<(openclConfig->gpu?\"true\":\"false\")<< std::endl;\n-         std::cout << \"openclConfig->schema\" <<configSchema<< std::endl;\n-      }\n-      cl_device_type requestedType = openclConfig==nullptr?CL_DEVICE_TYPE_GPU:openclConfig->gpu?CL_DEVICE_TYPE_GPU:CL_DEVICE_TYPE_CPU;\n-\n-      cl_int status;\n-      cl_uint platformc = 0;\n-      if ((status = clGetPlatformIDs(0, NULL, &platformc)) != CL_SUCCESS) {\n-         return;\n-      }\n-      cl_platform_id *platforms = new cl_platform_id[platformc];\n-      if ((status = clGetPlatformIDs(platformc, platforms, NULL)) != CL_SUCCESS) {\n-         return;\n-      }\n-\n-      cl_uint devicec = 0;\n-      for (unsigned int i = 0; devicec == 0 && i < platformc; ++i) {\n-         platform_id = platforms[i];\n-         if ((status = clGetDeviceIDs(platform_id, requestedType, 0, NULL, &devicec)) != CL_SUCCESS) {\n+        : Backend((Backend::Config *) openclConfig, configSchemaLen, configSchema), eventMax(0), events(nullptr), eventc(0) {\n+\n+    if (openclConfig == nullptr) {\n+        std::cout << \"openclConfig == null\" << std::endl;\n+    } else {\n+        std::cout << \"openclConfig->gpu\" << (openclConfig->gpu ? \"true\" : \"false\") << std::endl;\n+        std::cout << \"openclConfig->schema\" << configSchema << std::endl;\n+    }\n+    cl_device_type requestedType = openclConfig == nullptr ? CL_DEVICE_TYPE_GPU : openclConfig->gpu ? CL_DEVICE_TYPE_GPU : CL_DEVICE_TYPE_CPU;\n+\n+    cl_int status;\n+    cl_uint platformc = 0;\n+    if ((status = clGetPlatformIDs(0, NULL, &platformc)) != CL_SUCCESS) {\n+        return;\n+    }\n+    cl_platform_id *platforms = new cl_platform_id[platformc];\n+    if ((status = clGetPlatformIDs(platformc, platforms, NULL)) != CL_SUCCESS) {\n+        return;\n+    }\n+\n+    cl_uint devicec = 0;\n+    for (unsigned int i = 0; devicec == 0 && i < platformc; ++i) {\n+        platform_id = platforms[i];\n+        if ((status = clGetDeviceIDs(platform_id, requestedType, 0, NULL, &devicec)) != CL_SUCCESS) {\n@@ -158,34 +167,39 @@\n-         }\n-      }\n-      if (devicec == 0) {\n-         status = CL_DEVICE_NOT_AVAILABLE;\n-         return;\n-      }\n-      cl_device_id *device_ids = new cl_device_id[devicec];             \/\/ compute device id\n-      if ((status = clGetDeviceIDs(platform_id, requestedType, devicec, device_ids, NULL)) != CL_SUCCESS) {\n-         delete[] platforms;\n-         delete[] device_ids;\n-         return;\n-      }\n-      if ((context = clCreateContext(0, 1, device_ids, NULL, NULL, &status)) == NULL || status != CL_SUCCESS) {\n-         delete[] platforms;\n-         delete[] device_ids;\n-         return;\n-      }\n-\n-      cl_command_queue_properties queue_props = CL_QUEUE_PROFILING_ENABLE;\n-\n-      if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL || status != CL_SUCCESS) {\n-         clReleaseContext(context);\n-         delete[] platforms;\n-         delete[] device_ids;\n-         return;\n-      }\n-      device_id = device_ids[0];\n-      delete[] device_ids;\n-      delete[] platforms;\n-   }\n-\n-OpenCLBackend::~OpenCLBackend(){\n-   clReleaseContext(context);\n-   clReleaseCommandQueue(command_queue);\n+        }\n+    }\n+    if (devicec == 0) {\n+        status = CL_DEVICE_NOT_AVAILABLE;\n+        return;\n+    }\n+    cl_device_id *device_ids = new cl_device_id[devicec];             \/\/ compute device id\n+    if ((status = clGetDeviceIDs(platform_id, requestedType, devicec, device_ids, NULL)) != CL_SUCCESS) {\n+        delete[] platforms;\n+        delete[] device_ids;\n+        return;\n+    }\n+    if ((context = clCreateContext(0, 1, device_ids, NULL, NULL, &status)) == NULL || status != CL_SUCCESS) {\n+        delete[] platforms;\n+        delete[] device_ids;\n+        return;\n+    }\n+\n+    cl_command_queue_properties queue_props = CL_QUEUE_PROFILING_ENABLE;\n+\n+    if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL || status != CL_SUCCESS) {\n+        clReleaseContext(context);\n+        delete[] platforms;\n+        delete[] device_ids;\n+        return;\n+    }\n+    device_id = device_ids[0];\n+    delete[] device_ids;\n+    delete[] platforms;\n+}\n+\n+OpenCLBackend::OpenCLBackend()\n+        : OpenCLBackend(nullptr, 0, nullptr) {\n+\n+}\n+\n+OpenCLBackend::~OpenCLBackend() {\n+    clReleaseContext(context);\n+    clReleaseCommandQueue(command_queue);\n@@ -195,6 +209,6 @@\n-   if (events != nullptr || eventc != 0) {\n-      std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n-   }\n-   eventMax = max;\n-   eventc = 0;\n-   events = new cl_event[eventMax];\n+    if (events != nullptr || eventc != 0) {\n+        std::cerr << \"opencl state issue, we might have leaked events!\" << std::endl;\n+    }\n+    eventMax = max;\n+    eventc = 0;\n+    events = new cl_event[eventMax];\n@@ -204,7 +218,7 @@\n-   for (int i = 0; i < eventc; i++) {\n-      clReleaseEvent(events[i]);\n-   }\n-   delete[] events;\n-   eventMax = 0;\n-   eventc = 0;\n-   events = nullptr;\n+    for (int i = 0; i < eventc; i++) {\n+        clReleaseEvent(events[i]);\n+    }\n+    delete[] events;\n+    eventMax = 0;\n+    eventc = 0;\n+    events = nullptr;\n@@ -214,1 +228,1 @@\n-   clWaitForEvents(eventc, events);\n+    clWaitForEvents(eventc, events);\n@@ -218,30 +232,24 @@\n-   cl_ulong *samples = new cl_ulong[4 * eventc]; \/\/ queued, submit, start, end\n-   int sample = 0;\n-   cl_ulong min;\n-   cl_ulong max;\n-   for (int event = 0; event < eventc; event++) {\n-      for (int type = 0; type < 4; type++) {\n-         cl_profiling_info info;\n-         switch (type) {\n-            case 0:\n-               info = CL_PROFILING_COMMAND_QUEUED;\n-               break;\n-            case 1:\n-               info = CL_PROFILING_COMMAND_SUBMIT;\n-               break;\n-            case 2:\n-               info = CL_PROFILING_COMMAND_START;\n-               break;\n-            case 3:\n-               info = CL_PROFILING_COMMAND_END;\n-               break;\n-         }\n-\n-         if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) != CL_SUCCESS) {\n-            std::cerr << \"failed to get profile info \" << info << std::endl;\n-         }\n-         if (sample == 0) {\n-            min = max = samples[sample];\n-         } else {\n-            if (samples[sample] < min) {\n-               min = samples[sample];\n+    cl_ulong *samples = new cl_ulong[4 * eventc]; \/\/ queued, submit, start, end\n+    int sample = 0;\n+    cl_ulong min;\n+    cl_ulong max;\n+    for (int event = 0; event < eventc; event++) {\n+        for (int type = 0; type < 4; type++) {\n+            cl_profiling_info info;\n+            switch (type) {\n+                case 0:\n+                    info = CL_PROFILING_COMMAND_QUEUED;\n+                    break;\n+                case 1:\n+                    info = CL_PROFILING_COMMAND_SUBMIT;\n+                    break;\n+                case 2:\n+                    info = CL_PROFILING_COMMAND_START;\n+                    break;\n+                case 3:\n+                    info = CL_PROFILING_COMMAND_END;\n+                    break;\n+            }\n+\n+            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) != CL_SUCCESS) {\n+                std::cerr << \"failed to get profile info \" << info << std::endl;\n@@ -249,2 +257,9 @@\n-            if (samples[sample] > max) {\n-               max = samples[sample];\n+            if (sample == 0) {\n+                min = max = samples[sample];\n+            } else {\n+                if (samples[sample] < min) {\n+                    min = samples[sample];\n+                }\n+                if (samples[sample] > max) {\n+                    max = samples[sample];\n+                }\n@@ -252,27 +267,29 @@\n-         }\n-         sample++;\n-      }\n-   }\n-   sample = 0;\n-   int range = (max - min);\n-   int scale = range \/ width;  \/\/ range per char\n-   std::cout << \"Range: \" << range << \"(ns)\" << std::endl;\n-   std::cout << \"Scale: \" << scale << \" range (ns) per char\" << std::endl;\n-\n-   for (int event = 0; event < eventc; event++) {\n-      cl_ulong queue = (samples[sample++] - min) \/ scale;\n-      cl_ulong submit = (samples[sample++] - min) \/ scale;\n-      cl_ulong start = (samples[sample++] - min) \/ scale;\n-      cl_ulong end = (samples[sample++] - min) \/ scale;\n-      for (int c = 0; c < 80; c++) {\n-         if (c > queue) {\n-            if (c > submit) {\n-               if (c > start) {\n-                  if (c > end) {\n-                     std::cout << \" \";\n-                  } else {\n-                     std::cout << \"=\";\n-                  }\n-               } else {\n-                  std::cout << \"#\";\n-               }\n+            sample++;\n+        }\n+    }\n+    sample = 0;\n+    int range = (max - min);\n+    int scale = range \/ width;  \/\/ range per char\n+    std::cout << \"Range: \" << range << \"(ns)\" << std::endl;\n+    std::cout << \"Scale: \" << scale << \" range (ns) per char\" << std::endl;\n+\n+    for (int event = 0; event < eventc; event++) {\n+        cl_ulong queue = (samples[sample++] - min) \/ scale;\n+        cl_ulong submit = (samples[sample++] - min) \/ scale;\n+        cl_ulong start = (samples[sample++] - min) \/ scale;\n+        cl_ulong end = (samples[sample++] - min) \/ scale;\n+        for (int c = 0; c < 80; c++) {\n+            if (c > queue) {\n+                if (c > submit) {\n+                    if (c > start) {\n+                        if (c > end) {\n+                            std::cout << \" \";\n+                        } else {\n+                            std::cout << \"=\";\n+                        }\n+                    } else {\n+                        std::cout << \"#\";\n+                    }\n+                } else {\n+                    std::cout << \"+\";\n+                }\n@@ -280,1 +297,1 @@\n-               std::cout << \"+\";\n+                std::cout << \" \";\n@@ -282,8 +299,5 @@\n-         } else {\n-            std::cout << \" \";\n-         }\n-      }\n-      std::cout << std::endl;\n-\n-   }\n-   delete[] samples;\n+        }\n+        std::cout << std::endl;\n+\n+    }\n+    delete[] samples;\n@@ -292,5 +306,5 @@\n-int OpenCLBackend::getMaxComputeUnits(){\n-   std::cout << \"getMaxComputeUnits()\"<<std::endl;\n-   cl_uint value;\n-   clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n-   return value;\n+int OpenCLBackend::getMaxComputeUnits() {\n+    std::cout << \"getMaxComputeUnits()\" << std::endl;\n+    cl_uint value;\n+    clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(value), &value, nullptr);\n+    return value;\n@@ -299,92 +313,92 @@\n-void OpenCLBackend::info(){\n-   cl_int status;\n-   fprintf(stderr, \"platform{\\n\");\n-   char platformVersionName[512];\n-   status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName, NULL);\n-   char platformVendorName[512];\n-   char platformName[512];\n-   status = clGetPlatformInfo(platform_id, CL_PLATFORM_VENDOR, sizeof(platformVendorName), platformVendorName, NULL);\n-   status = clGetPlatformInfo(platform_id, CL_PLATFORM_NAME, sizeof(platformName), platformName, NULL);\n-   fprintf(stderr, \"   CL_PLATFORM_VENDOR..\\\"%s\\\"\\n\", platformVendorName);\n-   fprintf(stderr, \"   CL_PLATFORM_VERSION.\\\"%s\\\"\\n\", platformVersionName);\n-   fprintf(stderr, \"   CL_PLATFORM_NAME....\\\"%s\\\"\\n\", platformName);\n-\n-\n-   cl_device_type deviceType;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_TYPE..................... \");\n-   if (deviceType & CL_DEVICE_TYPE_DEFAULT) {\n-      deviceType &= ~CL_DEVICE_TYPE_DEFAULT;\n-      fprintf(stderr, \"Default \");\n-   }\n-   if (deviceType & CL_DEVICE_TYPE_CPU) {\n-      deviceType &= ~CL_DEVICE_TYPE_CPU;\n-      fprintf(stderr, \"CPU \");\n-   }\n-   if (deviceType & CL_DEVICE_TYPE_GPU) {\n-      deviceType &= ~CL_DEVICE_TYPE_GPU;\n-      fprintf(stderr, \"GPU \");\n-   }\n-   if (deviceType & CL_DEVICE_TYPE_ACCELERATOR) {\n-      deviceType &= ~CL_DEVICE_TYPE_ACCELERATOR;\n-      fprintf(stderr, \"Accelerator \");\n-   }\n-   fprintf(stderr, LongHexNewline, deviceType);\n-\n-   cl_uint maxComputeUnits;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(maxComputeUnits), &maxComputeUnits, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_MAX_COMPUTE_UNITS........ %u\\n\", maxComputeUnits);\n-\n-   cl_uint maxWorkItemDimensions;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions), &maxWorkItemDimensions, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. %u\\n\", maxWorkItemDimensions);\n-\n-   size_t *maxWorkItemSizes = new size_t[maxWorkItemDimensions];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n-   for (unsigned dimIdx = 0; dimIdx < maxWorkItemDimensions; dimIdx++) {\n-      fprintf(stderr, \"             dim[%d] = %ld\\n\", dimIdx, maxWorkItemSizes[dimIdx]);\n-   }\n-\n-   size_t maxWorkGroupSize;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \" Size_tNewline, maxWorkGroupSize);\n-\n-   cl_ulong maxMemAllocSize;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(maxMemAllocSize), &maxMemAllocSize, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \" LongUnsignedNewline, maxMemAllocSize);\n-\n-   cl_ulong globalMemSize;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(globalMemSize), &globalMemSize, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \" LongUnsignedNewline, globalMemSize);\n-\n-   cl_ulong localMemSize;\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(localMemSize), &localMemSize, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_LOCAL_MEM_SIZE........... \" LongUnsignedNewline, localMemSize);\n-\n-   char profile[2048];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_PROFILE, sizeof(profile), &profile, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_PROFILE.................. %s\\n\", profile);\n-\n-   char deviceVersion[2048];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_VERSION, sizeof(deviceVersion), &deviceVersion, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_VERSION.................. %s\\n\", deviceVersion);\n-\n-   char driverVersion[2048];\n-   status = clGetDeviceInfo(device_id, CL_DRIVER_VERSION, sizeof(driverVersion), &driverVersion, NULL);\n-   fprintf(stderr, \"         CL_DRIVER_VERSION.................. %s\\n\", driverVersion);\n-\n-   char cVersion[2048];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_OPENCL_C_VERSION, sizeof(cVersion), &cVersion, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_OPENCL_C_VERSION......... %s\\n\", cVersion);\n-\n-   char name[2048];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_NAME, sizeof(name), &name, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_NAME..................... %s\\n\", name);\n-   char extensions[2048];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_EXTENSIONS, sizeof(extensions), &extensions, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_EXTENSIONS............... %s\\n\", extensions);\n-   char builtInKernels[2048];\n-   status = clGetDeviceInfo(device_id, CL_DEVICE_BUILT_IN_KERNELS, sizeof(builtInKernels), &builtInKernels, NULL);\n-   fprintf(stderr, \"         CL_DEVICE_BUILT_IN_KERNELS......... %s\\n\", builtInKernels);\n-\n-   fprintf(stderr, \"      }\\n\");\n+void OpenCLBackend::info() {\n+    cl_int status;\n+    fprintf(stderr, \"platform{\\n\");\n+    char platformVersionName[512];\n+    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VERSION, sizeof(platformVersionName), platformVersionName, NULL);\n+    char platformVendorName[512];\n+    char platformName[512];\n+    status = clGetPlatformInfo(platform_id, CL_PLATFORM_VENDOR, sizeof(platformVendorName), platformVendorName, NULL);\n+    status = clGetPlatformInfo(platform_id, CL_PLATFORM_NAME, sizeof(platformName), platformName, NULL);\n+    fprintf(stderr, \"   CL_PLATFORM_VENDOR..\\\"%s\\\"\\n\", platformVendorName);\n+    fprintf(stderr, \"   CL_PLATFORM_VERSION.\\\"%s\\\"\\n\", platformVersionName);\n+    fprintf(stderr, \"   CL_PLATFORM_NAME....\\\"%s\\\"\\n\", platformName);\n+\n+\n+    cl_device_type deviceType;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_TYPE, sizeof(deviceType), &deviceType, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_TYPE..................... \");\n+    if (deviceType & CL_DEVICE_TYPE_DEFAULT) {\n+        deviceType &= ~CL_DEVICE_TYPE_DEFAULT;\n+        fprintf(stderr, \"Default \");\n+    }\n+    if (deviceType & CL_DEVICE_TYPE_CPU) {\n+        deviceType &= ~CL_DEVICE_TYPE_CPU;\n+        fprintf(stderr, \"CPU \");\n+    }\n+    if (deviceType & CL_DEVICE_TYPE_GPU) {\n+        deviceType &= ~CL_DEVICE_TYPE_GPU;\n+        fprintf(stderr, \"GPU \");\n+    }\n+    if (deviceType & CL_DEVICE_TYPE_ACCELERATOR) {\n+        deviceType &= ~CL_DEVICE_TYPE_ACCELERATOR;\n+        fprintf(stderr, \"Accelerator \");\n+    }\n+    fprintf(stderr, LongHexNewline, deviceType);\n+\n+    cl_uint maxComputeUnits;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(maxComputeUnits), &maxComputeUnits, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_MAX_COMPUTE_UNITS........ %u\\n\", maxComputeUnits);\n+\n+    cl_uint maxWorkItemDimensions;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, sizeof(maxWorkItemDimensions), &maxWorkItemDimensions, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. %u\\n\", maxWorkItemDimensions);\n+\n+    size_t *maxWorkItemSizes = new size_t[maxWorkItemDimensions];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(size_t) * maxWorkItemDimensions, maxWorkItemSizes, NULL);\n+    for (unsigned dimIdx = 0; dimIdx < maxWorkItemDimensions; dimIdx++) {\n+        fprintf(stderr, \"             dim[%d] = %ld\\n\", dimIdx, maxWorkItemSizes[dimIdx]);\n+    }\n+\n+    size_t maxWorkGroupSize;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(maxWorkGroupSize), &maxWorkGroupSize, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_MAX_WORK_GROUP_SIZE...... \" Size_tNewline, maxWorkGroupSize);\n+\n+    cl_ulong maxMemAllocSize;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(maxMemAllocSize), &maxMemAllocSize, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_MAX_MEM_ALLOC_SIZE....... \" LongUnsignedNewline, maxMemAllocSize);\n+\n+    cl_ulong globalMemSize;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(globalMemSize), &globalMemSize, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_GLOBAL_MEM_SIZE.......... \" LongUnsignedNewline, globalMemSize);\n+\n+    cl_ulong localMemSize;\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(localMemSize), &localMemSize, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_LOCAL_MEM_SIZE........... \" LongUnsignedNewline, localMemSize);\n+\n+    char profile[2048];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_PROFILE, sizeof(profile), &profile, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_PROFILE.................. %s\\n\", profile);\n+\n+    char deviceVersion[2048];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_VERSION, sizeof(deviceVersion), &deviceVersion, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_VERSION.................. %s\\n\", deviceVersion);\n+\n+    char driverVersion[2048];\n+    status = clGetDeviceInfo(device_id, CL_DRIVER_VERSION, sizeof(driverVersion), &driverVersion, NULL);\n+    fprintf(stderr, \"         CL_DRIVER_VERSION.................. %s\\n\", driverVersion);\n+\n+    char cVersion[2048];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_OPENCL_C_VERSION, sizeof(cVersion), &cVersion, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_OPENCL_C_VERSION......... %s\\n\", cVersion);\n+\n+    char name[2048];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_NAME, sizeof(name), &name, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_NAME..................... %s\\n\", name);\n+    char extensions[2048];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_EXTENSIONS, sizeof(extensions), &extensions, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_EXTENSIONS............... %s\\n\", extensions);\n+    char builtInKernels[2048];\n+    status = clGetDeviceInfo(device_id, CL_DEVICE_BUILT_IN_KERNELS, sizeof(builtInKernels), &builtInKernels, NULL);\n+    fprintf(stderr, \"         CL_DEVICE_BUILT_IN_KERNELS......... %s\\n\", builtInKernels);\n+\n+    fprintf(stderr, \"      }\\n\");\n@@ -392,37 +406,39 @@\n-long OpenCLBackend::compileProgram(int len, char *source){\n-   size_t srcLen = ::strlen(source);\n-   char *src = new char[srcLen + 1];\n-   ::strncpy(src, source, srcLen);\n-   src[srcLen] = '\\0';\n-   \/\/std::cout << \"native compiling \" << src << std::endl;\n-   cl_int status;\n-   cl_program program;\n-   if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr || status != CL_SUCCESS) {\n-      std::cerr << \"clCreateProgramWithSource failed\" << std::endl;\n-      delete[] src;\n-      return 0;\n-   }\n-\n-   if ((status = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr)) != CL_SUCCESS) {\n-      std::cerr << \"clBuildProgram failed\" << std::endl;\n-      \/\/ dont return we may still be able to get log!\n-   }\n-   size_t logLen = 0;\n-\n-   BuildInfo *buildInfo = nullptr;\n-   if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logLen)) != CL_SUCCESS) {\n-      std::cerr << \"clGetBuildInfo (getting log size) failed\" << std::endl;\n-      buildInfo = new BuildInfo(src,nullptr,true);\n-   } else {\n-      cl_build_status buildStatus;\n-      clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(buildStatus), &buildStatus, nullptr);\n-      if (logLen > 0) {\n-         char *log = new char[logLen + 1];\n-         if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log, nullptr)) != CL_SUCCESS) {\n-            std::cerr << \"clGetBuildInfo (getting log) failed\" << std::endl;\n-            delete[] log;\n-            log = nullptr;\n-         } else {\n-            log[logLen] = '\\0';\n-            if (logLen > 1) {\n-               std::cerr << \"logLen = \" << logLen << \" log  = \" << log << std::endl;\n+\n+long OpenCLBackend::compileProgram(int len, char *source) {\n+    size_t srcLen = ::strlen(source);\n+    char *src = new char[srcLen + 1];\n+    ::strncpy(src, source, srcLen);\n+    src[srcLen] = '\\0';\n+    \/\/std::cout << \"native compiling \" << src << std::endl;\n+    cl_int status;\n+    cl_program program;\n+    if ((program = clCreateProgramWithSource(context, 1, (const char **) &src, nullptr, &status)) == nullptr || status != CL_SUCCESS) {\n+        std::cerr << \"clCreateProgramWithSource failed\" << std::endl;\n+        delete[] src;\n+        return 0;\n+    }\n+\n+    if ((status = clBuildProgram(program, 0, nullptr, nullptr, nullptr, nullptr)) != CL_SUCCESS) {\n+        std::cerr << \"clBuildProgram failed\" << std::endl;\n+        \/\/ dont return we may still be able to get log!\n+    }\n+    size_t logLen = 0;\n+\n+    BuildInfo *buildInfo = nullptr;\n+    if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logLen)) != CL_SUCCESS) {\n+        std::cerr << \"clGetBuildInfo (getting log size) failed\" << std::endl;\n+        buildInfo = new BuildInfo(src, nullptr, true);\n+    } else {\n+        cl_build_status buildStatus;\n+        clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(buildStatus), &buildStatus, nullptr);\n+        if (logLen > 0) {\n+            char *log = new char[logLen + 1];\n+            if ((status = clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, logLen + 1, (void *) log, nullptr)) != CL_SUCCESS) {\n+                std::cerr << \"clGetBuildInfo (getting log) failed\" << std::endl;\n+                delete[] log;\n+                log = nullptr;\n+            } else {\n+                log[logLen] = '\\0';\n+                if (logLen > 1) {\n+                    std::cerr << \"logLen = \" << logLen << \" log  = \" << log << std::endl;\n+                }\n@@ -430,8 +446,7 @@\n-         }\n-         buildInfo = new BuildInfo(src,log,true);\n-      }else{\n-         buildInfo = new BuildInfo(src,nullptr,true);\n-      }\n-   }\n-\n-   return (long) new OpenCLProgram(this, buildInfo, program);\n+            buildInfo = new BuildInfo(src, log, true);\n+        } else {\n+            buildInfo = new BuildInfo(src, nullptr, true);\n+        }\n+    }\n+\n+    return (long) new OpenCLProgram(this, buildInfo, program);\n@@ -440,0 +455,66 @@\n+const char *OpenCLBackend::errorMsg(cl_int status) {\n+    static struct {\n+        cl_int code;\n+        const char *msg;\n+    } error_table[] = {\n+            {CL_SUCCESS,                         \"success\"},\n+            {CL_DEVICE_NOT_FOUND,                \"device not found\",},\n+            {CL_DEVICE_NOT_AVAILABLE,            \"device not available\",},\n+            {CL_COMPILER_NOT_AVAILABLE,          \"compiler not available\",},\n+            {CL_MEM_OBJECT_ALLOCATION_FAILURE,   \"mem object allocation failure\",},\n+            {CL_OUT_OF_RESOURCES,                \"out of resources\",},\n+            {CL_OUT_OF_HOST_MEMORY,              \"out of host memory\",},\n+            {CL_PROFILING_INFO_NOT_AVAILABLE,    \"profiling not available\",},\n+            {CL_MEM_COPY_OVERLAP,                \"memcopy overlaps\",},\n+            {CL_IMAGE_FORMAT_MISMATCH,           \"image format mismatch\",},\n+            {CL_IMAGE_FORMAT_NOT_SUPPORTED,      \"image format not supported\",},\n+            {CL_BUILD_PROGRAM_FAILURE,           \"build program failed\",},\n+            {CL_MAP_FAILURE,                     \"map failed\",},\n+            {CL_INVALID_VALUE,                   \"invalid value\",},\n+            {CL_INVALID_DEVICE_TYPE,             \"invalid device type\",},\n+            {CL_INVALID_PLATFORM,                \"invlaid platform\",},\n+            {CL_INVALID_DEVICE,                  \"invalid device\",},\n+            {CL_INVALID_CONTEXT,                 \"invalid context\",},\n+            {CL_INVALID_QUEUE_PROPERTIES,        \"invalid queue properties\",},\n+            {CL_INVALID_COMMAND_QUEUE,           \"invalid command queue\",},\n+            {CL_INVALID_HOST_PTR,                \"invalid host ptr\",},\n+            {CL_INVALID_MEM_OBJECT,              \"invalid mem object\",},\n+            {CL_INVALID_IMAGE_FORMAT_DESCRIPTOR, \"invalid image format descriptor \",},\n+            {CL_INVALID_IMAGE_SIZE,              \"invalid image size\",},\n+            {CL_INVALID_SAMPLER,                 \"invalid sampler\",},\n+            {CL_INVALID_BINARY,                  \"invalid binary\",},\n+            {CL_INVALID_BUILD_OPTIONS,           \"invalid build options\",},\n+            {CL_INVALID_PROGRAM,                 \"invalid program \",},\n+            {CL_INVALID_PROGRAM_EXECUTABLE,      \"invalid program executable\",},\n+            {CL_INVALID_KERNEL_NAME,             \"invalid kernel name\",},\n+            {CL_INVALID_KERNEL_DEFINITION,       \"invalid definition\",},\n+            {CL_INVALID_KERNEL,                  \"invalid kernel\",},\n+            {CL_INVALID_ARG_INDEX,               \"invalid arg index\",},\n+            {CL_INVALID_ARG_VALUE,               \"invalid arg value\",},\n+            {CL_INVALID_ARG_SIZE,                \"invalid arg size\",},\n+            {CL_INVALID_KERNEL_ARGS,             \"invalid kernel args\",},\n+            {CL_INVALID_WORK_DIMENSION,          \"invalid work dimension\",},\n+            {CL_INVALID_WORK_GROUP_SIZE,         \"invalid work group size\",},\n+            {CL_INVALID_WORK_ITEM_SIZE,          \"invalid work item size\",},\n+            {CL_INVALID_GLOBAL_OFFSET,           \"invalid global offset\",},\n+            {CL_INVALID_EVENT_WAIT_LIST,         \"invalid event wait list\",},\n+            {CL_INVALID_EVENT,                   \"invalid event\",},\n+            {CL_INVALID_OPERATION,               \"invalid operation\",},\n+            {CL_INVALID_GL_OBJECT,               \"invalid gl object\",},\n+            {CL_INVALID_BUFFER_SIZE,             \"invalid buffer size\",},\n+            {CL_INVALID_MIP_LEVEL,               \"invalid mip level\",},\n+            {CL_INVALID_GLOBAL_WORK_SIZE,        \"invalid global work size\",},\n+            {0, NULL},\n+    };\n+    static char unknown[256];\n+    int ii;\n+\n+    for (ii = 0; error_table[ii].msg != NULL; ii++) {\n+        if (error_table[ii].code == status) {\n+\/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n+            return error_table[ii].msg;\n+        }\n+    }\n+    SNPRINTF(unknown, sizeof(unknown), \"unknown error %d\", status);\n+    return unknown;\n+}\n@@ -441,3 +522,0 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema){\n-   \/\/ Dynamic cast?\n-   OpenCLBackend::OpenCLConfig *openclConfig = (OpenCLBackend::OpenCLConfig*)config;\n@@ -445,2 +523,6 @@\n-   return (long)new OpenCLBackend(openclConfig, configSchemaLen, configSchema);\n-}\n+long getBackend(void *config, int configSchemaLen, char *configSchema) {\n+    \/\/ Dynamic cast?\n+    OpenCLBackend::OpenCLConfig *openclConfig = (OpenCLBackend::OpenCLConfig *) config;\n+\n+    return (long) new OpenCLBackend(openclConfig, configSchemaLen, configSchema);\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/opencl\/cpp\/opencl_backend.cpp","additions":458,"deletions":376,"binary":false,"changes":834,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"opencl_shared.h\"\n-#include <cstdio>\n-\n-const char *error(cl_int status) {\n-   static struct {\n-      cl_int code;\n-      const char *msg;\n-   } error_table[] = {\n-      {CL_SUCCESS,                         \"success\"},\n-      {CL_DEVICE_NOT_FOUND,                \"device not found\",},\n-      {CL_DEVICE_NOT_AVAILABLE,            \"device not available\",},\n-      {CL_COMPILER_NOT_AVAILABLE,          \"compiler not available\",},\n-      {CL_MEM_OBJECT_ALLOCATION_FAILURE,   \"mem object allocation failure\",},\n-      {CL_OUT_OF_RESOURCES,                \"out of resources\",},\n-      {CL_OUT_OF_HOST_MEMORY,              \"out of host memory\",},\n-      {CL_PROFILING_INFO_NOT_AVAILABLE,    \"profiling not available\",},\n-      {CL_MEM_COPY_OVERLAP,                \"memcopy overlaps\",},\n-      {CL_IMAGE_FORMAT_MISMATCH,           \"image format mismatch\",},\n-      {CL_IMAGE_FORMAT_NOT_SUPPORTED,      \"image format not supported\",},\n-      {CL_BUILD_PROGRAM_FAILURE,           \"build program failed\",},\n-      {CL_MAP_FAILURE,                     \"map failed\",},\n-      {CL_INVALID_VALUE,                   \"invalid value\",},\n-      {CL_INVALID_DEVICE_TYPE,             \"invalid device type\",},\n-      {CL_INVALID_PLATFORM,                \"invlaid platform\",},\n-      {CL_INVALID_DEVICE,                  \"invalid device\",},\n-      {CL_INVALID_CONTEXT,                 \"invalid context\",},\n-      {CL_INVALID_QUEUE_PROPERTIES,        \"invalid queue properties\",},\n-      {CL_INVALID_COMMAND_QUEUE,           \"invalid command queue\",},\n-      {CL_INVALID_HOST_PTR,                \"invalid host ptr\",},\n-      {CL_INVALID_MEM_OBJECT,              \"invalid mem object\",},\n-      {CL_INVALID_IMAGE_FORMAT_DESCRIPTOR, \"invalid image format descriptor \",},\n-      {CL_INVALID_IMAGE_SIZE,              \"invalid image size\",},\n-      {CL_INVALID_SAMPLER,                 \"invalid sampler\",},\n-      {CL_INVALID_BINARY,                  \"invalid binary\",},\n-      {CL_INVALID_BUILD_OPTIONS,           \"invalid build options\",},\n-      {CL_INVALID_PROGRAM,                 \"invalid program \",},\n-      {CL_INVALID_PROGRAM_EXECUTABLE,      \"invalid program executable\",},\n-      {CL_INVALID_KERNEL_NAME,             \"invalid kernel name\",},\n-      {CL_INVALID_KERNEL_DEFINITION,       \"invalid definition\",},\n-      {CL_INVALID_KERNEL,                  \"invalid kernel\",},\n-      {CL_INVALID_ARG_INDEX,               \"invalid arg index\",},\n-      {CL_INVALID_ARG_VALUE,               \"invalid arg value\",},\n-      {CL_INVALID_ARG_SIZE,                \"invalid arg size\",},\n-      {CL_INVALID_KERNEL_ARGS,             \"invalid kernel args\",},\n-      {CL_INVALID_WORK_DIMENSION,          \"invalid work dimension\",},\n-      {CL_INVALID_WORK_GROUP_SIZE,         \"invalid work group size\",},\n-      {CL_INVALID_WORK_ITEM_SIZE,          \"invalid work item size\",},\n-      {CL_INVALID_GLOBAL_OFFSET,           \"invalid global offset\",},\n-      {CL_INVALID_EVENT_WAIT_LIST,         \"invalid event wait list\",},\n-      {CL_INVALID_EVENT,                   \"invalid event\",},\n-      {CL_INVALID_OPERATION,               \"invalid operation\",},\n-      {CL_INVALID_GL_OBJECT,               \"invalid gl object\",},\n-      {CL_INVALID_BUFFER_SIZE,             \"invalid buffer size\",},\n-      {CL_INVALID_MIP_LEVEL,               \"invalid mip level\",},\n-      {CL_INVALID_GLOBAL_WORK_SIZE,        \"invalid global work size\",},\n-      {0, NULL},\n-   };\n-   static char unknown[256];\n-   int ii;\n-\n-   for (ii = 0; error_table[ii].msg != NULL; ii++) {\n-      if (error_table[ii].code == status) {\n-         \/\/std::cerr << \" clerror '\" << error_table[ii].msg << \"'\" << std::endl;\n-         return error_table[ii].msg;\n-      }\n-   }\n-   SNPRINTF(unknown, sizeof(unknown), \"unknown error %d\", status);\n-   return unknown;\n-}\n-\n","filename":"hat\/backends\/opencl\/cpp\/opencl_shared.cpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -26,18 +26,45 @@\n-#include \"opencl_shared.h\"\n-\n-class OpenCLBackend: public Backend{\n-   public:\n-      class OpenCLConfig: public Backend::Config{\n-         public:\n-            boolean gpu;\n-            boolean junk;\n-      };\n-      class OpenCLProgram : public Backend::Program{\n-         class OpenCLKernel : public Backend::Program::Kernel{\n-            class OpenCLBuffer {\n-               public:\n-                  void *ptr;\n-                  size_t sizeInBytes;\n-                  cl_mem clMem;\n-                  OpenCLBuffer(cl_context context, void *ptr, size_t sizeInBytes);\n-                  virtual ~OpenCLBuffer();\n+#define CL_TARGET_OPENCL_VERSION 120\n+\n+#ifdef __APPLE__\n+#include <opencl\/opencl.h>\n+#define LongUnsignedNewline \"%llu\\n\"\n+#define Size_tNewline \"%lu\\n\"\n+#define LongHexNewline \"(0x%llx)\\n\"\n+#define alignedMalloc(size, alignment) memalign(alignment, size)\n+#define SNPRINTF snprintf\n+#else\n+#include <CL\/cl.h>\n+#include <malloc.h>\n+#define LongHexNewline \"(0x%lx)\\n\"\n+#define LongUnsignedNewline \"%lu\\n\"\n+#define Size_tNewline \"%lu\\n\"\n+#if defined (_WIN32)\n+#include \"windows.h\"\n+#define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n+#define SNPRINTF _snprintf\n+#else\n+#define alignedMalloc(size, alignment) memalign(alignment, size)\n+#define SNPRINTF  snprintf\n+#endif\n+#endif\n+#include \"shared.h\"\n+\n+class OpenCLBackend : public Backend {\n+public:\n+    class OpenCLConfig : public Backend::Config {\n+    public:\n+        boolean gpu;\n+        boolean junk;\n+    };\n+\n+    class OpenCLProgram : public Backend::Program {\n+        class OpenCLKernel : public Backend::Program::Kernel {\n+        class OpenCLBuffer  {\n+            public:\n+                void *ptr;\n+                size_t sizeInBytes;\n+                cl_mem clMem;\n+\n+                OpenCLBuffer(cl_context context, void *ptr, size_t sizeInBytes);\n+\n+                virtual ~OpenCLBuffer();\n@@ -46,1 +73,1 @@\n-            private:\n+        private:\n@@ -48,1 +75,1 @@\n-            public:\n+        public:\n@@ -50,0 +77,1 @@\n+\n@@ -51,2 +79,0 @@\n-            long ndrange( int range, void *argArray);\n-         };\n@@ -54,2 +80,30 @@\n-         private:\n-         cl_program program;\n+            long ndrange(int range, void *argArray);\n+        };\n+\n+    private:\n+        cl_program program;\n+\n+    public:\n+        OpenCLProgram(Backend *backend, BuildInfo *buildInfo, cl_program program);\n+\n+        ~OpenCLProgram();\n+\n+        long getKernel(int nameLen, char *name);\n+\n+        bool programOK();\n+    };\n+\n+public:\n+    cl_platform_id platform_id;\n+    cl_context context;\n+    cl_command_queue command_queue;\n+    cl_device_id device_id;\n+    size_t eventMax;\n+    cl_event *events;\n+    size_t eventc;\n+\n+    OpenCLBackend();\n+\n+    OpenCLBackend(OpenCLConfig *config, int configSchemaLen, char *configSchema);\n+\n+    ~OpenCLBackend();\n@@ -57,6 +111,1 @@\n-         public:\n-         OpenCLProgram(Backend *backend, BuildInfo *buildInfo,cl_program program);\n-         ~OpenCLProgram();\n-         long getKernel(int nameLen, char *name);\n-         bool programOK();\n-      };\n+    int getMaxComputeUnits();\n@@ -64,9 +113,1 @@\n-   public:\n-      cl_platform_id platform_id;\n-      cl_context context;\n-      cl_command_queue command_queue;\n-      cl_device_id device_id;\n-      size_t eventMax;\n-      cl_event *events;\n-      size_t eventc;\n-      OpenCLBackend(OpenCLConfig *config, int configSchemaLen, char *configSchema);\n+    void info();\n@@ -74,1 +115,1 @@\n-      ~OpenCLBackend();\n+    long compileProgram(int len, char *source);\n@@ -76,1 +117,1 @@\n-      void allocEvents(int max) ;\n+protected:\n@@ -78,1 +119,1 @@\n-      void releaseEvents();\n+    void allocEvents(int max);\n@@ -80,1 +121,1 @@\n-      void waitForEvents() ;\n+    void releaseEvents();\n@@ -82,1 +123,1 @@\n-      void showEvents(int width) ;\n+    void waitForEvents();\n@@ -84,1 +125,1 @@\n-      int getMaxComputeUnits();\n+    void showEvents(int width);\n@@ -86,2 +127,2 @@\n-      void info();\n-      long compileProgram(int len, char *source);\n+public:\n+    static const char *errorMsg(cl_int status);\n","filename":"hat\/backends\/opencl\/include\/opencl_backend.h","additions":88,"deletions":47,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#pragma once\n-#define CL_TARGET_OPENCL_VERSION 120\n-\n-#ifdef __APPLE__\n-#include <opencl\/opencl.h>\n-#define LongUnsignedNewline \"%llu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#define LongHexNewline \"(0x%llx)\\n\"\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF snprintf\n-#else\n-#include <CL\/cl.h>\n-#include <malloc.h>\n-#define LongHexNewline \"(0x%lx)\\n\"\n-#define LongUnsignedNewline \"%lu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#if defined (_WIN32)\n-#include \"windows.h\"\n-#define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n-#define SNPRINTF _snprintf\n-#else\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF  snprintf\n-#endif\n-#endif\n-#include \"shared.h\"\n-\n-extern const char *error(cl_int status);\n","filename":"hat\/backends\/opencl\/include\/opencl_shared.h","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -27,2 +27,2 @@\n-int main(){\n-   std::cout << \"inside PTX info\" << std::endl;\n+int main() {\n+    std::cout << \"inside PTX info\" << std::endl;\n","filename":"hat\/backends\/ptx\/cpp\/info.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,23 +28,31 @@\n-class PTXBackend: public Backend{\n-   public:\n-      class PTXConfig: public Backend::Config{\n-         public :\n-      };\n-      class PTXProgram : public Backend::Program{\n-         class PTXKernel : public Backend::Program::Kernel{\n-            public:\n-               PTXKernel(Backend::Program *program):Backend::Program::Kernel(program){\n-               }\n-               ~PTXKernel(){\n-               }\n-               long ndrange( int range, void *argArray) {\n-                  std::cout<<\"ptx ndrange(\"<<range<<\") \"<< std::endl;\n-                  return 0;\n-               }\n-         };\n-         public:\n-         PTXProgram(Backend *backend, BuildInfo *buildInfo ):Backend::Program(backend, buildInfo){\n-         }\n-         ~PTXProgram(){\n-         }\n-         long getKernel(int nameLen, char *name){\n+class PTXBackend : public Backend {\n+public:\n+    class PTXConfig : public Backend::Config {\n+    public :\n+    };\n+\n+    class PTXProgram : public Backend::Program {\n+        class PTXKernel : public Backend::Program::Kernel {\n+        public:\n+            PTXKernel(Backend::Program *program)\n+                    : Backend::Program::Kernel(program) {\n+            }\n+\n+            ~PTXKernel() {\n+            }\n+\n+            long ndrange(int range, void *argArray) {\n+                std::cout << \"ptx ndrange(\" << range << \") \" << std::endl;\n+                return 0;\n+            }\n+        };\n+\n+    public:\n+        PTXProgram(Backend *backend, BuildInfo *buildInfo)\n+                : Backend::Program(backend, buildInfo) {\n+        }\n+\n+        ~PTXProgram() {\n+        }\n+\n+        long getKernel(int nameLen, char *name) {\n@@ -52,2 +60,3 @@\n-         }\n-         bool programOK(){\n+        }\n+\n+        bool programOK() {\n@@ -55,34 +64,35 @@\n-         }\n-      };\n-\n-   public:\n-\n-      PTXBackend(PTXConfig *ptxConfig, int ptxConfigSchemeLen, char *ptxBackendSchema):Backend(ptxConfig,ptxConfigSchemeLen,ptxBackendSchema) {\n-         if (ptxConfig == nullptr){\n-            std::cout << \"ptxConfig == null\"<< std::endl;\n-         }else{\n-            std::cout << \"ptxConfig != null\" <<std::endl;\n-         }\n-      }\n-\n-      ~PTXBackend() {\n-      }\n-\n-      int getMaxComputeUnits(){\n-         std::cout << \"ptx getMaxComputeUnits()\"<<std::endl;\n-         return 0;\n-      }\n-\n-      void info(){\n-         std::cout << \"ptx info()\"<<std::endl;\n-      }\n-\n-      long compileProgram(int len, char *source){\n-         std::cout << \"ptx compileProgram()\"<<std::endl;\n-         size_t srcLen = ::strlen(source);\n-         char *src = new char[srcLen + 1];\n-         ::strncpy(src, source, srcLen);\n-         src[srcLen] = '\\0';\n-         std::cout << \"native compiling \" << src << std::endl;\n-         return (long) new PTXProgram(this, new BuildInfo(src, nullptr,false));\n-      }\n+        }\n+    };\n+\n+public:\n+\n+    PTXBackend(PTXConfig *ptxConfig, int ptxConfigSchemeLen, char *ptxBackendSchema)\n+            : Backend(ptxConfig, ptxConfigSchemeLen, ptxBackendSchema) {\n+        if (ptxConfig == nullptr) {\n+            std::cout << \"ptxConfig == null\" << std::endl;\n+        } else {\n+            std::cout << \"ptxConfig != null\" << std::endl;\n+        }\n+    }\n+\n+    ~PTXBackend() {\n+    }\n+\n+    int getMaxComputeUnits() {\n+        std::cout << \"ptx getMaxComputeUnits()\" << std::endl;\n+        return 0;\n+    }\n+\n+    void info() {\n+        std::cout << \"ptx info()\" << std::endl;\n+    }\n+\n+    long compileProgram(int len, char *source) {\n+        std::cout << \"ptx compileProgram()\" << std::endl;\n+        size_t srcLen = ::strlen(source);\n+        char *src = new char[srcLen + 1];\n+        ::strncpy(src, source, srcLen);\n+        src[srcLen] = '\\0';\n+        std::cout << \"native compiling \" << src << std::endl;\n+        return (long) new PTXProgram(this, new BuildInfo(src, nullptr, false));\n+    }\n@@ -91,3 +101,3 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema){\n-   PTXBackend::PTXConfig *ptxConfig = (PTXBackend::PTXConfig*)config;\n-   return (long)new PTXBackend(ptxConfig,configSchemaLen,configSchema);\n+long getBackend(void *config, int configSchemaLen, char *configSchema) {\n+    PTXBackend::PTXConfig *ptxConfig = (PTXBackend::PTXConfig *) config;\n+    return (long) new PTXBackend(ptxConfig, configSchemaLen, configSchema);\n","filename":"hat\/backends\/ptx\/cpp\/ptx_backend.cpp","additions":72,"deletions":62,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -29,9 +29,9 @@\n-   for (int i = 0; i < len; i++) {\n-      if (i % 16 == 0) {\n-         if (i != 0) {\n-            fprintf(file, \"\\n\");\n-         }\n-         fprintf(file, \"%lx :\", ((unsigned long) ptr) + i);\n-      }\n-      fprintf(file, \" %02x\", ((int) (((unsigned char *) ptr)[i]) & 0xff));\n-   }\n+    for (int i = 0; i < len; i++) {\n+        if (i % 16 == 0) {\n+            if (i != 0) {\n+                fprintf(file, \"\\n\");\n+            }\n+            fprintf(file, \"%lx :\", ((unsigned long) ptr) + i);\n+        }\n+        fprintf(file, \" %02x\", ((int) (((unsigned char *) ptr)[i]) & 0xff));\n+    }\n@@ -42,6 +42,6 @@\n-   ArgSled argSled((ArgArray_t*)ptr);\n-   std::cout  << \"ArgArray->argc = \" << argSled.argc()  << std::endl;\n-   for (int i=0; i<argSled.argc(); i++){\n-      argSled.dumpArg(i);\n-   }\n-   std::cout<< \"schema = \"<< argSled.schema() << std::endl;\n+    ArgSled argSled((ArgArray_t *) ptr);\n+    std::cout << \"ArgArray->argc = \" << argSled.argc() << std::endl;\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        argSled.dumpArg(i);\n+    }\n+    std::cout << \"schema = \" << argSled.schema() << std::endl;\n@@ -50,1 +50,1 @@\n-   \/\/#define YEP\n+    \/\/#define YEP\n@@ -52,115 +52,115 @@\n-   std::cout << std::endl << \"spec->\" << spec << std::endl;\n-\n-   char *data = (char *) ptr;\n-   char *p = spec;\n-   std::stack<State *> stack;\n-\n-   while (*p) {\n-      if (*p == '[' && ::isdigit(*(p+1))) {\n-         p++;\n-         int count = 0;\n-         while (::isdigit(*p)) {\n-            count = (count * 10) + (*p - '0');\n-            p++;\n-         }\n-         if (*p == ':') {\n-            p++;\n-         }\n-         stack.push(State::sequence(p, data, count));\n-         for (int i = 0; i < stack.size(); i++) {\n-            std::cout << \" \";\n-         }\n-         std::cout << (stack.top()->count) << \" of \" << (stack.top()->of) <<std::endl;\n-      } else if (*p == '[') {\n-         p++;\n-         stack.push(State::structOrUnion(p, data));\n-         for (int i = 0; i < stack.size(); i++) {\n-            std::cout << \" \";\n-         }\n-         std::cout << \"{\" << std::endl;\n-      } else if (*p == ']' && !stack.empty() && stack.top()->isMidSequence()) {\n-         stack.top()->count++;\n-         p = stack.top()->start;\n-         for (int i = 0; i < stack.size(); i++) {\n-            std::cout << \" \";\n-         }\n-         \/\/I V vi iii IV I IV V\n-         std::cout << (stack.top()->count) << \" of \" << (stack.top()->of) << std::endl ;\n-      } else if (*p == ']' && !stack.empty() && stack.top()->isSequence()) {\n-         p++;\n-         State *state = stack.top();\n-         if (*p == '(') {\n-            p++;\n-            char *start = p;\n-            while (*p != ')') {\n-               state->name[p - start] = *p;\n-               p++;\n-            }\n-            state->name[p - start] = '\\0';\n-         }\n-         p++;\n-         stack.pop();\n-         for (int i = 0; i < stack.size(); i++) {\n-            std::cout << \" \";\n-         }\n-         std::cout << \"]\" << state->name << std::endl;\n-         delete state;\n-\n-      } else if (*p == ']' && !stack.empty() && stack.top()->isStructOrUnion()) {\n-         p++;\n-         State *state = stack.top();\n-         if (*p == '(') {\n-            p++;\n-            char *start = p;\n-            while (*p != ')') {\n-               state->name[p - start] = *p;\n-               p++;\n-            }\n-            state->name[p - start] = '\\0';\n-         }\n-         p++;\n-         stack.pop();\n-         for (int i = 0; i < stack.size(); i++) {\n-            std::cout << \" \";\n-         }\n-         std::cout << \"}\" << state->name<< std::endl;\n-         delete state;\n-      } else if ( (*p == '|') && !stack.empty() && stack.top()->isStructOrUnion() ) {\n-         p++;\n-         \/\/ we refetch data from the dataStart of the enclosing union\n-         data = (char*)stack.top()->dataStart;\n-      } else if ( (*p == 'i' || *p == 'b' || *p == 's'|| *p == 'f') && !stack.empty() && stack.top()->isStructOrUnion() ) {\n-         char *start = p;\n-         p++;\n-         int sz = 0;\n-         while (::isdigit(*p)) {\n-            sz = sz * 10 + *p - '0';\n-            p++;\n-         }\n-         State *state =  State::member(start,data, sz);\n-         stack.push(state);\n-         if (*p == '(') {\n-            p++;\n-            char *start = p;\n-            while (*p != ')') {\n-               state->name[p - start] = *p;\n-               p++;\n-            }\n-            state->name[p - start] = '\\0';\n-         }\n-         for (int i = 0; i < stack.size(); i++) {\n-            std::cout << \" \";\n-         }\n-         state->value(std::cout, data);\n-         data += (state->sz \/ 8);\n-         stack.pop();\n-         delete state;\n-         p++;\n-      } else if (stack.empty()){\n-         std::cout << \"empty stack and  unhandled -> \"<< p<< std::endl;\n-         p++;\n-      } else {\n-         std::cout <<stack.top()->state()<< \" unhandled -> \"<< p<< std::endl;\n-         p++;\n-      }\n-   }\n+    std::cout << std::endl << \"spec->\" << spec << std::endl;\n+\n+    char *data = (char *) ptr;\n+    char *p = spec;\n+    std::stack<State *> stack;\n+\n+    while (*p) {\n+       if (*p == '[' && ::isdigit(*(p+1))) {\n+          p++;\n+          int count = 0;\n+          while (::isdigit(*p)) {\n+             count = (count * 10) + (*p - '0');\n+             p++;\n+          }\n+          if (*p == ':') {\n+             p++;\n+          }\n+          stack.push(State::sequence(p, data, count));\n+          for (int i = 0; i < stack.size(); i++) {\n+             std::cout << \" \";\n+          }\n+          std::cout << (stack.top()->count) << \" of \" << (stack.top()->of) <<std::endl;\n+       } else if (*p == '[') {\n+          p++;\n+          stack.push(State::structOrUnion(p, data));\n+          for (int i = 0; i < stack.size(); i++) {\n+             std::cout << \" \";\n+          }\n+          std::cout << \"{\" << std::endl;\n+       } else if (*p == ']' && !stack.empty() && stack.top()->isMidSequence()) {\n+          stack.top()->count++;\n+          p = stack.top()->start;\n+          for (int i = 0; i < stack.size(); i++) {\n+             std::cout << \" \";\n+          }\n+          \/\/I V vi iii IV I IV V\n+          std::cout << (stack.top()->count) << \" of \" << (stack.top()->of) << std::endl ;\n+       } else if (*p == ']' && !stack.empty() && stack.top()->isSequence()) {\n+          p++;\n+          State *state = stack.top();\n+          if (*p == '(') {\n+             p++;\n+             char *start = p;\n+             while (*p != ')') {\n+                state->name[p - start] = *p;\n+                p++;\n+             }\n+             state->name[p - start] = '\\0';\n+          }\n+          p++;\n+          stack.pop();\n+          for (int i = 0; i < stack.size(); i++) {\n+             std::cout << \" \";\n+          }\n+          std::cout << \"]\" << state->name << std::endl;\n+          delete state;\n+\n+       } else if (*p == ']' && !stack.empty() && stack.top()->isStructOrUnion()) {\n+          p++;\n+          State *state = stack.top();\n+          if (*p == '(') {\n+             p++;\n+             char *start = p;\n+             while (*p != ')') {\n+                state->name[p - start] = *p;\n+                p++;\n+             }\n+             state->name[p - start] = '\\0';\n+          }\n+          p++;\n+          stack.pop();\n+          for (int i = 0; i < stack.size(); i++) {\n+             std::cout << \" \";\n+          }\n+          std::cout << \"}\" << state->name<< std::endl;\n+          delete state;\n+       } else if ( (*p == '|') && !stack.empty() && stack.top()->isStructOrUnion() ) {\n+          p++;\n+          \/\/ we refetch data from the dataStart of the enclosing union\n+          data = (char*)stack.top()->dataStart;\n+       } else if ( (*p == 'i' || *p == 'b' || *p == 's'|| *p == 'f') && !stack.empty() && stack.top()->isStructOrUnion() ) {\n+          char *start = p;\n+          p++;\n+          int sz = 0;\n+          while (::isdigit(*p)) {\n+             sz = sz * 10 + *p - '0';\n+             p++;\n+          }\n+          State *state =  State::member(start,data, sz);\n+          stack.push(state);\n+          if (*p == '(') {\n+             p++;\n+             char *start = p;\n+             while (*p != ')') {\n+                state->name[p - start] = *p;\n+                p++;\n+             }\n+             state->name[p - start] = '\\0';\n+          }\n+          for (int i = 0; i < stack.size(); i++) {\n+             std::cout << \" \";\n+          }\n+          state->value(std::cout, data);\n+          data += (state->sz \/ 8);\n+          stack.pop();\n+          delete state;\n+          p++;\n+       } else if (stack.empty()){\n+          std::cout << \"empty stack and  unhandled -> \"<< p<< std::endl;\n+          p++;\n+       } else {\n+          std::cout <<stack.top()->state()<< \" unhandled -> \"<< p<< std::endl;\n+          p++;\n+       }\n+    }\n@@ -171,15 +171,15 @@\n-   unsigned char *buf = (unsigned char*)ptr;\n-   int i, j;\n-   for (i=0; i<buflen; i+=16) {\n-      printf(\"%06x: \", i);\n-      for (j=0; j<16; j++)\n-         if (i+j < buflen)\n-            printf(\"%02x \", buf[i+j]);\n-         else\n-            printf(\"   \");\n-      printf(\" \");\n-      for (j=0; j<16; j++)\n-         if (i+j < buflen)\n-            printf(\"%c\", isprint(buf[i+j]) ? buf[i+j] : '.');\n-      printf(\"\\n\");\n-   }\n+    unsigned char *buf = (unsigned char *) ptr;\n+    int i, j;\n+    for (i = 0; i < buflen; i += 16) {\n+        printf(\"%06x: \", i);\n+        for (j = 0; j < 16; j++)\n+            if (i + j < buflen)\n+                printf(\"%02x \", buf[i + j]);\n+            else\n+                printf(\"   \");\n+        printf(\" \");\n+        for (j = 0; j < 16; j++)\n+            if (i + j < buflen)\n+                printf(\"%c\", isprint(buf[i + j]) ? buf[i + j] : '.');\n+        printf(\"\\n\");\n+    }\n@@ -190,3 +190,3 @@\n-extern \"C\"  int getMaxComputeUnits(long backendHandle) {\n-   Backend *backend = (Backend*)backendHandle;\n-   return backend->getMaxComputeUnits();\n+extern \"C\" int getMaxComputeUnits(long backendHandle) {\n+    Backend *backend = (Backend *) backendHandle;\n+    return backend->getMaxComputeUnits();\n@@ -196,2 +196,2 @@\n-   Backend *backend = (Backend*)backendHandle;\n-   backend->info();\n+    Backend *backend = (Backend *) backendHandle;\n+    backend->info();\n@@ -200,2 +200,2 @@\n-   Backend* backend = (Backend*)backendHandle;\n-   delete backend;\n+    Backend *backend = (Backend *) backendHandle;\n+    delete backend;\n@@ -204,3 +204,3 @@\n-   \/\/std::cout << \"trampolining through backendHandle to compileProgram\" <<std::endl;\n-   Backend *backend = (Backend*)backendHandle;\n-   return backend->compileProgram(len, source);\n+    \/\/std::cout << \"trampolining through backendHandle to compileProgram\" <<std::endl;\n+    Backend *backend = (Backend *) backendHandle;\n+    return backend->compileProgram(len, source);\n@@ -209,3 +209,3 @@\n-   \/\/std::cout << \"trampolining through programHandle to get kernel\" <<std::endl;\n-   Backend::Program *program = (Backend::Program *)programHandle;\n-   return program->getKernel(nameLen, name);\n+    \/\/std::cout << \"trampolining through programHandle to get kernel\" <<std::endl;\n+    Backend::Program *program = (Backend::Program *) programHandle;\n+    return program->getKernel(nameLen, name);\n@@ -214,5 +214,5 @@\n-extern \"C\" long ndrange(long kernelHandle, int range, void* argArray) {\n-   \/\/std::cout << \"trampolining through kernelHandle to dispatch \" <<std::endl;\n-   Backend::Program::Kernel *kernel = (Backend::Program::Kernel *)kernelHandle;\n-   kernel->ndrange(range, argArray);\n-   return (long)0;\n+extern \"C\" long ndrange(long kernelHandle, int range, void *argArray) {\n+    \/\/std::cout << \"trampolining through kernelHandle to dispatch \" <<std::endl;\n+    Backend::Program::Kernel *kernel = (Backend::Program::Kernel *) kernelHandle;\n+    kernel->ndrange(range, argArray);\n+    return (long) 0;\n@@ -221,2 +221,2 @@\n-   Backend::Program::Kernel *kernel = (Backend::Program::Kernel *)kernelHandle;\n-   delete kernel;\n+    Backend::Program::Kernel *kernel = (Backend::Program::Kernel *) kernelHandle;\n+    delete kernel;\n@@ -226,2 +226,2 @@\n-   Backend::Program *program = (Backend::Program *)programHandle;\n-   delete program;\n+    Backend::Program *program = (Backend::Program *) programHandle;\n+    delete program;\n@@ -230,2 +230,2 @@\n-   Backend::Program *program = (Backend::Program *)programHandle;\n-   return program->programOK();\n+    Backend::Program *program = (Backend::Program *) programHandle;\n+    return program->programOK();\n","filename":"hat\/backends\/shared\/cpp\/shared.cpp","additions":170,"deletions":170,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -38,0 +39,1 @@\n+\n@@ -71,0 +73,1 @@\n+\n@@ -72,0 +75,1 @@\n+\n@@ -73,5 +77,5 @@\n-   void * memorySegment;   \/\/ Address of a Buffer\/MemorySegment\n-   long sizeInBytes;     \/\/ The size of the memory segment in bytes\n-   void * vendorPtr;       \/\/ The vendor side can reference vendor into\n-   u8_t access;          \/\/ 0=??\/1=RO\/2=WO\/3=RW if this is a buffer\n-   u8_t state;           \/\/ 0=UNKNOWN\/1=GPUDIRTY\/2=JAVADIRTY\n+    void *memorySegment;   \/\/ Address of a Buffer\/MemorySegment\n+    long sizeInBytes;     \/\/ The size of the memory segment in bytes\n+    void *vendorPtr;       \/\/ The vendor side can reference vendor into\n+    u8_t access;          \/\/ 0=??\/1=RO\/2=WO\/3=RW if this is a buffer\n+    u8_t state;           \/\/ 0=UNKNOWN\/1=GPUDIRTY\/2=JAVADIRTY\n@@ -81,10 +85,10 @@\n-   boolean   z1;  \/\/ 'Z'\n-   u8_t   s8;  \/\/ 'B'\n-   u16_t u16;  \/\/ 'C'\n-   s16_t  s16;  \/\/ 'S'\n-   s32_t  s32;  \/\/ 'I'\n-   f32_t f32; \/\/ 'F'\n-   f64_t f64; \/\/ 'D'\n-   s64_t   s64; \/\/ 'J'\n-   Buffer_t  buffer; \/\/ '&'\n-}Value_t;\n+    boolean z1;  \/\/ 'Z'\n+    u8_t s8;  \/\/ 'B'\n+    u16_t u16;  \/\/ 'C'\n+    s16_t s16;  \/\/ 'S'\n+    s32_t s32;  \/\/ 'I'\n+    f32_t f32; \/\/ 'F'\n+    f64_t f64; \/\/ 'D'\n+    s64_t s64; \/\/ 'J'\n+    Buffer_t buffer; \/\/ '&'\n+} Value_t;\n@@ -93,5 +97,5 @@\n-   u32_t idx;          \/\/ 0..argc\n-   u8_t variant;      \/\/ which variant 'I','Z','S','J','F', '&' implies Buffer\/MemorySegment\n-   u8_t pad1[8];\n-   Value_t value;\n-   u8_t pad[6];\n+    u32_t idx;          \/\/ 0..argc\n+    u8_t variant;      \/\/ which variant 'I','Z','S','J','F', '&' implies Buffer\/MemorySegment\n+    u8_t pad1[8];\n+    Value_t value;\n+    u8_t pad[6];\n@@ -100,7 +104,7 @@\n-typedef struct ArgArray_s{\n-   u32_t argc;\n-   u8_t pad[12];\n-   Arg_t argv[0\/*argc*\/];\n-   \/\/ void * vendorPtr;\n-   \/\/ int schemaLen\n-   \/\/ char schema[schemaLen]\n+typedef struct ArgArray_s {\n+    u32_t argc;\n+    u8_t pad[12];\n+    Arg_t argv[0\/*argc*\/];\n+    \/\/ void * vendorPtr;\n+    \/\/ int schemaLen\n+    \/\/ char schema[schemaLen]\n@@ -109,61 +113,86 @@\n-class ArgSled{\n-   private:\n-      ArgArray_t * argArray;\n-   public:\n-      int argc(){\n-         return argArray->argc;\n-      }\n-      Arg_t *arg(int n){\n-         Arg_t *a = (argArray->argv+n);\n-         return  a;\n-      }\n-\n-      void hexdumpArg(int n){\n-         hexdump(arg(n), sizeof(Arg_t));\n-      }\n-\n-      void dumpArg(int n){\n-         Arg_t *a= arg(n);\n-         int idx = (int)a->idx;\n-         std::cout << \"arg[\" << idx <<\"]\";\n-         char variant = (char)a->variant;\n-         switch (variant){\n-            case 'F':  std::cout << \" f32 \" << a->value.f32 <<std::endl;break;\n-            case 'I':  std::cout << \" s32 \" << a->value.s32 <<std::endl;break;\n-            case 'D':  std::cout << \" f64 \" << a->value.f64 <<std::endl;break;\n-            case 'J':  std::cout << \" s64 \" << a->value.s64 <<std::endl;break;\n-            case 'C':  std::cout << \" u16 \" << a->value.u16 <<std::endl;break;\n-            case 'S':  std::cout << \" s16 \" << a->value.s32 <<std::endl;break;\n-            case 'Z':  std::cout << \" z1 \" << a->value.z1 <<std::endl;break;\n-            case '&': std::cout << \" buffer {\"\n-                      <<  \" void *address = 0x\"<<std::hex<<(long)a->value.buffer.memorySegment <<std::dec\n-                         <<  \", long bytesSize= 0x\"<<std::hex<<(long)a->value.buffer.sizeInBytes <<std::dec\n-                         <<\"}\" <<std::endl;break;\n-            default: std::cout << (char)variant <<std::endl;break;\n-         }\n-      }\n-      void *vendorPtrPtr(){\n-         Arg_t *a = arg(argc());\n-         return (void *)a;\n-      }\n-      \/*  void *vendorPtr(){\n-          char *cptr = (char*)vendorPtrPtr();\n-          char *cptr2 =  (char*)cptr[0];\n-          return (void*)cptr2;\n-          }\n-\n-          void vendorPtr(void *vendorPtr){\n-       *vendorPtrPtr() =vendorPtr;\n-       } *\/\n-      int *schemaLenPtr(){\n-         int *schemaLenP = (int*) ((char*)vendorPtrPtr()+sizeof(void *));\n-         return schemaLenP;\n-      }\n-      int schemaLen(){\n-         return *schemaLenPtr();\n-      }\n-      char* schema(){\n-         int *schemaLenP = ((int*) ((char*)vendorPtrPtr()+sizeof(void *))+1);\n-         return (char*)schemaLenP;\n-      }\n-      ArgSled(ArgArray_t *argArray): argArray(argArray) {}\n+class ArgSled {\n+private:\n+    ArgArray_t *argArray;\n+public:\n+    int argc() {\n+        return argArray->argc;\n+    }\n+\n+    Arg_t *arg(int n) {\n+        Arg_t *a = (argArray->argv + n);\n+        return a;\n+    }\n+\n+    void hexdumpArg(int n) {\n+        hexdump(arg(n), sizeof(Arg_t));\n+    }\n+\n+    void dumpArg(int n) {\n+        Arg_t *a = arg(n);\n+        int idx = (int) a->idx;\n+        std::cout << \"arg[\" << idx << \"]\";\n+        char variant = (char) a->variant;\n+        switch (variant) {\n+            case 'F':\n+                std::cout << \" f32 \" << a->value.f32 << std::endl;\n+                break;\n+            case 'I':\n+                std::cout << \" s32 \" << a->value.s32 << std::endl;\n+                break;\n+            case 'D':\n+                std::cout << \" f64 \" << a->value.f64 << std::endl;\n+                break;\n+            case 'J':\n+                std::cout << \" s64 \" << a->value.s64 << std::endl;\n+                break;\n+            case 'C':\n+                std::cout << \" u16 \" << a->value.u16 << std::endl;\n+                break;\n+            case 'S':\n+                std::cout << \" s16 \" << a->value.s32 << std::endl;\n+                break;\n+            case 'Z':\n+                std::cout << \" z1 \" << a->value.z1 << std::endl;\n+                break;\n+            case '&':\n+                std::cout << \" buffer {\"\n+                          << \" void *address = 0x\" << std::hex << (long) a->value.buffer.memorySegment << std::dec\n+                          << \", long bytesSize= 0x\" << std::hex << (long) a->value.buffer.sizeInBytes << std::dec\n+                          << \"}\" << std::endl;\n+                break;\n+            default:\n+                std::cout << (char) variant << std::endl;\n+                break;\n+        }\n+    }\n+\n+    void *vendorPtrPtr() {\n+        Arg_t *a = arg(argc());\n+        return (void *) a;\n+    }\n+\n+    \/*  void *vendorPtr(){\n+        char *cptr = (char*)vendorPtrPtr();\n+        char *cptr2 =  (char*)cptr[0];\n+        return (void*)cptr2;\n+        }\n+\n+        void vendorPtr(void *vendorPtr){\n+     *vendorPtrPtr() =vendorPtr;\n+     } *\/\n+    int *schemaLenPtr() {\n+        int *schemaLenP = (int *) ((char *) vendorPtrPtr() + sizeof(void *));\n+        return schemaLenP;\n+    }\n+\n+    int schemaLen() {\n+        return *schemaLenPtr();\n+    }\n+\n+    char *schema() {\n+        int *schemaLenP = ((int *) ((char *) vendorPtrPtr() + sizeof(void *)) + 1);\n+        return (char *) schemaLenP;\n+    }\n+\n+    ArgSled(ArgArray_t *argArray)\n+            : argArray(argArray) {}\n@@ -173,1 +202,0 @@\n-\n@@ -175,14 +203,14 @@\n-   struct timeval startTV, endTV;\n-   public:\n-   unsigned long elapsed_us;\n-\n-   void start() {\n-      gettimeofday(&startTV, NULL);\n-   }\n-\n-   unsigned long end() {\n-      gettimeofday(&endTV, NULL);\n-      elapsed_us = (endTV.tv_sec - startTV.tv_sec) * 1000000;      \/\/ sec to us\n-      elapsed_us += (endTV.tv_usec - startTV.tv_usec);\n-      return elapsed_us;\n-   }\n+    struct timeval startTV, endTV;\n+public:\n+    unsigned long elapsed_us;\n+\n+    void start() {\n+        gettimeofday(&startTV, NULL);\n+    }\n+\n+    unsigned long end() {\n+        gettimeofday(&endTV, NULL);\n+        elapsed_us = (endTV.tv_sec - startTV.tv_sec) * 1000000;      \/\/ sec to us\n+        elapsed_us += (endTV.tv_usec - startTV.tv_usec);\n+        return elapsed_us;\n+    }\n@@ -190,0 +218,1 @@\n+\n@@ -420,4 +449,4 @@\n-   public:\n-      char *src;\n-      char *log;\n-      bool ok;\n+public:\n+    char *src;\n+    char *log;\n+    bool ok;\n@@ -425,3 +454,3 @@\n-      BuildInfo(char *src, char *log, bool ok)\n-         : src(src), log(log), ok(ok) {\n-         }\n+    BuildInfo(char *src, char *log, bool ok)\n+            : src(src), log(log), ok(ok) {\n+    }\n@@ -429,2 +458,2 @@\n-      ~BuildInfo() {\n-         if (src) {\n+    ~BuildInfo() {\n+        if (src) {\n@@ -432,2 +461,2 @@\n-         }\n-         if (log) {\n+        }\n+        if (log) {\n@@ -435,2 +464,2 @@\n-         }\n-      }\n+        }\n+    }\n@@ -442,0 +471,1 @@\n+\n@@ -445,21 +475,16 @@\n-class Backend{\n-   public:\n-      class Config{\n-         public:\n-      };\n-      class Program{\n-         public:\n-            class Kernel{\n-               public:\n-                  Program *program;\n-                  virtual long ndrange( int range, void *argArray)=0 ;\n-                  Kernel(Program *program):program(program){\n-                  }\n-                  virtual ~Kernel(){}\n-            };\n-         public:\n-            Backend *backend;\n-            BuildInfo *buildInfo;\n-            virtual long getKernel(int nameLen, char *name)=0 ;\n-            virtual bool programOK()=0;\n-            Program(Backend *backend, BuildInfo *buildInfo):backend(backend), buildInfo(buildInfo){\n+class Backend {\n+public:\n+    class Config {\n+    public:\n+    };\n+\n+    class Program {\n+    public:\n+        class Kernel {\n+        public:\n+            Program *program;\n+\n+            virtual long ndrange(int range, void *argArray) = 0;\n+\n+            Kernel(Program *program)\n+                    : program(program) {\n@@ -467,15 +492,38 @@\n-            virtual ~Program(){\n-               if (buildInfo != nullptr){\n-                  delete buildInfo;\n-               }\n-            };\n-\n-      };\n-      Config *config;\n-      int configSchemaLen;\n-      char *configSchema;\n-      Backend(Config *config, int configSchemaLen, char *configSchema):config(config),configSchemaLen(configSchemaLen), configSchema(configSchema){}\n-      virtual ~Backend(){};\n-      virtual void info()=0 ;\n-      virtual int getMaxComputeUnits()=0 ;\n-      virtual long compileProgram( int len, char *source)=0;\n+\n+            virtual ~Kernel() {}\n+        };\n+\n+    public:\n+        Backend *backend;\n+        BuildInfo *buildInfo;\n+\n+        virtual long getKernel(int nameLen, char *name) = 0;\n+\n+        virtual bool programOK() = 0;\n+\n+        Program(Backend *backend, BuildInfo *buildInfo)\n+                : backend(backend), buildInfo(buildInfo) {\n+        }\n+\n+        virtual ~Program() {\n+            if (buildInfo != nullptr) {\n+                delete buildInfo;\n+            }\n+        };\n+\n+    };\n+\n+    Config *config;\n+    int configSchemaLen;\n+    char *configSchema;\n+\n+    Backend(Config *config, int configSchemaLen, char *configSchema)\n+            : config(config), configSchemaLen(configSchemaLen), configSchema(configSchema) {}\n+\n+    virtual ~Backend() {};\n+\n+    virtual void info() = 0;\n+\n+    virtual int getMaxComputeUnits() = 0;\n+\n+    virtual long compileProgram(int len, char *source) = 0;\n@@ -484,3 +532,3 @@\n-extern \"C\" long getBackend(void *config, int configSchemaLen, char *configSchema) ;\n-extern \"C\" void info(long backendHandle) ;\n-extern \"C\" int getMaxComputeUnits(long backendHandle) ;\n+extern \"C\" long getBackend(void *config, int configSchemaLen, char *configSchema);\n+extern \"C\" void info(long backendHandle);\n+extern \"C\" int getMaxComputeUnits(long backendHandle);\n@@ -488,2 +536,2 @@\n-extern \"C\" long getKernel(long programHandle, int len, char *name) ;\n-extern \"C\" void releaseBackend(long backendHandle) ;\n+extern \"C\" long getKernel(long programHandle, int len, char *name);\n+extern \"C\" void releaseBackend(long backendHandle);\n@@ -492,2 +540,2 @@\n-extern \"C\" void releaseKernel(long kernelHandle) ;\n-extern \"C\" long ndrange(long kernelHandle, int range, void *argArray) ;\n+extern \"C\" void releaseKernel(long kernelHandle);\n+extern \"C\" long ndrange(long kernelHandle, int range, void *argArray);\n","filename":"hat\/backends\/shared\/include\/shared.h","additions":207,"deletions":159,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-int main(){\n-   std::cout << \"inside SPIRV info\" << std::endl;\n+int main() {\n+    std::cout << \"inside SPIRV info\" << std::endl;\n","filename":"hat\/backends\/spirv\/cpp\/info.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,23 +27,31 @@\n-class SpirvBackend: public Backend{\n-   public:\n-      class SpirvConfig: public Backend::Config{\n-         public :\n-      };\n-      class SpirvProgram : public Backend::Program{\n-         class SpirvKernel : public Backend::Program::Kernel{\n-            public:\n-               SpirvKernel(Backend::Program *program):Backend::Program::Kernel(program){\n-               }\n-               ~SpirvKernel(){\n-               }\n-               long ndrange( int range, void *argArray) {\n-                  std::cout<<\"spirv ndrange(\"<<range<<\") \"<< std::endl;\n-                  return 0;\n-               }\n-         };\n-         public:\n-         SpirvProgram(Backend *backend, BuildInfo *buildInfo ):Backend::Program(backend, buildInfo){\n-         }\n-         ~SpirvProgram(){\n-         }\n-         long getKernel(int nameLen, char *name){\n+class SpirvBackend : public Backend {\n+public:\n+    class SpirvConfig : public Backend::Config {\n+    public :\n+    };\n+\n+    class SpirvProgram : public Backend::Program {\n+        class SpirvKernel : public Backend::Program::Kernel {\n+        public:\n+            SpirvKernel(Backend::Program *program)\n+                    : Backend::Program::Kernel(program) {\n+            }\n+\n+            ~SpirvKernel() {\n+            }\n+\n+            long ndrange(int range, void *argArray) {\n+                std::cout << \"spirv ndrange(\" << range << \") \" << std::endl;\n+                return 0;\n+            }\n+        };\n+\n+    public:\n+        SpirvProgram(Backend *backend, BuildInfo *buildInfo)\n+                : Backend::Program(backend, buildInfo) {\n+        }\n+\n+        ~SpirvProgram() {\n+        }\n+\n+        long getKernel(int nameLen, char *name) {\n@@ -51,2 +59,3 @@\n-         }\n-         bool programOK(){\n+        }\n+\n+        bool programOK() {\n@@ -54,2 +63,2 @@\n-         }\n-      };\n+        }\n+    };\n@@ -57,1 +66,1 @@\n-   public:\n+public:\n@@ -59,7 +68,8 @@\n-      SpirvBackend(SpirvConfig *spirvConfig, int spirvConfigSchemeLen, char *spirvBackendSchema):Backend(spirvConfig,spirvConfigSchemeLen,spirvBackendSchema) {\n-         if (spirvConfig == nullptr){\n-            std::cout << \"spirvConfig == null\"<< std::endl;\n-         }else{\n-            std::cout << \"spirvConfig != null\" <<std::endl;\n-         }\n-      }\n+    SpirvBackend(SpirvConfig *spirvConfig, int spirvConfigSchemeLen, char *spirvBackendSchema)\n+            : Backend(spirvConfig, spirvConfigSchemeLen, spirvBackendSchema) {\n+        if (spirvConfig == nullptr) {\n+            std::cout << \"spirvConfig == null\" << std::endl;\n+        } else {\n+            std::cout << \"spirvConfig != null\" << std::endl;\n+        }\n+    }\n@@ -67,2 +77,2 @@\n-      ~SpirvBackend() {\n-      }\n+    ~SpirvBackend() {\n+    }\n@@ -70,4 +80,4 @@\n-      int getMaxComputeUnits(){\n-         std::cout << \"spirv getMaxComputeUnits()\"<<std::endl;\n-         return 0;\n-      }\n+    int getMaxComputeUnits() {\n+        std::cout << \"spirv getMaxComputeUnits()\" << std::endl;\n+        return 0;\n+    }\n@@ -75,3 +85,3 @@\n-      void info(){\n-         std::cout << \"spirv info()\"<<std::endl;\n-      }\n+    void info() {\n+        std::cout << \"spirv info()\" << std::endl;\n+    }\n@@ -79,9 +89,9 @@\n-      long compileProgram(int len, char *source){\n-         std::cout << \"spirv compileProgram()\"<<std::endl;\n-         size_t srcLen = ::strlen(source);\n-         char *src = new char[srcLen + 1];\n-         ::strncpy(src, source, srcLen);\n-         src[srcLen] = '\\0';\n-         std::cout << \"native compiling \" << src << std::endl;\n-         return (long) new SpirvProgram(this, new BuildInfo(src, nullptr,false));\n-      }\n+    long compileProgram(int len, char *source) {\n+        std::cout << \"spirv compileProgram()\" << std::endl;\n+        size_t srcLen = ::strlen(source);\n+        char *src = new char[srcLen + 1];\n+        ::strncpy(src, source, srcLen);\n+        src[srcLen] = '\\0';\n+        std::cout << \"native compiling \" << src << std::endl;\n+        return (long) new SpirvProgram(this, new BuildInfo(src, nullptr, false));\n+    }\n@@ -90,3 +100,3 @@\n-long getBackend(void *config, int configSchemaLen, char *configSchema){\n-   SpirvBackend::SpirvConfig *spirvConfig = (SpirvBackend::SpirvConfig*)config;\n-   return (long)new SpirvBackend(spirvConfig,configSchemaLen,configSchema);\n+long getBackend(void *config, int configSchemaLen, char *configSchema) {\n+    SpirvBackend::SpirvConfig *spirvConfig = (SpirvBackend::SpirvConfig *) config;\n+    return (long) new SpirvBackend(spirvConfig, configSchemaLen, configSchema);\n","filename":"hat\/backends\/spirv\/cpp\/spirv_backend.cpp","additions":66,"deletions":56,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+out\n","filename":"hat\/intellij\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"}]}