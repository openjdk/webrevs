{"files":[{"patch":"@@ -140,2 +140,3 @@\n-                if (op instanceof OnnxOp) {\n-                    int di = op.opName().lastIndexOf('.');\n+                if (op instanceof OnnxOp oop) {\n+                    String name = oop.schema().name();\n+                    int di = name.lastIndexOf('.');\n@@ -143,1 +144,1 @@\n-                        String dn = op.opName().substring(0, di);\n+                        String dn = name.substring(0, di);\n@@ -266,1 +267,1 @@\n-                            ifOp.opName(),\n+                            ifOp.schema().name(),\n@@ -273,1 +274,1 @@\n-                    opNodes.accept(node(loopOp.opName(),\n+                    opNodes.accept(node(loopOp.schema().name(),\n@@ -281,1 +282,1 @@\n-                            onnxOp.opName(),\n+                            onnxOp.schema().name(),\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-                    assert !(op instanceof Op.Terminating) : op.opName();\n+                    assert !(op instanceof Op.Terminating) : op;\n@@ -265,1 +265,1 @@\n-                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to));\n@@ -463,1 +463,1 @@\n-                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -468,1 +468,1 @@\n-                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -473,1 +473,1 @@\n-                MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+                MethodHandle mh = opHandle(l, o.externalizeOpName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -494,1 +494,1 @@\n-                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to));\n@@ -459,1 +459,1 @@\n-                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -464,1 +464,1 @@\n-                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -469,1 +469,1 @@\n-                MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+                MethodHandle mh = opHandle(l, o.externalizeOpName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -491,1 +491,1 @@\n-                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/PartialEvaluator.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+    final OnnxSchema schema;\n@@ -233,1 +234,1 @@\n-        super(def.name(), def.operands());\n+        super(def.operands());\n@@ -235,0 +236,1 @@\n+        this.schema = schema;\n@@ -260,0 +262,1 @@\n+        this.schema = that.schema;\n@@ -270,1 +273,1 @@\n-        super(schema.name(), concatValues(inputArguments));\n+        super(concatValues(inputArguments));\n@@ -272,0 +275,1 @@\n+        this.schema = schema;\n@@ -334,0 +338,5 @@\n+    @Override\n+    public String externalizeOpName() {\n+        return schema.name();\n+    }\n+\n@@ -346,0 +355,4 @@\n+    public OnnxSchema schema() {\n+        return schema;\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+        private static final String NAME = \"fma\";\n@@ -80,1 +81,0 @@\n-        private static final String NAME = \"fma\";\n@@ -83,1 +83,1 @@\n-            super(NAME, operands);\n+            super(operands);\n@@ -103,2 +103,2 @@\n-        public Map<String, Object> externalize() {\n-            return Map.of(\"\", this.typeElement);\n+        public String externalizeOpName() {\n+            return NAME;\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectFMAOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-        FMAIntrinsicOp(String opName, TypeElement typeDescriptor, List<Value> operands) {\n-            super(opName, operands);\n+        FMAIntrinsicOp(TypeElement typeDescriptor, List<Value> operands) {\n+            super(operands);\n@@ -95,2 +95,2 @@\n-        public Map<String, Object> externalize() {\n-            return Map.of(\"\", \"dialect.\" + this.opName());\n+        public String externalizeOpName() {\n+            return \"intrinsicsFMA\";\n@@ -123,1 +123,1 @@\n-                FMAIntrinsicOp myCustomFunction = new FMAIntrinsicOp(\"intrinsicsFMA\", invokeOp.resultType(), outputOperands);\n+                FMAIntrinsicOp myCustomFunction = new FMAIntrinsicOp(invokeOp.resultType(), outputOperands);\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/DialectWithInvoke.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+    private final String opName;\n@@ -40,1 +41,2 @@\n-        super(opName, List.of());\n+        super(List.of());\n+        this.opName = opName;\n@@ -45,1 +47,2 @@\n-        super(opName, operands);\n+        super(operands);\n+        this.opName = opName;\n@@ -50,1 +53,2 @@\n-        super(opName, operands);\n+        super(operands);\n+        this.opName = opName;\n@@ -56,0 +60,1 @@\n+        this.opName = that.opName;\n@@ -63,0 +68,5 @@\n+\n+    @Override\n+    public String externalizeOpName() {\n+        return opName;\n+    }\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+        final String opName;\n@@ -43,1 +44,1 @@\n-            super(def.name(), def.operands());;\n+            super(def.operands());\n@@ -45,0 +46,1 @@\n+            this.opName = def.name();\n@@ -51,0 +53,1 @@\n+            this.opName = that.opName;\n@@ -55,1 +58,1 @@\n-            super(name, operands);\n+            super(operands);\n@@ -57,0 +60,1 @@\n+            this.opName = name;\n@@ -64,0 +68,5 @@\n+\n+        @Override\n+        public String externalizeOpName() {\n+            return opName;\n+        }\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-        if (op.opName().equals(\"tt.func\")) {\n+        if (op.externalizeOpName().equals(\"tt.func\")) {\n@@ -526,1 +526,1 @@\n-        } else if (op.opName().equals(\"tt.load\")) {\n+        } else if (op.externalizeOpName().equals(\"tt.load\")) {\n@@ -529,1 +529,1 @@\n-        } else if (op.opName().equals(\"arith.constant\")) {\n+        } else if (op.externalizeOpName().equals(\"arith.constant\")) {\n@@ -549,1 +549,1 @@\n-        if (op.opName().equals(\"tuple.load\")) {\n+        if (op.externalizeOpName().equals(\"tuple.load\")) {\n@@ -552,1 +552,1 @@\n-        if (op.opName() == \"unreachable\") {\n+        if (op.externalizeOpName() == \"unreachable\") {\n@@ -559,1 +559,1 @@\n-                if (op.opName().equals(\"scf.for\")) {\n+                if (op.externalizeOpName().equals(\"scf.for\")) {\n@@ -561,1 +561,1 @@\n-                } else if (op.opName().equals(\"tuple.load\")) {\n+                } else if (op.externalizeOpName().equals(\"tuple.load\")) {\n@@ -569,1 +569,1 @@\n-        if (op.opName().equals(\"module\"))\n+        if (op.externalizeOpName().equals(\"module\"))\n@@ -571,1 +571,1 @@\n-        write(op.opName());\n+        write(op.externalizeOpName());\n@@ -620,1 +620,1 @@\n-            if (op.opName().equals(\"arith.constant\")) {\n+            if (op.externalizeOpName().equals(\"arith.constant\")) {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/MLIRGenerator.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-            super(def.name(), def.operands());;\n+            super(def.operands());\n@@ -90,1 +90,1 @@\n-            super(NAME, range);\n+            super(range);\n@@ -100,0 +100,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -116,1 +121,1 @@\n-            super(def.name(), def.operands());\n+            super(def.operands());\n@@ -129,1 +134,1 @@\n-            super(NAME, values);\n+            super(values);\n@@ -137,0 +142,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            super(def.name(), def.operands());\n+            super(def.operands());\n@@ -56,2 +56,2 @@\n-        TritonOp(String name, TypeElement resultType, List<? extends Value> operands) {\n-            super(name, operands);\n+        TritonOp(TypeElement resultType, List<? extends Value> operands) {\n+            super(operands);\n@@ -66,0 +66,7 @@\n+\n+        @Override\n+        public String externalizeOpName() {\n+            OpFactoryHelper.OpDeclaration opDecl = this.getClass().getDeclaredAnnotation(OpFactoryHelper.OpDeclaration.class);\n+            assert opDecl != null : this.getClass().getName();\n+            return opDecl.value();\n+        }\n@@ -113,1 +120,1 @@\n-            super(NAME, JavaType.VOID,\n+            super(JavaType.VOID,\n@@ -210,1 +217,1 @@\n-            super(NAME, JavaType.VOID,\n+            super(JavaType.VOID,\n@@ -285,1 +292,1 @@\n-            super(NAME, resultType, args);\n+            super(resultType, args);\n@@ -360,1 +367,1 @@\n-            super(NAME, reducerBuilder.bodyType().returnType(), List.of(tensor));\n+            super(reducerBuilder.bodyType().returnType(), List.of(tensor));\n@@ -403,1 +410,1 @@\n-            super(NAME, JavaType.VOID, List.of(r));\n+            super(JavaType.VOID, List.of(r));\n@@ -441,1 +448,1 @@\n-            super(NAME, JavaType.INT, List.of());\n+            super(JavaType.INT, List.of());\n@@ -499,1 +506,1 @@\n-            super(NAME, tensorType(start, end), List.of());\n+            super(tensorType(start, end), List.of());\n@@ -551,1 +558,1 @@\n-            super(NAME, tensorType, List.of(v));\n+            super(tensorType, List.of(v));\n@@ -584,1 +591,1 @@\n-            super(NAME, tensorType, List.of(v));\n+            super(tensorType, List.of(v));\n@@ -606,1 +613,1 @@\n-            super(NAME, tensorType, List.of(v));\n+            super(tensorType, List.of(v));\n@@ -628,1 +635,1 @@\n-            super(NAME, ptr.type(), List.of(ptr, offset));\n+            super(ptr.type(), List.of(ptr, offset));\n@@ -650,1 +657,1 @@\n-            super(NAME, tensorType, List.of(ptr, mask));\n+            super(tensorType, List.of(ptr, mask));\n@@ -654,1 +661,1 @@\n-            super(NAME, tensorType, List.of(ptr, mask, other));\n+            super(tensorType, List.of(ptr, mask, other));\n@@ -676,1 +683,1 @@\n-            super(NAME, JavaType.VOID, List.of(ptr, v, mask));\n+            super(JavaType.VOID, List.of(ptr, v, mask));\n@@ -698,1 +705,1 @@\n-            super(NAME, JavaType.VOID, List.of());\n+            super(JavaType.VOID, List.of());\n@@ -702,1 +709,1 @@\n-            super(NAME, JavaType.VOID, List.of(v));\n+            super(JavaType.VOID, List.of(v));\n@@ -724,1 +731,1 @@\n-            super(NAME, tensorType, List.of(a, b, c));\n+            super(tensorType, List.of(a, b, c));\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            super(def.name(), def.operands());\n+            super(def.operands());\n@@ -55,1 +55,1 @@\n-            super(NAME, values);\n+            super(values);\n@@ -62,0 +62,5 @@\n+\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-                    TypeElement t = checkWithTypeInterpreter(op, op.opName(), valueTypeMap);\n+                    TypeElement t = checkWithTypeInterpreter(op, op.externalizeOpName(), valueTypeMap);\n@@ -610,1 +610,1 @@\n-                Value result = tbi.build(op, op.opName(), valueTypeMap);\n+                Value result = tbi.build(op, op.externalizeOpName(), valueTypeMap);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-            super(NAME, operands);\n+            super(operands);\n@@ -195,0 +195,5 @@\n+\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+        private final String opName;\n@@ -54,1 +55,2 @@\n-            super(opName, operands);\n+            super(operands);\n+            this.opName = opName;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-            super(NAME, List.of(ptr));\n+            super(List.of(ptr));\n@@ -345,0 +345,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -379,1 +384,1 @@\n-            super(NAME, List.of(ptr, offset));\n+            super(List.of(ptr, offset));\n@@ -394,0 +399,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -419,1 +429,1 @@\n-            super(NAME, List.of(ptr));\n+            super(List.of(ptr));\n@@ -435,0 +445,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -453,1 +468,1 @@\n-            super(NAME, List.of(ptr));\n+            super(List.of(ptr));\n@@ -472,0 +487,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-            super(NAME, List.of(ptr));\n+            super(List.of(ptr));\n@@ -363,0 +363,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -398,1 +403,1 @@\n-            super(NAME, List.of(ptr, offset));\n+            super(List.of(ptr, offset));\n@@ -420,0 +425,5 @@\n+\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n@@ -439,1 +449,1 @@\n-            super(NAME, List.of(ptr));\n+            super(List.of(ptr));\n@@ -455,0 +465,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -474,1 +489,1 @@\n-            super(NAME, List.of(ptr));\n+            super(List.of(ptr));\n@@ -493,0 +508,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+            private final String opName;\n@@ -71,1 +72,2 @@\n-                super(opName, List.of());\n+                super(List.of());\n+                this.opName = opName;\n@@ -76,1 +78,2 @@\n-                super(opName, operands);\n+                super(operands);\n+                this.opName = opName;\n@@ -81,1 +84,2 @@\n-                super(opName, operands);\n+                super(operands);\n+                this.opName = opName;\n@@ -87,0 +91,1 @@\n+                this.opName = that.opName;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-        write(op.opName());\n+        write(op.externalizeOpName());\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/OpCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+    \/\/ @@@ stable value?\n@@ -275,0 +276,1 @@\n+    \/\/ @@@ stable value?\n@@ -277,2 +279,0 @@\n-    final String name;\n-\n@@ -290,1 +290,1 @@\n-        this(that.name, cc.getValues(that.operands));\n+        this(cc.getValues(that.operands));\n@@ -334,2 +334,1 @@\n-     * @param name       the operation name.\n-     * @param operands   the list of operands, a copy of the list is performed if required.\n+     * @param operands the list of operands, a copy of the list is performed if required.\n@@ -337,2 +336,1 @@\n-    protected Op(String name, List<? extends Value> operands) {\n-        this.name = name;\n+    protected Op(List<? extends Value> operands) {\n@@ -395,0 +393,5 @@\n+    \/**\n+     * {@return the operation's result type}\n+     *\/\n+    public abstract TypeElement resultType();\n+\n@@ -404,7 +407,0 @@\n-    \/**\n-     * {@return the operation name}\n-     *\/\n-    public String opName() {\n-        return name;\n-    }\n-\n@@ -414,1 +410,1 @@\n-    public List<Value> operands() {\n+    public final List<Value> operands() {\n@@ -420,0 +416,1 @@\n+     * @implSpec this implementation returns an unmodifiable empty list.\n@@ -425,5 +422,0 @@\n-    \/**\n-     * {@return the operation's result type}\n-     *\/\n-    public abstract TypeElement resultType();\n-\n@@ -438,1 +430,1 @@\n-    public FunctionType opType() {\n+    public final FunctionType opType() {\n@@ -443,12 +435,0 @@\n-    \/**\n-     * Externalizes the operation's state as a map of attributes.\n-     *\n-     * <p>A null attribute value is represented by the constant\n-     * value {@link jdk.incubator.code.extern.ExternalizedOp#NULL_ATTRIBUTE_VALUE}.\n-     *\n-     * @return the operation's externalized state, as an unmodifiable map\n-     *\/\n-    public Map<String, Object> externalize() {\n-        return Map.of();\n-    }\n-\n@@ -465,1 +445,1 @@\n-    public List<Value> capturedValues() {\n+    public final List<Value> capturedValues() {\n@@ -468,1 +448,4 @@\n-        capturedValues(cvs, new ArrayDeque<>(), this);\n+        Deque<Body> bodyStack = new ArrayDeque<>();\n+        for (Body childBody : bodies()) {\n+            Body.capturedValues(cvs, bodyStack, childBody);\n+        }\n@@ -472,3 +455,13 @@\n-    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Op op) {\n-        for (Body childBody : op.bodies()) {\n-            Body.capturedValues(capturedValues, bodyStack, childBody);\n+    \/**\n+     * Seals this operation. After this operation is sealed its {@link #result result} and {@link #parent parent} are guaranteed to always be {@code null}.\n+     * <p>\n+     * If a sealed operation is {@link Block.Builder#op appended} to a {@link Block.Builder} then it is\n+     * treated as if the operation is bound, and therefore the sealed operation will be transformed.\n+     * <p>\n+     * Sealing is idempotent if the operation is already sealed.\n+     *\n+     * @throws IllegalStateException if this operation is bound.\n+     *\/\n+    public final void seal() {\n+        if (result == Result.SEALED_RESULT) {\n+            return;\n@@ -476,0 +469,35 @@\n+        if (result != null) {\n+            throw new IllegalStateException(\"Operation cannot be sealed since it bound to a parent block\");\n+        }\n+        result = Result.SEALED_RESULT;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this operation is sealed.\n+     * @return {@code true} if this operation is sealed.\n+     * @see #seal()\n+     * *\/\n+    public final boolean isSealed() {\n+        return result == Result.SEALED_RESULT;\n+    }\n+\n+    \/**\n+     * Externalizes this operation's name as a string.\n+     * @implSpec this implementation returns the result of the expression {@code this.getClass().getName()}.\n+     * @return the operation name\n+     *\/\n+    public String externalizeOpName() {\n+        return this.getClass().getName();\n+    }\n+\n+    \/**\n+     * Externalizes this operation's specific state as a map of attributes.\n+     *\n+     * <p>A null attribute value is represented by the constant\n+     * value {@link jdk.incubator.code.extern.ExternalizedOp#NULL_ATTRIBUTE_VALUE}.\n+     * @implSpec this implementation returns an unmodifiable empty map.\n+     *\n+     * @return the operation's externalized state, as an unmodifiable map\n+     *\/\n+    public Map<String, Object> externalize() {\n+        return Map.of();\n@@ -483,1 +511,1 @@\n-    public String toText() {\n+    public final String toText() {\n@@ -610,29 +638,0 @@\n-\n-    \/**\n-     * Seals this operation. After this operation is sealed its {@link #result result} and {@link #parent parent} are guaranteed to always be {@code null}.\n-     * <p>\n-     * If a sealed operation is {@link Block.Builder#op appended} to a {@link Block.Builder} then it is\n-     * treated as if the operation is bound, and therefore the sealed operation will be transformed.\n-     * <p>\n-     * Sealing is idempotent if the operation is already sealed.\n-     *\n-     * @throws IllegalStateException if this operation is bound.\n-     *\/\n-    public void seal() {\n-        if (result == Result.SEALED_RESULT) {\n-            return;\n-        }\n-        if (result != null) {\n-            throw new IllegalStateException(\"Operation cannot be sealed since it bound to a parent block\");\n-        }\n-        result = Result.SEALED_RESULT;\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this operation is sealed.\n-     * @return {@code true} if this operation is sealed.\n-     * @see #seal()\n-    * *\/\n-    public boolean isSealed() {\n-        return result == Result.SEALED_RESULT;\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":67,"deletions":68,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -1152,1 +1152,1 @@\n-                            throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                            throw new UnsupportedOperationException(op + \" on int\");\n@@ -1159,1 +1159,1 @@\n-                            throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                            throw new UnsupportedOperationException(op + \" on Object\");\n@@ -1162,1 +1162,1 @@\n-                    throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+                    throw new UnsupportedOperationException(op + \" on \" + op.operands().get(0).type());\n@@ -1176,1 +1176,1 @@\n-                        throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                        throw new UnsupportedOperationException(op + \" on int\");\n@@ -1183,1 +1183,1 @@\n-                        throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                        throw new UnsupportedOperationException(op + \" on Object\");\n@@ -1198,1 +1198,1 @@\n-                throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+                throw new UnsupportedOperationException(op + \" on \" + op.operands().get(0).type());\n@@ -1225,1 +1225,1 @@\n-                throw new UnsupportedOperationException(op.opName());\n+                throw new UnsupportedOperationException(op.toString());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    protected SlotOp(String name, List<? extends Value> operands, int slot) {\n-        super(name, operands);\n+    protected SlotOp(List<? extends Value> operands, int slot) {\n+        super(operands);\n@@ -83,0 +83,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -106,1 +111,1 @@\n-            super(NAME, List.of(), slot);\n+            super(List.of(), slot);\n@@ -130,0 +135,5 @@\n+        @Override\n+        public String externalizeOpName() {\n+            return NAME;\n+        }\n+\n@@ -150,1 +160,1 @@\n-            super(NAME, List.of(v), slot);\n+            super(List.of(v), slot);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotOp.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -51,2 +51,9 @@\n-    protected CoreOp(String name, List<? extends Value> operands) {\n-        super(name, operands);\n+    protected CoreOp(List<? extends Value> operands) {\n+        super(operands);\n+    }\n+\n+    @Override\n+    public String externalizeOpName() {\n+        OpDeclaration opDecl = this.getClass().getDeclaredAnnotation(OpDeclaration.class);\n+        assert opDecl != null : this.getClass().getName();\n+        return opDecl.value();\n@@ -124,1 +131,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -203,1 +210,1 @@\n-            super(NAME, args);\n+            super(args);\n@@ -274,1 +281,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -343,1 +350,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -367,5 +374,0 @@\n-        @Override\n-        public List<Value> capturedValues() {\n-            return quotedBody.capturedValues();\n-        }\n-\n@@ -430,2 +432,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(List.of());\n@@ -451,5 +452,0 @@\n-        @Override\n-        public List<Value> capturedValues() {\n-            return body.capturedValues();\n-        }\n-\n@@ -492,1 +488,1 @@\n-            super(NAME, args);\n+            super(args);\n@@ -530,1 +526,1 @@\n-            super(NAME, operand == null ? List.of() : List.of(operand));\n+            super(operand == null ? List.of() : List.of(operand));\n@@ -576,1 +572,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -614,1 +610,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -618,1 +614,1 @@\n-            super(NAME, operands);\n+            super(operands);\n@@ -668,1 +664,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -724,1 +720,1 @@\n-            super(NAME, List.of(p));\n+            super(List.of(p));\n@@ -819,1 +815,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -894,1 +890,1 @@\n-            super(NAME, def.operands());\n+            super(def.operands());\n@@ -918,1 +914,1 @@\n-            super(NAME, init == null ? List.of() : List.of(init));\n+            super(init == null ? List.of() : List.of(init));\n@@ -968,2 +964,2 @@\n-        VarAccessOp(String name, List<Value> operands) {\n-            super(name, operands);\n+        VarAccessOp(List<Value> operands) {\n+            super(operands);\n@@ -1025,1 +1021,1 @@\n-                super(NAME, List.of(varValue));\n+                super(List.of(varValue));\n@@ -1056,2 +1052,1 @@\n-                super(NAME,\n-                        values);\n+                super(values);\n@@ -1067,1 +1062,1 @@\n-                super(NAME, List.of(varValue, v));\n+                super(List.of(varValue, v));\n@@ -1095,1 +1090,1 @@\n-            this(cc.getValues(that.operands()));\n+            super(that, cc);\n@@ -1104,1 +1099,1 @@\n-            super(NAME, componentValues);\n+            super(componentValues);\n@@ -1137,5 +1132,1 @@\n-            this(that, cc.getValues(that.operands()));\n-        }\n-\n-        TupleLoadOp(TupleLoadOp that, List<Value> values) {\n-            super(NAME, values);\n+            super(that, cc);\n@@ -1152,1 +1143,1 @@\n-            super(NAME, List.of(tupleValue));\n+            super(List.of(tupleValue));\n@@ -1198,5 +1189,1 @@\n-            this(that, cc.getValues(that.operands()));\n-        }\n-\n-        TupleWithOp(TupleWithOp that, List<Value> values) {\n-            super(NAME, values);\n+            super(that, cc);\n@@ -1213,1 +1200,1 @@\n-            super(NAME, List.of(tupleValue, value));\n+            super(List.of(tupleValue, value));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":35,"deletions":48,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -72,2 +72,9 @@\n-    protected JavaOp(String name, List<? extends Value> operands) {\n-        super(name, operands);\n+    protected JavaOp(List<? extends Value> operands) {\n+        super(operands);\n+    }\n+\n+    @Override\n+    public String externalizeOpName() {\n+        OpDeclaration opDecl = this.getClass().getDeclaredAnnotation(OpDeclaration.class);\n+        assert opDecl != null : this.getClass().getName();\n+        return opDecl.value();\n@@ -219,2 +226,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(List.of());\n@@ -246,5 +252,0 @@\n-        @Override\n-        public List<Value> capturedValues() {\n-            return body.capturedValues();\n-        }\n-\n@@ -432,1 +433,1 @@\n-            super(NAME, List.of(e));\n+            super(List.of(e));\n@@ -459,1 +460,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -496,2 +497,2 @@\n-        MonitorOp(String name, Value monitor) {\n-            super(name, List.of(monitor));\n+        MonitorOp(Value monitor) {\n+            super(List.of(monitor));\n@@ -534,1 +535,1 @@\n-                super(NAME, monitor);\n+                super(monitor);\n@@ -563,1 +564,1 @@\n-                super(NAME, monitor);\n+                super(monitor);\n@@ -657,1 +658,1 @@\n-            super(NAME, args);\n+            super(args);\n@@ -764,1 +765,1 @@\n-            super(NAME, List.of(arg));\n+            super(List.of(arg));\n@@ -823,1 +824,1 @@\n-            super(NAME, args);\n+            super(args);\n@@ -884,1 +885,1 @@\n-        FieldAccessOp(String name, List<Value> operands,\n+        FieldAccessOp(List<Value> operands,\n@@ -886,1 +887,1 @@\n-            super(name, operands);\n+            super(operands);\n@@ -942,1 +943,1 @@\n-                super(NAME, List.of(receiver), descriptor);\n+                super(List.of(receiver), descriptor);\n@@ -949,1 +950,1 @@\n-                super(NAME, List.of(), descriptor);\n+                super(List.of(), descriptor);\n@@ -998,1 +999,1 @@\n-                super(NAME, List.of(receiver, v), descriptor);\n+                super(List.of(receiver, v), descriptor);\n@@ -1003,1 +1004,1 @@\n-                super(NAME, List.of(v), descriptor);\n+                super(List.of(v), descriptor);\n@@ -1036,1 +1037,1 @@\n-            super(NAME, List.of(array));\n+            super(List.of(array));\n@@ -1052,5 +1053,1 @@\n-            this(that, cc.getValues(that.operands()));\n-        }\n-\n-        ArrayAccessOp(ArrayAccessOp that, List<Value> operands) {\n-            super(that.opName(), operands);\n+            super(that, cc);\n@@ -1059,3 +1056,2 @@\n-        ArrayAccessOp(String name,\n-                      Value array, Value index, Value v) {\n-            super(name, operands(array, index, v));\n+        ArrayAccessOp(Value array, Value index, Value v) {\n+            super(operands(array, index, v));\n@@ -1104,1 +1100,1 @@\n-                super(NAME, array, index, null);\n+                super(array, index, null);\n@@ -1141,1 +1137,1 @@\n-                super(NAME, array, index, v);\n+                super(array, index, v);\n@@ -1188,1 +1184,1 @@\n-            super(NAME, List.of(v));\n+            super(List.of(v));\n@@ -1246,1 +1242,1 @@\n-            super(NAME, List.of(v));\n+            super(List.of(v));\n@@ -1297,1 +1293,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -1300,1 +1296,1 @@\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+                throw new IllegalArgumentException(\"Operation must have two or more successors \" + this);\n@@ -1353,1 +1349,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -1356,1 +1352,1 @@\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+                throw new IllegalArgumentException(\"Operation must have two or more successors \" + this);\n@@ -1403,1 +1399,1 @@\n-            super(ConcatOp.NAME, List.of(lhs, rhs));\n+            super(List.of(lhs, rhs));\n@@ -1426,2 +1422,2 @@\n-        protected ArithmeticOperation(String name, List<Value> operands) {\n-            super(name, operands);\n+        protected ArithmeticOperation(List<Value> operands) {\n+            super(operands);\n@@ -1440,2 +1436,2 @@\n-        protected TestOperation(String name, List<Value> operands) {\n-            super(name, operands);\n+        protected TestOperation(List<Value> operands) {\n+            super(operands);\n@@ -1453,2 +1449,2 @@\n-        protected BinaryOp(String name, Value lhs, Value rhs) {\n-            super(name, List.of(lhs, rhs));\n+        protected BinaryOp(Value lhs, Value rhs) {\n+            super(List.of(lhs, rhs));\n@@ -1471,2 +1467,2 @@\n-        protected UnaryOp(String name, Value v) {\n-            super(name, List.of(v));\n+        protected UnaryOp(Value v) {\n+            super(List.of(v));\n@@ -1489,2 +1485,2 @@\n-        protected BinaryTestOp(String name, Value lhs, Value rhs) {\n-            super(name, List.of(lhs, rhs));\n+        protected BinaryTestOp(Value lhs, Value rhs) {\n+            super(List.of(lhs, rhs));\n@@ -1520,1 +1516,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1545,1 +1541,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1570,1 +1566,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1595,1 +1591,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1620,1 +1616,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1646,1 +1642,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1672,1 +1668,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1698,1 +1694,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1723,1 +1719,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1748,1 +1744,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1773,1 +1769,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1798,1 +1794,1 @@\n-            super(NAME, v);\n+            super(v);\n@@ -1823,1 +1819,1 @@\n-            super(NAME, v);\n+            super(v);\n@@ -1848,1 +1844,1 @@\n-            super(NAME, v);\n+            super(v);\n@@ -1874,1 +1870,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1900,1 +1896,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1925,1 +1921,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1951,1 +1947,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -1977,1 +1973,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -2003,1 +1999,1 @@\n-            super(NAME, lhs, rhs);\n+            super(lhs, rhs);\n@@ -2016,2 +2012,2 @@\n-        JavaLabelOp(String name, Value label) {\n-            super(name, checkLabel(label));\n+        JavaLabelOp(Value label) {\n+            super(checkLabel(label));\n@@ -2112,1 +2108,1 @@\n-            super(NAME, label);\n+            super(label);\n@@ -2142,1 +2138,1 @@\n-            super(NAME, label);\n+            super(label);\n@@ -2198,1 +2194,1 @@\n-            super(NAME, operand == null ? List.of() : List.of(operand));\n+            super(operand == null ? List.of() : List.of(operand));\n@@ -2281,1 +2277,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -2353,1 +2349,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -2503,1 +2499,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -2672,1 +2668,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -2784,2 +2780,2 @@\n-        JavaSwitchOp(String name, Value target, List<Body.Builder> bodyCs) {\n-            super(name, List.of(target));\n+        JavaSwitchOp(Value target, List<Body.Builder> bodyCs) {\n+            super(List.of(target));\n@@ -2941,1 +2937,1 @@\n-            super(NAME, target, bodyCs);\n+            super(target, bodyCs);\n@@ -2974,1 +2970,1 @@\n-            super(NAME, target, bodyCs);\n+            super(target, bodyCs);\n@@ -3006,1 +3002,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3165,1 +3161,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3381,1 +3377,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3562,1 +3558,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3568,1 +3564,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3694,1 +3690,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3700,1 +3696,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -3790,2 +3786,2 @@\n-        JavaConditionalOp(String name, List<Body.Builder> bodyCs) {\n-            super(name, List.of());\n+        JavaConditionalOp(List<Body.Builder> bodyCs) {\n+            super(List.of());\n@@ -3915,1 +3911,1 @@\n-            super(NAME, bodyCs);\n+            super(bodyCs);\n@@ -3970,1 +3966,1 @@\n-            super(NAME, bodyCs);\n+            super(bodyCs);\n@@ -4015,1 +4011,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -4202,1 +4198,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -4553,2 +4549,2 @@\n-            PatternOp(String name, List<Value> operands) {\n-                super(name, operands);\n+            PatternOp(List<Value> operands) {\n+                super(operands);\n@@ -4571,1 +4567,1 @@\n-                super(NAME, List.of());\n+                super(List.of());\n@@ -4596,1 +4592,1 @@\n-                super(NAME, List.of());\n+                super(List.of());\n@@ -4657,1 +4653,1 @@\n-                super(NAME, List.copyOf(nestedPatterns));\n+                super(List.copyOf(nestedPatterns));\n@@ -4698,1 +4694,1 @@\n-                super(NAME, List.of());\n+                super(List.of());\n@@ -4740,2 +4736,1 @@\n-                super(NAME,\n-                        List.of(target));\n+                super(List.of(target));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":101,"deletions":106,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                op.opName(),\n+                op.externalizeOpName(),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/ExternalizedOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-        write(op.opName());\n+        write(op.externalizeOpName());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,2 @@\n-        return func(\"builder.\" + op.opName(), builder.parentBody());\n+        \/\/ @@@ avoid use of opName\n+        return func(\"builder.\" + op.getClass().getName(), builder.parentBody());\n@@ -220,1 +221,1 @@\n-                inputOp.opName(),\n+                inputOp.externalizeOpName(),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-                    assert !(op instanceof Op.Terminating) : op.opName();\n+                    assert !(op instanceof Op.Terminating) : op;\n@@ -407,1 +407,1 @@\n-                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to));\n@@ -602,1 +602,2 @@\n-            MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+            \/\/ @@@ avoid use of opName\n+            MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -606,1 +607,2 @@\n-            MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+            \/\/ @@@ avoid use of opName\n+            MethodHandle mh = opHandle(l, o.externalizeOpName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -648,1 +650,1 @@\n-                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-                    throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+                    throw new UnsupportedOperationException(\"Operation not supported: \" + op);\n@@ -208,1 +208,1 @@\n-            default -> throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+            default -> throw new UnsupportedOperationException(\"Operation not supported: \" + op);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            super(NAME, List.of());\n+            super(List.of());\n@@ -136,1 +136,1 @@\n-            super(AnfLetRecOp.NAME, List.of());\n+            super(List.of());\n@@ -224,1 +224,1 @@\n-            super(NAME, List.of(test));\n+            super(List.of(test));\n@@ -309,1 +309,1 @@\n-            super(NAME,\n+            super(\n@@ -367,1 +367,1 @@\n-            super(AnfApply.NAME, arguments);\n+            super(arguments);\n@@ -417,1 +417,1 @@\n-            super(AnfApplyStub.NAME, arguments);\n+            super(arguments);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/AnfDialect.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-                        throw new UnsupportedOperationException(\"Unsupported terminator encountered: \" + o.opName());\n+                        throw new UnsupportedOperationException(\"Unsupported terminator encountered: \" + o);\n@@ -194,1 +194,1 @@\n-        throw new RuntimeException(\"Encountered Block with no return \" + op.opName());\n+        throw new RuntimeException(\"Encountered Block with no return \" + op);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/AnfTransformer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-                    verifyOpHandleExists(op, op.opName());\n+                    verifyOpHandleExists(op, op.externalizeOpName());\n@@ -137,1 +137,1 @@\n-                    verifyOpHandleExists(op, op.opName() + \"_\" + op.opType().returnType());\n+                    verifyOpHandleExists(op, op.externalizeOpName() + \"_\" + op.opType().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/Verifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to));\n@@ -458,1 +458,2 @@\n-                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                \/\/ @@@ TODO avoid use of opName\n+                MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -463,1 +464,2 @@\n-                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                \/\/ @@@ TODO avoid use of opName\n+                MethodHandle mh = opHandle(l, o.externalizeOpName(), o.opType());\n@@ -468,1 +470,2 @@\n-                MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+                \/\/ @@@ TODO avoid use of opName\n+                MethodHandle mh = opHandle(l, o.externalizeOpName() + \"_\" + o.opType().returnType(), o.opType());\n@@ -490,1 +493,1 @@\n-                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/PartialEvaluator.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            super(\"test-op\", List.of());\n+            super(List.of());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestAttributeSerialization.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}