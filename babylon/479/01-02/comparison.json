{"files":[{"patch":"@@ -86,1 +86,1 @@\n-                computeContext.computeCallGraph.entrypoint.lowered.op().writeTo(System.out);\n+                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op().toText());\n@@ -162,1 +162,1 @@\n-                returnFOW.op().writeTo(System.out);\n+                System.out.println(returnFOW.op().toText());\n@@ -232,1 +232,1 @@\n-                returnFOW.op().writeTo(System.out);\n+                System.out.println(returnFOW.op().toText());\n@@ -237,1 +237,1 @@\n-                returnFOW.op().writeTo(System.out);\n+                System.out.println(returnFOW.op().toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                computeContext.computeCallGraph.entrypoint.lowered.op().writeTo(System.out);\n+                System.out.println(computeContext.computeCallGraph.entrypoint.lowered.op().toText());\n@@ -97,1 +97,1 @@\n-            returnFOW.op().writeTo(System.out);\n+            System.out.println(returnFOW.op().toText());\n@@ -130,1 +130,1 @@\n-            returnFOW.op().writeTo(System.out);\n+            System.out.println(returnFOW.op().toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        f.writeTo(System.out);\n+        System.out.println(f.toText());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    public class TestLambdaMethodRef {\n+    public static class TestLambdaMethodRef {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/TestQuoted.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-            transformed.writeTo(System.out);\n+            System.out.println(transformed.toText());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,23 +229,0 @@\n-    \/**\n-     * Finds the child of this element that is an ancestor of the given descendant element,\n-     * otherwise returns the descendant element if a child of this element, otherwise\n-     * returns {@code null} if there is no such child.\n-     *\n-     * @param descendant the descendant element\n-     * @return the child that is an ancestor of the given descendant element, otherwise the descendant\n-     * element if a child of this element, otherwise {@code null}.\n-     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n-     *\/\n-    default C findChildAncestor(CodeElement<?, ?> descendant) {\n-        Objects.requireNonNull(descendant);\n-\n-        CodeElement<?, ?> e = descendant;\n-        while (e != null && e.parent() != this) {\n-            e = e.parent();\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        C child = (C) e;\n-        return child;\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeElement.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-                useOp = block.findChildAncestor(useOp);\n+                useOp = findChildAncestor(block, useOp);\n@@ -204,1 +204,1 @@\n-            Block B = CFG.findChildAncestor(use.declaringBlock());\n+            Block B = findChildAncestor(CFG, use.declaringBlock());\n@@ -329,0 +329,23 @@\n+    \/**\n+     * Finds the child of the parent element that is an ancestor of the given descendant element,\n+     * otherwise returns the descendant element if a child of this element, otherwise\n+     * returns {@code null} if there is no such child.\n+     *\n+     * @param parent the parent element\n+     * @param descendant the descendant element\n+     * @return the child that is an ancestor of the given descendant element, otherwise the descendant\n+     * element if a child of this element, otherwise {@code null}.\n+     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n+     *\/\n+    private static <C extends CodeElement<C, ?>> C findChildAncestor(CodeElement<?, C> parent, CodeElement<?, ?> descendant) {\n+        Objects.requireNonNull(descendant);\n+\n+        CodeElement<?, ?> e = descendant;\n+        while (e != null && e.parent() != parent) {\n+            e = e.parent();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        C child = (C) e;\n+        return child;\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Liveness.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-                CodeElement<?, ?> aChild = (i == j) ? null : path.get(i + 1);\n@@ -127,1 +126,1 @@\n-                testAncestors(a, aChild, e);\n+                testAncestors(a, e);\n@@ -132,1 +131,1 @@\n-    static void testAncestors(CodeElement<?, ?> a, CodeElement<?, ?> aChild, CodeElement<?, ?> e) {\n+    static void testAncestors(CodeElement<?, ?> a, CodeElement<?, ?> e) {\n@@ -138,2 +137,0 @@\n-        Assert.assertEquals(a.findChildAncestor(e), aChild);\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAncestors.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}