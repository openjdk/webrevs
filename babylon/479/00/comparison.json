{"files":[{"patch":"@@ -170,1 +170,1 @@\n-        var indexer = new Indexer(block.parentBody().parentOp(), Map.of());\n+        var indexer = new Indexer(block.ancestorOp(), Map.of());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-            if (operand.declaringBlock().parentBody() == op.ancestorBody()) {\n+            if (operand.declaringBlock().ancestorBody() == op.ancestorBody()) {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SimpleCountedForLoopInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -811,1 +811,1 @@\n-                    if (!bodyStack.contains(v.declaringBlock().parentBody())) {\n+                    if (!bodyStack.contains(v.declaringBlock().ancestorBody())) {\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        return new BodyWrapper(block().parentBody());\n+        return new BodyWrapper(block().ancestorBody());\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/BlockWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        return new BlockWrapper(op.parentBlock());\n+        return new BlockWrapper(op.ancestorBlock());\n@@ -158,0 +158,1 @@\n+\/\/        return new BodyWrapper(op.ancestorBody());\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Op top = qop.ancestorOp().ancestorOp();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                    declaringBlock().parentBody().parentOp() instanceof Op.Invokable o) {\n+                    declaringBlock().ancestorOp() instanceof Op.Invokable o) {\n@@ -201,9 +201,0 @@\n-    \/**\n-     * Returns this block's parent body.\n-     *\n-     * @return this block's parent body.\n-     *\/\n-    public Body parentBody() {\n-        return parentBody;\n-    }\n-\n@@ -260,22 +251,0 @@\n-    \/**\n-     * Finds the operation in this block that is the ancestor of the given operation.\n-     *\n-     * @param op the given operation.\n-     * @return the operation in this block that is the ancestor of the given operation,\n-     * otherwise {@code null}\n-     *\/\n-    public Op findAncestorOpInBlock(Op op) {\n-        Objects.requireNonNull(op);\n-\n-        while (op != null && op.parentBlock() != this) {\n-            Body encBody = op.ancestorBody();\n-            if (encBody == null) {\n-                return null;\n-            }\n-\n-            op = encBody.parentOp();\n-        }\n-\n-        return op;\n-    }\n-\n@@ -412,1 +381,1 @@\n-        Block b = findBlockForDomBody(this, dom.parentBody());\n+        Block b = findBlockForDomBody(this, dom.ancestorBody());\n@@ -423,1 +392,1 @@\n-        Block entry = b.parentBody().entryBlock();\n+        Block entry = b.ancestorBody().entryBlock();\n@@ -429,1 +398,1 @@\n-        Map<Block, Block> idoms = b.parentBody().immediateDominators();\n+        Map<Block, Block> idoms = b.ancestorBody().immediateDominators();\n@@ -452,1 +421,1 @@\n-        if (this == parentBody().entryBlock()) {\n+        if (this == ancestorBody().entryBlock()) {\n@@ -456,1 +425,1 @@\n-        Map<Block, Block> idoms = parentBody().immediateDominators();\n+        Map<Block, Block> idoms = ancestorBody().immediateDominators();\n@@ -471,1 +440,1 @@\n-        if (this == parentBody().entryBlock()) {\n+        if (this == ancestorBody().entryBlock()) {\n@@ -475,1 +444,1 @@\n-        Map<Block, Block> ipdoms = parentBody().immediatePostDominators();\n+        Map<Block, Block> ipdoms = ancestorBody().immediatePostDominators();\n@@ -483,1 +452,1 @@\n-        Body rb = b.parentBody();\n+        Body rb = b.ancestorBody();\n@@ -487,1 +456,1 @@\n-            b = rb.parentOp().parentBlock();\n+            b = rb.ancestorBlock();\n@@ -492,1 +461,1 @@\n-            rb = b.parentBody();\n+            rb = b.ancestorBody();\n@@ -754,1 +723,1 @@\n-                op = op.ancestorBody().parentOp();\n+                op = op.ancestorOp();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":12,"deletions":43,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -90,9 +90,0 @@\n-    \/**\n-     * Returns this body's parent operation.\n-     *\n-     * @return the body's parent operation.\n-     *\/\n-    public Op parentOp() {\n-        return parentOp;\n-    }\n-\n@@ -132,17 +123,0 @@\n-    \/**\n-     * Finds the block in this body that is the ancestor of the given block.\n-     *\n-     * @param b the given block.\n-     * @return the block in this body that is the ancestor of the given block,\n-     * otherwise {@code null}\n-     *\/\n-    public Block findAncestorBlockInBody(Block b) {\n-        Objects.requireNonNull(b);\n-\n-        while (b != null && b.parentBody() != this) {\n-            b = b.parentBody().parentOp().parentBlock();\n-        }\n-\n-        return b;\n-    }\n-\n@@ -420,2 +394,2 @@\n-            Block eb = r.parentOp().parentBlock();\n-            if (eb == null) {\n+            r = r.ancestorBody();\n+            if (r == null) {\n@@ -424,2 +398,0 @@\n-\n-            r = eb.parentBody();\n@@ -457,1 +429,1 @@\n-                    if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                    if (!bodyStack.contains(a.declaringBlock().ancestorBody())) {\n@@ -464,1 +436,1 @@\n-                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                        if (!bodyStack.contains(a.declaringBlock().ancestorBody())) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Body.java","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -31,0 +32,1 @@\n+import java.util.stream.Gatherer;\n@@ -36,2 +38,6 @@\n- * A code element may have child code elements, and so on, to form a tree. A (root) code element and all its descendants\n- * can be traversed.\n+ * A code may have a parent code element. An unbound code element is an operation, an unbound operation, that has no\n+ * parent block. An unbound operation may also be considered a root operation if never bound. A code element and all its\n+ * ancestors can be traversed, up to and including the unbound or root operation.\n+ * <p>\n+ * A code element may have child code elements, and so on. An unbound or root operation and all its descendants can be\n+ * traversed, down to and including operations with no children. Bodies and blocks have at least one child element.\n@@ -53,1 +59,0 @@\n-    \/\/ Code copied into the compiler cannot depend on new gatherer API\n@@ -55,1 +60,1 @@\n-        return Stream.of(Void.class).gather(() -> (_, _, downstream) -> traversePreOrder(downstream::push));\n+        return Stream.of(Void.class).gather(() -> (_, _, downstream) -> traversePreOrder(downstream));\n@@ -58,3 +63,2 @@\n-\/\/    private boolean traversePreOrder(Gatherer.Downstream<? super CodeElement<?, ?>> v) {\n-    private boolean traversePreOrder(Predicate<? super CodeElement<?, ?>> v) {\n-        if (!v.test(this)) {\n+    private boolean traversePreOrder(Gatherer.Downstream<? super CodeElement<?, ?>> v) {\n+        if (!v.push(this)) {\n@@ -130,4 +134,2 @@\n-     * Returns the parent code element.\n-     * <p>\n-     * If this element is an instance of {@code Op} then the parent may be {@code null}\n-     * if operation is not assigned to a block.\n+     * Returns the parent element, otherwise {@code null}\n+     * if there is no parent.\n@@ -135,1 +137,2 @@\n-     * @return the parent code element\n+     * @return the parent code element.\n+     * @throws IllegalStateException if this element is an operation whose parent block is unbuilt.\n@@ -139,0 +142,110 @@\n+    \/\/ Nearest ancestors\n+\n+    \/**\n+     * Finds the nearest ancestor operation, otherwise {@code null}\n+     * if there is no nearest ancestor.\n+     *\n+     * @return the nearest ancestor operation.\n+     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n+     *\/\n+    default Op ancestorOp() {\n+        return switch (this) {\n+            \/\/ block -> body -> op~\n+            case Block block -> block.parent().parent();\n+            \/\/ body -> op~\n+            case Body body -> body.parent();\n+            \/\/ op -> block? -> body -> op~\n+            case Op op -> {\n+                \/\/ Throws ISE if op is not bound\n+                Block parent = op.parent();\n+                yield parent == null ? null : parent.parent().parent();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Finds the nearest ancestor body, otherwise {@code null}\n+     * if there is no nearest ancestor.\n+     *\n+     * @return the nearest ancestor body.\n+     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n+     *\/\n+    default Body ancestorBody() {\n+        return switch (this) {\n+            \/\/ block -> body\n+            case Block block -> block.parent();\n+            \/\/ body -> op~ -> block? -> body\n+            case Body body -> {\n+                \/\/ Throws ISE if block is partially constructed\n+                Block ancestor = body.parent().parent();\n+                yield ancestor == null ? null : ancestor.parent();\n+            }\n+            \/\/ op~ -> block? -> body\n+            case Op op -> {\n+                \/\/ Throws ISE if op is not bound\n+                Block parent = op.parent();\n+                yield parent == null ? null : parent.parent();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Finds the nearest ancestor block, otherwise {@code null}\n+     * if there is no nearest ancestor.\n+     *\n+     * @return the nearest ancestor block.\n+     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n+     *\/\n+    default Block ancestorBlock() {\n+        return switch (this) {\n+            \/\/ block -> body -> op~ -> block?\n+            \/\/ Throws ISE if op is not bound\n+            case Block block -> block.parent().parent().parent();\n+            \/\/ body -> op~ -> block?\n+            \/\/ Throws ISE if op is not bound\n+            case Body body -> body.parent().parent();\n+            \/\/ op~ -> block?\n+            \/\/ Throws ISE if op is not bound\n+            case Op op -> op.parent();\n+        };\n+    }\n+\n+    \/**\n+     * Returns true if this element is an ancestor of the descendant element.\n+     *\n+     * @param descendant the descendant element.\n+     * @return true if this element is an ancestor of the descendant element.\n+     *\/\n+    default boolean isAncestorOf(CodeElement<?, ?> descendant) {\n+        Objects.requireNonNull(descendant);\n+\n+        CodeElement<?, ?> e = descendant.parent();\n+        while (e != null && e != this) {\n+            e = e.parent();\n+        }\n+        return e != null;\n+    }\n+\n+    \/**\n+     * Finds the child of this element that is an ancestor of the given descendant element,\n+     * otherwise returns the descendant element if a child of this element, otherwise\n+     * returns {@code null} if there is no such child.\n+     *\n+     * @param descendant the descendant element\n+     * @return the child that is an ancestor of the given descendant element, otherwise the descendant\n+     * element if a child of this element, otherwise {@code null}.\n+     * @throws IllegalStateException if an operation with unbuilt parent block is encountered.\n+     *\/\n+    default C findChildAncestor(CodeElement<?, ?> descendant) {\n+        Objects.requireNonNull(descendant);\n+\n+        CodeElement<?, ?> e = descendant;\n+        while (e != null && e.parent() != this) {\n+            e = e.parent();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        C child = (C) e;\n+        return child;\n+    }\n+\n@@ -145,0 +258,5 @@\n+\n+    \/\/ Siblings\n+    \/\/ Left, right\n+\n+    \/\/ Des\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeElement.java","additions":130,"deletions":12,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -308,9 +308,0 @@\n-        return parentBlock();\n-    }\n-\n-    \/**\n-     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n-     *\n-     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n-     *\/\n-    public final Block parentBlock() {\n@@ -350,19 +341,0 @@\n-\n-    \/**\n-     * Returns this operation's nearest ancestor body (the parent body of this operation's parent block),\n-     * otherwise {@code null} if the operation is not assigned to a block.\n-     *\n-     * @return operation's nearest ancestor body, or {@code null} if the operation is not assigned to a block.\n-     *\/\n-    public final Body ancestorBody() {\n-        if (result == null) {\n-            return null;\n-        }\n-\n-        if (!result.block.isBound()) {\n-            throw new IllegalStateException(\"Parent body is partially constructed\");\n-        }\n-\n-        return result.block.parentBody;\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                    && vop.result().uses().stream().noneMatch(u -> u.op().parentBlock() == fblock))\n+                    && vop.result().uses().stream().noneMatch(u -> u.op().ancestorBlock() == fblock))\n@@ -193,1 +193,1 @@\n-            } else if (v.uses().size() > 1 && v.uses().stream().anyMatch(u -> u.op().parentBlock() == fblock)) {\n+            } else if (v.uses().size() > 1 && v.uses().stream().anyMatch(u -> u.op().ancestorBlock() == fblock)) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quoted.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-        Body r1 = b1.parentBody();\n-        Body r2 = b2.parentBody();\n+        Body r1 = b1.ancestorBody();\n+        Body r2 = b2.ancestorBody();\n@@ -178,2 +178,2 @@\n-        Op o1 = r1.parentOp();\n-        Op o2 = r2.parentOp();\n+        Op o1 = r1.ancestorOp();\n+        Op o2 = r2.ancestorOp();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Value.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-                useOp = block.findAncestorOpInBlock(useOp);\n+                useOp = block.findChildAncestor(useOp);\n@@ -204,1 +204,1 @@\n-            Block B = CFG.findAncestorBlockInBody(use.declaringBlock());\n+            Block B = CFG.findChildAncestor(use.declaringBlock());\n@@ -290,1 +290,1 @@\n-        Block block = op.parentBlock();\n+        Block block = op.ancestorBlock();\n@@ -321,1 +321,1 @@\n-        if (thisOp.parentBlock() != thatOp.parentBlock()) {\n+        if (thisOp.ancestorBlock() != thatOp.ancestorBlock()) {\n@@ -325,1 +325,1 @@\n-        List<Op> ops = thisOp.parentBlock().ops();\n+        List<Op> ops = thisOp.ancestorBlock().ops();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Liveness.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                    Val val = readVariable(load.varOp(), load.parentBlock());\n+                    Val val = readVariable(load.varOp(), load.ancestorBlock());\n@@ -95,1 +95,1 @@\n-                        writeVariable(store.varOp(), store.parentBlock(), new Holder(store.storeOperand()));\n+                        writeVariable(store.varOp(), store.ancestorBlock(), new Holder(store.storeOperand()));\n@@ -100,1 +100,1 @@\n-                    writeVariable(initialStore, initialStore.parentBlock(), val);\n+                    writeVariable(initialStore, initialStore.ancestorBlock(), val);\n@@ -103,1 +103,1 @@\n-                    Block block = op.parentBlock();\n+                    Block block = op.ancestorBlock();\n@@ -152,1 +152,1 @@\n-        } else if (block.isEntryBlock() && variable.ancestorBody() != block.parentBody()) {\n+        } else if (block.isEntryBlock() && variable.ancestorBody() != block.ancestorBody()) {\n@@ -228,1 +228,1 @@\n-        Block originalBlock = op.parentBlock();\n+        Block originalBlock = op.ancestorBlock();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSABraun.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                        if (y.isDominatedBy(v.parentBlock())) {\n+                        if (y.isDominatedBy(v.ancestorBlock())) {\n@@ -337,1 +337,1 @@\n-                    stores.computeIfAbsent(storeOp.varOp(), _v -> new LinkedHashSet<>()).add(storeOp.parentBlock());\n+                    stores.computeIfAbsent(storeOp.varOp(), _v -> new LinkedHashSet<>()).add(storeOp.ancestorBlock());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSACytron.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import jdk.incubator.code.dialect.core.CoreType;\n@@ -428,1 +427,1 @@\n-            nextOp = nextOp.parentBlock().nextOp(nextOp);\n+            nextOp = nextOp.ancestorBlock().nextOp(nextOp);\n@@ -443,1 +442,1 @@\n-        if (use.declaringBlock() != op.parentBlock()) {\n+        if (use.declaringBlock() != op.ancestorBlock()) {\n@@ -1075,1 +1074,1 @@\n-        if (p.declaringBlock() != op.parentBlock()) {\n+        if (p.declaringBlock() != op.ancestorBlock()) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-            return \"block_\" + parentBlock().index() + \" \" + parentBlock().ops().indexOf(this) + \": #\" + slot + \" LOAD \" + typeKind();\n+            return \"block_\" + ancestorBlock().index() + \" \" + ancestorBlock().ops().indexOf(this) + \": #\" + slot + \" LOAD \" + typeKind();\n@@ -165,1 +165,1 @@\n-            return \"block_\" + parentBlock().index() + \" \" + parentBlock().ops().indexOf(this) + \": #\" + slot + \" STORE \" + typeKind();\n+            return \"block_\" + ancestorBlock().index() + \" \" + ancestorBlock().ops().indexOf(this) + \": #\" + slot + \" STORE \" + typeKind();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-            b = slotOp.parentBlock();\n+            b = slotOp.ancestorBlock();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotToVarTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                    List<Block> sourceBlocks = b.parentBody().blocks();\n+                    List<Block> sourceBlocks = b.ancestorBody().blocks();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedTypesTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2007,1 +2007,1 @@\n-                op = b.parentOp();\n+                op = b.ancestorOp();\n@@ -2032,1 +2032,1 @@\n-            if (value instanceof Result r && r.op().ancestorBody().parentOp() instanceof LabeledOp lop) {\n+            if (value instanceof Result r && r.op().ancestorOp() instanceof LabeledOp lop) {\n@@ -2206,1 +2206,1 @@\n-                op = b.parentOp();\n+                op = b.ancestorOp();\n@@ -2443,11 +2443,1 @@\n-            return target == this || ifAncestorOp(target, this);\n-        }\n-\n-        static boolean ifAncestorOp(Op ancestor, Op op) {\n-            while (op.ancestorBody() != null) {\n-                op = op.ancestorBody().parentOp();\n-                if (op == ancestor) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return target == this || target.isAncestorOf(this);\n@@ -3021,1 +3011,1 @@\n-            BranchTarget t = getBranchTarget(b.context(), parentBlock().parentBody());\n+            BranchTarget t = getBranchTarget(b.context(), ancestorBody());\n@@ -4549,11 +4539,1 @@\n-            return target == this || ifAncestorOp(target, this);\n-        }\n-\n-        static boolean ifAncestorOp(Op ancestor, Op op) {\n-            while (op.ancestorBody() != null) {\n-                op = op.ancestorBody().parentOp();\n-                if (op == ancestor) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return target == this || target.isAncestorOf(this);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            Block p = b.parentBody().parentOp().parentBlock();\n+            Block p = b.ancestorBlock();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-                yieldContext.b().parentBody() == entry.parentBody().parentOp().ancestorBody();\n+                yieldContext.b().ancestorBody() == entry.ancestorBody().ancestorBody();\n@@ -428,1 +428,1 @@\n-                top = top.ancestorBody().parentOp();\n+                top = top.ancestorOp();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run testng TestAncestors\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static java.lang.System.out;\n+\n+public class TestAncestors {\n+\n+    \/\/ Model with sufficient nested structure\n+    @CodeReflection\n+    static void f() {\n+        out.println(\"X\");\n+        {\n+            out.println(\"X\");\n+            {\n+                out.println(\"X\");\n+            }\n+            out.println(\"X\");\n+            {\n+                out.println(\"X\");\n+            }\n+            out.println(\"X\");\n+        }\n+        out.println(\"X\");\n+        {\n+            out.println(\"X\");\n+            {\n+                out.println(\"X\");\n+            }\n+            out.println(\"X\");\n+            {\n+                out.println(\"X\");\n+            }\n+            out.println(\"X\");\n+        }\n+        out.println(\"X\");\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+        out.println(f.toText());\n+\n+        List<List<CodeElement<?, ?>>> paths = new ArrayList<>();\n+        \/\/ path has pattern of [op, body, block, ... ,body, block, op]\n+        computedPaths(paths,List.of(), f);\n+\n+        testPathPrefix(paths.getFirst());\n+        paths.forEach(TestAncestors::testPathAncestors);\n+    }\n+\n+    static void testPathPrefix(List<CodeElement<?, ?>> path) {\n+        for (int i = 0; i < 3; i++) {\n+            CodeElement<?, ?> a = path.get(i);\n+            testTopElements(a);\n+        }\n+    }\n+\n+    static void testTopElements(CodeElement<?, ?> a) {\n+        switch (a) {\n+            case Op op -> {\n+                Assert.assertNull(op.ancestorOp());\n+                Assert.assertNull(op.ancestorBody());\n+                Assert.assertNull(op.ancestorBlock());\n+            }\n+            case Body body -> {\n+                Assert.assertNotNull(body.ancestorOp());\n+                Assert.assertNull(body.ancestorBody());\n+                Assert.assertNull(body.ancestorBlock());\n+            }\n+            case Block block -> {\n+                Assert.assertNotNull(block.ancestorOp());\n+                Assert.assertNotNull(block.ancestorBody());\n+                Assert.assertNull(block.ancestorBlock());\n+            }\n+        }\n+    }\n+\n+    static void testPathAncestors(List<CodeElement<?, ?>> path) {\n+        Assert.assertTrue(path.size() > 3);\n+        for (int i = 0; i < 3; i++) {\n+            CodeElement<?, ?> a = path.get(i);\n+            int size = path.size() - 1;\n+            for (int j = size; j > size - 3; j--) {\n+                if (j < i) {\n+                    continue;\n+                }\n+\n+                CodeElement<?, ?> aChild = (i == j) ? null : path.get(i + 1);\n+                CodeElement<?, ?> e = path.get(j);\n+                testAncestors(a, aChild, e);\n+            }\n+        }\n+    }\n+\n+    static void testAncestors(CodeElement<?, ?> a, CodeElement<?, ?> aChild, CodeElement<?, ?> e) {\n+        Assert.assertTrue(isSameOrAncestorUsingParent(e, a));\n+        if (a != e) {\n+            Assert.assertTrue(a.isAncestorOf(e));\n+        }\n+\n+        Assert.assertEquals(a.findChildAncestor(e), aChild);\n+\n+        switch (a) {\n+            case Op op -> {\n+                Assert.assertTrue(isSameOrAncestorOfOp(op, e));\n+            }\n+            case Body body -> {\n+                Assert.assertTrue(isSameOrAncestorOfBody(body, e));\n+            }\n+            case Block block -> {\n+                Assert.assertTrue(isSameOrAncestorOfBlock(block, e));\n+            }\n+        }\n+    }\n+\n+    static boolean isSameOrAncestorUsingParent(CodeElement<?, ?> e, CodeElement<?, ?> a) {\n+        while (e != null && e != a) {\n+            e = e.parent();\n+        }\n+        return e != null;\n+    }\n+\n+    static boolean isSameOrAncestorOfOp(Op a, CodeElement<?, ?> e) {\n+        while (e != null && e != a) {\n+            e = e.ancestorOp();\n+        }\n+        return e != null;\n+    }\n+\n+    static boolean isSameOrAncestorOfBody(Body a, CodeElement<?, ?> e) {\n+        while (e != null && e != a) {\n+            e = e.ancestorBody();\n+        }\n+        return e != null;\n+    }\n+\n+    static boolean isSameOrAncestorOfBlock(Block a, CodeElement<?, ?> e) {\n+        while (e != null && e != a) {\n+            e = e.ancestorBlock();\n+        }\n+        return e != null;\n+    }\n+\n+    static void computedPaths(List<List<CodeElement<?, ?>>> paths, List<CodeElement<?, ?>> path, CodeElement<?, ?> e) {\n+        ArrayList<CodeElement<?, ?>> p = new ArrayList<>(path);\n+        p.add(e);\n+\n+        if (e.children().isEmpty()) {\n+            paths.add(p);\n+            return;\n+        }\n+\n+        for (CodeElement<?, ?> child : e.children()) {\n+            computedPaths(paths, p, child);\n+        }\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestAncestors.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return Op.ofMethod(m).get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAncestors.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -77,1 +77,1 @@\n-            Assert.assertEquals(b.index(), b.parentBody().blocks().indexOf(b));\n+            Assert.assertEquals(b.index(), b.ancestorBody().blocks().indexOf(b));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockIndexes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        Assert.assertThrows(IllegalStateException.class, result.op()::parentBlock);\n+        Assert.assertThrows(IllegalStateException.class, result.op()::ancestorBlock);\n@@ -153,1 +153,1 @@\n-        Assert.assertNotNull(result.op().parentBlock());\n+        Assert.assertNotNull(result.op().ancestorBlock());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Op top = qop.ancestorOp().ancestorOp();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Op top = qop.ancestorOp().ancestorOp();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-                    if (b.parentBody().parentOp() == op) {\n+                    if (b.ancestorOp() == op) {\n@@ -300,1 +300,1 @@\n-            if (b.parentBody().parentOp() != top) {\n+            if (b.ancestorOp() != top) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-            op = op.ancestorBody().parentOp();\n+            op = op.ancestorOp();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-        CoreOp.QuotedOp qop = ((CoreOp.QuotedOp) op.ancestorBody().parentOp());\n-        CoreOp.FuncOp fop = ((CoreOp.FuncOp) qop.ancestorBody().parentOp());\n+        CoreOp.QuotedOp qop = ((CoreOp.QuotedOp) op.ancestorOp());\n+        CoreOp.FuncOp fop = ((CoreOp.FuncOp) qop.ancestorOp());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        var selfRefP = builderEntry.parameter(((CoreOp.FuncOp) b.parentOp()).invokableType());\n+        var selfRefP = builderEntry.parameter(((CoreOp.FuncOp) b.ancestorOp()).invokableType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/AnfTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                    error(\"%s %s operand %s is not dominated by its declaration in %s\", op.parentBlock(), op, v, v.declaringBlock());\n+                    error(\"%s %s operand %s is not dominated by its declaration in %s\", op.ancestorBlock(), op, v, v.declaringBlock());\n@@ -157,1 +157,1 @@\n-                        error(\"%s %s %s is not assignable from %s\", op.parentBlock(), op, params.get(i).type(), args.get(i).type());\n+                        error(\"%s %s %s is not assignable from %s\", op.ancestorBlock(), op, params.get(i).type(), args.get(i).type());\n@@ -204,1 +204,1 @@\n-            error(\"%s %s of type %s is not supported\", op.parentBlock(), op, op.opType());\n+            error(\"%s %s of type %s is not supported\", op.ancestorBlock(), op, op.opType());\n@@ -206,1 +206,1 @@\n-            error(\"%s %s %s\",  op.parentBlock(), op, roe.getMessage());\n+            error(\"%s %s %s\",  op.ancestorBlock(), op, roe.getMessage());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/Verifier.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}