{"files":[{"patch":"@@ -872,20 +872,2 @@\n-                        final boolean isInstance = op.hasReceiver();\n-                        final boolean isSuper = op instanceof InvokeOp.InvokeSuperOp;\n-                        Opcode invokeOpcode;\n-                        if (isInstance) {\n-                            if (isSuper) {\n-                                \/\/ @@@ We cannot generate an invokespecial as it will result in a verify error,\n-                                \/\/     since the owner is not assignable to generated hidden class\n-                                \/\/ @@@ Construct method handle via lookup.findSpecial\n-                                \/\/     using the lookup's class as the specialCaller and\n-                                \/\/     add that method handle to the to be defined hidden class's constant data\n-                                \/\/     Use and ldc+constant dynamic to access the class data,\n-                                \/\/     extract the method handle and then invoke it\n-                                throw new UnsupportedOperationException(\"invoke super unsupported: \" + op.invokeDescriptor());\n-                            } else if (isInterface) {\n-                                invokeOpcode = Opcode.INVOKEINTERFACE;\n-                            } else {\n-                                invokeOpcode = Opcode.INVOKEVIRTUAL;\n-                            }\n-                        } else {\n-                            invokeOpcode = Opcode.INVOKESTATIC;\n+                        if (op.isVarArgs()) {\n+                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n@@ -893,0 +875,15 @@\n+                        Opcode invokeOpcode = switch (op.invokeKind()) {\n+                            case STATIC ->\n+                                    Opcode.INVOKESTATIC;\n+                            case INSTANCE ->\n+                                    isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL;\n+                            case SUPER ->\n+                                    \/\/ @@@ We cannot generate an invokespecial as it will result in a verify error,\n+                                    \/\/     since the owner is not assignable to generated hidden class\n+                                    \/\/ @@@ Construct method handle via lookup.findSpecial\n+                                    \/\/     using the lookup's class as the specialCaller and\n+                                    \/\/     add that method handle to the to be defined hidden class's constant data\n+                                    \/\/     Use and ldc+constant dynamic to access the class data,\n+                                    \/\/     extract the method handle and then invoke it\n+                                    throw new UnsupportedOperationException(\"invoke super unsupported: \" + op.invokeDescriptor());\n+                        };\n@@ -1272,16 +1269,0 @@\n-    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l,\n-                                                            MethodRef d) throws ReflectiveOperationException {\n-        MethodHandle mh = d.resolveToHandle(l);\n-\n-        if (mh.describeConstable().isEmpty()) {\n-            throw new NoSuchMethodException();\n-        }\n-\n-        MethodHandleDesc mhd = mh.describeConstable().get();\n-        if (!(mhd instanceof DirectMethodHandleDesc dmhd)) {\n-            throw new NoSuchMethodException();\n-        }\n-\n-        return dmhd;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":17,"deletions":36,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -417,19 +417,5 @@\n-            MethodHandle mh;\n-            \/\/ @@@ This does not work for vararg methods\n-\/\/            if (co.hasReceiver()) {\n-\/\/                if (co instanceof CoreOp.InvokeOp.InvokeSuperOp) {\n-\/\/                    MethodHandles.Lookup in = l.in(target.parameterType(0));\n-\/\/                    mh = resolveToMethodHandle(in, co.invokeDescriptor(), MethodRef.ResolveKind.invokeSuper);\n-\/\/                } else {\n-\/\/                    mh = resolveToMethodHandle(l, co.invokeDescriptor(), MethodRef.ResolveKind.invokeInstance);\n-\/\/                }\n-\/\/            } else {\n-\/\/                mh = resolveToMethodHandle(l, co.invokeDescriptor(), MethodRef.ResolveKind.invokeClass);\n-\/\/            }\n-            if (co instanceof CoreOp.InvokeOp.InvokeSuperOp) {\n-                MethodHandles.Lookup in = l.in(target.parameterType(0));\n-                mh = resolveToMethodHandle(in, co.invokeDescriptor(), MethodRef.ResolveKind.invokeSuper);\n-            } else {\n-                \/\/ @@@ resolves to class or instance method handle\n-                mh = resolveToMethodHandle(l, co.invokeDescriptor());\n-            }\n+            MethodHandles.Lookup il = switch (co.invokeKind()) {\n+                case STATIC, INSTANCE -> l;\n+                case SUPER -> l.in(target.parameterType(0));\n+            };\n+            MethodHandle mh = resolveToMethodHandle(il, co.invokeDescriptor(), co.invokeKind());\n@@ -665,9 +651,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d) {\n-        try {\n-            return d.resolveToHandle(l);\n-        } catch (ReflectiveOperationException e) {\n-            throw interpreterException(e);\n-        }\n-    }\n-\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, MethodRef.ResolveKind kind) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1399,1 +1399,2 @@\n-    public sealed static abstract class InvokeOp extends CoreOp\n+    @OpFactory.OpDeclaration(InvokeOp.NAME)\n+    public static final class InvokeOp extends CoreOp\n@@ -1401,0 +1402,19 @@\n+\n+        \/**\n+         * The kind of invocation.\n+         *\/\n+        public enum InvokeKind {\n+            \/**\n+             * An invocation on a class (static) method.\n+             *\/\n+            STATIC,\n+            \/**\n+             * An invocation on an instance method.\n+             *\/\n+            INSTANCE,\n+            \/**\n+             * A super invocation on an instance method.\n+             *\/\n+            SUPER\n+        }\n+\n@@ -1403,0 +1423,2 @@\n+        public static final String ATTRIBUTE_INVOKE_KIND = NAME + \".kind\";\n+        public static final String ATTRIBUTE_INVOKE_VARARGS = NAME + \".varargs\";\n@@ -1404,0 +1426,2 @@\n+        final InvokeKind invokeKind;\n+        final boolean isVarArgs;\n@@ -1407,1 +1431,42 @@\n-        InvokeOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n+        public static InvokeOp create(ExternalizedOp def) {\n+            \/\/ Required attribute\n+            MethodRef invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n+                    true, v -> switch (v) {\n+                        case String s -> MethodRef.ofString(s);\n+                        case MethodRef md -> md;\n+                        case null, default ->\n+                                throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n+                    });\n+\n+            \/\/ If not present defaults to false\n+            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_INVOKE_VARARGS,\n+                    false, v -> switch (v) {\n+                        case String s -> Boolean.valueOf(s);\n+                        case Boolean b -> b;\n+                        case null, default -> false;\n+                    });\n+\n+            \/\/ If not present and is not varargs defaults to class or instance invocation\n+            \/\/ based on number of operands and parameters\n+            InvokeKind ik = def.extractAttributeValue(ATTRIBUTE_INVOKE_KIND,\n+                    false, v -> switch (v) {\n+                        case String s -> InvokeKind.valueOf(s);\n+                        case InvokeKind k -> k;\n+                        case null, default -> {\n+                            if (isVarArgs) {\n+                                \/\/ If varargs then we cannot infer invoke kind\n+                                throw new UnsupportedOperationException(\"Unsupported invoke kind value:\" + v);\n+                            }\n+                            int paramCount = invokeDescriptor.type().parameterTypes().size();\n+                            int argCount = def.operands().size();\n+                            yield (argCount == paramCount + 1)\n+                                    ? InvokeKind.INSTANCE\n+                                    : InvokeKind.STATIC;\n+                        }\n+                    });\n+\n+\n+            return new InvokeOp(def, ik, isVarArgs, invokeDescriptor);\n+        }\n+\n+        InvokeOp(ExternalizedOp def, InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor) {\n@@ -1410,0 +1475,4 @@\n+            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, def.operands());\n+\n+            this.invokeKind = invokeKind;\n+            this.isVarArgs = isVarArgs;\n@@ -1417,0 +1486,2 @@\n+            this.invokeKind = that.invokeKind;\n+            this.isVarArgs = that.isVarArgs;\n@@ -1421,2 +1492,9 @@\n-        InvokeOp(String name, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-            super(name, args);\n+        @Override\n+        public InvokeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InvokeOp(this, cc);\n+        }\n+\n+        InvokeOp(InvokeKind invokeKind, boolean isVarArgs, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+            super(NAME, args);\n+\n+            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, args);\n@@ -1424,0 +1502,2 @@\n+            this.invokeKind = invokeKind;\n+            this.isVarArgs = isVarArgs;\n@@ -1428,0 +1508,9 @@\n+        static void validateArgCount(InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor, List<Value> operands) {\n+            int paramCount = invokeDescriptor.type().parameterTypes().size();\n+            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n+            if ((!isVarArgs && argCount != paramCount)\n+                    || argCount < paramCount - 1) {\n+                throw new IllegalArgumentException(invokeKind + \" \" + isVarArgs + \" \" + invokeDescriptor);\n+            }\n+        }\n+\n@@ -1432,0 +1521,10 @@\n+            if (isVarArgs) {\n+                \/\/ If varargs then we need to declare the invoke.kind attribute\n+                \/\/ Given a method `A::m(A... more)` and an invocation with one\n+                \/\/ operand, we don't know if that operand corresponds to the\n+                \/\/ receiver or a method argument\n+                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n+                m.put(ATTRIBUTE_INVOKE_VARARGS, isVarArgs);\n+            } else if (invokeKind == InvokeKind.SUPER) {\n+                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n+            }\n@@ -1435,2 +1534,2 @@\n-        public MethodRef invokeDescriptor() {\n-            return invokeDescriptor;\n+        public InvokeKind invokeKind() {\n+            return invokeKind;\n@@ -1439,2 +1538,2 @@\n-        public boolean hasReceiver() {\n-            return operands().size() != invokeDescriptor().type().parameterTypes().size();\n+        public boolean isVarArgs() {\n+            return isVarArgs;\n@@ -1443,3 +1542,2 @@\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n+        public MethodRef invokeDescriptor() {\n+            return invokeDescriptor;\n@@ -1448,7 +1546,3 @@\n-        static MethodRef createInvokeDescriptor(ExternalizedOp def) {\n-            return def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n-                    true, v -> switch (v) {\n-                        case String s -> MethodRef.ofString(s);\n-                        case MethodRef md -> md;\n-                        case null, default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n-                    });\n+        \/\/ @@@ remove?\n+        public boolean hasReceiver() {\n+            return invokeKind != InvokeKind.STATIC;\n@@ -1457,24 +1551,3 @@\n-\n-        \/**\n-         * The invoke instance or class (static) operation, that can model Java language instance or class method\n-         * invocation expressions.\n-         *\/\n-        @OpFactory.OpDeclaration(InvokeInstanceClassOp.NAME)\n-        public static final class InvokeInstanceClassOp extends InvokeOp {\n-            public static final String NAME = InvokeOp.NAME;\n-\n-            public static InvokeInstanceClassOp create(ExternalizedOp def) {\n-                return new InvokeInstanceClassOp(def, createInvokeDescriptor(def));\n-            }\n-\n-            InvokeInstanceClassOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n-                super(def, invokeDescriptor);\n-            }\n-\n-            InvokeInstanceClassOp(InvokeOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public InvokeInstanceClassOp transform(CopyContext cc, OpTransformer ot) {\n-                return new InvokeInstanceClassOp(this, cc);\n+        public List<Value> varArgOperands() {\n+            if (!isVarArgs) {\n+                return null;\n@@ -1483,3 +1556,5 @@\n-            InvokeInstanceClassOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-                super(NAME, resultType, invokeDescriptor, args);\n-            }\n+            int operandCount = operands().size();\n+            int argCount = operandCount - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n+            int paramCount = invokeDescriptor.type().parameterTypes().size();\n+            int varArgCount = argCount - (paramCount - 1);\n+            return operands().subList(operandCount - varArgCount, operandCount);\n@@ -1488,28 +1563,3 @@\n-        \/**\n-         * The invoke super operation, that can model Java language super method\n-         * invocation expressions.\n-         *\/\n-        @OpFactory.OpDeclaration(InvokeSuperOp.NAME)\n-        public static final class InvokeSuperOp extends InvokeOp {\n-            public static final String NAME = InvokeOp.NAME + \".super\";\n-\n-            public static InvokeSuperOp create(ExternalizedOp def) {\n-                return new InvokeSuperOp(def, createInvokeDescriptor(def));\n-            }\n-\n-            InvokeSuperOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n-                super(def, invokeDescriptor);\n-            }\n-\n-            InvokeSuperOp(InvokeOp that, CopyContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public InvokeSuperOp transform(CopyContext cc, OpTransformer ot) {\n-                return new InvokeSuperOp(this, cc);\n-            }\n-\n-            InvokeSuperOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-                super(NAME, resultType, invokeDescriptor, args);\n-            }\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n@@ -1517,1 +1567,0 @@\n-\n@@ -3668,1 +3717,11 @@\n-     * Creates an invoke instance or class (static) operation.\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * <p>\n+     * The invoke return type is the invoke descriptors return type.\n@@ -3670,1 +3729,1 @@\n-     * @param invokeDescriptor the invocation descriptor\n+     * @param invokeDescriptor the invoke descriptor\n@@ -3679,1 +3738,11 @@\n-     * Creates an invoke instance or class (static) operation.\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * <p>\n+     * The invoke return type is the invoke descriptors return type.\n@@ -3681,2 +3750,2 @@\n-     * @param invokeDescriptor the invocation descriptor\n-     * @param args             the invoke parameters\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n@@ -3690,1 +3759,9 @@\n-     * Creates an invoke instance or class (static) operation.\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n@@ -3692,3 +3769,3 @@\n-     * @param returnType       the invocation return type\n-     * @param invokeDescriptor the invocation descriptor\n-     * @param args             the invoke parameters\n+     * @param returnType       the invoke return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n@@ -3702,1 +3779,9 @@\n-     * Creates an invoke instance or class (static) operation.\n+     * Creates an invoke operation modeling an invocation to an\n+     * instance or static (class) method with no variable arguments.\n+     * <p>\n+     * The invoke kind of the invoke operation is determined by\n+     * comparing the argument count with the invoke descriptor's\n+     * parameter count. If they are equal then the invoke kind is\n+     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n+     * plus one is equal to the argument count then the invoke kind\n+     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n@@ -3704,3 +3789,3 @@\n-     * @param returnType       the invocation return type\n-     * @param invokeDescriptor the invocation descriptor\n-     * @param args             the invoke parameters\n+     * @param returnType       the invoke return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n@@ -3710,1 +3795,6 @@\n-        return new InvokeOp.InvokeInstanceClassOp(returnType, invokeDescriptor, args);\n+        int paramCount = invokeDescriptor.type().parameterTypes().size();\n+        int argCount = args.size();\n+        InvokeOp.InvokeKind ik = (argCount == paramCount + 1)\n+                ? InvokeOp.InvokeKind.INSTANCE\n+                : InvokeOp.InvokeKind.STATIC;\n+        return new InvokeOp(ik, false, returnType, invokeDescriptor, args);\n@@ -3714,1 +3804,1 @@\n-     * Creates an invoke super operation.\n+     * Creates an invoke operation modelling an invocation to a method.\n@@ -3716,3 +3806,5 @@\n-     * @param returnType       the invocation return type\n-     * @param invokeDescriptor the invocation descriptor\n-     * @param args             the invoke parameters\n+     * @param invokeKind       the invoke kind\n+     * @param isVarArgs        true if an invocation to a variable argument method\n+     * @param returnType       the return type\n+     * @param invokeDescriptor the invoke descriptor\n+     * @param args             the invoke arguments\n@@ -3720,0 +3812,2 @@\n+     * @throws IllegalArgumentException if there is a mismatch between the argument count\n+     *                                  and the invoke descriptors parameter count.\n@@ -3721,2 +3815,3 @@\n-    public static InvokeOp.InvokeSuperOp invokeSuper(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        return new InvokeOp.InvokeSuperOp(returnType, invokeDescriptor, args);\n+    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n+                                  TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, args);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":189,"deletions":94,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    \/\/ Resolve using ResolveKind.invokeClass, on failure resolve using ResolveKind.invokeInstance\n-    Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    \/\/ Resolve to static or instance method declared on referenced class\n+    Method resolveToDirectMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -59,2 +59,2 @@\n-    \/\/ Resolve using ResolveKind.invokeClass, on failure resolve using ResolveKind.invokeInstance\n-    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    \/\/ Resolve to static or instance method declared on referenced class\n+    MethodHandle resolveToDirectHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -62,7 +62,1 @@\n-    enum ResolveKind {\n-        invokeClass,\n-        invokeInstance,\n-        invokeSuper\n-    }\n-\n-    Method resolveToMethod(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException;\n+    Method resolveToMethod(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n@@ -70,2 +64,2 @@\n-    \/\/ For ResolveKind.invokeSuper the specialCaller == l.lookupClass() for Lookup::findSpecial\n-    MethodHandle resolveToHandle(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException;\n+    \/\/ For InvokeKind.SUPER the specialCaller == l.lookupClass() for Lookup::findSpecial\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/MethodRef.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-                \/\/ @@@ resolves to class or instance method\n-                Method method = ((MethodRef)owner).resolveToMethod(lookup);\n+                Method method = methodRef.resolveToDirectMethod(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.code.op.CoreOp;\n@@ -37,0 +38,2 @@\n+import java.util.List;\n+import java.util.function.Function;\n@@ -66,4 +69,2 @@\n-    @Override\n-    public Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l));\n-        return methodHandleInfo.reflectAs(Method.class, l);\n+    public Method resolveToDirectMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        return resolveToDirectHandle(l, hr -> hr.mhi().reflectAs(Method.class, l));\n@@ -72,6 +73,19 @@\n-    @Override\n-    public MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        try {\n-            return resolveToHandle(l, ResolveKind.invokeClass);\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            return resolveToHandle(l, ResolveKind.invokeInstance);\n+    public MethodHandle resolveToDirectHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        return resolveToDirectHandle(l, HandleResult::mh);\n+    }\n+\n+    <T> T resolveToDirectHandle(MethodHandles.Lookup l, Function<HandleResult, T> f) throws ReflectiveOperationException {\n+        ReflectiveOperationException roe = null;\n+        for (CoreOp.InvokeOp.InvokeKind ik :\n+                List.of(CoreOp.InvokeOp.InvokeKind.STATIC, CoreOp.InvokeOp.InvokeKind.INSTANCE)) {\n+            try {\n+                HandleResult hr = resolveToHandleResult(l, ik);\n+                if (hr.isDirect()) {\n+                    return f.apply(hr);\n+                }\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                roe = e;\n+            }\n+        }\n+        if (roe == null) {\n+            roe = new ReflectiveOperationException(\"Indirect reference to method\");\n@@ -79,0 +93,1 @@\n+        throw roe;\n@@ -82,1 +97,1 @@\n-    public Method resolveToMethod(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException {\n+    public Method resolveToMethod(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n@@ -88,1 +103,1 @@\n-    public MethodHandle resolveToHandle(MethodHandles.Lookup l, ResolveKind kind) throws ReflectiveOperationException {\n+    public MethodHandle resolveToHandle(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n@@ -92,3 +107,19 @@\n-            case invokeSuper -> l.findSpecial(refC, name, mt, l.lookupClass());\n-            case invokeClass -> l.findStatic(refC, name, mt);\n-            case invokeInstance -> l.findVirtual(refC, name, mt);\n+            case SUPER -> l.findSpecial(refC, name, mt, l.lookupClass());\n+            case STATIC -> l.findStatic(refC, name, mt);\n+            case INSTANCE -> l.findVirtual(refC, name, mt);\n+        };\n+    }\n+\n+    record HandleResult (Class<?> refC, MethodHandle mh, MethodHandleInfo mhi) {\n+        boolean isDirect() {\n+            return refC == mhi.getDeclaringClass();\n+        }\n+    }\n+\n+    HandleResult resolveToHandleResult(MethodHandles.Lookup l, CoreOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n+        Class<?> refC = resolve(l, refType);\n+        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n+        MethodHandle mh = switch (kind) {\n+            case SUPER -> l.findSpecial(refC, name, mt, l.lookupClass());\n+            case STATIC -> l.findStatic(refC, name, mt);\n+            case INSTANCE -> l.findVirtual(refC, name, mt);\n@@ -96,0 +127,2 @@\n+        MethodHandleInfo mhi = l.revealDirect(resolveToHandle(l, kind));\n+        return new HandleResult(refC, mh, mhi);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    \/\/ instance varargs\n@@ -69,0 +70,1 @@\n+    \/\/ instance varargs\n@@ -75,0 +77,1 @@\n+    \/\/ static varargs\n@@ -191,1 +194,4 @@\n-            Value successor = builder.op(invoke(BLOCK_BUILDER_SUCCESSOR, args));\n+            Value successor = builder.op(invoke(\n+                    InvokeOp.InvokeKind.INSTANCE, true,\n+                    BLOCK_BUILDER_SUCCESSOR.type().returnType(),\n+                    BLOCK_BUILDER_SUCCESSOR, args));\n@@ -224,1 +230,4 @@\n-        Value bodyType = builder.op(invoke(FUNCTION_TYPE_FUNCTION_TYPE, yieldType));\n+        Value bodyType = builder.op(invoke(\n+                InvokeOp.InvokeKind.STATIC, true,\n+                FUNCTION_TYPE_FUNCTION_TYPE.type().returnType(),\n+                FUNCTION_TYPE_FUNCTION_TYPE, List.of(yieldType)));\n@@ -234,1 +243,3 @@\n-                block = builder.op(invoke(BLOCK_BUILDER_BLOCK, entryBlock));\n+                block = builder.op(invoke(InvokeOp.InvokeKind.INSTANCE, true,\n+                        BLOCK_BUILDER_BLOCK.type().returnType(),\n+                        BLOCK_BUILDER_BLOCK, List.of(entryBlock)));\n@@ -325,0 +336,4 @@\n+            case InvokeOp.InvokeKind ik -> {\n+                FieldRef enumValueRef = FieldRef.field(InvokeOp.InvokeKind.class, ik.name(), InvokeOp.InvokeKind.class);\n+                yield builder.op(fieldLoad(enumValueRef));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1075,0 +1075,1 @@\n+                    CoreOp.InvokeOp.InvokeKind ik;\n@@ -1076,0 +1077,1 @@\n+                        ik = CoreOp.InvokeOp.InvokeKind.INSTANCE;\n@@ -1077,0 +1079,2 @@\n+                    } else {\n+                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n@@ -1082,1 +1086,2 @@\n-                    Value res = append(CoreOp.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    Value res = append(CoreOp.invoke(ik, tree.varargsElement != null,\n+                            typeToTypeElement(meth.type.getReturnType()), mr, args));\n@@ -1096,1 +1101,1 @@\n-                    boolean isSuper;\n+                    CoreOp.InvokeOp.InvokeKind ik;\n@@ -1100,4 +1105,4 @@\n-                        isSuper = switch (access.selected) {\n-                            case JCIdent i when i.sym.name.equals(names._super) -> true;\n-                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> true;\n-                            default -> false;\n+                        ik = switch (access.selected) {\n+                            case JCIdent i when i.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n+                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n+                            default -> CoreOp.InvokeOp.InvokeKind.INSTANCE;\n@@ -1106,1 +1111,1 @@\n-                        isSuper = false;\n+                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n@@ -1114,3 +1119,2 @@\n-                    CoreOp.InvokeOp iop = isSuper\n-                            ? CoreOp.invokeSuper(returnType, mr, args)\n-                            : CoreOp.invoke(returnType, mr, args);\n+                    CoreOp.InvokeOp iop = CoreOp.invoke(ik, tree.varargsElement != null,\n+                            returnType, mr, args);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-                        em = r.resolveToMethod(l);\n+                        em = r.resolveToMethod(l, iop.invokeKind());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestVarArgsInvoke\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestVarArgsInvoke {\n+\n+    String m1(String... args) {\n+        StringBuilder sb = new StringBuilder(\"m1\");\n+        for (String arg : args) {\n+            sb.append(arg);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String sm1(String... args) {\n+        StringBuilder sb = new StringBuilder(\"sm1\");\n+        for (String arg : args) {\n+            sb.append(arg);\n+        }\n+        return sb.toString();\n+    }\n+\n+    String m2(String one, String... args) {\n+        StringBuilder sb = new StringBuilder(\"m2\");\n+        sb.append(one);\n+        for (String arg : args) {\n+            sb.append(arg);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String sm2(String one, String... args) {\n+        StringBuilder sb = new StringBuilder(\"sm2\");\n+        sb.append(one);\n+        for (String arg : args) {\n+            sb.append(arg);\n+        }\n+        return sb.toString();\n+    }\n+\n+    enum MethodKind {\n+        M1, SM1, M2, SM2;\n+    }\n+\n+    @CodeReflection\n+    String fArray(String[] array, MethodKind m) {\n+        return switch (m) {\n+            case M1 -> m1(array);\n+            case SM1 -> sm1(array);\n+            case M2 -> m2(\"first\", array);\n+            case SM2 -> sm2(\"first\", array);\n+        };\n+    }\n+\n+    @Test\n+    public void testArray() {\n+        CoreOp.FuncOp f = getFuncOp(\"fArray\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        invokes(f).forEach(iop -> {\n+            Assert.assertFalse(iop.isVarArgs());\n+            Assert.assertNull(iop.varArgOperands());\n+        });\n+\n+        String[] array = new String[]{\"second\", \"third\"};\n+        for (MethodKind mk : MethodKind.values()) {\n+            Assert.assertEquals(\n+                    Interpreter.invoke(MethodHandles.lookup(), f, this, array, mk),\n+                    fArray(array, mk));\n+        }\n+    }\n+\n+    @CodeReflection\n+    String fEmpty(MethodKind m) {\n+        return switch (m) {\n+            case M1 -> m1();\n+            case SM1 -> sm1();\n+            case M2 -> m2(\"first\");\n+            case SM2 -> sm2(\"first\");\n+        };\n+    }\n+\n+    @Test\n+    public void testEmpty() {\n+        CoreOp.FuncOp f = getFuncOp(\"fEmpty\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        invokes(f).forEach(iop -> {\n+            Assert.assertTrue(iop.isVarArgs());\n+            Assert.assertTrue(iop.varArgOperands().isEmpty());\n+        });\n+\n+        String[] array = new String[]{\"second\", \"third\"};\n+        for (MethodKind mk : MethodKind.values()) {\n+            Assert.assertEquals(\n+                    Interpreter.invoke(MethodHandles.lookup(), f, this, mk),\n+                    fEmpty(mk));\n+        }\n+    }\n+\n+    @CodeReflection\n+    String fOne(String one, MethodKind m) {\n+        return switch (m) {\n+            case M1 -> m1(one);\n+            case SM1 -> sm1(one);\n+            case M2 -> m2(\"first\", one);\n+            case SM2 -> sm2(\"first\", one);\n+        };\n+    }\n+\n+    @Test\n+    public void testOne() {\n+        CoreOp.FuncOp f = getFuncOp(\"fOne\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        invokes(f).forEach(iop -> {\n+            Assert.assertTrue(iop.isVarArgs());\n+            Assert.assertEquals(iop.varArgOperands().size(), 1);\n+        });\n+\n+        for (MethodKind mk : MethodKind.values()) {\n+            Assert.assertEquals(\n+                    Interpreter.invoke(MethodHandles.lookup(), f, this, \"one\", mk),\n+                    fOne(\"one\", mk));\n+        }\n+    }\n+\n+    @CodeReflection\n+    String fMany(String one, String two, MethodKind m) {\n+        return switch (m) {\n+            case M1 -> m1(one, two);\n+            case SM1 -> sm1(one, two);\n+            case M2 -> m2(\"first\", one, two);\n+            case SM2 -> sm2(\"first\", one, two);\n+        };\n+    }\n+\n+    @Test\n+    public void testMany() {\n+        CoreOp.FuncOp f = getFuncOp(\"fMany\");\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        invokes(f).forEach(iop -> {\n+            Assert.assertTrue(iop.isVarArgs());\n+            Assert.assertEquals(iop.varArgOperands().size(), 2);\n+        });\n+\n+        for (MethodKind mk : MethodKind.values()) {\n+            Assert.assertEquals(\n+                    Interpreter.invoke(MethodHandles.lookup(), f, this, \"one\", \"two\", mk),\n+                    fMany(\"one\", \"two\", mk));\n+        }\n+    }\n+\n+    static Stream<CoreOp.InvokeOp> invokes(CoreOp.FuncOp f) {\n+        return f.elements().mapMulti((ce, c) -> {\n+            if (ce instanceof CoreOp.InvokeOp iop &&\n+                iop.invokeDescriptor().refType().equals(JavaType.type(TestVarArgsInvoke.class))) {\n+                c.accept(iop);\n+            }\n+        });\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestVarArgsInvoke.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarArgsInvoke.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -551,1 +551,1 @@\n-                invoke %0 %3 %4 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                invoke %0 %3 %4 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n@@ -567,1 +567,1 @@\n-                invoke %0 %3 %4 %6 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                invoke %0 %3 %4 %6 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n@@ -585,1 +585,1 @@\n-                invoke %0 %3 %4 %6 %8 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                invoke %0 %3 %4 %6 %8 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -468,1 +468,1 @@\n-                invoke %0 %3 %4 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                invoke %0 %3 %4 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"ImplicitConversionTest::m(int, int, long[])void\";\n@@ -484,1 +484,1 @@\n-                invoke %0 %3 %4 %6 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                invoke %0 %3 %4 %6 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"ImplicitConversionTest::m(int, int, long[])void\";\n@@ -502,1 +502,1 @@\n-                invoke %0 %3 %4 %6 %8 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                invoke %0 %3 %4 %6 %8 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"ImplicitConversionTest::m(int, int, long[])void\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-                invoke %1 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                invoke %1 @invoke.kind=\"STATIC\" @invoke.varargs=\"true\" @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n@@ -460,1 +460,1 @@\n-                invoke %1 %2 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                invoke %1 %2 @invoke.kind=\"STATIC\" @invoke.varargs=\"false\" @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n@@ -474,1 +474,1 @@\n-                invoke %1 %2 %3 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                invoke %1 %2 %3 @invoke.kind=\"STATIC\" @invoke.varargs=\"true\" @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-                invoke.super %0 @\"SuperClass::get()void\";\n-                invoke.super %0 @\"SuperClass::get()void\";\n+                invoke %0 @invoke.kind=\"SUPER\" @\"SuperClass::get()void\";\n+                invoke %0 @invoke.kind=\"SUPER\" @\"SuperClass::get()void\";\n@@ -97,1 +97,1 @@\n-                invoke.super %0 @\"SuperInterface::get()void\";\n+                invoke %0 @invoke.kind=\"SUPER\" @\"SuperInterface::get()void\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SuperTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1909,1 +1909,1 @@\n-                        %23 : java.lang.String = invoke %19 %22 @\"java.lang.String::formatted(java.lang.Object[])java.lang.String\";\n+                        %23 : java.lang.String = invoke %19 %22 @invoke.kind=\"INSTANCE\" @invoke.varargs=\"true\" @\"java.lang.String::formatted(java.lang.Object[])java.lang.String\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchStatementTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}