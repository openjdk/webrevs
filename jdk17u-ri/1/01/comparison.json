{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1567,0 +1567,1 @@\n+        addEngine(\"KEM\",                                true,  null);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+\/**\n+ * An exception that is thrown by the\n+ * {@link javax.crypto.KEM.Decapsulator#decapsulate} method to denote an\n+ * error during decapsulation.\n+ *\n+ * @since 21\n+ *\/\n+public class DecapsulateException extends GeneralSecurityException {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 21L;\n+\n+    \/**\n+     * Creates a {@code DecapsulateException} with the specified\n+     * detail message.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     *\/\n+    public DecapsulateException(String message) {\n+        super(message);\n+    }\n+\n+    \/**\n+     * Creates a {@code DecapsulateException} with the specified\n+     * detail message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is permitted,\n+     *        and indicates that the cause is nonexistent or unknown.)\n+     *\/\n+    public DecapsulateException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/DecapsulateException.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,747 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import sun.security.jca.GetInstance;\n+\n+import java.security.*;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a Key Encapsulation Mechanism (KEM).\n+ * A KEM can be used to secure symmetric keys using asymmetric or public key\n+ * cryptography between two parties. The sender calls the encapsulate method\n+ * to generate a secret key and a key encapsulation message, and the receiver\n+ * calls the decapsulate method to recover the same secret key from\n+ * the key encapsulation message.\n+ * <p>\n+ * The {@code getInstance} method creates a new {@code KEM} object that\n+ * implements the specified algorithm.\n+ * <p>\n+ * A {@code KEM} object is immutable. It is safe to call multiple\n+ * {@code newEncapsulator} and {@code newDecapsulator} methods on the\n+ * same {@code KEM} object at the same time.\n+ * <p>\n+ * If a provider is not specified in the {@code getInstance} method when\n+ * instantiating a {@code KEM} object, the {@code newEncapsulator} and\n+ * {@code newDecapsulator} methods may return encapsulators or decapsulators\n+ * from different providers. The provider selected is based on the parameters\n+ * passed to the {@code newEncapsulator} or {@code newDecapsulator} methods:\n+ * the private or public key and the optional {@code AlgorithmParameterSpec}.\n+ * The {@link Encapsulator#providerName} and {@link Decapsulator#providerName}\n+ * methods return the name of the selected provider.\n+ * <p>\n+ * {@code Encapsulator} and {@code Decapsulator} objects are also immutable.\n+ * It is safe to invoke multiple {@code encapsulate} and {@code decapsulate}\n+ * methods on the same {@code Encapsulator} or {@code Decapsulator} object\n+ * at the same time. Each invocation of {@code encapsulate} will generate a\n+ * new shared secret and key encapsulation message.\n+ * <p>\n+ *\n+ * Example:\n+ * <pre>{@code\n+ *    \/\/ Receiver side\n+ *    var kpg = KeyPairGenerator.getInstance(\"X25519\");\n+ *    var kp = kpg.generateKeyPair();\n+ *\n+ *    \/\/ Sender side\n+ *    var kem1 = KEM.getInstance(\"DHKEM\");\n+ *    var sender = kem1.newEncapsulator(kp.getPublic());\n+ *    var encapsulated = sender.encapsulate();\n+ *    var k1 = encapsulated.key();\n+ *\n+ *    \/\/ Receiver side\n+ *    var kem2 = KEM.getInstance(\"DHKEM\");\n+ *    var receiver = kem2.newDecapsulator(kp.getPrivate());\n+ *    var k2 = receiver.decapsulate(encapsulated.encapsulation());\n+ *\n+ *    assert Arrays.equals(k1.getEncoded(), k2.getEncoded());\n+ * }<\/pre>\n+ *\n+ * @since 21\n+ *\/\n+public final class KEM {\n+\n+    \/**\n+     * This class specifies the return value of the encapsulate method of\n+     * a Key Encapsulation Mechanism (KEM), which includes the shared secret\n+     * (as a {@code SecretKey}), the key encapsulation message,\n+     * and optional parameters.\n+     * <p>\n+     * Note: the key encapsulation message can be also referred to as ciphertext.\n+     *\n+     * @see #newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)\n+     * @see Encapsulator#encapsulate(int, int, String)\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Encapsulated {\n+        private final SecretKey key;\n+        private final byte[] encapsulation;\n+        private final byte[] params;\n+\n+        \/**\n+         * Constructs an {@code Encapsulated} object.\n+         *\n+         * @param key the shared secret as a key, must not be {@code null}.\n+         * @param encapsulation the key encapsulation message, must not\n+         *          be {@code null}. The contents of the array are copied\n+         *          to protect against subsequent modification.\n+         * @param params optional parameters, can be {@code null}.\n+         *          The contents of the array are copied to protect\n+         *          against subsequent modification.\n+         * @throws NullPointerException if {@code key} or {@code encapsulation}\n+         *          is {@code null}\n+         *\/\n+        public Encapsulated(SecretKey key, byte[] encapsulation, byte[] params) {\n+            Objects.requireNonNull(key);\n+            Objects.requireNonNull(encapsulation);\n+            this.key = key;\n+            this.encapsulation = encapsulation.clone();\n+            this.params = params == null ? null : params.clone();\n+        }\n+\n+        \/**\n+         * Returns the {@code SecretKey}.\n+         *\n+         * @return the secret key\n+         *\/\n+        public SecretKey key() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the key encapsulation message.\n+         *\n+         * @return the key encapsulation message. A new copy of the byte array\n+         *      is returned.\n+         *\/\n+        public byte[] encapsulation() {\n+            return encapsulation.clone();\n+        }\n+\n+        \/**\n+         * Returns the optional parameters in a byte array.\n+         *\n+         * @return the optional parameters in a byte array or {@code null}\n+         *      if not specified. A new copy of the byte array is returned.\n+         *\/\n+        public byte[] params() {\n+            return params == null ? null : params.clone();\n+        }\n+    }\n+\n+    \/**\n+     * An encapsulator, generated by {@link #newEncapsulator} on the KEM\n+     * sender side.\n+     * <p>\n+     * This class represents the key encapsulation function of a KEM.\n+     * Each invocation of the {@code encapsulate} method generates a\n+     * new secret key and key encapsulation message that is returned\n+     * in an {@link Encapsulated} object.\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Encapsulator {\n+\n+        private final KEMSpi.EncapsulatorSpi e;\n+        private final Provider p;\n+\n+        private Encapsulator(KEMSpi.EncapsulatorSpi e, Provider p) {\n+            assert e != null;\n+            assert p != null;\n+            this.e = e;\n+            this.p = p;\n+        }\n+\n+        \/**\n+         * Returns the name of the provider.\n+         *\n+         * @return the name of the provider\n+         *\/\n+        public String providerName() {\n+            return p.getName();\n+        }\n+\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * This method is equivalent to\n+         * {@code encapsulate(0, secretSize(), \"Generic\")}. This combination\n+         * of arguments must be supported by every implementation.\n+         * <p>\n+         * The generated secret key is usually passed to a key derivation\n+         * function (KDF) as the input keying material.\n+         *\n+         * @return a {@link Encapsulated} object containing the shared\n+         *          secret, key encapsulation message, and optional parameters.\n+         *          The shared secret is a {@code SecretKey} containing all of\n+         *          the bytes of the secret, and an algorithm name of \"Generic\".\n+         *\/\n+        public Encapsulated encapsulate() {\n+            return encapsulate(0, secretSize(), \"Generic\");\n+        }\n+\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * Each invocation of this method generates a new secret key and key\n+         * encapsulation message that is returned in an {@link Encapsulated} object.\n+         * <p>\n+         * An implementation may choose to not support arbitrary combinations\n+         * of {@code from}, {@code to}, and {@code algorithm}.\n+         *\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a {@link Encapsulated} object containing a portion of\n+         *          the shared secret, key encapsulation message, and optional\n+         *          parameters. The portion of the shared secret is a\n+         *          {@code SecretKey} containing the bytes of the secret\n+         *          ranging from {@code from} to {@code to}, exclusive,\n+         *          and an algorithm name as specified. For example,\n+         *          {@code encapsulate(0, 16, \"AES\")} uses the first 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the encapsulator\n+         *\/\n+        public Encapsulated encapsulate(int from, int to, String algorithm) {\n+            return e.engineEncapsulate(from, to, algorithm);\n+        }\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         * <p>\n+         * This method can be called to find out the length of the shared secret\n+         * before {@code encapsulate} is called or if the obtained\n+         * {@code SecretKey} is not extractable.\n+         *\n+         * @return the size of the shared secret\n+         *\/\n+        public int secretSize() {\n+            int result = e.engineSecretSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineSecretSize result\";\n+            return result;\n+        }\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         * <p>\n+         * This method can be called to find out the length of the encapsulation\n+         * message before {@code encapsulate} is called.\n+         *\n+         * @return the size of the key encapsulation message\n+         *\/\n+        public int encapsulationSize() {\n+            int result = e.engineEncapsulationSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineEncapsulationSize result\";\n+            return result;\n+        }\n+    }\n+\n+    \/**\n+     * A decapsulator, generated by {@link #newDecapsulator} on the KEM\n+     * receiver side.\n+     * <p>\n+     * This class represents the key decapsulation function of a KEM.\n+     * An invocation of the {@code decapsulate} method recovers the\n+     * secret key from the key encapsulation message.\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Decapsulator {\n+        private final KEMSpi.DecapsulatorSpi d;\n+        private final Provider p;\n+\n+        private Decapsulator(KEMSpi.DecapsulatorSpi d, Provider p) {\n+            assert d != null;\n+            assert p != null;\n+            this.d = d;\n+            this.p = p;\n+        }\n+\n+        \/**\n+         * Returns the name of the provider.\n+         *\n+         * @return the name of the provider\n+         *\/\n+        public String providerName() {\n+            return p.getName();\n+        }\n+\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * This method is equivalent to\n+         * {@code decapsulate(encapsulation, 0, secretSize(), \"Generic\")}. This\n+         * combination of arguments must be supported by every implementation.\n+         * <p>\n+         * The generated secret key is usually passed to a key derivation\n+         * function (KDF) as the input keying material.\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @return the shared secret as a {@code SecretKey} with\n+         *          an algorithm name of \"Generic\"\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws NullPointerException if {@code encapsulation} is {@code null}\n+         *\/\n+        public SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {\n+            return decapsulate(encapsulation, 0, secretSize(), \"Generic\");\n+        }\n+\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * An invocation of this method recovers the secret key from the key\n+         * encapsulation message.\n+         * <p>\n+         * An implementation may choose to not support arbitrary combinations\n+         * of {@code from}, {@code to}, and {@code algorithm}.\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a portion of the shared secret as a {@code SecretKey}\n+         *          containing the bytes of the secret ranging from {@code from}\n+         *          to {@code to}, exclusive, and an algorithm name as specified.\n+         *          For example, {@code decapsulate(encapsulation, secretSize()\n+         *          - 16, secretSize(), \"AES\")} uses the last 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n+         *\/\n+        public SecretKey decapsulate(byte[] encapsulation,\n+                int from, int to, String algorithm)\n+                throws DecapsulateException {\n+            return d.engineDecapsulate(\n+                    encapsulation,\n+                    from, to,\n+                    algorithm);\n+        }\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         * <p>\n+         * This method can be called to find out the length of the shared secret\n+         * before {@code decapsulate} is called or if the obtained\n+         * {@code SecretKey} is not extractable.\n+         *\n+         * @return the size of the shared secret\n+         *\/\n+        public int secretSize() {\n+            int result = d.engineSecretSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineSecretSize result\";\n+            return result;\n+        }\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         * <p>\n+         * This method can be used to extract the encapsulation message\n+         * from a longer byte array if no length information is provided\n+         * by a higher level protocol.\n+         *\n+         * @return the size of the key encapsulation message\n+         *\/\n+        public int encapsulationSize() {\n+            int result = d.engineEncapsulationSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineEncapsulationSize result\";\n+            return result;\n+        }\n+    }\n+\n+    private static final class DelayedKEM {\n+\n+        private final Provider.Service[] list; \/\/ non empty array\n+\n+        private DelayedKEM(Provider.Service[] list) {\n+            this.list = list;\n+        }\n+\n+        private Encapsulator newEncapsulator(PublicKey publicKey,\n+                AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (publicKey == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n+            RuntimeException re = null;\n+            InvalidAlgorithmParameterException iape = null;\n+            InvalidKeyException ike = null;\n+            NoSuchAlgorithmException nsae = null;\n+            for (Provider.Service service : list) {\n+                if (!service.supportsParameter(publicKey)) {\n+                    continue;\n+                }\n+                try {\n+                    KEMSpi spi = (KEMSpi) service.newInstance(null);\n+                    return new Encapsulator(\n+                            spi.engineNewEncapsulator(publicKey, spec, secureRandom),\n+                            service.getProvider());\n+                } catch (NoSuchAlgorithmException e) {\n+                    nsae = merge(nsae, e);\n+                } catch (InvalidAlgorithmParameterException e) {\n+                    iape = merge(iape, e);\n+                } catch (InvalidKeyException e) {\n+                    ike = merge(ike, e);\n+                } catch (RuntimeException e) {\n+                    re = merge(re, e);\n+                }\n+            }\n+            if (iape != null) throw iape;\n+            if (ike != null) throw ike;\n+            if (nsae != null) {\n+                throw new InvalidKeyException(\"No installed provider found\", nsae);\n+            }\n+            throw new InvalidKeyException(\"No installed provider supports this key: \"\n+                            + publicKey.getClass().getName(), re);\n+        }\n+\n+        private static <T extends Exception> T merge(T e1, T e2) {\n+            if (e1 == null) {\n+                return e2;\n+            } else {\n+                e1.addSuppressed(e2);\n+                return e1;\n+            }\n+        }\n+\n+        private Decapsulator newDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (privateKey == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n+            RuntimeException re = null;\n+            InvalidAlgorithmParameterException iape = null;\n+            InvalidKeyException ike = null;\n+            NoSuchAlgorithmException nsae = null;\n+            for (Provider.Service service : list) {\n+                if (!service.supportsParameter(privateKey)) {\n+                    continue;\n+                }\n+                try {\n+                    KEMSpi spi = (KEMSpi) service.newInstance(null);\n+                    return new Decapsulator(\n+                            spi.engineNewDecapsulator(privateKey, spec),\n+                            service.getProvider());\n+                } catch (NoSuchAlgorithmException e) {\n+                    nsae = merge(nsae, e);\n+                } catch (InvalidAlgorithmParameterException e) {\n+                    iape = merge(iape, e);\n+                } catch (InvalidKeyException e) {\n+                    ike = merge(ike, e);\n+                } catch (RuntimeException e) {\n+                    re = merge(re, e);\n+                }\n+            }\n+            if (iape != null) throw iape;\n+            if (ike != null) throw ike;\n+            if (nsae != null) {\n+                throw new InvalidKeyException(\"No installed provider found\", nsae);\n+            }\n+            throw new InvalidKeyException(\"No installed provider supports this key: \"\n+                    + privateKey.getClass().getName(), re);\n+        }\n+    }\n+\n+    \/\/ If delayed provider selection is needed\n+    private final DelayedKEM delayed;\n+\n+    \/\/ otherwise\n+    private final KEMSpi spi;\n+    private final Provider provider;\n+\n+    private final String algorithm;\n+\n+    private KEM(String algorithm, KEMSpi spi, Provider provider) {\n+        assert spi != null;\n+        assert provider != null;\n+        this.delayed = null;\n+        this.spi = spi;\n+        this.provider = provider;\n+        this.algorithm = algorithm;\n+    }\n+\n+    private KEM(String algorithm, DelayedKEM delayed) {\n+        assert delayed != null;\n+        this.delayed = delayed;\n+        this.spi = null;\n+        this.provider = null;\n+        this.algorithm = algorithm;\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if no {@code Provider} supports a\n+     *         {@code KEM} implementation for the specified algorithm\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm)\n+            throws NoSuchAlgorithmException {\n+        List<Provider.Service> list = GetInstance.getServices(\n+                \"KEM\",\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"));\n+        List<Provider.Service> allowed = new ArrayList<>();\n+        for (Provider.Service s : list) {\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                continue;\n+            }\n+            allowed.add(s);\n+        }\n+        if (allowed.isEmpty()) {\n+            throw new NoSuchAlgorithmException\n+                    (algorithm + \" KEM not available\");\n+        }\n+\n+        return new KEM(algorithm, new DelayedKEM(allowed.toArray(new Provider.Service[0])));\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm\n+     * from the specified security provider.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @param provider the provider. If {@code null}, this method is equivalent\n+     *                 to {@link #getInstance(String)}.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if a {@code provider} is specified and\n+     *          it does not support the specified KEM algorithm,\n+     *          or if {@code provider} is {@code null} and there is no provider\n+     *          that supports a KEM implementation of the specified algorithm\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm, Provider provider)\n+            throws NoSuchAlgorithmException {\n+        if (provider == null) {\n+            return getInstance(algorithm);\n+        }\n+        GetInstance.Instance instance = JceSecurity.getInstance(\n+                \"KEM\",\n+                KEMSpi.class,\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"),\n+                provider);\n+        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm\n+     * from the specified security provider.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @param provider the provider. If {@code null}, this method is equivalent\n+     *                 to {@link #getInstance(String)}.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if a {@code provider} is specified and\n+     *          it does not support the specified KEM algorithm,\n+     *          or if {@code provider} is {@code null} and there is no provider\n+     *          that supports a KEM implementation of the specified algorithm\n+     * @throws NoSuchProviderException if the specified provider is not\n+     *         registered in the security provider list\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        if (provider == null) {\n+            return getInstance(algorithm);\n+        }\n+        GetInstance.Instance instance = JceSecurity.getInstance(\n+                \"KEM\",\n+                KEMSpi.class,\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"),\n+                provider);\n+        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * This method is equivalent to {@code newEncapsulator(publicKey, null, null)}.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @return the encapsulator for this key\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        try {\n+            return newEncapsulator(publicKey, null, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(\n+                    \"AlgorithmParameterSpec must be provided\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * This method is equivalent to {@code newEncapsulator(publicKey, null, secureRandom)}.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code} null, a default one from the\n+     *                     implementation will be used.\n+     * @return the encapsulator for this key\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey, SecureRandom secureRandom)\n+            throws InvalidKeyException {\n+        try {\n+            return newEncapsulator(publicKey, null, secureRandom);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(\n+                    \"AlgorithmParameterSpec must be provided\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * An algorithm can define an {@code AlgorithmParameterSpec} child class to\n+     * provide extra information in this method. This is especially useful if\n+     * the same key can be used to derive shared secrets in different ways.\n+     * If any extra information inside this object needs to be transmitted along\n+     * with the key encapsulation message so that the receiver is able to create\n+     * a matching decapsulator, it will be included as a byte array in the\n+     * {@link Encapsulated#params} field inside the encapsulation output.\n+     * In this case, the security provider should provide an\n+     * {@code AlgorithmParameters} implementation using the same algorithm name\n+     * as the KEM. The receiver can initiate such an {@code AlgorithmParameters}\n+     * instance with the {@code params} byte array received and recover\n+     * an {@code AlgorithmParameterSpec} object to be used in its\n+     * {@link #newDecapsulator(PrivateKey, AlgorithmParameterSpec)} call.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code} null, a default one from the\n+     *                     implementation will be used.\n+     * @return the encapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        return delayed != null\n+                ? delayed.newEncapsulator(publicKey, spec, secureRandom)\n+                : new Encapsulator(spi.engineNewEncapsulator(publicKey, spec, secureRandom), provider);\n+    }\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     * <p>\n+     * This method is equivalent to {@code newDecapsulator(privateKey, null)}.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Decapsulator newDecapsulator(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        try {\n+            return newDecapsulator(privateKey, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @param spec the parameter, can be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     *\/\n+    public Decapsulator newDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        return delayed != null\n+                ? delayed.newDecapsulator(privateKey, spec)\n+                : new Decapsulator(spi.engineNewDecapsulator(privateKey, spec), provider);\n+    }\n+\n+    \/**\n+     * Returns the name of the algorithm for this {@code KEM} object.\n+     *\n+     * @return the name of the algorithm for this {@code KEM} object.\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":747,"deletions":0,"binary":false,"changes":747,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ * This class defines the Service Provider Interface (SPI) for the {@link KEM}\n+ * class. A security provider implements this interface to provide an\n+ * implementation of a Key Encapsulation Mechanism (KEM) algorithm.\n+ * <p>\n+ * A KEM algorithm may support a family of configurations. Each configuration\n+ * may accept different types of keys, cryptographic primitives, and sizes of\n+ * shared secrets and key encapsulation messages. A configuration is defined\n+ * by the KEM algorithm name, the key it uses, and an optional\n+ * {@code AlgorithmParameterSpec} argument that is specified when creating\n+ * an encapsulator or decapsulator. The result of calling\n+ * {@link #engineNewEncapsulator} or {@link #engineNewDecapsulator} must return\n+ * an encapsulator or decapsulator that maps to a single configuration,\n+ * where its {@code engineSecretSize()} and {@code engineEncapsulationSize()}\n+ * methods return constant values.\n+ * <p>\n+ * A {@code KEMSpi} implementation must be immutable. It must be safe to\n+ * call multiple {@code engineNewEncapsulator} and {@code engineNewDecapsulator}\n+ * methods at the same time.\n+ * <p>\n+ * {@code EncapsulatorSpi} and {@code DecapsulatorSpi} implementations must also\n+ * be immutable. It must be safe to invoke multiple {@code encapsulate} and\n+ * {@code decapsulate} methods at the same time. Each invocation of\n+ * {@code encapsulate} should generate a new shared secret and key\n+ * encapsulation message.\n+ * <p>\n+ * For example,\n+ * <pre>{@code\n+ * public static class MyKEMImpl implements KEMSpi {\n+ *\n+ *     @Override\n+ *     public KEMSpi.EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+ *             AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+ *             throws InvalidAlgorithmParameterException, InvalidKeyException {\n+ *         if (!checkPublicKey(publicKey)) {\n+ *             throw new InvalidKeyException(\"unsupported key\");\n+ *         }\n+ *         if (!checkParameters(spec)) {\n+ *             throw new InvalidAlgorithmParameterException(\"unsupported params\");\n+ *         }\n+ *         return new MyEncapsulator(publicKey, spec, secureRandom);\n+ *     }\n+ *\n+ *     class MyEncapsulator implements KEMSpi.EncapsulatorSpi {\n+ *         MyEncapsulator(PublicKey publicKey, AlgorithmParameterSpec spec,\n+ *                 SecureRandom secureRandom){\n+ *             this.spec = spec != null ? spec : getDefaultParameters();\n+ *             this.secureRandom = secureRandom != null\n+ *                     ? secureRandom\n+ *                     : getDefaultSecureRandom();\n+ *             this.publicKey = publicKey;\n+ *         }\n+ *\n+ *         @Override\n+ *         public KEM.Encapsulated encapsulate(int from, int to, String algorithm) {\n+ *             byte[] encapsulation;\n+ *             byte[] secret;\n+ *             \/\/ calculating...\n+ *             return new KEM.Encapsulated(\n+ *                     new SecretKeySpec(secret, from, to - from, algorithm),\n+ *                     encapsulation, null);\n+ *         }\n+ *\n+ *         \/\/ ...\n+ *     }\n+ *\n+ *     \/\/ ...\n+ * }\n+ * }<\/pre>\n+ *\n+ * @see KEM\n+ * @since 21\n+ *\/\n+public interface KEMSpi {\n+\n+    \/**\n+     * The KEM encapsulator implementation, generated by\n+     * {@link #engineNewEncapsulator} on the KEM sender side.\n+     *\n+     * @see KEM.Encapsulator\n+     *\n+     * @since 21\n+     *\/\n+    interface EncapsulatorSpi {\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * Each invocation of this method must generate a new secret key and key\n+         * encapsulation message that is returned in an {@link KEM.Encapsulated} object.\n+         * <p>\n+         * An implementation must support the case where {@code from} is 0,\n+         * {@code to} is the same as the return value of {@code secretSize()},\n+         * and {@code algorithm} is \"Generic\".\n+         *\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return an {@link KEM.Encapsulated} object containing a portion of\n+         *          the shared secret as a key with the specified algorithm,\n+         *          key encapsulation message, and optional parameters.\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the encapsulator\n+         * @see KEM.Encapsulated\n+         * @see KEM.Encapsulator#encapsulate(int, int, String)\n+         *\/\n+        KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm);\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         *\n+         * @return the size of the shared secret as a finite non-negative integer\n+         * @see KEM.Encapsulator#secretSize()\n+         *\/\n+        int engineSecretSize();\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         *\n+         * @return the size of the key encapsulation message as a finite non-negative integer\n+         * @see KEM.Encapsulator#encapsulationSize()\n+         *\/\n+        int engineEncapsulationSize();\n+    }\n+\n+    \/**\n+     * The KEM decapsulator implementation, generated by\n+     * {@link #engineNewDecapsulator} on the KEM receiver side.\n+     *\n+     * @see KEM.Decapsulator\n+     *\n+     * @since 21\n+     *\/\n+    interface DecapsulatorSpi {\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * An invocation of this method recovers the secret key from the key\n+         * encapsulation message.\n+         * <p>\n+         * An implementation must support the case where {@code from} is 0,\n+         * {@code to} is the same as the return value of {@code secretSize()},\n+         * and {@code algorithm} is \"Generic\".\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #engineEncapsulationSize()} ()}, or a\n+         *          {@code DecapsulateException} must be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a portion of the shared secret as a {@code SecretKey} with\n+         *          the specified algorithm\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n+         * @see KEM.Decapsulator#decapsulate(byte[], int, int, String)\n+         *\/\n+        SecretKey engineDecapsulate(byte[] encapsulation, int from, int to, String algorithm)\n+                throws DecapsulateException;\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         *\n+         * @return the size of the shared secret as a finite non-negative integer\n+         * @see KEM.Decapsulator#secretSize()\n+         *\/\n+        int engineSecretSize();\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         *\n+         * @return the size of the key encapsulation message as a finite non-negative integer\n+         * @see KEM.Decapsulator#encapsulationSize()\n+         *\/\n+        int engineEncapsulationSize();\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code null}, the implementation must provide\n+     *                     a default one.\n+     * @return the encapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @see KEM#newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)\n+     *\/\n+    EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     * @see KEM#newDecapsulator(PrivateKey, AlgorithmParameterSpec)\n+     *\/\n+    DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException;\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEMSpi.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,533 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297878\n+ * @summary RSA_KEM example\n+ * @modules java.base\/sun.security.jca\n+ *          java.base\/sun.security.rsa\n+ *          java.base\/sun.security.util\n+ *          java.base\/javax.crypto:+open\n+ *\/\n+import sun.security.jca.JCAUtil;\n+import sun.security.rsa.RSACore;\n+import sun.security.util.*;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/\/ This test implements RSA-KEM as described in RFC 5990. In this KEM, the\n+\/\/ sender configures the encapsulator with an RSAKEMParameterSpec object.\n+\/\/ This object is encoded as a byte array and included in the Encapsulated\n+\/\/ output. The receiver is then able to recover the same RSAKEMParameterSpec\n+\/\/ object from the encoding using an AlgorithmParameters implementation\n+\/\/ and use the object to configure the decapsulator.\n+public class RSA_KEM {\n+    public static void main(String[] args) throws Exception {\n+        Provider p = new ProviderImpl();\n+        RSAKEMParameterSpec[] kspecs = new RSAKEMParameterSpec[] {\n+                RSAKEMParameterSpec.kdf1(\"SHA-256\", \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf1(\"SHA-512\", \"AES_256\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf2(\"SHA-256\", \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf2(\"SHA-512\", \"AES_256\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-256\", new byte[10], \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-256\", new byte[0], \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-512\", new byte[0], \"AES_128\/KW\/NoPadding\"),\n+        };\n+        for (RSAKEMParameterSpec kspec : kspecs) {\n+            System.err.println(\"---------\");\n+            System.err.println(kspec);\n+            AlgorithmParameters d = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+            d.init(kspec);\n+            AlgorithmParameters s = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+            s.init(d.getEncoded());\n+            AlgorithmParameterSpec spec = s.getParameterSpec(AlgorithmParameterSpec.class);\n+            if (!spec.toString().equals(kspec.toString())) {\n+                throw new RuntimeException(spec.toString());\n+            }\n+        }\n+        byte[] msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        byte[] iv = new byte[16];\n+        for (int size : List.of(1024, 2048)) {\n+            KeyPairGenerator g = KeyPairGenerator.getInstance(\"RSA\");\n+            g.initialize(size);\n+            KeyPair kp = g.generateKeyPair();\n+            for (RSAKEMParameterSpec kspec : kspecs) {\n+                SecretKey cek = KeyGenerator.getInstance(\"AES\").generateKey();\n+                KEM kem1 = getKemImpl(p);\n+                Cipher c = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n+                c.init(Cipher.ENCRYPT_MODE, cek, new IvParameterSpec(iv));\n+                byte[] ciphertext = c.doFinal(msg);\n+\n+                KEM.Encapsulator e = kem1.newEncapsulator(kp.getPublic(), kspec, null);\n+                KEM.Encapsulated enc = e.encapsulate(0, e.secretSize(), \"AES\");\n+                Cipher c2 = Cipher.getInstance(kspec.encAlg);\n+                c2.init(Cipher.WRAP_MODE, enc.key());\n+                byte[] ek = c2.wrap(cek);\n+\n+                AlgorithmParameters a = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+                a.init(enc.params());\n+                KEM kem2 = getKemImpl(p);\n+                KEM.Decapsulator d = kem2.newDecapsulator(kp.getPrivate(), a.getParameterSpec(AlgorithmParameterSpec.class));\n+                SecretKey k = d.decapsulate(enc.encapsulation(), 0, d.secretSize(), \"AES\");\n+                Cipher c3 = Cipher.getInstance(kspec.encAlg);\n+                c3.init(Cipher.UNWRAP_MODE, k);\n+                cek = (SecretKey) c3.unwrap(ek, \"AES\", Cipher.SECRET_KEY);\n+                Cipher c4 = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n+                c4.init(Cipher.DECRYPT_MODE, cek, new IvParameterSpec(iv));\n+                byte[] cleartext = c4.doFinal(ciphertext);\n+\n+                if (!Arrays.equals(cleartext, msg)) {\n+                    throw new RuntimeException();\n+                }\n+                System.out.printf(\"%4d %20s - %11d %11d %11d %11d %s\\n\",\n+                        size, kspec,\n+                        e.secretSize(), e.encapsulationSize(),\n+                        d.secretSize(), d.encapsulationSize(), k.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    \/\/ To bypass the JCE security provider signature check\n+    private static KEM getKemImpl(Provider p) throws Exception {\n+        var ctor = KEM.class.getDeclaredConstructor(\n+                String.class, KEMSpi.class, Provider.class);\n+        ctor.setAccessible(true);\n+        return ctor.newInstance(\"RSA-KEM\", new KEMImpl(), p);\n+    }\n+\n+    static final String RSA_KEM = \"1.2.840.113549.1.9.16.3.14\";\n+    static final String KEM_RSA = \"1.0.18033.2.2.4\";\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"MYKEM\", \"1\", \"RSA-KEM\");\n+            List<String> alias = List.of(RSA_KEM, \"OID.\" + RSA_KEM);\n+            Map<String, String> attrs = Map.of(\n+                    \"SupportedKeyClasses\", \"java.security.interfaces.RSAKey\");\n+            putService(new Service(this, \"KEM\", \"RSA-KEM\",\n+                    \"RSA_KEM$KEMImpl\", alias, attrs));\n+            putService(new Service(this, \"AlgorithmParameters\", \"RSA-KEM\",\n+                    \"RSA_KEM$AlgorithmParametersImpl\", alias, attrs));\n+        }\n+    }\n+\n+    public static class AlgorithmParametersImpl extends AlgorithmParametersSpi {\n+        RSAKEMParameterSpec spec;\n+        @Override\n+        protected void engineInit(AlgorithmParameterSpec paramSpec)\n+                throws InvalidParameterSpecException {\n+            if (paramSpec instanceof RSAKEMParameterSpec rspec) {\n+                spec = rspec;\n+            } else {\n+                throw new InvalidParameterSpecException();\n+            }\n+        }\n+\n+        @Override\n+        protected void engineInit(byte[] params) throws IOException {\n+            spec = decode(params);\n+        }\n+\n+        @Override\n+        protected void engineInit(byte[] params, String format) throws IOException {\n+            spec = decode(params);\n+        }\n+\n+        @Override\n+        protected <T extends AlgorithmParameterSpec> T engineGetParameterSpec(\n+                Class<T> paramSpec) throws InvalidParameterSpecException {\n+            if (paramSpec.isAssignableFrom(RSAKEMParameterSpec.class)) {\n+                return paramSpec.cast(spec);\n+            } else {\n+                throw new InvalidParameterSpecException();\n+            }\n+        }\n+\n+        @Override\n+        protected byte[] engineGetEncoded() throws IOException {\n+            return encode(spec);\n+        }\n+\n+        @Override\n+        protected byte[] engineGetEncoded(String format) throws IOException {\n+            return encode(spec);\n+        }\n+\n+        @Override\n+        protected String engineToString() {\n+            return spec == null ? \"<null>\" : spec.toString();\n+        }\n+\n+        static final ObjectIdentifier id_rsa_kem;\n+        static final ObjectIdentifier id_kem_rsa;\n+        static final ObjectIdentifier id_kdf1;\n+        static final ObjectIdentifier id_kdf2;\n+        static final ObjectIdentifier id_kdf3;\n+\n+        static {\n+            try {\n+                id_rsa_kem = ObjectIdentifier.of(\"1.2.840.113549.1.9.16.3.14\");\n+                id_kem_rsa = ObjectIdentifier.of(\"1.0.18033.2.2.4\");\n+                id_kdf1 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.0\"); \/\/ fake\n+                id_kdf2 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.1\");\n+                id_kdf3 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.2\");\n+            } catch (IOException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static byte[] encode(RSAKEMParameterSpec spec) throws IOException {\n+            var d1 = new DerOutputStream();\n+            d1.putOID(oid4(spec.hashAlg));\n+            var d2 = new DerOutputStream();\n+            d2.putOID(oid4(spec.kdfAlg));\n+            d2.write(DerValue.tag_Sequence, d1);\n+            DerOutputStream kdf = new DerOutputStream();\n+            kdf.write(DerValue.tag_Sequence, d2);\n+            kdf.putInteger(spec.kdfLen());\n+            \/\/ The next line is not in RFC 5990\n+            if (spec.fixedInfo != null) {\n+                kdf.putOctetString(spec.fixedInfo);\n+            }\n+            var d3 = new DerOutputStream();\n+            d3.putOID(oid4(spec.encAlg));\n+            var d4 = new DerOutputStream();\n+            d4.putOID(id_kem_rsa);\n+            d4.write(DerValue.tag_Sequence, kdf);\n+            var d5 = new DerOutputStream();\n+            d5.write(DerValue.tag_Sequence, d4);\n+            d5.write(DerValue.tag_Sequence, d3);\n+            var d6 = new DerOutputStream();\n+            d6.write(DerValue.tag_Sequence, d5);\n+            return d6.toByteArray();\n+        }\n+\n+        static RSAKEMParameterSpec decode(byte[] der) throws IOException {\n+            System.out.println(new HexDumpEncoder().encodeBuffer(der));\n+            String kdfAlg, encAlg, hashAlg;\n+            int kdfLen;\n+            byte[] fixedInfo;\n+            DerInputStream d2 = new DerValue(der).toDerInputStream();\n+            DerInputStream d3 = d2.getDerValue().toDerInputStream();\n+            if (!d3.getOID().equals(id_kem_rsa)) {\n+                throw new IOException(\"not id_kem_rsa\");\n+            }\n+            DerInputStream d4 = d3.getDerValue().toDerInputStream();\n+            DerInputStream d5 = d4.getDerValue().toDerInputStream();\n+            kdfLen = d4.getInteger();\n+            fixedInfo = d4.available() > 0 ? d4.getOctetString() : null;\n+            if (d4.available() != 0) {\n+                throw new IOException(\"Extra unused bytes\");\n+            }\n+            ObjectIdentifier kdfOid = d5.getOID();\n+            if (kdfOid.equals(id_kdf1)) {\n+                kdfAlg = \"kdf1\";\n+            } else if (kdfOid.equals(id_kdf2)) {\n+                kdfAlg = \"kdf2\";\n+            } else if (kdfOid.equals(id_kdf3)) {\n+                kdfAlg = \"kdf3\";\n+            } else {\n+                throw new IOException(\"unknown kdf\");\n+            }\n+            DerInputStream d6 = d5.getDerValue().toDerInputStream();\n+            String hashOID = d6.getOID().toString();\n+            KnownOIDs k = KnownOIDs.findMatch(hashOID);\n+            hashAlg = k == null ? hashOID : k.stdName();\n+            if (d6.available() != 0) {\n+                throw new IOException(\"Extra unused bytes\");\n+            }\n+            if (d5.available() != 0) {\n+                throw new IOException(\"Extra unused bytes\");\n+            }\n+\n+            if (d3.available() != 0) {\n+                throw new IOException(\"Extra unused bytes\");\n+            }\n+            DerInputStream d7 = d2.getDerValue().toDerInputStream();\n+            String encOID = d7.getOID().toString();\n+            KnownOIDs e = KnownOIDs.findMatch(encOID);\n+            encAlg = e == null ? encOID : e.stdName();\n+            if (d7.available() != 0) {\n+                throw new IOException(\"Extra unused bytes\");\n+            }\n+            if (d2.available() != 0) {\n+                throw new IOException(\"Extra unused bytes\");\n+            }\n+            if (kdfLen != RSAKEMParameterSpec.kdfLen(encAlg)) {\n+                throw new IOException(\"kdfLen does not match encAlg\");\n+            }\n+            return new RSAKEMParameterSpec(kdfAlg, hashAlg, fixedInfo, encAlg);\n+        }\n+\n+        static ObjectIdentifier oid4(String s) {\n+            return switch (s) {\n+                case \"kdf1\" -> id_kdf1;\n+                case \"kdf2\" -> id_kdf2;\n+                case \"kdf3\" -> id_kdf3;\n+                default -> {\n+                    KnownOIDs k = KnownOIDs.findMatch(s);\n+                    if (k == null) throw new UnsupportedOperationException();\n+                    yield ObjectIdentifier.of(k);\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class RSAKEMParameterSpec implements AlgorithmParameterSpec {\n+        private final String kdfAlg;\n+        private final String hashAlg;\n+        private final byte[] fixedInfo;\n+        private final String encAlg;\n+\n+        private RSAKEMParameterSpec(String kdfAlg, String hashAlg, byte[] fixedInfo, String encAlg) {\n+            this.hashAlg = hashAlg;\n+            this.kdfAlg = kdfAlg;\n+            this.fixedInfo = fixedInfo == null ? null : fixedInfo.clone();\n+            this.encAlg = encAlg;\n+        }\n+\n+        public static RSAKEMParameterSpec kdf1(String hashAlg, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf1\", hashAlg, null, encAlg);\n+        }\n+        public static RSAKEMParameterSpec kdf2(String hashAlg, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf2\", hashAlg, null, encAlg);\n+        }\n+        public static RSAKEMParameterSpec kdf3(String hashAlg, byte[] fixedInfo, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf3\", hashAlg, fixedInfo, encAlg);\n+        }\n+\n+        public int kdfLen() {\n+            return RSAKEMParameterSpec.kdfLen(encAlg);\n+        }\n+\n+        public static int kdfLen(String encAlg) {\n+            return Integer.parseInt(encAlg, 4, 7, 10) \/ 8;\n+        }\n+\n+        public String hashAlgorithm() {\n+            return hashAlg;\n+        }\n+        public String kdfAlgorithm() {\n+            return kdfAlg;\n+        }\n+        public byte[] fixedInfo() {\n+            return fixedInfo == null ? null : fixedInfo.clone();\n+        }\n+\n+        public String getEncAlg() {\n+            return encAlg;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s,%s,%s]\", kdfAlg, hashAlg, encAlg);\n+        }\n+    }\n+\n+    public static class KEMImpl implements KEMSpi {\n+\n+        @Override\n+        public KEMSpi.EncapsulatorSpi engineNewEncapsulator(\n+                PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!(pk instanceof RSAPublicKey rpk)) {\n+                throw new InvalidKeyException(\"Not an RSA key\");\n+            }\n+            return Handler.newEncapsulator(spec, rpk, secureRandom);\n+        }\n+\n+        @Override\n+        public KEMSpi.DecapsulatorSpi engineNewDecapsulator(\n+                PrivateKey sk, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!(sk instanceof RSAPrivateCrtKey rsk)) {\n+                throw new InvalidKeyException(\"Not an RSA key\");\n+            }\n+            return Handler.newDecapsulator(spec, rsk);\n+        }\n+\n+        static class Handler implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+\n+            private final RSAPublicKey rpk; \/\/ not null for encapsulator\n+            private final RSAPrivateKey rsk; \/\/ not null for decapsulator\n+            private final RSAKEMParameterSpec kspec; \/\/ not null\n+            private final SecureRandom sr; \/\/ not null for encapsulator\n+\n+            Handler(AlgorithmParameterSpec spec, RSAPublicKey rpk, RSAPrivateCrtKey rsk, SecureRandom sr)\n+                    throws InvalidAlgorithmParameterException {\n+                this.rpk = rpk;\n+                this.rsk = rsk;\n+                this.sr = sr;\n+                if (spec != null) {\n+                    if (spec instanceof RSAKEMParameterSpec rs) {\n+                        this.kspec = rs;\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException();\n+                    }\n+                } else {\n+                    this.kspec = RSAKEMParameterSpec\n+                            .kdf2(\"SHA-256\", \"AES_256\/KW\/NoPadding\");\n+                }\n+            }\n+\n+            static Handler newEncapsulator(AlgorithmParameterSpec spec, RSAPublicKey rpk, SecureRandom sr)\n+                    throws InvalidAlgorithmParameterException {\n+                if (sr == null) {\n+                    sr = JCAUtil.getDefSecureRandom();\n+                }\n+                return new Handler(spec, rpk, null, sr);\n+            }\n+\n+            static Handler newDecapsulator(AlgorithmParameterSpec spec, RSAPrivateCrtKey rsk)\n+                    throws InvalidAlgorithmParameterException {\n+                return new Handler(spec, null, rsk, null);\n+            }\n+\n+            @Override\n+            public SecretKey engineDecapsulate(byte[] encapsulation,\n+                    int from, int to, String algorithm)\n+                    throws DecapsulateException {\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+                if (encapsulation.length != KeyUtil.getKeySize(rsk) \/ 8) {\n+                    throw new DecapsulateException(\"incorrect encapsulation size\");\n+                }\n+                try {\n+                    byte[] Z = RSACore.rsa(encapsulation, rsk, false);\n+                    return new SecretKeySpec(kdf(Z), from, to - from, algorithm);\n+                } catch (BadPaddingException e) {\n+                    throw new DecapsulateException(\"cannot decrypt\", e);\n+                }\n+            }\n+\n+            @Override\n+            public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                int nLen = rpk.getModulus().bitLength();\n+                int nSize = (nLen + 7) \/ 8;\n+                BigInteger z;\n+                int tried = 0;\n+                while (true) {\n+                    z = new BigInteger(nLen, sr);\n+                    if (z.compareTo(rpk.getModulus()) < 0) {\n+                        break;\n+                    }\n+                    if (tried++ > 20) {\n+                        throw new ProviderException(\"Cannot get good random number\");\n+                    }\n+                }\n+                byte[] Z = z.toByteArray();\n+                if (Z.length > nSize) {\n+                    Z = Arrays.copyOfRange(Z, Z.length - nSize, Z.length);\n+                } else if (Z.length < nSize) {\n+                    byte[] tmp = new byte[nSize];\n+                    System.arraycopy(Z, 0, tmp, nSize - Z.length, Z.length);\n+                    Z = tmp;\n+                }\n+                byte[] c;\n+                try {\n+                    c = RSACore.rsa(Z, rpk);\n+                } catch (BadPaddingException e) {\n+                    throw new AssertionError(e);\n+                }\n+                try {\n+                    return new KEM.Encapsulated(\n+                            new SecretKeySpec(kdf(Z), from, to - from, algorithm),\n+                            c, AlgorithmParametersImpl.encode(kspec));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            byte[] kdf(byte[] input) {\n+                String hashAlg = kspec.hashAlgorithm();\n+                MessageDigest md;\n+                try {\n+                    md = MessageDigest.getInstance(hashAlg);\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new ProviderException(e);\n+                }\n+                String kdfAlg = kspec.kdfAlgorithm();\n+                byte[] fixedInput = kspec.fixedInfo();\n+                int length = kspec.kdfLen();\n+\n+                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                int n = kdfAlg.equals(\"kdf1\") ? 0 : 1;\n+                while (true) {\n+                    switch (kdfAlg) {\n+                        case \"kdf1\", \"kdf2\" -> {\n+                            md.update(input);\n+                            md.update(u32str(n));\n+                        }\n+                        case \"kdf3\" -> {\n+                            md.update(u32str(n));\n+                            md.update(input);\n+                            md.update(fixedInput);\n+                        }\n+                        default -> throw new ProviderException();\n+                    }\n+                    bout.writeBytes(md.digest());\n+                    if (bout.size() > length) break;\n+                    n++;\n+                }\n+                byte[] result = bout.toByteArray();\n+                return result.length == length\n+                        ? result\n+                        : Arrays.copyOf(result, length);\n+            }\n+\n+            @Override\n+            public int engineSecretSize() {\n+                return kspec.kdfLen();\n+            }\n+\n+            @Override\n+            public int engineEncapsulationSize() {\n+                return KeyUtil.getKeySize(rsk == null ? rpk : rsk) \/ 8;\n+            }\n+        }\n+    }\n+\n+    static byte[] u32str(int i) {\n+        return new byte[] {\n+                (byte)(i >> 24), (byte)(i >> 16), (byte)(i >> 8), (byte)i };\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/RSA_KEM.java","additions":533,"deletions":0,"binary":false,"changes":533,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+public class A {\n+    public static void main(String[] args) throws Exception {\n+        B.go();\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/proc\/A.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+public class B {\n+    public static void go() {\n+        System.out.println(\"Hello\");\n+        System.err.println(\"World\");\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/proc\/B.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.test.lib.process.Proc;\n+\n+\/*\n+ * @test\n+ * @bug 8305846\n+ * @library \/test\/lib\n+ *\/\n+public class Launcher {\n+    public static void main(String[] args) throws Exception {\n+        Proc.create(\"A\")\n+                .compile()\n+                .start()\n+                .output()\n+                .stdoutShouldContain(\"Hello\")\n+                .stderrShouldContain(\"World\");\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/proc\/Launcher.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+\n@@ -121,1 +123,5 @@\n-    private List<String> cp;        \/\/ user-provided classpath\n+    private boolean addcp;          \/\/ user-provided classpath is appended\n+    private List<String> cp;        \/\/ user-provided classpaths\n+\n+    private boolean compile;        \/\/ compile the program as well\n+\n@@ -127,0 +133,2 @@\n+    private final StringBuilder stdout = new StringBuilder();\n+\n@@ -197,2 +205,1 @@\n-    \/\/ Sets classpath. If not called, Proc will choose a classpath. If called\n-    \/\/ with no arg, no classpath will be used. Can be called multiple times.\n+    \/\/ Sets classpath. Can be called multiple times.\n@@ -206,0 +213,6 @@\n+    \/\/ Adds classpath to defaults. Can be called multiple times.\n+    \/\/ Once called, addcp is always true.\n+    public Proc addcp(String... s) {\n+        addcp = true;\n+        return cp(s);\n+    }\n@@ -261,0 +274,28 @@\n+    \/\/ Compile as well\n+    public Proc compile() {\n+        compile = true;\n+        return this;\n+    }\n+\n+    \/\/ get full classpath.\n+    \/\/ 1. Default classpath used if neither cp() or addcp() is called\n+    \/\/ 2. User provided classpath (can be empty) used if only cp() is called\n+    \/\/ 3. User provided classpath + default classpath used, otherwise\n+    String fullcp() {\n+        if (cp == null) {\n+            return System.getProperty(\"test.class.path\") + File.pathSeparator +\n+                    System.getProperty(\"test.src.path\");\n+        } else {\n+            var newcp = new ArrayList<>(cp);\n+            if (addcp) {\n+                newcp.add(System.getProperty(\"test.class.path\"));\n+                newcp.add(System.getProperty(\"test.src.path\"));\n+            }\n+            if (!newcp.isEmpty()) {\n+                return newcp.stream().collect(Collectors.joining(File.pathSeparator));\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n@@ -284,4 +325,2 @@\n-        Collections.addAll(cmd, splitProperty(\"test.vm.opts\"));\n-        Collections.addAll(cmd, splitProperty(\"test.java.opts\"));\n-\n-        if (cp == null) {\n+        var lcp = fullcp();\n+        if (lcp != null) {\n@@ -289,5 +328,12 @@\n-            cmd.add(System.getProperty(\"test.class.path\") + File.pathSeparator +\n-                    System.getProperty(\"test.src.path\"));\n-        } else if (!cp.isEmpty()) {\n-            cmd.add(\"-cp\");\n-            cmd.add(cp.stream().collect(Collectors.joining(File.pathSeparator)));\n+            cmd.add(lcp);\n+        }\n+\n+        if (compile) {\n+            boolean comp = CompilerUtils.compile(\n+                    Path.of(System.getProperty(\"test.src\"), clazz + \".java\"),\n+                    Path.of(System.getProperty(\"test.classes\")),\n+                    cmd.subList(1, cmd.size()).toArray(new String[0]));\n+                        \/\/ subList(1): all options added without launcher name\n+            if (!comp) {\n+                throw new RuntimeException(\"Compilation error\");\n+            }\n@@ -296,0 +342,3 @@\n+        Collections.addAll(cmd, splitProperty(\"test.vm.opts\"));\n+        Collections.addAll(cmd, splitProperty(\"test.java.opts\"));\n+\n@@ -361,0 +410,3 @@\n+        if (s != null) {\n+            stdout.append(s).append('\\n');\n+        }\n@@ -412,0 +464,9 @@\n+    \/\/ Returns an OutputAnalyzer\n+    public OutputAnalyzer output() throws Exception {\n+        int exitCode = waitFor();\n+        Path stderr = Path.of(getId(\"stderr\"));\n+        return new OutputAnalyzer(stdout.toString(),\n+                Files.exists(stderr) ? Files.readString(stderr) : \"\",\n+                exitCode);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/Proc.java","additions":74,"deletions":13,"binary":false,"changes":87,"status":"modified"}]}