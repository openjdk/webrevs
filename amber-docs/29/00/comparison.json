{"files":[{"patch":"@@ -81,0 +81,1 @@\n+    -   [Data-Oriented Programming for Java: Beyond Records](design-notes\/beyond-records) (January 2026)\n","filename":"site\/_index.md","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,688 @@\n+# Data-Oriented Programming for Java: Beyond Records\n+#### Brian Goetz {.author}\n+#### January 2026 {.date}\n+\n+Everyone loves records; they allow us to create shallowly immutable data holder\n+classes -- which we can think of as \"nominal tuples\" -- derived from a concise\n+state description, and to destructure records through pattern matching.  But\n+records have strict constraints, and not all data holder classes fit into the\n+restrictions of records.  Maybe they have some mutable state, or derived or\n+cached state that is not part of the state description, or their representation\n+and their API do not match up exactly, or they need to break up their state\n+across a hierarchy.  In these classes, even though they may also be “data\n+holders”, the user experience is like falling off a cliff.  Even a small\n+deviation from the record ideal means one has to go back to a blank slate and\n+write explicit constructor declarations, accessor method declarations, and\n+Object method implementations -- and give up on destructuring through pattern\n+matching.\n+\n+Since the start of the design process for records, we’ve kept in mind the goal\n+of enabling a broader range of classes to gain access to the \"record goodies\":\n+reduced declaration burden, participating in destructuring, and soon,\n+[reconstruction](https:\/\/openjdk.org\/jeps\/468). During the design of records, we\n+also explored a number of weaker semantic models that would allow for greater\n+flexibility. While at the time they all failed to live up to the goals _for\n+records_, there is a weaker set of semantic constraints we can impose that\n+allows for more flexibility and still enables the features we want, along with\n+some degree of syntactic concision that is commensurate with the distance from\n+the record-ideal, without fall-off-the-cliff behaviors.\n+\n+Records, sealed classes, and destructuring with record patterns constitute the\n+first feature arc of \"data-oriented programming\" for Java.  After considering\n+numerous design ideas, we're now ready to move forward with the next \"data\n+oriented programming\" feature arc: _carrier classes_ (and interfaces.)\n+\n+## Beyond record patterns\n+\n+Record patterns allow a record instance to be destructured into its components.\n+Record patterns can be used in `instanceof` and `switch`, and when a record\n+pattern is also exhaustive, will be usable in the upcoming\n+[_pattern assignment statement_](https:\/\/mail.openjdk.org\/pipermail\/amber-spec-experts\/2026-January\/004306.html) feature.\n+\n+In exploring the question \"how will classes be able to participate in the same\n+sort of destructuring as records\", we had initially focused on a new form of\n+declaration in a class -- a \"deconstructor\" -- that operated as a constructor in\n+reverse. Just as a constructor takes component values and produces an aggregate\n+instance, a deconstructor would take an aggregate instance and recover its\n+component values.\n+\n+But as this exploration played out, the more interesting question turned out to\n+be: which classes are suitable for destructuring in the first place? And the\n+answer to that question led us to a different approach for expressing\n+deconstruction.  The classes that are suitable for destructuring are those that,\n+like records, are little more than carriers for a specific tuple of data. This\n+is not just a thing that a class _has_, like a constructor or method, but\n+something a class _is_.  And as such, it makes more sense to describe\n+deconstruction as a top-level property of a class.  This, in turn, leads to a\n+number of simplifications.\n+\n+## The power of the state description\n+\n+Records are a semantic feature; they are only incidentally concise.  But they\n+_are_ concise; when we declare a record\n+\n+```{.java}\n+record Point(int x, int y) { ... }\n+```\n+\n+we automatically get a sensible API (canonical constructor, deconstruction\n+pattern, accessor methods for each component) and implementation (fields,\n+constructor, accessor methods, Object methods.)  We can explicitly specify most\n+of these (except the fields) if we like, but most of the time we don't have to,\n+because the default is exactly what we want.\n+\n+A record is a shallowly-immutable, final class whose API and representation are\n+_completely defined_ by its _state description_.  (The slogan for records is\n+\"the state, the whole state, and nothing but the state.\")  The state description\n+is the ordered list of _record components_ declared in the record's header.  A\n+component is more than a mere field or accessor method; it is an API element on\n+its own, describing a state element that instances of the class have.\n+\n+The state description of a record has several desirable properties:\n+\n+ - The components in the order specified, are the _canonical_ description of the\n+   record's state.\n+ - The components are the _complete_ description of the record’s state.\n+ - The components are _nominal_; their names are a committed part of the\n+   record's API.\n+\n+Records derive their benefits from making two commitments:\n+\n+ - The _external_ commitment that the data-access API of a record (constructor,\n+   deconstruction pattern, and component accessor methods) is defined by the\n+   state description.\n+ - The _internal_ commitments that the _representation_ of the record (its\n+   fields) is also completely defined by the state description.\n+\n+These semantic properties are what enable us to derive almost everything about\n+records.  We can derive the API of the canonical constructor because the state\n+description is canonical.  We can derive the API for the component accessor\n+methods because the state description is nominal.  And we can derive a\n+deconstruction pattern from the accessor methods because the state description\n+is complete (along with sensible implementations for the state-related `Object`\n+methods.)\n+\n+The internal commitment that the state description is also the representation\n+allows us to completely derive the rest of the implementation.  Records get a\n+(private, final) field for each component, but more importantly, there is a\n+clear mapping between these fields and their corresponding components, which is\n+what allows us to derive the canonical constructor and accessor method\n+implementations.\n+\n+Records can additionally declare a _compact constructor_ that allows us to elide\n+the boilerplate aspects of record constructors -- the argument list and field\n+assignments -- and just specify the code that is _not_ mechanically derivable.\n+This is more concise, less error-prone, and easier to read:\n+\n+```{.java}\n+record Rational(int num, int denom) {\n+    Rational {\n+        if (denom == 0)\n+            throw new IllegalArgumentException(\"denominator cannot be zero\");\n+    }\n+}\n+```\n+\n+is shorthand for the more explicit\n+\n+```{.java}\n+record Rational(int num, int denom) {\n+    Rational(int num, int denom) {\n+        if (denom == 0)\n+            throw new IllegalArgumentException(\"denominator cannot be zero\");\n+        this.num = num;\n+        this.denom = denom;\n+    }\n+}\n+```\n+\n+While compact constructors are pleasantly concise, the more important benefit is\n+that by eliminating the mechanically derivable code, the \"more interesting\" code\n+comes to the fore.\n+\n+Looking ahead, the state description is a gift that keeps on giving.  These\n+semantic commitments are enablers for a number of potential future language and\n+library features for managing object lifecycle, such as:\n+\n+ - [Reconstruction](https:\/\/openjdk.org\/jeps\/468) of record instances, allowing\n+   the appearance of controlled mutation of record state.\n+ - Automatic marshalling and unmarshalling of record instances.\n+ - Instantiating or destructuring record instances identifying components\n+   nominally rather than positionally.\n+\n+### Reconstruction\n+\n+JEP 468 proposes a mechanism by which a new record instance can be derived from\n+an existing one using syntax that is evocative of direct mutation, via a `with`\n+expression:\n+\n+```{.java}\n+record Complex(double re, double im) { }\n+Complex c = ...\n+Complex cConjugate = c with { im = -im; };\n+```\n+\n+The block on the right side of `with` can contain any Java statements, not just\n+assignments.  It is enhanced with mutable variables (_component variables_) for\n+each component of the record, initialized to the value of that component in the\n+record instance on the left, the block is executed, and a new record instance is\n+created whose component values are the ending values of the component variables.\n+\n+A reconstruction expression implicitly destructures the record instance using\n+the canonical deconstruction pattern, executes the block in a scope enhanced\n+with the component variables, and then creates a new record using the canonical\n+constructor.  Invariant checking is centralized in the canonical constructor, so\n+if the new state is not valid, the reconstruction will fail.  JEP 468 has been\n+\"on hold\" for a while, primarily because we were waiting for sufficient\n+confidence that there was a path to extending it to suitable classes before\n+committing to it for records.  The ideal path would be for those classes to also\n+support a notion of canonical constructor and deconstruction pattern.\n+\n+Careful readers will note a similarity between the transformation block of a\n+`with` expression and the body of a compact constructor.  In both cases, the\n+block is \"preloaded\" with a set of component variables, initialized to suitable\n+starting values, the block can mutate those variables as desired, and upon\n+normal completion of the block, those variables are passed to a canonical\n+constructor to produce the final result.  The main difference is where the\n+starting values come from; for a compact constructor, it is from the constructor\n+parameters, and for a reconstruction expression, it is from the canonical\n+deconstruction pattern of the source record to the left of `with`.\n+\n+### Breaking down the cliff\n+\n+Records make a strong semantic commitment to derive both their API and\n+representation from the state description, and in return get a lot of help from\n+the language.  We can now turn our attention to smoothing out \"the cliff\" --\n+identifying weaker semantic commitments that classes can make that would still\n+allow classes to get _some_ help from the language.  And ideally, the amount of\n+help you give up would be proportional to the degree of deviation from the\n+record ideal.\n+\n+With records, we got a lot of mileage out of having a complete, canonical,\n+nominal state description.  Where the record contract is sometimes too\n+constraining is the _implementation_ contract that the representation aligns\n+exactly with the state description, that the class is final, that the fields are\n+final, and that the class may not extend anything but `Record`.\n+\n+Our path here takes one step back and one step forward: keeping the external\n+commitment to the state description, but dropping the internal commitment that\n+the state description _is_ the representation -- and then _adding back_ a simple\n+mechanism for mapping fields representing components back to their corresponding\n+components, where practical.  (With records, because we derive the\n+representation from the state description, this mapping can be safely inferred.)\n+\n+As a thought experiment, imagine a class that makes the external commitment to a\n+state description -- that the state description is a complete, canonical,\n+nominal description of its state -- but is on its own to provide its\n+representation.  What can we do for such a class?  Quite a bit, actually.  For\n+all the same reasons we can for records, we can derive the API requirement for a\n+canonical constructor and component accessor methods.  From there, we can derive\n+both the requirement for a canonical deconstruction pattern, and also the\n+implementation of the deconstruction pattern (as it is implemented in terms of\n+the accessor methods). And since the state description is complete, we can\n+further derive sensible default implementations of the Object methods `equals`,\n+`hashCode`, and `toString` in terms of the accessor methods as well. And given\n+that there is a canonical constructor and deconstruction pattern, it can also\n+participate in reconstruction.  The author would just have to provide the\n+fields, accessor methods, and canonical constructor.  This is good progress, but\n+we'd like to do better.\n+\n+What enables us to derive the rest of the implementation for records (fields,\n+constructor, accessor methods, and Object methods) is the knowledge of how the\n+representation maps to the state description.  Records commit to their state\n+description _being_ the representation, so is is a short leap from there to a\n+complete implementation.\n+\n+To make this more concrete, let's look at a typical \"almost record\" class, a\n+carrier for the state description `(int x, int y, Optional<String> s)` but which\n+has made the representation choice to internally store `s` as a nullable\n+`String`.\n+\n+```{.java}\n+class AlmostRecord {\n+    private final int x;\n+    private final int y;\n+    private final String s;                                 \/\/ *\n+\n+    public AlmostRecord(int x, int y, Optional<String> s) {\n+        this.x = x;\n+        this.y = y;\n+        this.s = s.orElse(null);                            \/\/ *\n+    }\n+\n+    public int x() { return x; }\n+    public int y() { return y; }\n+    public Optional<String> s() {\n+        return Optional.ofNullable(s);                      \/\/ *\n+    }\n+\n+    public boolean equals(Object other) { ... }     \/\/ derived from x(), y(), s()\n+    public int hashCode() { ... }                   \/\/    \"\n+    public String toString() { ... }                \/\/    \"\n+}\n+```\n+\n+The main differences between this class and the expansion of its record analogue\n+are the lines marked with a `*`; these are the ones that deal with the disparity\n+between the state description and the actual representation.  It would be nice\n+if the author of this class _only_ had to write the code that was different from\n+what we could derive for a record; not only would this be pleasantly concise,\n+but it would mean that all the code that _is_ there exists to capture the\n+differences between its representation and its API.\n+\n+## Carrier classes\n+\n+A _carrier class_ is a normal class declared with a state description.  As with\n+a record, the state description is a complete, canonical, nominal description of\n+the class's state.  In return, the language derives the same API constraints as\n+it does for records: canonical constructor, canonical deconstruction pattern,\n+and component accessor methods.\n+\n+```{.java}\n+class Point(int x, int y) {                \/\/ class, not record!\n+    \/\/ explicitly declared representation\n+\n+    ...\n+\n+    \/\/ must have a constructor taking (int x, int y)\n+    \/\/ must have accessors for x and y\n+    \/\/ supports a deconstruction pattern yielding (int x, int y)\n+}\n+```\n+\n+Unlike a record, the language makes no assumptions about the object's\n+representation; the class author has to declare that just as with any other\n+class.\n+\n+Saying the state description is \"complete\" means that it carries all the\n+“important” state of the class -- if we were to extract this state and recreate\n+the object, that should yield an “equivalent” instance.  As with records, this\n+can be captured by tying together the behavior of construction, accessors, and\n+equality:\n+\n+```{.java}\n+Point p = ...\n+Point q = new Point(p.x(), p.y());\n+assert p.equals(q);\n+```\n+\n+We can also derive _some_ implementation from the information we have so far; we\n+can derive sensible implementations of the `Object` methods (implemented in terms\n+of component accessor methods) and we can derive the canonical deconstruction\n+pattern (again in terms of the component accessor methods).  And from there, we\n+can derive support for reconstruction (`with` expressions.)  Unfortunately, we\n+cannot (yet) derive the bulk of the state-related implementation: the canonical\n+constructor and component accessor methods.\n+\n+### Component fields and accessor methods\n+\n+One of the most tedious aspects of data-holder classes is the accessor methods;\n+there are often many of them, and they are almost always pure boilerplate.  Even\n+though IDEs can reduce the writing burden by generating these for us, readers\n+still have to slog through a lot of low-information code -- just to learn that\n+they didn't actually need to slog through that code after all.  We can derive\n+the implementation of accessor methods for records because records make the\n+internal commitment that the components are all backed with individual fields\n+whose name and type align with the state description.\n+\n+For a carrier class, we don't know whether _any_ of the components are directly\n+backed by a single field that aligns to the name or type of the component.  But\n+it is a pretty good bet that many carrier class components will do exactly this\n+for at least _some_ of their fields.  If we can tell the language that this\n+correspondence is not merely accidental, the language can do more for us.\n+\n+We do so by allowing suitable fields of a carrier class to be declared as\n+`component` fields.  (As usual at this stage, syntax is provisional, but not\n+currently a topic for discussion.)  A component field must have the same name\n+and type as a component of the current class (though it need not be `private` or\n+`final`, as record fields are.)  This signals that this field _is_ the\n+representation for the corresponding component, and hence we can derive the\n+accessor method for this component as well.\n+\n+```{.java}\n+class Point(int x, int y) {\n+    private \/* mutable *\/ component int x;\n+    private \/* mutable *\/ component int y;\n+\n+    \/\/ must have a canonical constructor, but (so far) must be explicit\n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    \/\/ derived implementations of accessors for x and y\n+    \/\/ derived implementations of equals, hashCode, toString\n+}\n+```\n+\n+This is getting better; the class author had to bring the representation and the\n+mapping from representation to components (in the form of the `component`\n+modifier), and the canonical constructor.\n+\n+### Compact constructors\n+\n+Just as we are able to derive the accessor method implementation if we are\n+given an explicit correspondence between a field and a component, we can do the\n+same for constructors.  For this, we build on the notion of _compact\n+constructors_ that was introduced for records.\n+\n+As with a record, a compact constructor in a carrier class is a shorthand for a\n+canonical constructor, which has the same shape as the state description, but\n+which is freed of the responsibility of actually committing the ending value of\n+the component parameters to the fields.  The main difference is that for a\n+record, _all_ of the components are backed by a component field, whereas for a\n+carrier class, only some of them might be.  But we can generalize compact\n+constructors by freeing the author of the responsibility to initialize the\n+_component_ fields, while leaving them responsible for initializing the rest of\n+the fields.  In the limiting case where all components are backed by component\n+fields, and there is no other logic desired in the constructor, the compact\n+constructor may be elided.\n+\n+For our mutable `Point` class, this means we can elide nearly everything, except\n+the field declarations themselves:\n+\n+```{.java}\n+class Point(int x, int y) {\n+    private \/* mutable *\/ component int x;\n+    private \/* mutable *\/ component int y;\n+\n+    \/\/ derived compact constructor\n+    \/\/ derived accessors for x, y\n+    \/\/ derived implementations of equals, hashCode, toString\n+}\n+```\n+\n+We can think of this class as having an implicit empty compact constructor,\n+which in turn means that the component fields `x` and `y` are initialized from\n+their corresponding constructor parameters.  There are also implicitly derived\n+accessor methods for each component, and implementations of `Object` methods\n+based on the state description.\n+\n+This is great for a class where all the components are backed by fields, but\n+what about our `AlmostRecord` class?  The story here is good as well; we can\n+derive the accessor methods for the components backed by component fields, and\n+we can elide the initialization of the component fields from the compact\n+constructor, meaning that we _only_ have to specify the code for the parts that\n+deviate from the \"record ideal\":\n+\n+```{.java}\n+class AlmostRecord(int x,\n+                   int y,\n+                   Optional<String> s) {\n+\n+    private final component int x;\n+    private final component int y;\n+    private final String s;\n+\n+    public AlmostRecord {\n+        this.s = s.orElse(null);\n+        \/\/ x and y fields implicitly initialized\n+    }\n+\n+    public Optional<String> s() {\n+        return Optional.ofNullable(s);\n+    }\n+\n+    \/\/ derived implementation of x and y accessors\n+    \/\/ derived implementation of equals, hashCode, toString\n+}\n+```\n+\n+Because so many real-world almost-records differ from their record ideal in\n+minor ways, we expect to get a significant concision benefit for most carrier\n+classes, as we did for `AlmostRecord`.  As with records, if we want to\n+explicitly implement the constructor, accessor methods, or `Object` methods, we\n+are still free to do so.\n+\n+### Derived state\n+\n+One of the most frequent complaints about records is the inability to derive\n+state from the components and cache it for fast retrieval.  With carrier\n+classes, this is simple: declare a non-component field for the derived quantity,\n+initialize it in the constructor, and provide an accessor:\n+\n+```{.java}\n+class Point(int x, int y) {\n+    private final component int x;\n+    private final component int y;\n+    private final double norm;\n+\n+    Point {\n+        norm = Math.hypot(x, y);\n+    }\n+\n+    public double norm() { return norm; }\n+\n+    \/\/ derived implementation of x and y accessors\n+    \/\/ derived implementation of equals, hashCode, toString\n+}\n+```\n+\n+### Deconstruction and reconstruction\n+\n+Like records, carrier classes automatically acquire deconstruction patterns that\n+match the canonical constructor, so we can destructure our `Point` class as if\n+it were a record:\n+\n+```{.java}\n+case Point(var x, var y):\n+```\n+\n+Because reconstruction (`with`) derives from a canonical constructor and\n+corresponding deconstruction pattern, when we support reconstruction of records,\n+we will also be able to do so for carrier classes:\n+\n+```{.java}\n+point = point with { x = 3; }\n+```\n+\n+## Carrier interfaces\n+\n+A state description makes sense on interfaces as well.  It makes the statement\n+that the state description is a complete, canonical, nominal description of the\n+interface's state (subclasses are allowed to add additional state), and\n+accordingly, implementations must provide accessor methods for the components.\n+This enables such interfaces to participate in pattern matching:\n+\n+```{.java}\n+interface Pair<T,U>(T first, U second) {\n+    \/\/ implicit abstract accessors for first() and second()\n+}\n+\n+...\n+\n+if (o instanceof Pair(var a, var b)) { ... }\n+```\n+\n+Along with the upcoming feature for pattern assignment in foreach-loop headers,\n+if `Map.Entry` became a carrier interface (which it will), we would be able to\n+iterate a `Map` like:\n+\n+```{.java}\n+for (Map.Entry(var key, var val) : map.entrySet()) { ... }\n+```\n+\n+It is a common pattern in libraries to export an interface that is sealed to a\n+single private implementation.  In this pattern, the interface and\n+implementation can share a common state description:\n+\n+```{.java}\n+public sealed interface Pair<T,U>(T first, U second) { }\n+\n+private record PairImpl<T, U>(T first, U second) implements Pair<T, U> { }\n+```\n+\n+Compared to the old way of doing this, we get enhanced semantics, better type\n+checking, and more concision.\n+\n+### Extension\n+\n+The main obligation of a carrier class author is to ensure that the fundamental\n+claim -- that the state description is a complete, canonical, nominal\n+description of the object's state -- is actually true.  This does not rule out\n+having the representation of a carrier class spread out over a hierarchy, so\n+unlike records, carrier classes are not required to be final or concrete, nor\n+are they restricted in their extension.\n+\n+There are several cases that arise when carrier classes can participate in\n+extension:\n+\n+ - A carrier class extends a non-carrier class;\n+ - A non-carrier class extends a carrier class;\n+ - A carrier class extends another carrier class, where all of the superclass\n+   components are subsumed by the subclass state description;\n+ - A carrier class extends another carrier class, but there are one or more\n+   superclass components that are not subsumed by the subclass state\n+   description.\n+\n+Extending a non-carrier class with a carrier class will usually be motiviated by\n+the desire to \"wrap\" a state description around an existing hierarchy which we\n+cannot or do not want to modify directly, but we wish to gain the benefits of\n+deconstruction and reconstruction.  Such an implementation would have to ensure\n+that the class actually conforms to the state description, and that the\n+canonical constructor and component accessors are implemented.\n+\n+When one carrier class extends another, the more straightforward case is that it\n+simply adds new components to the state description of the superclass.  For\n+example, given our `Point` class:\n+\n+```{.java}\n+class Point(int x, int y) {\n+    component int x;\n+    component int y;\n+\n+    \/\/ everything else for free!\n+}\n+```\n+\n+we can use this as the base class for a 3d point class:\n+\n+```{.java}\n+class Point3d(int x, int y, int z) extends Point {\n+    component int z;\n+\n+    Point3d {\n+        super(x, y);\n+    }\n+}\n+```\n+\n+In this case -- because the superclass components are all part of the subclass\n+state description -- we can actually omit the constructor as well, because we\n+can derive the association between subclass components and superclass\n+components, and thereby derive the needed super-constructor invocation.  So we\n+could actually write:\n+\n+```{.java}\n+class Point3d(int x, int y, int z) extends Point {\n+    component int z;\n+\n+    \/\/ everything else for free!\n+}\n+```\n+\n+One might think that we would need some marking on the `x` and `y` components of\n+`Point3d` to indicate that they map to the corresponding components of `Point`,\n+as we did for associating component fields with their corresponding components.\n+But in this case, we need no such marking, because there is no way that an `int\n+x` component of `Point` and an `int x` component of its subclass could possibly\n+refer to different things -- since they both are tied to the same `int x()`\n+accessor methods.  So we can safely infer which subclass components are managed\n+by superclasses, just by matching up their names and types.\n+\n+In the other carrier-to-carrier extension case, where one or more superclass\n+components are _not_ subsumed by the subclass state description, it is necessary\n+to provide an explicit `super` constructor call in the subclass constructor.\n+\n+A carrier class may be also declared abstract; the main effect of this is that\n+we will not derive `Object` method implementations, instead leaving that for the\n+subclass to do.\n+\n+### Abstract records\n+\n+This framework also gives us an opportunity to relax one of the restrictions on\n+records: that records can't extend anything other than `java.lang.Record`.  We\n+can also allow records to be declared `abstract`, and for records to extend\n+abstract records.\n+\n+Just as with carrier classes that extend other carrier classes, there are two\n+cases: when the component list of the superclass is entirely contained within\n+that of the subclass, and when one or more superclass components are derived\n+from subclass components (or are constant), but are not components of the\n+subclass itself.  And just as with carrier classes, the main difference is\n+whether an explicit `super` call is required in the subclass constructor.\n+\n+When a record extends an abstract record, any components of the subclass that\n+are also components of the superclass do not implicitly get component fields in\n+the subclass (because they are already in the superclass), and they inherit the\n+accessor methods from the superclass.\n+\n+### Records are carriers too\n+\n+With this framework in place, records can now be seen to be \"just\" carrier\n+classes that are implicitly final, extend `java.lang.Record`, that implicitly\n+have private final component fields for each component, and can have no other\n+fields.\n+\n+## Migration compatibility\n+\n+There will surely be some existing classes that would like to become carrier\n+classes.  This is a compatible migration as long as none of the mandated members\n+conflict with existing members of the class, and the class adheres to the\n+requirement that the state description is a complete, canonical, and nominal\n+description of the object state.\n+\n+### Compatible evolution of records and carrier classes\n+\n+To date, libraries have been reluctant to use records in public APIs because\n+of the difficulty of evolving them compatibly.  For a record:\n+\n+```{.java}\n+record R(A a, B b) { }\n+```\n+\n+that wants to evolve by adding new components:\n+\n+```{.java}\n+record R(A a, B b, C c, D d) { }\n+```\n+\n+we have several compatibility challenges to manage.  As long as we are only\n+adding and not removing\/renaming, accessor method invocations will continue to\n+work. And existing constructor invocations can be allowed to continue work by\n+explicitly adding back a constructor that has the old shape:\n+\n+```{.java}\n+record R(A a, B b, C c, D d) {\n+\n+    \/\/ Explicit constructor for old shape required\n+    public R(A a, B b) {\n+        this(a, b, DEFAULT_C, DEFAULT_D);\n+    }\n+\n+}\n+```\n+\n+But, what can we do about existing uses of record _patterns_?  While the\n+translation of record patterns would make adding components binary-compatible,\n+it would not be source-compatible, and there is no way to explicitly add a\n+deconstruction pattern for the old shape as we did with the constructor.\n+\n+We can take advantage of the simplification offered by there being _only_ the\n+canonical deconstruction pattern, and allow uses of deconstruction patterns to\n+supply nested patterns for any _prefix_ of the component list.  So for the\n+evolved record R:\n+\n+```{.java}\n+case R(P1, P2)\n+```\n+\n+would be interpreted as:\n+\n+```{.java}\n+case R(P1, P2, _, _)\n+```\n+\n+where `_` is the match-all pattern.  This means that one can compatibly evolve a\n+record by only adding new components at the end, and adding a suitable\n+constructor for compatibility with existing constructor invocations.\n","filename":"site\/design-notes\/beyond-records.md","additions":688,"deletions":0,"binary":false,"changes":688,"status":"added"}]}