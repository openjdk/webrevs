{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,1 +202,0 @@\n-  const JfrStackTraceRepository& _stack_trace_repo;\n@@ -204,1 +203,0 @@\n-  const JfrStackTrace* resolve(const ObjectSample* sample);\n@@ -206,0 +204,1 @@\n+  const JfrStackTrace* resolve(const ObjectSample* sample) const;\n@@ -207,1 +206,6 @@\n-  StackTraceBlobInstaller(const JfrStackTraceRepository& stack_trace_repo);\n+  StackTraceBlobInstaller() : _cache(JfrOptionSet::old_object_queue_size()) {\n+    prepare_for_resolution();\n+  }\n+  ~StackTraceBlobInstaller() {\n+    JfrStackTraceRepository::clear_leak_profiler();\n+  }\n@@ -215,9 +219,0 @@\n-StackTraceBlobInstaller::StackTraceBlobInstaller(const JfrStackTraceRepository& stack_trace_repo) :\n-  _stack_trace_repo(stack_trace_repo), _cache(JfrOptionSet::old_object_queue_size()) {\n-  prepare_for_resolution();\n-}\n-\n-const JfrStackTrace* StackTraceBlobInstaller::resolve(const ObjectSample* sample) {\n-  return _stack_trace_repo.lookup(sample->stack_trace_hash(), sample->stack_trace_id());\n-}\n-\n@@ -233,0 +228,4 @@\n+inline const JfrStackTrace* StackTraceBlobInstaller::resolve(const ObjectSample* sample) const {\n+  return JfrStackTraceRepository::lookup_for_leak_profiler(sample->stack_trace_hash(), sample->stack_trace_id());\n+}\n+\n@@ -245,1 +244,1 @@\n-  blob = writer.move();\n+  blob = writer.copy();\n@@ -250,1 +249,1 @@\n-static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository& stack_trace_repo) {\n+static void install_stack_traces(const ObjectSampler* sampler) {\n@@ -256,1 +255,1 @@\n-    StackTraceBlobInstaller installer(stack_trace_repo);\n+    StackTraceBlobInstaller installer;\n@@ -261,1 +260,1 @@\n-void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository& stack_trace_repo) {\n+void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler) {\n@@ -270,1 +269,1 @@\n-  install_stack_traces(sampler, stack_trace_repo);\n+  install_stack_traces(sampler);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-class JfrStackTraceRepository;\n@@ -56,1 +55,1 @@\n-  static void on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository& repo);\n+  static void on_rotation(const ObjectSampler* sampler);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -161,4 +161,10 @@\n-static void record_stacktrace(JavaThread* thread) {\n-  assert(thread != NULL, \"invariant\");\n-  if (JfrEventSetting::has_stacktrace(EventOldObjectSample::eventId)) {\n-    JfrStackTraceRepository::record_and_cache(thread);\n+class RecordStackTrace {\n+ private:\n+  JavaThread* _jt;\n+  bool _enabled;\n+ public:\n+  RecordStackTrace(JavaThread* jt) : _jt(jt),\n+    _enabled(JfrEventSetting::has_stacktrace(EventOldObjectSample::eventId)) {\n+    if (_enabled) {\n+      JfrStackTraceRepository::record_for_leak_profiler(jt);\n+    }\n@@ -166,1 +172,6 @@\n-}\n+  ~RecordStackTrace() {\n+    if (_enabled) {\n+      _jt->jfr_thread_local()->clear_cached_stack_trace();\n+    }\n+  }\n+};\n@@ -175,1 +186,1 @@\n-  record_stacktrace(thread);\n+  RecordStackTrace rst(thread);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,0 @@\n-  static traceid load_raw(const Klass* klass, const Method* method);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -440,1 +440,1 @@\n-  _stack_trace_repository.clear();\n+  JfrStackTraceRepository::clear();\n@@ -455,1 +455,1 @@\n-  _stack_trace_repository.clear();\n+  JfrStackTraceRepository::clear();\n@@ -542,1 +542,1 @@\n-    ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);\n+    ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire());\n@@ -563,0 +563,1 @@\n+  JfrStackTraceRepository::clear_leak_profiler();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,6 @@\n-static JfrStackTraceRepository* _instance = NULL;\n+\/*\n+ * There are two separate repository instances.\n+ * One instance is dedicated to stacktraces taken as part of the leak profiler subsystem.\n+ * It is kept separate because at the point of insertion, it is unclear if a trace will be serialized,\n+ * which is a decision postponed and taken during rotation.\n+ *\/\n@@ -35,3 +40,3 @@\n-JfrStackTraceRepository::JfrStackTraceRepository() : _next_id(0), _entries(0) {\n-  memset(_table, 0, sizeof(_table));\n-}\n+static JfrStackTraceRepository* _instance = NULL;\n+static JfrStackTraceRepository* _leak_profiler_instance = NULL;\n+static traceid _next_id = 0;\n@@ -40,0 +45,1 @@\n+  assert(_instance != NULL, \"invariant\");\n@@ -43,0 +49,9 @@\n+static JfrStackTraceRepository& leak_profiler_instance() {\n+  assert(_leak_profiler_instance != NULL, \"invariant\");\n+  return *_leak_profiler_instance;\n+}\n+\n+JfrStackTraceRepository::JfrStackTraceRepository() : _last_entries(0), _entries(0) {\n+  memset(_table, 0, sizeof(_table));\n+}\n+\n@@ -45,0 +60,5 @@\n+  assert(_leak_profiler_instance == NULL, \"invariant\");\n+  _leak_profiler_instance = new JfrStackTraceRepository();\n+  if (_leak_profiler_instance == NULL) {\n+    return NULL;\n+  }\n@@ -72,0 +92,2 @@\n+  delete _leak_profiler_instance;\n+  _leak_profiler_instance = NULL;\n@@ -74,2 +96,0 @@\n-static traceid last_id = 0;\n-\n@@ -77,1 +97,1 @@\n-  return last_id != _next_id;\n+  return _last_entries != _entries;\n@@ -105,1 +125,1 @@\n-  last_id = _next_id;\n+  _last_entries = _entries;\n@@ -109,1 +129,1 @@\n-size_t JfrStackTraceRepository::clear() {\n+size_t JfrStackTraceRepository::clear(JfrStackTraceRepository& repo) {\n@@ -111,1 +131,1 @@\n-  if (_entries == 0) {\n+  if (repo._entries == 0) {\n@@ -115,1 +135,1 @@\n-    JfrStackTrace* stacktrace = _table[i];\n+    JfrStackTrace* stacktrace = repo._table[i];\n@@ -122,3 +142,4 @@\n-  memset(_table, 0, sizeof(_table));\n-  const size_t processed = _entries;\n-  _entries = 0;\n+  memset(repo._table, 0, sizeof(repo._table));\n+  const size_t processed = repo._entries;\n+  repo._entries = 0;\n+  repo._last_entries = 0;\n@@ -150,1 +171,1 @@\n-  return stacktrace.record_safe(thread, skip) ? add(stacktrace) : 0;\n+  return stacktrace.record_safe(thread, skip) ? add(instance(), stacktrace) : 0;\n@@ -152,3 +173,2 @@\n-\n-traceid JfrStackTraceRepository::add(const JfrStackTrace& stacktrace) {\n-  traceid tid = instance().add_trace(stacktrace);\n+traceid JfrStackTraceRepository::add(JfrStackTraceRepository& repo, const JfrStackTrace& stacktrace) {\n+  traceid tid = repo.add_trace(stacktrace);\n@@ -157,1 +177,1 @@\n-    tid = instance().add_trace(stacktrace);\n+    tid = repo.add_trace(stacktrace);\n@@ -163,1 +183,5 @@\n-void JfrStackTraceRepository::record_and_cache(JavaThread* thread, int skip \/* 0 *\/) {\n+traceid JfrStackTraceRepository::add(const JfrStackTrace& stacktrace) {\n+  return add(instance(), stacktrace);\n+}\n+\n+void JfrStackTraceRepository::record_for_leak_profiler(JavaThread* thread, int skip \/* 0 *\/) {\n@@ -172,1 +196,1 @@\n-    tl->set_cached_stack_trace_id(instance().add(stacktrace), hash);\n+    tl->set_cached_stack_trace_id(add(leak_profiler_instance(), stacktrace), hash);\n@@ -199,1 +223,1 @@\n-const JfrStackTrace* JfrStackTraceRepository::lookup(unsigned int hash, traceid id) const {\n+const JfrStackTrace* JfrStackTraceRepository::lookup_for_leak_profiler(unsigned int hash, traceid id) {\n@@ -201,1 +225,1 @@\n-  const JfrStackTrace* trace = _table[index];\n+  const JfrStackTrace* trace = leak_profiler_instance()._table[index];\n@@ -210,0 +234,9 @@\n+\n+void JfrStackTraceRepository::clear_leak_profiler() {\n+  clear(leak_profiler_instance());\n+}\n+\n+size_t JfrStackTraceRepository::clear() {\n+  clear_leak_profiler();\n+  return clear(instance());\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":57,"deletions":24,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+  friend class RecordStackTrace;\n@@ -48,1 +49,1 @@\n-  traceid _next_id;\n+  u4 _last_entries;\n@@ -58,0 +59,2 @@\n+  static size_t clear();\n+  static size_t clear(JfrStackTraceRepository& repo);\n@@ -59,1 +62,0 @@\n-  size_t clear();\n@@ -61,1 +63,3 @@\n-  const JfrStackTrace* lookup(unsigned int hash, traceid id) const;\n+  static const JfrStackTrace* lookup_for_leak_profiler(unsigned int hash, traceid id);\n+  static void record_for_leak_profiler(JavaThread* thread, int skip = 0);\n+  static void clear_leak_profiler();\n@@ -64,0 +68,1 @@\n+  static traceid add(JfrStackTraceRepository& repo, const JfrStackTrace& stacktrace);\n@@ -69,1 +74,0 @@\n-  static void record_and_cache(JavaThread* thread, int skip = 0);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"jfr\/support\/jfrThreadLocal.hpp\"\n@@ -32,1 +31,1 @@\n-JfrAllocationTracer::JfrAllocationTracer(const Klass* klass, HeapWord* obj, size_t alloc_size, bool outside_tlab, Thread* thread) : _tl(NULL) {\n+JfrAllocationTracer::JfrAllocationTracer(const Klass* klass, HeapWord* obj, size_t alloc_size, bool outside_tlab, Thread* thread) {\n@@ -34,1 +33,0 @@\n-    _tl = thread->jfr_thread_local();\n@@ -37,1 +35,0 @@\n-  \/\/ Let this happen after LeakProfiler::sample, to possibly reuse a cached stacktrace.\n@@ -40,6 +37,0 @@\n-\n-JfrAllocationTracer::~JfrAllocationTracer() {\n-  if (_tl != NULL) {\n-    _tl->clear_cached_stack_trace();\n-  }\n-}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAllocationTracer.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-class JfrThreadLocal;\n@@ -35,2 +34,0 @@\n- private:\n-  JfrThreadLocal* _tl;\n@@ -39,1 +36,0 @@\n-  ~JfrAllocationTracer();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAllocationTracer.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}