{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,3 @@\n+\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.jpackage.internal.model.ConfigException;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/PackageProperty.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -41,1 +42,1 @@\n-        DottedVersion ver = new DottedVersion(value);\n+        DottedVersion ver = DottedVersion.greedy(value);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/CFBundleVersion.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n@@ -52,0 +55,1 @@\n+import jdk.jpackage.internal.util.PathGroup;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,3 @@\n+\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,4 +37,0 @@\n-error.no-app-signing-key=No Mac App Store App Signing Key\n-error.no-app-signing-key.advice=Install your app signing keys into your Mac Keychain using XCode.\n-error.no-pkg-signing-key=No Mac App Store Installer Signing Key\n-error.no-pkg-signing-key.advice=Install your app signing keys into your Mac Keychain using XCode.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageBundler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-\n+import jdk.jpackage.internal.util.PathGroup;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Bundler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FileAssociation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import java.util.ArrayList;\n+import java.text.MessageFormat;\n@@ -29,1 +29,0 @@\n-import java.util.ListResourceBundle;\n@@ -31,2 +30,0 @@\n-import jdk.internal.util.OperatingSystem;\n-\n@@ -34,2 +31,2 @@\n-import static java.util.stream.Collectors.toMap;\n-import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.util.MultiResourceBundle;\n@@ -43,18 +40,6 @@\n-    private static class MultiResourceBundle extends ListResourceBundle {\n-\n-        MultiResourceBundle(ResourceBundle... bundles) {\n-            contents = Stream.of(bundles).map(bundle -> {\n-                return bundle.keySet().stream().map(key -> {\n-                    return Map.entry(key, bundle.getObject(key));\n-                });\n-            }).flatMap(x -> x).collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (o, n) -> {\n-                \/\/ Override old value with the new one\n-                return n;\n-            })).entrySet().stream().map(e -> {\n-                return new Object[]{e.getKey(), e.getValue()};\n-            }).toArray(Object[][]::new);\n-        }\n-\n-        @Override\n-        protected Object[][] getContents() {\n-            return contents;\n+    static String format(String key, Object ... args) {\n+        var str = getString(key);\n+        if (args.length != 0) {\n+            return MessageFormat.format(str, args);\n+        } else {\n+            return str;\n@@ -62,2 +47,0 @@\n-\n-        private final Object[][] contents;\n@@ -66,1 +49,1 @@\n-    private static final MultiResourceBundle BUNDLE;\n+    private static final ResourceBundle BUNDLE;\n@@ -69,17 +52,9 @@\n-        List<String> bundleNames = new ArrayList<>();\n-\n-        bundleNames.add(\"jdk.jpackage.internal.resources.MainResources\");\n-\n-        if (OperatingSystem.isLinux()) {\n-            bundleNames.add(\"jdk.jpackage.internal.resources.LinuxResources\");\n-        } else if (OperatingSystem.isWindows()) {\n-            bundleNames.add(\"jdk.jpackage.internal.resources.WinResources\");\n-            bundleNames.add(\"jdk.jpackage.internal.resources.WinResourcesNoL10N\");\n-        } else if (OperatingSystem.isMacOS()) {\n-            bundleNames.add(\"jdk.jpackage.internal.resources.MacResources\");\n-        } else {\n-            throw new IllegalStateException(\"Unknown platform\");\n-        }\n-\n-        BUNDLE = new MultiResourceBundle(bundleNames.stream().map(ResourceBundle::getBundle)\n-                .toArray(ResourceBundle[]::new));\n+        var prefix = \"jdk.jpackage.internal.resources.\";\n+        BUNDLE = MultiResourceBundle.create(\n+                prefix + \"MainResources\",\n+                Map.of(\n+                        OperatingSystem.LINUX, List.of(prefix + \"LinuxResources\"),\n+                        OperatingSystem.MACOS, List.of(prefix + \"MacResources\"),\n+                        OperatingSystem.WINDOWS, List.of(prefix + \"WinResources\", prefix + \"WinResourcesNoL10N\")\n+                )\n+        );\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/I18N.java","additions":20,"deletions":45,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkBundlerHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\n+import jdk.jpackage.internal.model.ConfigException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,259 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.BiFunction;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.util.FileUtils;\n-\n-\n-\/**\n- * Group of paths.\n- * Each path in the group is assigned a unique id.\n- *\/\n-final class PathGroup {\n-    PathGroup(Map<Object, Path> paths) {\n-        entries = new HashMap<>(paths);\n-    }\n-\n-    Path getPath(Object id) {\n-        if (id == null) {\n-            throw new NullPointerException();\n-        }\n-        return entries.get(id);\n-    }\n-\n-    void setPath(Object id, Path path) {\n-        if (path != null) {\n-            entries.put(id, path);\n-        } else {\n-            entries.remove(id);\n-        }\n-    }\n-\n-    \/**\n-     * All configured entries.\n-     *\/\n-    List<Path> paths() {\n-        return entries.values().stream().toList();\n-    }\n-\n-    \/**\n-     * Root entries.\n-     *\/\n-    List<Path> roots() {\n-        \/\/ Sort by the number of path components in ascending order.\n-        List<Map.Entry<Path, Path>> sorted = normalizedPaths().stream().sorted(\n-                (a, b) -> a.getKey().getNameCount() - b.getKey().getNameCount()).toList();\n-\n-        \/\/ Returns `true` if `a` is a parent of `b`\n-        BiFunction<Map.Entry<Path, Path>, Map.Entry<Path, Path>, Boolean> isParentOrSelf = (a, b) -> {\n-            return a == b || b.getKey().startsWith(a.getKey());\n-        };\n-\n-        return sorted.stream().filter(\n-                v -> v == sorted.stream().sequential().filter(\n-                        v2 -> isParentOrSelf.apply(v2, v)).findFirst().get()).map(\n-                        v -> v.getValue()).toList();\n-    }\n-\n-    long sizeInBytes() throws IOException {\n-        long reply = 0;\n-        for (Path dir : roots().stream().filter(f -> Files.isDirectory(f)).collect(\n-                Collectors.toList())) {\n-            try (Stream<Path> stream = Files.walk(dir)) {\n-                reply += stream.filter(p -> Files.isRegularFile(p)).mapToLong(\n-                        f -> f.toFile().length()).sum();\n-            }\n-        }\n-        return reply;\n-    }\n-\n-    PathGroup resolveAt(Path root) {\n-        return new PathGroup(entries.entrySet().stream().collect(\n-                Collectors.toMap(e -> e.getKey(),\n-                        e -> root.resolve(e.getValue()))));\n-    }\n-\n-    void copy(PathGroup dst) throws IOException {\n-        copy(this, dst, null, false);\n-    }\n-\n-    void move(PathGroup dst) throws IOException {\n-        copy(this, dst, null, true);\n-    }\n-\n-    void transform(PathGroup dst, TransformHandler handler) throws IOException {\n-        copy(this, dst, handler, false);\n-    }\n-\n-    static interface Facade<T> {\n-        PathGroup pathGroup();\n-\n-        default Collection<Path> paths() {\n-            return pathGroup().paths();\n-        }\n-\n-        default List<Path> roots() {\n-            return pathGroup().roots();\n-        }\n-\n-        default long sizeInBytes() throws IOException {\n-            return pathGroup().sizeInBytes();\n-        }\n-\n-        T resolveAt(Path root);\n-\n-        default void copy(Facade<T> dst) throws IOException {\n-            pathGroup().copy(dst.pathGroup());\n-        }\n-\n-        default void move(Facade<T> dst) throws IOException {\n-            pathGroup().move(dst.pathGroup());\n-        }\n-\n-        default void transform(Facade<T> dst, TransformHandler handler) throws\n-                IOException {\n-            pathGroup().transform(dst.pathGroup(), handler);\n-        }\n-    }\n-\n-    static interface TransformHandler {\n-        public void copyFile(Path src, Path dst) throws IOException;\n-        public void createDirectory(Path dir) throws IOException;\n-    }\n-\n-    private static void copy(PathGroup src, PathGroup dst,\n-            TransformHandler handler, boolean move) throws IOException {\n-        List<Map.Entry<Path, Path>> copyItems = new ArrayList<>();\n-        List<Path> excludeItems = new ArrayList<>();\n-\n-        for (var id: src.entries.keySet()) {\n-            Path srcPath = src.entries.get(id);\n-            if (dst.entries.containsKey(id)) {\n-                copyItems.add(Map.entry(srcPath, dst.entries.get(id)));\n-            } else {\n-                excludeItems.add(srcPath);\n-            }\n-        }\n-\n-        copy(move, copyItems, excludeItems, handler);\n-    }\n-\n-    private static void copy(boolean move, List<Map.Entry<Path, Path>> entries,\n-            List<Path> excludePaths, TransformHandler handler) throws\n-            IOException {\n-\n-        if (handler == null) {\n-            handler = new TransformHandler() {\n-                @Override\n-                public void copyFile(Path src, Path dst) throws IOException {\n-                    Files.createDirectories(IOUtils.getParent(dst));\n-                    if (move) {\n-                        Files.move(src, dst);\n-                    } else {\n-                        Files.copy(src, dst);\n-                    }\n-                }\n-\n-                @Override\n-                public void createDirectory(Path dir) throws IOException {\n-                    Files.createDirectories(dir);\n-                }\n-            };\n-        }\n-\n-        \/\/ destination -> source file mapping\n-        Map<Path, Path> actions = new HashMap<>();\n-        for (var action: entries) {\n-            Path src = action.getKey();\n-            Path dst = action.getValue();\n-            if (Files.isDirectory(src)) {\n-               try (Stream<Path> stream = Files.walk(src)) {\n-                   stream.sequential().forEach(path -> actions.put(dst.resolve(\n-                            src.relativize(path)).normalize(), path));\n-               }\n-            } else {\n-                actions.put(dst.normalize(), src);\n-            }\n-        }\n-\n-        for (var action : actions.entrySet()) {\n-            Path dst = action.getKey();\n-            Path src = action.getValue();\n-\n-            if (excludePaths.stream().anyMatch(src::startsWith)) {\n-                continue;\n-            }\n-\n-            if (src.equals(dst) || !src.toFile().exists()) {\n-                continue;\n-            }\n-\n-            if (Files.isDirectory(src)) {\n-                handler.createDirectory(dst);\n-            } else {\n-                handler.copyFile(src, dst);\n-            }\n-        }\n-\n-        if (move) {\n-            \/\/ Delete source dirs.\n-            for (var entry: entries) {\n-                Path srcFile = entry.getKey();\n-                if (Files.isDirectory(srcFile)) {\n-                    FileUtils.deleteRecursive(srcFile);\n-                }\n-            }\n-        }\n-    }\n-\n-    private static Map.Entry<Path, Path> normalizedPath(Path v) {\n-        final Path normalized;\n-        if (!v.isAbsolute()) {\n-            normalized = Path.of(\".\/\").resolve(v.normalize());\n-        } else {\n-            normalized = v.normalize();\n-        }\n-\n-        return Map.entry(normalized, v);\n-    }\n-\n-    private List<Map.Entry<Path, Path>> normalizedPaths() {\n-        return entries.values().stream().map(PathGroup::normalizedPath).collect(\n-                Collectors.toList());\n-    }\n-\n-    private final Map<Object, Path> entries;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PathGroup.java","additions":0,"deletions":259,"binary":false,"changes":259,"status":"deleted"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.jpackage.internal.model.ConfigException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.jpackage.internal;\n+package jdk.jpackage.internal.model;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ConfigException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ConfigException.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package jdk.jpackage.internal;\n+package jdk.jpackage.internal.model;\n@@ -37,5 +37,1 @@\n-final class DottedVersion {\n-\n-    DottedVersion(String version) {\n-        this(version, true);\n-    }\n+public final class DottedVersion {\n@@ -159,2 +155,2 @@\n-    static DottedVersion greedy(String version) {\n-        return new DottedVersion(version);\n+    public static DottedVersion greedy(String version) {\n+        return new DottedVersion(version, true);\n@@ -163,1 +159,1 @@\n-    static DottedVersion lazy(String version) {\n+    public static DottedVersion lazy(String version) {\n@@ -167,1 +163,1 @@\n-    static int compareComponents(DottedVersion a, DottedVersion b) {\n+    public static int compareComponents(DottedVersion a, DottedVersion b) {\n@@ -227,1 +223,1 @@\n-    String toComponentsString() {\n+    public String toComponentsString() {\n@@ -231,1 +227,1 @@\n-    BigInteger[] getComponents() {\n+    public BigInteger[] getComponents() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/DottedVersion.java","additions":8,"deletions":12,"binary":false,"changes":20,"previous_filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DottedVersion.java","status":"renamed"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.text.MessageFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.util.MultiResourceBundle;\n+\n+final class I18N {\n+\n+    static String getString(String key) {\n+        return BUNDLE.getString(key);\n+    }\n+\n+    static String format(String key, Object ... args) {\n+        var str = getString(key);\n+        if (args.length != 0) {\n+            return MessageFormat.format(str, args);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    private static final ResourceBundle BUNDLE;\n+\n+    static {\n+        var prefix = \"jdk.jpackage.internal.resources.\";\n+        BUNDLE = MultiResourceBundle.create(\n+                prefix + \"MainResources\",\n+                Map.of(\n+                        OperatingSystem.LINUX, List.of(prefix + \"LinuxResources\"),\n+                        OperatingSystem.MACOS, List.of(prefix + \"MacResources\"),\n+                        OperatingSystem.WINDOWS, List.of(prefix + \"WinResources\")\n+                )\n+        );\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/I18N.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.jpackage.internal;\n+package jdk.jpackage.internal.model;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackagerException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagerException.java","status":"renamed"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListResourceBundle;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.ResourceBundle;\n+import static java.util.stream.Collectors.toMap;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+\n+public final class MultiResourceBundle extends ListResourceBundle {\n+\n+    public static ResourceBundle create(String sharedResourceBundleName,\n+            Map<OperatingSystem, List<String>> platformResourceBundleNames) {\n+        List<String> bundleNames = new ArrayList<>();\n+        Optional.ofNullable(sharedResourceBundleName).ifPresent(bundleNames::add);\n+        Optional.ofNullable(platformResourceBundleNames.get(OperatingSystem.current())).ifPresent(bundleNames::addAll);\n+        if (bundleNames.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty resource bundle names list\");\n+        } else {\n+            var resourceBundles = bundleNames.stream().map(ResourceBundle::getBundle).toArray(ResourceBundle[]::new);\n+            if (resourceBundles.length == 1) {\n+                return resourceBundles[0];\n+            } else {\n+                return new MultiResourceBundle(resourceBundles);\n+            }\n+        }\n+    }\n+\n+    private MultiResourceBundle(ResourceBundle... bundles) {\n+        contents = Stream.of(bundles).map(bundle -> {\n+            return bundle.keySet().stream().map(key -> {\n+                return Map.entry(key, bundle.getObject(key));\n+            });\n+        }).flatMap(x -> x).collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (o, n) -> {\n+            \/\/ Override old value with the new one\n+            return n;\n+        })).entrySet().stream().map(e -> {\n+            return new Object[]{e.getKey(), e.getValue()};\n+        }).toArray(Object[][]::new);\n+    }\n+\n+    @Override\n+    protected Object[][] getContents() {\n+        return contents;\n+    }\n+\n+    private final Object[][] contents;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/MultiResourceBundle.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathFactory;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.w3c.dom.Node;\n+import org.xml.sax.SAXException;\n+\n+public final class PListReader {\n+\n+    public String queryValue(String keyName) {\n+        final var node = getNode(keyName);\n+        switch (node.getNodeName()) {\n+            case \"string\" -> {\n+                return node.getTextContent();\n+            }\n+            default -> {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+    }\n+\n+    public boolean queryBoolValue(String keyName) {\n+        final var node = getNode(keyName);\n+        switch (node.getNodeName()) {\n+            case \"true\" -> {\n+                return true;\n+            }\n+            case \"false\" -> {\n+                return false;\n+            }\n+            default -> {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+    }\n+\n+    public List<String> queryArrayValue(String keyName) {\n+        final var node = getNode(keyName);\n+        switch (node.getNodeName()) {\n+            case \"array\" -> {\n+                return XmlUtils.toStream(node.getChildNodes()).filter(n -> {\n+                    return n.getNodeName().equals(\"string\");\n+                }).map(Node::getTextContent).toList();\n+            }\n+            default -> {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+    }\n+\n+    public PListReader(Node doc) {\n+        this.root = Objects.requireNonNull(doc);\n+    }\n+\n+    public PListReader(byte[] xmlData) throws ParserConfigurationException, SAXException, IOException {\n+        this(XmlUtils.initDocumentBuilder().parse(new ByteArrayInputStream(xmlData)));\n+    }\n+\n+    private Node getNode(String keyName) {\n+        final var xPath = XPathFactory.newInstance().newXPath();\n+        final var query = String.format(\"\/\/*[preceding-sibling::key = \\\"%s\\\"][1]\", keyName);\n+        return Optional.ofNullable(ThrowingSupplier.toSupplier(() -> {\n+            return (Node) xPath.evaluate(query, root, XPathConstants.NODE);\n+        }).get()).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    private final Node root;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListReader.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+\/**\n+ * Group of paths.\n+ * Each path in the group is assigned a unique id.\n+ *\/\n+public final class PathGroup {\n+    public PathGroup(Map<Object, Path> paths) {\n+        entries = new HashMap<>(paths);\n+    }\n+\n+    public Path getPath(Object id) {\n+        if (id == null) {\n+            throw new NullPointerException();\n+        }\n+        return entries.get(id);\n+    }\n+\n+    public void setPath(Object id, Path path) {\n+        if (path != null) {\n+            entries.put(id, path);\n+        } else {\n+            entries.remove(id);\n+        }\n+    }\n+\n+    \/**\n+     * All configured entries.\n+     *\/\n+    public List<Path> paths() {\n+        return entries.values().stream().toList();\n+    }\n+\n+    \/**\n+     * Root entries.\n+     *\/\n+    public List<Path> roots() {\n+        \/\/ Sort by the number of path components in ascending order.\n+        List<Map.Entry<Path, Path>> sorted = normalizedPaths().stream().sorted(\n+                (a, b) -> a.getKey().getNameCount() - b.getKey().getNameCount()).toList();\n+\n+        \/\/ Returns `true` if `a` is a parent of `b`\n+        BiFunction<Map.Entry<Path, Path>, Map.Entry<Path, Path>, Boolean> isParentOrSelf = (a, b) -> {\n+            return a == b || b.getKey().startsWith(a.getKey());\n+        };\n+\n+        return sorted.stream().filter(\n+                v -> v == sorted.stream().sequential().filter(\n+                        v2 -> isParentOrSelf.apply(v2, v)).findFirst().get()).map(\n+                        v -> v.getValue()).toList();\n+    }\n+\n+    public long sizeInBytes() throws IOException {\n+        long reply = 0;\n+        for (Path dir : roots().stream().filter(f -> Files.isDirectory(f)).collect(\n+                Collectors.toList())) {\n+            try (Stream<Path> stream = Files.walk(dir)) {\n+                reply += stream.filter(p -> Files.isRegularFile(p)).mapToLong(\n+                        f -> f.toFile().length()).sum();\n+            }\n+        }\n+        return reply;\n+    }\n+\n+    public PathGroup resolveAt(Path root) {\n+        return new PathGroup(entries.entrySet().stream().collect(\n+                Collectors.toMap(e -> e.getKey(),\n+                        e -> root.resolve(e.getValue()))));\n+    }\n+\n+    public void copy(PathGroup dst) throws IOException {\n+        copy(this, dst, null, false);\n+    }\n+\n+    public void move(PathGroup dst) throws IOException {\n+        copy(this, dst, null, true);\n+    }\n+\n+    public void transform(PathGroup dst, TransformHandler handler) throws IOException {\n+        copy(this, dst, handler, false);\n+    }\n+\n+    public static interface Facade<T> {\n+        PathGroup pathGroup();\n+\n+        default Collection<Path> paths() {\n+            return pathGroup().paths();\n+        }\n+\n+        default List<Path> roots() {\n+            return pathGroup().roots();\n+        }\n+\n+        default long sizeInBytes() throws IOException {\n+            return pathGroup().sizeInBytes();\n+        }\n+\n+        T resolveAt(Path root);\n+\n+        default void copy(Facade<T> dst) throws IOException {\n+            pathGroup().copy(dst.pathGroup());\n+        }\n+\n+        default void move(Facade<T> dst) throws IOException {\n+            pathGroup().move(dst.pathGroup());\n+        }\n+\n+        default void transform(Facade<T> dst, TransformHandler handler) throws\n+                IOException {\n+            pathGroup().transform(dst.pathGroup(), handler);\n+        }\n+    }\n+\n+    public static interface TransformHandler {\n+        void copyFile(Path src, Path dst) throws IOException;\n+        void createDirectory(Path dir) throws IOException;\n+    }\n+\n+    private static void copy(PathGroup src, PathGroup dst,\n+            TransformHandler handler, boolean move) throws IOException {\n+        List<Map.Entry<Path, Path>> copyItems = new ArrayList<>();\n+        List<Path> excludeItems = new ArrayList<>();\n+\n+        for (var id: src.entries.keySet()) {\n+            Path srcPath = src.entries.get(id);\n+            if (dst.entries.containsKey(id)) {\n+                copyItems.add(Map.entry(srcPath, dst.entries.get(id)));\n+            } else {\n+                excludeItems.add(srcPath);\n+            }\n+        }\n+\n+        copy(move, copyItems, excludeItems, handler);\n+    }\n+\n+    private static void copy(boolean move, List<Map.Entry<Path, Path>> entries,\n+            List<Path> excludePaths, TransformHandler handler) throws\n+            IOException {\n+\n+        if (handler == null) {\n+            handler = new TransformHandler() {\n+                @Override\n+                public void copyFile(Path src, Path dst) throws IOException {\n+                    Files.createDirectories(dst.getParent());\n+                    if (move) {\n+                        Files.move(src, dst);\n+                    } else {\n+                        Files.copy(src, dst);\n+                    }\n+                }\n+\n+                @Override\n+                public void createDirectory(Path dir) throws IOException {\n+                    Files.createDirectories(dir);\n+                }\n+            };\n+        }\n+\n+        \/\/ destination -> source file mapping\n+        Map<Path, Path> actions = new HashMap<>();\n+        for (var action: entries) {\n+            Path src = action.getKey();\n+            Path dst = action.getValue();\n+            if (Files.isDirectory(src)) {\n+               try (Stream<Path> stream = Files.walk(src)) {\n+                   stream.sequential().forEach(path -> actions.put(dst.resolve(\n+                            src.relativize(path)).normalize(), path));\n+               }\n+            } else {\n+                actions.put(dst.normalize(), src);\n+            }\n+        }\n+\n+        for (var action : actions.entrySet()) {\n+            Path dst = action.getKey();\n+            Path src = action.getValue();\n+\n+            if (excludePaths.stream().anyMatch(src::startsWith)) {\n+                continue;\n+            }\n+\n+            if (src.equals(dst) || !src.toFile().exists()) {\n+                continue;\n+            }\n+\n+            if (Files.isDirectory(src)) {\n+                handler.createDirectory(dst);\n+            } else {\n+                handler.copyFile(src, dst);\n+            }\n+        }\n+\n+        if (move) {\n+            \/\/ Delete source dirs.\n+            for (var entry: entries) {\n+                Path srcFile = entry.getKey();\n+                if (Files.isDirectory(srcFile)) {\n+                    FileUtils.deleteRecursive(srcFile);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Map.Entry<Path, Path> normalizedPath(Path v) {\n+        final Path normalized;\n+        if (!v.isAbsolute()) {\n+            normalized = Path.of(\".\/\").resolve(v.normalize());\n+        } else {\n+            normalized = v.normalize();\n+        }\n+\n+        return Map.entry(normalized, v);\n+    }\n+\n+    private List<Map.Entry<Path, Path>> normalizedPaths() {\n+        return entries.values().stream().map(PathGroup::normalizedPath).collect(\n+                Collectors.toList());\n+    }\n+\n+    private final Map<Object, Path> entries;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n@@ -44,0 +47,6 @@\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n@@ -48,0 +57,9 @@\n+    @FunctionalInterface\n+    public interface XmlConsumerNoArg {\n+        void accept() throws IOException, XMLStreamException;\n+    }\n+\n+    public static XmlConsumer toXmlConsumer(XmlConsumerNoArg xmlConsumer) {\n+        return xml -> xmlConsumer.accept();\n+    }\n+\n@@ -104,0 +122,16 @@\n+\n+    public static Stream<Node> queryNodes(Node xml, XPath xPath, String xpathExpr) throws XPathExpressionException {\n+        return toStream((NodeList) xPath.evaluate(xpathExpr, xml, XPathConstants.NODESET));\n+    }\n+\n+    public static Stream<Node> toStream(NodeList nodes) {\n+        return Optional.ofNullable(nodes).map(v -> {\n+            return IntStream.range(0, v.getLength()).mapToObj(v::item);\n+        }).orElseGet(Stream::of);\n+    }\n+\n+    public static Stream<Node> toStream(NamedNodeMap nodes) {\n+        return Optional.ofNullable(nodes).map(v -> {\n+            return IntStream.range(0, v.getLength()).mapToObj(v::item);\n+        }).orElseGet(Stream::of);\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/XmlUtils.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import jdk.jpackage.internal.model.DottedVersion;\n+\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.MsiVersion;\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,2 @@\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.util.PathGroup;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.jpackage.internal.model.DottedVersion;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixFragmentBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.DottedVersion;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixToolset.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package jdk.jpackage.internal;\n+package jdk.jpackage.internal.model;\n@@ -31,1 +31,1 @@\n-final class MsiVersion {\n+public final class MsiVersion {\n@@ -42,2 +42,2 @@\n-    static DottedVersion of(String value) {\n-        DottedVersion ver = new DottedVersion(value);\n+    public static DottedVersion of(String value) {\n+        DottedVersion ver = DottedVersion.greedy(value);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/MsiVersion.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/MsiVersion.java","status":"renamed"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.ArrayList;\n@@ -42,4 +41,0 @@\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.xpath.XPath;\n@@ -49,0 +44,1 @@\n+import jdk.jpackage.internal.util.PListReader;\n@@ -50,0 +46,1 @@\n+import jdk.jpackage.internal.util.XmlUtils;\n@@ -53,2 +50,0 @@\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n@@ -132,1 +127,1 @@\n-    public static PListWrapper readPListFromAppImage(Path appImage) {\n+    public static PListReader readPListFromAppImage(Path appImage) {\n@@ -136,1 +131,1 @@\n-    public static PListWrapper readPList(Path path) {\n+    public static PListReader readPList(Path path) {\n@@ -142,1 +137,1 @@\n-    public static PListWrapper readPList(List<String> lines) {\n+    public static PListReader readPList(List<String> lines) {\n@@ -146,2 +141,2 @@\n-    public static PListWrapper readPList(Stream<String> lines) {\n-        return ThrowingSupplier.toSupplier(() -> new PListWrapper(lines\n+    public static PListReader readPList(Stream<String> lines) {\n+        return ThrowingSupplier.toSupplier(() -> new PListReader(lines\n@@ -150,1 +145,1 @@\n-                .collect(Collectors.joining()))).get();\n+                .collect(Collectors.joining()).getBytes(StandardCharsets.UTF_8))).get();\n@@ -264,1 +259,1 @@\n-                var doc = createDocumentBuilder().parse(\n+                var doc = XmlUtils.initDocumentBuilder().parse(\n@@ -373,54 +368,0 @@\n-    public static final class PListWrapper {\n-        public String queryValue(String keyName) {\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            \/\/ Query for the value of <string> element preceding <key> element\n-            \/\/ with value equal to `keyName`\n-            String query = String.format(\n-                    \"\/\/string[preceding-sibling::key = \\\"%s\\\"][1]\", keyName);\n-            return ThrowingSupplier.toSupplier(() -> (String) xPath.evaluate(\n-                    query, doc, XPathConstants.STRING)).get();\n-        }\n-\n-        public Boolean queryBoolValue(String keyName) {\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            \/\/ Query boolean element preceding <key> element\n-            \/\/ with value equal to `keyName`\n-            String query = String.format(\n-                    \"name(\/\/*[preceding-sibling::key = \\\"%s\\\"])\", keyName);\n-            String value = ThrowingSupplier.toSupplier(() -> (String) xPath.evaluate(\n-                    query, doc, XPathConstants.STRING)).get();\n-            return Boolean.valueOf(value);\n-        }\n-\n-        public List<String> queryArrayValue(String keyName) {\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            \/\/ Query string array preceding <key> element with value equal to `keyName`\n-            String query = String.format(\n-                    \"\/\/array[preceding-sibling::key = \\\"%s\\\"]\", keyName);\n-            NodeList list = ThrowingSupplier.toSupplier(() -> (NodeList) xPath.evaluate(\n-                    query, doc, XPathConstants.NODESET)).get();\n-            if (list.getLength() != 1) {\n-                throw new RuntimeException(\n-                        String.format(\"Unable to find <array> element for key = \\\"%s\\\"]\",\n-                                keyName));\n-            }\n-\n-            NodeList childList = list.item(0).getChildNodes();\n-            List<String> values = new ArrayList<>(childList.getLength());\n-            for (int i = 0; i < childList.getLength(); i++) {\n-                if (childList.item(i).getNodeName().equals(\"string\")) {\n-                    values.add(childList.item(i).getTextContent());\n-                }\n-            }\n-            return values;\n-        }\n-\n-        private PListWrapper(String xml) throws ParserConfigurationException,\n-                SAXException, IOException {\n-            doc = createDocumentBuilder().parse(new ByteArrayInputStream(\n-                    xml.getBytes(StandardCharsets.UTF_8)));\n-        }\n-\n-        private final org.w3c.dom.Document doc;\n-    }\n-\n@@ -431,9 +372,0 @@\n-    private static DocumentBuilder createDocumentBuilder() throws\n-                ParserConfigurationException {\n-        DocumentBuilderFactory dbf = DocumentBuilderFactory.newDefaultInstance();\n-        dbf.setFeature(\n-                \"http:\/\/apache.org\/xml\/features\/nonvalidating\/load-external-dtd\",\n-                false);\n-        return dbf.newDocumentBuilder();\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":9,"deletions":77,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+        jdk.jpackage\/jdk.jpackage.internal.model:+open \\\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+\n+import jdk.jpackage.internal.model.PackagerException;\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DeployParamsTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.function.Function;\n-import java.lang.reflect.Method;\n@@ -31,0 +28,6 @@\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -83,2 +86,2 @@\n-        MAC_CFBUNDLE_VERSION_CLASS(\"jdk.jpackage.internal.CFBundleVersion\"),\n-        WIN_MSI_PRODUCT_VERSION_CLASS(\"jdk.jpackage.internal.MsiVersion\");\n+        MAC_CFBUNDLE_VERSION_CLASS(\"jdk.jpackage.internal.CFBundleVersion\", OperatingSystem.MACOS),\n+        WIN_MSI_PRODUCT_VERSION_CLASS(\"jdk.jpackage.internal.model.MsiVersion\", OperatingSystem.WINDOWS);\n@@ -86,2 +89,6 @@\n-        PlatformVersion(String className) {\n-            parser = findParser(className);\n+        PlatformVersion(String className, OperatingSystem os) {\n+            if (os.equals(OperatingSystem.current())) {\n+                parser = getParser(className);\n+            } else {\n+                parser = null;\n+            }\n@@ -97,1 +104,1 @@\n-    private static Function<String, DottedVersion> findParser(String className) {\n+    private static Function<String, DottedVersion> getParser(String className) {\n@@ -114,3 +121,1 @@\n-        } catch (ClassNotFoundException e) {\n-            return null;\n-        } catch (SecurityException | NoSuchMethodException ex) {\n+        } catch (SecurityException | NoSuchMethodException | ClassNotFoundException ex) {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PlatformVersionTest.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.model.ConfigException;\n@@ -55,1 +57,1 @@\n-                new DottedVersion(\"1\")).setVersionParser(unused -> \"10\").validate());\n+                DottedVersion.greedy(\"1\")).setVersionParser(unused -> \"10\").validate());\n@@ -59,1 +61,1 @@\n-                new DottedVersion(\"5\")).setVersionParser(unused -> \"4.99.37\").validate(),\n+                DottedVersion.greedy(\"5\")).setVersionParser(unused -> \"4.99.37\").validate(),\n@@ -68,1 +70,1 @@\n-                new DottedVersion(\"8\")).setVersionParser(unused -> \"10\").validate());\n+                DottedVersion.greedy(\"8\")).setVersionParser(unused -> \"10\").validate());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ToolValidatorTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-package jdk.jpackage.internal;\n+package jdk.jpackage.internal.model;\n@@ -135,1 +135,1 @@\n-            final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> new DottedVersion(version));\n+            final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> DottedVersion.greedy(version));\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/DottedVersionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DottedVersionTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import javax.xml.parsers.ParserConfigurationException;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.w3c.dom.Node;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+\n+public class PListReaderTest {\n+\n+    enum QueryType {\n+        STRING(PListReader::queryValue),\n+        BOOLEAN(PListReader::queryBoolValue),\n+        STRING_ARRY(PListReader::queryArrayValue);\n+\n+        QueryType(BiFunction<PListReader, String, ?> queryMethod) {\n+            this.queryMethod = Objects.requireNonNull(queryMethod);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <T> T queryValue(PListReader pListReader, String keyName) {\n+            return (T)queryMethod.apply(pListReader, keyName);\n+        }\n+\n+        private final BiFunction<PListReader, String, ?> queryMethod;\n+    }\n+\n+    public record QueryValueTestSpec(QueryType queryType, String keyName, Optional<Object> expectedValue,\n+            Optional<Class<? extends RuntimeException>> expectedException, String... xml) {\n+\n+        public QueryValueTestSpec {\n+            Objects.requireNonNull(queryType);\n+            Objects.requireNonNull(keyName);\n+            Objects.requireNonNull(expectedValue);\n+            Objects.requireNonNull(expectedException);\n+            Objects.requireNonNull(xml);\n+            if (expectedValue.isEmpty() == expectedException.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            Builder queryType(QueryType v) {\n+                queryType = v;\n+                return this;\n+            }\n+\n+            Builder keyName(String v) {\n+                keyName = v;\n+                return this;\n+            }\n+\n+            Builder expectedValue(Object v) {\n+                expectedValue = v;\n+                if (v instanceof String) {\n+                    queryType(QueryType.STRING);\n+                } else if (v instanceof Boolean) {\n+                    queryType(QueryType.BOOLEAN);\n+                } else if (v instanceof List<?>) {\n+                    queryType(QueryType.STRING_ARRY);\n+                }\n+                return this;\n+            }\n+\n+            Builder expectedException(Class<? extends RuntimeException> v) {\n+                expectedException = v;\n+                return this;\n+            }\n+\n+            Builder xml(String... v) {\n+                xml = v;\n+                return this;\n+            }\n+\n+            QueryValueTestSpec create() {\n+                return new QueryValueTestSpec(queryType, keyName, Optional.ofNullable(expectedValue),\n+                        validatedExpectedException(), xml);\n+            }\n+\n+            private Optional<Class<? extends RuntimeException>> validatedExpectedException() {\n+                if (expectedValue == null && expectedException == null) {\n+                    return Optional.of(NoSuchElementException.class);\n+                } else {\n+                    return Optional.ofNullable(expectedException);\n+                }\n+            }\n+\n+            private QueryType queryType = QueryType.STRING;\n+            private String keyName = \"foo\";\n+            private Object expectedValue;\n+            private Class<? extends RuntimeException> expectedException;\n+            private String[] xml = new String[0];\n+        }\n+\n+        void test() {\n+            final var plistReader = new PListReader(createXml(xml));\n+\n+            expectedValue.ifPresent(v -> {\n+                final var actualValue = queryType.queryValue(plistReader, keyName);\n+                assertEquals(v, actualValue);\n+            });\n+\n+            expectedException.ifPresent(v -> {\n+                assertThrows(v, () -> queryType.queryValue(plistReader, keyName));\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(queryType);\n+            sb.append(\"; key=\").append(keyName);\n+            expectedValue.ifPresent(v -> {\n+                sb.append(\"; expected=\");\n+                sb.append(v);\n+            });\n+            expectedException.ifPresent(v -> {\n+                sb.append(\"; throws=\");\n+                sb.append(v);\n+            });\n+            sb.append(\"; xml=\");\n+            sb.append(String.join(\"\", xml));\n+            return sb.toString();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(QueryType.class)\n+    public void testNoSuchElement(QueryType queryType) {\n+        testSpec(queryType).create().test();\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(QueryType.class)\n+    public void testWrongValueType(QueryType queryType) {\n+        final var builder = testSpec(queryType).xml(\n+                \"<key>string-key<\/key>\",\n+                \"<string>a<\/string>\",\n+                \"<key>boolean-true-key<\/key>\",\n+                \"<true\/>\",\n+                \"<key>boolean-false-key<\/key>\",\n+                \"<false\/>\",\n+                \"<key>array-key<\/key>\",\n+                \"<array><string>b<\/string><\/array>\");\n+\n+        List<QueryValueTestSpec> testSpecs = new ArrayList<>();\n+\n+        switch (queryType) {\n+            case STRING -> {\n+                testSpecs.add(builder.keyName(\"boolean-true-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-false-key\").create());\n+                testSpecs.add(builder.keyName(\"array-key\").create());\n+            }\n+            case BOOLEAN -> {\n+                testSpecs.add(builder.keyName(\"string-key\").create());\n+                testSpecs.add(builder.keyName(\"array-key\").create());\n+            }\n+            case STRING_ARRY -> {\n+                testSpecs.add(builder.keyName(\"string-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-true-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-false-key\").create());\n+            }\n+        }\n+\n+        testSpecs.forEach(QueryValueTestSpec::test);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testQueryValue(QueryValueTestSpec testSpec) {\n+        testSpec.test();\n+    }\n+\n+    @Test\n+    public void testByteArrayCtor() throws ParserConfigurationException, SAXException, IOException {\n+        final var plistReader = new PListReader(xmlToString(\"<key>foo<\/key><string>A<\/string>\").getBytes(StandardCharsets.UTF_8));\n+        final var actualValue = plistReader.queryValue(\"foo\");\n+        assertEquals(\"A\", actualValue);\n+    }\n+\n+    private static List<QueryValueTestSpec> testQueryValue() {\n+        return List.of(\n+                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string>\").create(),\n+                testSpec().expectedValue(\"\").xml(\"<key>foo<\/key><string\/>\").create(),\n+                testSpec().xml(\"<key>foo<\/key><String\/>\").create(),\n+                testSpec().expectedValue(Boolean.TRUE).xml(\"<key>foo<\/key><true\/>\").create(),\n+                testSpec().expectedValue(Boolean.FALSE).xml(\"<key>foo<\/key><false\/>\").create(),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><True\/>\").create(),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/>\").create(),\n+                testSpec().expectedValue(List.of(\"foo\", \"bar\")).xml(\"<key>foo<\/key><array><string>foo<\/string><string>bar<\/string><\/array>\").create(),\n+                testSpec().expectedValue(List.of()).xml(\"<key>foo<\/key><array\/>\").create(),\n+                testSpec(QueryType.STRING_ARRY).xml(\"<key>foo<\/key><Array\/>\").create(),\n+                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\").create(),\n+                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string>\").create()\n+        );\n+    }\n+\n+    private static QueryValueTestSpec.Builder testSpec() {\n+        return new QueryValueTestSpec.Builder();\n+    }\n+\n+    private static QueryValueTestSpec.Builder testSpec(QueryType queryType) {\n+        return testSpec().queryType(queryType);\n+    }\n+\n+    private static String xmlToString(String ...xml) {\n+        final List<String> content = new ArrayList<>();\n+        content.add(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n+        content.add(\"<plist version=\\\"1.0\\\">\");\n+        content.addAll(List.of(xml));\n+        content.add(\"<\/plist>\");\n+        return String.join(\"\", content.toArray(String[]::new));\n+    }\n+\n+    private static Node createXml(String ...xml) {\n+        try {\n+            return XmlUtils.initDocumentBuilder().parse(new InputSource(new StringReader(xmlToString(xml))));\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } catch (SAXException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PListReaderTest.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package jdk.jpackage.internal;\n+package jdk.jpackage.internal.util;\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PathGroupTest.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import jdk.jpackage.test.MacHelper.PListWrapper;\n+import jdk.jpackage.internal.util.PListReader;\n@@ -77,1 +77,1 @@\n-    private static void checkStringValue(PListWrapper plist, String key, String value) {\n+    private static void checkStringValue(PListReader plist, String key, String value) {\n@@ -83,1 +83,1 @@\n-    private static void checkBoolValue(PListWrapper plist, String key, Boolean value) {\n+    private static void checkBoolValue(PListReader plist, String key, Boolean value) {\n@@ -89,1 +89,1 @@\n-    private static void checkArrayValue(PListWrapper plist, String key,\n+    private static void checkArrayValue(PListReader plist, String key,\n@@ -97,1 +97,1 @@\n-        PListWrapper plist = MacHelper.readPListFromAppImage(appImage);\n+        var plist = MacHelper.readPListFromAppImage(appImage);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}