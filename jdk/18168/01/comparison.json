{"files":[{"patch":"@@ -2984,3 +2984,1 @@\n-                exactnessCheck = make\n-                        .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1)))\n-                        .setType(syms.booleanType);\n+                exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1));\n@@ -2989,3 +2987,5 @@\n-                JCExpression nullCheck = makeBinary(NE,\n-                        make.Ident(dollar_s),\n-                        makeNull());\n+                JCExpression nullCheck =\n+                        makeBinary(NE,\n+                            make.Ident(dollar_s),\n+                            makeNull());\n+\n@@ -2993,3 +2993,1 @@\n-                    exactnessCheck = make\n-                            .LetExpr(List.of(var), nullCheck)\n-                            .setType(syms.booleanType);\n+                    exactnessCheck = nullCheck;\n@@ -2997,2 +2995,4 @@\n-                    exactnessCheck = getExactnessCheck(tree,\n-                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                    exactnessCheck =\n+                        makeBinary(AND,\n+                            nullCheck,\n+                            getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n@@ -3000,3 +3000,6 @@\n-                    exactnessCheck = make.at(tree.pos())\n-                            .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n-                            .setType(syms.booleanType);\n+                    exactnessCheck =\n+                        makeBinary(AND,\n+                            nullCheck,\n+                            make.at(tree.pos())\n+                                .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n+                                .setType(syms.booleanType));\n@@ -3004,5 +3007,0 @@\n-\n-                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n-                        nullCheck,\n-                        exactnessCheck))\n-                        .setType(syms.booleanType);\n@@ -3011,7 +3009,1 @@\n-                JCIdent argument = make.Ident(dollar_s);\n-\n-                JCExpression exactnessCheckCall =\n-                        getExactnessCheck(tree, argument);\n-\n-                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n-                        .setType(syms.booleanType);\n+                exactnessCheck = getExactnessCheck(tree, make.Ident(dollar_s));\n@@ -3020,1 +3012,2 @@\n-            result = exactnessCheck;\n+            result = make.LetExpr(List.of(var), exactnessCheck)\n+                    .setType(syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-                    make.Ident(bindingVar), convert(make.Ident(currentValue), castTargetType)).setType(bindingVar.erasure(types));\n+                    make.Ident(bindingVar), convert(make.Ident(currentValue).setType(currentValue.erasure(types)), castTargetType)).setType(bindingVar.erasure(types));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing2());\n@@ -106,2 +107,2 @@\n-    public static <T extends Integer> boolean wideningReferenceConversionUnboxing() {\n-        R_generic i = new R_generic(42);\n+    public static boolean wideningReferenceConversionUnboxing() {\n+        R_generic<Integer> i = new R_generic<Integer>(42);\n@@ -111,2 +112,7 @@\n-    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive() {\n-        R_generic i = new R_generic(42);\n+    public static boolean wideningReferenceConversionUnboxing2() {\n+        R_generic2<Byte> i = new R_generic2<Byte>(Byte.valueOf((byte) 42));\n+        return i instanceof R_generic2(byte _);\n+    }\n+\n+    public static boolean wideningReferenceConversionUnboxingAndWideningPrimitive() {\n+        R_generic<Integer> i = new R_generic<Integer>(42);\n@@ -158,1 +164,3 @@\n-    record R_generic<T extends Integer>(int i) {}\n+    record R_generic<T extends Integer>(T i) {}\n+    record R_generic2<T extends Byte>(T i) {}\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithRecordPatterns.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487 8325257\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfPatternOpWithTopLevelPatterns.java\n+ * @run main\/othervm PrimitiveInstanceOfPatternOpWithTopLevelPatterns\n+ *\/\n+public class PrimitiveInstanceOfPatternOpWithTopLevelPatterns {\n+    public static final int qualI = 42;\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  qualifiedExprConversion());\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing(42));\n+        assertEquals(true,  wideningReferenceConversionUnboxing2(Byte.valueOf((byte) 42)));\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive(42));\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+        assertEquals(true,  patternExtractRecordComponent());\n+        assertEquals(true,  exprMethod());\n+        assertEquals(true,  exprStaticallyQualified());\n+    }\n+\n+    public static boolean qualifiedExprConversion() {\n+        return PrimitiveInstanceOfTypeComparisonOp.qualI instanceof int;\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        int i = 42;\n+        return i instanceof int ii;\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        short s = (short) 42;\n+        char c = 'a';\n+\n+        return b instanceof int bb && s instanceof int ss && c instanceof int cc;\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        long l_within_int_range = 42L;\n+        long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int lw && !(l_outside_int_range instanceof int lo);\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        byte b2 = (byte) -42;\n+        char c = (char) 42;\n+        return b instanceof char bb && c instanceof byte cc && !(b2 instanceof char b2b);\n+    }\n+\n+    public static boolean boxingConversion() {\n+        int i = 42;\n+\n+        return i instanceof Integer ii;\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        int i = 42;\n+        return i instanceof Object io &&\n+                i instanceof Number in &&\n+                i instanceof Comparable cc;\n+    }\n+\n+    public static boolean unboxing() {\n+        Integer i = Integer.valueOf(1);\n+        return i instanceof int ii;\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        Object o1 = (int) 42;\n+        Object o2 = (byte) 42;\n+\n+        return o1 instanceof int o1o &&\n+                o2 instanceof byte o2o &&\n+                !(o1 instanceof byte o1b &&\n+                        !(o2 instanceof int o2b ));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing(T i) {\n+        return i instanceof int ii;\n+    }\n+\n+    public static <T extends Byte> boolean wideningReferenceConversionUnboxing2(T i) {\n+        return i instanceof byte bb;\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive(T i) {\n+        return i instanceof double ii;\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        Byte b = Byte.valueOf((byte)42);\n+        Short s = Short.valueOf((short)42);\n+        Character c = Character.valueOf('a');\n+\n+        return (b instanceof int bb) && (s instanceof int ss) && (c instanceof int cc);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        Integer i = Integer.valueOf(smallestIntNotRepresentable);\n+\n+        return i instanceof float ii;\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        Byte b = null;\n+        Short s = null;\n+        Character c = null;\n+\n+        return !(b instanceof int bb) && !(s instanceof int ss) && !(c instanceof int cc);\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        Number n = Byte.valueOf((byte) 42);\n+\n+        return n instanceof byte nn;\n+    }\n+\n+    public record P(int i) { }\n+    public static boolean patternExtractRecordComponent() {\n+        Object p = new P(42);\n+        if (p instanceof P(byte b)) {\n+            return b == 42;\n+        }\n+        return false;\n+    }\n+\n+    public static int meth() {return 42;}\n+    public static boolean exprMethod() {\n+        return meth() instanceof int ii;\n+    }\n+\n+    public class A1 {\n+        public static int i = 42;\n+    }\n+    public static boolean exprStaticallyQualified() {\n+        return A1.i instanceof int ii;\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithTopLevelPatterns.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing2(Byte.valueOf((byte) 42)));\n@@ -109,4 +110,4 @@\n-        return o1 instanceof int i1 &&\n-                o2 instanceof byte b1 &&\n-                !(o1 instanceof byte b2 &&\n-                !(o2 instanceof int i2));\n+        return o1 instanceof int &&\n+                o2 instanceof byte &&\n+                !(o1 instanceof byte &&\n+                !(o2 instanceof int));\n@@ -119,0 +120,4 @@\n+    public static <T extends Byte> boolean wideningReferenceConversionUnboxing2(T i) {\n+        return i instanceof byte;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}