{"files":[{"patch":"@@ -260,1 +260,1 @@\n-static int           latest_compilation_id   = 0;\n+static unsigned int  latest_compilation_id   = 0;\n@@ -594,1 +594,5 @@\n-  assert(granularity > 0, \"granularity should be positive.\");\n+  if (!(granularity > 0)) {\n+    printBox(ast, '-', \"Requested granularity must be > 0 to aggregate statistics.\", nullptr);\n+    BUFFEREDSTREAM_FLUSH(\"\")\n+    return;\n+  }\n@@ -661,1 +665,1 @@\n-    int          highest_compilation_id = 0;\n+    unsigned int highest_compilation_id = 0;\n@@ -681,1 +685,1 @@\n-      int compile_id = 0;\n+      unsigned int compile_id = 0;\n@@ -687,1 +691,0 @@\n-      \/\/ Do not assert here, just check, print error message and return.\n@@ -689,0 +692,1 @@\n+      \/\/ Therefore, just print some failure message and quit processing.\n@@ -803,1 +807,1 @@\n-            } else if ((used_topSizeBlocks < alloc_topSizeBlocks) && (hb_len < currMin)) {\n+            } else if ((used_topSizeBlocks < alloc_topSizeBlocks) && (hb_len <= currMin)) {\n@@ -805,1 +809,1 @@\n-              TopSizeArray[currMin_ix].index = used_topSizeBlocks;\n+              TopSizeArray[currMin_ix].index = used_topSizeBlocks; \/\/ link currMin -> newMin\n@@ -844,1 +848,0 @@\n-                        assert(TopSizeArray[i].len == currMin, \"sort error\");\n@@ -893,1 +896,1 @@\n-                          TopSizeArray[i].nm_size     = nm_size;\n+                          TopSizeArray[j].nm_size     = nm_size;\n@@ -1108,3 +1111,12 @@\n-        for (unsigned int i = 0; (TopSizeArray[i].index != tsbStopper) && (j++ < alloc_topSizeBlocks); i = TopSizeArray[i].index) {\n-          if (TopSizeArray[i].len < TopSizeArray[TopSizeArray[i].index].len) {\n-            out->print_cr(\"sort error at index %d: %d !>= %d\", i, TopSizeArray[i].len, TopSizeArray[TopSizeArray[i].index].len);\n+\n+        if (used_topSizeBlocks > 1) {\n+          int this_i = 0;\n+          int prev_i = tsbStopper;\n+          int elem_i = 1;\n+          while (TopSizeArray[this_i].index != tsbStopper) {\n+            elem_i++;\n+            prev_i = this_i;\n+            this_i = TopSizeArray[this_i].index;\n+            if (TopSizeArray[this_i].len > TopSizeArray[prev_i].len) {\n+              out->print_cr(\"TopSizeArray[%d].len(%d) <= TopSizeArray[%d].len(%d), #total = %d, #current = %d\", this_i, TopSizeArray[this_i].len, prev_i, TopSizeArray[prev_i].len, used_topSizeBlocks, elem_i);\n+            }\n@@ -1113,0 +1125,1 @@\n+\n@@ -1262,7 +1275,1 @@\n-    ast->fill_to(51);\n-    ast->print(\"%4s\", \"blob\");\n-    ast->fill_to(56);\n-    ast->print(\"%9s\", \"compiler\");\n-    ast->fill_to(66);\n-    ast->print_cr(\"%6s\", \"method\");\n-    ast->print_cr(\"%18s %13s %17s %9s  %5s %s\",      \"Addr(module)      \", \"offset\", \"size\", \"type\", \" type lvl\", \"Name\");\n+    print_MethodlistHeader(ast);\n@@ -1285,6 +1292,2 @@\n-          \/\/---<  blob address  >---\n-          ast->print(INTPTR_FORMAT, p2i(this_blob));\n-          ast->fill_to(19);\n-          \/\/---<  blob offset from CodeHeap begin  >---\n-          ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)((char*)this_blob-low_bound));\n-          ast->fill_to(33);\n+          \/\/---<  blob address and offset from CodeHeap begin  >---\n+          print_address_and_offset(ast, (address)this_blob, (address)low_bound);\n@@ -1292,6 +1295,2 @@\n-          \/\/---<  block address  >---\n-          ast->print(INTPTR_FORMAT, p2i(TopSizeArray[i].start));\n-          ast->fill_to(19);\n-          \/\/---<  block offset from CodeHeap begin  >---\n-          ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)((char*)TopSizeArray[i].start-low_bound));\n-          ast->fill_to(33);\n+          \/\/---<  block address and offset from CodeHeap begin  >---\n+          print_address_and_offset(ast, (address)TopSizeArray[i].start, (address)low_bound);\n@@ -1312,1 +1311,1 @@\n-          ast->fill_to(67+6);\n+          ast->fill_to(67);\n@@ -1321,1 +1320,1 @@\n-          ast->fill_to(67+6);\n+          ast->fill_to(67);\n@@ -1980,5 +1979,5 @@\n-      int age1      = StatArray[ix].t1_age;\n-      int age2      = StatArray[ix].t2_age;\n-      int agex      = StatArray[ix].tx_age;\n-      int age       = age1 > age2 ? age1 : age2;\n-      age       = age > agex ? age : agex;\n+      unsigned int age1  = StatArray[ix].t1_age;\n+      unsigned int age2  = StatArray[ix].t2_age;\n+      unsigned int agex  = StatArray[ix].tx_age;\n+      unsigned int age   = age1 > age2 ? age1 : age2;\n+      age = age > agex ? age : agex;\n@@ -2090,0 +2089,1 @@\n+  print_blobType_legend(ast);\n@@ -2123,0 +2123,1 @@\n+        unsigned int   blob_size = this_blob->size();\n@@ -2148,5 +2149,1 @@\n-          ast->fill_to(51);\n-          ast->print(\"%9s\", \"compiler\");\n-          ast->fill_to(61);\n-          ast->print_cr(\"%6s\", \"method\");\n-          ast->print_cr(\"%18s %13s %17s %9s  %18s  %s\", \"Addr(module)      \", \"offset\", \"size\", \" type lvl\", \"blobType          \", \"Name\");\n+          print_MethodlistHeader(ast);\n@@ -2157,4 +2154,1 @@\n-        ast->print(INTPTR_FORMAT, p2i(this_blob));\n-        ast->fill_to(19);\n-        ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)((char*)this_blob-low_bound));\n-        ast->fill_to(33);\n+        print_address_and_offset(ast, (address)this_blob, (address)low_bound);\n@@ -2170,0 +2164,16 @@\n+#if 1\n+          CompLevel level = (CompLevel)(nm->comp_level());\n+          u2     compiler = 0;\n+          if (nm->is_compiled_by_c1()) {\n+            compiler = c1;\n+          }\n+          if (nm->is_compiled_by_c2()) {\n+            compiler = c2;\n+          }\n+          if (nm->is_compiled_by_jvmci()) {\n+            compiler = jvmci;\n+          }\n+#else\n+          u2     compiler = StatArray[ix].compiler;\n+          CompLevel level = StatArray[ix].level\n+#endif\n@@ -2173,1 +2183,1 @@\n-          \/\/---<  compiler information  >---\n+          \/\/---<  blob type  >---\n@@ -2175,1 +2185,4 @@\n-          ast->print(\"%5s %3d\", compTypeName[StatArray[ix].compiler], StatArray[ix].level);\n+          ast->print(\"  %c\", blobTypeChar[cbType]);\n+          \/\/---<  compiler information  >---\n+          ast->fill_to(56);\n+          ast->print(\"%5s %3d\", compTypeName[compiler], level);\n@@ -2177,3 +2190,1 @@\n-          ast->fill_to(62);\n-          ast->print(\"%s\", blobTypeName[cbType]);\n-          ast->fill_to(82);\n+          ast->fill_to(67);\n@@ -2183,0 +2194,1 @@\n+            const char* classNameS;\n@@ -2189,2 +2201,5 @@\n-            assert(klass != nullptr, \"No method holder\");\n-            const char* classNameS = (klass->name() == nullptr) ? \"<class name unavailable>\" : klass->external_name();\n+            if (klass != nullptr) {\n+              classNameS = (klass->name() == nullptr) ? \"<class name unavailable>\" : klass->external_name();\n+            } else {\n+              classNameS = \"<no method holder>\";\n+            }\n@@ -2205,3 +2220,7 @@\n-          ast->fill_to(62);\n-          ast->print(\"%s\", blobTypeName[cbType]);\n-          ast->fill_to(82);\n+          \/\/---<  blob size in hex  >---\n+          ast->print(UINT32_FORMAT_X_0, blob_size);\n+          ast->print(\"(\" SIZE_FORMAT_W(4) \"K)\", blob_size\/K);\n+          ast->fill_to(51);\n+          \/\/---<  blob type  >---\n+          ast->print(\"  %c\", blobTypeChar[cbType]);\n+          ast->fill_to(67);\n@@ -2210,1 +2229,1 @@\n-          ast->fill_to(62);\n+          ast->fill_to(67);\n@@ -2225,0 +2244,25 @@\n+void CodeHeapState::print_MethodlistHeader(outputStream* ast) {\n+\n+  \/\/ Header layout:\n+  \/\/ 1                  20            34                52    57        67\n+  \/\/ |                  |             |                 |     |         |\n+  \/\/                                                    blob  compiler  method\n+  \/\/ Addr(module)              offset              size type  type lvl  Name\n+  \/\/ 0x000000010a87c008 (+0x00000008) 0x00000098(   0K)   N   none   0  java.lang.Byte.toUnsignedInt(B)I\n+\n+  ast->fill_to(51);\n+  ast->print(\"%4s\", \"blob\");\n+  ast->fill_to(56);\n+  ast->print(\"%9s\", \" compiler\");\n+  ast->fill_to(67);\n+  ast->print_cr(\"%6s\", \"method\");\n+  ast->print_cr(\"%18s %13s %17s %4s %9s  %s\", \"Addr(module)      \", \"offset\", \"size\", \"type\", \" type lvl\", \"Name\");\n+}\n+\n+void CodeHeapState::print_address_and_offset(outputStream* ast, address here, address base) {\n+  ast->print(INTPTR_FORMAT, p2i(here));\n+  ast->fill_to(19);\n+  ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)(here - base));\n+  ast->fill_to(33);\n+}\n+\n@@ -2276,1 +2320,0 @@\n-  int range_beg = latest_compilation_id;\n@@ -2290,2 +2333,2 @@\n-  int age_range = 256;\n-  int range_beg = latest_compilation_id;\n+  unsigned int age_range = 256;\n+  unsigned int range_beg = latest_compilation_id;\n@@ -2320,1 +2363,1 @@\n-void CodeHeapState::print_age_single(outputStream* out, int age) {\n+void CodeHeapState::print_age_single(outputStream* out, unsigned int age) {\n@@ -2322,1 +2365,1 @@\n-  int age_range = 256;\n+  unsigned int age_range = 256;\n@@ -2335,0 +2378,1 @@\n+  \/\/ Note: out and ast MUST designate the SAME stream!\n@@ -2340,1 +2384,0 @@\n-    assert(out == ast, \"must use the same stream!\");\n@@ -2342,3 +2385,2 @@\n-    ast->print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));\n-    ast->fill_to(19);\n-    ast->print(\"(+\" UINT32_FORMAT_X_0 \"): |\", (unsigned int)(ix*granule_size));\n+    print_address_and_offset(ast, (address)(low_bound + ix*granule_size), (address)low_bound);\n+    ast->print(\" |\");\n@@ -2349,1 +2391,1 @@\n-  assert(out != ast, \"must not use the same stream!\");\n+  \/\/ Note: out and ast MUST NOT designate the SAME stream!\n@@ -2366,3 +2408,2 @@\n-    ast->print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));\n-    ast->fill_to(19);\n-    ast->print(\"(+\" UINT32_FORMAT_X_0 \"): |\", (unsigned int)(ix*granule_size));\n+    print_address_and_offset(ast, (address)(low_bound + ix*granule_size), (address)low_bound);\n+    ast->print(\" |\");\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":112,"deletions":71,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  static void print_MethodlistHeader(outputStream* ast);\n+  static void print_address_and_offset(outputStream* ast, address here, address base);\n@@ -91,1 +93,1 @@\n-  static void print_age_single(outputStream *ast, int age);\n+  static void print_age_single(outputStream *ast, unsigned int age);\n@@ -123,3 +125,3 @@\n-    int       t1_age;      \/\/ oldest compilation_id of tier1 nMethods.\n-    int       t2_age;      \/\/ oldest compilation_id of tier2 nMethods.\n-    int       tx_age;      \/\/ oldest compilation_id of inactive\/not entrant nMethods.\n+    unsigned int       t1_age;      \/\/ oldest compilation_id of tier1 nMethods.\n+    unsigned int       t2_age;      \/\/ oldest compilation_id of tier2 nMethods.\n+    unsigned int       tx_age;      \/\/ oldest compilation_id of inactive\/not entrant nMethods.\n","filename":"src\/hotspot\/share\/code\/codeHeapState.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}