{"files":[{"patch":"@@ -261,1 +261,1 @@\n-static int           latest_compilation_id   = 0;\n+static unsigned int  latest_compilation_id   = 0;\n@@ -595,1 +595,5 @@\n-  assert(granularity > 0, \"granularity should be positive.\");\n+  if (!(granularity > 0)) {\n+    printBox(ast, '-', \"Requested granularity must be > 0 to aggregate statistics.\", nullptr);\n+    BUFFEREDSTREAM_FLUSH(\"\")\n+    return;\n+  }\n@@ -662,1 +666,1 @@\n-    int          highest_compilation_id = 0;\n+    unsigned int highest_compilation_id = 0;\n@@ -682,1 +686,1 @@\n-      int compile_id = 0;\n+      unsigned int compile_id = 0;\n@@ -688,1 +692,0 @@\n-      \/\/ Do not assert here, just check, print error message and return.\n@@ -690,0 +693,1 @@\n+      \/\/ Therefore, just print some failure message and quit processing.\n@@ -804,1 +808,1 @@\n-            } else if ((used_topSizeBlocks < alloc_topSizeBlocks) && (hb_len < currMin)) {\n+            } else if ((used_topSizeBlocks < alloc_topSizeBlocks) && (hb_len <= currMin)) {\n@@ -806,1 +810,1 @@\n-              TopSizeArray[currMin_ix].index = used_topSizeBlocks;\n+              TopSizeArray[currMin_ix].index = used_topSizeBlocks; \/\/ link currMin -> newMin\n@@ -845,1 +849,0 @@\n-                        assert(TopSizeArray[i].len == currMin, \"sort error\");\n@@ -894,1 +897,1 @@\n-                          TopSizeArray[i].nm_size     = nm_size;\n+                          TopSizeArray[j].nm_size     = nm_size;\n@@ -1109,3 +1112,12 @@\n-        for (unsigned int i = 0; (TopSizeArray[i].index != tsbStopper) && (j++ < alloc_topSizeBlocks); i = TopSizeArray[i].index) {\n-          if (TopSizeArray[i].len < TopSizeArray[TopSizeArray[i].index].len) {\n-            out->print_cr(\"sort error at index %d: %d !>= %d\", i, TopSizeArray[i].len, TopSizeArray[TopSizeArray[i].index].len);\n+\n+        if (used_topSizeBlocks > 1) {\n+          int this_i = 0;\n+          int prev_i = tsbStopper;\n+          int elem_i = 1;\n+          while (TopSizeArray[this_i].index != tsbStopper) {\n+            elem_i++;\n+            prev_i = this_i;\n+            this_i = TopSizeArray[this_i].index;\n+            if (TopSizeArray[this_i].len > TopSizeArray[prev_i].len) {\n+              out->print_cr(\"TopSizeArray[%d].len(%d) <= TopSizeArray[%d].len(%d), #total = %d, #current = %d\", this_i, TopSizeArray[this_i].len, prev_i, TopSizeArray[prev_i].len, used_topSizeBlocks, elem_i);\n+            }\n@@ -1114,0 +1126,1 @@\n+\n@@ -1263,7 +1276,1 @@\n-    ast->fill_to(51);\n-    ast->print(\"%4s\", \"blob\");\n-    ast->fill_to(56);\n-    ast->print(\"%9s\", \"compiler\");\n-    ast->fill_to(66);\n-    ast->print_cr(\"%6s\", \"method\");\n-    ast->print_cr(\"%18s %13s %17s %9s  %5s %s\",      \"Addr(module)      \", \"offset\", \"size\", \"type\", \" type lvl\", \"Name\");\n+    print_MethodlistHeader(ast);\n@@ -1286,6 +1293,2 @@\n-          \/\/---<  blob address  >---\n-          ast->print(INTPTR_FORMAT, p2i(this_blob));\n-          ast->fill_to(19);\n-          \/\/---<  blob offset from CodeHeap begin  >---\n-          ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)((char*)this_blob-low_bound));\n-          ast->fill_to(33);\n+          \/\/---<  blob address and offset from CodeHeap begin  >---\n+          print_address_and_offset(ast, (address)this_blob, (address)low_bound);\n@@ -1293,6 +1296,2 @@\n-          \/\/---<  block address  >---\n-          ast->print(INTPTR_FORMAT, p2i(TopSizeArray[i].start));\n-          ast->fill_to(19);\n-          \/\/---<  block offset from CodeHeap begin  >---\n-          ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)((char*)TopSizeArray[i].start-low_bound));\n-          ast->fill_to(33);\n+          \/\/---<  block address and offset from CodeHeap begin  >---\n+          print_address_and_offset(ast, (address)TopSizeArray[i].start, (address)low_bound);\n@@ -1313,1 +1312,1 @@\n-          ast->fill_to(67+6);\n+          ast->fill_to(67);\n@@ -1322,1 +1321,1 @@\n-          ast->fill_to(67+6);\n+          ast->fill_to(67);\n@@ -1981,5 +1980,5 @@\n-      int age1      = StatArray[ix].t1_age;\n-      int age2      = StatArray[ix].t2_age;\n-      int agex      = StatArray[ix].tx_age;\n-      int age       = age1 > age2 ? age1 : age2;\n-      age       = age > agex ? age : agex;\n+      unsigned int age1  = StatArray[ix].t1_age;\n+      unsigned int age2  = StatArray[ix].t2_age;\n+      unsigned int agex  = StatArray[ix].tx_age;\n+      unsigned int age   = age1 > age2 ? age1 : age2;\n+      age = age > agex ? age : agex;\n@@ -2091,0 +2090,1 @@\n+  print_blobType_legend(ast);\n@@ -2124,0 +2124,1 @@\n+        unsigned int   blob_size = this_blob->size();\n@@ -2149,5 +2150,1 @@\n-          ast->fill_to(51);\n-          ast->print(\"%9s\", \"compiler\");\n-          ast->fill_to(61);\n-          ast->print_cr(\"%6s\", \"method\");\n-          ast->print_cr(\"%18s %13s %17s %9s  %18s  %s\", \"Addr(module)      \", \"offset\", \"size\", \" type lvl\", \"blobType          \", \"Name\");\n+          print_MethodlistHeader(ast);\n@@ -2158,4 +2155,1 @@\n-        ast->print(INTPTR_FORMAT, p2i(this_blob));\n-        ast->fill_to(19);\n-        ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)((char*)this_blob-low_bound));\n-        ast->fill_to(33);\n+        print_address_and_offset(ast, (address)this_blob, (address)low_bound);\n@@ -2171,0 +2165,16 @@\n+#if 1\n+          CompLevel level = (CompLevel)(nm->comp_level());\n+          u2     compiler = 0;\n+          if (nm->is_compiled_by_c1()) {\n+            compiler = c1;\n+          }\n+          if (nm->is_compiled_by_c2()) {\n+            compiler = c2;\n+          }\n+          if (nm->is_compiled_by_jvmci()) {\n+            compiler = jvmci;\n+          }\n+#else\n+          u2     compiler = StatArray[ix].compiler;\n+          CompLevel level = StatArray[ix].level\n+#endif\n@@ -2174,1 +2184,1 @@\n-          \/\/---<  compiler information  >---\n+          \/\/---<  blob type  >---\n@@ -2176,1 +2186,4 @@\n-          ast->print(\"%5s %3d\", compTypeName[StatArray[ix].compiler], StatArray[ix].level);\n+          ast->print(\"  %c\", blobTypeChar[cbType]);\n+          \/\/---<  compiler information  >---\n+          ast->fill_to(56);\n+          ast->print(\"%5s %3d\", compTypeName[compiler], level);\n@@ -2178,3 +2191,1 @@\n-          ast->fill_to(62);\n-          ast->print(\"%s\", blobTypeName[cbType]);\n-          ast->fill_to(82);\n+          ast->fill_to(67);\n@@ -2184,0 +2195,1 @@\n+            const char* classNameS;\n@@ -2190,2 +2202,5 @@\n-            assert(klass != nullptr, \"No method holder\");\n-            const char* classNameS = (klass->name() == nullptr) ? \"<class name unavailable>\" : klass->external_name();\n+            if (klass != nullptr) {\n+              classNameS = (klass->name() == nullptr) ? \"<class name unavailable>\" : klass->external_name();\n+            } else {\n+              classNameS = \"<no method holder>\";\n+            }\n@@ -2206,3 +2221,7 @@\n-          ast->fill_to(62);\n-          ast->print(\"%s\", blobTypeName[cbType]);\n-          ast->fill_to(82);\n+          \/\/---<  blob size in hex  >---\n+          ast->print(UINT32_FORMAT_X_0, blob_size);\n+          ast->print(\"(\" SIZE_FORMAT_W(4) \"K)\", blob_size\/K);\n+          ast->fill_to(51);\n+          \/\/---<  blob type  >---\n+          ast->print(\"  %c\", blobTypeChar[cbType]);\n+          ast->fill_to(67);\n@@ -2211,1 +2230,1 @@\n-          ast->fill_to(62);\n+          ast->fill_to(67);\n@@ -2226,0 +2245,25 @@\n+void CodeHeapState::print_MethodlistHeader(outputStream* ast) {\n+\n+  \/\/ Header layout:\n+  \/\/ 1                  20            34                52    57        67\n+  \/\/ |                  |             |                 |     |         |\n+  \/\/                                                    blob  compiler  method\n+  \/\/ Addr(module)              offset              size type  type lvl  Name\n+  \/\/ 0x000000010a87c008 (+0x00000008) 0x00000098(   0K)   N   none   0  java.lang.Byte.toUnsignedInt(B)I\n+\n+  ast->fill_to(51);\n+  ast->print(\"%4s\", \"blob\");\n+  ast->fill_to(56);\n+  ast->print(\"%9s\", \" compiler\");\n+  ast->fill_to(67);\n+  ast->print_cr(\"%6s\", \"method\");\n+  ast->print_cr(\"%18s %13s %17s %4s %9s  %s\", \"Addr(module)      \", \"offset\", \"size\", \"type\", \" type lvl\", \"Name\");\n+}\n+\n+void CodeHeapState::print_address_and_offset(outputStream* ast, address here, address base) {\n+  ast->print(INTPTR_FORMAT, p2i(here));\n+  ast->fill_to(19);\n+  ast->print(\"(+\" UINT32_FORMAT_X_0 \")\", (unsigned int)(here - base));\n+  ast->fill_to(33);\n+}\n+\n@@ -2277,1 +2321,0 @@\n-  int range_beg = latest_compilation_id;\n@@ -2291,2 +2334,2 @@\n-  int age_range = 256;\n-  int range_beg = latest_compilation_id;\n+  unsigned int age_range = 256;\n+  unsigned int range_beg = latest_compilation_id;\n@@ -2321,1 +2364,1 @@\n-void CodeHeapState::print_age_single(outputStream* out, int age) {\n+void CodeHeapState::print_age_single(outputStream* out, unsigned int age) {\n@@ -2323,1 +2366,1 @@\n-  int age_range = 256;\n+  unsigned int age_range = 256;\n@@ -2336,0 +2379,1 @@\n+  \/\/ Note: out and ast MUST designate the SAME stream!\n@@ -2341,1 +2385,0 @@\n-    assert(out == ast, \"must use the same stream!\");\n@@ -2343,3 +2386,2 @@\n-    ast->print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));\n-    ast->fill_to(19);\n-    ast->print(\"(+\" UINT32_FORMAT_X_0 \"): |\", (unsigned int)(ix*granule_size));\n+    print_address_and_offset(ast, (address)(low_bound + ix*granule_size), (address)low_bound);\n+    ast->print(\" |\");\n@@ -2350,1 +2392,1 @@\n-  assert(out != ast, \"must not use the same stream!\");\n+  \/\/ Note: out and ast MUST NOT designate the SAME stream!\n@@ -2367,3 +2409,2 @@\n-    ast->print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));\n-    ast->fill_to(19);\n-    ast->print(\"(+\" UINT32_FORMAT_X_0 \"): |\", (unsigned int)(ix*granule_size));\n+    print_address_and_offset(ast, (address)(low_bound + ix*granule_size), (address)low_bound);\n+    ast->print(\" |\");\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":112,"deletions":71,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  static void print_MethodlistHeader(outputStream* ast);\n+  static void print_address_and_offset(outputStream* ast, address here, address base);\n@@ -91,1 +93,1 @@\n-  static void print_age_single(outputStream *ast, int age);\n+  static void print_age_single(outputStream *ast, unsigned int age);\n@@ -123,3 +125,3 @@\n-    int       t1_age;      \/\/ oldest compilation_id of tier1 nMethods.\n-    int       t2_age;      \/\/ oldest compilation_id of tier2 nMethods.\n-    int       tx_age;      \/\/ oldest compilation_id of inactive\/not entrant nMethods.\n+    unsigned int       t1_age;      \/\/ oldest compilation_id of tier1 nMethods.\n+    unsigned int       t2_age;      \/\/ oldest compilation_id of tier2 nMethods.\n+    unsigned int       tx_age;      \/\/ oldest compilation_id of inactive\/not entrant nMethods.\n","filename":"src\/hotspot\/share\/code\/codeHeapState.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}