{"files":[{"patch":"@@ -673,1 +673,1 @@\n-      heap->old_generation()->cancel_gc();\n+      heap->old_generation()->abandon_gc();\n@@ -699,12 +699,1 @@\n-  if (!_do_old_gc_bootstrap) {\n-    \/\/ Update region state for only young regions\n-    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_region_states);\n-    ShenandoahInitMarkUpdateRegionStateClosure cl;\n-    _generation->parallel_heap_region_iterate(&cl);\n-  } else {\n-    shenandoah_assert_generational();\n-    assert(_generation->is_young(), \"Expect young for bootstrap\");\n-    assert(_generation->ref_processor()->get_old_generation_ref_processor() == nullptr,\n-           \"Young ref processor should not have old ref processor here\");\n-\n-    \/\/ Update region state for both young and old regions\n+  {\n@@ -713,6 +702,8 @@\n-    heap->parallel_heap_region_iterate(&cl);\n-\n-    \/\/ Configure old ref processor for bootstrap and old marking\n-    ShenandoahReferenceProcessor* old_ref_processor = heap->old_generation()->ref_processor();\n-    old_ref_processor->reset_thread_locals();\n-    _generation->ref_processor()->set_old_generation_ref_processor(old_ref_processor);\n+    if (_do_old_gc_bootstrap) {\n+      \/\/ Update region state for both young and old regions\n+      shenandoah_assert_generational();\n+      heap->parallel_heap_region_iterate(&cl);\n+    } else {\n+      \/\/ Update region state for only current generation regions\n+      _generation->parallel_heap_region_iterate(&cl);\n+    }\n@@ -1111,6 +1102,0 @@\n-\n-  ShenandoahReferenceProcessor* old = _generation->ref_processor()->get_old_generation_ref_processor();\n-  if (old != nullptr) {\n-    assert(_generation->is_young(), \"Only young ref processor can have an old ref processor\");\n-    old->heal_discovered_lists();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-          \/\/ (even if they have degenerated). If this is a global cycle, we'd have cancelled\n+          \/\/ (even if they have degenerated). If this is a global cycle, we'd have abandoned\n@@ -167,2 +167,3 @@\n-          \/\/ the generation does NOT abandon incomplete SATB buffers as cancel_concurrent_mark does.\n-          \/\/ We need to separate out the old pointers which is done below.\n+          \/\/ the young generation does NOT abandon incomplete SATB buffers in the old generation\n+          \/\/ as cancel_concurrent_mark does. We need to separate out the old pointers which\n+          \/\/ is done below.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -409,0 +409,2 @@\n+      \/\/ Configure the young generation for bootstrapping the old mark\n+      young_generation->prepare_for_bootstrap(old_generation);\n@@ -411,5 +413,0 @@\n-      \/\/ Configure the young generation's concurrent mark to put objects in\n-      \/\/ old regions into the concurrent mark queues associated with the old\n-      \/\/ generation. The young cycle will run as normal except that rather than\n-      \/\/ ignore old references it will mark and enqueue them in the old concurrent\n-      \/\/ task queues but it will not traverse them.\n@@ -417,1 +414,0 @@\n-      young_generation->set_old_gen_task_queues(old_generation->task_queues());\n@@ -563,2 +559,2 @@\n-    assert(generation->is_global(), \"If not young, must be GLOBAL\");\n-    assert(!do_old_gc_bootstrap, \"Do not bootstrap with GLOBAL GC\");\n+    assert(generation->is_global(), \"If not young, must be Global\");\n+    assert(!do_old_gc_bootstrap, \"Do not bootstrap with Global GC\");\n@@ -566,1 +562,1 @@\n-      msg = \"At end of Interrupted Concurrent GLOBAL GC\";\n+      msg = \"At end of Interrupted Concurrent Global GC\";\n@@ -778,2 +774,3 @@\n-    log_debug(gc, thread)(\"Transition from: %s to: %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n-    EventMark event(\"Control thread transition from: %s, to %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n+    FormatBuffer<> msg(\"Transition from: %s to: %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n+    log_debug(gc, thread)(\"%s\", msg.buffer());\n+    Events::log(this, \"%s\", msg.buffer());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+  \/\/ If we were bootstrapping, we don't need that configuration anymore\n+  heap->young_generation()->clear_bootstrap_configuration();\n+\n@@ -62,1 +65,1 @@\n-  heap->old_generation()->cancel_gc();\n+  heap->old_generation()->abandon_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -946,0 +946,11 @@\n+\n+\n+  ShenandoahReferenceProcessor* old_ref_processor = generation->ref_processor()->get_old_generation_ref_processor();\n+  if (old_ref_processor != nullptr) {\n+    \/\/ Discovered lists may have young references with old referents. These references will be\n+    \/\/ processed at the end of old marking. We need to update them.\n+    assert(generation->is_young(), \"We should only have old discovered lists in a young collection\");\n+    ShenandoahPhaseTimings::Phase phase = concurrent ? ShenandoahPhaseTimings::conc_weak_refs : ShenandoahPhaseTimings::degen_gc_weakrefs;\n+    old_ref_processor->heal_discovered_lists(phase, workers(), concurrent);\n+  }\n+\n@@ -1034,3 +1045,2 @@\n-  \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up\n-  \/\/ transient state. Otherwise, these actions have no effect.\n-  reset_generation_reserves();\n+\n+  complete_cycle();\n@@ -1045,0 +1055,2 @@\n+  complete_cycle();\n+\n@@ -1055,0 +1067,11 @@\n+\n+}\n+\n+void ShenandoahGenerationalHeap::complete_cycle() {\n+  if (young_generation()->is_bootstrap_cycle()) {\n+    \/\/ Once the bootstrap cycle is completed, the young generation is no longer obliged to mark old\n+    young_generation()->clear_bootstrap_configuration();\n+  }\n+\n+  \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up\n+  \/\/ transient state. Otherwise, these actions have no effect.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+  void complete_cycle();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,8 +60,0 @@\n-    \/\/ Old collection is complete, the young generation no longer needs this\n-    \/\/ reference to the old concurrent mark so clean it up. It also no longer\n-    \/\/ needs a reference to the old generation ref processor.\n-    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-    young_generation->set_old_gen_task_queues(nullptr);\n-    young_generation->ref_processor()->clear_old_generation_ref_processor();\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-void ShenandoahOldGeneration::cancel_gc() {\n+void ShenandoahOldGeneration::abandon_gc() {\n@@ -308,2 +308,0 @@\n-    \/\/ Remove old generation access to young generation mark queues\n-    ShenandoahHeap::heap()->young_generation()->set_old_gen_task_queues(nullptr);\n@@ -449,2 +447,3 @@\n-    log_debug(gc, thread)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n-    EventMark event(\"Old was %s, now is %s\", state_name(_state), state_name(new_state));\n+    FormatBuffer<> msg(\"Old was %s, now is %s\", state_name(_state), state_name(new_state));\n+    log_debug(gc, thread)(\"%s\", msg.buffer());\n+    Events::log(Thread::current(), \"%s\", msg.buffer());\n@@ -534,0 +533,1 @@\n+      assert(heap->young_generation()->is_bootstrap_cycle(), \"Young generation needs old mark queues.\");\n@@ -537,1 +537,1 @@\n-      assert(heap->young_generation()->old_gen_task_queues() != nullptr, \"Young generation needs old mark queues.\");\n+      assert(!heap->young_generation()->is_bootstrap_cycle(), \"Young generation is done with bootstrapping\");\n@@ -555,1 +555,0 @@\n-  assert(heap->young_generation()->old_gen_task_queues() == nullptr, \"Cannot become ready for bootstrap when still setup for bootstrapping.\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -228,2 +228,2 @@\n-  \/\/ Cancels old gc and transitions to the idle state\n-  void cancel_gc();\n+  \/\/ Abandons all old gc state and transitions to the idle state\n+  void abandon_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,0 +182,43 @@\n+template <typename CallbackT>\n+class ShenandoahReferenceProcessorTask : public WorkerTask {\n+private:\n+  bool const                          _concurrent;\n+  ShenandoahPhaseTimings::Phase const _phase;\n+  ShenandoahRefProcThreadLocal* const _ref_proc_thread_locals;\n+  CallbackT _callback;\n+  volatile uint _iterate_discovered_list_id;\n+\n+public:\n+  ShenandoahReferenceProcessorTask(ShenandoahPhaseTimings::Phase phase, bool concurrent,\n+                                   ShenandoahRefProcThreadLocal* ref_proc_thread_locals, CallbackT callback) :\n+    WorkerTask(\"ShenandoahReferenceProcessorTask\"),\n+    _concurrent(concurrent),\n+    _phase(phase),\n+    _ref_proc_thread_locals(ref_proc_thread_locals),\n+    _callback(callback),\n+    _iterate_discovered_list_id(0) {\n+  }\n+\n+  virtual void work(uint worker_id) {\n+    if (_concurrent) {\n+      ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::WeakRefProc, worker_id, true);\n+      do_work();\n+    } else {\n+      ShenandoahParallelWorkerSession worker_session(worker_id);\n+      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::WeakRefProc, worker_id, true);\n+      do_work();\n+    }\n+  }\n+\n+  void do_work() {\n+    const uint max_workers = ShenandoahHeap::heap()->max_workers();\n+    uint worker_id = AtomicAccess::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n+    while (worker_id < max_workers) {\n+      ShenandoahRefProcThreadLocal& ref_proc_data = _ref_proc_thread_locals[worker_id];\n+      _callback(ref_proc_data, worker_id);\n+      worker_id = AtomicAccess::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n+    }\n+  }\n+};\n+\n@@ -207,4 +250,5 @@\n-    \/\/ Update our list with the forwarded object\n-    const oop reference = lrb(CompressedOops::decode(*list));\n-    if (CompressedOops::decode(*list) != reference) {\n-      RawAccess<IS_NOT_NULL>::oop_store(list, reference);\n+    const oop discovered_ref = CompressedOops::decode(*list);\n+    const oop reference = lrb(discovered_ref);\n+    if (discovered_ref != reference) {\n+      \/\/ Update our list with the forwarded object\n+      set_oop_field(list, reference);\n@@ -254,1 +298,0 @@\n-  _iterate_discovered_list_id(0U),\n@@ -286,8 +329,11 @@\n-void ShenandoahReferenceProcessor::heal_discovered_lists() const {\n-  for (uint i = 0; i < ShenandoahHeap::heap()->max_workers(); i++) {\n-    if (UseCompressedOops) {\n-      _ref_proc_thread_locals[i].heal_discovered_list<narrowOop>();\n-    } else {\n-      _ref_proc_thread_locals[i].heal_discovered_list<oop>();\n-    }\n-  }\n+void ShenandoahReferenceProcessor::heal_discovered_lists(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent) {\n+    ShenandoahReferenceProcessorTask heal_lists_task(phase, concurrent, _ref_proc_thread_locals,\n+[&](ShenandoahRefProcThreadLocal& ref_proc_data, uint worker_id) {\n+         if (UseCompressedOops) {\n+           ref_proc_data.heal_discovered_list<narrowOop>();\n+         } else {\n+           ref_proc_data.heal_discovered_list<oop>();\n+         }\n+       }\n+    );\n+  workers->run_task(&heal_lists_task);\n@@ -496,1 +542,1 @@\n-T* ShenandoahReferenceProcessor::keep(oop reference, ReferenceType type, uint worker_id) {\n+T* ShenandoahReferenceProcessor::keep(oop reference, ReferenceType type) {\n@@ -499,3 +545,0 @@\n-  \/\/ Update statistics\n-  _ref_proc_thread_locals[worker_id].inc_enqueued(type);\n-\n@@ -531,1 +574,5 @@\n-      p = keep<T>(reference, type, worker_id);\n+      \/\/ Update statistics\n+      refproc_data.inc_enqueued(type);\n+\n+      \/\/ Keep this reference on the list and make it inactive\n+      p = keep<T>(reference, type);\n@@ -559,27 +606,1 @@\n-void ShenandoahReferenceProcessor::work() {\n-  \/\/ Process discovered references\n-  uint max_workers = ShenandoahHeap::heap()->max_workers();\n-  uint worker_id = AtomicAccess::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n-  while (worker_id < max_workers) {\n-    if (UseCompressedOops) {\n-      process_references<narrowOop>(_ref_proc_thread_locals[worker_id], worker_id);\n-    } else {\n-      process_references<oop>(_ref_proc_thread_locals[worker_id], worker_id);\n-    }\n-    worker_id = AtomicAccess::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n-  }\n-}\n-\n-class ShenandoahReferenceProcessorTask : public WorkerTask {\n-private:\n-  bool const                          _concurrent;\n-  ShenandoahPhaseTimings::Phase const _phase;\n-  ShenandoahReferenceProcessor* const _reference_processor;\n-\n-public:\n-  ShenandoahReferenceProcessorTask(ShenandoahPhaseTimings::Phase phase, bool concurrent, ShenandoahReferenceProcessor* reference_processor) :\n-    WorkerTask(\"ShenandoahReferenceProcessorTask\"),\n-    _concurrent(concurrent),\n-    _phase(phase),\n-    _reference_processor(reference_processor) {\n-  }\n+void ShenandoahReferenceProcessor::process_references(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent) {\n@@ -587,5 +608,3 @@\n-  virtual void work(uint worker_id) {\n-    if (_concurrent) {\n-      ShenandoahConcurrentWorkerSession worker_session(worker_id);\n-      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::WeakRefProc, worker_id);\n-      _reference_processor->work();\n+  auto process_refs = [&](ShenandoahRefProcThreadLocal& ref_proc_data, uint worker_id) {\n+    if (UseCompressedOops) {\n+      process_references<narrowOop>(ref_proc_data, worker_id);\n@@ -593,3 +612,1 @@\n-      ShenandoahParallelWorkerSession worker_session(worker_id);\n-      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::WeakRefProc, worker_id);\n-      _reference_processor->work();\n+      process_references<oop>(ref_proc_data, worker_id);\n@@ -597,6 +614,1 @@\n-  }\n-};\n-\n-void ShenandoahReferenceProcessor::process_references(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent) {\n-\n-  AtomicAccess::release_store_fence(&_iterate_discovered_list_id, 0U);\n+  };\n@@ -605,1 +617,1 @@\n-  ShenandoahReferenceProcessorTask task(phase, concurrent, this);\n+  ShenandoahReferenceProcessorTask task(phase, concurrent, _ref_proc_thread_locals, process_refs);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":72,"deletions":60,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -142,2 +142,0 @@\n-  volatile uint _iterate_discovered_list_id;\n-\n@@ -169,1 +167,1 @@\n-  T* keep(oop reference, ReferenceType type, uint worker_id);\n+  T* keep(oop reference, ReferenceType type);\n@@ -220,1 +218,1 @@\n-  void heal_discovered_lists() const;\n+  void heal_discovered_lists(ShenandoahPhaseTimings::Phase phase, WorkerThreads* workers, bool concurrent);\n@@ -226,3 +224,1 @@\n-  const ReferenceProcessorStats& reference_process_stats() { return _stats; }\n-\n-  void work();\n+  const ReferenceProcessorStats& reference_process_stats() const { return _stats; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n@@ -42,6 +43,4 @@\n-  if (is_bootstrap_cycle() && in_progress && !heap->is_prepare_for_old_mark_in_progress()) {\n-    \/\/ This is not a bug. When the bootstrapping marking phase is complete,\n-    \/\/ the old generation marking is still in progress, unless it's not.\n-    \/\/ In the case that old-gen preparation for mixed evacuation has been\n-    \/\/ preempted, we do not want to set concurrent old mark to be in progress.\n-    heap->set_concurrent_old_mark_in_progress(in_progress);\n+  if (is_bootstrap_cycle() && in_progress) {\n+    \/\/ The start of concurrent mark for young is also the start of the concurrent mark for old\n+    assert(!heap->is_prepare_for_old_mark_in_progress(), \"Filling old regions must be complete before bootstrap\");\n+    heap->set_concurrent_old_mark_in_progress(true);\n@@ -51,0 +50,18 @@\n+\/\/ A bootstrap cycle will run as normal young cycle except that rather than\n+\/\/ ignore old references it will mark and enqueue them in the old concurrent\n+\/\/ task queues, but it will not traverse them. Similarly, we must configure\n+\/\/ the young ref processor to have the old ref processor discover old weak\n+\/\/ references.\n+void ShenandoahYoungGeneration::prepare_for_bootstrap(ShenandoahGeneration* generation) {\n+  assert(generation->is_old(), \"Need old generation to prepare for bootstrap\");\n+  ShenandoahReferenceProcessor* old_ref_processor = generation->ref_processor();\n+  _old_gen_task_queues = generation->task_queues();\n+  ref_processor()->set_old_generation_ref_processor(old_ref_processor);\n+  old_ref_processor->reset_thread_locals();\n+}\n+\n+void ShenandoahYoungGeneration::clear_bootstrap_configuration() {\n+  _old_gen_task_queues = nullptr;\n+  ref_processor()->clear_old_generation_ref_processor();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -63,3 +63,1 @@\n-  void set_old_gen_task_queues(ShenandoahObjToScanQueueSet* old_gen_queues) {\n-    _old_gen_task_queues = old_gen_queues;\n-  }\n+\n@@ -72,1 +70,1 @@\n-  bool is_bootstrap_cycle() {\n+  bool is_bootstrap_cycle() const {\n@@ -76,0 +74,6 @@\n+  \/\/ Take a reference to the old task queues and reference processor\n+  void prepare_for_bootstrap(ShenandoahGeneration* generation);\n+\n+  \/\/ Clear references to old gen marking\n+  void clear_bootstrap_configuration();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,1 +24,3 @@\n- *      -XX:ShenandoahLearningSteps=0 -ea\n+ *      -XX:ShenandoahLearningSteps=0 -XX:ShenandoahIgnoreOldGrowthBelowPercentage=100\n+ *      -XX:-UseCompressedOops\n+ *      -Xmx128M -Xms128M -ea\n@@ -41,2 +43,1 @@\n- *      -XX:ShenandoahLearningSteps=0\n- *      -XX:ShenandoahIgnoreGarbageThreshold=0 -XX:ShenandoahOldGarbageThreshold=0 -XX:ShenandoahGarbageThreshold=0\n+ *      -XX:ShenandoahLearningSteps=0 -XX:ShenandoahIgnoreOldGrowthBelowPercentage=100\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestGenerationalReferenceProcessing.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}