{"files":[{"patch":"@@ -47,0 +47,3 @@\n+  \/\/ Young collections can never unload classes\n+  bool can_unload_classes() override { return false; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -720,3 +720,2 @@\n-  if (_do_old_gc_bootstrap) {\n-    shenandoah_assert_generational();\n-    \/\/ Update region state for both young and old regions\n+  if (!_do_old_gc_bootstrap) {\n+    \/\/ Update region state for only young regions\n@@ -725,2 +724,1 @@\n-    heap->parallel_heap_region_iterate(&cl);\n-    heap->old_generation()->ref_processor()->reset_thread_locals();\n+    _generation->parallel_heap_region_iterate(&cl);\n@@ -728,1 +726,6 @@\n-    \/\/ Update region state for only young regions\n+    shenandoah_assert_generational();\n+    assert(_generation->is_young(), \"Expect young for bootstrap\");\n+    assert(_generation->ref_processor()->get_old_generation_ref_processor() == nullptr,\n+           \"Young ref processor should not have old ref processor here\");\n+\n+    \/\/ Update region state for both young and old regions\n@@ -731,1 +734,6 @@\n-    _generation->parallel_heap_region_iterate(&cl);\n+    heap->parallel_heap_region_iterate(&cl);\n+\n+    \/\/ Configure old ref processor for bootstrap and old marking\n+    ShenandoahReferenceProcessor* old_ref_processor = heap->old_generation()->ref_processor();\n+    old_ref_processor->reset_thread_locals();\n+    _generation->ref_processor()->set_old_generation_ref_processor(old_ref_processor);\n@@ -1122,1 +1130,1 @@\n-void ShenandoahConcurrentGC::op_update_refs() {\n+void ShenandoahConcurrentGC::op_update_refs() const {\n@@ -1124,0 +1132,6 @@\n+\n+  ShenandoahReferenceProcessor* old = _generation->ref_processor()->get_old_generation_ref_processor();\n+  if (old != nullptr) {\n+    assert(_generation->is_young(), \"Only young ref processor can have an old ref processor\");\n+    old->heal_discovered_lists();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  void op_update_refs();\n+  void op_update_refs() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n+  ShenandoahReferenceProcessor* ref_processor() const { return _ref_processor; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,4 +173,3 @@\n-  ShenandoahHeuristics* global_heuristics = _heap->global_generation()->heuristics();\n-  request.generation = _heap->global_generation();\n-  global_heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(request.cause));\n-  global_heuristics->record_requested_gc();\n+  ShenandoahHeuristics* heuristics = request.generation->heuristics();\n+  heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(request.cause));\n+  heuristics->record_requested_gc();\n@@ -179,6 +178,1 @@\n-    return stw_full;;\n-  } else {\n-    \/\/ Unload and clean up everything. Note that this is an _explicit_ request and so does not use\n-    \/\/ the same `should_unload_classes` call as the regulator's concurrent gc request.\n-    _heap->set_unload_classes(global_heuristics->can_unload_classes());\n-    return concurrent_normal;\n+    return stw_full;\n@@ -186,0 +180,5 @@\n+\n+  \/\/ Unload and clean up everything. Note that this is an _explicit_ request and so does not use\n+  \/\/ the same `should_unload_classes` call as the regulator's concurrent gc request.\n+  _heap->set_unload_classes(heuristics->can_unload_classes());\n+  return concurrent_normal;\n@@ -719,10 +718,1 @@\n-void ShenandoahGenerationalControlThread::handle_requested_gc(GCCause::Cause cause) {\n-  \/\/ For normal requested GCs (System.gc) we want to block the caller. However,\n-  \/\/ for whitebox requested GC, we want to initiate the GC and return immediately.\n-  \/\/ The whitebox caller thread will arrange for itself to wait until the GC notifies\n-  \/\/ it that has reached the requested breakpoint (phase in the GC).\n-  if (cause == GCCause::_wb_breakpoint) {\n-    notify_control_thread(cause, ShenandoahHeap::heap()->global_generation());\n-    return;\n-  }\n-\n+void ShenandoahGenerationalControlThread::wait_for_gc_cycle(GCCause::Cause cause, ShenandoahGeneration* generation) {\n@@ -743,1 +733,1 @@\n-    notify_control_thread(cause, ShenandoahHeap::heap()->global_generation());\n+    notify_control_thread(cause, generation);\n@@ -749,0 +739,15 @@\n+void ShenandoahGenerationalControlThread::handle_requested_gc(GCCause::Cause cause) {\n+  \/\/ For normal requested GCs (System.gc) we want to block the caller. However,\n+  \/\/ for whitebox requested GC, we want to initiate the GC and return immediately.\n+  \/\/ The whitebox caller thread will arrange for itself to wait until the GC notifies\n+  \/\/ it that has reached the requested breakpoint (phase in the GC).\n+  if (cause == GCCause::_wb_breakpoint) {\n+    notify_control_thread(cause, ShenandoahHeap::heap()->global_generation());\n+    return;\n+  }\n+  ShenandoahGeneration* generation = cause == GCCause::_wb_young_gc\n+                                   ? ShenandoahHeap::heap()->young_generation()\n+                                   : ShenandoahHeap::heap()->global_generation();\n+  wait_for_gc_cycle(cause, generation);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+  \/\/ Visible for white box API to start an old cycle\n+  void wait_for_gc_cycle(GCCause::Cause cause, ShenandoahGeneration* generation);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,0 +130,5 @@\n+bool ShenandoahGenerationalHeap::start_old_collection() {\n+  static_cast<ShenandoahGenerationalControlThread*>(_control_thread)->wait_for_gc_cycle(GCCause::_shenandoah_concurrent_gc, old_generation());\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+  bool start_old_collection();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,2 +61,6 @@\n-    \/\/ reference to the old concurrent mark so clean it up.\n-    heap->young_generation()->set_old_gen_task_queues(nullptr);\n+    \/\/ reference to the old concurrent mark so clean it up. It also no longer\n+    \/\/ needs a reference to the old generation ref processor.\n+    ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+    young_generation->set_old_gen_task_queues(nullptr);\n+    young_generation->ref_processor()->clear_old_generation_ref_processor();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -199,0 +199,23 @@\n+template <typename T>\n+void ShenandoahRefProcThreadLocal::heal_discovered_list() {\n+  if (_discovered_list == nullptr) {\n+    return;\n+  }\n+\n+  T* list = reinterpret_cast<T*>(&_discovered_list);\n+  while (list != nullptr) {\n+    \/\/ Update our list with the forwarded object\n+    const oop reference = lrb(CompressedOops::decode(*list));\n+    if (CompressedOops::decode(*list) != reference) {\n+      RawAccess<IS_NOT_NULL>::oop_store(list, reference);\n+    }\n+\n+    \/\/ Discovered list terminates with a self-loop\n+    const oop discovered = lrb(reference_discovered<T>(reference));\n+    if (reference == discovered) {\n+      break;\n+    }\n+    list = reference_discovered_addr<T>(reference);\n+  }\n+}\n+\n@@ -232,1 +255,2 @@\n-  _generation(generation) {\n+  _generation(generation),\n+  _old_generation_ref_processor(nullptr) {\n@@ -262,0 +286,11 @@\n+void ShenandoahReferenceProcessor::heal_discovered_lists() const {\n+  for (uint i = 0; i < ShenandoahHeap::heap()->max_workers(); i++) {\n+    if (UseCompressedOops) {\n+      _ref_proc_thread_locals[i].heal_discovered_list<narrowOop>();\n+    } else {\n+      _ref_proc_thread_locals[i].heal_discovered_list<oop>();\n+    }\n+  }\n+}\n+\n+\n@@ -297,1 +332,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -315,0 +349,6 @@\n+    if (_old_generation_ref_processor != nullptr) {\n+      log_trace(gc,ref)(\"Discovered reference for old: \" PTR_FORMAT, p2i(reference));\n+      _old_generation_ref_processor->discover_reference(reference, type);\n+      return true;\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -100,0 +100,3 @@\n+  template<typename T>\n+  void heal_discovered_list();\n+\n@@ -145,0 +148,2 @@\n+  ShenandoahReferenceProcessor* _old_generation_ref_processor;\n+\n@@ -184,0 +189,33 @@\n+  void set_old_generation_ref_processor(ShenandoahReferenceProcessor* ref_processor) {\n+    _old_generation_ref_processor = ref_processor;\n+  }\n+\n+  void clear_old_generation_ref_processor() {\n+    _old_generation_ref_processor = nullptr;\n+  }\n+\n+  ShenandoahReferenceProcessor* get_old_generation_ref_processor() const {\n+    return _old_generation_ref_processor;\n+  }\n+\n+  \/\/ The generational mode for Shenandoah will collect _referents_ for the generation\n+  \/\/ being collected. For example, if we have a young reference pointing to an old\n+  \/\/ referent, that young reference will be processed after we finish marking the old\n+  \/\/ generation. This presents a problem for discovery.\n+  \/\/\n+  \/\/ When the young mark _encounters_ a young reference with an old referent, it\n+  \/\/ cannot \"discover\" it because old marking hasn't finished. However, if it does not\n+  \/\/ discover it, the old referent will be strongly marked. This will prevent the\n+  \/\/ old generation from clearing the referent (if it even reaches it again during\n+  \/\/ old marking).\n+  \/\/\n+  \/\/ To solve this, we let young reference processing discover the old reference\n+  \/\/ by having it use the old generation reference processor to discover it. This means\n+  \/\/ the old reference processor can have a discovered list that contains young\n+  \/\/ weak references. If any of these young references reside in a region that is collected,\n+  \/\/ old reference processing will crash when it processes this young reference. Therefore,\n+  \/\/ we have this method to traverse the discovered lists after young evacuation is\n+  \/\/ complete. It will replace any forwarded entries in the discovered list with the\n+  \/\/ forwardee.\n+  void heal_discovered_lists() const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#endif \/\/ INCLUDE_SHENANDOAHGC\n@@ -693,0 +697,39 @@\n+#if INCLUDE_SHENANDOAHGC\n+WB_ENTRY(jint, WB_ShenandoahRegionSize(JNIEnv* env, jobject o))\n+  if (UseShenandoahGC) {\n+    return ShenandoahHeapRegion::region_size_bytes_jint();\n+  }\n+THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_ShenandoahRegionSize: Shenandoah GC is not enabled\");\n+WB_END\n+\n+WB_ENTRY(jint, WB_ShenandoahRegionCount(JNIEnv* env, jobject o))\n+  if (UseShenandoahGC) {\n+    return static_cast<jint>(ShenandoahHeap::heap()->num_regions());\n+  }\n+THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_ShenandoahRegionSize: Shenandoah GC is not enabled\");\n+WB_END\n+\n+WB_ENTRY(jint, WB_ShenandoahRegionIndex(JNIEnv* env, jobject o, jobject obj))\n+  if (UseShenandoahGC) {\n+    oop resolved = JNIHandles::resolve(obj);\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    if (heap->is_in(resolved)) {\n+      return static_cast<jint>(heap->heap_region_containing(resolved)->index());\n+    }\n+    return -1;\n+  }\n+THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_ShenandoahRegionSize: Shenandoah GC is not enabled\");\n+WB_END\n+\n+WB_ENTRY(jboolean, WB_ShenandoahOldGC(JNIEnv* env, jobject o))\n+  if (UseShenandoahGC) {\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      return ShenandoahGenerationalHeap::heap()->start_old_collection();\n+    }\n+    return false;\n+  }\n+THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_ShenandoahRegionSize: Shenandoah GC is not enabled\");\n+WB_END\n+\n+#endif\n+\n@@ -2861,0 +2904,8 @@\n+#if INCLUDE_SHENANDOAHGC\n+  {CC\"shenandoahRegionSize\",   CC\"()I\",                   (void*)&WB_ShenandoahRegionSize  },\n+  {CC\"shenandoahRegionCount\",  CC\"()I\",                   (void*)&WB_ShenandoahRegionCount },\n+  {CC\"shenandoahRegionIndex\",  CC\"(Ljava\/lang\/Object;)I\", (void*)&WB_ShenandoahRegionIndex },\n+  {CC\"shenandoahOldGC\",        CC\"()Z\",                   (void*)&WB_ShenandoahOldGC },\n+\n+#endif\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+package gc.shenandoah.generational;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.*;\n+import java.util.function.Supplier;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test id=young\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that young non-strong references are collected.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGenerationalMinTenuringAge=1 -XX:ShenandoahGenerationalMaxTenuringAge=1\n+ *      -XX:ShenandoahLearningSteps=0 -ea\n+ *      gc.shenandoah.generational.TestGenerationalReferenceProcessing young\n+ *\/\n+\n+\/*\n+ * @test id=old\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that young non-strong references are collected.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGenerationalMinTenuringAge=1 -XX:ShenandoahGenerationalMaxTenuringAge=1\n+ *      -XX:ShenandoahLearningSteps=0\n+ *      -XX:ShenandoahIgnoreGarbageThreshold=0 -XX:ShenandoahOldGarbageThreshold=0 -XX:ShenandoahGarbageThreshold=0\n+ *      -XX:-UseCompressedOops\n+ *      -Xmx128M -Xms128M -ea\n+ *      gc.shenandoah.generational.TestGenerationalReferenceProcessing old\n+ *\/\n+public class TestGenerationalReferenceProcessing {\n+    static final int OLD = 0;\n+    static final int YOUNG = 1;\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static class LeakedObject {}\n+\n+    private static final int REGION_SIZE = WB.shenandoahRegionSize();\n+    private static final int REGION_COUNT = WB.shenandoahRegionCount();\n+    private static final int OBJECT_SIZE = (int)WB.getObjectSize(new LeakedObject());\n+\n+    \/\/ We don't want to fill too much of the heap, or the heuristics will trigger GCs instead of our test\n+    private static final int REGIONS_TO_FILL = REGION_COUNT \/ 12;\n+    private static final int OBJECTS_PER_REGION = REGION_SIZE \/ OBJECT_SIZE \/ 2;\n+    private static final int OBJECT_COUNT = OBJECTS_PER_REGION * REGIONS_TO_FILL;\n+\n+    private static final List<WeakReference<?>> WEAK_REFS = new ArrayList<>(OBJECT_COUNT);\n+    private static final List<LeakedObject> REFERENTS = new ArrayList<>(OBJECT_COUNT);\n+    private static final ReferenceQueue<LeakedObject> refQueue = new ReferenceQueue<>();\n+\n+    private static final int MINIMUM_CROSS_GENERATIONAL_REFERENCE_COUNT = 50;\n+\n+    static class ReferenceClassifier {\n+        private final Object[][] references;\n+\n+        ReferenceClassifier() {\n+            references = new Object[][]{\n+                    {new HashSet<WeakReference<?>>(), new HashSet<WeakReference<?>>()},\n+                    {new HashSet<WeakReference<?>>(), new HashSet<WeakReference<?>>()}\n+            };\n+        }\n+\n+        void classify() {\n+            clear();\n+\n+            for (int j = 0; j < TestGenerationalReferenceProcessing.WEAK_REFS.size(); ++j) {\n+                var weakRef = TestGenerationalReferenceProcessing.WEAK_REFS.get(j);\n+                var referent = weakRef.get();\n+                if (referent != null) {\n+                    int row = WB.isObjectInOldGen(weakRef) ? OLD : YOUNG;\n+                    int column = WB.isObjectInOldGen(referent) ? OLD : YOUNG;\n+                    getReferences(row, column).add(weakRef);\n+                }\n+            }\n+        }\n+\n+        private void clear() {\n+            getReferences(OLD, OLD).clear();\n+            getReferences(OLD, YOUNG).clear();\n+            getReferences(YOUNG, OLD).clear();\n+            getReferences(YOUNG, YOUNG).clear();\n+        }\n+\n+        HashSet<WeakReference<?>> getReferences(int reference, int referent) {\n+            assert(reference == OLD || reference == YOUNG);\n+            assert(referent == OLD || referent == YOUNG);\n+            return (HashSet<WeakReference<?>>)references[reference][referent];\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"OO: %d, OY: %d, YO: %d, YY: %d\",\n+                    getReferences(OLD, OLD).size(), getReferences(OLD, YOUNG).size(),\n+                    getReferences(YOUNG, OLD).size(), getReferences(YOUNG, YOUNG).size());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            System.out.println(\"Call with generation to test: young|old\");\n+            return;\n+        }\n+\n+        if (\"young\".equals(args[0])) {\n+            testCollectCrossGenerationalReferents(OLD, YOUNG);\n+        } else if (\"old\".equals(args[0])) {\n+            testCollectCrossGenerationalReferents(YOUNG, OLD);\n+        }\n+    }\n+\n+    private static String name(int generation) {\n+        return generation == OLD ? \"old\" : \"young\";\n+    }\n+\n+    private static void testCollectCrossGenerationalReferents(int referenceGen, int referentGen) {\n+        ReferenceClassifier classifier = new ReferenceClassifier();\n+\n+        useMemoryUntil(() -> {\n+                classifier.classify();\n+                return classifier.getReferences(referenceGen, referentGen).size() > MINIMUM_CROSS_GENERATIONAL_REFERENCE_COUNT;\n+        });\n+\n+        assert !classifier.getReferences(referenceGen, referentGen).isEmpty() : \"Conditions for test not met: \" + classifier;\n+\n+        System.out.println(\"Before clearing all referents: \" + classifier);\n+        drainReferenceQueueAndClearReferents();\n+\n+        if (referentGen == YOUNG) {\n+            WB.youngGC();\n+        } else {\n+            \/\/ Print address of old references before old GC.\n+            var oldToOld = classifier.getReferences(referentGen, referentGen);\n+            printReferences(OLD, OLD, oldToOld);\n+            WB.shenandoahOldGC();\n+        }\n+\n+        int cleared = removeClearedWeakReferences();\n+        classifier.classify();\n+        System.out.println(\"After \" + name(referentGen) + \" GC, cleared: \" + cleared + \", referents: \" + classifier);\n+\n+        assertReferencesCleared(referentGen, referentGen, classifier);\n+        assertReferencesCleared(referenceGen, referentGen, classifier);\n+    }\n+\n+    private static void assertReferencesCleared(int referenceGen, int referentGen, ReferenceClassifier classifier) {\n+        var references = classifier.getReferences(referenceGen, referentGen);\n+        if (references.isEmpty()) {\n+            return;\n+        }\n+\n+        \/\/ Addresses here could be relocated and may not match logs from old gen collection\n+        printReferences(referenceGen, referentGen, references);\n+        throw new AssertionError(name(referenceGen) + \" to \" + name(referentGen) + \" referents should have been cleared\");\n+    }\n+\n+    private static void printReferences(int referenceGen, int referentGen, HashSet<WeakReference<?>> references) {\n+        final int max_references = 10;\n+        int references_shown = 0;\n+        for (var reference : references) {\n+            if (references_shown > max_references) {\n+                break;\n+            }\n+\n+            ++references_shown;\n+            System.out.printf(\"reference: 0x%x in %s refers to 0x%x in %s\\n\",\n+                    WB.getObjectAddress(reference), name(referenceGen),\n+                    WB.getObjectAddress(reference.get()), name(referentGen));\n+        }\n+    }\n+\n+    private static int removeClearedWeakReferences() {\n+        int cleared = 0;\n+        Reference<?> weak;\n+        while ((weak = refQueue.poll()) != null) {\n+            WEAK_REFS.remove(weak);\n+            ++cleared;\n+        }\n+        return cleared;\n+    }\n+\n+    private static void drainReferenceQueueAndClearReferents() {\n+        \/\/ Drain the reference queue of any incidental weak references from outside the test\n+        while (refQueue.poll() != null);\n+\n+        \/\/ Make all our referents unreachable now\n+        REFERENTS.clear();\n+    }\n+\n+    private static void useMemoryUntil(Supplier<Boolean> exitCondition) {\n+        \/\/ This is not an exact science here. We want to create weak references\n+        \/\/ with referents in a different region. We also don't want to allocate\n+        \/\/ everything up front, or else they will all end up in old together, and\n+        \/\/ we won't get a good mix of cross generational pointers.\n+        for (int i = 0; i < REGIONS_TO_FILL; i += 4) {\n+            allocateReferents(2);\n+            allocateReferences(2);\n+\n+            WB.youngGC();\n+            if (exitCondition.get()) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static void allocateReferents(int regions) {\n+        for (int j = 0; j < regions; j++) {\n+            for (int i = 0; i < OBJECTS_PER_REGION; ++i) {\n+                var leakedObject = new LeakedObject();\n+                REFERENTS.add(leakedObject);\n+                byte[] garbage = new byte[OBJECT_SIZE];\n+                garbage[i % garbage.length] = (byte) i;\n+            }\n+        }\n+    }\n+\n+    private static void allocateReferences(int regions) {\n+\n+        \/\/ Fill up regions that are equal parts garbage and references\n+        \/\/ We want to create cross region references to increase the chances\n+        \/\/ of cross generational references.\n+        int referentCount = REFERENTS.size() - 1;\n+        for (int j = 0; j < regions; j++) {\n+            for (int i = 0; i < OBJECTS_PER_REGION; ++i) {\n+                var leakedObject = REFERENTS.get(referentCount - i);\n+                var ref = new WeakReference<>(leakedObject, refQueue);\n+                WEAK_REFS.add(ref);\n+                byte[] garbage = new byte[OBJECT_SIZE];\n+                garbage[i % garbage.length] = (byte) i;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestGenerationalReferenceProcessing.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -312,0 +312,5 @@\n+  public native int shenandoahRegionSize();\n+  public native int shenandoahRegionCount();\n+  public native int shenandoahRegionIndex(Object o);\n+  public native boolean shenandoahOldGC();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}