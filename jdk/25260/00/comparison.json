{"files":[{"patch":"@@ -85,2 +85,1 @@\n-        POSIX_SPAWN,\n-        VFORK\n+        POSIX_SPAWN\n@@ -100,13 +99,9 @@\n-            \/\/ Should be value of a LaunchMechanism enum\n-            LaunchMechanism lm = LaunchMechanism.valueOf(s.toUpperCase(Locale.ROOT));\n-            switch (OperatingSystem.current()) {\n-                case LINUX:\n-                    return lm;      \/\/ All options are valid for Linux\n-                case AIX:\n-                case MACOS:\n-                    if (lm != LaunchMechanism.VFORK) {\n-                        return lm; \/\/ All but VFORK are valid\n-                    }\n-                    break;\n-                case WINDOWS:\n-                    \/\/ fall through to throw to Error\n+            \/\/ On Posix platforms, chose a launch mechanism (should be value of a LaunchMechanism enum)\n+            if (OperatingSystem.current() != OperatingSystem.WINDOWS) {\n+                String v = s.toUpperCase(Locale.ROOT);\n+                if (v.equals(\"VFORK\")) {\n+                    System.err.println(\"The VFORK launch mechanism has been removed; please either remove the \" +\n+                            \"jdk.lang.Process.launchMechanism property (preferred) or use \" +\n+                            \"-Djdk.lang.Process.launchMechanism=FORK instead.\");\n+                }\n+                return LaunchMechanism.valueOf(v);\n@@ -259,1 +254,0 @@\n-     *   3 - vfork(2) and exec(2)\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * There are three ways to fork off:\n+ * On the OS-side are four ways to fork off:\n@@ -77,14 +77,2 @@\n- *    the parent. Things that can go wrong include:\n- *    - Programming errors in the child process before the exec(2) call may\n- *      trash memory in the parent process, most commonly the stack of the\n- *      thread invoking vfork.\n- *    - Signals received by the child before the exec(2) call may be at best\n- *      misdirected to the parent, at worst immediately kill child and parent.\n- *\n- *    This is mitigated by very strict rules about what one is allowed to do in\n- *    the child process between vfork(2) and exec(2), which is basically nothing.\n- *    However, we always broke this rule by doing the pre-exec work between\n- *    vfork(2) and exec(2).\n- *\n- *    Also note that vfork(2) has been deprecated by the OpenGroup, presumably\n- *    because of its many dangers.\n+ *    the parent. This mode is inherently dangerous, and the danger partly outside\n+ *    the control of the programmer. Therefore we don't support vfork (anymore)\n@@ -96,9 +84,6 @@\n- * Aside from these three possibilities there is a forth option:  posix_spawn(3).\n- * Where fork\/vfork\/clone all fork off the process and leave pre-exec work and\n- * calling exec(2) to the user, posix_spawn(3) offers the user fork+exec-like\n- * functionality in one package, similar to CreateProcess() on Windows.\n- *\n- * It is not a system call in itself, but usually a wrapper implemented within\n- * the libc in terms of one of (fork|vfork|clone)+exec - so whether or not it\n- * has advantages over calling the naked (fork|vfork|clone) functions depends\n- * on how posix_spawn(3) is implemented.\n+ * D) posix_spawn(3): Where fork\/vfork\/clone all fork off the process and leave\n+ * pre-exec work and calling exec(2) to the user, posix_spawn(3) offers the user\n+ * fork+exec-like functionality in one package, similar to CreateProcess() on Windows.\n+ * It is not a system call, but usually a wrapper implemented within the libc in terms\n+ * of one of (fork|vfork|clone)+exec - so whether or not it has advantages over calling\n+ * the naked (fork|vfork|clone) functions depends on how posix_spawn(3) is implemented.\n@@ -489,22 +474,0 @@\n-\/* vfork(2) is deprecated on Darwin *\/\n-#ifndef __APPLE__\n-static pid_t\n-vforkChild(ChildStuff *c) {\n-    volatile pid_t resultPid;\n-\n-    \/*\n-     * We separate the call to vfork into a separate function to make\n-     * very sure to keep stack of child from corrupting stack of parent,\n-     * as suggested by the scary gcc warning:\n-     *  warning: variable 'foo' might be clobbered by 'longjmp' or 'vfork'\n-     *\/\n-    resultPid = vfork();\n-\n-    if (resultPid == 0) {\n-        childProcess(c);\n-    }\n-    assert(resultPid != 0);  \/* childProcess never returns *\/\n-    return resultPid;\n-}\n-#endif\n-\n@@ -655,5 +618,0 @@\n-\/* vfork(2) is deprecated on Darwin*\/\n-      #ifndef __APPLE__\n-      case MODE_VFORK:\n-        return vforkChild(c);\n-      #endif\n@@ -768,3 +726,0 @@\n-          case MODE_VFORK:\n-            throwInternalIOException(env, errno, \"vfork failed\", c->mode);\n-            break;\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":9,"deletions":54,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -207,25 +207,0 @@\n-\/**\n- * Exec FILE as a traditional Bourne shell script (i.e. one without #!).\n- * If we could do it over again, we would probably not support such an ancient\n- * misfeature, but compatibility wins over sanity.  The original support for\n- * this was imported accidentally from execvp().\n- *\/\n-static void\n-execve_as_traditional_shell_script(const char *file,\n-                                   const char *argv[],\n-                                   const char *const envp[])\n-{\n-    \/* Use the extra word of space provided for us in argv by caller. *\/\n-    const char *argv0 = argv[0];\n-    const char *const *end = argv;\n-    while (*end != NULL)\n-        ++end;\n-    memmove(argv+2, argv+1, (end-argv) * sizeof(*end));\n-    argv[0] = \"\/bin\/sh\";\n-    argv[1] = file;\n-    execve(argv[0], (char **) argv, (char **) envp);\n-    \/* Can't even exec \/bin\/sh?  Big trouble, but let's soldier on... *\/\n-    memmove(argv+1, argv+2, (end-argv) * sizeof(*end));\n-    argv[0] = argv0;\n-}\n-\n@@ -241,10 +216,3 @@\n-    if (mode == MODE_VFORK) {\n-        \/* shared address space; be very careful. *\/\n-        execve(file, (char **) argv, (char **) envp);\n-        if (errno == ENOEXEC)\n-            execve_as_traditional_shell_script(file, argv, envp);\n-    } else {\n-        \/* unshared address space; we can mutate environ. *\/\n-        environ = (char **) envp;\n-        execvp(file, (char **) argv);\n-    }\n+    \/* unshared address space; we can mutate environ. *\/\n+    environ = (char **) envp;\n+    execvp(file, (char **) argv);\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-#define MODE_VFORK 3\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}