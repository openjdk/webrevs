{"files":[{"patch":"@@ -1838,0 +1838,1 @@\n+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n@@ -1840,0 +1841,1 @@\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5325,0 +5325,279 @@\n+  \/**\n+   * vector registers:\n+   * input VectorRegister's:  intputV1-V4, for m2 they could be v2, v4, v6, for m1 they could be v2, v4, v6, v8\n+   * index VectorRegister's:  idxV1-V3, for m2 they could be v8, v10, v12, v14, for m1 they could be v10, v12, v14, v16\n+   * output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v18, v20, v22\n+   *\n+   * NOTE: each field will occupy a single vector register group\n+   *\/\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ decoding\n+    \/\/   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    \/\/   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    \/\/   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   * int j.u.Base64.Decoder.decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *  c_rarg6   - isMIME, Decoding MIME block - unused here\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    static const uint8_t fromBase64[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URL[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+    Register isMIME = c_rarg6;\n+\n+    Register codec     = c_rarg7;\n+    Register dstBackup = x31;\n+    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+    Label ProcessScalar, ProcessVector;\n+\n+    \/\/ intrinsic only processes data of length in multiple of 4\n+    __ sub(length, send, soff);\n+    \/\/ it's not guaranteed by java level, so do it explicitly\n+    __ andi(length, length, -4);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    \/\/ backup of dst, used to calculate the return value at exit\n+    __ mv(dstBackup, dst);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) fromBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) fromBase64URL));\n+    __ BIND(ProcessData);\n+\n+\n+    \/\/ scalar version\n+    {\n+      Label ScalarLoop;\n+\n+      Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n+      Register combined32Bits = x29; \/\/ t5\n+\n+      if (UseRVV) {\n+        __ bnez(isMIME, ScalarLoop);\n+        __ mv(t0, MaxVectorSize * 4);\n+        __ bge(length, t0, ProcessVector);\n+        __ BIND(ProcessScalar);\n+        __ beqz(length, Exit);\n+      }\n+\n+      __ BIND(ScalarLoop);\n+      {\n+        \/\/ encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n+        \/\/ plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n+\n+        \/\/ load 4 bytes encoded src data\n+        __ lbu(byte0, Address(src, 0));\n+        __ lbu(byte1, Address(src, 1));\n+        __ lbu(byte2, Address(src, 2));\n+        __ lbu(byte3, Address(src, 3));\n+        __ addi(src, src, 4);\n+\n+        \/\/ get codec index and decode (ie. load from codec by index)\n+        __ add(byte0, codec, byte0);\n+        __ add(byte1, codec, byte1);\n+        __ lb(byte0, Address(byte0, 0));\n+        __ lb(byte1, Address(byte1, 0));\n+        __ add(byte2, codec, byte2);\n+        __ add(byte3, codec, byte3);\n+        __ lb(byte2, Address(byte2, 0));\n+        __ lb(byte3, Address(byte3, 0));\n+        __ slliw(byte0, byte0, 18);\n+        __ slliw(byte1, byte1, 12);\n+        __ orr(byte0, byte0, byte1);\n+        __ orr(byte0, byte0, byte3);\n+        __ slliw(byte2, byte2, 6);\n+        __ orr(combined32Bits, byte0, byte2);\n+\n+        \/\/ error check\n+        __ bltz(combined32Bits, Exit);\n+\n+        \/\/ store 3 bytes decoded data\n+        __ sraiw(byte0, combined32Bits, 16);\n+        __ sraiw(byte1, combined32Bits, 8);\n+        __ sb(byte0, Address(dst, 0));\n+        __ sb(byte1, Address(dst, 1));\n+        __ sb(combined32Bits, Address(dst, 2));\n+\n+        __ sub(length, length, 4);\n+        __ addi(dst, dst, 3);\n+        \/\/ loop back\n+        __ bnez(length, ScalarLoop);\n+\n+        __ j(Exit);\n+      }\n+    }\n+\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      __ BIND(ProcessVector);\n+\n+      Label ProcessM1, ProcessM2;\n+\n+      Register failedIdx = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+      Register size      = x29;   \/\/ t4\n+      Register minusOne  = x30;   \/\/ t5\n+\n+      __ mv(minusOne, -1);\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 4);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 3);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM2);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst, failedIdx, minusOne,\n+                    v2, v4, v6, v8,      \/\/ inputs\n+                    v10, v12, v14, v16,  \/\/ indexes\n+                    v18, v20, v22,       \/\/ outputs\n+                    Assembler::m2);\n+      __ sub(length, length, stepSrcM2);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst, failedIdx, minusOne,\n+                    v1, v2, v3, v4,      \/\/ inputs\n+                    v5, v6, v7, v8,      \/\/ indexes\n+                    v9, v10, v11,        \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      \/\/ error check\n+      __ beq(failedIdx, minusOne, ProcessScalar);\n+    }\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, dstBackup);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5983,0 +6262,1 @@\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":280,"deletions":0,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}