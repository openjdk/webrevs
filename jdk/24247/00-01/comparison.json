{"files":[{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/ci\/ciUtilities.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"compiler\/compiler_globals.hpp\"\n@@ -30,0 +29,2 @@\n+\n+#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,10 @@\n+    \/\/\/ Gets the first substring in `s` enclosed by `start` and `end`.\n+    private static String extract(String s, char start, char end) {\n+        int startIndex = s.indexOf(start);\n+        int endIndex = s.indexOf(end, startIndex + 1);\n+        if (startIndex == -1 || endIndex == -1) {\n+            throw new IllegalArgumentException(s);\n+        }\n+        return s.substring(startIndex + 1, endIndex);\n+    }\n+\n@@ -53,0 +63,1 @@\n+    \/\/\/ @param path path of source file containing `block`\n@@ -56,1 +67,1 @@\n-    private static String sortedIncludes(String block) {\n+    private static String sortedIncludes(Path path, String block) {\n@@ -60,1 +71,0 @@\n-        List<String> blankLines = new ArrayList<>();\n@@ -62,1 +72,15 @@\n-        \/\/ Partition lines into user include, sys includes and blank lines\n+        \/\/ From the style guide:\n+        \/\/\n+        \/\/ All .inline.hpp files should include their corresponding .hpp file\n+        \/\/ as the first include line with a blank line separating it from the\n+        \/\/ rest of the include lines. Declarations needed by other files should\n+        \/\/ be put in the .hpp file, and not in the .inline.hpp file. This rule\n+        \/\/ exists to resolve problems with circular dependencies between\n+        \/\/ .inline.hpp files.\n+        String pathString = path.toString();\n+        boolean isInlineHpp = pathString.endsWith(\".inline.hpp\");\n+        String nonInlineHpp = pathString.replace(\".inline.hpp\", \".hpp\");\n+\n+        List<String> result = new ArrayList<>(lines.length);\n+\n+        \/\/ Partition lines into user include and sys includes and discard blank lines\n@@ -64,0 +88,1 @@\n+            int doubleQuote = line.indexOf('\"');\n@@ -65,1 +90,5 @@\n-                userIncludes.add(line);\n+                if (isInlineHpp && nonInlineHpp.endsWith(extract(line, '\"', '\"'))) {\n+                    result.add(line);\n+                } else {\n+                    userIncludes.add(line);\n+                }\n@@ -68,2 +97,0 @@\n-            } else if (line.isEmpty()) {\n-                blankLines.add(line);\n@@ -73,3 +100,9 @@\n-        List<String> result = new ArrayList<>(userIncludes);\n-        if (!userIncludes.isEmpty() && !sysIncludes.isEmpty() && blankLines.isEmpty()) {\n-            blankLines = List.of(\"\");\n+        if (!result.isEmpty() && (!userIncludes.isEmpty() || !sysIncludes.isEmpty())) {\n+            \/\/ Insert blank line between include of .hpp from .inline.hpp\n+            \/\/ and the rest of the includes\n+            result.add(\"\");\n+        }\n+        result.addAll(userIncludes);\n+        if (!userIncludes.isEmpty() && !sysIncludes.isEmpty()) {\n+            \/\/ Insert blank line between user and sys includes\n+            result.add(\"\");\n@@ -77,1 +110,0 @@\n-        result.addAll(blankLines);\n@@ -98,1 +130,1 @@\n-            buf.append(sortedIncludes(matcher.group()));\n+            buf.append(sortedIncludes(path, matcher.group()));\n","filename":"test\/hotspot\/jtreg\/sources\/SortIncludes.java","additions":43,"deletions":11,"binary":false,"changes":54,"status":"modified"}]}