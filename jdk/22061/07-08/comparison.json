{"files":[{"patch":"@@ -26,0 +26,3 @@\n+\n+import java.util.Random;\n+\n@@ -36,0 +39,2 @@\n+    public static final int RANDOM_POWER_OF_2 = 1 << (1 + new Random().nextInt(30));\n+\n@@ -37,1 +42,1 @@\n-        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=inline,*Math::max\");\n@@ -40,1 +45,2 @@\n-    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Minus1\"})\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Random\", \"powerOf2Minus1\", \n+                 \"positivePowerOf2\", \"positivePowerOf2Random\"})\n@@ -65,1 +71,4 @@\n-        Asserts.assertEQ(Math.max(0, a) % 32, powerOf2(a));\n+        Asserts.assertEQ(a % 32, powerOf2(a));\n+        Asserts.assertEQ(a % RANDOM_POWER_OF_2, powerOf2Random(a));\n+        Asserts.assertEQ(Math.max(0, a) % 32, positivePowerOf2(a));\n+        Asserts.assertEQ(Math.max(0, a) % RANDOM_POWER_OF_2, positivePowerOf2Random(a));\n@@ -86,1 +95,1 @@\n-    @IR(failOn = {IRNode.MOD_I, IRNode.RSHIFT, IRNode.ADD})\n+    @IR(failOn = {IRNode.MOD_I, IRNode.RSHIFT, IRNode.ADD, IRNode.SUB})\n@@ -88,2 +97,1 @@\n-    \/\/ If the dividend is positive, and divisor is of the form 2^k, we can use a simple bit mask.\n-    public int powerOf2(int x) {\n+    public int positivePowerOf2(int x) {\n@@ -93,0 +101,21 @@\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.RSHIFT, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int positivePowerOf2Random(int x) {\n+        return Math.max(0, x) % RANDOM_POWER_OF_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int powerOf2(int x) {\n+        return x % 32;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int powerOf2Random(int x) {\n+        return x % RANDOM_POWER_OF_2;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModINodeIdealizationTests.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+\n+import java.util.Random;\n+\n@@ -36,0 +39,2 @@\n+    public static final long RANDOM_POWER_OF_2 = 1L << (1 + new Random().nextInt(62));\n+\n@@ -40,1 +45,1 @@\n-    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Minus1\"})\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Random\", \"powerOf2Minus1\"})\n@@ -65,1 +70,1 @@\n-        Asserts.assertEQ(Math.max(0, a) % 8589934592L, powerOf2(a));\n+        Asserts.assertEQ(a % 8589934592L, powerOf2(a));\n@@ -86,1 +91,1 @@\n-    @IR(failOn = {IRNode.MOD_L, IRNode.RSHIFT, IRNode.ADD})\n+    @IR(failOn = {IRNode.MOD_L, IRNode.DIV})\n@@ -90,1 +95,9 @@\n-        return Math.max(0, x) % 8589934592L;\n+        return x % 8589934592L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_L, \"1\"})\n+    \/\/ If the dividend is positive, and divisor is of the form 2^k, we can use a simple bit mask.\n+    public long powerOf2Random(long x) {\n+        return x % RANDOM_POWER_OF_2;\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModLNodeIdealizationTests.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+\n+import java.util.Random;\n+\n@@ -36,0 +39,2 @@\n+    public static final int RANDOM_POWER_OF_2 = 1 << (1 + new Random().nextInt(30));\n+\n@@ -41,1 +46,1 @@\n-            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\" })\n+            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\", \"divByPow2Random\" })\n@@ -142,0 +147,7 @@\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public int divByPow2Random(int x) {\n+        return Integer.divideUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+\n+import java.util.Random;\n+\n@@ -36,0 +39,2 @@\n+    public static final long RANDOM_POWER_OF_2 = 1 << (1 + new Random().nextInt(62));\n+\n@@ -41,1 +46,1 @@\n-            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\"})\n+            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\", \"divByPow2Random\"})\n@@ -142,0 +147,7 @@\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public long divByPow2Random(long x) {\n+        return Long.divideUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+\n+import java.util.Random;\n+\n@@ -36,0 +39,2 @@\n+    public static final int RANDOM_POWER_OF_2 = 1 << (1 + new Random().nextInt(30));\n+    \n@@ -40,1 +45,1 @@\n-    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"reallyConstant\"})\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"powerOf2Random\", \"reallyConstant\"})\n@@ -100,0 +105,8 @@\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public int powerOf2Random(int x) {\n+        return Integer.remainderUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UModINodeIdealizationTests.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+\n+import java.util.Random;\n+\n@@ -36,0 +39,2 @@\n+    public static final long RANDOM_POWER_OF_2 = 1 << (1 + new Random().nextInt(62));\n+\n@@ -40,1 +45,1 @@\n-    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"reallyConstant\"})\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"powerOf2Random\", \"reallyConstant\"})\n@@ -100,0 +105,8 @@\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public long powerOf2Random(long x) {\n+        return Long.remainderUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UModLNodeIdealizationTests.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}