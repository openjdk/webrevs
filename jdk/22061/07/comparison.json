{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,0 +450,67 @@\n+template <typename TypeClass>\n+Node* make_and(Node* a, Node* b);\n+\n+template <>\n+Node* make_and<TypeLong>(Node* a, Node* b) {\n+  return new AndLNode(a, b);\n+}\n+\n+template <>\n+Node* make_and<TypeInt>(Node* a, Node* b) {\n+  return new AndINode(a, b);\n+}\n+\n+template <typename TypeClass>\n+Node* make_urshift(Node* a, Node* b);\n+\n+template <>\n+Node* make_urshift<TypeLong>(Node* a, Node* b) {\n+  return new URShiftLNode(a, b);\n+}\n+\n+template <>\n+Node* make_urshift<TypeInt>(Node* a, Node* b) {\n+  return new URShiftINode(a, b);\n+}\n+\n+template <typename TypeClass, typename Unsigned>\n+Node* unsigned_div_ideal(PhaseGVN* phase, bool can_reshape, Node* div) {\n+  \/\/ Check for dead control input\n+  if (div->in(0) && div->remove_dead_region(phase, can_reshape)) {\n+    return div;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if (div->in(0) && div->in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  const Type* t = phase->type(div->in(2));\n+  const TypeClass* tl = t->cast<TypeClass>();\n+  if (!tl) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (div->in(0) && (tl->_hi < 0 || tl->_lo > 0)) {\n+    div->set_req(0, nullptr); \/\/ Yank control input\n+    return div;\n+  }\n+\n+  if (!tl->is_con()) {\n+    return nullptr;\n+  }\n+  Unsigned l = static_cast<Unsigned>(tl->get_con()); \/\/ Get divisor\n+\n+  if (l == 0 || l == 1) {\n+    return nullptr; \/\/ Dividing by zero constant does not idealize\n+  }\n+\n+  if (is_power_of_2(l)) {\n+    return make_urshift<TypeClass>(div->in(1), phase->intcon(log2i_graceful(l)));\n+  }\n+\n+  return nullptr;\n+}\n+\n+\n@@ -876,3 +943,1 @@\n-  \/\/ Check for dead control input\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n+  return unsigned_div_ideal<TypeInt, juint>(phase, can_reshape, this);\n@@ -881,1 +946,0 @@\n-\n@@ -915,3 +979,1 @@\n-  \/\/ Check for dead control input\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n+  return unsigned_div_ideal<TypeLong, julong>(phase, can_reshape, this);\n@@ -920,1 +982,0 @@\n-\n@@ -1087,1 +1148,3 @@\n-Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+\n+template <typename TypeClass, typename Unsigned>\n+static Node* unsigned_mod_ideal(PhaseGVN* phase, bool can_reshape, Node* mod) {\n@@ -1089,1 +1152,35 @@\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  if (mod->in(0) && mod->remove_dead_region(phase, can_reshape)) {\n+    return mod;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if (mod->in(0) && mod->in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Get the modulus\n+  const Type* t = phase->type(mod->in(2));\n+  if (t == Type::TOP) {\n+    return nullptr;\n+  }\n+  const TypeClass* ti = t->cast<TypeClass>();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding mod-zero case\n+  if (mod->in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    mod->set_req(0, nullptr); \/\/ Yank control input\n+    return mod;\n+  }\n+\n+  if (!ti->is_con()) {\n+    return nullptr;\n+  }\n+  Unsigned con = static_cast<Unsigned>(ti->get_con());\n+\n+  if (con == 0) {\n+    return nullptr;\n+  }\n+\n+  if (is_power_of_2(con)) {\n+    return make_and<TypeClass>(mod->in(1), phase->makecon(TypeClass::make(con - 1)));\n+  }\n+\n@@ -1093,0 +1190,50 @@\n+template <typename TypeClass, typename Unsigned, typename Signed>\n+static const Type* unsigned_mod_value(PhaseGVN* phase, const Node* mod) {\n+  const Type* t1 = phase->type(mod->in(1));\n+  const Type* t2 = phase->type(mod->in(2));\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ 0 MOD X is 0\n+  if (t1 == TypeClass::ZERO) {\n+    return TypeClass::ZERO;\n+  }\n+  \/\/ X MOD X is 0\n+  if (mod->in(1) == mod->in(2)) {\n+    return TypeClass::ZERO;\n+  }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type* bot = mod->bottom_type();\n+  if ((t1 == bot) || (t2 == bot) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM)) {\n+    return bot;\n+  }\n+\n+  const TypeClass* i2 = t2->cast<TypeClass>();\n+  if (i2->is_con() && i2->get_con() == 1) {\n+    return TypeClass::ZERO;\n+  }\n+\n+  const TypeClass* i1 = t1->cast<TypeClass>();\n+  if (i1->is_con() && i2->is_con()) {\n+    Unsigned au = static_cast<Unsigned>(i1->get_con());\n+    Unsigned bu = static_cast<Unsigned>(i2->get_con());\n+    return TypeClass::make(static_cast<Signed>(au % bu));\n+  }\n+\n+  return bot;\n+}\n+\n+Node* UModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return unsigned_mod_ideal<TypeInt, juint>(phase, can_reshape, this);\n+}\n+\n+const Type* UModINode::Value(PhaseGVN* phase) const {\n+  return unsigned_mod_value<TypeInt, juint, jint>(phase, this);\n+}\n+\n@@ -1306,3 +1453,1 @@\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n+  return unsigned_mod_ideal<TypeLong, julong>(phase, can_reshape, this);\n@@ -1311,0 +1456,3 @@\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  return unsigned_mod_value<TypeLong, julong, jlong>(phase, this);\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":162,"deletions":14,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -185,0 +186,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1129,1 +1129,0 @@\n-protected:\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -317,0 +317,3 @@\n+  template <typename TypeClass>\n+  const TypeClass* cast() const;\n+\n@@ -2169,0 +2172,9 @@\n+template <>\n+inline const TypeInt* Type::cast<TypeInt>() const {\n+  return is_int();\n+}\n+\n+template <>\n+inline const TypeLong* Type::cast<TypeLong>() const {\n+  return is_long();\n+}\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of ModINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ModINodeIdealizationTests\n+ *\/\n+public class ModINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Minus1\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 2 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 2 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a % a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Math.max(0, a) % 32, powerOf2(a));\n+        Asserts.assertEQ(a % 127, powerOf2Minus1(a));\n+        Asserts.assertEQ(a % 1, constantAgain(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constant(int x) {\n+        return x % x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantAgain(int x) {\n+        return x % 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.RSHIFT, IRNode.ADD})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    \/\/ If the dividend is positive, and divisor is of the form 2^k, we can use a simple bit mask.\n+    public int powerOf2(int x) {\n+        return Math.max(0, x) % 32;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I})\n+    @IR(counts = {IRNode.AND_I, \">=1\", IRNode.RSHIFT, \">=1\", IRNode.CMP_I, \"2\"})\n+    \/\/ Special optimization for the case 2^k-1 for bigger k\n+    public int powerOf2Minus1(int x) {\n+        return x % 127;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModINodeIdealizationTests.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of ModLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ModLNodeIdealizationTests\n+ *\/\n+public class ModLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Minus1\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        a = (a == 0) ? 2 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+        b = (b == 0) ? 2 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a % a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Math.max(0, a) % 8589934592L, powerOf2(a));\n+        Asserts.assertEQ(a % 8589934591L, powerOf2Minus1(a));\n+        Asserts.assertEQ(a % 1, constantAgain(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constant(long x) {\n+        return x % x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantAgain(long x) {\n+        return x % 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.RSHIFT, IRNode.ADD})\n+    @IR(counts = {IRNode.AND_L, \"1\"})\n+    \/\/ If the dividend is positive, and divisor is of the form 2^k, we can use a simple bit mask.\n+    public long powerOf2(long x) {\n+        return Math.max(0, x) % 8589934592L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L})\n+    @IR(counts = {IRNode.AND_L, \">=1\", IRNode.RSHIFT, \">=1\", IRNode.CMP_L, \"2\"})\n+    \/\/ Special optimization for the case 2^k-1 for bigger k\n+    public long powerOf2Minus1(long x) {\n+        return x % 8589934591L;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModLNodeIdealizationTests.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UDivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivINodeIdealizationTests\n+ *\/\n+public class UDivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityAgainButBig\", \"identityThird\",\n+            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\" })\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Integer.divideUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Integer.divideUnsigned(a, Integer.divideUnsigned(b, b)), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Integer.divideUnsigned((a * b), b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Integer.divideUnsigned(a, 1), identity(a));\n+        Asserts.assertEQ(Integer.divideUnsigned(a, Integer.divideUnsigned(13, 13)), identityAgain(a));\n+        Asserts.assertEQ(Integer.divideUnsigned(a, 8), divByPow2(a), \"divByPow2 \" + a);\n+        Asserts.assertEQ(Integer.divideUnsigned(a, -2147483648), divByPow2Big(a));\n+        Asserts.assertEQ(Integer.divideUnsigned(a, Integer.divideUnsigned(-2129457054, -2129457054)), identityAgainButBig(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return Integer.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return Integer.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgainButBig(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(-2129457054, -2129457054));  \/\/ Integer.parseUnsignedInt(\"2165510242\") = -2129457054\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+            IRNode.UDIV_I, \"1\",\n+            IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+    })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return Integer.divideUnsigned((x * y), y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    \/\/ Dividing an unsigned number by 8 is a trivial right shift by 3\n+    public int divByPow2(int x) {\n+        return Integer.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public int divByPow2Big(int x) {\n+        return Integer.divideUnsigned(x, -2147483648);  \/\/ -2147483648 = Integer.parseUnsignedInt(\"2147483648\")\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UDivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivLNodeIdealizationTests\n+ *\/\n+public class UDivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityAgainButBig\", \"identityThird\",\n+            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+        b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Long.divideUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Long.divideUnsigned((a * b), b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Long.divideUnsigned(a, Long.divideUnsigned(b, b)), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Long.divideUnsigned(a, 1), identity(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, Long.divideUnsigned(13, 13)), identityAgain(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, 8), divByPow2(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, -9223372036854775808L), divByPow2Big(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, Long.divideUnsigned(-9214294468834361176L, -9214294468834361176L)), identityAgainButBig(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return Long.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return Long.divideUnsigned(x, 1L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(13L, 13L));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgainButBig(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(-9214294468834361176L, -9214294468834361176L));  \/\/ Long.parseUnsignedLong(\"9232449604875190440\") = -9214294468834361176L\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+            IRNode.UDIV_L, \"1\",\n+            IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+    })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return Long.divideUnsigned((x * y), y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    \/\/ Dividing an unsigned number by 8 is a trivial right shift by 3\n+    public long divByPow2(long x) {\n+        return Long.divideUnsigned(x, 8L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public long divByPow2Big(long x) {\n+        return Long.divideUnsigned(x, -9223372036854775808L);  \/\/ -9223372036837998592 = Long.parseUnsignedLong(\"9223372036854775808\")\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UModINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UModINodeIdealizationTests\n+ *\/\n+public class UModINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"reallyConstant\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 2 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 2 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Integer.remainderUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Integer.remainderUnsigned(a, 1), constantAgain(a));\n+        Asserts.assertEQ(Integer.remainderUnsigned(a, 32), powerOf2(a));\n+        Asserts.assertEQ(Integer.remainderUnsigned(Integer.parseUnsignedInt(\"2147483648\"), 302032), reallyConstant());\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constant(int x) {\n+        return Integer.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantAgain(int x) {\n+        return Integer.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    \/\/ Checks that modulo with two constants is calculated at compile time\n+    public int reallyConstant() {\n+        return Integer.remainderUnsigned(-2147483648, 302032); \/\/ -2147483648 = Integer.parseUnsignedInt(\"2147483648\")\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public int powerOf2(int x) {\n+        return Integer.remainderUnsigned(x, 32);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public int powerOf2Big(int x) {\n+        return Integer.remainderUnsigned(x, -2147483648); \/\/ -2147483648 = Integer.parseUnsignedInt(\"2147483648\")\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UModINodeIdealizationTests.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UModLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UModLNodeIdealizationTests\n+ *\/\n+public class UModLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"reallyConstant\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 2 : a;\n+        long b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 2 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Long.remainderUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Long.remainderUnsigned(a, 1), constantAgain(a));\n+        Asserts.assertEQ(Long.remainderUnsigned(a, 8589934592L), powerOf2(a));\n+        Asserts.assertEQ(Long.remainderUnsigned(Long.parseUnsignedLong(\"9223372036854775808\"), 302032), reallyConstant());\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constant(long x) {\n+        return Long.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantAgain(long x) {\n+        return Long.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    \/\/ Checks that modulo with two constants is calculated at compile time\n+    public long reallyConstant() {\n+        return Long.remainderUnsigned(-9223372036854775808L, 302032); \/\/ -9223372036854775808 =  Long.parseUnsignedLong(\"9223372036854775808\")\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public long powerOf2(long x) {\n+        return Long.remainderUnsigned(x, 8589934592L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public long powerOf2Big(long x) {\n+        return Long.remainderUnsigned(x, -9223372036854775808L); \/\/ -9223372036854775808 =  Long.parseUnsignedLong(\"9223372036854775808\")\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UModLNodeIdealizationTests.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}