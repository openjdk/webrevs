{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,0 +450,41 @@\n+template <typename TypeClass, typename Unsigned>\n+Node* unsigned_div_ideal(PhaseGVN* phase, bool can_reshape, Node* div) {\n+  \/\/ Check for dead control input\n+  if (div->in(0) != nullptr && div->remove_dead_region(phase, can_reshape)) {\n+    return div;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if (div->in(0) != nullptr && div->in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  const Type* t = phase->type(div->in(2));\n+  if (t == Type::TOP) {\n+    return nullptr;\n+  }\n+  const TypeClass* type_divisor = t->cast<TypeClass>();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (div->in(0) != nullptr && (type_divisor->_hi < 0 || type_divisor->_lo > 0)) {\n+    div->set_req(0, nullptr); \/\/ Yank control input\n+    return div;\n+  }\n+\n+  if (!type_divisor->is_con()) {\n+    return nullptr;\n+  }\n+  Unsigned divisor = static_cast<Unsigned>(type_divisor->get_con()); \/\/ Get divisor\n+\n+  if (divisor == 0 || divisor == 1) {\n+    return nullptr; \/\/ Dividing by zero constant does not idealize\n+  }\n+\n+  if (is_power_of_2(divisor)) {\n+    return make_urshift<TypeClass>(div->in(1), phase->intcon(log2i_graceful(divisor)));\n+  }\n+\n+  return nullptr;\n+}\n+\n+\n@@ -876,3 +917,1 @@\n-  \/\/ Check for dead control input\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n+  return unsigned_div_ideal<TypeInt, juint>(phase, can_reshape, this);\n@@ -881,1 +920,0 @@\n-\n@@ -915,3 +953,1 @@\n-  \/\/ Check for dead control input\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n+  return unsigned_div_ideal<TypeLong, julong>(phase, can_reshape, this);\n@@ -920,1 +956,0 @@\n-\n@@ -1087,1 +1122,3 @@\n-Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+\n+template <typename TypeClass, typename Unsigned>\n+static Node* unsigned_mod_ideal(PhaseGVN* phase, bool can_reshape, Node* mod) {\n@@ -1089,1 +1126,35 @@\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  if (mod->in(0) != nullptr && mod->remove_dead_region(phase, can_reshape)) {\n+    return mod;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if (mod->in(0) != nullptr && mod->in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Get the modulus\n+  const Type* t = phase->type(mod->in(2));\n+  if (t == Type::TOP) {\n+    return nullptr;\n+  }\n+  const TypeClass* type_divisor = t->cast<TypeClass>();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding mod-zero case\n+  if (mod->in(0) != nullptr && (type_divisor->_hi < 0 || type_divisor->_lo > 0)) {\n+    mod->set_req(0, nullptr); \/\/ Yank control input\n+    return mod;\n+  }\n+\n+  if (!type_divisor->is_con()) {\n+    return nullptr;\n+  }\n+  Unsigned divisor = static_cast<Unsigned>(type_divisor->get_con());\n+\n+  if (divisor == 0) {\n+    return nullptr;\n+  }\n+\n+  if (is_power_of_2(divisor)) {\n+    return make_and<TypeClass>(mod->in(1), phase->makecon(TypeClass::make(divisor - 1)));\n+  }\n+\n@@ -1093,0 +1164,50 @@\n+template <typename TypeClass, typename Unsigned, typename Signed>\n+static const Type* unsigned_mod_value(PhaseGVN* phase, const Node* mod) {\n+  const Type* t1 = phase->type(mod->in(1));\n+  const Type* t2 = phase->type(mod->in(2));\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ 0 MOD X is 0\n+  if (t1 == TypeClass::ZERO) {\n+    return TypeClass::ZERO;\n+  }\n+  \/\/ X MOD X is 0\n+  if (mod->in(1) == mod->in(2)) {\n+    return TypeClass::ZERO;\n+  }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type* bot = mod->bottom_type();\n+  if ((t1 == bot) || (t2 == bot) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM)) {\n+    return bot;\n+  }\n+\n+  const TypeClass* type_divisor = t2->cast<TypeClass>();\n+  if (type_divisor->is_con() && type_divisor->get_con() == 1) {\n+    return TypeClass::ZERO;\n+  }\n+\n+  const TypeClass* type_dividend = t1->cast<TypeClass>();\n+  if (type_dividend->is_con() && type_divisor->is_con()) {\n+    Unsigned au = static_cast<Unsigned>(type_dividend->get_con());\n+    Unsigned bu = static_cast<Unsigned>(type_divisor->get_con());\n+    return TypeClass::make(static_cast<Signed>(au % bu));\n+  }\n+\n+  return bot;\n+}\n+\n+Node* UModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return unsigned_mod_ideal<TypeInt, juint>(phase, can_reshape, this);\n+}\n+\n+const Type* UModINode::Value(PhaseGVN* phase) const {\n+  return unsigned_mod_value<TypeInt, juint, jint>(phase, this);\n+}\n+\n@@ -1306,3 +1427,1 @@\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n+  return unsigned_mod_ideal<TypeLong, julong>(phase, can_reshape, this);\n@@ -1311,0 +1430,3 @@\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  return unsigned_mod_value<TypeLong, julong, jlong>(phase, this);\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":136,"deletions":14,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -185,0 +186,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -282,0 +282,2 @@\n+    case Op_UDivI:\n+    case Op_UModI:\n@@ -286,0 +288,2 @@\n+    case Op_UDivL:\n+    case Op_UModL:\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,0 +229,13 @@\n+template <typename TypeClass>\n+Node* make_and(Node* a, Node* b);\n+\n+template <>\n+inline Node* make_and<TypeLong>(Node* a, Node* b) {\n+  return new AndLNode(a, b);\n+}\n+\n+template <>\n+inline Node* make_and<TypeInt>(Node* a, Node* b) {\n+  return new AndINode(a, b);\n+}\n+\n@@ -361,0 +374,13 @@\n+template <typename TypeClass>\n+Node* make_urshift(Node* a, Node* b);\n+\n+template <>\n+inline Node* make_urshift<TypeLong>(Node* a, Node* b) {\n+  return new URShiftLNode(a, b);\n+}\n+\n+template <>\n+inline Node* make_urshift<TypeInt>(Node* a, Node* b) {\n+  return new URShiftINode(a, b);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1129,1 +1129,0 @@\n-protected:\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1734,1 +1734,3 @@\n-    case Op_ModI: {\n+    case Op_ModI:\n+    case Op_UDivI:\n+    case Op_UModI: {\n@@ -1744,1 +1746,3 @@\n-    case Op_ModL: {\n+    case Op_ModL:\n+    case Op_UDivL:\n+    case Op_UModL: {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -317,0 +317,3 @@\n+  template <typename TypeClass>\n+  const TypeClass* cast() const;\n+\n@@ -2169,0 +2172,9 @@\n+template <>\n+inline const TypeInt* Type::cast<TypeInt>() const {\n+  return is_int();\n+}\n+\n+template <>\n+inline const TypeLong* Type::cast<TypeLong>() const {\n+  return is_long();\n+}\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of ModINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ModINodeIdealizationTests\n+ *\/\n+public class ModINodeIdealizationTests {\n+    public static final int RANDOM_POWER_OF_2 = 1 << (1 + Utils.getRandomInstance().nextInt(30));\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Random\", \"powerOf2Minus1\",\n+                 \"positivePowerOf2\", \"positivePowerOf2Random\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 2 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 2 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a % a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a % 32, powerOf2(a));\n+        Asserts.assertEQ(a % RANDOM_POWER_OF_2, powerOf2Random(a));\n+        Asserts.assertEQ(Math.max(0, a) % 32, positivePowerOf2(a));\n+        Asserts.assertEQ(Math.max(0, a) % RANDOM_POWER_OF_2, positivePowerOf2Random(a));\n+        Asserts.assertEQ(a % 127, powerOf2Minus1(a));\n+        Asserts.assertEQ(a % 1, constantAgain(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constant(int x) {\n+        return x % x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantAgain(int x) {\n+        return x % 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.RSHIFT, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int positivePowerOf2(int x) {\n+        return Math.max(0, x) % 32;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.RSHIFT, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int positivePowerOf2Random(int x) {\n+        return Math.max(0, x) % RANDOM_POWER_OF_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int powerOf2(int x) {\n+        return x % 32;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    public int powerOf2Random(int x) {\n+        return x % RANDOM_POWER_OF_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I})\n+    @IR(counts = {IRNode.AND_I, \">=1\", IRNode.RSHIFT, \">=1\", IRNode.CMP_I, \"2\"})\n+    \/\/ Special optimization for the case 2^k-1 for bigger k\n+    public int powerOf2Minus1(int x) {\n+        return x % 127;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModINodeIdealizationTests.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of ModLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ModLNodeIdealizationTests\n+ *\/\n+public class ModLNodeIdealizationTests {\n+    public static final long RANDOM_POWER_OF_2 = 1L << (1 + Utils.getRandomInstance().nextInt(62));\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Random\", \"powerOf2Minus1\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        a = (a == 0) ? 2 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+        b = (b == 0) ? 2 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a % a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a % (1L << 33), powerOf2(a));\n+        Asserts.assertEQ(a % ((1L << 33) - 1), powerOf2Minus1(a));\n+        Asserts.assertEQ(a % 1, constantAgain(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constant(long x) {\n+        return x % x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantAgain(long x) {\n+        return x % 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_L, \"1\"})\n+    \/\/ If the dividend is positive, and divisor is of the form 2^k, we can use a simple bit mask.\n+    public long powerOf2(long x) {\n+        return x % (1L << 33);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.DIV})\n+    @IR(counts = {IRNode.AND_L, \"1\"})\n+    \/\/ If the dividend is positive, and divisor is of the form 2^k, we can use a simple bit mask.\n+    public long powerOf2Random(long x) {\n+        return x % RANDOM_POWER_OF_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L})\n+    @IR(counts = {IRNode.AND_L, \">=1\", IRNode.RSHIFT, \">=1\", IRNode.CMP_L, \"2\"})\n+    \/\/ Special optimization for the case 2^k-1 for bigger k\n+    public long powerOf2Minus1(long x) {\n+        return x % ((1L << 33) - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModLNodeIdealizationTests.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UDivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivINodeIdealizationTests\n+ *\/\n+public class UDivINodeIdealizationTests {\n+    public static final int RANDOM_POWER_OF_2 = 1 << (1 + Utils.getRandomInstance().nextInt(30));\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityAgainButBig\", \"identityThird\",\n+            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\", \"divByPow2Random\" })\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Integer.divideUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Integer.divideUnsigned(a, Integer.divideUnsigned(b, b)), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Integer.divideUnsigned((a * b), b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Integer.divideUnsigned(a, 1), identity(a));\n+        Asserts.assertEQ(Integer.divideUnsigned(a, Integer.divideUnsigned(13, 13)), identityAgain(a));\n+        Asserts.assertEQ(Integer.divideUnsigned(a, 8), divByPow2(a), \"divByPow2 \" + a);\n+        Asserts.assertEQ(Integer.divideUnsigned(a, Integer.MIN_VALUE), divByPow2Big(a));\n+        Asserts.assertEQ(Integer.divideUnsigned(a, Integer.divideUnsigned((1 << 20) + 1, (1 << 20) + 1)), identityAgainButBig(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return Integer.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return Integer.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgainButBig(int x) {\n+        \/\/ (1 << 20) + 1 is an arbitrary integer that cannot be optimized by the power of 2 optimizations\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned((1 << 20) + 1, (1 << 20) + 1));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+            IRNode.UDIV_I, \"1\",\n+            IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+    })\n+    public int retainDenominator(int x, int y) {\n+        return Integer.divideUnsigned((x * y), y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    \/\/ Dividing an unsigned number by 8 is a trivial right shift by 3\n+    public int divByPow2(int x) {\n+        return Integer.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public int divByPow2Random(int x) {\n+        return Integer.divideUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public int divByPow2Big(int x) {\n+        return Integer.divideUnsigned(x, Integer.MIN_VALUE);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UDivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivLNodeIdealizationTests\n+ *\/\n+public class UDivLNodeIdealizationTests {\n+    public static final long RANDOM_POWER_OF_2 = 1L << (1 + Utils.getRandomInstance().nextInt(62));\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityAgainButBig\", \"identityThird\",\n+            \"retainDenominator\", \"divByPow2\", \"divByPow2Big\", \"divByPow2Random\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+        b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Long.divideUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Long.divideUnsigned((a * b), b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(Long.divideUnsigned(a, Long.divideUnsigned(b, b)), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Long.divideUnsigned(a, 1), identity(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, Long.divideUnsigned(13, 13)), identityAgain(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, 8), divByPow2(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, Long.MIN_VALUE), divByPow2Big(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, RANDOM_POWER_OF_2), divByPow2Random(a));\n+        Asserts.assertEQ(Long.divideUnsigned(a, Long.divideUnsigned((1L << 40) + 1, (1L << 40) + 1)), identityAgainButBig(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return Long.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return Long.divideUnsigned(x, 1L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(13L, 13L));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgainButBig(long x) {\n+        \/\/ (1L << 40) + 1 is an arbitrary integer that cannot be optimized by the power of 2 optimizations\n+        return Long.divideUnsigned(x, Long.divideUnsigned((1L << 40) + 1, (1L << 40) + 1));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+            IRNode.UDIV_L, \"1\",\n+            IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+    })\n+    public long retainDenominator(long x, long y) {\n+        return Long.divideUnsigned((x * y), y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    \/\/ Dividing an unsigned number by 8 is a trivial right shift by 3\n+    public long divByPow2(long x) {\n+        return Long.divideUnsigned(x, 8L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public long divByPow2Random(long x) {\n+        return Long.divideUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\"})\n+    public long divByPow2Big(long x) {\n+        return Long.divideUnsigned(x, Long.MIN_VALUE);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UModINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UModINodeIdealizationTests\n+ *\/\n+public class UModINodeIdealizationTests {\n+    public static final int RANDOM_POWER_OF_2 = 1 << (1 + Utils.getRandomInstance().nextInt(30));\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"powerOf2Random\", \"reallyConstant\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 2 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 2 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Integer.remainderUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Integer.remainderUnsigned(a, 1), constantAgain(a));\n+        Asserts.assertEQ(Integer.remainderUnsigned(a, 32), powerOf2(a));\n+        Asserts.assertEQ(Integer.remainderUnsigned(a, Integer.MIN_VALUE), powerOf2Big(a));\n+        Asserts.assertEQ(Integer.remainderUnsigned(a, RANDOM_POWER_OF_2), powerOf2Random(a));\n+        Asserts.assertEQ(Integer.remainderUnsigned(Integer.MIN_VALUE, 302032), reallyConstant());\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constant(int x) {\n+        return Integer.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantAgain(int x) {\n+        return Integer.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    \/\/ Checks that modulo with two constants is calculated at compile time\n+    public int reallyConstant() {\n+        return Integer.remainderUnsigned(Integer.MIN_VALUE, 302032); \/\/ -2147483648 = Integer.parseUnsignedInt(\"2147483648\")\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public int powerOf2(int x) {\n+        return Integer.remainderUnsigned(x, 32);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public int powerOf2Random(int x) {\n+        return Integer.remainderUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public int powerOf2Big(int x) {\n+        return Integer.remainderUnsigned(x, Integer.MIN_VALUE);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UModINodeIdealizationTests.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UModLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UModLNodeIdealizationTests\n+ *\/\n+public class UModLNodeIdealizationTests {\n+    public static final long RANDOM_POWER_OF_2 = 1L << (1 + Utils.getRandomInstance().nextInt(62));\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"constantAgain\", \"powerOf2\", \"powerOf2Big\", \"powerOf2Random\", \"reallyConstant\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextInt();\n+        a = (a == 0) ? 2 : a;\n+        long b = RunInfo.getRandom().nextInt();\n+        b = (b == 0) ? 2 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(Long.remainderUnsigned(a, a), constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        } catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expect an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(Long.remainderUnsigned(a, 1), constantAgain(a));\n+        Asserts.assertEQ(Long.remainderUnsigned(a, 1L << 33), powerOf2(a));\n+        Asserts.assertEQ(Long.remainderUnsigned(Long.MIN_VALUE, 302032), reallyConstant());\n+        Asserts.assertEQ(Long.remainderUnsigned(a, Long.MIN_VALUE), powerOf2Big(a));\n+        Asserts.assertEQ(Long.remainderUnsigned(a, RANDOM_POWER_OF_2), powerOf2Random(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constant(long x) {\n+        return Long.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantAgain(long x) {\n+        return Long.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    \/\/ Checks that modulo with two constants is calculated at compile time\n+    public long reallyConstant() {\n+        return Long.remainderUnsigned(Long.MIN_VALUE, 302032);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public long powerOf2(long x) {\n+        return Long.remainderUnsigned(x, 1L << 33);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public long powerOf2Random(long x) {\n+        return Long.remainderUnsigned(x, RANDOM_POWER_OF_2);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L, IRNode.MUL})\n+    @IR(counts = {IRNode.AND, \"1\"})\n+    \/\/ Checks that for x % 2^k, 2^k-1 is used as a bit mask.\n+    public long powerOf2Big(long x) {\n+        return Long.remainderUnsigned(x, Long.MIN_VALUE);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UModLNodeIdealizationTests.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -528,0 +528,5 @@\n+    public static final String UDIV = PREFIX + \"UDIV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV, \"UDiv(I|L|F|D)\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,3 @@\n+        \/\/ Make sure classes are loaded when compiling with -Xcomp\n+        Integer.divideUnsigned(2, 3);\n+        Long.divideUnsigned(2, 3);\n@@ -88,0 +91,10 @@\n+            testPushUDivLThruPhiForOuterLongLoop();\n+            testPushUModLThruPhiForOuterLongLoop();\n+            testPushUDivIThruPhi();\n+            testPushUDivIThruPhiInChain();\n+            testPushUModIThruPhi();\n+            testPushUModIThruPhiInChain();\n+            testPushUDivLThruPhi();\n+            testPushUDivLThruPhiInChain();\n+            testPushUModLThruPhi();\n+            testPushUModLThruPhiInChain();\n@@ -205,0 +218,110 @@\n+\n+    \/\/ Same as above but with UDivI.\n+    static void testPushUDivIThruPhi() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            lFld = Integer.divideUnsigned(10, i);\n+\n+            \/\/ Loop that is not removed such that we do not transform the outer LongCountedLoop (only done if innermost)\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UDivI.\n+    static void testPushUDivIThruPhiInChain() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = Integer.divideUnsigned(10, (i * 100));\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UModI\n+    static void testPushUModIThruPhi() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            lFld = Integer.remainderUnsigned(10, i);\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UModI\n+    static void testPushUModIThruPhiInChain() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = Integer.remainderUnsigned(10, (i * 100));\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UDivL.\n+    static void testPushUDivLThruPhi() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = Long.divideUnsigned(10L, i);\n+\n+            \/\/ Loop that is not removed such that we do not transform the outer LongCountedLoop (only done if innermost)\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UDivL.\n+    static void testPushUDivLThruPhiInChain() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = Long.divideUnsigned(10L, (i * 100L));\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UModL\n+    static void testPushUModLThruPhi() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = Long.remainderUnsigned(10L, i);\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with UModL\n+    static void testPushUModLThruPhiInChain() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = Long.remainderUnsigned(10L, (i * 100L));\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    static void testPushUDivLThruPhiForOuterLongLoop() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = Long.divideUnsigned(10, i);\n+        }\n+    }\n+\n+    static void testPushUModLThruPhiForOuterLongLoop() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = Integer.remainderUnsigned(10, i);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"}]}