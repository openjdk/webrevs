{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collection;\n@@ -33,1 +32,0 @@\n-import java.util.ListIterator;\n@@ -113,4 +111,0 @@\n-    \/\/ A subset of block tags, which acts as sentence breakers, appearing\n-    \/\/ anywhere but the zero'th position in the first sentence.\n-    final Set<String> sentenceBreakTags;\n-\n@@ -130,0 +124,1 @@\n+    private final SentenceBreaker breaker;\n@@ -141,1 +136,1 @@\n-        sentenceBreakTags = Set.of(\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"PRE\", \"P\");\n+        breaker = new SentenceBreaker(this);\n@@ -520,14 +515,29 @@\n-    \/*\n-     * Breaks up the body tags into the first sentence and its successors.\n-     * The first sentence is determined with the presence of a period,\n-     * block tag, or a sentence break, as returned by the BreakIterator.\n-     * Trailing whitespaces are trimmed.\n-     *\/\n-    private Pair<List<DCTree>, List<DCTree>> splitBody(Collection<? extends DocTree> list) {\n-        \/\/ pos is modified as we create trees, therefore\n-        \/\/ we save the pos and restore it later.\n-        final int savedpos = this.pos;\n-        try {\n-            ListBuffer<DCTree> body = new ListBuffer<>();\n-            \/\/ split body into first sentence and body\n-            ListBuffer<DCTree> fs = new ListBuffer<>();\n+    @SuppressWarnings(\"unchecked\")\n+    private static List<DCTree> cast(List<? extends DocTree> list) {\n+        return (List<DCTree>) list;\n+    }\n+\n+    Pair<List<DCTree>, List<DCTree>> splitBody(List<? extends DocTree> list) {\n+        return breaker.splitBody(list);\n+    }\n+\n+    static class SentenceBreaker {\n+        final DocTreeMaker m;\n+\n+        \/\/ A subset of block tags, which acts as sentence breakers, appearing\n+        \/\/ anywhere but the zero'th position in the first sentence.\n+        static final Set<String> sentenceBreakTags = Set.of(\n+                \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\",\n+                \"PRE\", \"P\");\n+\n+        SentenceBreaker(DocTreeMaker m) {\n+            this.m = m;\n+        }\n+\n+        \/*\n+         * Breaks up the body tags into the first sentence and its successors.\n+         * The first sentence is determined with the presence of a period,\n+         * block tag, or a sentence break, as returned by the BreakIterator.\n+         * Trailing whitespaces are trimmed.\n+         *\/\n+        Pair<List<DCTree>, List<DCTree>> splitBody(List<? extends DocTree> list) {\n@@ -535,1 +545,1 @@\n-                return new Pair<>(fs.toList(), body.toList());\n+                return new Pair<>(List.of(), List.of());\n@@ -537,27 +547,16 @@\n-            boolean foundFirstSentence = false;\n-            ArrayList<DocTree> alist = new ArrayList<>(list);\n-            ListIterator<DocTree> itr = alist.listIterator();\n-            while (itr.hasNext()) {\n-                boolean isFirst = !itr.hasPrevious();\n-                DocTree dt = itr.next();\n-                int spos = ((DCTree) dt).pos;\n-                if (foundFirstSentence) {\n-                    body.add((DCTree) dt);\n-                    continue;\n-                }\n-                switch (dt.getKind()) {\n-                    case RETURN:\n-                    case SUMMARY:\n-                        foundFirstSentence = true;\n-                        break;\n-                    case TEXT:\n-                        DCText tt = (DCText) dt;\n-                        String s = tt.getBody();\n-                        DocTree peekedNext = itr.hasNext()\n-                                ? alist.get(itr.nextIndex())\n-                                : null;\n-                        int sbreak = getSentenceBreak(s, peekedNext);\n-                        if (sbreak > 0) {\n-                            s = s.substring(0, sbreak).stripTrailing();\n-                            DCText text = this.at(spos).newTextTree(s);\n-                            fs.add(text);\n+            \/\/ pos is modified as we create trees, therefore\n+            \/\/ we save the pos and restore it later.\n+            final var savedPos = m.pos;\n+            try {\n+                \/\/ split list into first sentence and body\n+                var fs = new ListBuffer<DCTree>();\n+                var body = new ListBuffer<DCTree>();\n+                var alist = new ArrayList<>(cast(list)); \/\/ copy to allow indexed access for peeking\n+                var iter = alist.listIterator();\n+                var foundFirstSentence = false;\n+                while (iter.hasNext() && !foundFirstSentence) {\n+                    boolean isFirst = !iter.hasPrevious();\n+                    DCTree dt = iter.next();\n+                    switch (dt.getKind()) {\n+                        case RETURN, SUMMARY -> {\n+                            fs.add(dt);\n@@ -565,4 +564,31 @@\n-                            int nwPos = skipWhiteSpace(tt.getBody(), sbreak);\n-                            if (nwPos > 0) {\n-                                DCText text2 = this.at(spos + nwPos).newTextTree(tt.getBody().substring(nwPos));\n-                                body.add(text2);\n+                        }\n+\n+                        case TEXT -> {\n+                            var dtPos = dt.pos;\n+                            var s = ((DCText) dt).getBody();\n+                            var peekedNext = iter.hasNext()\n+                                    ? alist.get(iter.nextIndex())\n+                                    : null;\n+                            int sbreak = getSentenceBreak(s, peekedNext);\n+                            if (sbreak > 0) {\n+                                var fsPart = m.at(dtPos).newTextTree(s.substring(0, sbreak).stripTrailing());\n+                                fs.add(fsPart);\n+                                int offsetPos = skipWhiteSpace(s, sbreak);\n+                                if (offsetPos > 0) {\n+                                    DCText bodyPart = m.at(dtPos + offsetPos).newTextTree(s.substring(offsetPos));\n+                                    body.add(bodyPart);\n+                                }\n+                                foundFirstSentence = true;\n+                            } else if (peekedNext != null) {\n+                                \/\/ if the next doctree is a break, remove trailing spaces\n+                                if (isSentenceBreak(peekedNext, false)) {\n+                                    DCTree next = iter.next();\n+                                    DCText fsPart = m.at(dtPos).newTextTree(s.stripTrailing());\n+                                    fs.add(fsPart);\n+                                    body.add(next);\n+                                    foundFirstSentence = true;\n+                                } else {\n+                                    fs.add(dt);\n+                                }\n+                            } else {\n+                                fs.add(dt);\n@@ -570,11 +596,9 @@\n-                            continue;\n-                        } else if (itr.hasNext()) {\n-                            \/\/ if the next doctree is a break, remove trailing spaces\n-                            peekedNext = alist.get(itr.nextIndex());\n-                            boolean sbrk = isSentenceBreak(peekedNext, false);\n-                            if (sbrk) {\n-                                DocTree next = itr.next();\n-                                s = s.stripTrailing();\n-                                DCText text = this.at(spos).newTextTree(s);\n-                                fs.add(text);\n-                                body.add((DCTree) next);\n+                        }\n+\n+                        default -> {\n+                            \/\/ This ignores certain block tags if they appear first in the list,\n+                            \/\/ allowing the content of that tag to provide the first sentence.\n+                            \/\/ It would be better if other block tags always terminated the\n+                            \/\/ first sentence as well, like lists and tables.\n+                            if (isSentenceBreak(dt, isFirst)) {\n+                                body.add(dt);\n@@ -582,1 +606,2 @@\n-                                continue;\n+                            } else {\n+                                fs.add(dt);\n@@ -585,0 +610,25 @@\n+                    }\n+                }\n+\n+                \/\/ if there are remaining elements, then we have found the first\n+                \/\/ sentence, and remaining elements are for the body.\n+                while (iter.hasNext()) {\n+                    body.add(iter.next());\n+                }\n+\n+                return new Pair<>(fs.toList(), body.toList());\n+            } finally {\n+                m.pos = savedPos;\n+            }\n+        }\n+\n+        \/*\n+         * Computes the first sentence break, a simple dot-space algorithm.\n+         *\/\n+        private int defaultSentenceBreak(String s) {\n+            \/\/ scan for period followed by whitespace\n+            int period = -1;\n+            for (int i = 0; i < s.length(); i++) {\n+                switch (s.charAt(i)) {\n+                    case '.':\n+                        period = i;\n@@ -586,5 +636,8 @@\n-                    default:\n-                        if (isSentenceBreak(dt, isFirst)) {\n-                            body.add((DCTree) dt);\n-                            foundFirstSentence = true;\n-                            continue;\n+\n+                    case ' ':\n+                    case '\\f':\n+                    case '\\n':\n+                    case '\\r':\n+                    case '\\t':\n+                        if (period >= 0) {\n+                            return i;\n@@ -593,0 +646,4 @@\n+\n+                    default:\n+                        period = -1;\n+                        break;\n@@ -594,1 +651,0 @@\n-                fs.add((DCTree) dt);\n@@ -596,3 +652,1 @@\n-            return new Pair<>(fs.toList(), body.toList());\n-        } finally {\n-            this.pos = savedpos;\n+            return -1;\n@@ -600,1 +654,0 @@\n-    }\n@@ -602,25 +655,31 @@\n-    private boolean isTextTree(DocTree tree) {\n-        return tree.getKind() == Kind.TEXT;\n-    }\n-\n-    \/*\n-     * Computes the first sentence break, a simple dot-space algorithm.\n-     *\/\n-    private int defaultSentenceBreak(String s) {\n-        \/\/ scan for period followed by whitespace\n-        int period = -1;\n-        for (int i = 0; i < s.length(); i++) {\n-            switch (s.charAt(i)) {\n-                case '.':\n-                    period = i;\n-                    break;\n-\n-                case ' ':\n-                case '\\f':\n-                case '\\n':\n-                case '\\r':\n-                case '\\t':\n-                    if (period >= 0) {\n-                        return i;\n-                    }\n-                    break;\n+        \/*\n+         * Computes the first sentence, if using a default breaker,\n+         * the break is returned, if not then a -1, indicating that\n+         * more doctree elements are required to be examined.\n+         *\n+         * BreakIterator.next points to the start of the following sentence,\n+         * and does not provide an easy way to disambiguate between \"sentence break\",\n+         * \"possible sentence break\" and \"not a sentence break\" at the end of the input.\n+         * For example, BreakIterator.next returns the index for the end\n+         * of the string for all of these examples,\n+         * using vertical bars to delimit the bounds of the example text\n+         * |Abc|        (not a valid end of sentence break, if followed by more text)\n+         * |Abc.|       (maybe a valid end of sentence break, depending on the following text)\n+         * |Abc. |      (maybe a valid end of sentence break, depending on the following text)\n+         * |\"Abc.\" |    (maybe a valid end of sentence break, depending on the following text)\n+         * |Abc.  |     (definitely a valid end of sentence break)\n+         * |\"Abc.\"  |   (definitely a valid end of sentence break)\n+         * Therefore, we have to probe further to determine whether\n+         * there really is a sentence break or not at the end of this run of text.\n+         *\/\n+        private int getSentenceBreak(String s, DCTree nextTree) {\n+            BreakIterator breakIterator = m.trees.getBreakIterator();\n+            if (breakIterator == null) {\n+                return defaultSentenceBreak(s);\n+            }\n+            breakIterator.setText(s);\n+            final int sbrk = breakIterator.next();\n+            \/\/ This is the last doctree, found the droid we are looking for\n+            if (nextTree == null) {\n+                return sbrk;\n+            }\n@@ -628,3 +687,4 @@\n-                default:\n-                    period = -1;\n-                    break;\n+            \/\/ If the break is well within the span of the string ie. not\n+            \/\/ at EOL, then we have a clear break.\n+            if (sbrk < s.length() - 1) {\n+                return sbrk;\n@@ -632,3 +692,0 @@\n-        }\n-        return -1;\n-    }\n@@ -636,31 +693,14 @@\n-    \/*\n-     * Computes the first sentence, if using a default breaker,\n-     * the break is returned, if not then a -1, indicating that\n-     * more doctree elements are required to be examined.\n-     *\n-     * BreakIterator.next points to the start of the following sentence,\n-     * and does not provide an easy way to disambiguate between \"sentence break\",\n-     * \"possible sentence break\" and \"not a sentence break\" at the end of the input.\n-     * For example, BreakIterator.next returns the index for the end\n-     * of the string for all of these examples,\n-     * using vertical bars to delimit the bounds of the example text\n-     * |Abc|        (not a valid end of sentence break, if followed by more text)\n-     * |Abc.|       (maybe a valid end of sentence break, depending on the following text)\n-     * |Abc. |      (maybe a valid end of sentence break, depending on the following text)\n-     * |\"Abc.\" |    (maybe a valid end of sentence break, depending on the following text)\n-     * |Abc.  |     (definitely a valid end of sentence break)\n-     * |\"Abc.\"  |   (definitely a valid end of sentence break)\n-     * Therefore, we have to probe further to determine whether\n-     * there really is a sentence break or not at the end of this run of text.\n-     *\/\n-    private int getSentenceBreak(String s, DocTree dt) {\n-        BreakIterator breakIterator = trees.getBreakIterator();\n-        if (breakIterator == null) {\n-            return defaultSentenceBreak(s);\n-        }\n-        breakIterator.setText(s);\n-        final int sbrk = breakIterator.next();\n-        \/\/ This is the last doctree, found the droid we are looking for\n-        if (dt == null) {\n-            return sbrk;\n-        }\n+            if (nextTree.getKind() == Kind.TEXT) {\n+                \/\/ Two adjacent text trees, a corner case, perhaps\n+                \/\/ produced by a tool synthesizing a doctree. In\n+                \/\/ this case, does the break lie within the first span,\n+                \/\/ then we have the droid, otherwise allow the callers\n+                \/\/ logic to handle the break in the adjacent doctree.\n+                TextTree ttnext = (TextTree) nextTree;\n+                String combined = s + ttnext.getBody();\n+                breakIterator.setText(combined);\n+                int sbrk2 = breakIterator.next();\n+                if (sbrk < sbrk2) {\n+                    return sbrk;\n+                }\n+            }\n@@ -668,5 +708,4 @@\n-        \/\/ If the break is well within the span of the string ie. not\n-        \/\/ at EOL, then we have a clear break.\n-        if (sbrk < s.length() - 1) {\n-            return sbrk;\n-        }\n+            \/\/ Is the adjacent tree a sentence breaker ?\n+            if (isSentenceBreak(nextTree, false)) {\n+                return sbrk;\n+            }\n@@ -674,8 +713,4 @@\n-        if (isTextTree(dt)) {\n-            \/\/ Two adjacent text trees, a corner case, perhaps\n-            \/\/ produced by a tool synthesizing a doctree. In\n-            \/\/ this case, does the break lie within the first span,\n-            \/\/ then we have the droid, otherwise allow the callers\n-            \/\/ logic to handle the break in the adjacent doctree.\n-            TextTree ttnext = (TextTree) dt;\n-            String combined = s + ttnext.getBody();\n+            \/\/ At this point the adjacent tree is either a javadoc tag ({@..),\n+            \/\/ html tag (<..) or an entity (&..). Perform a litmus test, by\n+            \/\/ concatenating a sentence, to validate the break earlier identified.\n+            String combined = s + \"Dummy Sentence.\";\n@@ -684,2 +719,2 @@\n-            if (sbrk < sbrk2) {\n-                return sbrk;\n+            if (sbrk2 <= sbrk) {\n+                return sbrk2;\n@@ -687,0 +722,1 @@\n+            return -1; \/\/ indeterminate at this time\n@@ -689,13 +725,11 @@\n-        \/\/ Is the adjacent tree a sentence breaker ?\n-        if (isSentenceBreak(dt, false)) {\n-            return sbrk;\n-        }\n-\n-        \/\/ At this point the adjacent tree is either a javadoc tag ({@..),\n-        \/\/ html tag (<..) or an entity (&..). Perform a litmus test, by\n-        \/\/ concatenating a sentence, to validate the break earlier identified.\n-        String combined = s + \"Dummy Sentence.\";\n-        breakIterator.setText(combined);\n-        int sbrk2 = breakIterator.next();\n-        if (sbrk2 <= sbrk) {\n-            return sbrk2;\n+        private boolean isSentenceBreak(DCTree dt, boolean isFirstDocTree) {\n+            switch (dt.getKind()) {\n+                case START_ELEMENT:\n+                    StartElementTree set = (StartElementTree) dt;\n+                    return !isFirstDocTree && dt.pos > 1 && isSentenceBreak(set.getName());\n+                case END_ELEMENT:\n+                    EndElementTree eet = (EndElementTree) dt;\n+                    return !isFirstDocTree && dt.pos > 1 && isSentenceBreak(eet.getName());\n+                default:\n+                    return false;\n+            }\n@@ -703,6 +737,0 @@\n-        return -1; \/\/ indeterminate at this time\n-    }\n-\n-    private boolean isSentenceBreak(Name tagName) {\n-        return sentenceBreakTags.contains(StringUtils.toUpperCase(tagName.toString()));\n-    }\n@@ -710,10 +738,2 @@\n-    private boolean isSentenceBreak(DocTree dt, boolean isFirstDocTree) {\n-        switch (dt.getKind()) {\n-            case START_ELEMENT:\n-                    StartElementTree set = (StartElementTree)dt;\n-                    return !isFirstDocTree && ((DCTree) dt).pos > 1 && isSentenceBreak(set.getName());\n-            case END_ELEMENT:\n-                    EndElementTree eet = (EndElementTree)dt;\n-                    return !isFirstDocTree && ((DCTree) dt).pos > 1 && isSentenceBreak(eet.getName());\n-            default:\n-                return false;\n+        private boolean isSentenceBreak(Name tagName) {\n+            return sentenceBreakTags.contains(StringUtils.toUpperCase(tagName.toString()));\n@@ -721,1 +741,0 @@\n-    }\n@@ -723,8 +742,9 @@\n-    \/*\n-     * Returns the position of the first non-whitespace character.\n-     *\/\n-    private int skipWhiteSpace(String s, int start) {\n-        for (int i = start; i < s.length(); i++) {\n-            char c = s.charAt(i);\n-            if (!Character.isWhitespace(c)) {\n-                return i;\n+        \/*\n+         * Returns the position of the first non-whitespace character.\n+         *\/\n+        private int skipWhiteSpace(String s, int start) {\n+            for (int i = start; i < s.length(); i++) {\n+                char c = s.charAt(i);\n+                if (!Character.isWhitespace(c)) {\n+                    return i;\n+                }\n@@ -732,0 +752,1 @@\n+            return -1;\n@@ -733,1 +754,0 @@\n-        return -1;\n@@ -736,4 +756,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private List<DCTree> cast(List<? extends DocTree> list) {\n-        return (List<DCTree>) list;\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":211,"deletions":195,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-import com.sun.tools.javac.util.List;\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceDocTreeScannerTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}