{"files":[{"patch":"@@ -2015,5 +2015,1 @@\n-  \/\/ If we are loading from a freshly-allocated object, produce a zero,\n-  \/\/ if the load is provably beyond the header of the object.\n-  \/\/ (Also allow a variable load from a fresh array to produce zero.)\n-  const TypeOopPtr* tinst = tp->isa_oopptr();\n-  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n+  \/\/ If load can see a previous constant store, use that.\n@@ -2230,7 +2226,10 @@\n-  bool is_vect = (_type->isa_vect() != nullptr);\n-  if (is_instance && !is_vect) {\n-    \/\/ If we have an instance type and our memory input is the\n-    \/\/ programs's initial memory state, there is no matching store,\n-    \/\/ so just return a zero of the appropriate type -\n-    \/\/ except if it is vectorized - then we have no zero constant.\n-    Node *mem = in(MemNode::Memory);\n+  \/\/ If we are loading from a freshly-allocated object\/array, produce a zero.\n+  \/\/ Things to check:\n+  \/\/   1. Load is beyond the header: headers are not guaranteed to be zero\n+  \/\/   2. Load is not vectorized: vectors have no zero constant\n+  \/\/   3. Load has no matching store, i.e. the input is the initial memory state\n+  const TypeOopPtr* tinst = tp->isa_oopptr();\n+  bool is_not_header = (tinst != nullptr) && tinst->is_known_instance_field();\n+  bool is_not_vect = (_type->isa_vect() == nullptr);\n+  if (is_not_header && is_not_vect) {\n+    Node* mem = in(MemNode::Memory);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"}]}