{"files":[{"patch":"@@ -5546,0 +5546,10 @@\n+void Assembler::vpunpcklqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit && VM_Version::supports_avx() ||\n+         vector_len == AVX_256bit && VM_Version::supports_avx2() ||\n+         vector_len == AVX_512bit && VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6C, (0xC0 | encode));\n+}\n+\n@@ -5893,0 +5903,8 @@\n+void Assembler::evalignd(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len) {\n+  assert(vector_len == AVX_512bit && VM_Version::supports_evex() || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x3, (0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2006,0 +2006,1 @@\n+  void vpunpcklqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2096,0 +2097,1 @@\n+  void evalignd(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6092,0 +6092,61 @@\n+void C2_MacroAssembler::slice_32B_avx1(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                       XMMRegister xtmp1, XMMRegister xtmp2, int shift_count) {\n+  assert(UseAVX == 1, \"\");\n+  if (shift_count < 16) {\n+    vextractf128(xtmp1, src1, 1);\n+    vpalignr(xtmp2, xtmp1, src1, shift_count, AVX_128bit);\n+    vpalignr(xtmp1, src2, xtmp1, shift_count, AVX_128bit);\n+    vinsertf128(dst, xtmp2, xtmp1, 1);\n+  } else {\n+    assert(shift_count > 16, \"\");\n+    shift_count -= 16;\n+    vextractf128(xtmp1, src1, 1);\n+    vextractf128(xtmp2, src2, 1);\n+    vpalignr(xtmp1, src2, xtmp1, shift_count, AVX_128bit);\n+    vpalignr(xtmp2, xtmp2, src2, shift_count, AVX_128bit);\n+    vinsertf128(dst, xtmp1, xtmp2, 1);\n+  }\n+}\n+\n+void C2_MacroAssembler::slice_32B_avx2(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                       XMMRegister xtmp, int shift_count) {\n+  assert(UseAVX >= 2, \"\");\n+  if (VM_Version::supports_avx512vl()) {\n+    \/\/ vperm2f128 requires legacy registers, so we switch to evalignd\n+    evalignd(xtmp, src2, src1, 4, AVX_256bit);\n+  } else {\n+    vperm2i128(xtmp, src1, src2, 0x21);\n+  }\n+\n+  if (shift_count > 16) {\n+    shift_count -= 16;\n+    vpalignr(dst, src2, xtmp, shift_count, AVX_256bit);\n+  } else {\n+    assert(shift_count < 16, \"\");\n+    vpalignr(dst, xtmp, src1, shift_count, AVX_256bit);\n+  }\n+}\n+\n+void C2_MacroAssembler::slice_64B(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                  XMMRegister xtmp1, XMMRegister xtmp2, int shift_count) {\n+  assert(VM_Version::supports_avx512bw(), \"\"); \/\/ This is required for 512-bit byte or short vector\n+  if (shift_count < 16) {\n+    assert(shift_count > 0, \"\");\n+    assert(xtmp2 == xnoreg, \"\");\n+    evalignd(xtmp1, src2, src1, 4, AVX_512bit);\n+    vpalignr(dst, xtmp1, src1, shift_count % 16U, AVX_512bit);\n+  } else if (shift_count < 32) {\n+    evalignd(xtmp1, src2, src1, 4, AVX_512bit);\n+    evalignd(xtmp2, src2, src1, 8, AVX_512bit);\n+    vpalignr(dst, xtmp2, xtmp1, shift_count % 16U, AVX_512bit);\n+  } else if (shift_count < 48) {\n+    evalignd(xtmp1, src2, src1, 8, AVX_512bit);\n+    evalignd(xtmp2, src2, src1, 12, AVX_512bit);\n+    vpalignr(dst, xtmp2, xtmp1, shift_count % 16U, AVX_512bit);\n+  } else {\n+    assert(shift_count < 64, \"\");\n+    assert(xtmp2 == xnoreg, \"\");\n+    evalignd(xtmp1, src2, src1, 12, AVX_512bit);\n+    vpalignr(dst, src2, xtmp1, shift_count % 16U, AVX_512bit);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -487,0 +487,9 @@\n+  void slice_32B_avx1(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                      XMMRegister xtmp1, XMMRegister xtmp2, int shift_count);\n+\n+  void slice_32B_avx2(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                      XMMRegister xtmp, int shift_count);\n+\n+  void slice_64B(XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                 XMMRegister xtmp1, XMMRegister xtmp2, int shift_count);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -7917,1 +7917,0 @@\n-\n@@ -7932,0 +7931,175 @@\n+\/\/ --------------------------------- Vector Slice --------------------------------------\n+\n+instruct slice8B(vec dst, vec src, immI origin) %{\n+  predicate(Matcher::vector_length_in_bytes(n) < 16 &&\n+            UseAVX == 0);\n+  match(Set dst (VectorSlice (Binary dst src) origin));\n+  format %{ \"vector_slice $dst, $src, $origin\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length_in_bytes(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (vlen == 8) {\n+      __ punpcklqdq($dst$$XMMRegister, $src$$XMMRegister);\n+    } else {\n+      assert(vlen == 4, \"\");\n+      __ punpckldq($dst$$XMMRegister, $src$$XMMRegister);\n+    }\n+    __ psrldq($dst$$XMMRegister, $origin$$constant * type2aelembytes(bt));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct slice16B_srldq(vec dst, vec src, immI origin, vec xtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            !VM_Version::supports_ssse3());\n+  match(Set dst (VectorSlice (Binary dst src) origin));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_slice $dst, $src, $origin\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    __ psrldq($dst$$XMMRegister, shift_count);\n+    __ movdqu($xtmp$$XMMRegister, $src$$XMMRegister);\n+    __ pslldq($xtmp$$XMMRegister, 16 - shift_count);\n+    __ por($dst$$XMMRegister, $xtmp$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct slice16B_alignr(vec dst, vec src, immI origin) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            UseAVX == 0 &&\n+            VM_Version::supports_ssse3());\n+  match(Set dst (VectorSlice (Binary src dst) origin));\n+  format %{ \"vector_slice $dst, $src, $origin\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ palignr($dst$$XMMRegister, $src$$XMMRegister, $origin$$constant * type2aelembytes(bt));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vslice16B(vec dst, vec src1, vec src2, immI origin) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            UseAVX > 0);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length_in_bytes(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    if (vlen == 16) {\n+      __ vpalignr($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, shift_count, Assembler::AVX_128bit);\n+    } else {\n+      if (vlen == 8) {\n+        __ vpunpcklqdq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::AVX_128bit);\n+      } else {\n+        assert(vlen == 4, \"\");\n+        __ vpunpckldq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::AVX_128bit);\n+      }\n+      __ vpsrldq($dst$$XMMRegister, $dst$$XMMRegister, shift_count, Assembler::AVX_128bit);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vslice32B16(vec dst, vec src1, vec src2, immI origin) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 32 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() == 16 &&\n+            !VM_Version::supports_avx512vl());\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vperm2f128($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, 0x21);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct slice32B(vec dst, vec src1, vec src2, immI origin, vec xtmp1, vec xtmp2) %{\n+  predicate(UseAVX == 1 &&\n+            Matcher::vector_length_in_bytes(n) == 32 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() != 16);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    __ slice_32B_avx1($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                      $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, shift_count);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vslice32B(vec dst, vec src1, vec src2, immI origin, vec xtmp) %{\n+  predicate(UseAVX >= 2 &&\n+            Matcher::vector_length_in_bytes(n) == 32 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() != 16 &&\n+            ((type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int()) % 4U != 0 ||\n+             !VM_Version::supports_avx512vl()));\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    __ slice_32B_avx2($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                      $xtmp$$XMMRegister, shift_count);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evslice64B_near(vec dst, vec src1, vec src2, immI origin, vec xtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 64 &&\n+            (type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int()) % 4U != 0 &&\n+            (type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() < 16 ||\n+             type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() > 48));\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    assert(shift_count % 4U != 0, \"\");\n+    __ slice_64B($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                 $xtmp$$XMMRegister, xnoreg, shift_count);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evslice64B_far(vec dst, vec src1, vec src2, immI origin, vec xtmp1, vec xtmp2) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 64 &&\n+            (type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int()) % 4U != 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() > 16 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int() < 48);\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    assert(shift_count % 4U != 0, \"\");\n+    __ slice_64B($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                 $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, shift_count);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evsliceILFD(vec dst, vec src1, vec src2, immI origin) %{\n+  predicate((type2aelembytes(Matcher::vector_element_basic_type(n)) * n->in(2)->get_int()) % 4U == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 64 ||\n+             (Matcher::vector_length_in_bytes(n) == 32 &&\n+              VM_Version::supports_avx512vl())));\n+  match(Set dst (VectorSlice (Binary src1 src2) origin));\n+  format %{ \"vector_slice $dst, $src1, $src2, $origin\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int shift_count = $origin$$constant * type2aelembytes(bt);\n+    assert(shift_count % 4U == 0, \"\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evalignd($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, shift_count \/ 4U, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":176,"deletions":2,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -4228,1 +4228,1 @@\n-    \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n+    \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorSlice\", \"VectorInsert\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1071,0 +1071,11 @@\n+  do_intrinsic(_VectorSlice, jdk_internal_vm_vector_VectorSupport, vector_slice_name, vector_slice_sig, F_S)                                   \\\n+   do_signature(vector_slice_sig, \"(Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"I\"                                                                                                         \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                             \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                             \\\n+                                   \"I\"                                                                                                         \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSliceOp;)\"                                                     \\\n+                                   \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                            \\\n+   do_name(vector_slice_name, \"slice\")                                                                                                         \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -777,0 +777,1 @@\n+  case vmIntrinsics::_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+macro(VectorSlice)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -712,0 +712,2 @@\n+  case vmIntrinsics::_VectorSlice:\n+    return inline_vector_slice();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,0 +352,1 @@\n+  bool inline_vector_slice();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2470,0 +2470,1 @@\n+    case Op_VectorSlice:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1829,1 +1829,1 @@\n-\/\/         VectorBlendOp<V, M, E> defaultImpl)\n+\/\/         VectorBlendOp<V, M> defaultImpl)\n@@ -1896,0 +1896,68 @@\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E>\n+\/\/ V slice(Class<? extends V> vectorClass, Class<E> elementType, int vlen,\n+\/\/         V v1, V v2, int origin,\n+\/\/         VectorSliceOp<V> defaultImpl)\n+bool LibraryCallKit::inline_vector_slice() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     origin       = gvn().type(argument(5))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || origin == NULL) {\n+    return false; \/\/ dead code\n+  }\n+  if (vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL ||\n+      !vlen->is_con() || !origin->is_con()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s origin=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+  if (!is_klass_initialized(vector_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+  BasicType elem_bt = elem_type->basic_type();\n+  int num_elem = vlen->get_con();\n+\n+  if (!arch_supports_vector(Op_VectorSlice, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=2 op=slice vlen=%d etype=%s ismask=notused\",\n+                    num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* v1   = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* v2   = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* o    = argument(5);\n+\n+  if (v1 == NULL || v2 == NULL) {\n+    return false; \/\/ operand unboxing failed\n+  }\n+\n+  Node* slice = gvn().transform(new VectorSliceNode(v1, v2, o));\n+\n+  Node* box = box_vector(slice, vbox_type, elem_bt, num_elem);\n+  set_result(box);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1460,0 +1460,8 @@\n+class VectorSliceNode : public VectorNode {\n+ public:\n+  VectorSliceNode(Node* vec1, Node* vec2, Node* origin)\n+    : VectorNode(vec1, vec2, origin, vec1->bottom_type()->is_vect()) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1846,0 +1846,1 @@\n+  declare_c2_type(VectorSliceNode, VectorNode)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -629,0 +630,18 @@\n+\n+    public interface VectorSliceOp<V extends Vector<?>> {\n+        V apply(V v1, V v2, int origin);\n+    }\n+\n+    @ForceInline\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     E>\n+    V slice(Class<? extends V> vClass, Class<E> eClass, int length,\n+            V v1, V v2, int origin,\n+            VectorSliceOp<V> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, origin);\n+    }\n+\n+    \/* ============================================================================ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Byte128Vector slice(int origin) {\n-        return (Byte128Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Byte256Vector slice(int origin) {\n-        return (Byte256Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Byte512Vector slice(int origin) {\n-        return (Byte512Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Byte64Vector slice(int origin) {\n-        return (Byte64Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -419,6 +419,0 @@\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector slice(int origin) {\n-        return (ByteMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2282,3 +2282,1 @@\n-    ByteVector sliceTemplate(int origin, Vector<Byte> v1) {\n-        ByteVector that = (ByteVector) v1;\n-        that.check(this);\n+    ByteVector sliceTemplate(int origin, Vector<Byte> v) {\n@@ -2286,4 +2284,13 @@\n-        VectorShuffle<Byte> iota = iotaShuffle();\n-        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        ByteVector that = (ByteVector) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), byte.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<ByteVector>() {\n+                @ForceInline\n+                public ByteVector apply(ByteVector v1, ByteVector v2, int o) {\n+                    VectorMask<Byte> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<Byte> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2308,5 +2315,0 @@\n-    public abstract\n-    ByteVector slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2314,6 +2316,3 @@\n-    ByteVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<Byte> iota = iotaShuffle();\n-        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    ByteVector slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Double128Vector slice(int origin) {\n-        return (Double128Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Double256Vector slice(int origin) {\n-        return (Double256Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Double512Vector slice(int origin) {\n-        return (Double512Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Double64Vector slice(int origin) {\n-        return (Double64Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector slice(int origin) {\n-        return (DoubleMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2124,3 +2124,1 @@\n-    DoubleVector sliceTemplate(int origin, Vector<Double> v1) {\n-        DoubleVector that = (DoubleVector) v1;\n-        that.check(this);\n+    DoubleVector sliceTemplate(int origin, Vector<Double> v) {\n@@ -2128,4 +2126,13 @@\n-        VectorShuffle<Double> iota = iotaShuffle();\n-        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        DoubleVector that = (DoubleVector) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), double.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<DoubleVector>() {\n+                @ForceInline\n+                public DoubleVector apply(DoubleVector v1, DoubleVector v2, int o) {\n+                    VectorMask<Double> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<Double> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2150,5 +2157,0 @@\n-    public abstract\n-    DoubleVector slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2156,6 +2158,3 @@\n-    DoubleVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<Double> iota = iotaShuffle();\n-        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    DoubleVector slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Float128Vector slice(int origin) {\n-        return (Float128Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Float256Vector slice(int origin) {\n-        return (Float256Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,6 +408,0 @@\n-    @Override\n-    @ForceInline\n-    public Float512Vector slice(int origin) {\n-        return (Float512Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -410,6 +410,0 @@\n-    public Float64Vector slice(int origin) {\n-        return (Float64Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -409,6 +409,0 @@\n-    @ForceInline\n-    public FloatMaxVector slice(int origin) {\n-        return (FloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2136,3 +2136,1 @@\n-    FloatVector sliceTemplate(int origin, Vector<Float> v1) {\n-        FloatVector that = (FloatVector) v1;\n-        that.check(this);\n+    FloatVector sliceTemplate(int origin, Vector<Float> v) {\n@@ -2140,4 +2138,13 @@\n-        VectorShuffle<Float> iota = iotaShuffle();\n-        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        FloatVector that = (FloatVector) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), float.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<FloatVector>() {\n+                @ForceInline\n+                public FloatVector apply(FloatVector v1, FloatVector v2, int o) {\n+                    VectorMask<Float> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<Float> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2162,5 +2169,0 @@\n-    public abstract\n-    FloatVector slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2168,6 +2170,3 @@\n-    FloatVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<Float> iota = iotaShuffle();\n-        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    FloatVector slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Int128Vector slice(int origin) {\n-        return (Int128Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Int256Vector slice(int origin) {\n-        return (Int256Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Int512Vector slice(int origin) {\n-        return (Int512Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Int64Vector slice(int origin) {\n-        return (Int64Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public IntMaxVector slice(int origin) {\n-        return (IntMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2267,3 +2267,1 @@\n-    IntVector sliceTemplate(int origin, Vector<Integer> v1) {\n-        IntVector that = (IntVector) v1;\n-        that.check(this);\n+    IntVector sliceTemplate(int origin, Vector<Integer> v) {\n@@ -2271,4 +2269,13 @@\n-        VectorShuffle<Integer> iota = iotaShuffle();\n-        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        IntVector that = (IntVector) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), int.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<IntVector>() {\n+                @ForceInline\n+                public IntVector apply(IntVector v1, IntVector v2, int o) {\n+                    VectorMask<Integer> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<Integer> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2293,5 +2300,0 @@\n-    public abstract\n-    IntVector slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2299,6 +2301,3 @@\n-    IntVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<Integer> iota = iotaShuffle();\n-        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    IntVector slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -411,6 +411,0 @@\n-    @Override\n-    @ForceInline\n-    public Long128Vector slice(int origin) {\n-        return (Long128Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -411,6 +411,0 @@\n-    @Override\n-    @ForceInline\n-    public Long256Vector slice(int origin) {\n-        return (Long256Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -411,6 +411,0 @@\n-    @Override\n-    @ForceInline\n-    public Long512Vector slice(int origin) {\n-        return (Long512Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -411,6 +411,0 @@\n-    @Override\n-    @ForceInline\n-    public Long64Vector slice(int origin) {\n-        return (Long64Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -411,6 +411,0 @@\n-    @Override\n-    @ForceInline\n-    public LongMaxVector slice(int origin) {\n-        return (LongMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2133,3 +2133,1 @@\n-    LongVector sliceTemplate(int origin, Vector<Long> v1) {\n-        LongVector that = (LongVector) v1;\n-        that.check(this);\n+    LongVector sliceTemplate(int origin, Vector<Long> v) {\n@@ -2137,4 +2135,13 @@\n-        VectorShuffle<Long> iota = iotaShuffle();\n-        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        LongVector that = (LongVector) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), long.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<LongVector>() {\n+                @ForceInline\n+                public LongVector apply(LongVector v1, LongVector v2, int o) {\n+                    VectorMask<Long> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<Long> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2159,5 +2166,0 @@\n-    public abstract\n-    LongVector slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2165,6 +2167,3 @@\n-    LongVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<Long> iota = iotaShuffle();\n-        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    LongVector slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Short128Vector slice(int origin) {\n-        return (Short128Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Short256Vector slice(int origin) {\n-        return (Short256Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -419,6 +419,0 @@\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public Short512Vector slice(int origin) {\n-        return (Short512Vector) super.sliceTemplate(origin);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public Short64Vector slice(int origin) {\n-        return (Short64Vector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -421,6 +421,0 @@\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector slice(int origin) {\n-        return (ShortMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2283,3 +2283,1 @@\n-    ShortVector sliceTemplate(int origin, Vector<Short> v1) {\n-        ShortVector that = (ShortVector) v1;\n-        that.check(this);\n+    ShortVector sliceTemplate(int origin, Vector<Short> v) {\n@@ -2287,4 +2285,13 @@\n-        VectorShuffle<Short> iota = iotaShuffle();\n-        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        ShortVector that = (ShortVector) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), short.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<ShortVector>() {\n+                @ForceInline\n+                public ShortVector apply(ShortVector v1, ShortVector v2, int o) {\n+                    VectorMask<Short> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<Short> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2309,5 +2316,0 @@\n-    public abstract\n-    ShortVector slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2315,6 +2317,3 @@\n-    ShortVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<Short> iota = iotaShuffle();\n-        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    ShortVector slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2659,3 +2659,1 @@\n-    $abstractvectortype$ sliceTemplate(int origin, Vector<$Boxtype$> v1) {\n-        $abstractvectortype$ that = ($abstractvectortype$) v1;\n-        that.check(this);\n+    $abstractvectortype$ sliceTemplate(int origin, Vector<$Boxtype$> v) {\n@@ -2663,4 +2661,13 @@\n-        VectorShuffle<$Boxtype$> iota = iotaShuffle();\n-        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+        $abstractvectortype$ that = ($abstractvectortype$) v;\n+        that.check(this);\n+        return VectorSupport.slice(\n+            getClass(), $type$.class, length(),\n+            this, that, origin,\n+            new VectorSliceOp<$Type$Vector>() {\n+                @ForceInline\n+                public $Type$Vector apply($Type$Vector v1, $Type$Vector v2, int o) {\n+                    VectorMask<$Boxtype$> blendMask = v1.vspecies().indexInRange(o, v1.length());\n+                    VectorShuffle<$Boxtype$> iota = v1.iotaShuffle(o, 1, true);\n+                    return v2.rearrange(iota).blend(v1.rearrange(iota), blendMask);\n+                }\n+            });\n@@ -2685,5 +2692,0 @@\n-    public abstract\n-    $abstractvectortype$ slice(int origin);\n-\n-    \/*package-private*\/\n-    final\n@@ -2691,6 +2693,3 @@\n-    $abstractvectortype$ sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length() + 1);\n-        VectorShuffle<$Boxtype$> iota = iotaShuffle();\n-        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n-        iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    public final\n+    $abstractvectortype$ slice(int origin) {\n+        return slice(origin, broadcast(0));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -426,6 +426,0 @@\n-\n-    @Override\n-    @ForceInline\n-    public $vectortype$ slice(int origin) {\n-        return ($vectortype$) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1181,0 +1181,5 @@\n+    public static final String VECTOR_SLICE = PREFIX + \"VECTOR_SLICE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_SLICE, \"VectorSlice\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,796 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.function.BiConsumer;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+* @test\n+* @bug 8287835\n+* @summary Test vector slice intrinsics\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.TestVectorSlice\n+*\/\n+public class TestVectorSlice {\n+    @Run(test = {\"testB64\", \"testB128\", \"testB256\", \"testB512\"})\n+    static void testBytes() {\n+        int maxSize = 64;\n+        int diff = 70;\n+        int length;\n+        byte[][] dst;\n+        byte[] src1 = new byte[maxSize];\n+        byte[] src2 = new byte[maxSize];\n+        for (int i = 0; i < src1.length; i++) {\n+            src1[i] = (byte)i;\n+            src2[i] = (byte)(i + diff);\n+        }\n+\n+        BiConsumer<byte[][], Integer> verifier = (byte[][] tgt, Integer len) -> {\n+            for (int i = 0; i <= len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    int offset = i + j;\n+                    byte expected;\n+                    if (offset < len) {\n+                        expected = (byte)offset;\n+                    } else {\n+                        expected = (byte)(offset + diff - len);\n+                    }\n+                    Asserts.assertEquals(expected, tgt[i][j]);\n+                }\n+            }\n+        };\n+\n+        length = 8;\n+        dst = new byte[length + 1][length];\n+        testB64(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 16;\n+        dst = new byte[length + 1][length];\n+        testB128(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 32;\n+        dst = new byte[length + 1][length];\n+        testB256(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 64;\n+        dst = new byte[length + 1][length];\n+        testB512(dst, src1, src2);\n+        verifier.accept(dst, length);\n+    }\n+\n+    @Run(test = {\"testS64\", \"testS128\", \"testS256\", \"testS512\"})\n+    static void testShorts() {\n+        int maxSize = 32;\n+        int diff = 70;\n+        int length;\n+        short[][] dst;\n+        short[] src1 = new short[maxSize];\n+        short[] src2 = new short[maxSize];\n+        for (int i = 0; i < src1.length; i++) {\n+            src1[i] = (short)i;\n+            src2[i] = (short)(i + diff);\n+        }\n+\n+        BiConsumer<short[][], Integer> verifier = (short[][] tgt, Integer len) -> {\n+            for (int i = 0; i <= len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    int offset = i + j;\n+                    short expected;\n+                    if (offset < len) {\n+                        expected = (short)offset;\n+                    } else {\n+                        expected = (short)(offset + diff - len);\n+                    }\n+                    Asserts.assertEquals(expected, tgt[i][j]);\n+                }\n+            }\n+        };\n+\n+        length = 4;\n+        dst = new short[length + 1][length];\n+        testS64(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 8;\n+        dst = new short[length + 1][length];\n+        testS128(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 16;\n+        dst = new short[length + 1][length];\n+        testS256(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 32;\n+        dst = new short[length + 1][length];\n+        testS512(dst, src1, src2);\n+        verifier.accept(dst, length);\n+    }\n+\n+    @Run(test = {\"testI64\", \"testI128\", \"testI256\", \"testI512\"})\n+    static void testInts() {\n+        int maxSize = 16;\n+        int diff = 70;\n+        int length;\n+        int[][] dst;\n+        int[] src1 = new int[maxSize];\n+        int[] src2 = new int[maxSize];\n+        for (int i = 0; i < src1.length; i++) {\n+            src1[i] = i;\n+            src2[i] = i + diff;\n+        }\n+\n+        BiConsumer<int[][], Integer> verifier = (int[][] tgt, Integer len) -> {\n+            for (int i = 0; i <= len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    int offset = i + j;\n+                    int expected;\n+                    if (offset < len) {\n+                        expected = offset;\n+                    } else {\n+                        expected = offset + diff - len;\n+                    }\n+                    Asserts.assertEquals(expected, tgt[i][j]);\n+                }\n+            }\n+        };\n+\n+        length = 2;\n+        dst = new int[length + 1][length];\n+        testI64(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 4;\n+        dst = new int[length + 1][length];\n+        testI128(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 8;\n+        dst = new int[length + 1][length];\n+        testI256(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 16;\n+        dst = new int[length + 1][length];\n+        testI512(dst, src1, src2);\n+        verifier.accept(dst, length);\n+    }\n+\n+    @Run(test = {\"testL128\", \"testL256\", \"testL512\"})\n+    static void testLongs() {\n+        int maxSize = 8;\n+        int diff = 70;\n+        int length;\n+        long[][] dst;\n+        long[] src1 = new long[maxSize];\n+        long[] src2 = new long[maxSize];\n+        for (int i = 0; i < src1.length; i++) {\n+            src1[i] = i;\n+            src2[i] = i + diff;\n+        }\n+\n+        BiConsumer<long[][], Integer> verifier = (long[][] tgt, Integer len) -> {\n+            for (int i = 0; i <= len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    int offset = i + j;\n+                    long expected;\n+                    if (offset < len) {\n+                        expected = offset;\n+                    } else {\n+                        expected = offset + diff - len;\n+                    }\n+                    Asserts.assertEquals(expected, tgt[i][j]);\n+                }\n+            }\n+        };\n+\n+        length = 2;\n+        dst = new long[length + 1][length];\n+        testL128(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 4;\n+        dst = new long[length + 1][length];\n+        testL256(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 8;\n+        dst = new long[length + 1][length];\n+        testL512(dst, src1, src2);\n+        verifier.accept(dst, length);\n+    }\n+\n+    @Run(test = {\"testF64\", \"testF128\", \"testF256\", \"testF512\"})\n+    static void testFloats() {\n+        int maxSize = 64;\n+        int diff = 70;\n+        int length;\n+        float[][] dst;\n+        float[] src1 = new float[maxSize];\n+        float[] src2 = new float[maxSize];\n+        for (int i = 0; i < src1.length; i++) {\n+            src1[i] = i;\n+            src2[i] = i + diff;\n+        }\n+\n+        BiConsumer<float[][], Integer> verifier = (float[][] tgt, Integer len) -> {\n+            for (int i = 0; i <= len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    int offset = i + j;\n+                    float expected;\n+                    if (offset < len) {\n+                        expected = offset;\n+                    } else {\n+                        expected = offset + diff - len;\n+                    }\n+                    Asserts.assertEquals(expected, tgt[i][j]);\n+                }\n+            }\n+        };\n+\n+        length = 2;\n+        dst = new float[length + 1][length];\n+        testF64(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 4;\n+        dst = new float[length + 1][length];\n+        testF128(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 8;\n+        dst = new float[length + 1][length];\n+        testF256(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 16;\n+        dst = new float[length + 1][length];\n+        testF512(dst, src1, src2);\n+        verifier.accept(dst, length);\n+    }\n+\n+    @Run(test = {\"testD128\", \"testD256\", \"testD512\"})\n+    static void testDoubles() {\n+        int maxSize = 64;\n+        int diff = 70;\n+        int length;\n+        double[][] dst;\n+        double[] src1 = new double[maxSize];\n+        double[] src2 = new double[maxSize];\n+        for (int i = 0; i < src1.length; i++) {\n+            src1[i] = i;\n+            src2[i] = i + diff;\n+        }\n+\n+        BiConsumer<double[][], Integer> verifier = (double[][] tgt, Integer len) -> {\n+            for (int i = 0; i <= len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    int offset = i + j;\n+                    double expected;\n+                    if (offset < len) {\n+                        expected = offset;\n+                    } else {\n+                        expected = offset + diff - len;\n+                    }\n+                    Asserts.assertEquals(expected, tgt[i][j]);\n+                }\n+            }\n+        };\n+\n+        length = 2;\n+        dst = new double[length + 1][length];\n+        testD128(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 4;\n+        dst = new double[length + 1][length];\n+        testD256(dst, src1, src2);\n+        verifier.accept(dst, length);\n+\n+        length = 8;\n+        dst = new double[length + 1][length];\n+        testD512(dst, src1, src2);\n+        verifier.accept(dst, length);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"9\"})\n+    static void testB64(byte[][] dst, byte[] src1, byte[] src2) {\n+        var species = ByteVector.SPECIES_64;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"17\"})\n+    static void testB128(byte[][] dst, byte[] src1, byte[] src2) {\n+        var species = ByteVector.SPECIES_128;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"33\"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    static void testB256(byte[][] dst, byte[] src1, byte[] src2) {\n+        var species = ByteVector.SPECIES_256;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+        helper(species, dst[17], src1, src2, 17);\n+        helper(species, dst[18], src1, src2, 18);\n+        helper(species, dst[19], src1, src2, 19);\n+        helper(species, dst[20], src1, src2, 20);\n+        helper(species, dst[21], src1, src2, 21);\n+        helper(species, dst[22], src1, src2, 22);\n+        helper(species, dst[23], src1, src2, 23);\n+        helper(species, dst[24], src1, src2, 24);\n+        helper(species, dst[25], src1, src2, 25);\n+        helper(species, dst[26], src1, src2, 26);\n+        helper(species, dst[27], src1, src2, 27);\n+        helper(species, dst[28], src1, src2, 28);\n+        helper(species, dst[29], src1, src2, 29);\n+        helper(species, dst[30], src1, src2, 30);\n+        helper(species, dst[31], src1, src2, 31);\n+        helper(species, dst[32], src1, src2, 32);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"65\"}, applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    static void testB512(byte[][] dst, byte[] src1, byte[] src2) {\n+        var species = ByteVector.SPECIES_512;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+        helper(species, dst[17], src1, src2, 17);\n+        helper(species, dst[18], src1, src2, 18);\n+        helper(species, dst[19], src1, src2, 19);\n+        helper(species, dst[20], src1, src2, 20);\n+        helper(species, dst[21], src1, src2, 21);\n+        helper(species, dst[22], src1, src2, 22);\n+        helper(species, dst[23], src1, src2, 23);\n+        helper(species, dst[24], src1, src2, 24);\n+        helper(species, dst[25], src1, src2, 25);\n+        helper(species, dst[26], src1, src2, 26);\n+        helper(species, dst[27], src1, src2, 27);\n+        helper(species, dst[28], src1, src2, 28);\n+        helper(species, dst[29], src1, src2, 29);\n+        helper(species, dst[30], src1, src2, 30);\n+        helper(species, dst[31], src1, src2, 31);\n+        helper(species, dst[32], src1, src2, 32);\n+        helper(species, dst[33], src1, src2, 33);\n+        helper(species, dst[34], src1, src2, 34);\n+        helper(species, dst[35], src1, src2, 35);\n+        helper(species, dst[36], src1, src2, 36);\n+        helper(species, dst[37], src1, src2, 37);\n+        helper(species, dst[38], src1, src2, 38);\n+        helper(species, dst[39], src1, src2, 39);\n+        helper(species, dst[40], src1, src2, 40);\n+        helper(species, dst[41], src1, src2, 41);\n+        helper(species, dst[42], src1, src2, 42);\n+        helper(species, dst[43], src1, src2, 43);\n+        helper(species, dst[44], src1, src2, 44);\n+        helper(species, dst[45], src1, src2, 45);\n+        helper(species, dst[46], src1, src2, 46);\n+        helper(species, dst[47], src1, src2, 47);\n+        helper(species, dst[48], src1, src2, 48);\n+        helper(species, dst[49], src1, src2, 49);\n+        helper(species, dst[50], src1, src2, 50);\n+        helper(species, dst[51], src1, src2, 51);\n+        helper(species, dst[52], src1, src2, 52);\n+        helper(species, dst[53], src1, src2, 53);\n+        helper(species, dst[54], src1, src2, 54);\n+        helper(species, dst[55], src1, src2, 55);\n+        helper(species, dst[56], src1, src2, 56);\n+        helper(species, dst[57], src1, src2, 57);\n+        helper(species, dst[58], src1, src2, 58);\n+        helper(species, dst[59], src1, src2, 59);\n+        helper(species, dst[60], src1, src2, 60);\n+        helper(species, dst[61], src1, src2, 61);\n+        helper(species, dst[62], src1, src2, 62);\n+        helper(species, dst[63], src1, src2, 63);\n+        helper(species, dst[64], src1, src2, 64);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"5\"})\n+    static void testS64(short[][] dst, short[] src1, short[] src2) {\n+        var species = ShortVector.SPECIES_64;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"9\"})\n+    static void testS128(short[][] dst, short[] src1, short[] src2) {\n+        var species = ShortVector.SPECIES_128;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"17\"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    static void testS256(short[][] dst, short[] src1, short[] src2) {\n+        var species = ShortVector.SPECIES_256;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"33\"}, applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    static void testS512(short[][] dst, short[] src1, short[] src2) {\n+        var species = ShortVector.SPECIES_512;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+        helper(species, dst[17], src1, src2, 17);\n+        helper(species, dst[18], src1, src2, 18);\n+        helper(species, dst[19], src1, src2, 19);\n+        helper(species, dst[20], src1, src2, 20);\n+        helper(species, dst[21], src1, src2, 21);\n+        helper(species, dst[22], src1, src2, 22);\n+        helper(species, dst[23], src1, src2, 23);\n+        helper(species, dst[24], src1, src2, 24);\n+        helper(species, dst[25], src1, src2, 25);\n+        helper(species, dst[26], src1, src2, 26);\n+        helper(species, dst[27], src1, src2, 27);\n+        helper(species, dst[28], src1, src2, 28);\n+        helper(species, dst[29], src1, src2, 29);\n+        helper(species, dst[30], src1, src2, 30);\n+        helper(species, dst[31], src1, src2, 31);\n+        helper(species, dst[32], src1, src2, 32);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"3\"})\n+    static void testI64(int[][] dst, int[] src1, int[] src2) {\n+        var species = IntVector.SPECIES_64;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"5\"})\n+    static void testI128(int[][] dst, int[] src1, int[] src2) {\n+        var species = IntVector.SPECIES_128;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"9\"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    static void testI256(int[][] dst, int[] src1, int[] src2) {\n+        var species = IntVector.SPECIES_256;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"17\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n+    static void testI512(int[][] dst, int[] src1, int[] src2) {\n+        var species = IntVector.SPECIES_512;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"3\"})\n+    static void testL128(long[][] dst, long[] src1, long[] src2) {\n+        var species = LongVector.SPECIES_128;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"5\"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    static void testL256(long[][] dst, long[] src1, long[] src2) {\n+        var species = LongVector.SPECIES_256;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"9\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n+    static void testL512(long[][] dst, long[] src1, long[] src2) {\n+        var species = LongVector.SPECIES_512;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"3\"})\n+    static void testF64(float[][] dst, float[] src1, float[] src2) {\n+        var species = FloatVector.SPECIES_64;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"5\"})\n+    static void testF128(float[][] dst, float[] src1, float[] src2) {\n+        var species = FloatVector.SPECIES_128;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"9\"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    static void testF256(float[][] dst, float[] src1, float[] src2) {\n+        var species = FloatVector.SPECIES_256;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"17\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n+    static void testF512(float[][] dst, float[] src1, float[] src2) {\n+        var species = FloatVector.SPECIES_512;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+        helper(species, dst[9], src1, src2, 9);\n+        helper(species, dst[10], src1, src2, 10);\n+        helper(species, dst[11], src1, src2, 11);\n+        helper(species, dst[12], src1, src2, 12);\n+        helper(species, dst[13], src1, src2, 13);\n+        helper(species, dst[14], src1, src2, 14);\n+        helper(species, dst[15], src1, src2, 15);\n+        helper(species, dst[16], src1, src2, 16);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"3\"})\n+    static void testD128(double[][] dst, double[] src1, double[] src2) {\n+        var species = DoubleVector.SPECIES_128;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"5\"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    static void testD256(double[][] dst, double[] src1, double[] src2) {\n+        var species = DoubleVector.SPECIES_256;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_SLICE, \"9\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n+    static void testD512(double[][] dst, double[] src1, double[] src2) {\n+        var species = DoubleVector.SPECIES_512;\n+        helper(species, dst[0], src1, src2, 0);\n+        helper(species, dst[1], src1, src2, 1);\n+        helper(species, dst[2], src1, src2, 2);\n+        helper(species, dst[3], src1, src2, 3);\n+        helper(species, dst[4], src1, src2, 4);\n+        helper(species, dst[5], src1, src2, 5);\n+        helper(species, dst[6], src1, src2, 6);\n+        helper(species, dst[7], src1, src2, 7);\n+        helper(species, dst[8], src1, src2, 8);\n+    }\n+\n+    @ForceInline\n+    static void helper(VectorSpecies<Byte> species, byte[] dst, byte[] src1, byte[] src2, int origin) {\n+        var v1 = ByteVector.fromArray(species, src1, 0);\n+        var v2 = ByteVector.fromArray(species, src2, 0);\n+        v1.slice(origin, v2).intoArray(dst, 0);\n+    }\n+\n+    @ForceInline\n+    static void helper(VectorSpecies<Short> species, short[] dst, short[] src1, short[] src2, int origin) {\n+        var v1 = ShortVector.fromArray(species, src1, 0);\n+        var v2 = ShortVector.fromArray(species, src2, 0);\n+        v1.slice(origin, v2).intoArray(dst, 0);\n+    }\n+\n+    @ForceInline\n+    static void helper(VectorSpecies<Integer> species, int[] dst, int[] src1, int[] src2, int origin) {\n+        var v1 = IntVector.fromArray(species, src1, 0);\n+        var v2 = IntVector.fromArray(species, src2, 0);\n+        v1.slice(origin, v2).intoArray(dst, 0);\n+    }\n+\n+    @ForceInline\n+    static void helper(VectorSpecies<Long> species, long[] dst, long[] src1, long[] src2, int origin) {\n+        var v1 = LongVector.fromArray(species, src1, 0);\n+        var v2 = LongVector.fromArray(species, src2, 0);\n+        v1.slice(origin, v2).intoArray(dst, 0);\n+    }\n+\n+    @ForceInline\n+    static void helper(VectorSpecies<Float> species, float[] dst, float[] src1, float[] src2, int origin) {\n+        var v1 = FloatVector.fromArray(species, src1, 0);\n+        var v2 = FloatVector.fromArray(species, src2, 0);\n+        v1.slice(origin, v2).intoArray(dst, 0);\n+    }\n+\n+    @ForceInline\n+    static void helper(VectorSpecies<Double> species, double[] dst, double[] src1, double[] src2, int origin) {\n+        var v1 = DoubleVector.fromArray(species, src1, 0);\n+        var v2 = DoubleVector.fromArray(species, src2, 0);\n+        v1.slice(origin, v2).intoArray(dst, 0);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(15000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorSlice.java","additions":796,"deletions":0,"binary":false,"changes":796,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+slice1_const_template=\"Slice-bop-const\"\n@@ -530,0 +531,1 @@\n+gen_op_tmpl $slice1_const_template \"sliceBinaryConstant\" \"\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Slice-bop-const.template","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"}]}