{"files":[{"patch":"@@ -37,1 +37,1 @@\n-#include \"jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackTraceRepository.inline.hpp\"\n@@ -42,1 +42,1 @@\n-#include \"jfr\/utilities\/jfrPredicate.hpp\"\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -51,1 +51,1 @@\n-const int initial_array_size = 64;\n+const unsigned int initial_size = 431;\n@@ -53,3 +53,2 @@\n-template <typename T>\n-static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {\n-  return new (mtTracing) GrowableArray<T>(size, mtTracing);\n+static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n+  return new JfrCHeapTraceIdSet(size);\n@@ -58,1 +57,1 @@\n-static GrowableArray<traceid>* unloaded_thread_id_set = nullptr;\n+static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n@@ -76,1 +75,1 @@\n-  return JfrPredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+  return unloaded_thread_id_set->contains(tid);\n@@ -82,1 +81,1 @@\n-    unloaded_thread_id_set = c_heap_allocate_array<traceid>();\n+    unloaded_thread_id_set = c_heap_allocate_set();\n@@ -84,1 +83,1 @@\n-  JfrMutablePredicate<traceid, compare_traceid>::test(unloaded_thread_id_set, tid);\n+  unloaded_thread_id_set->add(tid);\n@@ -197,1 +196,1 @@\n-static GrowableArray<traceid>* id_set = nullptr;\n+static JfrResourceAreaTraceIdSet* id_set = nullptr;\n@@ -200,1 +199,1 @@\n-  id_set = new GrowableArray<traceid>(JfrOptionSet::old_object_queue_size());\n+  id_set = new JfrResourceAreaTraceIdSet(initial_size);\n@@ -270,1 +269,0 @@\n-  JfrKlassUnloading::sort();\n@@ -320,1 +318,1 @@\n-  return JfrMutablePredicate<traceid, compare_traceid>::test(id_set, method_id);\n+  return !id_set->add(method_id);\n@@ -365,1 +363,40 @@\n-static GrowableArray<traceid>* _stacktrace_ids = nullptr;\n+static JfrResourceAreaTraceIdSet* _stacktrace_id_set = nullptr;\n+\n+static inline bool should_write(const JfrStackTrace* stacktrace) {\n+  assert(stacktrace != nullptr, \"invariant\");\n+  assert(_stacktrace_id_set != nullptr, \"invariant\");\n+  return stacktrace->should_write() && _stacktrace_id_set->contains(stacktrace->id());\n+}\n+\n+class LeakProfilerStackTraceWriter {\n+ private:\n+  JfrCheckpointWriter& _writer;\n+  int _count;\n+ public:\n+  LeakProfilerStackTraceWriter(JfrCheckpointWriter& writer) : _writer(writer), _count(0) {\n+    assert(_stacktrace_id_set != nullptr, \"invariant\");\n+  }\n+\n+  int count() const { return _count; }\n+\n+  void operator()(const JfrStackTrace* stacktrace) {\n+    if (should_write(stacktrace)) {\n+      stacktrace->write(_writer);\n+      ++_count;\n+    }\n+  }\n+};\n+\n+void ObjectSampleCheckpoint::write_stacktraces(Thread* thread) {\n+  assert(_stacktrace_id_set != nullptr, \"invariant\");\n+  assert(_stacktrace_id_set->is_nonempty(), \"invariant\");\n+\n+  JfrCheckpointWriter writer(thread);\n+  writer.write_type(TYPE_STACKTRACE);\n+  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n+\n+  LeakProfilerStackTraceWriter lpstw(writer);\n+  JfrStackTraceRepository::iterate_leakprofiler(lpstw);\n+  assert(lpstw.count() == _stacktrace_id_set->size(), \"invariant\");\n+  writer.write_count(lpstw.count(), count_offset);\n+}\n@@ -368,1 +405,2 @@\n-  assert(_stacktrace_ids != nullptr, \"invariant\");\n+  assert(sample != nullptr, \"invariant\");\n+  assert(_stacktrace_id_set != nullptr, \"invariant\");\n@@ -375,1 +413,1 @@\n-    _stacktrace_ids->append(stacktrace_id);\n+    _stacktrace_id_set->add(stacktrace_id);\n@@ -409,0 +447,5 @@\n+static inline unsigned int set_size() {\n+  const unsigned int queue_size = static_cast<unsigned int>(JfrOptionSet::old_object_queue_size());\n+  return queue_size > initial_size ? queue_size : initial_size;\n+}\n+\n@@ -415,1 +458,1 @@\n-    _stacktrace_ids = new GrowableArray<traceid>(JfrOptionSet::old_object_queue_size());\n+    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(set_size());\n@@ -417,3 +460,2 @@\n-    if (_stacktrace_ids->is_nonempty()) {\n-      _stacktrace_ids->sort(sort_traceid);\n-      JfrStackTraceRepository::write_leak_profiler(_stacktrace_ids, thread);\n+    if (_stacktrace_id_set->is_nonempty()) {\n+      write_stacktraces(thread);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":63,"deletions":21,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  static void write_stacktraces(Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1228,3 +1228,0 @@\n-  if (!_class_unload) {\n-    JfrKlassUnloading::sort(previous_epoch());\n-  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-static const size_t initial_klass_list_size = 256;\n+static const size_t initial_klass_list_size = 4096;\n@@ -52,3 +52,1 @@\n-  \/\/ resource allocation\n-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n+  \/\/ Resource allocations. Keep in this allocation order.\n@@ -56,0 +54,2 @@\n+  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n+  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n@@ -66,1 +66,2 @@\n-  \/\/ _klass_list and _klass_loader_list will be cleared by a ResourceMark\n+  \/\/ _klass_loader_set, _klass_loader_leakp_set and\n+  \/\/ _klass_list will be cleared by a ResourceMark\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+  friend class LeakProfilerStackTraceWriter;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-#include \"jfr\/utilities\/jfrPredicate.hpp\"\n-#include \"jfr\/utilities\/jfrRelation.hpp\"\n@@ -33,1 +31,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -51,1 +48,1 @@\n-static JfrStackTraceRepository& leak_profiler_instance() {\n+JfrStackTraceRepository& JfrStackTraceRepository::leak_profiler_instance() {\n@@ -248,33 +245,0 @@\n-\n-static inline bool should_write(const JfrStackTrace* stacktrace, GrowableArray<traceid>* leakp_set) {\n-  assert(stacktrace != nullptr, \"invariant\");\n-  return stacktrace->should_write() && JfrPredicate<traceid, compare_traceid>::test(leakp_set, stacktrace->id());\n-}\n-\n-void JfrStackTraceRepository::write_leak_profiler(GrowableArray<traceid>* leakp_set, Thread* t) {\n-  assert(leakp_set != nullptr, \"invariant\");\n-  assert(leakp_set->is_nonempty(), \"invariant\");\n-  assert(t != nullptr, \"invariant\");\n-\n-  JfrCheckpointWriter writer(t);\n-  writer.write_type(TYPE_STACKTRACE);\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n-  int count = 0;\n-  const JfrStackTraceRepository& repo = leak_profiler_instance();\n-\n-  for (u4 i = 0; i < TABLE_SIZE; ++i) {\n-    const JfrStackTrace* stacktrace = repo._table[i];\n-    while (stacktrace != nullptr) {\n-      if (should_write(stacktrace, leakp_set)) {\n-        stacktrace->write(writer);\n-        ++count;\n-      }\n-      stacktrace = stacktrace->next();\n-    }\n-  }\n-\n-  assert(count > 0, \"invariant\");\n-  assert(count <= leakp_set->length(), \"invariant\");\n-  writer.write_count(count, count_offset);\n-}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-template <typename>\n-class GrowableArray;\n-\n@@ -57,0 +54,1 @@\n+  static JfrStackTraceRepository& leak_profiler_instance();\n@@ -67,1 +65,0 @@\n-  static void write_leak_profiler(GrowableArray<traceid>* leakp_set, Thread* t);\n@@ -70,0 +67,3 @@\n+  template <typename Callback>\n+  static void iterate_leakprofiler(Callback& cb);\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKTRACEREPOSITORY_INLINE_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKTRACEREPOSITORY_INLINE_HPP\n+\n+#include \"jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp\"\n+\n+template <typename Callback>\n+inline void JfrStackTraceRepository::iterate_leakprofiler(Callback& cb) {\n+  JfrStackTraceRepository& repo = leak_profiler_instance();\n+  for (u4 i = 0; i < TABLE_SIZE; ++i) {\n+    const JfrStackTrace* stacktrace = repo._table[i];\n+    while (stacktrace != nullptr) {\n+      cb(stacktrace);\n+      stacktrace = stacktrace->next();\n+    }\n+  }\n+}\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKTRACEREPOSITORY_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -357,1 +357,0 @@\n-    JfrKlassUnloading::sort(true);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-#include \"jfr\/utilities\/jfrPredicate.hpp\"\n-#include \"jfr\/utilities\/jfrRelation.hpp\"\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -34,1 +33,1 @@\n-static const int initial_array_size = 64;\n+static const int initial_size = 1009;\n@@ -36,3 +35,2 @@\n-template <typename T>\n-static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {\n-  return new (mtTracing) GrowableArray<T>(size, mtTracing);\n+static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n+  return new JfrCHeapTraceIdSet(size);\n@@ -42,2 +40,2 @@\n-static GrowableArray<traceid>* _unload_set_epoch_0 = nullptr;\n-static GrowableArray<traceid>* _unload_set_epoch_1 = nullptr;\n+static JfrCHeapTraceIdSet* _unload_set_epoch_0 = nullptr;\n+static JfrCHeapTraceIdSet* _unload_set_epoch_1 = nullptr;\n@@ -47,1 +45,1 @@\n-static GrowableArray<traceid>* unload_set_epoch_0() {\n+static JfrCHeapTraceIdSet* unload_set_epoch_0() {\n@@ -49,1 +47,1 @@\n-    _unload_set_epoch_0 = c_heap_allocate_array<traceid>(initial_array_size);\n+    _unload_set_epoch_0 = c_heap_allocate_set();\n@@ -54,1 +52,1 @@\n-static GrowableArray<traceid>* unload_set_epoch_1() {\n+static JfrCHeapTraceIdSet* unload_set_epoch_1() {\n@@ -56,1 +54,1 @@\n-    _unload_set_epoch_1 = c_heap_allocate_array<traceid>(initial_array_size);\n+    _unload_set_epoch_1 = c_heap_allocate_set();\n@@ -61,1 +59,1 @@\n-static GrowableArray<traceid>* get_unload_set(u1 epoch) {\n+static JfrCHeapTraceIdSet* get_unload_set(u1 epoch) {\n@@ -65,1 +63,1 @@\n-static GrowableArray<traceid>* get_unload_set() {\n+static JfrCHeapTraceIdSet* get_unload_set() {\n@@ -69,1 +67,1 @@\n-static GrowableArray<traceid>* get_unload_set_previous_epoch() {\n+static JfrCHeapTraceIdSet* get_unload_set_previous_epoch() {\n@@ -73,6 +71,0 @@\n-static void sort_set(GrowableArray<traceid>* set) {\n-  assert(set != nullptr, \"invariant\");\n-  assert(set->is_nonempty(), \"invariant\");\n-  set->sort(sort_traceid);\n-}\n-\n@@ -86,10 +78,0 @@\n-void JfrKlassUnloading::sort(bool previous_epoch) {\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  if (is_nonempty_set(JfrTraceIdEpoch::current())) {\n-    sort_set(get_unload_set());\n-  }\n-  if (previous_epoch && is_nonempty_set(JfrTraceIdEpoch::previous())) {\n-    sort_set(get_unload_set_previous_epoch());\n-  }\n-}\n-\n@@ -105,1 +87,1 @@\n-  GrowableArray<traceid>* const unload_set = get_unload_set();\n+  JfrCHeapTraceIdSet* const unload_set = get_unload_set();\n@@ -107,2 +89,1 @@\n-  assert(unload_set->find(klass_id) == -1, \"invariant\");\n-  unload_set->append(klass_id);\n+  unload_set->add(klass_id);\n@@ -134,0 +115,5 @@\n+static inline bool is_unloaded(const JfrCHeapTraceIdSet* set, const traceid& id) {\n+  assert(set != nullptr, \"invariant\");\n+  return set->contains(id);\n+}\n+\n@@ -137,1 +123,1 @@\n-    if (JfrPredicate<traceid, compare_traceid>::test(get_unload_set_previous_epoch(), klass_id)) {\n+    if (::is_unloaded(get_unload_set_previous_epoch(), klass_id)) {\n@@ -141,1 +127,1 @@\n-  return JfrPredicate<traceid, compare_traceid>::test(get_unload_set(), klass_id);\n+  return ::is_unloaded(get_unload_set(), klass_id);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":22,"deletions":36,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-  static void sort(bool previous_epoch = false);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_UTILITIES_JFRSET_HPP\n+#define SHARE_JFR_UTILITIES_JFRSET_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+\n+template <typename AllocPolicy = JfrCHeapObj, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n+class ConfigTraceID : public AllStatic {\n+ public:\n+  typedef AllocPolicy STORAGE;\n+  typedef traceid TYPE;\n+\n+  constexpr static AnyObj::allocation_type alloc_type() {\n+    return AllocType;\n+  }\n+\n+  constexpr static MemTag memory_tag() {\n+    return memtag;\n+  }\n+\n+  \/\/ Knuth multiplicative hashing.\n+  static uint32_t hash(const TYPE& id) {\n+    const uint32_t v = static_cast<uint32_t>(id);\n+    return v * UINT32_C(2654435761);\n+  }\n+\n+  static bool cmp(const TYPE& lhs, const TYPE& rhs) {\n+    return lhs == rhs;\n+  }\n+};\n+\n+constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n+\n+template <typename CONFIG>\n+class JfrSet : public CONFIG::STORAGE {\n+ public:\n+  typedef typename CONFIG::TYPE TYPE;\n+  typedef ResizeableResourceHashtable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n+\n+  constexpr static bool is_cheap() {\n+    return CONFIG::alloc_type() == AnyObj::C_HEAP;\n+  }\n+\n+  JfrSet(unsigned int initial_size, unsigned int max_size = MAX_TABLE_SIZE) :\n+    _map(is_cheap() ? new (CONFIG::memory_tag()) HashMap(initial_size, max_size) : new HashMap(initial_size, max_size)) {}\n+\n+  ~JfrSet() {\n+    if (is_cheap()) {\n+      delete _map;\n+    }\n+  }\n+\n+  bool add(const TYPE& k) {\n+    bool inserted;\n+    _map->put_if_absent(k, &inserted);\n+    return inserted;\n+  }\n+\n+  bool remove(const TYPE& k) {\n+    return _map->remove(k);\n+  }\n+\n+  bool contains(const TYPE& k) const {\n+    return _map->contains(k);\n+  }\n+\n+  bool is_empty() const {\n+    return _map->number_of_entries() == 0;\n+  }\n+\n+  bool is_nonempty() const {\n+    return !is_empty();\n+  }\n+\n+  int size() const {\n+    return _map->number_of_entries();\n+  }\n+\n+  void clear() {\n+    if (is_nonempty()) {\n+      _map->unlink(this);\n+    }\n+    assert(is_empty(), \"invariant\");\n+  }\n+\n+  \/\/ Callback for node deletion, used by clear().\n+  bool do_entry(const TYPE& k, const TYPE& v) {\n+    return true;\n+  }\n+\n+ private:\n+  HashMap* _map;\n+};\n+\n+typedef JfrSet<ConfigTraceID<> > JfrCHeapTraceIdSet;\n+typedef JfrSet<ConfigTraceID<ResourceObj, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n+\n+#endif \/\/ SHARE_JFR_UTILITIES_JFRSET_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}