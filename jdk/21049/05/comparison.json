{"files":[{"patch":"@@ -387,0 +387,1 @@\n+      - test-macos-aarch64\n","filename":".github\/workflows\/main.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+# JDK Vulnerabilities\n+\n+Please follow the process outlined in the [OpenJDK Vulnerability Policy](https:\/\/openjdk.org\/groups\/vulnerability\/report) to disclose vulnerabilities in the JDK.\n","filename":"SECURITY.md","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -617,4 +617,3 @@\n-<p>You will need the Xcode command line developer tools to be able to\n-build the JDK. (Actually, <em>only<\/em> the command line tools are\n-needed, not the IDE.) The simplest way to install these is to run:<\/p>\n-<pre><code>xcode-select --install<\/code><\/pre>\n+<p>You will need to download Xcode either from the App Store or specific\n+versions can be easily located via the <a\n+href=\"https:\/\/xcodereleases.com\">Xcode Releases<\/a> website.<\/p>\n","filename":"doc\/building.html","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -425,7 +425,3 @@\n-You will need the Xcode command line developer tools to be able to build the\n-JDK. (Actually, *only* the command line tools are needed, not the IDE.) The\n-simplest way to install these is to run:\n-\n-```\n-xcode-select --install\n-```\n+You will need to download Xcode either from the App Store or specific versions\n+can be easily located via the [Xcode Releases](https:\/\/xcodereleases.com)\n+website.\n","filename":"doc\/building.md","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,6 +72,0 @@\n-\/\/-----------------------------------------------------------------------------\n-\n-extern \"C\" void entry(CodeBuffer*);\n-\n-\/\/-----------------------------------------------------------------------------\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1081,0 +1081,1 @@\n+    case Interpreter::java_lang_math_tanh : \/* run interpreted *\/ break;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -708,0 +708,10 @@\n+  void fencei() {\n+    unsigned insn = 0;\n+    patch((address)&insn,  6,  0, 0b0001111);      \/\/ opcode\n+    patch((address)&insn, 11,  7, 0b00000);        \/\/ rd\n+    patch((address)&insn, 14, 12, 0b001);          \/\/ func\n+    patch((address)&insn, 19, 15, 0b00000);        \/\/ rs1\n+    patch((address)&insn, 31, 20, 0b000000000000); \/\/ fm\n+    emit(insn);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -639,2 +639,14 @@\n-  \/\/ A full fence is generated before icache_flush by default in invalidate_word\n-  ICache::invalidate_range(addr, bytes);\n+  \/\/ If we are using UseCtxFencei no ICache invalidation is needed here.\n+  \/\/ Instead every hart will preform an fence.i either by a Java thread\n+  \/\/ (due to patching epoch will take it to slow path),\n+  \/\/ or by the kernel when a Java thread is moved to a hart.\n+  \/\/ The instruction streams changes must only happen before the disarm of\n+  \/\/ the nmethod barrier. Where the disarm have a leading full two way fence.\n+  \/\/ If this is performed during a safepoint, all Java threads will emit a fence.i\n+  \/\/ before transitioning to 'Java', e.g. leaving native or the safepoint wait barrier.\n+  if (!UseCtxFencei) {\n+    \/\/ ICache invalidation is a serialization point.\n+    \/\/ The above patching of instructions happens before the invalidation.\n+    \/\/ Hence it have a leading full two way fence (wr, wr).\n+    ICache::invalidate_range(addr, bytes);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -125,1 +125,3 @@\n-          \"Far calls uses jal to trampoline.\")\n+          \"Far calls uses jal to trampoline.\")                                   \\\n+  product(bool, UseCtxFencei, false, EXPERIMENTAL,                               \\\n+          \"Use PR_RISCV_CTX_SW_FENCEI_ON to avoid explicit icache flush\")\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1458,0 +1458,1 @@\n+#ifdef COMPILER2\n@@ -1553,0 +1554,1 @@\n+#endif \/\/ COMPILER2\n@@ -1579,0 +1581,1 @@\n+#ifdef COMPILER2\n@@ -1584,0 +1587,1 @@\n+#endif \/\/ COMPILER2\n@@ -1646,0 +1650,1 @@\n+#ifdef COMPILER2\n@@ -1658,0 +1663,1 @@\n+#endif \/\/ COMPILER2\n@@ -2088,7 +2094,1 @@\n-  if (is_simm12(-decrement)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n+  add(Rd, Rn, -decrement, temp);\n@@ -2098,7 +2098,1 @@\n-  if (is_simm12(-decrement)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n+  addw(Rd, Rn, -decrement, temp);\n@@ -3174,0 +3168,7 @@\n+void MacroAssembler::cmodx_fence() {\n+  BLOCK_COMMENT(\"cmodx fence\");\n+  if (VM_Version::supports_fencei_barrier()) {\n+    Assembler::fencei();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -434,0 +434,2 @@\n+  void cmodx_fence();\n+\n@@ -1322,0 +1324,2 @@\n+\n+#ifdef COMPILER2\n@@ -1326,1 +1330,0 @@\n-#ifdef COMPILER2\n@@ -1356,1 +1359,1 @@\n-#endif\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,15 @@\n-  ICache::invalidate_range(addr(), bytes);\n+\n+  \/\/ If we are using UseCtxFencei no ICache invalidation is needed here.\n+  \/\/ Instead every hart will preform an fence.i either by a Java thread\n+  \/\/ (due to patching epoch will take it to slow path),\n+  \/\/ or by the kernel when a Java thread is moved to a hart.\n+  \/\/ The instruction streams changes must only happen before the disarm of\n+  \/\/ the nmethod barrier. Where the disarm have a leading full two way fence.\n+  \/\/ If this is performed during a safepoint, all Java threads will emit a fence.i\n+  \/\/ before transitioning to 'Java', e.g. leaving native or the safepoint wait barrier.\n+  if (!UseCtxFencei) {\n+    \/\/ ICache invalidation is a serialization point.\n+    \/\/ The above patching of instructions happens before the invalidation.\n+    \/\/ Hence it have a leading full two way fence (wr, wr).\n+    ICache::invalidate_range(addr(), bytes);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4898,1 +4898,0 @@\n-    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n@@ -4902,1 +4901,1 @@\n-    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);\n@@ -4932,1 +4931,0 @@\n-    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n@@ -4936,1 +4934,1 @@\n-    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg), (int)sew);\n@@ -4972,1 +4970,0 @@\n-    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n@@ -4976,1 +4973,1 @@\n-    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg), (int)sew);\n@@ -5006,1 +5003,0 @@\n-    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n@@ -5010,1 +5006,1 @@\n-    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg), (int)sew);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2431,0 +2431,8 @@\n+      \/\/ There are two ways this can work:\n+      \/\/ - The writer did system icache shootdown after the instruction stream update.\n+      \/\/   Hence do nothing.\n+      \/\/ - The writer trust us to make sure our icache is in sync before entering.\n+      \/\/   Hence use cmodx fence (fence.i, may change).\n+      if (UseCtxFencei) {\n+        __ cmodx_fence();\n+      }\n@@ -5494,1 +5502,0 @@\n-      Register minusOne  = x30;   \/\/ t5\n@@ -5496,1 +5503,0 @@\n-      __ mv(minusOne, -1);\n@@ -5516,1 +5522,2 @@\n-      __ bne(failedIdx, minusOne, Exit);\n+      \/\/ valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);\n@@ -5536,1 +5543,2 @@\n-      __ bne(failedIdx, minusOne, Exit);\n+      \/\/ valid value of failedIdx can only be -1 when < 0\n+      __ bgez(failedIdx, Exit);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -288,0 +288,1 @@\n+  static bool supports_fencei_barrier() { return ext_Zifencei.enabled(); }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    lightweight_lock(Roop, Rmark, tmp, slow_case);\n+    lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  compiler_fast_lock_lightweight_object(obj, temp1, temp2);\n+  compiler_fast_lock_lightweight_object(obj, box, temp1, temp2);\n@@ -42,1 +42,1 @@\n-  compiler_fast_unlock_lightweight_object(obj, temp1, temp2);\n+  compiler_fast_unlock_lightweight_object(obj, box, temp1, temp2);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-static const int native_invoker_code_base_size = 512;\n-static const int native_invoker_size_per_args = 8;\n+static const int native_invoker_code_base_size = 384;\n+static const int native_invoker_size_per_args = 12;\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-    lightweight_lock(object, header, tmp, slow_case);\n+    lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6010,1 +6010,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register temp1, Register temp2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -6013,1 +6013,1 @@\n-  assert_different_registers(obj, temp1, temp2);\n+  assert_different_registers(basic_lock, obj, temp1, temp2);\n@@ -6025,0 +6025,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    const Address om_cache_addr = Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes())));\n+    z_mvghi(om_cache_addr, 0);\n+  }\n@@ -6148,2 +6153,2 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n-  assert_different_registers(obj, tmp1, tmp2);\n+void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, box, tmp1, tmp2);\n@@ -6158,0 +6163,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    z_mvghi(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n+\n@@ -6222,0 +6232,1 @@\n+    const Register tmp1_monitor = tmp1;\n@@ -6223,20 +6234,1 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tagged_monitor = mark;\n-      const Register zero           = tmp2;\n-\n-      \/\/ Try to CAS m->owner from null to current thread.\n-      \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-      \/\/ Otherwise, register zero is filled with the current owner.\n-      z_lghi(zero, 0);\n-      z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n-      z_bre(locked);\n-\n-      \/\/ Check if recursive.\n-      z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n-      z_brne(slow_path);\n-\n-      \/\/ Recursive\n-      z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-      z_cgr(zero, zero);\n-      \/\/ z_bru(locked);\n-      \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+      assert(tmp1_monitor == mark, \"should be the same here\");\n@@ -6244,3 +6236,28 @@\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      z_ltgr(obj, obj);\n+      NearLabel monitor_found;\n+\n+      \/\/ load cache address\n+      z_la(tmp1, Address(Z_thread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        z_cg(obj, Address(tmp1));\n+        z_bre(monitor_found);\n+        add2reg(tmp1, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      NearLabel loop;\n+      \/\/ Search for obj in cache\n+\n+      bind(loop);\n+\n+      \/\/ check for match.\n+      z_cg(obj, Address(tmp1));\n+      z_bre(monitor_found);\n+\n+      \/\/ search until null encountered, guaranteed _null_sentinel at end.\n+      add2reg(tmp1, in_bytes(OMCache::oop_to_oop_difference()));\n+      z_cghsi(0, tmp1, 0);\n+      z_brne(loop); \/\/ if not EQ to 0, go for another loop\n+\n+      \/\/ we reached to the end, cache miss\n+      z_ltgr(obj, obj); \/\/ set CC to NE\n@@ -6248,0 +6265,4 @@\n+\n+      \/\/ cache hit\n+      bind(monitor_found);\n+      z_lg(tmp1_monitor, Address(tmp1, OMCache::oop_to_monitor_difference()));\n@@ -6249,0 +6270,33 @@\n+    NearLabel monitor_locked;\n+    \/\/ lock the monitor\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register tagged_monitor = mark;\n+    const Register zero           = tmp2;\n+\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, owner_address);\n+    z_bre(monitor_locked);\n+\n+    \/\/ Check if recursive.\n+    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+    z_brne(slow_path);\n+\n+    \/\/ Recursive\n+    z_agsi(recursions_address, 1ll);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock\n+      z_stg(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n+    \/\/ set the CC now\n+    z_cgr(obj, obj);\n@@ -6273,2 +6327,2 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n-  assert_different_registers(obj, tmp1, tmp2);\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, box, tmp1, tmp2);\n@@ -6277,1 +6331,1 @@\n-  NearLabel inflated, inflated_load_monitor;\n+  NearLabel inflated, inflated_load_mark;\n@@ -6297,1 +6351,1 @@\n-    branch_optimized(bcondNotEqual, inflated_load_monitor);\n+    branch_optimized(bcondNotEqual, inflated_load_mark);\n@@ -6318,0 +6372,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -6356,1 +6413,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -6381,0 +6438,2 @@\n+    const Register tmp1_monitor = tmp1;\n+\n@@ -6382,2 +6441,6 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register monitor = mark;\n+      assert(tmp1_monitor == mark, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      z_lg(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      z_cghi(tmp1_monitor, alignof(ObjectMonitor*));\n@@ -6385,2 +6448,2 @@\n-      NearLabel not_recursive;\n-      const Register recursions = tmp2;\n+      z_brl(slow_path);\n+    }\n@@ -6388,3 +6451,2 @@\n-      \/\/ Check if recursive.\n-      load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-      z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n@@ -6392,4 +6454,5 @@\n-      \/\/ Recursive unlock\n-      z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-      z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n-      z_bru(unlocked);\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -6397,1 +6460,2 @@\n-      bind(not_recursive);\n+    NearLabel not_recursive;\n+    const Register recursions = tmp2;\n@@ -6399,6 +6463,3 @@\n-      NearLabel not_ok;\n-      \/\/ Check if the entry lists are empty.\n-      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-      z_brne(not_ok);\n-      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-      z_brne(not_ok);\n+    \/\/ Check if recursive.\n+    load_and_test_long(recursions, recursions_address);\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -6406,2 +6467,4 @@\n-      z_release();\n-      z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+    \/\/ Recursive unlock\n+    z_agsi(recursions_address, -1ll);\n+    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+    z_bru(unlocked);\n@@ -6409,1 +6472,1 @@\n-      z_bru(unlocked); \/\/ CC = EQ here\n+    bind(not_recursive);\n@@ -6411,1 +6474,6 @@\n-      bind(not_ok);\n+    NearLabel not_ok;\n+    \/\/ Check if the entry lists are empty.\n+    load_and_test_long(tmp2, EntryList_address);\n+    z_brne(not_ok);\n+    load_and_test_long(tmp2, cxq_address);\n+    z_brne(not_ok);\n@@ -6413,11 +6481,12 @@\n-      \/\/ The owner may be anonymous, and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n-      z_bru(slow_path); \/\/ CC = NE here\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      z_ltgr(obj, obj);\n-      z_bru(slow_path);\n-    }\n+    z_release();\n+    z_stg(tmp2 \/*=0*\/, owner_address);\n+\n+    z_bru(unlocked); \/\/ CC = EQ here\n+\n+    bind(not_ok);\n+\n+    \/\/ The owner may be anonymous, and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    z_stg(Z_thread, owner_address);\n+    z_bru(slow_path); \/\/ CC = NE here\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":134,"deletions":65,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Label& slow);\n@@ -757,2 +757,2 @@\n-  void compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n-  void compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n+  void compiler_fast_lock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2);\n+  void compiler_fast_unlock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -1716,1 +1717,1 @@\n-      __ compiler_fast_lock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+      __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1920,1 +1921,1 @@\n-      __ compiler_fast_unlock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+      __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1227,0 +1227,1 @@\n+    case Interpreter::java_lang_math_tanh : \/* run interpreted *\/ break;\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -8051,0 +8051,8 @@\n+void Assembler::andnpd(XMMRegister dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ !_legacy_mode_dq, \/* legacy_mode *\/ _legacy_mode_dq, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x55, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2634,0 +2634,1 @@\n+  void andnpd(XMMRegister dst, XMMRegister src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -810,1 +810,5 @@\n-      x->id() == vmIntrinsics::_dlog10) {\n+      x->id() == vmIntrinsics::_dlog10\n+#ifdef _LP64\n+      || x->id() == vmIntrinsics::_dtanh\n+#endif\n+      ) {\n@@ -992,1 +996,1 @@\n-      __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args());\n+        __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args());\n@@ -997,0 +1001,6 @@\n+    case vmIntrinsics::_dtanh:\n+       assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n+       if (StubRoutines::dtanh() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dtanh(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3576,0 +3576,3 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtanh)) {\n+      StubRoutines::_dtanh = generate_libmTanh(); \/\/ from stubGenerator_x86_64_tanh.cpp\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -549,0 +549,1 @@\n+  address generate_libmTanh();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,502 @@\n+\/*\n+* Copyright (c) 2024, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION\n+\/\/                     ---------------------\n+\/\/\n+\/\/ tanh(x)=(exp(x)-exp(-x))\/(exp(x)+exp(-x))=(1-exp(-2*x))\/(1+exp(-2*x))\n+\/\/\n+\/\/ Let |x|=xH+xL (upper 26 bits, lower 27 bits)\n+\/\/ log2(e) rounded to 26 bits (high part) plus a double precision low part is\n+\/\/         L2EH+L2EL (upper 26, lower 53 bits)\n+\/\/\n+\/\/ Let xH*L2EH=k+f+r`, where (k+f)*2^8*2=int(xH*L2EH*2^9),\n+\/\/                             f=0.b1 b2 ... b8, k integer\n+\/\/ 2^{-f} is approximated as Tn[f]+Dn[f]\n+\/\/ Tn stores the high 53 bits, Dn stores (2^{-f}-Tn[f]) rounded to double precision\n+\/\/\n+\/\/  r=r`+xL*L2EH+|x|*L2EL, |r|<2^{-9}+2^{-14},\n+\/\/                      for |x| in [23\/64,3*2^7)\n+\/\/ e^{-2*|x|}=2^{-k-f}*2^{-r} ~ 2^{-k}*(Tn+Dn)*(1+p)=(T0+D0)*(1+p)\n+\/\/\n+\/\/ For |x| in [2^{-4},2^5):\n+\/\/         2^{-r}-1 ~ p=c1*r+c2*r^2+..+c5*r^5\n+\/\/      Let R=1\/(1+T0+p*T0), truncated to 35 significant bits\n+\/\/  R=1\/(1+T0+D0+p*(T0+D0))*(1+eps), |eps|<2^{-33}\n+\/\/  1+T0+D0+p*(T0+D0)=KH+KL, where\n+\/\/       KH=(1+T0+c1*r*T0)_high (leading 17 bits)\n+\/\/       KL=T0_low+D0+(c1*r*T0)_low+c1*r*D0+(c2*r^2+..c5*r^5)*T0\n+\/\/  eps ~ (R*KH-1)+R*KL\n+\/\/  1\/(1+T0+D0+p*(T0+D0)) ~ R-R*eps\n+\/\/  The result is approximated as (1-T0-D0-(T0+D0)*p)*(R-R*eps)\n+\/\/  1-T0-D0-(T0+D0)*p=-((KH-2)+KL)\n+\/\/    The result is formed as\n+\/\/    (KH-2)*R+(-(KH-2)*R*eps+(KL*R-KL*R*eps)), with the correct sign\n+\/\/                                                  set at the end\n+\/\/\n+\/\/ For |x| in [2^{-64},2^{-4}):\n+\/\/  A Taylor series expansion is used  (x+p3*x^3+..+p13*x^{13})\n+\/\/\n+\/\/ For |x|<2^{-64}:  x is returned\n+\/\/\n+\/\/ For |x|>=2^32: return +\/-1\n+\/\/\n+\/\/ Special cases:\n+\/\/  tanh(NaN) = quiet NaN, and raise invalid exception\n+\/\/  tanh(INF) = that INF\n+\/\/  tanh(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _HALFMASK[] =\n+{\n+    4160749568, 2147483647\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _ONEMASK[] =\n+{\n+    0, 1072693248\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _TWOMASK[] =\n+{\n+    0, 1073741824\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _MASK3[] =\n+{\n+    0, 4294967280, 0, 4294967280\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _RMASK[] =\n+{\n+    4294705152, 4294967295, 4294705152, 4294967295\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _L2E[] =\n+{\n+    1610612736, 1082594631, 4166901572, 1055174155\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _Shifter[] =\n+{\n+    0, 1127743488, 0, 3275227136\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _cv[] =\n+{\n+    3884607281, 3168131199, 3607404735, 3190582024, 1874480759,\n+    1032041131, 4286760334, 1053736893, 4277811695, 3211144770,\n+    0,          0\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _pv[] =\n+{\n+    236289503,  1064135997, 463583772,  3215696314, 1441186365,\n+    3212977891, 286331153,  1069617425, 2284589306, 1066820852,\n+    1431655765, 3218429269\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _T2_neg_f[] =\n+{\n+    0,          1072693248, 0,          0,          1797923801, 1072687577,\n+    1950547427, 1013229059, 730821105,  1072681922, 2523232743, 1012067188,\n+    915592468,  1072676282, 352947894,  3161024371, 2174652632, 1072670657,\n+    4087714590, 1014450259, 35929225,   1072665048, 2809788041, 3159436968,\n+    2912730644, 1072659453, 3490067722, 3163405074, 2038973688, 1072653874,\n+    892941374,  1016046459, 1533953344, 1072648310, 769171851,  1015665633,\n+    1222472308, 1072642761, 1054357470, 3161021018, 929806999,  1072637227,\n+    3205336643, 1015259557, 481706282,  1072631708, 1696079173, 3162710528,\n+    3999357479, 1072626203, 2258941616, 1015924724, 2719515920, 1072620714,\n+    2760332941, 1015137933, 764307441,  1072615240, 3021057420, 3163329523,\n+    2256325230, 1072609780, 580117746,  1015317295, 2728693978, 1072604335,\n+    396109971,  3163462691, 2009970496, 1072598905, 2159039665, 3162572948,\n+    4224142467, 1072593489, 3389820386, 1015207202, 610758006,  1072588089,\n+    1965209397, 3161866232, 3884662774, 1072582702, 2158611599, 1014210185,\n+    991358482,  1072577331, 838715019,  3163157668, 351641897,  1072571974,\n+    2172261526, 3163010599, 1796832535, 1072566631, 3176955716, 3160585513,\n+    863738719,  1072561303, 1326992220, 3162613197, 1679558232, 1072555989,\n+    2390342287, 3163333970, 4076975200, 1072550689, 2029000899, 1015208535,\n+    3594158869, 1072545404, 2456521700, 3163256561, 64696965,   1072540134,\n+    1768797490, 1015816960, 1912561781, 1072534877, 3147495102, 1015678253,\n+    382305176,  1072529635, 2347622376, 3162578625, 3898795731, 1072524406,\n+    1249994144, 1011869818, 3707479175, 1072519192, 3613079303, 1014164738,\n+    3939148246, 1072513992, 3210352148, 1015274323, 135105010,  1072508807,\n+    1906148728, 3163375739, 721996136,  1072503635, 563754734,  1015371318,\n+    1242007932, 1072498477, 1132034716, 3163339831, 1532734324, 1072493333,\n+    3094216535, 3163162857, 1432208378, 1072488203, 1401068914, 3162363963,\n+    778901109,  1072483087, 2248183955, 3161268751, 3706687593, 1072477984,\n+    3521726940, 1013253067, 1464976603, 1072472896, 3507292405, 3161977534,\n+    2483480501, 1072467821, 1216371780, 1013034172, 2307442995, 1072462760,\n+    3190117721, 3162404539, 777507147,  1072457713, 4282924205, 1015187533,\n+    2029714210, 1072452679, 613660079,  1015099143, 1610600570, 1072447659,\n+    3766732298, 1015760183, 3657065772, 1072442652, 399025623,  3162957078,\n+    3716502172, 1072437659, 2303740125, 1014042725, 1631695677, 1072432680,\n+    2717633076, 3162344026, 1540824585, 1072427714, 1064017011, 3163487690,\n+    3287523847, 1072422761, 1625971539, 3157009955, 2420883922, 1072417822,\n+    2049810052, 1014119888, 3080351519, 1072412896, 3379126788, 3157218001,\n+    815859274,  1072407984, 240396590,  3163487443, 4062661092, 1072403084,\n+    1422616006, 3163255318, 4076559943, 1072398198, 2119478331, 3160758351,\n+    703710506,  1072393326, 1384660846, 1015195891, 2380618042, 1072388466,\n+    3149557219, 3163320799, 364333489,  1072383620, 3923737744, 3161421373,\n+    3092190715, 1072378786, 814012168,  3159523422, 1822067026, 1072373966,\n+    1241994956, 1015340290, 697153126,  1072369159, 1283515429, 3163283189,\n+    3861050111, 1072364364, 254893773,  3162813180, 2572866477, 1072359583,\n+    878562433,  1015521741, 977020788,  1072354815, 3065100517, 1015541563,\n+    3218338682, 1072350059, 3404164304, 3162477108, 557149882,  1072345317,\n+    3672720709, 1014537265, 1434058175, 1072340587, 251133233,  1015085769,\n+    1405169241, 1072335870, 2998539689, 3162830951, 321958744,  1072331166,\n+    3401933767, 1015794558, 2331271250, 1072326474, 812057446,  1012207446,\n+    2990417245, 1072321795, 3683467745, 3163369326, 2152073944, 1072317129,\n+    1486860576, 3163203456, 3964284211, 1072312475, 2111583915, 1015427164,\n+    3985553595, 1072307834, 4002146062, 1015834136, 2069751141, 1072303206,\n+    1562170675, 3162724681, 2366108318, 1072298590, 2867985102, 3161762254,\n+    434316067,  1072293987, 2028358766, 1013458122, 424392917,  1072289396,\n+    2749202995, 3162838718, 2191782032, 1072284817, 2960257726, 1013742662,\n+    1297350157, 1072280251, 1308022040, 3163412558, 1892288442, 1072275697,\n+    2446255666, 3162600381, 3833209506, 1072271155, 2722920684, 1013754842,\n+    2682146384, 1072266626, 2082178513, 3163363419, 2591453363, 1072262109,\n+    2132396182, 3159074198, 3418903055, 1072257604, 2527457337, 3160820604,\n+    727685349,  1072253112, 2038246809, 3162358742, 2966275557, 1072248631,\n+    2176155324, 3159842759, 1403662306, 1072244163, 2788809599, 3161671007,\n+    194117574,  1072239707, 777528612,  3163412089, 3492293770, 1072235262,\n+    2248032210, 1015386826, 2568320822, 1072230830, 2732824428, 1014352915,\n+    1577608921, 1072226410, 1875489510, 3162968394, 380978316,  1072222002,\n+    854188970,  3160462686, 3134592888, 1072217605, 4232266862, 1015991134,\n+    1110089947, 1072213221, 1451641639, 1015474673, 2759350287, 1072208848,\n+    1148526634, 1015894933, 3649726105, 1072204487, 4085036346, 1015649474,\n+    3643909174, 1072200138, 3537586109, 1014354647, 2604962541, 1072195801,\n+    2614425274, 3163539192, 396319521,  1072191476, 4172420816, 3159074632,\n+    1176749997, 1072187162, 2738998779, 3162035844, 515457527,  1072182860,\n+    836709333,  1015651226, 2571947539, 1072178569, 3558159064, 3163376669,\n+    2916157145, 1072174290, 219487565,  1015309367, 1413356050, 1072170023,\n+    1651349291, 3162668166, 2224145553, 1072165767, 3482522030, 3161489169,\n+    919555682,  1072161523, 3121969534, 1012948226, 1660913392, 1072157290,\n+    4218599604, 1015135707, 19972402,   1072153069, 3507899862, 1016009292,\n+    158781403,  1072148859, 2221464712, 3163286453, 1944781191, 1072144660,\n+    3993278767, 3161724279, 950803702,  1072140473, 1655364926, 1015237032,\n+    1339972927, 1072136297, 167908909,  1015572152, 2980802057, 1072132132,\n+    378619896,  1015773303, 1447192521, 1072127979, 1462857171, 3162514521,\n+    903334909,  1072123837, 1636462108, 1015039997, 1218806132, 1072119706,\n+    1818613052, 3162548441, 2263535754, 1072115586, 752233586,  3162639008,\n+    3907805044, 1072111477, 2257091225, 3161550407, 1727278727, 1072107380,\n+    3562710623, 1011471940, 4182873220, 1072103293, 629542646,  3161996303,\n+    2555984613, 1072099218, 2652555442, 3162552692, 1013258799, 1072095154,\n+    1748797611, 3160129082, 3721688645, 1072091100, 3069276937, 1015839401,\n+    1963711167, 1072087058, 1744767757, 3160574294, 4201977662, 1072083026,\n+    748330254,  1013594357, 1719614413, 1072079006, 330458198,  3163282740,\n+    2979960120, 1072074996, 2599109725, 1014498493, 3561793907, 1072070997,\n+    1157054053, 1011890350, 3339203574, 1072067009, 1483497780, 3162408754,\n+    2186617381, 1072063032, 2270764084, 3163272713, 4273770423, 1072059065,\n+    3383180809, 3163218901, 885834528,  1072055110, 1973258547, 3162261564,\n+    488188413,  1072051165, 3199821029, 1015564048, 2956612997, 1072047230,\n+    2118169751, 3162735553, 3872257780, 1072043306, 1253592103, 1015958334,\n+    3111574537, 1072039393, 2606161479, 3162759746, 551349105,  1072035491,\n+    3821916050, 3162106589, 363667784,  1072031599, 813753950,  1015785209,\n+    2425981843, 1072027717, 2830390851, 3163346599, 2321106615, 1072023846,\n+    2171176610, 1009535771, 4222122499, 1072019985, 1277378074, 3163256737,\n+    3712504873, 1072016135, 88491949,   1015427660, 671025100,  1072012296,\n+    3832014351, 3163022030, 3566716925, 1072008466, 1536826856, 1014142433,\n+    3689071823, 1072004647, 2321004996, 3162552716, 917841882,  1072000839,\n+    18715565,   1015659308, 3723038930, 1071997040, 378465264,  3162569582,\n+    3395129871, 1071993252, 4025345435, 3162335388, 4109806887, 1071989474,\n+    422403966,  1014469229, 1453150082, 1071985707, 498154669,  3161488062,\n+    3896463087, 1071981949, 1139797873, 3161233805, 2731501122, 1071978202,\n+    1774031855, 3162470021, 2135241198, 1071974465, 1236747871, 1013589147,\n+    1990012071, 1071970738, 3529070563, 3162813193, 2178460671, 1071967021,\n+    777878098,  3162842493, 2583551245, 1071963314, 3161094195, 1015606491,\n+    3088564500, 1071959617, 1762311517, 1015045673, 3577096743, 1071955930,\n+    2951496418, 1013793687, 3933059031, 1071952253, 2133366768, 3161531832,\n+    4040676318, 1071948586, 4090609238, 1015663458, 3784486610, 1071944929,\n+    1581883040, 3161698953, 3049340112, 1071941282, 3062915824, 1013170595,\n+    1720398391, 1071937645, 3980678963, 3163300080, 3978100823, 1071934017,\n+    3513027190, 1015845963, 1118294578, 1071930400, 2197495694, 3159909401,\n+    1617004845, 1071926792, 82804944,   1010342778, 1065662932, 1071923194,\n+    2533670915, 1014530238, 3645941911, 1071919605, 3814685081, 3161573341,\n+    654919306,  1071916027, 3232961757, 3163047469, 569847338,  1071912458,\n+    472945272,  3159290729, 3278348324, 1071908898, 3069497416, 1014750712,\n+    78413852,   1071905349, 4183226867, 3163017251, 3743175029, 1071901808,\n+    2072812490, 3162175075, 1276261410, 1071898278, 300981948,  1014684169,\n+    1156440435, 1071894757, 2351451249, 1013967056, 3272845541, 1071891245,\n+    928852419,  3163488248, 3219942644, 1071887743, 3798990616, 1015368806,\n+    887463927,  1071884251, 3596744163, 3160794166, 460407023,  1071880768,\n+    4237175092, 3163138469, 1829099622, 1071877294, 1016661181, 3163461005,\n+    589198666,  1071873830, 2664346172, 3163157962, 926591435,  1071870375,\n+    3208833762, 3162913514, 2732492859, 1071866929, 2691479646, 3162255684,\n+    1603444721, 1071863493, 1548633640, 3162201326, 1726216749, 1071860066,\n+    2466808228, 3161676405, 2992903935, 1071856648, 2218154406, 1015228193,\n+    1000925746, 1071853240, 1018491672, 3163309544, 4232894513, 1071849840,\n+    2383938684, 1014668519, 3991843581, 1071846450, 4092853457, 1014585763,\n+    171030293,  1071843070, 3526460132, 1014428778, 1253935211, 1071839698,\n+    1395382931, 3159702613, 2839424854, 1071836335, 1171596163, 1013041679,\n+    526652809,  1071832982, 4223459736, 1015879375, 2799960843, 1071829637,\n+    1423655381, 1015022151, 964107055,  1071826302, 2800439588, 3162833221,\n+    3504003472, 1071822975, 3594001060, 3157330652, 1724976915, 1071819658,\n+    420909223,  3163117379, 4112506593, 1071816349, 2947355221, 1014371048,\n+    1972484976, 1071813050, 675290301,  3161640050, 3790955393, 1071809759,\n+    2352942462, 3163180090, 874372905,  1071806478, 100263788,  1015940732,\n+    1709341917, 1071803205, 2571168217, 1014152499, 1897844341, 1071799941,\n+    1254300460, 1015275938, 1337108031, 1071796686, 3203724452, 1014677845,\n+    4219606026, 1071793439, 2434574742, 1014681548, 1853186616, 1071790202,\n+    3066496371, 1015656574, 2725843665, 1071786973, 1433917087, 1014838523,\n+    2440944790, 1071783753, 2492769774, 1014147454, 897099801,  1071780542,\n+    754756297,  1015241005, 2288159958, 1071777339, 2169144469, 1014876021,\n+    2218315341, 1071774145, 2694295388, 3163288868, 586995997,  1071770960,\n+    41662348,   3162627992, 1588871207, 1071767783, 143439582,  3162963416,\n+    828946858,  1071764615, 10642492,   1015939438, 2502433899, 1071761455,\n+    2148595913, 1015023991, 2214878420, 1071758304, 892270087,  3163116422,\n+    4162030108, 1071755161, 2763428480, 1015529349, 3949972341, 1071752027,\n+    2068408548, 1014913868, 1480023343, 1071748902, 2247196168, 1015327453,\n+    948735466,  1071745785, 3516338028, 3162574883, 2257959872, 1071742676,\n+    3802946148, 1012964927, 1014845819, 1071739576, 3117910646, 3161559105,\n+    1416741826, 1071736484, 2196380210, 1011413563, 3366293073, 1071733400,\n+    3119426314, 1014120554, 2471440686, 1071730325, 968836267,  3162214888,\n+    2930322912, 1071727258, 2599499422, 3162714047, 351405227,  1071724200,\n+    3125337328, 3159822479, 3228316108, 1071721149, 3010241991, 3158422804,\n+    2875075254, 1071718107, 4144233330, 3163333716, 3490863953, 1071715073,\n+    960797498,  3162948880, 685187902,  1071712048, 378731989,  1014843115,\n+    2952712987, 1071709030, 3293494651, 3160120301, 1608493509, 1071706021,\n+    3159622171, 3162807737, 852742562,  1071703020, 667253586,  1009793559,\n+    590962156,  1071700027, 3829346666, 3163275597, 728909815,  1071697042,\n+    383930225,  1015029468, 1172597893, 1071694065, 114433263,  1015347593,\n+    1828292879, 1071691096, 1255956747, 1015588398, 2602514713, 1071688135,\n+    2268929336, 1014354284, 3402036099, 1071685182, 405889334,  1015105656,\n+    4133881824, 1071682237, 2148155345, 3162931299, 410360776,  1071679301,\n+    1269990655, 1011975870, 728934454,  1071676372, 1413842688, 1014178612,\n+    702412510,  1071673451, 3803266087, 3162280415, 238821257,  1071670538,\n+    1469694871, 3162884987, 3541402996, 1071667632, 2759177317, 1014854626,\n+    1928746161, 1071664735, 983617676,  1014285177, 3899555717, 1071661845,\n+    427280750,  3162546972, 772914124,  1071658964, 4004372762, 1012230161,\n+    1048019041, 1071656090, 1398474845, 3160510595, 339411585,  1071653224,\n+    264588982,  3161636657, 2851812149, 1071650365, 2595802551, 1015767337,\n+    4200250559, 1071647514, 2808127345, 3161781938\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmTanh() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmTanh\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n+  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1;\n+  Label B1_2, B1_4;\n+\n+  address HALFMASK     = (address)_HALFMASK;\n+  address ONEMASK      = (address)_ONEMASK;\n+  address TWOMASK      = (address)_TWOMASK;\n+  address MASK3        = (address)_MASK3;\n+  address RMASK        = (address)_RMASK;\n+  address L2E          = (address)_L2E;\n+  address Shifter      = (address)_Shifter;\n+  address cv           = (address)_cv;\n+  address pv           = (address)_pv;\n+  address T2_neg_f     = (address) _T2_neg_f;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ bind(B1_2);\n+  __ movsd(xmm3, ExternalAddress(HALFMASK), r11 \/*rscratch*\/);\n+  __ xorpd(xmm4, xmm4);\n+  __ movsd(xmm1, ExternalAddress(L2E), r11 \/*rscratch*\/);\n+  __ movsd(xmm2, ExternalAddress(L2E + 8), r11 \/*rscratch*\/);\n+  __ movl(rax, 32768);\n+  __ pinsrw(xmm4, rax, 3);\n+  __ movsd(xmm6,  ExternalAddress(Shifter), r11 \/*rscratch*\/);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andpd(xmm3, xmm0);\n+  __ andnpd(xmm4, xmm0);\n+  __ pshufd(xmm5, xmm4, 68);\n+  __ movl(rdx, 32768);\n+  __ andl(rdx, rcx);\n+  __ andl(rcx, 32767);\n+  __ subl(rcx, 16304);\n+  __ cmpl(rcx, 144);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_1);\n+  __ subsd(xmm4, xmm3);\n+  __ mulsd(xmm3, xmm1);\n+  __ mulsd(xmm2, xmm5);\n+  __ cvtsd2siq(rax, xmm3);\n+  __ movq(xmm7, xmm3);\n+  __ addsd(xmm3, xmm6);\n+  __ mulsd(xmm1, xmm4);\n+  __ movsd(xmm4, ExternalAddress(ONEMASK), r11 \/*rscratch*\/);\n+  __ subsd(xmm3, xmm6);\n+  __ xorpd(xmm0, xmm0);\n+  __ addsd(xmm2, xmm1);\n+  __ subsd(xmm7, xmm3);\n+  __ movdqu(xmm6, ExternalAddress(cv), r11 \/*rscratch*\/);\n+  __ addsd(xmm2, xmm7);\n+  __ movl(rcx, 255);\n+  __ andl(rcx, rax);\n+  __ addl(rcx, rcx);\n+  __ lea(r8, ExternalAddress(T2_neg_f));\n+  __ movdqu(xmm5, Address(r8, rcx, Address::times(8)));\n+  __ shrl(rax, 4);\n+  __ andl(rax, 65520);\n+  __ subl(rax, 16368);\n+  __ negl(rax);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ movdqu(xmm1, ExternalAddress(cv + 16), r11 \/*rscratch*\/);\n+  __ pshufd(xmm0, xmm0, 68);\n+  __ mulpd(xmm0, xmm5);\n+  __ movsd(xmm7, ExternalAddress(cv + 32), r11 \/*rscratch*\/);\n+  __ pshufd(xmm2, xmm2, 68);\n+  __ movq(xmm5, xmm4);\n+  __ addsd(xmm4, xmm0);\n+  __ mulpd(xmm6, xmm2);\n+  __ mulsd(xmm7, xmm2);\n+  __ mulpd(xmm2, xmm2);\n+  __ addpd(xmm1, xmm6);\n+  __ mulsd(xmm2, xmm2);\n+  __ movsd(xmm3, ExternalAddress(ONEMASK), r11 \/*rscratch*\/);\n+  __ mulpd(xmm1, xmm2);\n+  __ pshufd(xmm6, xmm1, 78);\n+  __ addsd(xmm1, xmm6);\n+  __ movq(xmm6, xmm1);\n+  __ addsd(xmm1, xmm7);\n+  __ mulsd(xmm1, xmm0);\n+  __ addsd(xmm1, xmm4);\n+  __ andpd(xmm4, ExternalAddress(MASK3), r11 \/*rscratch*\/);\n+  __ divsd(xmm5, xmm1);\n+  __ subsd(xmm3, xmm4);\n+  __ pshufd(xmm1, xmm0, 238);\n+  __ addsd(xmm3, xmm0);\n+  __ movq(xmm2, xmm4);\n+  __ addsd(xmm3, xmm1);\n+  __ mulsd(xmm1, xmm7);\n+  __ mulsd(xmm7, xmm0);\n+  __ addsd(xmm3, xmm1);\n+  __ addsd(xmm4, xmm7);\n+  __ movsd(xmm1, ExternalAddress(RMASK), r11 \/*rscratch*\/);\n+  __ mulsd(xmm6, xmm0);\n+  __ andpd(xmm4, ExternalAddress(MASK3), r11 \/*rscratch*\/);\n+  __ addsd(xmm3, xmm6);\n+  __ movq(xmm6, xmm4);\n+  __ subsd(xmm2, xmm4);\n+  __ addsd(xmm2, xmm7);\n+  __ movsd(xmm7, ExternalAddress(ONEMASK), r11 \/*rscratch*\/);\n+  __ andpd(xmm5, xmm1);\n+  __ addsd(xmm3, xmm2);\n+  __ mulsd(xmm4, xmm5);\n+  __ xorpd(xmm2, xmm2);\n+  __ mulsd(xmm3, xmm5);\n+  __ subsd(xmm6, ExternalAddress(TWOMASK), r11 \/*rscratch*\/);\n+  __ subsd(xmm4, xmm7);\n+  __ xorl(rdx, 32768);\n+  __ pinsrw(xmm2, rdx, 3);\n+  __ addsd(xmm4, xmm3);\n+  __ mulsd(xmm6, xmm5);\n+  __ movq(xmm1, xmm3);\n+  __ mulsd(xmm3, xmm4);\n+  __ movq(xmm0, xmm6);\n+  __ mulsd(xmm6, xmm4);\n+  __ subsd(xmm1, xmm3);\n+  __ subsd(xmm1, xmm6);\n+  __ addsd(xmm0, xmm1);\n+  __ xorpd(xmm0, xmm2);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_0_0_1);\n+  __ addl(rcx, 960);\n+  __ cmpl(rcx, 1104);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_1_0_1);\n+  __ movdqu(xmm2, ExternalAddress(pv), r11 \/*rscratch*\/);\n+  __ pshufd(xmm1, xmm0, 68);\n+  __ movdqu(xmm3, ExternalAddress(pv + 16), r11 \/*rscratch*\/);\n+  __ mulpd(xmm1, xmm1);\n+  __ movdqu(xmm4, ExternalAddress(pv + 32), r11 \/*rscratch*\/);\n+  __ mulpd(xmm2, xmm1);\n+  __ pshufd(xmm5, xmm1, 68);\n+  __ addpd(xmm2, xmm3);\n+  __ mulsd(xmm5, xmm5);\n+  __ mulpd(xmm2, xmm1);\n+  __ mulsd(xmm5, xmm5);\n+  __ addpd(xmm2, xmm4);\n+  __ mulpd(xmm2, xmm5);\n+  __ pshufd(xmm5, xmm2, 238);\n+  __ addsd(xmm2, xmm5);\n+  __ mulsd(xmm2, xmm0);\n+  __ addsd(xmm0, xmm2);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_1_0_1);\n+  __ addl(rcx, 15344);\n+  __ cmpl(rcx, 16448);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_1);\n+  __ cmpl(rcx, 16);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_3_0_1);\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rax, 17392);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ mulsd(xmm2, xmm0);\n+  __ addsd(xmm2, xmm0);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_3_0_1);\n+  __ movq(xmm2, xmm0);\n+  __ mulsd(xmm2, xmm2);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_2_0_1);\n+  __ cmpl(rcx, 32752);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_4_0_1);\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rcx, 15344);\n+  __ pinsrw(xmm2, rcx, 3);\n+  __ movq(xmm3, xmm2);\n+  __ mulsd(xmm2, xmm2);\n+  __ addsd(xmm2, xmm3);\n+\n+  __ bind(L_2TAG_PACKET_5_0_1);\n+  __ xorpd(xmm0, xmm0);\n+  __ orl(rdx, 16368);\n+  __ pinsrw(xmm0, rdx, 3);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_4_0_1);\n+  __ movq(xmm2, xmm0);\n+  __ movdl(rax, xmm0);\n+  __ psrlq(xmm2, 20);\n+  __ movdl(rcx, xmm2);\n+  __ orl(rcx, rax);\n+  __ cmpl(rcx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_5_0_1);\n+  __ addsd(xmm0, xmm0);\n+\n+  __ bind(B1_4);\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":502,"deletions":0,"binary":false,"changes":502,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,0 +376,4 @@\n+  if (kind == Interpreter::java_lang_math_tanh) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,0 +468,4 @@\n+  } else if (kind == Interpreter::java_lang_math_tanh) {\n+      assert(StubRoutines::dtanh() != nullptr, \"not initialized\");\n+      __ movdbl(xmm0, Address(rsp, wordSize));\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dtanh())));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1950,1 +1950,4 @@\n-      if (build_number > 20347) {\n+      \/\/ - 2025 Preview build   : 26040\n+      if (build_number > 26039) {\n+        st->print(\"Server 2025\");\n+      } else if (build_number > 20347) {\n@@ -4093,0 +4096,33 @@\n+void getWindowsInstallationType(char* buffer, int bufferSize) {\n+  HKEY hKey;\n+  const char* subKey = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\";\n+  const char* valueName = \"InstallationType\";\n+\n+  DWORD valueLength = bufferSize;\n+\n+  \/\/ Initialize buffer with empty string\n+  buffer[0] = '\\0';\n+\n+  \/\/ Open the registry key\n+  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hKey) != ERROR_SUCCESS) {\n+    \/\/ Return empty buffer if key cannot be opened\n+    return;\n+  }\n+\n+  \/\/ Query the value\n+  if (RegQueryValueExA(hKey, valueName, NULL, NULL, (LPBYTE)buffer, &valueLength) != ERROR_SUCCESS) {\n+    RegCloseKey(hKey);\n+    buffer[0] = '\\0';\n+    return;\n+  }\n+\n+  RegCloseKey(hKey);\n+}\n+\n+bool isNanoServer() {\n+  const int BUFFER_SIZE = 256;\n+  char installationType[BUFFER_SIZE];\n+  getWindowsInstallationType(installationType, BUFFER_SIZE);\n+  return (strcmp(installationType, \"Nano Server\") == 0);\n+}\n+\n@@ -4110,1 +4146,7 @@\n-  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n+\n+  if (isNanoServer()) {\n+    \/\/ On Windows Nanoserver the kernel32.dll is located in the forwarders subdirectory\n+    strncat(kernel32_path, \"\\\\forwarders\\\\kernel32.dll\", MAX_PATH - ret);\n+  } else {\n+    strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n+  }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -57,0 +57,18 @@\n+  \/\/ From 3 Zifencei Instruction-Fetch Fence, Version 2.0\n+  \/\/ \"RISC-V does not guarantee that stores to instruction memory will be made\n+  \/\/ visible to instruction fetches on a RISC-V hart until that hart executes a\n+  \/\/ FENCE.I instruction. A FENCE.I instruction ensures that a subsequent\n+  \/\/ instruction fetch on a RISC-V hart will see any previous data stores\n+  \/\/ already visible to the same RISC-V hart. FENCE.I does not ensure that other\n+  \/\/ RISC-V harts instruction fetches will observe the local harts stores in a\n+  \/\/ multiprocessor system.\"\n+  \/\/\n+  \/\/ Hence to be able to use fence.i directly we need a kernel that supports\n+  \/\/ PR_RISCV_CTX_SW_FENCEI_ON. Thus if context switch to another hart we are\n+  \/\/ ensured that instruction fetch will see any previous data stores\n+  \/\/\n+  \/\/ The alternative is using full system IPI (system wide icache sync) then\n+  \/\/ this barrier is not strictly needed. As this is emitted in runtime slow-path\n+  \/\/ we will just always emit it, typically after a safepoint.\n+  guarantee(VM_Version::supports_fencei_barrier(), \"Linux kernel require fence.i\");\n+  __asm__ volatile(\"fence.i\" : : : \"memory\");\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/orderAccess_linux_riscv.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <sys\/prctl.h>\n@@ -85,0 +86,17 @@\n+\/\/ prctl PR_RISCV_SET_ICACHE_FLUSH_CTX is from Linux 6.9\n+#ifndef PR_RISCV_SET_ICACHE_FLUSH_CTX\n+#define PR_RISCV_SET_ICACHE_FLUSH_CTX 71\n+#endif\n+#ifndef PR_RISCV_CTX_SW_FENCEI_ON\n+#define PR_RISCV_CTX_SW_FENCEI_ON  0\n+#endif\n+#ifndef PR_RISCV_CTX_SW_FENCEI_OFF\n+#define PR_RISCV_CTX_SW_FENCEI_OFF 1\n+#endif\n+#ifndef PR_RISCV_SCOPE_PER_PROCESS\n+#define PR_RISCV_SCOPE_PER_PROCESS 0\n+#endif\n+#ifndef PR_RISCV_SCOPE_PER_THREAD\n+#define PR_RISCV_SCOPE_PER_THREAD  1\n+#endif\n+\n@@ -105,0 +123,1 @@\n+\n@@ -158,0 +177,18 @@\n+  \/\/ Linux kernel require Zifencei\n+  if (!ext_Zifencei.enabled()) {\n+    log_info(os, cpu)(\"Zifencei not found, required by Linux, enabling.\");\n+    ext_Zifencei.enable_feature();\n+  }\n+\n+  if (UseCtxFencei) {\n+    \/\/ Note that we can set this up only for effected threads\n+    \/\/ via PR_RISCV_SCOPE_PER_THREAD, i.e. on VM attach\/deattach.\n+    int ret = prctl(PR_RISCV_SET_ICACHE_FLUSH_CTX, PR_RISCV_CTX_SW_FENCEI_ON, PR_RISCV_SCOPE_PER_PROCESS);\n+    if (ret == 0) {\n+      log_debug(os, cpu)(\"UseCtxFencei (PR_RISCV_CTX_SW_FENCEI_ON) enabled.\");\n+    } else {\n+      FLAG_SET_ERGO(UseCtxFencei, false);\n+      log_info(os, cpu)(\"UseCtxFencei (PR_RISCV_CTX_SW_FENCEI_ON) disabled, unsupported by kernel.\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,3 @@\n+  #if defined(AMD64)\n+  case vmIntrinsics::_dtanh:\n+  #endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3342,0 +3342,1 @@\n+  case vmIntrinsics::_dtanh         : \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2036,0 +2036,1 @@\n+    bool callee_is_private = _profiled_callee->is_loaded() && _profiled_callee->is_private();\n@@ -2037,1 +2038,1 @@\n-    bool call_is_virtual = (bc == Bytecodes::_invokevirtual && !_profiled_callee->can_be_statically_bound()) || bc == Bytecodes::_invokeinterface;\n+    bool call_is_virtual = (bc == Bytecodes::_invokevirtual && !callee_is_private) || bc == Bytecodes::_invokeinterface;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2974,0 +2974,1 @@\n+  case vmIntrinsics::_dtanh:          \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  FUNCTION_CASE(entry, StubRoutines::dtanh());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -252,0 +252,5 @@\n+\/\/ The goal is to sort the objects in increasing order of:\n+\/\/ - objects that have only oop pointers\n+\/\/ - objects that have both native and oop pointers\n+\/\/ - objects that have only native pointers\n+\/\/ - objects that have no pointers\n@@ -256,1 +261,1 @@\n-  if (!has_oop_ptr) {\n+  if (has_oop_ptr) {\n@@ -271,5 +276,0 @@\n-\/\/ The goal is to sort the objects in increasing order of:\n-\/\/ - objects that have no pointers\n-\/\/ - objects that have only native pointers\n-\/\/ - objects that have both native and oop pointers\n-\/\/ - objects that have only oop pointers\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  static void set_old_cds_flags_used() { CDS_ONLY(_old_cds_flags_used = true); }\n+  static void set_old_cds_flags_used()                       { CDS_ONLY(_old_cds_flags_used = true); }\n+  static bool old_cds_flags_used()                           { return CDS_ONLY(_old_cds_flags_used) NOT_CDS(false); }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1596,5 +1596,6 @@\n-\/\/ The start of the archived heap has many primitive arrays (String\n-\/\/ bodies) that are not marked by the oop\/ptr maps. So we must have\n-\/\/ lots of leading zeros.\n-size_t FileMapInfo::remove_bitmap_leading_zeros(CHeapBitMap* map) {\n-  size_t old_zeros = map->find_first_set_bit(0);\n+\/\/ The sorting code groups the objects with non-null oop\/ptrs together.\n+\/\/ Relevant bitmaps then have lots of leading and trailing zeros, which\n+\/\/ we do not have to store.\n+size_t FileMapInfo::remove_bitmap_zeros(CHeapBitMap* map) {\n+  BitMap::idx_t first_set = map->find_first_set_bit(0);\n+  BitMap::idx_t last_set  = map->find_last_set_bit(0);\n@@ -1604,1 +1605,1 @@\n-  map->truncate(old_zeros, map->size());\n+  map->truncate(first_set, last_set + 1);\n@@ -1606,4 +1607,2 @@\n-  DEBUG_ONLY(\n-    size_t new_zeros = map->find_first_set_bit(0);\n-    assert(new_zeros == 0, \"Should have removed leading zeros\");\n-  )\n+  assert(map->at(0), \"First bit should be set\");\n+  assert(map->at(map->size() - 1), \"Last bit should be set\");\n@@ -1611,1 +1610,2 @@\n-  return old_zeros;\n+\n+  return first_set;\n@@ -1616,4 +1616,4 @@\n-  size_t removed_rw_zeros = remove_bitmap_leading_zeros(rw_ptrmap);\n-  size_t removed_ro_zeros = remove_bitmap_leading_zeros(ro_ptrmap);\n-  header()->set_rw_ptrmap_start_pos(removed_rw_zeros);\n-  header()->set_ro_ptrmap_start_pos(removed_ro_zeros);\n+  size_t removed_rw_leading_zeros = remove_bitmap_zeros(rw_ptrmap);\n+  size_t removed_ro_leading_zeros = remove_bitmap_zeros(ro_ptrmap);\n+  header()->set_rw_ptrmap_start_pos(removed_rw_leading_zeros);\n+  header()->set_ro_ptrmap_start_pos(removed_ro_leading_zeros);\n@@ -1623,6 +1623,5 @@\n-    \/\/ Remove leading zeros\n-    size_t removed_oop_zeros = remove_bitmap_leading_zeros(heap_info->oopmap());\n-    size_t removed_ptr_zeros = remove_bitmap_leading_zeros(heap_info->ptrmap());\n-\n-    header()->set_heap_oopmap_start_pos(removed_oop_zeros);\n-    header()->set_heap_ptrmap_start_pos(removed_ptr_zeros);\n+    \/\/ Remove leading and trailing zeros\n+    size_t removed_oop_leading_zeros = remove_bitmap_zeros(heap_info->oopmap());\n+    size_t removed_ptr_leading_zeros = remove_bitmap_zeros(heap_info->ptrmap());\n+    header()->set_heap_oopmap_start_pos(removed_oop_leading_zeros);\n+    header()->set_heap_ptrmap_start_pos(removed_ptr_leading_zeros);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  size_t remove_bitmap_leading_zeros(CHeapBitMap* map);\n+  size_t remove_bitmap_zeros(CHeapBitMap* map);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -715,3 +715,5 @@\n-  if (AOTMode != nullptr && strcmp(AOTMode, \"create\") == 0) {\n-    \/\/ We can't return to the JLI launcher, as it will try to run the main class, but\n-    \/\/ the main class is not specified when -XX:AOTMode=create is used.\n+  if (!CDSConfig::old_cds_flags_used()) {\n+    \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n+    \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n+    \/\/ to the JLI launcher, as the launcher will fail when trying to\n+    \/\/ run the main class, which is not what we want.\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -304,6 +304,0 @@\n-protected:\n-  static InstanceKlass* _well_known_klasses[];\n-\n-private:\n-  \/\/ table of box klasses (int_klass, etc.)\n-  static InstanceKlass* _box_klasses[T_VOID+1];\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,8 +49,0 @@\n-\n-\/\/ CDS: scan and relocate all classes referenced by _klasses[].\n-void vmClasses::metaspace_pointers_do(MetaspaceClosure* it) {\n-  for (auto id : EnumRange<vmClassID>{}) {\n-    it->push(klass_addr_at(id));\n-  }\n-}\n-\n@@ -209,2 +201,0 @@\n-  \/\/_box_klasses[T_OBJECT]  = vmClasses::object_klass();\n-  \/\/_box_klasses[T_ARRAY]   = vmClasses::object_klass();\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-class MetaspaceClosure;\n@@ -98,1 +97,0 @@\n-  static void metaspace_pointers_do(MetaspaceClosure* it);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -144,0 +145,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -291,0 +293,1 @@\n+  case vmIntrinsics::_dtanh:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  do_name(round_name, \"round\")                                                                                          \\\n+  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")                                                               \\\n@@ -164,0 +164,1 @@\n+  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,   double_double_signature,          F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+    assert(call_info->resolved_method() != nullptr, \"virtual or interface method must be found\");\n@@ -241,0 +242,1 @@\n+    assert(call_info->resolved_method() != nullptr, \"virtual or interface method must be found\");\n@@ -257,0 +259,1 @@\n+  assert(call_info->selected_method() != nullptr, \"virtual or interface method must be found\");\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,2 +90,0 @@\n-  \/\/ Size (in elements) of a partial objArray task chunk.\n-  size_t _partial_objarray_chunk_size;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1138,0 +1138,20 @@\n+bool OopStorage::print_containing(const oop* addr, outputStream* st) {\n+  if (addr != nullptr) {\n+    Block* block = find_block_or_null(addr);\n+    if (block != nullptr && block->print_containing(addr, st)) {\n+      st->print(\" in oop storage \\\"%s\\\"\", name());\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool OopStorage::Block::print_containing(const oop* addr, outputStream* st) {\n+  if (contains(addr)) {\n+    st->print(PTR_FORMAT \" is a pointer %u\/%zu into block %zu\",\n+              p2i(addr), get_index(addr), ARRAY_SIZE(_data), _active_index);\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  bool print_containing(const oop* addr, outputStream* st);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -199,0 +199,2 @@\n+\n+  bool print_containing(const oop* addr, outputStream* st);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,17 @@\n+bool OopStorageSet::print_containing(const void* addr, outputStream* st) {\n+  if (addr != nullptr) {\n+    const void* aligned_addr = align_down(addr, alignof(oop));\n+    for (OopStorage* storage : Range<Id>()) {\n+      if (storage->print_containing((oop*) aligned_addr, st)) {\n+        if (aligned_addr != addr) {\n+          st->print_cr(\" (unaligned)\");\n+        } else {\n+          st->cr();\n+        }\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/oop.hpp\"\n@@ -92,0 +93,2 @@\n+  \/\/ Debugging: print location info, if in storage.\n+  static bool print_containing(const void* addr, outputStream* st);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -274,0 +274,5 @@\n+bool ShenandoahBarrierSetC2::is_shenandoah_clone_call(Node* call) {\n+  return call->is_CallLeaf() &&\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier);\n+}\n+\n@@ -678,1 +683,0 @@\n-\/\/ Support for GC barriers emitted during parsing\n@@ -680,12 +684,3 @@\n-  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;\n-  if (node->Opcode() != Op_CallLeaf && node->Opcode() != Op_CallLeafNoFP) {\n-    return false;\n-  }\n-  CallLeafNode *call = node->as_CallLeaf();\n-  if (call->_name == nullptr) {\n-    return false;\n-  }\n-\n-  return strcmp(call->_name, \"shenandoah_clone_barrier\") == 0 ||\n-         strcmp(call->_name, \"shenandoah_cas_obj\") == 0 ||\n-         strcmp(call->_name, \"shenandoah_wb_pre\") == 0;\n+  return is_shenandoah_lrb_call(node) ||\n+         is_shenandoah_wb_pre_call(node) ||\n+         is_shenandoah_clone_call(node);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  static bool is_shenandoah_clone_call(Node* call);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-        \"shenandoah_clone_barrier\",\n+        \"shenandoah_clone\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,2 +228,1 @@\n-  TASKQUEUE_STATS_ONLY(task_queues()->print_taskqueue_stats());\n-  TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(task_queues()->print_and_reset_taskqueue_stats(\"\"));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-  TASKQUEUE_STATS_ONLY(task_queues()->print_taskqueue_stats());\n-  TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(task_queues()->print_and_reset_taskqueue_stats(\"\"));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,39 +54,0 @@\n-#if TASKQUEUE_STATS\n-void ShenandoahObjToScanQueueSet::print_taskqueue_stats_hdr(outputStream* const st) {\n-  st->print_raw_cr(\"GC Task Stats\");\n-  st->print_raw(\"thr \"); TaskQueueStats::print_header(1, st); st->cr();\n-  st->print_raw(\"--- \"); TaskQueueStats::print_header(2, st); st->cr();\n-}\n-\n-void ShenandoahObjToScanQueueSet::print_taskqueue_stats() const {\n-  if (!log_develop_is_enabled(Trace, gc, task, stats)) {\n-    return;\n-  }\n-  Log(gc, task, stats) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-  outputStream* st = &ls;\n-  print_taskqueue_stats_hdr(st);\n-\n-  ShenandoahObjToScanQueueSet* queues = const_cast<ShenandoahObjToScanQueueSet*>(this);\n-  TaskQueueStats totals;\n-  const uint n = size();\n-  for (uint i = 0; i < n; ++i) {\n-    st->print(UINT32_FORMAT_W(3), i);\n-    queues->queue(i)->stats.print(st);\n-    st->cr();\n-    totals += queues->queue(i)->stats;\n-  }\n-  st->print(\"tot \"); totals.print(st); st->cr();\n-  DEBUG_ONLY(totals.verify());\n-\n-}\n-\n-void ShenandoahObjToScanQueueSet::reset_taskqueue_stats() {\n-  const uint n = size();\n-  for (uint i = 0; i < n; ++i) {\n-    queue(i)->stats.reset();\n-  }\n-}\n-#endif \/\/ TASKQUEUE_STATS\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.cpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -358,6 +358,0 @@\n-\n-#if TASKQUEUE_STATS\n-  static void print_taskqueue_stats_hdr(outputStream* const st);\n-  void print_taskqueue_stats() const;\n-  void reset_taskqueue_stats();\n-#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,2 +251,1 @@\n-    page->verify_remset_cleared_current();\n-    page->verify_remset_cleared_previous();\n+    page->remset_delete();\n@@ -264,0 +263,1 @@\n+    _page_table.remove(page);\n@@ -265,3 +265,1 @@\n-      \/\/ The remset of pages should be clean when installed into the page\n-      \/\/ cache.\n-      page->remset_clear();\n+      page->remset_delete();\n@@ -269,1 +267,0 @@\n-    _page_table.remove(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,2 +81,2 @@\n-void ZPage::remset_initialize() {\n-  \/\/ Remsets should only be initialized once and only for old pages.\n+void ZPage::remset_alloc() {\n+  \/\/ Remsets should only be allocated\/initialized once and only for old pages.\n@@ -89,13 +89,2 @@\n-void ZPage::remset_initialize_or_verify_cleared() {\n-  assert(is_old(), \"Only old pages need a remset\");\n-\n-  if (_remembered_set.is_initialized()) {\n-    verify_remset_cleared_current();\n-    verify_remset_cleared_previous();\n-  } else {\n-    remset_initialize();\n-  }\n-}\n-\n-void ZPage::remset_clear() {\n-  _remembered_set.clear_all();\n+void ZPage::remset_delete() {\n+  _remembered_set.delete_all();\n@@ -126,1 +115,0 @@\n-  _remembered_set.resize(size());\n@@ -219,4 +207,0 @@\n-void ZPage::clear_remset_current() {\n-  _remembered_set.clear_current();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,3 +158,2 @@\n-  void remset_initialize();\n-  void remset_initialize_or_verify_cleared();\n-  void remset_clear();\n+  void remset_alloc();\n+  void remset_delete();\n@@ -185,1 +184,0 @@\n-  void clear_remset_current();\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -736,1 +736,1 @@\n-    page->remset_initialize_or_verify_cleared();\n+    page->remset_alloc();\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -851,1 +851,1 @@\n-      to_page->remset_initialize();\n+      to_page->remset_alloc();\n@@ -946,1 +946,1 @@\n-  void clear_remset_before_reuse(ZPage* page, bool in_place) {\n+  void clear_remset_before_in_place_reuse(ZPage* page) {\n@@ -952,23 +952,3 @@\n-    if (in_place) {\n-      \/\/ Clear 'previous' remset bits. For in-place relocated pages, the previous\n-      \/\/ remset bits are always used, even when active_remset_is_current().\n-      page->clear_remset_previous();\n-\n-      return;\n-    }\n-\n-    \/\/ Normal relocate\n-\n-    \/\/ Clear active remset bits\n-    if (active_remset_is_current()) {\n-      page->clear_remset_current();\n-    } else {\n-      page->clear_remset_previous();\n-    }\n-\n-    \/\/ Verify that inactive remset bits are all cleared\n-    if (active_remset_is_current()) {\n-      page->verify_remset_cleared_previous();\n-    } else {\n-      page->verify_remset_cleared_current();\n-    }\n+    \/\/ Clear 'previous' remset bits. For in-place relocated pages, the previous\n+    \/\/ remset bits are always used, even when active_remset_is_current().\n+    page->clear_remset_previous();\n@@ -1020,1 +1000,1 @@\n-      clear_remset_before_reuse(page, true \/* in_place *\/);\n+      clear_remset_before_in_place_reuse(page);\n@@ -1032,5 +1012,0 @@\n-      \/\/ Ensure that all remset bits are cleared\n-      \/\/ Note: cleared after detach_page, when we know that\n-      \/\/ the young generation isn't scanning the remset.\n-      clear_remset_before_reuse(page, false \/* in_place *\/);\n-\n@@ -1295,1 +1270,1 @@\n-        new_page->remset_initialize();\n+        new_page->remset_alloc();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,12 +58,4 @@\n-void ZRememberedSet::resize(size_t page_size) {\n-  \/\/ The bitmaps only need to be resized if remset has been\n-  \/\/ initialized, and hence the bitmaps have been initialized.\n-  if (is_initialized()) {\n-    const BitMap::idx_t size_in_bits = to_bit_size(page_size);\n-\n-    \/\/ The bitmaps need to be cleared when free, but since this function is\n-    \/\/ only used for shrinking the clear argument is correct but not crucial.\n-    assert(size_in_bits <= _bitmap[0].size(), \"Only used for shrinking\");\n-    _bitmap[0].resize(size_in_bits, true \/* clear *\/);\n-    _bitmap[1].resize(size_in_bits, true \/* clear *\/);\n-  }\n+void ZRememberedSet::delete_all() {\n+  assert(is_initialized(), \"precondition\");\n+  _bitmap[0].resize(0);\n+  _bitmap[1].resize(0);\n@@ -80,9 +72,0 @@\n-void ZRememberedSet::clear_all() {\n-  _bitmap[0].clear_large();\n-  _bitmap[1].clear_large();\n-}\n-\n-void ZRememberedSet::clear_current() {\n-  current()->clear_large();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRememberedSet.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,2 +117,1 @@\n-\n-  void resize(size_t page_size);\n+  void delete_all();\n@@ -136,2 +135,0 @@\n-  void clear_all();\n-  void clear_current();\n","filename":"src\/hotspot\/share\/gc\/z\/zRememberedSet.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+      case vmIntrinsics::_dtanh:             return java_lang_math_tanh;\n@@ -201,0 +202,1 @@\n+  case java_lang_math_tanh        : return vmIntrinsics::_dtanh;\n@@ -312,0 +314,1 @@\n+    case java_lang_math_tanh    : tty->print(\"java_lang_math_tanh\"    ); break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,1 @@\n+    java_lang_math_tanh,                                        \/\/ implementation of java.lang.Math.tanh  (x)\n@@ -154,0 +155,1 @@\n+      case vmIntrinsics::_dtanh : \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  assert(itable_index == resolved_method()->itable_index(), \"\");\n+  assert(itable_index == resolved_method->itable_index(), \"\");\n@@ -1544,1 +1544,1 @@\n-  if (!is_abstract_interpretation && !resolved_method()->is_private()) {\n+  if (!is_abstract_interpretation && !resolved_method->is_private()) {\n@@ -1593,1 +1593,1 @@\n-    int itable_index = resolved_method()->itable_index();\n+    int itable_index = resolved_method->itable_index();\n@@ -1600,2 +1600,2 @@\n-    assert(resolved_method()->is_private() ||\n-           (resolved_method()->is_final() && resolved_method->method_holder() == vmClasses::Object_klass()),\n+    assert(resolved_method->is_private() ||\n+           (resolved_method->is_final() && resolved_method->method_holder() == vmClasses::Object_klass()),\n@@ -1603,1 +1603,1 @@\n-    assert(resolved_method()->can_be_statically_bound(), \"Should only have non-virtual invokeinterface for statically bound methods!\");\n+    assert(resolved_method->can_be_statically_bound(), \"Should only have non-virtual invokeinterface for statically bound methods!\");\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-  BasicType    result_type() const               { return selected_method()->result_type(); }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,0 +195,1 @@\n+  method_entry(java_lang_math_tanh )\n@@ -460,0 +461,1 @@\n+  case Interpreter::java_lang_math_tanh    : \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    method_entry(java_lang_math_tanh  );\n@@ -98,0 +99,1 @@\n+  case Interpreter::java_lang_math_tanh    : \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+    static address dtanh;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+address CompilerToVM::Data::dtanh;\n@@ -271,0 +272,13 @@\n+\n+#define SET_TRIGFUNC_OR_NULL(name)                              \\\n+  if (StubRoutines::name() != nullptr) {                        \\\n+    name = StubRoutines::name();                                \\\n+  } else {                                                      \\\n+    name = nullptr;                                             \\\n+  }\n+\n+  SET_TRIGFUNC_OR_NULL(dtanh);\n+\n+#undef SET_TRIGFUNC_OR_NULL\n+\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,0 +83,9 @@\n+    if (!FLAG_IS_DEFAULT(EnableJVMCI) && !EnableJVMCI) {\n+      jio_fprintf(defaultStream::error_stream(),\n+          \"Improperly specified VM option UseJVMCICompiler: EnableJVMCI cannot be disabled\\n\");\n+      return false;\n+    }\n+    FLAG_SET_DEFAULT(EnableJVMCI, true);\n+  }\n+\n+  if (EnableJVMCI) {\n@@ -91,6 +100,3 @@\n-    if (!FLAG_IS_DEFAULT(EnableJVMCI) && !EnableJVMCI) {\n-      jio_fprintf(defaultStream::error_stream(),\n-          \"Improperly specified VM option UseJVMCICompiler: EnableJVMCI cannot be disabled\\n\");\n-      return false;\n-    }\n-    FLAG_SET_DEFAULT(EnableJVMCI, true);\n+  }\n+\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-          \"on the HotSpot heap. Defaults to true if EnableJVMCIProduct is \" \\\n+          \"on the HotSpot heap. Defaults to true if EnableJVMCI is \"        \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  inline static size_t malloc_overhead() { return sizeof(MallocHeader) + sizeof(uint16_t); }\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-    return _all_mallocs.count() * sizeof(MallocHeader);\n+    return _all_mallocs.count() * MallocHeader::malloc_overhead();\n@@ -272,1 +272,1 @@\n-  static const size_t overhead_per_malloc = sizeof(MallocHeader) + sizeof(uint16_t);\n+  static inline size_t overhead_per_malloc() { return MallocHeader::malloc_overhead(); }\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    return enabled() ? MallocTracker::overhead_per_malloc : 0;\n+    return enabled() ? MallocTracker::overhead_per_malloc() : 0;\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,4 @@\n-NarrowPtrStruct CompressedOops::_narrow_oop = { nullptr, 0, true };\n-MemRegion       CompressedOops::_heap_address_range;\n+address CompressedOops::_base = nullptr;\n+int CompressedOops::_shift = 0;\n+bool CompressedOops::_use_implicit_null_checks = true;\n+MemRegion CompressedOops::_heap_address_range;\n@@ -91,1 +93,1 @@\n-  _narrow_oop._base    = base;\n+  _base = base;\n@@ -95,1 +97,1 @@\n-  _narrow_oop._shift   = shift;\n+  _shift = shift;\n@@ -100,1 +102,1 @@\n-  _narrow_oop._use_implicit_null_checks   = use;\n+  _use_implicit_null_checks = use;\n@@ -151,1 +153,1 @@\n-  return _narrow_oop._base != nullptr && is_disjoint_heap_base_address(_narrow_oop._base);\n+  return _base != nullptr && is_disjoint_heap_base_address(_base);\n@@ -158,1 +160,1 @@\n-  return _narrow_oop._base != nullptr && !is_disjoint_heap_base_address(_narrow_oop._base);\n+  return _base != nullptr && !is_disjoint_heap_base_address(_base);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,1 +37,3 @@\n-struct NarrowPtrStruct {\n+class CompressedOops : public AllStatic {\n+  friend class VMStructs;\n+\n@@ -40,1 +42,1 @@\n-  address _base;\n+  static address _base;\n@@ -42,1 +44,1 @@\n-  \/\/ 0 if using wide ptrs or zero based unscaled narrow ptrs,\n+  \/\/ 0 if using wide oops or zero based unscaled narrow oops,\n@@ -44,10 +46,3 @@\n-  int     _shift;\n-  \/\/ Generate code with implicit null checks for narrow ptrs.\n-  bool    _use_implicit_null_checks;\n-};\n-\n-class CompressedOops : public AllStatic {\n-  friend class VMStructs;\n-\n-  \/\/ For UseCompressedOops.\n-  static NarrowPtrStruct _narrow_oop;\n+  static int _shift;\n+  \/\/ Generate code with implicit null checks for narrow oops.\n+  static bool _use_implicit_null_checks;\n@@ -76,2 +71,1 @@\n-    HeapBasedNarrowOop = 3,\n-    AnyNarrowOopMode = 4\n+    HeapBasedNarrowOop = 3\n@@ -90,2 +84,2 @@\n-  static address  base()                     { return _narrow_oop._base; }\n-  static address  base_addr()                { return (address)&_narrow_oop._base; }\n+  static address  base()                     { return _base; }\n+  static address  base_addr()                { return (address)&_base; }\n@@ -95,2 +89,2 @@\n-  static int      shift()                    { return _narrow_oop._shift; }\n-  static bool     use_implicit_null_checks() { return _narrow_oop._use_implicit_null_checks; }\n+  static int      shift()                    { return _shift; }\n+  static bool     use_implicit_null_checks() { return _use_implicit_null_checks; }\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -606,0 +606,1 @@\n+      assert(!old_method->is_deleted(), \"cannot delete these methods\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+  product(bool, StressUnstableIfTraps, false, DIAGNOSTIC,                   \\\n+          \"Randomly take unstable if traps\")                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -613,0 +613,1 @@\n+  case vmIntrinsics::_dtanh:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -350,1 +350,0 @@\n-  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call) const;\n@@ -445,0 +444,1 @@\n+  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -722,0 +722,5 @@\n+  if (StressLCM || StressGCM || StressIGVN || StressCCP ||\n+      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps) {\n+    initialize_stress_seed(directive);\n+  }\n+\n@@ -846,5 +851,0 @@\n-  if (StressLCM || StressGCM || StressIGVN || StressCCP ||\n-      StressIncrementalInlining || StressMacroExpansion) {\n-    initialize_stress_seed(directive);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -843,1 +843,1 @@\n-ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call) const {\n+ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason) const {\n@@ -845,1 +845,1 @@\n-    call = proj_out(i)->is_uncommon_trap_proj();\n+    call = proj_out(i)->is_uncommon_trap_proj(reason);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -1882,0 +1883,3 @@\n+  case vmIntrinsics::_dtanh:\n+    return StubRoutines::dtanh() != nullptr ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtanh(), \"dtanh\") : false;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1921,1 +1921,2 @@\n-  \/\/         final_correction = canonicalized_correction + limit_correction\n+  \/\/         (v) final_correction = canonicalized_correction + limit_correction\n+  \/\/\n@@ -1927,0 +1928,15 @@\n+  \/\/     However, we need to be careful that (v) does not over- or underflow.\n+  \/\/     We know that:\n+  \/\/         canonicalized_correction = stride - 1\n+  \/\/     and\n+  \/\/         limit_correction <= stride + 1\n+  \/\/     and thus\n+  \/\/         canonicalized_correction + limit_correction <= 2 * stride\n+  \/\/     To prevent an over- or underflow of (v), we must ensure that\n+  \/\/         2 * stride <= max_int\n+  \/\/     which can safely be checked without over- or underflow with\n+  \/\/         (vi) stride != min_int AND abs(stride) <= max_int \/ 2\n+  \/\/\n+  \/\/     We could try to further optimize the cases where (vi) does not hold but given that such large strides are\n+  \/\/     very uncommon and the loop would only run for a very few iterations anyway, we simply bail out if (vi) fails.\n+  \/\/\n@@ -1957,0 +1973,4 @@\n+  \/\/ Check (vi) and bail out if the stride is too big.\n+  if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -615,0 +615,5 @@\n+  \/\/ Stress unstable if traps\n+  void stress_trap(IfNode* orig_iff, Node* counter, Node* incr_store);\n+  \/\/ Increment counter used by StressUnstableIfTraps\n+  void increment_trap_stress_counter(Node*& counter, Node*& incr_store);\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1374,0 +1374,10 @@\n+\/\/ Used by StressUnstableIfTraps\n+static volatile int _trap_stress_counter = 0;\n+\n+void Parse::increment_trap_stress_counter(Node*& counter, Node*& incr_store) {\n+  Node* counter_addr = makecon(TypeRawPtr::make((address)&_trap_stress_counter));\n+  counter = make_load(control(), counter_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+  counter = _gvn.transform(new AddINode(counter, intcon(1)));\n+  incr_store = store_to_memory(control(), counter_addr, counter, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+}\n+\n@@ -1378,0 +1388,7 @@\n+  Node* counter = nullptr;\n+  Node* incr_store = nullptr;\n+  bool do_stress_trap = StressUnstableIfTraps && ((C->random() % 2) == 0);\n+  if (do_stress_trap) {\n+    increment_trap_stress_counter(counter, incr_store);\n+  }\n+\n@@ -1442,0 +1459,4 @@\n+\n+  if (do_stress_trap) {\n+    stress_trap(iff, counter, incr_store);\n+  }\n@@ -1471,0 +1492,7 @@\n+  Node* counter = nullptr;\n+  Node* incr_store = nullptr;\n+  bool do_stress_trap = StressUnstableIfTraps && ((C->random() % 2) == 0);\n+  if (do_stress_trap) {\n+    increment_trap_stress_counter(counter, incr_store);\n+  }\n+\n@@ -1553,0 +1581,45 @@\n+\n+  if (do_stress_trap) {\n+    stress_trap(iff, counter, incr_store);\n+  }\n+}\n+\n+\/\/ Force unstable if traps to be taken randomly to trigger intermittent bugs such as incorrect debug information.\n+\/\/ Add another if before the unstable if that checks a \"random\" condition at runtime (a simple shared counter) and\n+\/\/ then either takes the trap or executes the original, unstable if.\n+void Parse::stress_trap(IfNode* orig_iff, Node* counter, Node* incr_store) {\n+  \/\/ Search for an unstable if trap\n+  CallStaticJavaNode* trap = nullptr;\n+  assert(orig_iff->Opcode() == Op_If && orig_iff->outcnt() == 2, \"malformed if\");\n+  ProjNode* trap_proj = orig_iff->uncommon_trap_proj(trap, Deoptimization::Reason_unstable_if);\n+  if (trap == nullptr || !trap->jvms()->should_reexecute()) {\n+    \/\/ No suitable trap found. Remove unused counter load and increment.\n+    C->gvn_replace_by(incr_store, incr_store->in(MemNode::Memory));\n+    return;\n+  }\n+\n+  \/\/ Remove trap from optimization list since we add another path to the trap.\n+  bool success = C->remove_unstable_if_trap(trap, true);\n+  assert(success, \"Trap already modified\");\n+\n+  \/\/ Add a check before the original if that will trap with a certain frequency and execute the original if otherwise\n+  int freq_log = (C->random() % 31) + 1; \/\/ Random logarithmic frequency in [1, 31]\n+  Node* mask = intcon(right_n_bits(freq_log));\n+  counter = _gvn.transform(new AndINode(counter, mask));\n+  Node* cmp = _gvn.transform(new CmpINode(counter, intcon(0)));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::mask::eq));\n+  IfNode* iff = _gvn.transform(new IfNode(orig_iff->in(0), bol, orig_iff->_prob, orig_iff->_fcnt))->as_If();\n+  Node* if_true = _gvn.transform(new IfTrueNode(iff));\n+  Node* if_false = _gvn.transform(new IfFalseNode(iff));\n+  assert(!if_true->is_top() && !if_false->is_top(), \"trap always \/ never taken\");\n+\n+  \/\/ Trap\n+  assert(trap_proj->outcnt() == 1, \"some other nodes are dependent on the trap projection\");\n+\n+  Node* trap_region = new RegionNode(3);\n+  trap_region->set_req(1, trap_proj);\n+  trap_region->set_req(2, if_true);\n+  trap->set_req(0, _gvn.transform(trap_region));\n+\n+  \/\/ Don't trap, execute original if\n+  orig_iff->set_req(0, if_false);\n@@ -1556,0 +1629,4 @@\n+  \/\/ Randomly skip emitting an uncommon trap\n+  if (StressUnstableIfTraps && ((C->random() % 2) == 0)) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-      strcmp(value, \"on\")) {\n+      strcmp(value, \"on\") != 0) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -1320,0 +1321,5 @@\n+  \/\/ Ask if any OopStorage knows about this address.\n+  if (OopStorageSet::print_containing(addr, st)) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+address StubRoutines::_dtanh = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+  static address _dtanh;\n@@ -475,0 +476,1 @@\n+  static address dtanh()               { return _dtanh; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,3 +376,3 @@\n-     static_field(CompressedOops,              _narrow_oop._base,                             address)                               \\\n-     static_field(CompressedOops,              _narrow_oop._shift,                            int)                                   \\\n-     static_field(CompressedOops,              _narrow_oop._use_implicit_null_checks,         bool)                                  \\\n+     static_field(CompressedOops,              _base,                                         address)                               \\\n+     static_field(CompressedOops,              _shift,                                        int)                                   \\\n+     static_field(CompressedOops,              _use_implicit_null_checks,                     bool)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,109 +63,73 @@\n- * If a processor \/ os combination has the ability to run binaries of\n- * two data models and cohabitation of jre\/jdk bits with both data\n- * models is supported, then DUAL_MODE is defined. MacOSX is a hybrid\n- * system in that, the universal library can contain all types of libraries\n- * 32\/64 and client\/server, thus the spawn is capable of linking with the\n- * appropriate library as requested.\n- *\n- * Notes:\n- * 1. VM. DUAL_MODE is disabled, and not supported, however, it is left here in\n- *    for experimentation and perhaps enable it in the future.\n- * 2. At the time of this writing, the universal library contains only\n- *    a server 64-bit server JVM.\n- * 3. \"-client\" command line option is supported merely as a command line flag,\n- *    for, compatibility reasons, however, a server VM will be launched.\n- *\/\n-\n-\/*\n- * Flowchart of launcher execs and options processing on unix\n- *\n- * The selection of the proper vm shared library to open depends on\n- * several classes of command line options, including vm \"flavor\"\n- * options (-client, -server) and the data model options, -d32  and\n- * -d64, as well as a version specification which may have come from\n- * the command line or from the manifest of an executable jar file.\n- * The vm selection options are not passed to the running\n- * virtual machine; they must be screened out by the launcher.\n- *\n- * The version specification (if any) is processed first by the\n- * platform independent routine SelectVersion.  This may result in\n- * the exec of the specified launcher version.\n- *\n- * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n- * required libraries are loaded by the runtime linker, using the known paths\n- * baked into the shared libraries at compile time. Therefore,\n- * in most cases, the launcher will only exec, if the data models are\n- * mismatched, and will not set any environment variables, regardless of the\n- * data models.\n- *\n- *\n- *\n- *  Main\n- *  (incoming argv)\n- *  |\n- * \\|\/\n- * CreateExecutionEnvironment\n- * (determines desired data model)\n- *  |\n- *  |\n- * \\|\/\n- *  Have Desired Model ? --> NO --> Is Dual-Mode ? --> NO --> Exit(with error)\n- *  |                                          |\n- *  |                                          |\n- *  |                                         \\|\/\n- *  |                                         YES\n- *  |                                          |\n- *  |                                          |\n- *  |                                         \\|\/\n- *  |                                CheckJvmType\n- *  |                               (removes -client, -server etc.)\n- *  |                                          |\n- *  |                                          |\n- * \\|\/                                        \\|\/\n- * YES                             Find the desired executable\/library\n- *  |                                          |\n- *  |                                          |\n- * \\|\/                                        \\|\/\n- * CheckJvmType                             POINT A\n- * (removes -client, -server, etc.)\n- *  |\n- *  |\n- * \\|\/\n- * TranslateDashJArgs...\n- * (Prepare to pass args to vm)\n- *  |\n- *  |\n- * \\|\/\n- * ParseArguments\n- * (processes version options,\n- *  creates argument list for vm,\n- *  etc.)\n- *   |\n- *   |\n- *  \\|\/\n- * POINT A\n- *   |\n- *   |\n- *  \\|\/\n- * Path is desired JRE ? YES --> Continue\n- *  NO\n- *   |\n- *   |\n- *  \\|\/\n- * Paths have well known\n- * jvm paths ?       --> NO --> Continue\n- *  YES\n- *   |\n- *   |\n- *  \\|\/\n- *  Does libjvm.so exist\n- *  in any of them ? --> NO --> Continue\n- *   YES\n- *   |\n- *   |\n- *  \\|\/\n- * Re-exec \/ Spawn\n- *   |\n- *   |\n- *  \\|\/\n- * Main\n+ * Following is the high level flow of the launcher\n+ * code residing in the common java.c and this\n+ * macosx specific java_md_macosx file:\n+ *\n+ *  - JLI_Launch function, which is the entry point\n+ *    to the launcher, calls CreateExecutionEnvironment.\n+ *\n+ *  - CreateExecutionEnvironment does the following\n+ *    (not necessarily in this order):\n+ *      - determines the relevant JVM type that needs\n+ *        to be ultimately created\n+ *      - determines the path and asserts the presence\n+ *        of libjava and relevant libjvm library\n+ *      - removes any JVM selection options from the\n+ *        arguments that were passed to the launcher\n+ *\n+ *  - CreateExecutionEnvironment then creates a new\n+ *    thread, within the same process, to launch the\n+ *    application's main() Java method and parks the\n+ *    current thread, on which CreateExecutionEnvironment\n+ *    was invoked, in Apple's Cocoa event loop. Before\n+ *    doing so, CreateExecutionEnvironment maintains a\n+ *    state flag to keep note that a new thread has\n+ *    been spawned.\n+ *\n+ *  - The newly created thread (in which the application's\n+ *    main() method will ultimately run) starts right from\n+ *    the beginning of the current process' main function,\n+ *    which effectively means that JLI_Launch is re-invoked\n+ *    on this new thread and the same above sequence of code\n+ *    flow repeats again. During this \"recursive\" call, when\n+ *    at the point of creating a new thread in\n+ *    CreateExecutionEnvironment, the CreateExecutionEnvironment\n+ *    will check for the state flag to see if a new thread\n+ *    has already been spawned and upon noticing that it\n+ *    has, it will skip spawning any more threads and will\n+ *    return back from CreateExecutionEnvironment.\n+ *\n+ *  - The control returns back from CreateExecutionEnvironment\n+ *    to JLI_Launch, and the thread on which the control\n+ *    returns is the thread on which the application's main()\n+ *    Java method will be invoked.\n+ *\n+ *  - JLI_Launch then invokes LoadJavaVM which dlopen()s the\n+ *    JVM library and asserts the presence of JNI Invocation\n+ *    Functions \"JNI_CreateJavaVM\", \"JNI_GetDefaultJavaVMInitArgs\"\n+ *    and \"JNI_GetCreatedJavaVMs\" in that library. It then sets\n+ *    internal function pointers in the launcher to point to\n+ *    those functions.\n+ *\n+ *  - JLI_Launch then translates any -J options by invoking\n+ *    TranslateApplicationArgs.\n+ *\n+ *  - JLI_Launch then invokes ParseArguments to parse\/process\n+ *    the launcher arguments.\n+ *\n+ *  - JLI_Launch then ultimately calls JVMInit.\n+ *\n+ *  - JVMInit then invokes JavaMain.\n+ *\n+ *  - JavaMain, before launching the application, invokes\n+ *    PostJVMInit.\n+ *\n+ *  - PostJVMInit invokes ShowSplashScreen which displays\n+ *    a splash screen for the application, if applicable.\n+ *\n+ *  - Control then returns back from PostJVMInit into\n+ *    JavaMain, which then loads the application's main\n+ *    class and invokes the relevant main() Java method.\n+ *\n+ *  - JavaMain then returns back an integer result which\n+ *    then gets propagated as a return value all the way\n+ *    out of the JLI_Launch function.\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":73,"deletions":109,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -28,0 +29,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -30,0 +33,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -48,0 +52,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -576,2 +581,1 @@\n-        byte[] bytearr;\n-        char[] chararr;\n+        byte[] bytearr = null;\n@@ -579,3 +583,2 @@\n-            if (dis.bytearr.length < utflen) {\n-                dis.bytearr = new byte[utflen*2];\n-                dis.chararr = new char[utflen*2];\n+            if (dis.bytearr.length >= utflen) {\n+                bytearr = dis.bytearr;\n@@ -583,3 +586,3 @@\n-            chararr = dis.chararr;\n-            bytearr = dis.bytearr;\n-        } else {\n+        }\n+        boolean trusted = false;\n+        if (bytearr == null) {\n@@ -587,1 +590,1 @@\n-            chararr = new char[utflen];\n+            trusted = true;\n@@ -595,0 +598,14 @@\n+        int ascii = JLA.countPositives(bytearr, 0, utflen);\n+        if (ascii == utflen) {\n+            String str;\n+            if (trusted) {\n+                str = JLA.newStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n+            } else {\n+                str = new String(bytearr, 0, utflen, StandardCharsets.ISO_8859_1);\n+            }\n+            return str;\n+        }\n+        if (trusted && in instanceof DataInputStream dis) {\n+            dis.bytearr = bytearr;\n+            trusted = false;\n+        }\n@@ -596,5 +613,14 @@\n-        while (count < utflen) {\n-            c = (int) bytearr[count] & 0xff;\n-            if (c > 127) break;\n-            count++;\n-            chararr[chararr_count++]=(char)c;\n+        char[] chararr;\n+        if (in instanceof DataInputStream dis) {\n+            if (dis.chararr.length < (utflen << 1)) {\n+                dis.chararr = new char[utflen << 1];\n+            }\n+            chararr = dis.chararr;\n+        } else {\n+            chararr = new char[utflen];\n+        }\n+\n+        if (ascii != 0) {\n+            JLA.inflateBytesToChars(bytearr, 0, chararr, 0, ascii);\n+            count += ascii;\n+            chararr_count += ascii;\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2740,0 +2740,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -276,9 +277,3 @@\n-        private static final VarHandle COUNT;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                COUNT = l.findVarHandle(BaseThreadFactory.class, \"count\", long.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n+        private static final VarHandle COUNT = MhUtil.findVarHandle(\n+                MethodHandles.lookup(), \"count\", long.class);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadBuilders.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -618,26 +618,4 @@\n-            if (value instanceof Integer iVal)\n-                return switch (iVal) {\n-                    case -1 -> iconst_m1();\n-                    case 0 -> iconst_0();\n-                    case 1 -> iconst_1();\n-                    case 2 -> iconst_2();\n-                    case 3 -> iconst_3();\n-                    case 4 -> iconst_4();\n-                    case 5 -> iconst_5();\n-                    default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n-                            : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n-                            : ldc(constantPool().intEntry(iVal));\n-                };\n-            if (value instanceof Long lVal)\n-                return lVal == 0L ? lconst_0()\n-                        : lVal == 1L ? lconst_1()\n-                        : ldc(constantPool().longEntry(lVal));\n-            if (value instanceof Float fVal)\n-                return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n-                        : fVal == 1.0f ? fconst_1()\n-                        : fVal == 2.0f ? fconst_2()\n-                        : ldc(constantPool().floatEntry(fVal));\n-            if (value instanceof Double dVal)\n-                return Double.doubleToRawLongBits(dVal) == 0L ? dconst_0()\n-                        : dVal == 1.0d ? dconst_1()\n-                        : ldc(constantPool().doubleEntry(dVal));\n+            if (value instanceof Integer) return loadConstant((int)    value);\n+            if (value instanceof Long   ) return loadConstant((long)   value);\n+            if (value instanceof Float  ) return loadConstant((float)  value);\n+            if (value instanceof Double ) return loadConstant((double) value);\n@@ -648,0 +626,63 @@\n+\n+    \/**\n+     * Generate an instruction pushing a constant int value onto the operand stack.\n+     * This is identical to {@link #loadConstant(ConstantDesc) loadConstant(Integer.valueOf(value))}.\n+     * @param value the int value\n+     * @return this builder\n+     * @since 24\n+     *\/\n+    default CodeBuilder loadConstant(int value) {\n+        return switch (value) {\n+            case -1 -> iconst_m1();\n+            case  0 -> iconst_0();\n+            case  1 -> iconst_1();\n+            case  2 -> iconst_2();\n+            case  3 -> iconst_3();\n+            case  4 -> iconst_4();\n+            case  5 -> iconst_5();\n+            default -> (value >= Byte.MIN_VALUE  && value <= Byte.MAX_VALUE ) ? bipush(value)\n+                     : (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) ? sipush(value)\n+                     : ldc(constantPool().intEntry(value));\n+        };\n+    }\n+\n+    \/**\n+     * Generate an instruction pushing a constant long value onto the operand stack.\n+     * This is identical to {@link #loadConstant(ConstantDesc) loadConstant(Long.valueOf(value))}.\n+     * @param value the long value\n+     * @return this builder\n+     * @since 24\n+     *\/\n+    default CodeBuilder loadConstant(long value) {\n+        return value == 0l ? lconst_0()\n+             : value == 1l ? lconst_1()\n+             : ldc(constantPool().longEntry(value));\n+    }\n+\n+    \/**\n+     * Generate an instruction pushing a constant float value onto the operand stack.\n+     * This is identical to {@link #loadConstant(ConstantDesc) loadConstant(Float.valueOf(value))}.\n+     * @param value the float value\n+     * @return this builder\n+     * @since 24\n+     *\/\n+    default CodeBuilder loadConstant(float value) {\n+        return Float.floatToRawIntBits(value) == 0 ? fconst_0()\n+             : value == 1.0f                       ? fconst_1()\n+             : value == 2.0f                       ? fconst_2()\n+             : ldc(constantPool().floatEntry(value));\n+    }\n+\n+    \/**\n+     * Generate an instruction pushing a constant double value onto the operand stack.\n+     * This is identical to {@link #loadConstant(ConstantDesc) loadConstant(Double.valueOf(value))}.\n+     * @param value the double value\n+     * @return this builder\n+     * @since 24\n+     *\/\n+    default CodeBuilder loadConstant(double value) {\n+        return Double.doubleToRawLongBits(value) == 0l ? dconst_0()\n+             : value == 1.0d                           ? dconst_1()\n+             : ldc(constantPool().doubleEntry(value));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":67,"deletions":26,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1648,1 +1648,1 @@\n-                    cob.loadConstant(os.toString());\n+                    cob.ldc(os.toString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -684,10 +685,3 @@\n-        private static final MethodHandle MH_asSpreader;\n-\n-        static {\n-            try {\n-                MH_asSpreader = IMPL_LOOKUP.findVirtual(MethodHandle.class, \"asSpreader\",\n-                        MethodType.methodType(MethodHandle.class, Class.class, int.class));\n-            } catch (ReflectiveOperationException ex) {\n-                throw newInternalError(ex);\n-            }\n-        }\n+        private static final MethodHandle MH_asSpreader = MhUtil.findVirtual(\n+                IMPL_LOOKUP, MethodHandle.class, \"asSpreader\",\n+                MethodType.methodType(MethodHandle.class, Class.class, int.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import static java.lang.invoke.MethodHandleStatics.NO_SOFT_CACHE;\n@@ -92,1 +93,2 @@\n-    private static final class Transform extends SoftReference<LambdaForm> {\n+    private static final class Transform {\n+        final Object cache;\n@@ -97,1 +99,5 @@\n-            super(result);\n+            if (NO_SOFT_CACHE) {\n+                cache = result;\n+            } else {\n+                cache = new SoftReference<LambdaForm>(result);\n+            }\n@@ -138,0 +144,9 @@\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        public LambdaForm get() {\n+            if (cache instanceof LambdaForm lf) {\n+                return lf;\n+            } else {\n+                return ((SoftReference<LambdaForm>)cache).get();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    static final boolean NO_SOFT_CACHE; \/\/ Don't use SoftReference in LambdaFormEditor and MethodTypeForm so they can be archived by CDS.\n@@ -91,0 +92,1 @@\n+        NO_SOFT_CACHE = CDS.disableMethodHandleSoftCache();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -43,0 +44,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -2245,8 +2247,12 @@\n-        static class ClassFile {\n-            final String name;  \/\/ internal name\n-            final int accessFlags;\n-            final byte[] bytes;\n-            ClassFile(String name, int accessFlags, byte[] bytes) {\n-                this.name = name;\n-                this.accessFlags = accessFlags;\n-                this.bytes = bytes;\n+        \/**\n+         * This method checks the class file version and the structure of `this_class`.\n+         * and checks if the bytes is a class or interface (ACC_MODULE flag not set)\n+         * that is in the named package.\n+         *\n+         * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags\n+         * or the class is not in the given package name.\n+         *\/\n+        static String validateAndFindInternalName(byte[] bytes, String pkgName) {\n+            int magic = readInt(bytes, 0);\n+            if (magic != ClassFile.MAGIC_NUMBER) {\n+                throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n@@ -2254,0 +2260,4 @@\n+            \/\/ We have to read major and minor this way as ClassFile API throws IAE\n+            \/\/ yet we want distinct ClassFormatError and UnsupportedClassVersionError\n+            int minor = readUnsignedShort(bytes, 4);\n+            int major = readUnsignedShort(bytes, 6);\n@@ -2255,2 +2265,2 @@\n-            static ClassFile newInstanceNoCheck(String name, byte[] bytes) {\n-                return new ClassFile(name, 0, bytes);\n+            if (!VM.isSupportedClassFileVersion(major, minor)) {\n+                throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n@@ -2259,18 +2269,17 @@\n-            \/**\n-             * This method checks the class file version and the structure of `this_class`.\n-             * and checks if the bytes is a class or interface (ACC_MODULE flag not set)\n-             * that is in the named package.\n-             *\n-             * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags\n-             * or the class is not in the given package name.\n-             *\/\n-            static ClassFile newInstance(byte[] bytes, String pkgName) {\n-                var cf = readClassFile(bytes);\n-\n-                \/\/ check if it's in the named package\n-                int index = cf.name.lastIndexOf('\/');\n-                String pn = (index == -1) ? \"\" : cf.name.substring(0, index).replace('\/', '.');\n-                if (!pn.equals(pkgName)) {\n-                    throw newIllegalArgumentException(cf.name + \" not in same package as lookup class\");\n-                }\n-                return cf;\n+            String name;\n+            ClassDesc sym;\n+            int accessFlags;\n+            try {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n+                var thisClass = cm.thisClass();\n+                name = thisClass.asInternalName();\n+                sym = thisClass.asSymbol();\n+                accessFlags = cm.flags().flagsMask();\n+            } catch (IllegalArgumentException e) {\n+                ClassFormatError cfe = new ClassFormatError();\n+                cfe.initCause(e);\n+                throw cfe;\n+            }\n+            \/\/ must be a class or interface\n+            if ((accessFlags & ACC_MODULE) != 0) {\n+                throw newIllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n@@ -2279,27 +2288,3 @@\n-            private static ClassFile readClassFile(byte[] bytes) {\n-                int magic = readInt(bytes, 0);\n-                if (magic != 0xCAFEBABE) {\n-                    throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n-                }\n-                int minor = readUnsignedShort(bytes, 4);\n-                int major = readUnsignedShort(bytes, 6);\n-                if (!VM.isSupportedClassFileVersion(major, minor)) {\n-                    throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n-                }\n-\n-                String name;\n-                int accessFlags;\n-                try {\n-                    ClassModel cm = java.lang.classfile.ClassFile.of().parse(bytes);\n-                    name = cm.thisClass().asInternalName();\n-                    accessFlags = cm.flags().flagsMask();\n-                } catch (IllegalArgumentException e) {\n-                    ClassFormatError cfe = new ClassFormatError();\n-                    cfe.initCause(e);\n-                    throw cfe;\n-                }\n-                \/\/ must be a class or interface\n-                if ((accessFlags & ACC_MODULE) != 0) {\n-                    throw newIllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n-                }\n-                return new ClassFile(name, accessFlags, bytes);\n+            String pn = sym.packageName();\n+            if (!pn.equals(pkgName)) {\n+                throw newIllegalArgumentException(name + \" not in same package as lookup class\");\n@@ -2308,8 +2293,6 @@\n-            private static int readInt(byte[] bytes, int offset) {\n-                if ((offset+4) > bytes.length) {\n-                    throw new ClassFormatError(\"Invalid ClassFile structure\");\n-                }\n-                return ((bytes[offset] & 0xFF) << 24)\n-                        | ((bytes[offset + 1] & 0xFF) << 16)\n-                        | ((bytes[offset + 2] & 0xFF) << 8)\n-                        | (bytes[offset + 3] & 0xFF);\n+            return name;\n+        }\n+\n+        private static int readInt(byte[] bytes, int offset) {\n+            if ((offset + 4) > bytes.length) {\n+                throw new ClassFormatError(\"Invalid ClassFile structure\");\n@@ -2317,0 +2300,5 @@\n+            return ((bytes[offset] & 0xFF) << 24)\n+                    | ((bytes[offset + 1] & 0xFF) << 16)\n+                    | ((bytes[offset + 2] & 0xFF) << 8)\n+                    | (bytes[offset + 3] & 0xFF);\n+        }\n@@ -2318,5 +2306,3 @@\n-            private static int readUnsignedShort(byte[] bytes, int offset) {\n-                if ((offset+2) > bytes.length) {\n-                    throw new ClassFormatError(\"Invalid ClassFile structure\");\n-                }\n-                return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n+        private static int readUnsignedShort(byte[] bytes, int offset) {\n+            if ((offset+2) > bytes.length) {\n+                throw new ClassFormatError(\"Invalid ClassFile structure\");\n@@ -2324,0 +2310,1 @@\n+            return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n@@ -2337,2 +2324,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, defaultDumper());\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return new ClassDefiner(this, internalName, bytes, STRONG_LOADER_LINK, defaultDumper());\n@@ -2345,1 +2332,1 @@\n-         * @param name    internal name\n+         * @param internalName internal name\n@@ -2350,1 +2337,1 @@\n-        ClassDefiner makeClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+        ClassDefiner makeClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper) {\n@@ -2352,2 +2339,1 @@\n-            ClassFile cf = ClassFile.newInstanceNoCheck(name, bytes);\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, dumper);\n+            return new ClassDefiner(this, internalName, bytes, STRONG_LOADER_LINK, dumper);\n@@ -2371,2 +2357,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return makeHiddenClassDefiner(cf, false, dumper, 0);\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, 0);\n@@ -2394,2 +2380,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return makeHiddenClassDefiner(cf, accessVmAnnotations, defaultDumper(), flags);\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return makeHiddenClassDefiner(internalName, bytes, accessVmAnnotations, defaultDumper(), flags);\n@@ -2402,1 +2388,1 @@\n-         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param internalName internal name that specifies the prefix of the hidden class\n@@ -2407,1 +2393,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+        ClassDefiner makeHiddenClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper) {\n@@ -2410,1 +2396,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, 0);\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, 0);\n@@ -2417,1 +2403,1 @@\n-         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param internalName internal name that specifies the prefix of the hidden class\n@@ -2423,1 +2409,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper, int flags) {\n+        ClassDefiner makeHiddenClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper, int flags) {\n@@ -2426,1 +2412,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, flags);\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, flags);\n@@ -2433,1 +2419,2 @@\n-         * @param cf ClassFile\n+         * @param internalName internal name\n+         * @param bytes Class byte array\n@@ -2438,1 +2425,2 @@\n-        private ClassDefiner makeHiddenClassDefiner(ClassFile cf,\n+        private ClassDefiner makeHiddenClassDefiner(String internalName,\n+                                                    byte[] bytes,\n@@ -2449,1 +2437,1 @@\n-            return new ClassDefiner(this, cf, flags, dumper);\n+            return new ClassDefiner(this, internalName, bytes, flags, dumper);\n@@ -2452,18 +2440,3 @@\n-        static class ClassDefiner {\n-            private final Lookup lookup;\n-            private final String name;  \/\/ internal name\n-            private final byte[] bytes;\n-            private final int classFlags;\n-            private final ClassFileDumper dumper;\n-\n-            private ClassDefiner(Lookup lookup, ClassFile cf, int flags, ClassFileDumper dumper) {\n-                assert ((flags & HIDDEN_CLASS) != 0 || (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);\n-                this.lookup = lookup;\n-                this.bytes = cf.bytes;\n-                this.name = cf.name;\n-                this.classFlags = flags;\n-                this.dumper = dumper;\n-            }\n-\n-            String internalName() {\n-                return name;\n+        record ClassDefiner(Lookup lookup, String internalName, byte[] bytes, int classFlags, ClassFileDumper dumper) {\n+            ClassDefiner {\n+                assert ((classFlags & HIDDEN_CLASS) != 0 || (classFlags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);\n@@ -2498,1 +2471,1 @@\n-                            .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n+                            .defineClass(loader, lookupClass, internalName, bytes, pd, initialize, classFlags, classData);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":79,"deletions":106,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static java.lang.invoke.MethodHandleStatics.NO_SOFT_CACHE;\n@@ -54,1 +55,1 @@\n-    final SoftReference<MethodHandle>[] methodHandles;\n+    private final Object[] methodHandles;\n@@ -64,1 +65,1 @@\n-    final SoftReference<LambdaForm>[] lambdaForms;\n+    private final Object[] lambdaForms;\n@@ -112,0 +113,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -113,2 +115,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = methodHandles[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof MethodHandle mh) {\n+            return mh;\n+        } else {\n+            return ((SoftReference<MethodHandle>)entry).get();\n+        }\n@@ -119,6 +127,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        if (entry != null) {\n-            MethodHandle prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        MethodHandle prev = cachedMethodHandle(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (NO_SOFT_CACHE) {\n+            methodHandles[which] = mh;\n+        } else {\n+            methodHandles[which] = new SoftReference<>(mh);\n@@ -126,1 +136,0 @@\n-        methodHandles[which] = new SoftReference<>(mh);\n@@ -130,0 +139,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -131,2 +141,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = lambdaForms[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof LambdaForm lf) {\n+            return lf;\n+        } else {\n+            return ((SoftReference<LambdaForm>)entry).get();\n+        }\n@@ -137,6 +153,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        if (entry != null) {\n-            LambdaForm prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        LambdaForm prev = cachedLambdaForm(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (NO_SOFT_CACHE) {\n+            lambdaForms[which] = form;\n+        } else {\n+            lambdaForms[which] = new SoftReference<>(form);\n@@ -144,1 +162,0 @@\n-        lambdaForms[which] = new SoftReference<>(form);\n@@ -194,2 +211,2 @@\n-            this.lambdaForms   = new SoftReference[LF_LIMIT];\n-            this.methodHandles = new SoftReference[MH_LIMIT];\n+            this.lambdaForms   = new Object[LF_LIMIT];\n+            this.methodHandles = new Object[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -277,1 +278,1 @@\n-        STORE_BARRIER.lazySet(0);\n+        UNSAFE.storeFence();\n@@ -283,1 +284,0 @@\n-    private static final AtomicInteger STORE_BARRIER = new AtomicInteger();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MutableCallSite.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,0 +117,4 @@\n+    private static final String OBJECT_HASH_CODE_SIG;\n+    private static final String OBJECT_EQUALS_SIG;\n+    private static final String OBJECT_TO_STRING_SIG;\n+\n@@ -120,0 +124,1 @@\n+            OBJECT_HASH_CODE_SIG = OBJECT_HASH_CODE_METHOD.toShortSignature();\n@@ -121,0 +126,1 @@\n+            OBJECT_EQUALS_SIG = OBJECT_EQUALS_METHOD.toShortSignature();\n@@ -122,0 +128,1 @@\n+            OBJECT_TO_STRING_SIG = OBJECT_TO_STRING_METHOD.toShortSignature();\n@@ -449,3 +456,3 @@\n-        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, OBJECT_HASH_CODE_SIG, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, OBJECT_EQUALS_SIG, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, OBJECT_TO_STRING_SIG, \"m2\"));\n@@ -529,1 +536,1 @@\n-        sigmethods.add(new ProxyMethod(m, sig, m.getSharedParameterTypes(), returnType,\n+        sigmethods.add(new ProxyMethod(m, sig, returnType,\n@@ -620,1 +627,1 @@\n-                            cob.aload(cob.parameterSlot(0))\n+                            cob.aload(0)\n@@ -624,1 +631,1 @@\n-                               .aload(cob.parameterSlot(0))\n+                               .aload(0)\n@@ -632,1 +639,1 @@\n-                               .aload(cob.parameterSlot(0))\n+                               .aload(0)\n@@ -653,1 +660,0 @@\n-        private final Class<?>[] parameterTypes;\n@@ -659,1 +665,1 @@\n-        private ProxyMethod(Method method, String sig, Class<?>[] parameterTypes,\n+        private ProxyMethod(Method method, String sig,\n@@ -664,1 +670,0 @@\n-            this.parameterTypes = parameterTypes;\n@@ -673,0 +678,4 @@\n+        private Class<?>[] parameterTypes() {\n+            return method.getSharedParameterTypes();\n+        }\n+\n@@ -678,3 +687,2 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n-            this(method, method.toShortSignature(),\n-                 method.getSharedParameterTypes(), method.getReturnType(),\n+        private ProxyMethod(Method method, String sig, String methodFieldName) {\n+            this(method, sig, method.getReturnType(),\n@@ -688,1 +696,1 @@\n-            var desc = methodTypeDesc(returnType, parameterTypes);\n+            var desc = methodTypeDesc(returnType, parameterTypes());\n@@ -691,1 +699,0 @@\n-            var catchList = computeUniqueCatchList(exceptionTypes);\n@@ -695,0 +702,1 @@\n+                        var catchList = computeUniqueCatchList(exceptionTypes);\n@@ -699,0 +707,1 @@\n+                        Class<?>[] parameterTypes = parameterTypes();\n@@ -787,0 +796,1 @@\n+            Class<?>[] parameterTypes = parameterTypes();\n@@ -820,4 +830,8 @@\n-            cob.ldc(cl.getName())\n-               .iconst_0() \/\/ false\n-               .aload(0)\/\/ classLoader\n-               .invokestatic(classForName);\n+            if (cl == Object.class) {\n+                cob.ldc(objectCE);\n+            } else {\n+                cob.ldc(cl.getName())\n+                        .iconst_0() \/\/ false\n+                        .aload(0)\/\/ classLoader\n+                        .invokestatic(classForName);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -105,8 +106,4 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            STATE = l.findVarHandle(Socket.class, \"state\", int.class);\n-            IN = l.findVarHandle(Socket.class, \"in\", InputStream.class);\n-            OUT = l.findVarHandle(Socket.class, \"out\", OutputStream.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        STATE = MhUtil.findVarHandle(l, \"state\", int.class);\n+        IN = MhUtil.findVarHandle(l, \"in\", InputStream.class);\n+        OUT = MhUtil.findVarHandle(l, \"out\", OutputStream.class);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -432,9 +434,3 @@\n-    private static final VarHandle ATTACHMENT;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            ATTACHMENT = l.findVarHandle(SelectionKey.class, \"attachment\", Object.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n+    private static final VarHandle ATTACHMENT = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"attachment\", Object.class);\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SelectionKey.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -49,9 +50,2 @@\n-    private static final VarHandle INVALID;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            INVALID = l.findVarHandle(AbstractSelectionKey.class, \"invalid\", boolean.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n+    private static final VarHandle INVALID = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"invalid\", boolean.class);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectionKey.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.invoke.MhUtil;\n@@ -75,9 +77,3 @@\n-    private static final VarHandle CLOSED;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            CLOSED = l.findVarHandle(AbstractSelector.class, \"closed\", boolean.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n+    private static final VarHandle CLOSED = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"closed\", boolean.class);\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelector.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -899,0 +899,10 @@\n+\n+        \/**\n+         * If this object is readonly, no new objects can be added to it using {@code add}.\n+         *\n+         * @return {@code true} if this object is marked as readonly, {@code false} otherwise.\n+         *\/\n+        @Override\n+        public boolean isReadOnly() {\n+            return perms.isReadOnly();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/Policy.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -29,3 +32,1 @@\n-import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.io.*;\n+import java.net.URI;\n@@ -33,0 +34,15 @@\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -35,0 +51,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +54,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -39,0 +55,3 @@\n+import sun.security.jca.GetInstance;\n+import sun.security.jca.ProviderList;\n+import sun.security.jca.Providers;\n@@ -42,2 +61,0 @@\n-import sun.security.jca.*;\n-\n@@ -66,1 +83,11 @@\n-    private static Properties props;\n+    private static final Properties props = new Properties() {\n+        @Override\n+        public synchronized Object put(Object key, Object val) {\n+            if (key instanceof String strKey && val instanceof String strVal &&\n+                    SecPropLoader.isInclude(strKey)) {\n+                SecPropLoader.loadInclude(strVal);\n+                return null;\n+            }\n+            return super.put(key, val);\n+        }\n+    };\n@@ -77,0 +104,210 @@\n+    private static final class SecPropLoader {\n+        private enum LoadingMode {OVERRIDE, APPEND}\n+\n+        private static final String OVERRIDE_SEC_PROP =\n+                \"security.overridePropertiesFile\";\n+\n+        private static final String EXTRA_SYS_PROP =\n+                \"java.security.properties\";\n+\n+        private static Path currentPath;\n+\n+        private static final Set<Path> activePaths = new HashSet<>();\n+\n+        static void loadAll() {\n+            \/\/ first load the master properties file to\n+            \/\/ determine the value of OVERRIDE_SEC_PROP\n+            loadMaster();\n+            loadExtra();\n+        }\n+\n+        static boolean isInclude(String key) {\n+            return \"include\".equals(key);\n+        }\n+\n+        static void checkReservedKey(String key)\n+                throws IllegalArgumentException {\n+            if (isInclude(key)) {\n+                throw new IllegalArgumentException(\"Key '\" + key +\n+                        \"' is reserved and cannot be used as a \" +\n+                        \"Security property name.\");\n+            }\n+        }\n+\n+        private static void loadMaster() {\n+            try {\n+                loadFromPath(Path.of(StaticProperty.javaHome(), \"conf\",\n+                        \"security\", \"java.security\"), LoadingMode.APPEND);\n+            } catch (IOException e) {\n+                throw new InternalError(\"Error loading java.security file\", e);\n+            }\n+        }\n+\n+        private static void loadExtra() {\n+            if (\"true\".equalsIgnoreCase(props.getProperty(OVERRIDE_SEC_PROP))) {\n+                String propFile = System.getProperty(EXTRA_SYS_PROP);\n+                if (propFile != null) {\n+                    LoadingMode mode = LoadingMode.APPEND;\n+                    if (propFile.startsWith(\"=\")) {\n+                        mode = LoadingMode.OVERRIDE;\n+                        propFile = propFile.substring(1);\n+                    }\n+                    try {\n+                        loadExtraHelper(propFile, mode);\n+                    } catch (Exception e) {\n+                        if (sdebug != null) {\n+                            sdebug.println(\"unable to load security \" +\n+                                    \"properties from \" + propFile);\n+                            e.printStackTrace();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static void loadExtraHelper(String propFile, LoadingMode mode)\n+                throws Exception {\n+            propFile = PropertyExpander.expand(propFile);\n+            if (propFile.isEmpty()) {\n+                throw new IOException(\"Empty extra properties file path\");\n+            }\n+\n+            \/\/ Try to interpret propFile as a path\n+            Exception error;\n+            if ((error = loadExtraFromPath(propFile, mode)) == null) {\n+                return;\n+            }\n+\n+            \/\/ Try to interpret propFile as a file URL\n+            URI uri = null;\n+            try {\n+                uri = new URI(propFile);\n+            } catch (Exception ignore) {}\n+            if (uri != null && \"file\".equalsIgnoreCase(uri.getScheme()) &&\n+                    (error = loadExtraFromFileUrl(uri, mode)) == null) {\n+                return;\n+            }\n+\n+            \/\/ Try to interpret propFile as a URL\n+            URL url;\n+            try {\n+                url = newURL(propFile);\n+            } catch (MalformedURLException ignore) {\n+                \/\/ URL has no scheme: previous error is more accurate\n+                throw error;\n+            }\n+            loadFromUrl(url, mode);\n+        }\n+\n+        private static Exception loadExtraFromPath(String propFile,\n+                LoadingMode mode) throws Exception {\n+            Path path;\n+            try {\n+                path = Path.of(propFile);\n+                if (!Files.exists(path)) {\n+                    return new FileNotFoundException(propFile);\n+                }\n+            } catch (InvalidPathException e) {\n+                return e;\n+            }\n+            loadFromPath(path, mode);\n+            return null;\n+        }\n+\n+\n+        private static Exception loadExtraFromFileUrl(URI uri, LoadingMode mode)\n+                throws Exception {\n+            Path path;\n+            try {\n+                path = Path.of(uri);\n+            } catch (Exception e) {\n+                return e;\n+            }\n+            loadFromPath(path, mode);\n+            return null;\n+        }\n+\n+        private static void reset(LoadingMode mode) {\n+            if (mode == LoadingMode.OVERRIDE) {\n+                if (sdebug != null) {\n+                    sdebug.println(\n+                            \"overriding other security properties files!\");\n+                }\n+                props.clear();\n+            }\n+        }\n+\n+        static void loadInclude(String propFile) {\n+            String expPropFile = PropertyExpander.expandNonStrict(propFile);\n+            if (sdebug != null) {\n+                sdebug.println(\"processing include: '\" + propFile + \"'\" +\n+                        (propFile.equals(expPropFile) ? \"\" :\n+                                \" (expanded to '\" + expPropFile + \"')\"));\n+            }\n+            try {\n+                Path path = Path.of(expPropFile);\n+                if (!path.isAbsolute()) {\n+                    if (currentPath == null) {\n+                        throw new InternalError(\"Cannot resolve '\" +\n+                                expPropFile + \"' relative path when included \" +\n+                                \"from a non-regular properties file \" +\n+                                \"(e.g. HTTP served file)\");\n+                    }\n+                    path = currentPath.resolveSibling(path);\n+                }\n+                loadFromPath(path, LoadingMode.APPEND);\n+            } catch (IOException | InvalidPathException e) {\n+                throw new InternalError(\"Unable to include '\" + expPropFile +\n+                        \"'\", e);\n+            }\n+        }\n+\n+        private static void loadFromPath(Path path, LoadingMode mode)\n+                throws IOException {\n+            boolean isRegularFile = Files.isRegularFile(path);\n+            if (isRegularFile) {\n+                path = path.toRealPath();\n+            } else if (Files.isDirectory(path)) {\n+                throw new IOException(\"Is a directory\");\n+            } else {\n+                path = path.toAbsolutePath();\n+            }\n+            if (activePaths.contains(path)) {\n+                throw new InternalError(\"Cyclic include of '\" + path + \"'\");\n+            }\n+            try (InputStream is = Files.newInputStream(path)) {\n+                reset(mode);\n+                Path previousPath = currentPath;\n+                currentPath = isRegularFile ? path : null;\n+                activePaths.add(path);\n+                try {\n+                    debugLoad(true, path);\n+                    props.load(is);\n+                    debugLoad(false, path);\n+                } finally {\n+                    activePaths.remove(path);\n+                    currentPath = previousPath;\n+                }\n+            }\n+        }\n+\n+        private static void loadFromUrl(URL url, LoadingMode mode)\n+                throws IOException {\n+            try (InputStream is = url.openStream()) {\n+                reset(mode);\n+                debugLoad(true, url);\n+                props.load(is);\n+                debugLoad(false, url);\n+            }\n+        }\n+\n+        private static void debugLoad(boolean start, Object source) {\n+            if (sdebug != null) {\n+                int level = activePaths.isEmpty() ? 1 : activePaths.size();\n+                sdebug.println((start ?\n+                        \">\".repeat(level) + \" starting to process \" :\n+                        \"<\".repeat(level) + \" finished processing \") + source);\n+            }\n+        }\n+    }\n+\n@@ -80,2 +317,1 @@\n-        \/\/ (the FileInputStream call and the File.exists call,\n-        \/\/ the securityPropFile call, etc)\n+        \/\/ (the FileInputStream call and the File.exists call, etc)\n@@ -97,22 +333,1 @@\n-        props = new Properties();\n-        boolean overrideAll = false;\n-\n-        \/\/ first load the system properties file\n-        \/\/ to determine the value of security.overridePropertiesFile\n-        File propFile = securityPropFile(\"java.security\");\n-        boolean success = loadProps(propFile, null, false);\n-        if (!success) {\n-            throw new InternalError(\"Error loading java.security file\");\n-        }\n-\n-        if (\"true\".equalsIgnoreCase(props.getProperty\n-                (\"security.overridePropertiesFile\"))) {\n-\n-            String extraPropFile = System.getProperty\n-                    (\"java.security.properties\");\n-            if (extraPropFile != null && extraPropFile.startsWith(\"=\")) {\n-                overrideAll = true;\n-                extraPropFile = extraPropFile.substring(1);\n-            }\n-            loadProps(null, extraPropFile, overrideAll);\n-        }\n+        SecPropLoader.loadAll();\n@@ -126,57 +341,0 @@\n-\n-    }\n-\n-    private static boolean loadProps(File masterFile, String extraPropFile, boolean overrideAll) {\n-        InputStream is = null;\n-        try {\n-            if (masterFile != null && masterFile.exists()) {\n-                is = new FileInputStream(masterFile);\n-            } else if (extraPropFile != null) {\n-                extraPropFile = PropertyExpander.expand(extraPropFile);\n-                File propFile = new File(extraPropFile);\n-                URL propURL;\n-                if (propFile.exists()) {\n-                    propURL = newURL\n-                            (\"file:\" + propFile.getCanonicalPath());\n-                } else {\n-                    propURL = newURL(extraPropFile);\n-                }\n-\n-                is = propURL.openStream();\n-                if (overrideAll) {\n-                    props = new Properties();\n-                    if (sdebug != null) {\n-                        sdebug.println\n-                                (\"overriding other security properties files!\");\n-                    }\n-                }\n-            } else {\n-                \/\/ unexpected\n-                return false;\n-            }\n-            props.load(is);\n-            if (sdebug != null) {\n-                \/\/ ExceptionInInitializerError if masterFile.getName() is\n-                \/\/ called here (NPE!). Leave as is (and few lines down)\n-                sdebug.println(\"reading security properties file: \" +\n-                        masterFile == null ? extraPropFile : \"java.security\");\n-            }\n-            return true;\n-        } catch (IOException | PropertyExpander.ExpandException e) {\n-            if (sdebug != null) {\n-                sdebug.println(\"unable to load security properties from \" +\n-                        masterFile == null ? extraPropFile : \"java.security\");\n-                e.printStackTrace();\n-            }\n-            return false;\n-        } finally {\n-            if (is != null) {\n-                try {\n-                    is.close();\n-                } catch (IOException ioe) {\n-                    if (sdebug != null) {\n-                        sdebug.println(\"unable to close input stream\");\n-                    }\n-                }\n-            }\n-        }\n@@ -191,8 +349,0 @@\n-    private static File securityPropFile(String filename) {\n-        \/\/ maybe check for a system property which will specify where to\n-        \/\/ look. Someday.\n-        String sep = File.separator;\n-        return new File(StaticProperty.javaHome() + sep + \"conf\" + sep +\n-                        \"security\" + sep + filename);\n-    }\n-\n@@ -717,0 +867,3 @@\n+     * @throws  IllegalArgumentException if key is reserved and cannot be\n+     *          used as a Security property name. Reserved keys are:\n+     *          \"include\".\n@@ -722,6 +875,2 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new SecurityPermission(\"getProperty.\"+\n-                                                      key));\n-        }\n+        SecPropLoader.checkReservedKey(key);\n+        check(\"getProperty.\" + key);\n@@ -752,0 +901,3 @@\n+     * @throws  IllegalArgumentException if key is reserved and cannot be\n+     *          used as a Security property name. Reserved keys are:\n+     *          \"include\".\n@@ -757,0 +909,1 @@\n+        SecPropLoader.checkReservedKey(key);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":256,"deletions":103,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -3082,8 +3084,4 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            RESULT = l.findVarHandle(CompletableFuture.class, \"result\", Object.class);\n-            STACK = l.findVarHandle(CompletableFuture.class, \"stack\", Completion.class);\n-            NEXT = l.findVarHandle(Completion.class, \"next\", Completion.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        RESULT = MhUtil.findVarHandle(l, \"result\", Object.class);\n+        STACK = MhUtil.findVarHandle(l, \"stack\", Completion.class);\n+        NEXT = MhUtil.findVarHandle(l, Completion.class, \"next\", Completion.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -533,9 +535,5 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            BOUND = l.findVarHandle(Exchanger.class, \"bound\", int.class);\n-            MATCH = l.findVarHandle(Node.class, \"match\", Object.class);\n-            ENTRY = l.findVarHandle(Slot.class, \"entry\", Node.class);\n-            AA = MethodHandles.arrayElementVarHandle(Slot[].class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        BOUND = MhUtil.findVarHandle(l, \"bound\", int.class);\n+        MATCH = MhUtil.findVarHandle(l, Node.class, \"match\", Object.class);\n+        ENTRY = MhUtil.findVarHandle(l, Slot.class, \"entry\", Node.class);\n+        AA = MethodHandles.arrayElementVarHandle(Slot[].class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -585,8 +587,4 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            STATE = l.findVarHandle(FutureTask.class, \"state\", int.class);\n-            RUNNER = l.findVarHandle(FutureTask.class, \"runner\", Thread.class);\n-            WAITERS = l.findVarHandle(FutureTask.class, \"waiters\", WaitNode.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        STATE = MhUtil.findVarHandle(l, \"state\", int.class);\n+        RUNNER = MhUtil.findVarHandle(l, \"runner\", Thread.class);\n+        WAITERS = MhUtil.findVarHandle(l, \"waiters\", WaitNode.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/FutureTask.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -1140,1 +1142,2 @@\n-    private static final VarHandle STATE;\n+    private static final VarHandle STATE = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"state\", long.class);\n@@ -1142,7 +1145,0 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            STATE = l.findVarHandle(Phaser.class, \"state\", long.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Phaser.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -1096,11 +1097,4 @@\n-    private static final VarHandle ALLOCATIONSPINLOCK;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            ALLOCATIONSPINLOCK = l.findVarHandle(PriorityBlockingQueue.class,\n-                                                 \"allocationSpinLock\",\n-                                                 int.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n+    private static final VarHandle ALLOCATIONSPINLOCK =\n+            MhUtil.findVarHandle(\n+                    MethodHandles.lookup(), \"allocationSpinLock\", int.class);\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/PriorityBlockingQueue.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -993,7 +994,3 @@\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                FIRST_RESULT = l.findVarHandle(ShutdownOnSuccess.class, \"firstResult\", Object.class);\n-                FIRST_EXCEPTION = l.findVarHandle(ShutdownOnSuccess.class, \"firstException\", Throwable.class);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n+            MethodHandles.Lookup l = MethodHandles.lookup();\n+            FIRST_RESULT = MhUtil.findVarHandle(l, \"firstResult\", Object.class);\n+            FIRST_EXCEPTION = MhUtil.findVarHandle(l, \"firstException\", Throwable.class);\n@@ -1180,9 +1177,2 @@\n-        private static final VarHandle FIRST_EXCEPTION;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                FIRST_EXCEPTION = l.findVarHandle(ShutdownOnFailure.class, \"firstException\", Throwable.class);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n+        private static final VarHandle FIRST_EXCEPTION =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -1508,10 +1510,4 @@\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                CTL = l.findVarHandle(BufferedSubscription.class, \"ctl\",\n-                                      int.class);\n-                DEMAND = l.findVarHandle(BufferedSubscription.class, \"demand\",\n-                                         long.class);\n-                QA = MethodHandles.arrayElementVarHandle(Object[].class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n+            MethodHandles.Lookup l = MethodHandles.lookup();\n+            CTL = MhUtil.findVarHandle(l, \"ctl\", int.class);\n+            DEMAND = MhUtil.findVarHandle(l, \"demand\", long.class);\n+            QA = MethodHandles.arrayElementVarHandle(Object[].class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SubmissionPublisher.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -51,9 +52,2 @@\n-    private static final VarHandle STATE;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            STATE = l.findVarHandle(ThreadPerTaskExecutor.class, \"state\", int.class);\n-        } catch (Exception e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n+    private static final VarHandle STATE = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"state\", int.class);\n@@ -509,8 +503,4 @@\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                RESULT = l.findVarHandle(AnyResultHolder.class, \"result\", Object.class);\n-                EXCEPTION = l.findVarHandle(AnyResultHolder.class, \"exception\", Throwable.class);\n-                EXCEPTION_COUNT = l.findVarHandle(AnyResultHolder.class, \"exceptionCount\", int.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n+            MethodHandles.Lookup l = MethodHandles.lookup();\n+            RESULT = MhUtil.findVarHandle(l, \"result\", Object.class);\n+            EXCEPTION = MhUtil.findVarHandle(l, \"exception\", Throwable.class);\n+            EXCEPTION_COUNT = MhUtil.findVarHandle(l, \"exceptionCount\", int.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPerTaskExecutor.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -53,9 +55,2 @@\n-    private static final VarHandle VALUE;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            VALUE = l.findVarHandle(AtomicBoolean.class, \"value\", int.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n+    private static final VarHandle VALUE = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"value\", int.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicBoolean.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -193,10 +195,2 @@\n-    private static final VarHandle PAIR;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            PAIR = l.findVarHandle(AtomicMarkableReference.class, \"pair\",\n-                                   Pair.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n+    private static final VarHandle PAIR = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"pair\", Pair.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicMarkableReference.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -53,9 +55,2 @@\n-    private static final VarHandle VALUE;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            VALUE = l.findVarHandle(AtomicReference.class, \"value\", Object.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n+    private static final VarHandle VALUE = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"value\", Object.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReference.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -193,10 +195,2 @@\n-    private static final VarHandle PAIR;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            PAIR = l.findVarHandle(AtomicStampedReference.class, \"pair\",\n-                                   Pair.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n+    private static final VarHandle PAIR = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"pair\", Pair.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicStampedReference.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -141,9 +143,2 @@\n-        private static final VarHandle VALUE;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n+        private static final VarHandle VALUE = MhUtil.findVarHandle(\n+                MethodHandles.lookup(), \"value\", long.class);\n@@ -384,6 +379,4 @@\n-        try {\n-            MethodHandles.Lookup l1 = MethodHandles.lookup();\n-            BASE = l1.findVarHandle(Striped64.class,\n-                    \"base\", long.class);\n-            CELLSBUSY = l1.findVarHandle(Striped64.class,\n-                    \"cellsBusy\", int.class);\n+        MethodHandles.Lookup l1 = MethodHandles.lookup();\n+\n+        BASE = MhUtil.findVarHandle(l1, \"base\", long.class);\n+        CELLSBUSY = MhUtil.findVarHandle(l1, \"cellsBusy\", int.class);\n@@ -391,1 +384,1 @@\n-            MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(\n+        MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(\n@@ -400,5 +393,1 @@\n-            THREAD_PROBE = l2.findVarHandle(Thread.class,\n-                    \"threadLocalRandomProbe\", int.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n- * multi-release jar file, the content of a versioned entry is verfieid against\n+ * multi-release jar file, the content of a versioned entry is verified against\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.invoke.MhUtil;\n+\n@@ -373,9 +375,2 @@\n-        private static final VarHandle NEXT;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                NEXT = l.findVarHandle(ForEachOrderedTask.class, \"next\", ForEachOrderedTask.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n+        private static final VarHandle NEXT = MhUtil.findVarHandle(\n+                MethodHandles.lookup(), \"next\", ForEachOrderedTask.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ForEachOps.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -456,10 +457,2 @@\n-            private static final VarHandle NEXT;\n-\n-            static {\n-                try {\n-                    MethodHandles.Lookup l = MethodHandles.lookup();\n-                    NEXT = l.findVarHandle(Hybrid.class, \"next\", Hybrid.class);\n-                } catch (Exception e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n+            private static final VarHandle NEXT = MhUtil.findVarHandle(\n+                    MethodHandles.lookup(), \"next\", Hybrid.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-     * This enum represents the three possible return values for\n+     * Constants representing the three possible return values for\n@@ -64,2 +64,2 @@\n-    enum Comparison {\n-        \/**\n+    static final byte\n+        \/*\n@@ -68,3 +68,3 @@\n-          *\/\n-        EXACT_MATCH,\n-        \/**\n+         *\/\n+        EXACT_MATCH = 0,\n+        \/*\n@@ -74,2 +74,2 @@\n-        DIRECTORY_MATCH,\n-        \/**\n+        DIRECTORY_MATCH = 1,\n+        \/*\n@@ -79,2 +79,1 @@\n-        NO_MATCH\n-    }\n+        NO_MATCH = 2;\n@@ -200,1 +199,1 @@\n-     * {@link Comparison#EXACT_MATCH}.\n+     * {@link EXACT_MATCH}.\n@@ -204,1 +203,1 @@\n-     * trailing '\/' character, then return {@link Comparison#DIRECTORY_MATCH}.\n+     * trailing '\/' character, then return {@link DIRECTORY_MATCH}.\n@@ -206,1 +205,1 @@\n-     * Otherwise, return {@link Comparison#NO_MATCH}\n+     * Otherwise, return {@link NO_MATCH}\n@@ -220,1 +219,1 @@\n-    Comparison compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n+    byte compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n@@ -224,1 +223,1 @@\n-                return Comparison.EXACT_MATCH;\n+                return EXACT_MATCH;\n@@ -228,1 +227,1 @@\n-                return Comparison.DIRECTORY_MATCH;\n+                return DIRECTORY_MATCH;\n@@ -231,1 +230,1 @@\n-        return Comparison.NO_MATCH;\n+        return NO_MATCH;\n@@ -281,1 +280,1 @@\n-        Comparison compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n+        byte compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n@@ -286,1 +285,1 @@\n-                    return Comparison.EXACT_MATCH;\n+                    return EXACT_MATCH;\n@@ -288,1 +287,1 @@\n-                    return Comparison.DIRECTORY_MATCH;\n+                    return DIRECTORY_MATCH;\n@@ -290,1 +289,1 @@\n-                    return Comparison.NO_MATCH;\n+                    return NO_MATCH;\n@@ -293,1 +292,1 @@\n-                return Comparison.NO_MATCH;\n+                return NO_MATCH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-     * This establish an approximate high-bound value for DOS times in\n+     * This establishes an approximate high-bound value for DOS times in\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1872,1 +1872,1 @@\n-                        case EXACT_MATCH:\n+                        case ZipCoder.EXACT_MATCH:\n@@ -1875,1 +1875,1 @@\n-                        case DIRECTORY_MATCH:\n+                        case ZipCoder.DIRECTORY_MATCH:\n@@ -1880,1 +1880,1 @@\n-                        case NO_MATCH:\n+                        case ZipCoder.NO_MATCH:\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -381,0 +381,4 @@\n+     * <p>\n+     * A ZipException will be thrown if the combined length, after encoding,\n+     * of the entry name, the extra field data, the entry comment and\n+     * {@linkplain #CENHDR CEN Header size}, exceeds 65,535 bytes.\n@@ -401,1 +405,3 @@\n-     * Closes the ZIP output stream as well as the stream being filtered.\n+     * Closes the underlying stream and the stream being filtered after\n+     * the contents of the ZIP output stream are fully written.\n+     *\n@@ -592,1 +598,2 @@\n-        writeShort(nameBytes.length);\n+        int nlen = nameBytes.length;\n+        writeShort(nlen);\n@@ -629,1 +636,2 @@\n-        byte[] commentBytes;\n+        byte[] commentBytes = null;\n+        int clen = 0;\n@@ -632,4 +640,1 @@\n-            writeShort(Math.min(commentBytes.length, 0xffff));\n-        } else {\n-            commentBytes = null;\n-            writeShort(0);\n+            clen = Math.min(commentBytes.length, 0xffff);\n@@ -637,0 +642,1 @@\n+        writeShort(clen);              \/\/ file comment length\n@@ -642,1 +648,1 @@\n-        writeBytes(nameBytes, 0, nameBytes.length);\n+        writeBytes(nameBytes, 0, nlen);\n@@ -682,0 +688,8 @@\n+\n+        \/\/ CEN header size + name length + comment length + extra length\n+        \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+        \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+        long headerSize = (long)CENHDR + nlen + clen + elen;\n+        if (headerSize > 0xFFFF ) {\n+            throw new ZipException(\"invalid CEN header (bad header size)\");\n+        }\n@@ -684,1 +698,1 @@\n-            writeBytes(commentBytes, 0, Math.min(commentBytes.length, 0xffff));\n+            writeBytes(commentBytes, 0, clen);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+\n@@ -87,4 +89,12 @@\n-    public static Utf8Entry rawUtf8EntryFromStandardAttributeName(String name) {\n-        \/\/assuming standard attribute names are all US_ASCII\n-        var raw = name.getBytes(StandardCharsets.US_ASCII);\n-        return new Utf8EntryImpl(null, 0, raw, 0, raw.length);\n+    static int hashClassFromUtf8(boolean isArray, Utf8EntryImpl content) {\n+        int hash = content.contentHash();\n+        return hashClassFromDescriptor(isArray ? hash : Util.descriptorStringHash(content.length(), hash));\n+    }\n+\n+    static int hashClassFromDescriptor(int descriptorHash) {\n+        return hash1(ClassFile.TAG_CLASS, descriptorHash);\n+    }\n+\n+    static boolean isArrayDescriptor(Utf8EntryImpl cs) {\n+        \/\/ Do not throw out-of-bounds for empty strings\n+        return !cs.isEmpty() && cs.charAt(0) == '[';\n@@ -95,0 +105,2 @@\n+        if (cp.canWriteDirect(entry.constantPool()))\n+            return entry;\n@@ -99,1 +111,0 @@\n-    public final byte tag;\n@@ -103,2 +114,1 @@\n-    private AbstractPoolEntry(ConstantPool constantPool, int tag, int index, int hash) {\n-        this.tag = (byte) tag;\n+    private AbstractPoolEntry(ConstantPool constantPool, int index, int hash) {\n@@ -119,3 +129,1 @@\n-    public byte tag() {\n-        return tag;\n-    }\n+    public abstract byte tag();\n@@ -124,1 +132,1 @@\n-        return (tag == ClassFile.TAG_LONG || tag == ClassFile.TAG_DOUBLE) ? 2 : 1;\n+        return 1;\n@@ -151,1 +159,1 @@\n-        private @Stable int hash;\n+        private @Stable int contentHash;\n@@ -162,1 +170,1 @@\n-            super(cpm, ClassFile.TAG_UTF8, index, 0);\n+            super(cpm, index, 0);\n@@ -170,1 +178,1 @@\n-            this(cpm, index, s, hashString(s.hashCode()));\n+            this(cpm, index, s, s.hashCode());\n@@ -173,2 +181,2 @@\n-        Utf8EntryImpl(ConstantPool cpm, int index, String s, int hash) {\n-            super(cpm, ClassFile.TAG_UTF8, index, 0);\n+        Utf8EntryImpl(ConstantPool cpm, int index, String s, int contentHash) {\n+            super(cpm, index, 0);\n@@ -181,1 +189,1 @@\n-            this.hash = hash;\n+            this.contentHash = contentHash;\n@@ -185,1 +193,1 @@\n-            super(cpm, ClassFile.TAG_UTF8, index, 0);\n+            super(cpm, index, 0);\n@@ -190,1 +198,1 @@\n-            this.hash = u.hash;\n+            this.contentHash = u.contentHash;\n@@ -197,0 +205,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_UTF8;\n+        }\n+\n@@ -236,1 +249,1 @@\n-                this.hash = hashString(hash);\n+                this.contentHash = hash;\n@@ -294,1 +307,1 @@\n-                this.hash = hashString(hash);\n+                this.contentHash = hash;\n@@ -307,2 +320,0 @@\n-            if (cp.canWriteDirect(constantPool))\n-                return this;\n@@ -316,0 +327,4 @@\n+            return hashString(contentHash());\n+        }\n+\n+        int contentHash() {\n@@ -318,1 +333,1 @@\n-            return hash;\n+            return contentHash;\n@@ -389,0 +404,32 @@\n+        \/**\n+         * Returns if this utf8 entry's content equals a substring\n+         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n+         * This check avoids a substring allocation.\n+         *\/\n+        public boolean equalsRegion(String s, int start, int end) {\n+            \/\/ start and end values trusted\n+            if (state == State.RAW)\n+                inflate();\n+            int len = charLen;\n+            if (len != end - start)\n+                return false;\n+\n+            var sv = stringValue;\n+            if (sv != null) {\n+                return sv.regionMatches(0, s, start, len);\n+            }\n+\n+            var chars = this.chars;\n+            if (chars != null) {\n+                for (int i = 0; i < len; i++)\n+                    if (chars[i] != s.charAt(start + i))\n+                        return false;\n+            } else {\n+                var bytes = this.rawBytes;\n+                for (int i = 0; i < len; i++)\n+                    if (bytes[offset + i] != s.charAt(start + i))\n+                        return false;\n+            }\n+            return true;\n+        }\n+\n@@ -397,1 +444,1 @@\n-                    if (charLen != s.length() || hash != hashString(s.hashCode()))\n+                    if (charLen != s.length() || contentHash != s.hashCode())\n@@ -406,1 +453,1 @@\n-                    if (rawLen != s.length() || hash != hashString(s.hashCode()))\n+                    if (rawLen != s.length() || contentHash != s.hashCode())\n@@ -420,1 +467,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(TAG_UTF8);\n@@ -452,1 +499,1 @@\n-            super(constantPool, tag, index, hash1(tag, ref1.index()));\n+            super(constantPool, index, hash1(tag, ref1.index()));\n@@ -461,1 +508,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(tag());\n@@ -477,1 +524,1 @@\n-            super(constantPool, tag, index, hash2(tag, ref1.index(), ref2.index()));\n+            super(constantPool, index, hash2(tag, ref1.index(), ref2.index()));\n@@ -491,1 +538,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(tag());\n@@ -519,1 +566,2 @@\n-        public ClassDesc sym = null;\n+        public @Stable ClassDesc sym;\n+        private @Stable int hash;\n@@ -522,0 +570,9 @@\n+            super(cpm, TAG_CLASS, index, name);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_CLASS;\n+        }\n+\n+        ClassEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl name, int hash, ClassDesc sym) {\n@@ -523,0 +580,2 @@\n+            this.hash = hash;\n+            this.sym = sym;\n@@ -527,7 +586,1 @@\n-            if (cp.canWriteDirect(constantPool)) {\n-                return this;\n-            } else {\n-                ClassEntryImpl ret = (ClassEntryImpl)cp.classEntry(ref1);\n-                ret.sym = sym;\n-                return ret;\n-            }\n+            return ((SplitConstantPool) cp).cloneClassEntry(this);\n@@ -542,1 +595,7 @@\n-            return this.sym = Util.toClassDesc(asInternalName());\n+\n+            if (isArrayDescriptor(ref1)) {\n+                sym = ref1.fieldTypeSymbol(); \/\/ array, symbol already available\n+            } else {\n+                sym = ClassDesc.ofInternalName(asInternalName()); \/\/ class or interface\n+            }\n+            return this.sym = sym;\n@@ -548,4 +607,2 @@\n-            if (o instanceof ClassEntryImpl cce) {\n-                return cce.name().equals(this.name());\n-            } else if (o instanceof ClassEntry c) {\n-                return c.asSymbol().equals(this.asSymbol());\n+            if (o instanceof ClassEntryImpl other) {\n+                return equalsEntry(other);\n@@ -555,0 +612,19 @@\n+\n+        boolean equalsEntry(ClassEntryImpl other) {\n+            var tsym = this.sym;\n+            var osym = other.sym;\n+            if (tsym != null && osym != null) {\n+                return tsym.equals(osym);\n+            }\n+\n+            return ref1.equalsUtf8(other.ref1);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            var hash = this.hash;\n+            if (hash != 0)\n+                return hash;\n+\n+            return this.hash = hashClassFromUtf8(isArrayDescriptor(ref1), ref1);\n+        }\n@@ -560,1 +636,6 @@\n-            super(cpm, ClassFile.TAG_PACKAGE, index, name);\n+            super(cpm, TAG_PACKAGE, index, name);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_PACKAGE;\n@@ -565,1 +646,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.packageEntry(ref1);\n+            return cp.packageEntry(ref1);\n@@ -586,1 +667,6 @@\n-            super(cpm, ClassFile.TAG_MODULE, index, name);\n+            super(cpm, TAG_MODULE, index, name);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_MODULE;\n@@ -591,1 +677,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.moduleEntry(ref1);\n+            return cp.moduleEntry(ref1);\n@@ -613,1 +699,6 @@\n-            super(cpm, ClassFile.TAG_NAMEANDTYPE, index, name, type);\n+            super(cpm, TAG_NAMEANDTYPE, index, name, type);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_NAMEANDTYPE;\n@@ -628,3 +719,0 @@\n-            if (cp.canWriteDirect(constantPool)) {\n-                return this;\n-            }\n@@ -673,1 +761,1 @@\n-                return tag == m.tag()\n+                return tag() == m.tag()\n@@ -685,1 +773,6 @@\n-            super(cpm, ClassFile.TAG_FIELDREF, index, owner, nameAndType);\n+            super(cpm, TAG_FIELDREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_FIELDREF;\n@@ -690,1 +783,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.fieldRefEntry(ref1, ref2);\n+            return cp.fieldRefEntry(ref1, ref2);\n@@ -701,0 +794,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_METHODREF;\n+        }\n+\n@@ -703,1 +801,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodRefEntry(ref1, ref2);\n+            return cp.methodRefEntry(ref1, ref2);\n@@ -714,0 +812,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_INTERFACEMETHODREF;\n+        }\n+\n@@ -716,1 +819,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.interfaceMethodRefEntry(ref1, ref2);\n+            return cp.interfaceMethodRefEntry(ref1, ref2);\n@@ -726,1 +829,1 @@\n-        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, BootstrapMethodEntryImpl bootstrapMethod,\n+        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int index, int hash, BootstrapMethodEntryImpl bootstrapMethod,\n@@ -728,1 +831,1 @@\n-            super(cpm, tag, index, hash);\n+            super(cpm, index, hash);\n@@ -734,1 +837,1 @@\n-        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, int bsmIndex,\n+        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int index, int hash, int bsmIndex,\n@@ -736,1 +839,1 @@\n-            super(cpm, tag, index, hash);\n+            super(cpm, index, hash);\n@@ -767,1 +870,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(tag());\n@@ -796,1 +899,1 @@\n-            super(cpm, ClassFile.TAG_INVOKEDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n+            super(cpm, index, hash, bootstrapMethod, nameAndType);\n@@ -801,1 +904,1 @@\n-            super(cpm, ClassFile.TAG_INVOKEDYNAMIC, index, hash2(ClassFile.TAG_INVOKEDYNAMIC, bsmIndex, nameAndType.index()),\n+            super(cpm, index, hash2(TAG_INVOKEDYNAMIC, bsmIndex, nameAndType.index()),\n@@ -805,0 +908,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_INVOKEDYNAMIC;\n+        }\n+\n@@ -807,1 +915,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.invokeDynamicEntry(bootstrap(), nameAndType());\n+            return cp.invokeDynamicEntry(bootstrap(), nameAndType());\n@@ -816,1 +924,1 @@\n-            super(cpm, ClassFile.TAG_CONSTANTDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n+            super(cpm, index, hash, bootstrapMethod, nameAndType);\n@@ -821,1 +929,1 @@\n-            super(cpm, ClassFile.TAG_CONSTANTDYNAMIC, index, hash2(ClassFile.TAG_CONSTANTDYNAMIC, bsmIndex, nameAndType.index()),\n+            super(cpm, index, hash2(TAG_CONSTANTDYNAMIC, bsmIndex, nameAndType.index()),\n@@ -825,0 +933,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_CONSTANTDYNAMIC;\n+        }\n+\n@@ -827,1 +940,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.constantDynamicEntry(bootstrap(), nameAndType());\n+            return cp.constantDynamicEntry(bootstrap(), nameAndType());\n@@ -839,1 +952,1 @@\n-            super(cpm, ClassFile.TAG_METHODHANDLE, index, hash);\n+            super(cpm, index, hash);\n@@ -846,1 +959,1 @@\n-            super(cpm, ClassFile.TAG_METHODHANDLE, index, hash2(ClassFile.TAG_METHODHANDLE, refKind, reference.index()));\n+            super(cpm, index, hash2(ClassFile.TAG_METHODHANDLE, refKind, reference.index()));\n@@ -851,0 +964,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_METHODHANDLE;\n+        }\n+\n@@ -872,1 +990,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(TAG_METHODHANDLE);\n@@ -879,1 +997,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodHandleEntry(refKind, reference);\n+            return cp.methodHandleEntry(refKind, reference);\n@@ -904,1 +1022,6 @@\n-            super(cpm, ClassFile.TAG_METHODTYPE, index, descriptor);\n+            super(cpm, TAG_METHODTYPE, index, descriptor);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_METHODTYPE;\n@@ -914,3 +1037,0 @@\n-            if (cp.canWriteDirect(constantPool)) {\n-                return this;\n-            }\n@@ -940,1 +1060,6 @@\n-            super(cpm, ClassFile.TAG_STRING, index, utf8);\n+            super(cpm, TAG_STRING, index, utf8);\n+        }\n+\n+        @Override\n+        public byte tag() {\n+            return TAG_STRING;\n@@ -960,1 +1085,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.stringEntry(ref1);\n+            return cp.stringEntry(ref1);\n@@ -986,1 +1111,1 @@\n-            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            super(cpm, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n@@ -990,0 +1115,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_INTEGER;\n+        }\n+\n@@ -992,1 +1122,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(TAG_INTEGER);\n@@ -998,1 +1128,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.intEntry(val);\n+            return cp.intEntry(val);\n@@ -1027,1 +1157,1 @@\n-            super(cpm, ClassFile.TAG_FLOAT, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n+            super(cpm, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n@@ -1031,0 +1161,5 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_FLOAT;\n+        }\n+\n@@ -1033,1 +1168,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(TAG_FLOAT);\n@@ -1039,1 +1174,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.floatEntry(val);\n+            return cp.floatEntry(val);\n@@ -1067,1 +1202,1 @@\n-            super(cpm, ClassFile.TAG_LONG, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n+            super(cpm, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n@@ -1071,0 +1206,10 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_LONG;\n+        }\n+\n+        @Override\n+        public int width() {\n+            return 2;\n+        }\n+\n@@ -1073,1 +1218,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(TAG_LONG);\n@@ -1079,1 +1224,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.longEntry(val);\n+            return cp.longEntry(val);\n@@ -1107,1 +1252,1 @@\n-            super(cpm, ClassFile.TAG_DOUBLE, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n+            super(cpm, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n@@ -1111,0 +1256,10 @@\n+        @Override\n+        public byte tag() {\n+            return TAG_DOUBLE;\n+        }\n+\n+        @Override\n+        public int width() {\n+            return 2;\n+        }\n+\n@@ -1113,1 +1268,1 @@\n-            pool.writeU1(tag);\n+            pool.writeU1(TAG_DOUBLE);\n@@ -1119,1 +1274,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.doubleEntry(val);\n+            return cp.doubleEntry(val);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":245,"deletions":90,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -102,0 +103,1 @@\n+    @ForceInline\n@@ -286,0 +288,1 @@\n+    @ForceInline\n@@ -290,1 +293,1 @@\n-            throw new IllegalArgumentException(idx + \" is not a valid index. Entry: \" + entry);\n+            throw invalidIndex(idx, entry);\n@@ -294,0 +297,4 @@\n+    static IllegalArgumentException invalidIndex(int idx, PoolEntry entry) {\n+        return new IllegalArgumentException(idx + \" is not a valid index. Entry: \" + entry);\n+    }\n+\n@@ -301,0 +308,10 @@\n+\n+    \/**\n+     * Join head and tail into an exact-size buffer\n+     *\/\n+    static byte[] join(BufWriterImpl head, BufWriterImpl tail) {\n+        byte[] result = new byte[head.size() + tail.size()];\n+        head.copyTo(result, 0);\n+        tail.copyTo(result, head.size());\n+        return result;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+        var constantPool = this.constantPool;\n@@ -183,3 +184,4 @@\n-        List<ClassEntry> ies = new ArrayList<>(interfaceEntries.size());\n-        for (ClassEntry ce : interfaceEntries)\n-            ies.add(AbstractPoolEntry.maybeClone(constantPool, ce));\n+        int interfaceEntriesSize = interfaceEntries.size();\n+        List<ClassEntry> ies = new ArrayList<>(interfaceEntriesSize);\n+        for (int i = 0; i < interfaceEntriesSize; i++)\n+            ies.add(AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i)));\n@@ -200,2 +202,1 @@\n-        boolean written = constantPool.writeBootstrapMethods(tail);\n-        if (written) {\n+        if (constantPool.writeBootstrapMethods(tail)) {\n@@ -207,3 +208,3 @@\n-        head.writeInt(ClassFile.MAGIC_NUMBER);\n-        head.writeU2(minorVersion);\n-        head.writeU2(majorVersion);\n+        head.writeLong((((long) ClassFile.MAGIC_NUMBER) << 32)\n+                | ((minorVersion & 0xFFFFL) << 16)\n+                | (majorVersion & 0xFFFFL));\n@@ -217,4 +218,1 @@\n-        byte[] result = new byte[head.size() + tail.size()];\n-        head.copyTo(result, 0);\n-        tail.copyTo(result, head.size());\n-        return result;\n+        return BufWriterImpl.join(head, tail);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -193,0 +193,7 @@\n+        if (handlersSize > 0) {\n+            writeExceptionHandlers(buf, pos);\n+        }\n+    }\n+\n+    private void writeExceptionHandlers(BufWriterImpl buf, int pos) {\n+        int handlersSize = handlers.size();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.internal.constant.ConstantUtils;\n+\n@@ -374,1 +376,0 @@\n-                && ce.hashCode() == hash\n@@ -401,0 +402,84 @@\n+    private AbstractPoolEntry.Utf8EntryImpl tryFindUtf8OfRegion(int hash, String target, int start, int end) {\n+        EntryMap map = map();\n+        while (true) {\n+            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+                PoolEntry e = entryByIndex(map.getIndexByToken(token));\n+                if (e.tag() == ClassFile.TAG_UTF8\n+                        && e instanceof AbstractPoolEntry.Utf8EntryImpl ce\n+                        && ce.equalsRegion(target, start, end))\n+                    return ce;\n+            }\n+            if (!doneFullScan) {\n+                fullScan();\n+                continue;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private AbstractPoolEntry.ClassEntryImpl tryFindClassOrInterface(int hash, ClassDesc cd) {\n+        while (true) {\n+            EntryMap map = map();\n+            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+                PoolEntry e = entryByIndex(map.getIndexByToken(token));\n+                if (e.tag() == TAG_CLASS\n+                        && e instanceof AbstractPoolEntry.ClassEntryImpl ce) {\n+                    var esym = ce.sym;\n+\n+                    if (esym != null) {\n+                        if (cd.equals(esym)) {\n+                            return ce; \/\/ definite match\n+                        }\n+                        continue; \/\/ definite mismatch\n+                    }\n+\n+                    \/\/ no symbol available\n+                    var desc = cd.descriptorString();\n+                    if (ce.ref1.equalsRegion(desc, 1, desc.length() - 1)) {\n+                        \/\/ definite match, propagate symbol\n+                        ce.sym = cd;\n+                        return ce;\n+                    }\n+                    \/\/ definite mismatch\n+                }\n+            }\n+            if (!doneFullScan) {\n+                fullScan();\n+                continue;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private AbstractPoolEntry.ClassEntryImpl classEntryForClassOrInterface(ClassDesc cd) {\n+        var desc = cd.descriptorString();\n+\n+        int hash = AbstractPoolEntry.hashClassFromDescriptor(desc.hashCode());\n+        var ce = tryFindClassOrInterface(hash, cd);\n+        if (ce != null)\n+            return ce;\n+\n+        var utfHash = Util.internalNameHash(desc);\n+        var utf = tryFindUtf8OfRegion(AbstractPoolEntry.hashString(utfHash), desc, 1, desc.length() - 1);\n+        if (utf == null)\n+            utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, ConstantUtils.dropFirstAndLastChar(desc), utfHash));\n+\n+        return internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, utf, hash, cd));\n+    }\n+\n+    private AbstractPoolEntry.ClassEntryImpl tryFindClassEntry(int hash, AbstractPoolEntry.Utf8EntryImpl utf8) {\n+        EntryMap map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = entryByIndex(map.getIndexByToken(token));\n+            if (e.tag() == ClassFile.TAG_CLASS\n+                    && e instanceof AbstractPoolEntry.ClassEntryImpl ce\n+                    && ce.ref1.equalsUtf8(utf8))\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return tryFindClassEntry(hash, utf8);\n+        }\n+        return null;\n+    }\n+\n@@ -402,1 +487,1 @@\n-    public Utf8Entry utf8Entry(ClassDesc desc) {\n+    public AbstractPoolEntry.Utf8EntryImpl utf8Entry(ClassDesc desc) {\n@@ -404,1 +489,2 @@\n-        utf8.typeSym = desc;\n+        if (utf8.typeSym == null)\n+            utf8.typeSym = desc;\n@@ -411,1 +497,2 @@\n-        utf8.typeSym = desc;\n+        if (utf8.typeSym == null)\n+            utf8.typeSym = desc;\n@@ -417,3 +504,3 @@\n-        int hash = AbstractPoolEntry.hashString(s.hashCode());\n-        var ce = tryFindUtf8(hash, s);\n-        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, hash)) : ce;\n+        int contentHash = s.hashCode();\n+        var ce = tryFindUtf8(AbstractPoolEntry.hashString(contentHash), s);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, contentHash)) : ce;\n@@ -432,3 +519,31 @@\n-        AbstractPoolEntry.Utf8EntryImpl ne = maybeCloneUtf8Entry(nameEntry);\n-        var e = (AbstractPoolEntry.ClassEntryImpl) findEntry(TAG_CLASS, ne);\n-        return e == null ? internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, ne)) : e;\n+        var ne = maybeCloneUtf8Entry(nameEntry);\n+        return classEntry(ne, AbstractPoolEntry.isArrayDescriptor(ne));\n+    }\n+\n+    AbstractPoolEntry.ClassEntryImpl classEntry(AbstractPoolEntry.Utf8EntryImpl ne, boolean isArray) {\n+        int hash = AbstractPoolEntry.hashClassFromUtf8(isArray, ne);\n+        var e = tryFindClassEntry(hash, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, ne, hash,\n+                isArray && ne.typeSym instanceof ClassDesc cd ? cd : null)) : e;\n+    }\n+\n+    @Override\n+    public ClassEntry classEntry(ClassDesc cd) {\n+        if (cd.isClassOrInterface()) { \/\/ implicit null check\n+            return classEntryForClassOrInterface(cd);\n+        }\n+        if (cd.isArray()) {\n+            return classEntry(utf8Entry(cd), true);\n+        }\n+        throw new IllegalArgumentException(\"Cannot be encoded as ClassEntry: \" + cd.displayName());\n+    }\n+\n+    AbstractPoolEntry.ClassEntryImpl cloneClassEntry(AbstractPoolEntry.ClassEntryImpl e) {\n+        var ce = tryFindClassEntry(e.hashCode(), e.ref1);\n+        if (ce != null) {\n+            return ce;\n+        }\n+\n+        var utf8 = maybeCloneUtf8Entry(e.ref1); \/\/ call order matters\n+        return internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size,\n+                utf8, e.hashCode(), e.sym));\n@@ -461,6 +576,2 @@\n-        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n-        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n-        if (!canWriteDirect(oe.constantPool))\n-            oe = classEntry(owner.name());\n-        if (!canWriteDirect(ne.constantPool))\n-            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        var oe = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.ClassEntryImpl) owner);\n+        var ne = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -473,6 +584,2 @@\n-        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n-        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n-        if (!canWriteDirect(oe.constantPool))\n-            oe = classEntry(owner.name());\n-        if (!canWriteDirect(ne.constantPool))\n-            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        var oe = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.ClassEntryImpl) owner);\n+        var ne = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -485,6 +592,2 @@\n-        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n-        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n-        if (!canWriteDirect(oe.constantPool))\n-            oe = classEntry(owner.name());\n-        if (!canWriteDirect(ne.constantPool))\n-            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        var oe = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.ClassEntryImpl) owner);\n+        var ne = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -509,9 +612,1 @@\n-        if (!canWriteDirect(reference.constantPool())) {\n-            reference = switch (reference.tag()) {\n-                case TAG_FIELDREF -> fieldRefEntry(reference.owner(), reference.nameAndType());\n-                case TAG_METHODREF -> methodRefEntry(reference.owner(), reference.nameAndType());\n-                case TAG_INTERFACEMETHODREF -> interfaceMethodRefEntry(reference.owner(), reference.nameAndType());\n-                default -> throw new IllegalArgumentException(String.format(\"Bad tag %d\", reference.tag()));\n-            };\n-        }\n-\n+        reference = AbstractPoolEntry.maybeClone(this, reference);\n@@ -541,2 +636,1 @@\n-        if (!canWriteDirect(nameAndType.constantPool()))\n-            nameAndType = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        nameAndType = AbstractPoolEntry.maybeClone(this, nameAndType);\n@@ -572,2 +666,1 @@\n-        if (!canWriteDirect(nameAndType.constantPool()))\n-            nameAndType = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        nameAndType = AbstractPoolEntry.maybeClone(this, nameAndType);\n@@ -631,2 +724,1 @@\n-        if (!canWriteDirect(methodReference.constantPool()))\n-            methodReference = methodHandleEntry(methodReference.kind(), methodReference.reference());\n+        methodReference = AbstractPoolEntry.maybeClone(this, methodReference);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":135,"deletions":43,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -403,0 +403,2 @@\n+        var frames = this.frames;\n+        var currentFrame = this.currentFrame;\n@@ -418,0 +420,1 @@\n+                    Frame nextFrame = frames.get(stackmapIndex++);\n@@ -419,1 +422,1 @@\n-                        currentFrame.checkAssignableTo(frames.get(stackmapIndex));\n+                        currentFrame.checkAssignableTo(nextFrame);\n@@ -421,1 +424,0 @@\n-                    Frame nextFrame = frames.get(stackmapIndex++);\n@@ -432,1 +434,1 @@\n-                    throw new ClassFormatError(String.format(\"Bad stack map offset %d\", thisOffset));\n+                    throw generatorError(\"Bad stack map offset\");\n@@ -1046,1 +1048,3 @@\n-            checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n+            checkLocal(Util.parameterSlots(methodDesc) + (isStatic ? -1 : 0));\n+            Type type;\n+            Type[] locals = this.locals;\n@@ -1048,1 +1052,0 @@\n-                localsSize++;\n@@ -1050,1 +1053,1 @@\n-                    setLocal(0, Type.UNITIALIZED_THIS_TYPE);\n+                    type = Type.UNITIALIZED_THIS_TYPE;\n@@ -1053,1 +1056,1 @@\n-                    setLocalRawInternal(0, thisKlass);\n+                    type = thisKlass;\n@@ -1055,0 +1058,1 @@\n+                locals[localsSize++] = type;\n@@ -1058,10 +1062,15 @@\n-                if (!desc.isPrimitive()) {\n-                    setLocalRawInternal(localsSize++, Type.referenceType(desc));\n-                } else switch (desc.descriptorString().charAt(0)) {\n-                    case 'J' -> {\n-                        setLocalRawInternal(localsSize++, Type.LONG_TYPE);\n-                        setLocalRawInternal(localsSize++, Type.LONG2_TYPE);\n-                    }\n-                    case 'D' -> {\n-                        setLocalRawInternal(localsSize++, Type.DOUBLE_TYPE);\n-                        setLocalRawInternal(localsSize++, Type.DOUBLE2_TYPE);\n+                if (desc == CD_long) {\n+                    locals[localsSize    ] = Type.LONG_TYPE;\n+                    locals[localsSize + 1] = Type.LONG2_TYPE;\n+                    localsSize += 2;\n+                } else if (desc == CD_double) {\n+                    locals[localsSize    ] = Type.DOUBLE_TYPE;\n+                    locals[localsSize + 1] = Type.DOUBLE2_TYPE;\n+                    localsSize += 2;\n+                } else {\n+                    if (desc instanceof ReferenceClassDescImpl) {\n+                        type = Type.referenceType(desc);\n+                    } else if (desc == CD_float) {\n+                        type = Type.FLOAT_TYPE;\n+                    } else {\n+                        type = Type.INTEGER_TYPE;\n@@ -1069,5 +1078,1 @@\n-                    case 'I', 'Z', 'B', 'C', 'S' ->\n-                        setLocalRawInternal(localsSize++, Type.INTEGER_TYPE);\n-                    case 'F' ->\n-                        setLocalRawInternal(localsSize++, Type.FLOAT_TYPE);\n-                    default -> throw new AssertionError(\"Should not reach here\");\n+                    locals[localsSize++] = type;\n@@ -1093,0 +1098,2 @@\n+            int localsSize = this.localsSize;\n+            int stackSize = this.stackSize;\n@@ -1094,1 +1101,1 @@\n-                target.locals = locals == null ? null : Arrays.copyOf(locals, localsSize);\n+                target.locals = locals == null ? null : locals.clone();\n@@ -1096,2 +1103,4 @@\n-                target.stack = stack == null ? null : Arrays.copyOf(stack, stackSize);\n-                target.stackSize = stackSize;\n+                if (stackSize > 0) {\n+                    target.stack = stack.clone();\n+                    target.stackSize = stackSize;\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n@@ -251,0 +253,1 @@\n+    @ForceInline\n@@ -252,3 +255,4 @@\n-        buf.writeU2(list.size());\n-        for (var e : list) {\n-            writeAttribute(buf, e);\n+        int size = list.size();\n+        buf.writeU2(size);\n+        for (int i = 0; i < size; i++) {\n+            writeAttribute(buf, list.get(i));\n@@ -258,0 +262,1 @@\n+    @ForceInline\n@@ -259,3 +264,4 @@\n-        buf.writeU2(list.size());\n-        for (var e : list) {\n-            e.writeTo(buf);\n+        int size = list.size();\n+        buf.writeU2(size);\n+        for (int i = 0; i < size; i++) {\n+            list.get(i).writeTo(buf);\n@@ -340,0 +346,78 @@\n+\n+    \/**\n+     * Returns the hash code of an internal name given the class or interface L descriptor.\n+     *\/\n+    public static int internalNameHash(String desc) {\n+        if (desc.length() > 0xffff)\n+            throw new IllegalArgumentException(\"String too long: \".concat(Integer.toString(desc.length())));\n+        return (desc.hashCode() - pow31(desc.length() - 1) * 'L' - ';') * INVERSE_31;\n+    }\n+\n+    \/**\n+     * Returns the hash code of a class or interface L descriptor given the internal name.\n+     *\/\n+    public static int descriptorStringHash(int length, int hash) {\n+        if (length > 0xffff)\n+            throw new IllegalArgumentException(\"String too long: \".concat(Integer.toString(length)));\n+        return 'L' * pow31(length + 1) + hash * 31 + ';';\n+    }\n+\n+    \/\/ k is at most 65536, length of Utf8 entry + 1\n+    public static int pow31(int k) {\n+        int r = 1;\n+        \/\/ calculate the power contribution from index-th octal digit\n+        \/\/ from least to most significant (right to left)\n+        \/\/ e.g. decimal 26=octal 32, power(26)=powerOctal(2,0)*powerOctal(3,1)\n+        for (int i = 0; i < SIGNIFICANT_OCTAL_DIGITS; i++) {\n+            r *= powerOctal(k & 7, i);\n+            k >>= 3;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ The inverse of 31 in Z\/2^32Z* modulo group, a * INVERSE_31 * 31 = a\n+    static final int INVERSE_31 = 0xbdef7bdf;\n+\n+    \/\/ k is at most 65536 = octal 200000, only consider 6 octal digits\n+    \/\/ Note: 31 powers repeat beyond 1 << 27, only 9 octal digits matter\n+    static final int SIGNIFICANT_OCTAL_DIGITS = 6;\n+\n+    \/\/ for base k, storage is k * log_k(N)=k\/ln(k) * ln(N)\n+    \/\/ k = 2 or 4 is better for space at the cost of more multiplications\n+    \/**\n+     * The code below is as if:\n+     * {@snippet lang=java :\n+     * int[] powers = new int[7 * SIGNIFICANT_OCTAL_DIGITS];\n+     *\n+     * for (int i = 1, k = 31; i <= 7; i++, k *= 31) {\n+     *    int t = powers[powersIndex(i, 0)] = k;\n+     *    for (int j = 1; j < SIGNIFICANT_OCTAL_DIGITS; j++) {\n+     *        t *= t;\n+     *        t *= t;\n+     *        t *= t;\n+     *        powers[powersIndex(i, j)] = t;\n+     *    }\n+     * }\n+     * }\n+     * This is converted to explicit initialization to avoid bootstrap overhead.\n+     * Validated in UtilTest.\n+     *\/\n+    static final @Stable int[] powers = new int[] {\n+            0x0000001f, 0x000003c1, 0x0000745f, 0x000e1781, 0x01b4d89f, 0x34e63b41, 0x67e12cdf,\n+            0x94446f01, 0x50a9de01, 0x84304d01, 0x7dd7bc01, 0x8ca02b01, 0xff899a01, 0x25940901,\n+            0x4dbf7801, 0xe3bef001, 0xc1fe6801, 0xe87de001, 0x573d5801, 0x0e3cd001, 0x0d7c4801,\n+            0x54fbc001, 0xb9f78001, 0x2ef34001, 0xb3ef0001, 0x48eac001, 0xede68001, 0xa2e24001,\n+            0x67de0001, 0xcfbc0001, 0x379a0001, 0x9f780001, 0x07560001, 0x6f340001, 0xd7120001,\n+            0x3ef00001, 0x7de00001, 0xbcd00001, 0xfbc00001, 0x3ab00001, 0x79a00001, 0xb8900001,\n+    };\n+\n+    static int powersIndex(int digit, int index) {\n+        return (digit - 1) + index * 7;\n+    }\n+\n+    \/\/ (31 ^ digit) ^ (8 * index) = 31 ^ (digit * (8 ^ index))\n+    \/\/ digit: 0 - 7\n+    \/\/ index: 0 - SIGNIFICANT_OCTAL_DIGITS - 1\n+    private static int powerOctal(int digit, int index) {\n+        return digit == 0 ? 1 : powers[powersIndex(digit, index)];\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":90,"deletions":6,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -43,9 +44,2 @@\n-    static final VarHandle ASYNC_RELEASE_COUNT;\n-\n-    static {\n-        try {\n-            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedSession.class, \"asyncReleaseCount\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n+    static final VarHandle ASYNC_RELEASE_COUNT= MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"asyncReleaseCount\", int.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -60,1 +61,3 @@\n-    static final VarHandle STATE;\n+    static final VarHandle STATE = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"state\", int.class);\n+\n@@ -72,8 +75,0 @@\n-    static {\n-        try {\n-            STATE = MethodHandles.lookup().findVarHandle(MemorySessionImpl.class, \"state\", int.class);\n-        } catch (Exception ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -94,9 +95,2 @@\n-        static final VarHandle FST;\n-\n-        static {\n-            try {\n-                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError();\n-            }\n-        }\n+        static final VarHandle FST = MhUtil.findVarHandle(\n+                MethodHandles.lookup(), ResourceList.class, \"fst\", ResourceCleanup.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -41,1 +42,0 @@\n-import java.util.Map;\n@@ -59,2 +59,3 @@\n-    private static final MethodHandle MH_INVOKE_INTERP_BINDINGS;\n-    private static final MethodHandle EMPTY_OBJECT_ARRAY_HANDLE = MethodHandles.constant(Object[].class, new Object[0]);\n+    private static final MethodHandle MH_INVOKE_INTERP_BINDINGS = MhUtil.findVirtual(\n+            MethodHandles.lookup(), DowncallLinker.class, \"invokeInterpBindings\",\n+            methodType(Object.class, SegmentAllocator.class, Object[].class, InvocationData.class));\n@@ -62,9 +63,1 @@\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_INVOKE_INTERP_BINDINGS = lookup.findVirtual(DowncallLinker.class, \"invokeInterpBindings\",\n-                    methodType(Object.class, SegmentAllocator.class, Object[].class, InvocationData.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n+    private static final MethodHandle EMPTY_OBJECT_ARRAY_HANDLE = MethodHandles.constant(Object[].class, new Object[0]);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -160,9 +161,3 @@\n-            static final MethodHandle MH_SCALE;\n-            static {\n-                try {\n-                    MH_SCALE = MethodHandles.lookup().findVirtual(MemoryLayout.class, \"scale\",\n-                            MethodType.methodType(long.class, long.class, long.class));\n-                } catch (ReflectiveOperationException e) {\n-                    throw new ExceptionInInitializerError(e);\n-                }\n-            }\n+            static final MethodHandle MH_SCALE = MhUtil.findVirtual(\n+                    MethodHandles.lookup(), MemoryLayout.class, \"scale\",\n+                    MethodType.methodType(long.class, long.class, long.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.invoke;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+\/**\n+ * Static factories for certain VarHandle\/MethodHandle variants.\n+ * <p>\n+ * The methods will throw an {@link InternalError} if the lookup fails.\n+ * <p>\n+ * Here is an example of how one of these methods could be used:\n+ * {@snippet lang=java\n+ * static MethodHandle BAR_HANDLE =\n+ *         MhUtil.findVirtual(MethodHandles.lookup(),\n+ *                 Foo.class,\"bar\",MethodType.methodType(int.class));\n+ * }\n+ *\/\n+public final class MhUtil {\n+\n+    private MhUtil() {}\n+\n+    public static VarHandle findVarHandle(MethodHandles.Lookup lookup,\n+                                          String name,\n+                                          Class<?> type) {\n+        return findVarHandle(lookup, lookup.lookupClass(), name, type);\n+    }\n+\n+    public static VarHandle findVarHandle(MethodHandles.Lookup lookup,\n+                                          Class<?> recv,\n+                                          String name,\n+                                          Class<?> type) {\n+        try {\n+            return lookup.findVarHandle(recv, name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+\n+    public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                           Class<?> refc,\n+                                           String name,\n+                                           MethodType type) {\n+        try {\n+            return lookup.findVirtual(refc, name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -79,0 +79,10 @@\n+    \/*\n+     * When dumping the static archive, CDS is able to archive MethodHandles.\n+     * However, CDS cannot archive SoftReference objects, so we need to\n+     * make sure the archived MethodHandles do not directly or indirectly use\n+     * SoftReferences.\n+     *\/\n+    public static boolean disableMethodHandleSoftCache() {\n+        return isDumpingStaticArchive();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -87,7 +88,3 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            THREAD_COUNT = l.findVarHandle(ThreadFlock.class, \"threadCount\", int.class);\n-            PERMIT = l.findVarHandle(ThreadFlock.class, \"permit\", boolean.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        THREAD_COUNT = MhUtil.findVarHandle(l, \"threadCount\", int.class);\n+        PERMIT = MhUtil.findVarHandle(l, \"permit\", boolean.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -161,4 +162,0 @@\n-    private static int classFileMajorVersion;\n-    private static int classFileMinorVersion;\n-    private static final int PREVIEW_MINOR_VERSION = 65535;\n-\n@@ -178,1 +175,1 @@\n-        if (major < 45 || major > classFileMajorVersion) return false;\n+        if (major < ClassFile.JAVA_1_VERSION || major > ClassFile.latestMajorVersion()) return false;\n@@ -180,1 +177,1 @@\n-        if (major < 56) return true;\n+        if (major < ClassFile.JAVA_12_VERSION) return true;\n@@ -182,1 +179,1 @@\n-        return minor == 0 || minor == PREVIEW_MINOR_VERSION;\n+        return minor == 0 || (minor == ClassFile.PREVIEW_MINOR_VERSION && major == ClassFile.latestMajorVersion());\n@@ -192,6 +189,2 @@\n-        if (major < 53 || major > classFileMajorVersion) return false;\n-        \/\/ for major version is between 45 and 55 inclusive, the minor version may be any value\n-        if (major < 56) return true;\n-        \/\/ otherwise, the minor version must be 0 or 65535\n-        \/\/ preview features do not apply to module-info.class but JVMS allows it\n-        return minor == 0 || minor == PREVIEW_MINOR_VERSION;\n+        if (major < ClassFile.JAVA_9_VERSION) return false;\n+        return isSupportedClassFileVersion(major, minor);\n@@ -274,9 +267,0 @@\n-\n-        s = props.get(\"java.class.version\");\n-        int index = s.indexOf('.');\n-        try {\n-            classFileMajorVersion = Integer.parseInt(s.substring(0, index));\n-            classFileMinorVersion = Integer.parseInt(s.substring(index + 1));\n-        } catch (NumberFormatException e) {\n-            throw new InternalError(e);\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -313,11 +314,4 @@\n-            static final JavaLangInvokeAccess JLIA;\n-            static final MethodHandle NATIVE_ACCESSOR_INVOKE;\n-            static {\n-                try {\n-                    JLIA = SharedSecrets.getJavaLangInvokeAccess();\n-                    NATIVE_ACCESSOR_INVOKE = MethodHandles.lookup().findVirtual(NativeAccessor.class, \"invoke\",\n-                            genericMethodType(1, true));\n-                } catch (NoSuchMethodException|IllegalAccessException e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n+            static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+            static final MethodHandle NATIVE_ACCESSOR_INVOKE = MhUtil.findVirtual(\n+                    MethodHandles.lookup(), NativeAccessor.class, \"invoke\",\n+                    genericMethodType(1, true));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -44,9 +45,3 @@\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            CLOSED = l.findVarHandle(SharedThreadContainer.class,\n-                    \"closed\", boolean.class);\n-            VIRTUAL_THREADS = l.findVarHandle(SharedThreadContainer.class,\n-                    \"virtualThreads\", Set.class);\n-        } catch (Exception e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        CLOSED = MhUtil.findVarHandle(l, \"closed\", boolean.class);\n+        VIRTUAL_THREADS = MhUtil.findVarHandle(l, \"virtualThreads\", Set.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/SharedThreadContainer.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -78,0 +77,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -152,9 +152,2 @@\n-    private static final VarHandle SOCKET;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            SOCKET = l.findVarHandle(DatagramChannelImpl.class, \"socket\", DatagramSocket.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n+    private static final VarHandle SOCKET = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), \"socket\", DatagramSocket.class);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -54,3 +55,1 @@\n-    public static String expand(String value)\n-        throws ExpandException\n-    {\n+    public static String expand(String value) throws ExpandException {\n@@ -60,3 +59,21 @@\n-     public static String expand(String value, boolean encodeURL)\n-         throws ExpandException\n-     {\n+    public static String expand(String value, boolean encodeURL)\n+            throws ExpandException {\n+        return expand(value, encodeURL, System::getProperty);\n+    }\n+\n+    \/*\n+     * In non-strict mode an undefined property is replaced by an empty string.\n+     *\/\n+    public static String expandNonStrict(String value) {\n+        try {\n+            return expand(value, false, key -> System.getProperty(key, \"\"));\n+        } catch (ExpandException e) {\n+            \/\/ should not happen\n+            throw new AssertionError(\"unexpected expansion error: when \" +\n+                    \"expansion is non-strict, undefined properties should \" +\n+                    \"be replaced by an empty string\", e);\n+        }\n+    }\n+\n+    private static String expand(String value, boolean encodeURL,\n+            UnaryOperator<String> propertiesGetter) throws ExpandException {\n@@ -108,1 +125,1 @@\n-                    String val = System.getProperty(prop);\n+                    String val = propertiesGetter.apply(prop);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PropertyExpander.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,27 @@\n+#\n+# The special \"include\" property can be defined one or multiple times with\n+# a filesystem path value. The effect of each definition is to include a\n+# referred security properties file inline, adding all its properties.\n+# Security properties defined before an include statement may be overridden\n+# by properties in the included file, if their names match. Conversely,\n+# properties defined after an include statement may override properties in\n+# the included file.\n+#\n+# Included files, as well as files pointed to by java.security.properties,\n+# can include other files recursively. Paths may be absolute or relative.\n+# Each relative path is resolved against the base file containing its\n+# \"include\" definition, if local. Paths may contain system properties for\n+# expansion in the form of ${system.property}. If a system property does\n+# not have a value, it expands to the empty string.\n+#\n+# An error will be thrown if a file cannot be included. This may happen\n+# if the file cannot be resolved, does not exist, is a directory, there are\n+# insufficient permissions to read it, it is recursively included more than\n+# once, or for any other reason. For a secure JDK configuration, it is\n+# important to review OS write permissions assigned to any file included.\n+#\n+# Examples:\n+#   1) include ${java.home}\/conf\/security\/extra.security\n+#   2) include extra.security\n+#   3) include ${java.home}\/conf\/security\/profile${SecurityProfile}.security\n+#\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -106,3 +106,0 @@\n-#define SPC_ERROR1      \"Error: Specifying an alternate JDK\/JRE version is no longer supported.\\n  The use of the flag '-version:' is no longer valid.\\n  Please download and execute the appropriate version.\"\n-#define SPC_ERROR2      \"Error: Specifying an alternate JDK\/JRE is no longer supported.\\n  The related flags -jre-restrict-search | -jre-no-restrict-search are also no longer valid.\"\n-\n","filename":"src\/java.base\/share\/native\/libjli\/emessages.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * vm does not understand and will not process.  These options include\n+ * vm does not understand and will not process. These options include\n@@ -39,1 +39,1 @@\n- * -server) as well as options which select the data model to use.\n+ * -server).\n@@ -45,6 +45,1 @@\n- * removes \"-J\" prefixes.  The CreateExecutionEnvironment function processes\n- * and removes -d<n> options. On unix, there is a possibility that the running\n- * data model may not match to the desired data model, in this case an exec is\n- * required to start the desired model. If the data models match, then\n- * ParseArguments will remove the -d<n> flags. If the data models do not match\n- * the CreateExecutionEnviroment will remove the -d<n> flags.\n+ * removes \"-J\" prefixes.\n@@ -58,0 +53,1 @@\n+#include \"stdbool.h\"\n@@ -61,2 +57,2 @@\n- * the program image remain relatively small until after SelectVersion\n- * CreateExecutionEnvironment have finished their possibly recursive\n+ * the program image remain relatively small until after\n+ * CreateExecutionEnvironment has finished its possibly recursive\n@@ -91,4 +87,4 @@\n- * Entries for splash screen environment variables.\n- * putenv is performed in SelectVersion. We need\n- * them in memory until UnsetEnv, so they are made static\n- * global instead of auto local.\n+ * Values that will be stored into splash screen environment variables.\n+ * putenv is performed to set _JAVA_SPLASH_FILE and _JAVA_SPLASH_JAR\n+ * with these values. We need them in memory until UnsetEnv in\n+ * ShowSplashScreen, so they are made static global instead of auto local.\n@@ -113,1 +109,0 @@\n-static void SelectVersion(int argc, char **argv, char **main_class);\n@@ -116,1 +111,1 @@\n-                               int *pret, const char *jrepath);\n+                               int *pret);\n@@ -121,0 +116,1 @@\n+static void SetupSplashScreenEnvVars(const char *splash_file_path, char *jar_path);\n@@ -125,1 +121,0 @@\n-static void SetApplicationClassPath(const char**);\n@@ -133,3 +128,0 @@\n-static jboolean ValidateModules(JNIEnv* env);\n-\n-static void SetPaths(int argc, char **argv);\n@@ -243,1 +235,0 @@\n-    char *main_class = NULL;\n@@ -260,0 +251,4 @@\n+        char *env_in;\n+        if ((env_in = getenv(MAIN_CLASS_ENV_ENTRY)) != NULL) {\n+            printf(\"Launched through Multiple JRE (mJRE) support\\n\");\n+        }\n@@ -272,12 +267,0 @@\n-    \/*\n-     * SelectVersion() has several responsibilities:\n-     *\n-     *  1) Disallow specification of another JRE.  With 1.9, another\n-     *     version of the JRE cannot be invoked.\n-     *  2) Allow for a JRE version to invoke JDK 1.9 or later.  Since\n-     *     all mJRE directives have been stripped from the request but\n-     *     the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been\n-     *     invoked from the command line.\n-     *\/\n-    SelectVersion(argc, argv, &main_class);\n-\n@@ -326,1 +309,1 @@\n-    if (!ParseArguments(&argc, &argv, &mode, &what, &ret, jrepath)) {\n+    if (!ParseArguments(&argc, &argv, &mode, &what, &ret)) {\n@@ -1081,161 +1064,0 @@\n-\/*\n- * The SelectVersion() routine ensures that an appropriate version of\n- * the JRE is running.  The specification for the appropriate version\n- * is obtained from either the manifest of a jar file (preferred) or\n- * from command line options.\n- * The routine also parses splash screen command line options and\n- * passes on their values in private environment variables.\n- *\/\n-static void\n-SelectVersion(int argc, char **argv, char **main_class)\n-{\n-    char    *arg;\n-    char    *operand;\n-    int     jarflag = 0;\n-    int     headlessflag = 0;\n-    manifest_info info;\n-    char    *splash_file_name = NULL;\n-    char    *splash_jar_name = NULL;\n-    char    *env_in;\n-    int     res;\n-    jboolean has_arg;\n-\n-    \/*\n-     * If the version has already been selected, set *main_class\n-     * with the value passed through the environment (if any) and\n-     * simply return.\n-     *\/\n-\n-    \/*\n-     * This environmental variable can be set by mJRE capable JREs\n-     * [ 1.5 thru 1.8 ].  All other aspects of mJRE processing have been\n-     * stripped by those JREs.  This environmental variable allows 1.9+\n-     * JREs to be started by these mJRE capable JREs.\n-     * Note that mJRE directives in the jar manifest file would have been\n-     * ignored for a JRE started by another JRE...\n-     * .. skipped for JRE 1.5 and beyond.\n-     * .. not even checked for pre 1.5.\n-     *\/\n-    if ((env_in = getenv(ENV_ENTRY)) != NULL) {\n-        if (*env_in != '\\0')\n-            *main_class = JLI_StringDup(env_in);\n-        return;\n-    }\n-\n-    \/*\n-     * Scan through the arguments for options relevant to multiple JRE\n-     * support.  Multiple JRE support existed in JRE versions 1.5 thru 1.8.\n-     *\n-     * This capability is no longer available with JRE versions 1.9 and later.\n-     * These command line options are reported as errors.\n-     *\/\n-\n-    argc--;\n-    argv++;\n-    while (argc > 0 && *(arg = *argv) == '-') {\n-        has_arg = IsOptionWithArgument(argc, argv);\n-        if (JLI_StrCCmp(arg, \"-version:\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR1);\n-        } else if (JLI_StrCmp(arg, \"-jre-restrict-search\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR2);\n-        } else if (JLI_StrCmp(arg, \"-jre-no-restrict-search\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR2);\n-        } else {\n-            if (JLI_StrCmp(arg, \"-jar\") == 0)\n-                jarflag = 1;\n-            if (IsWhiteSpaceOption(arg)) {\n-                if (has_arg) {\n-                    argc--;\n-                    argv++;\n-                    arg = *argv;\n-                }\n-            }\n-\n-            \/*\n-             * Checking for headless toolkit option in the some way as AWT does:\n-             * \"true\" means true and any other value means false\n-             *\/\n-            if (JLI_StrCmp(arg, \"-Djava.awt.headless=true\") == 0) {\n-                headlessflag = 1;\n-            } else if (JLI_StrCCmp(arg, \"-Djava.awt.headless=\") == 0) {\n-                headlessflag = 0;\n-            } else if (JLI_StrCCmp(arg, \"-splash:\") == 0) {\n-                splash_file_name = arg+8;\n-            }\n-        }\n-        argc--;\n-        argv++;\n-    }\n-    if (argc <= 0) {    \/* No operand? Possibly legit with -[full]version *\/\n-        operand = NULL;\n-    } else {\n-        argc--;\n-        operand = *argv++;\n-    }\n-\n-    \/*\n-     * If there is a jar file, read the manifest. If the jarfile can't be\n-     * read, the manifest can't be read from the jar file, or the manifest\n-     * is corrupt, issue the appropriate error messages and exit.\n-     *\n-     * Even if there isn't a jar file, construct a manifest_info structure\n-     * containing the command line information.  It's a convenient way to carry\n-     * this data around.\n-     *\/\n-    if (jarflag && operand) {\n-        if ((res = JLI_ParseManifest(operand, &info)) != 0) {\n-            if (res == -1)\n-                JLI_ReportErrorMessage(JAR_ERROR2, operand);\n-            else\n-                JLI_ReportErrorMessage(JAR_ERROR3, operand);\n-            exit(1);\n-        }\n-\n-        \/*\n-         * Command line splash screen option should have precedence\n-         * over the manifest, so the manifest data is used only if\n-         * splash_file_name has not been initialized above during command\n-         * line parsing\n-         *\/\n-        if (!headlessflag && !splash_file_name && info.splashscreen_image_file_name) {\n-            splash_file_name = info.splashscreen_image_file_name;\n-            splash_jar_name = operand;\n-        }\n-    } else {\n-        info.manifest_version = NULL;\n-        info.main_class = NULL;\n-        info.jre_version = NULL;\n-        info.jre_restrict_search = 0;\n-    }\n-\n-    \/*\n-     * Passing on splash screen info in environment variables\n-     *\/\n-    if (splash_file_name && !headlessflag) {\n-        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")+JLI_StrLen(splash_file_name)+1);\n-        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n-        JLI_StrCat(splash_file_entry, splash_file_name);\n-        putenv(splash_file_entry);\n-    }\n-    if (splash_jar_name && !headlessflag) {\n-        splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY \"=\")+JLI_StrLen(splash_jar_name)+1);\n-        JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY \"=\");\n-        JLI_StrCat(splash_jar_entry, splash_jar_name);\n-        putenv(splash_jar_entry);\n-    }\n-\n-\n-    \/*\n-     * \"Valid\" returns (other than unrecoverable errors) follow.  Set\n-     * main_class as a side-effect of this routine.\n-     *\/\n-    if (info.main_class != NULL)\n-        *main_class = JLI_StringDup(info.main_class);\n-\n-    if (info.jre_version == NULL) {\n-        JLI_FreeManifest();\n-        return;\n-    }\n-\n-}\n-\n@@ -1328,1 +1150,1 @@\n-               int *pret, const char *jrepath)\n+               int *pret)\n@@ -1334,0 +1156,2 @@\n+    bool headless = false;\n+    char *splash_file_path = NULL; \/\/ value of \"-splash:\" option\n@@ -1495,1 +1319,1 @@\n-            ; \/* Ignore machine independent options already handled *\/\n+            splash_file_path = arg + 8;\n@@ -1504,0 +1328,8 @@\n+            } else if (JLI_StrCmp(arg, \"-Djava.awt.headless=true\") == 0) {\n+                \/*\n+                 * Checking for headless toolkit option in the same way as AWT does:\n+                 * \"true\" means true and any other value means false\n+                 *\/\n+                headless = true;\n+            } else if (JLI_StrCCmp(arg, \"-Djava.awt.headless=\") == 0) {\n+                headless = false;\n@@ -1554,0 +1386,10 @@\n+    if (!headless) {\n+        char *jar_path = NULL;\n+        if (mode == LM_JAR) {\n+            jar_path = *pwhat;\n+        }\n+        \/\/ Not in headless mode. We now set a couple of env variables that\n+        \/\/ will be used later by ShowSplashScreen().\n+        SetupSplashScreenEnvVars(splash_file_path, jar_path);\n+    }\n+\n@@ -1557,0 +1399,63 @@\n+\/*\n+ * Sets the relevant environment variables that are subsequently used by\n+ * the ShowSplashScreen() function. The splash_file_path and jar_path parameters\n+ * are used to determine which environment variables to set.\n+ * The splash_file_path is the value that was provided to the \"-splash:\" option\n+ * when launching java. It may be null, which implies the \"-splash:\" option wasn't used.\n+ * The jar_path is the value that was provided to the \"-jar\" option when launching java.\n+ * It too may be null, which implies the \"-jar\" option wasn't used.\n+ *\/\n+static void\n+SetupSplashScreenEnvVars(const char *splash_file_path, char *jar_path) {\n+    \/\/ Command line specified \"-splash:\" takes priority over manifest one.\n+    if (splash_file_path) {\n+        \/\/ We set up the splash file name as a env variable which then gets\n+        \/\/ used when showing the splash screen in ShowSplashScreen().\n+\n+        \/\/ create the string of the form _JAVA_SPLASH_FILE=<val>\n+        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")\n+                                         + JLI_StrLen(splash_file_path) + 1);\n+        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n+        JLI_StrCat(splash_file_entry, splash_file_path);\n+        putenv(splash_file_entry);\n+        return;\n+    }\n+    if (!jar_path) {\n+        \/\/ no jar to look into for \"SplashScreen-Image\" manifest attribute\n+        return;\n+    }\n+    \/\/ parse the jar's manifest to find any \"SplashScreen-Image\"\n+    int res = 0;\n+    manifest_info  info;\n+    if ((res = JLI_ParseManifest(jar_path, &info)) != 0) {\n+        JLI_FreeManifest(); \/\/ cleanup any manifest structure\n+        if (res == -1) {\n+            JLI_ReportErrorMessage(JAR_ERROR2, jar_path);\n+        } else {\n+            JLI_ReportErrorMessage(JAR_ERROR3, jar_path);\n+        }\n+        exit(1);\n+    }\n+    if (!info.splashscreen_image_file_name) {\n+        JLI_FreeManifest(); \/\/ cleanup the manifest structure\n+        \/\/ no \"SplashScreen-Image\" in jar's manifest\n+        return;\n+    }\n+    \/\/ The jar's manifest had a \"Splashscreen-Image\" specified. We set up the jar entry name\n+    \/\/ and the jar file name as env variables which then get used when showing the splash screen\n+    \/\/ in ShowSplashScreen().\n+\n+    \/\/ create the string of the form _JAVA_SPLASH_FILE=<val>\n+    splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")\n+                                     + JLI_StrLen(info.splashscreen_image_file_name) + 1);\n+    JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n+    JLI_StrCat(splash_file_entry, info.splashscreen_image_file_name);\n+    putenv(splash_file_entry);\n+    \/\/ create the string of the form _JAVA_SPLASH_JAR=<val>\n+    splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY \"=\") + JLI_StrLen(jar_path) + 1);\n+    JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY \"=\");\n+    JLI_StrCat(splash_jar_entry, jar_path);\n+    putenv(splash_jar_entry);\n+    JLI_FreeManifest(); \/\/ cleanup the manifest structure\n+}\n+\n@@ -2343,1 +2248,1 @@\n-    (void)UnsetEnv(ENV_ENTRY);\n+    (void)UnsetEnv(MAIN_CLASS_ENV_ENTRY);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":103,"deletions":198,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,0 @@\n-#define CURRENT_DATA_MODEL (CHAR_BIT * sizeof(void*))\n-\n@@ -54,15 +52,11 @@\n- * The following environment variable is used to influence the behavior\n- * of the jre exec'd through the SelectVersion routine.  The command line\n- * options which specify the version are not passed to the exec'd version,\n- * because that jre may be an older version which wouldn't recognize them.\n- * This environment variable is known to this (and later) version and serves\n- * to suppress the version selection code.  This is not only for efficiency,\n- * but also for correctness, since any command line options have been\n- * removed which would cause any value found in the manifest to be used.\n- * This would be incorrect because the command line options are defined\n- * to take precedence.\n- *\n- * The value associated with this environment variable is the MainClass\n- * name from within the executable jar file (if any). This is strictly a\n- * performance enhancement to avoid re-reading the jar file manifest.\n- *\n+ * Older versions of java launcher used to support JRE version selection - specifically,\n+ * the java launcher in JDK 1.8 can be used to launch a java application using a different\n+ * java runtime (older, newer or same version JRE installed at a different location) than\n+ * the one the launcher belongs to.\n+ * That support was discontinued starting JDK 9. However, the JDK 8 launcher can still\n+ * be started with JRE version selection options to launch Java runtimes greater than JDK 8.\n+ * In such cases, the JDK 8 launcher when exec()ing the JDK N launcher, will set and propagate\n+ * the _JAVA_VERSION_SET environment variable. The value of this environment variable is the\n+ * Main-Class name from within the executable jar file (if any).\n+ * The java launcher in the current version of the JDK doesn't use this environment variable\n+ * in any way other than merely using it in debug logging.\n@@ -70,1 +64,1 @@\n-#define ENV_ENTRY \"_JAVA_VERSION_SET\"\n+#define MAIN_CLASS_ENV_ENTRY \"_JAVA_VERSION_SET\"\n@@ -110,3 +104,0 @@\n-void\n-GetXUsagePath(char *buf, jint bufsize);\n-\n@@ -119,2 +110,0 @@\n-#define GetArch() GetArchPath(CURRENT_DATA_MODEL)\n-\n@@ -156,1 +145,0 @@\n-void PrintMachineDependentOptions();\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,4 +170,0 @@\n-    char        *manifest_version;      \/* Manifest-Version string *\/\n-    char        *main_class;            \/* Main-Class entry *\/\n-    char        *jre_version;           \/* Appropriate J2SE release spec *\/\n-    char        jre_restrict_search;    \/* Restricted JRE search *\/\n","filename":"src\/java.base\/share\/native\/libjli\/manifest_info.h","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -597,4 +597,0 @@\n-    info->manifest_version = NULL;\n-    info->main_class = NULL;\n-    info->jre_version = NULL;\n-    info->jre_restrict_search = 0;\n@@ -613,11 +609,1 @@\n-        if (JLI_StrCaseCmp(name, \"Manifest-Version\") == 0) {\n-            info->manifest_version = value;\n-        } else if (JLI_StrCaseCmp(name, \"Main-Class\") == 0) {\n-            info->main_class = value;\n-        } else if (JLI_StrCaseCmp(name, \"JRE-Version\") == 0) {\n-            \/*\n-             * Manifest specification overridden by command line option\n-             * so we will silently override there with no specification.\n-             *\/\n-            info->jre_version = 0;\n-        } else if (JLI_StrCaseCmp(name, \"Splashscreen-Image\") == 0) {\n+        if (JLI_StrCaseCmp(name, \"Splashscreen-Image\") == 0) {\n","filename":"src\/java.base\/share\/native\/libjli\/parse_manifest.c","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,1 +55,3 @@\n- * Flowchart of launcher execs and options processing on unix\n+ * Following is the high level flow of the launcher\n+ * code residing in the common java.c and this\n+ * unix specific java_md file:\n@@ -57,5 +59,2 @@\n- * The selection of the proper vm shared library to open depends on\n- * several classes of command line options, including vm \"flavor\"\n- * options (-client, -server).\n- * The vm selection options are not passed to the running\n- * virtual machine; they must be screened out by the launcher.\n+ *  - JLI_Launch function, which is the entry point\n+ *    to the launcher, calls CreateExecutionEnvironment.\n@@ -63,3 +62,8 @@\n- * The version specification (if any) is processed first by the\n- * platform independent routine SelectVersion.  This may result in\n- * the exec of the specified launcher version.\n+ *  - CreateExecutionEnvironment does the following\n+ *    (not necessarily in this order):\n+ *      - determines the relevant JVM type that\n+ *        needs to be ultimately created\n+ *      - determines the path and asserts the presence\n+ *        of libjava and relevant libjvm library\n+ *      - removes any JVM selection options from the\n+ *        arguments that were passed to the launcher\n@@ -67,4 +71,10 @@\n- * Previously the launcher modified the LD_LIBRARY_PATH appropriately for the\n- * desired data model path, regardless if data models matched or not. The\n- * launcher subsequently exec'ed the desired executable, in order to make the\n- * LD_LIBRARY_PATH path available, for the runtime linker.\n+ *  - CreateExecutionEnvironment then determines (by calling\n+ *    RequiresSetenv function) if LD_LIBRARY_PATH environment\n+ *    variable needs to be set\/updated.\n+ *      - If LD_LIBRARY_PATH needs to be set\/updated,\n+ *        then CreateExecutionEnvironment exec()s\n+ *        the current process with the appropriate value\n+ *        for LD_LIBRARY_PATH.\n+ *      - Else if LD_LIBRARY_PATH need not be set or\n+ *        updated, then CreateExecutionEnvironment\n+ *        returns back.\n@@ -72,6 +82,9 @@\n- * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n- * required libraries are loaded by the runtime linker, using the\n- * $RPATH\/$ORIGIN baked into the shared libraries at compile time. Therefore,\n- * in most cases, the launcher will only exec, if the data models are\n- * mismatched, and will not set any environment variables, regardless of the\n- * data models.\n+ *  - If CreateExecutionEnvironment exec()ed the process\n+ *    in the previous step, then the code control for the\n+ *    process will again start from the process' entry\n+ *    point and JLI_Launch is thus re-invoked and the\n+ *    same above sequence of code flow repeats again.\n+ *    During this \"recursive\" call into CreateExecutionEnvironment,\n+ *    the implementation of the check for LD_LIBRARY_PATH\n+ *    will realize that no further exec() is required and\n+ *    the control will return back from CreateExecutionEnvironment.\n@@ -79,7 +92,2 @@\n- * However, if the environment contains a LD_LIBRARY_PATH, this will cause the\n- * launcher to inspect the LD_LIBRARY_PATH. The launcher will check\n- *  a. if the LD_LIBRARY_PATH's first component is the path to the desired\n- *     libjvm.so\n- *  b. if any other libjvm.so is found in any of the paths.\n- * If case b is true, then the launcher will set the LD_LIBRARY_PATH to the\n- * desired JRE and reexec, in order to propagate the environment.\n+ *  - The control returns back from CreateExecutionEnvironment\n+ *    to JLI_Launch.\n@@ -87,64 +95,40 @@\n- *  Main\n- *  (incoming argv)\n- *  |\n- * \\|\/\n- * CreateExecutionEnvironment\n- * (determines desired data model)\n- *  |\n- *  |\n- * \\|\/\n- *  Have Desired Model ? --> NO --> Exit(with error)\n- *  |\n- *  |\n- * \\|\/\n- * YES\n- *  |\n- *  |\n- * \\|\/\n- * CheckJvmType\n- * (removes -client, -server, etc.)\n- *  |\n- *  |\n- * \\|\/\n- * TranslateDashJArgs...\n- * (Prepare to pass args to vm)\n- *  |\n- *  |\n- * \\|\/\n- * ParseArguments\n- *   |\n- *   |\n- *  \\|\/\n- * RequiresSetenv\n- * Is LD_LIBRARY_PATH\n- * and friends set ? --> NO --> Continue\n- *  YES\n- *   |\n- *   |\n- *  \\|\/\n- * Path is desired JRE ? YES --> Continue\n- *  NO\n- *   |\n- *   |\n- *  \\|\/\n- * Paths have well known\n- * jvm paths ?       --> NO --> Error\/Exit\n- *  YES\n- *   |\n- *   |\n- *  \\|\/\n- *  Does libjvm.so exist\n- *  in any of them ? --> NO  --> Continue\n- *   YES\n- *   |\n- *   |\n- *  \\|\/\n- *  Set the LD_LIBRARY_PATH\n- *   |\n- *   |\n- *  \\|\/\n- * Re-exec\n- *   |\n- *   |\n- *  \\|\/\n- * Main\n+ *  - JLI_Launch then invokes LoadJavaVM which dlopen()s\n+ *    the JVM library and asserts the presence of\n+ *    JNI Invocation Functions \"JNI_CreateJavaVM\",\n+ *    \"JNI_GetDefaultJavaVMInitArgs\" and\n+ *    \"JNI_GetCreatedJavaVMs\" in that library. It then\n+ *    sets internal function pointers in the launcher to\n+ *    point to those functions.\n+ *\n+ *  - JLI_Launch then translates any -J options by\n+ *    invoking TranslateApplicationArgs.\n+ *\n+ *  - JLI_Launch then invokes ParseArguments to\n+ *    parse\/process the launcher arguments.\n+ *\n+ *  - JLI_Launch then ultimately calls JVMInit.\n+ *\n+ *  - JVMInit invokes ShowSplashScreen which displays\n+ *    a splash screen for the application, if applicable.\n+ *\n+ *  - JVMInit then creates a new thread (T2), in the\n+ *    current process, and invokes JavaMain function\n+ *    in that new thread. The current thread (T1) then\n+ *    waits for the newly launched thread (T2) to complete.\n+ *\n+ *  - JavaMain function, in thread T2, before launching\n+ *    the application, invokes PostJVMInit.\n+ *\n+ *  - PostJVMInit is a no-op and returns back.\n+ *\n+ *  - Control then returns back from PostJVMInit into JavaMain,\n+ *    which then loads the application's main class and invokes\n+ *    the relevant main() Java method.\n+ *\n+ *  - JavaMain, in thread T2, then returns back an integer\n+ *    result and thread T2 execution ends here.\n+ *\n+ *  - The thread T1 in JVMInit, which is waiting on T2 to\n+ *    complete, receives the integer result and then propagates\n+ *    it as a return value all the way out of the\n+ *    JLI_Launch function.\n@@ -224,1 +208,1 @@\n- * Test whether the environment variable needs to be set, see flowchart.\n+ * Test whether the LD_LIBRARY_PATH environment variable needs to be set.\n@@ -230,1 +214,0 @@\n-    char *dmllp = NULL;\n@@ -248,1 +231,1 @@\n-    if (llp == NULL && dmllp == NULL) {\n+    if (llp == NULL) {\n@@ -287,3 +270,0 @@\n-    if (dmllp != NULL && ContainsLibJVM(dmllp)) {\n-        return JNI_TRUE;\n-    }\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":76,"deletions":96,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,3 +236,0 @@\n-#ifdef PROCESSOR_ARCHITECTURE_IA64\n-    case PROCESSOR_ARCHITECTURE_IA64: return \"ia64\";\n-#endif\n@@ -447,0 +444,2 @@\n+         * Windows Server 2025          10              0  (!VER_NT_WORKSTATION)\n+         *       where (buildNumber > 26039)\n@@ -530,1 +529,4 @@\n-                        if (buildNumber > 20347) {\n+                        \/* Windows server 2025 Preview build is 26040 *\/\n+                        if (buildNumber > 26039) {\n+                            sprops.os_name = \"Windows Server 2025\";\n+                        } else if (buildNumber > 20347) {\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-     * setting the {@code processingEnv} field to the value of the\n+     * setting the {@link #processingEnv} field to the value of the\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/AbstractProcessor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * The interface for an annotation processor.\n+ * The interface for an <dfn>{@index \"annotation processor\"}<\/dfn>.\n@@ -37,6 +37,7 @@\n- * <p>Annotation processing happens in a sequence of {@linkplain\n- * javax.annotation.processing.RoundEnvironment rounds}.  On each\n- * round, a processor may be asked to {@linkplain #process process} a\n- * subset of the annotations found on the source and class files\n- * produced by a prior round.  The inputs to the first round of\n- * processing are the initial inputs to a run of the tool; these\n+ * <p>Annotation processing happens in a sequence of <dfn>rounds<\/dfn>.\n+ * On each\n+ * {@linkplain RoundEnvironment round}, a processor may be asked to {@linkplain #process process} a\n+ * subset of the annotations found on the\n+ * {@linkplain RoundEnvironment#getRootElements() source and class files\n+ * produced by a prior round}.  The inputs to the first round of\n+ * processing are the <dfn>{@index \"initial inputs\"}<\/dfn> to a run of the tool; these\n@@ -80,1 +81,1 @@\n- * <p> The tool uses a <i>discovery process<\/i> to find annotation\n+ * <p> The tool uses a <dfn>{@index \"discovery process\"}<\/dfn> to find annotation\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Processor.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-     * environmental configuration. If an runtime annotation interface is\n+     * environmental configuration. If a runtime annotation interface is\n@@ -176,1 +176,1 @@\n-     * environmental configuration. If an runtime annotation interface is\n+     * environmental configuration. If a runtime annotation interface is\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/RoundEnvironment.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n- * <em>declaration annotation<\/em> and an annotation on a type is a\n- * <em>type annotation<\/em>.\n+ * <dfn>{@index \"declaration annotation\"}<\/dfn> and an annotation on a type is a\n+ * <dfn>{@index \"type annotation\"}<\/dfn>.\n@@ -48,1 +48,1 @@\n- * <em>indirectly present<\/em>, and <em>associated <\/em> are used\n+ * <em>indirectly present<\/em>, and <em>associated<\/em> are used\n@@ -55,1 +55,1 @@\n- * interface, the type of the containing annotation is <i>AIC<\/i>.\n+ * interface, the type of the container annotation is <i>AIC<\/i>.\n@@ -57,1 +57,1 @@\n- * <p>Annotation <i>A<\/i> is <em>directly present<\/em> on a construct\n+ * <p>Annotation <i>A<\/i> is <dfn>{@index \"directly present\"}<\/dfn> on a construct\n@@ -81,1 +81,1 @@\n- * <i>C<\/i>, then if <i>AI<\/i> is repeatable annotation interface, an\n+ * <i>C<\/i>, then if <i>AI<\/i> is a repeatable annotation interface, an\n@@ -90,1 +90,1 @@\n- * <p>An annotation <i>A<\/i> is <em>present<\/em> on a\n+ * <p>An annotation <i>A<\/i> is <dfn>{@index \"present\"}<\/dfn> on a\n@@ -102,1 +102,1 @@\n- * An annotation <i>A<\/i> is <em>indirectly present<\/em> on a construct\n+ * An annotation <i>A<\/i> is <dfn>{@index \"indirectly present\"}<\/dfn> on a construct\n@@ -117,1 +117,1 @@\n- * An annotation <i>A<\/i> is <em>associated<\/em> with a construct\n+ * An annotation <i>A<\/i> is <dfn>{@index \"associated\"}<\/dfn> with a construct\n@@ -192,1 +192,2 @@\n-     * Returns annotations that are <em>associated<\/em> with this construct.\n+     * Returns annotations of the specified type that are <em>associated<\/em>\n+     * with this construct.\n@@ -194,2 +195,2 @@\n-     * If there are no annotations associated with this construct, the\n-     * return value is an array of length 0.\n+     * If there are no annotations of the specified type associated with this\n+     * construct, the return value is an array of length 0.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/AnnotatedConstruct.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-     RELEASE_9,\n+    RELEASE_9,\n@@ -479,1 +479,1 @@\n-     * is running on a platform version different than the latest\n+     * is running on a platform version different from the latest\n@@ -505,2 +505,1 @@\n-     * keywords, and the literals {@code \"true\"},\n-     * {@code \"false\"}, {@code \"null\"}.\n+     * keywords, boolean literals, and the null literal.\n@@ -599,2 +598,2 @@\n-     * Returns whether or not {@code s} is a keyword, boolean literal,\n-     * or null literal in the latest source version.\n+     * Returns whether or not {@code s} is a keyword, a boolean literal,\n+     * or the null literal in the latest source version.\n@@ -605,2 +604,2 @@\n-     * @return {@code true} if {@code s} is a keyword, or boolean\n-     * literal, or null literal, {@code false} otherwise.\n+     * @return {@code true} if {@code s} is a keyword, a boolean\n+     * literal, or the null literal, {@code false} otherwise.\n@@ -616,2 +615,2 @@\n-     * Returns whether or not {@code s} is a keyword, boolean literal,\n-     * or null literal in the given source version.\n+     * Returns whether or not {@code s} is a keyword, a boolean literal,\n+     * or the null literal in the given source version.\n@@ -623,2 +622,2 @@\n-     * @return {@code true} if {@code s} is a keyword, or boolean\n-     * literal, or null literal, {@code false} otherwise.\n+     * @return {@code true} if {@code s} is a keyword, a boolean\n+     * literal, or the null literal, {@code false} otherwise.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-     * This is returned in the form of a map that associates elements\n+     * These are returned in the form of a map that associates elements\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationMirror.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * clause, among other restrictions; see JLS {@jls 9.6.1} for details\n+ * clause, among other restrictions; see JLS {@jls 9.6.1} for details.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * The <i>nesting kind<\/i> of a type element.\n+ * The <dfn>nesting kind<\/dfn> of a type element.\n@@ -110,1 +110,1 @@\n-     * A <i>nested<\/i> type element is any that is not top-level.\n+     * A <dfn>nested<\/dfn> type element is any that is not top-level.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/NestingKind.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n- * backing construct. For example, multiple classes and interface can\n- * be declared in the same source file, including, but are not limited\n+ * backing construct. For example, multiple classes and interfaces can\n+ * be declared in the same source file, including, but not limited\n@@ -68,1 +68,1 @@\n- * NestingKind#isNested() nested class and interfaces} within it\n+ * NestingKind#isNested() nested classes and interfaces} within it\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * program inside a method body; for example there is no\n+ * program inside a method body; for example, there is no\n@@ -87,1 +87,1 @@\n- * operating on class files, it is helpful be able to operate on such\n+ * operating on class files, it is helpful to be able to operate on such\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-     *         where the provided ModuleSymbol is any\n+     *         where the provided ModuleElement is any\n@@ -63,1 +63,1 @@\n-     *         {@link #getAllModuleElements() all modules} for observable\n+     *         {@linkplain #getAllModuleElements() all modules} for observable\n@@ -146,1 +146,1 @@\n-     *         where the provided ModuleSymbol is any\n+     *         where the provided ModuleElement is any\n@@ -150,1 +150,1 @@\n-     *         {@link #getAllModuleElements() all modules} for observable\n+     *         {@linkplain #getAllModuleElements() all modules} for observable\n@@ -620,1 +620,1 @@\n-     * declared directly.  For a class the result also includes its\n+     * declared directly.  For a class, the result also includes its\n@@ -881,4 +881,4 @@\n-     * enclosing the accessor has kind {@link ElementKind#RECORD RECORD} if that is\n-     * the case, then all the record components on the accessor's enclosing element\n-     * are retrieved by invoking {@link ElementFilter#recordComponentsIn(Iterable)}.\n-     * If the accessor of at least one of the record components retrieved happen to\n+     * enclosing the accessor has kind {@link ElementKind#RECORD RECORD}, if that is\n+     * the case, then all the record components of the accessor's enclosing element\n+     * are isolated by invoking {@link ElementFilter#recordComponentsIn(Iterable)}.\n+     * If the accessor of at least one of the record components retrieved happens to\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * methods. One or more out of scope arguments will typically result\n+ * methods. One or more out-of-scope arguments will typically result\n@@ -168,1 +168,1 @@\n-     * Annotations on the direct super types are preserved.\n+     * Annotations on the direct supertypes are preserved.\n@@ -188,1 +188,1 @@\n-     * That is, <i>boxing conversion<\/i> is applied.\n+     * That is, <dfn>boxing conversion<\/dfn> is applied.\n@@ -321,1 +321,1 @@\n-     * the number of type arguments must equal the\n+     * the number of type arguments must be equal to the\n@@ -357,1 +357,1 @@\n-     * or a wildcard type, any constitute types, such as the\n+     * or a wildcard type, any constituent types, such as the\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * should be interpreted as referring indirectly to the {@link #fileObject delegate file object}.\n+ * should be interpreted as referring indirectly to the {@linkplain #fileObject delegate file object}.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingFileObject.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * should be interpreted as referring indirectly to the {@link #fileManager delegate file manager}.\n+ * should be interpreted as referring indirectly to the {@linkplain #fileManager delegate file manager}.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * should be interpreted as referring indirectly to the {@link #fileObject delegate file object}.\n+ * should be interpreted as referring indirectly to the {@linkplain #fileObject delegate file object}.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileObject.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * fully qualified class and interface names.  For convenience '.'\n+ * fully qualified class and interface names.  For convenience, '.'\n@@ -242,1 +242,1 @@\n-     * Compares two file objects and return true if they represent the\n+     * Compares two file objects and returns true if they represent the\n@@ -258,1 +258,1 @@\n-     * file manager it will consume any arguments to that option from\n+     * file manager, it will consume any arguments to that option from\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/JavaFileManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n- * files in the {@linkplain java.nio.file.FileSystems#getDefault() default file system.}\n+ * files in the {@linkplain java.nio.file.FileSystems#getDefault() default file system}.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/StandardJavaFileManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,2 @@\n-     * Use the {@link java.util.spi.ToolProvider system tool provider} or\n-     * {@link java.util.ServiceLoader service loader} mechanisms to\n+     * Use the {@linkplain java.util.spi.ToolProvider system tool provider} or\n+     * {@linkplain java.util.ServiceLoader service loader} mechanisms to\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ToolProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,2 @@\n-    private final int FORWARD_TRAVERSAL = 0;\n-    private final int BACKWARD_TRAVERSAL = 1;\n+    private static final int FORWARD_TRAVERSAL = 0;\n+    private static final int BACKWARD_TRAVERSAL = 1;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SortingFocusTraversalPolicy.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -289,0 +289,4 @@\n+        if (textKind == DocTree.Kind.MARKDOWN) {\n+            initMarkdownLine();\n+        }\n+\n@@ -295,4 +299,1 @@\n-                        markdown.update();\n-                        if (markdown.isIndentedCodeBlock()) {\n-                            markdown.skipLine();\n-                        }\n+                        initMarkdownLine();\n@@ -491,0 +492,11 @@\n+    void initMarkdownLine() {\n+        if (textStart == -1) {\n+            textStart = bp;\n+        }\n+        markdown.update();\n+        if (markdown.isIndentedCodeBlock()) {\n+            markdown.skipLine();\n+            lastNonWhite = bp - 1; \/\/ do not include newline or EOF\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -595,17 +595,3 @@\n-                            int breakOffset = getSentenceBreak(dt.getKind(), content, peekedNext);\n-                            if (breakOffset > 0) {\n-                                \/\/ the end of sentence is within the current node;\n-                                \/\/ split it, skipping whitespace in between the two parts\n-                                var fsPart = newNode(dt.getKind(), dt.pos, content.substring(0, breakOffset).stripTrailing());\n-                                fs.add(fsPart);\n-                                int wsOffset = skipWhiteSpace(content, breakOffset);\n-                                if (wsOffset > 0) {\n-                                    var bodyPart = newNode(dt.getKind(), dt.pos + wsOffset, content.substring(wsOffset));\n-                                    body.add(bodyPart);\n-                                }\n-                                foundFirstSentence = true;\n-                            } else if (peekedNext != null && isSentenceBreak(peekedNext, false)) {\n-                                \/\/ the next node is a sentence break, so this is the end of the first sentence;\n-                                \/\/ remove trailing spaces\n-                                var fsPart = newNode(dt.getKind(), dt.pos, content.stripTrailing());\n-                                fs.add(fsPart);\n+                            if (isFirst && dt.getKind() == Kind.MARKDOWN && isIndented(content)) {\n+                                \/\/ begins with an indented code block (unusual), so no first sentence\n+                                body.add(dt);\n@@ -614,2 +600,22 @@\n-                                \/\/ no sentence break found; keep scanning\n-                                fs.add(dt);\n+                                int breakOffset = getSentenceBreak(dt.getKind(), content, peekedNext);\n+                                if (breakOffset > 0) {\n+                                    \/\/ the end of sentence is within the current node;\n+                                    \/\/ split it, skipping whitespace in between the two parts\n+                                    var fsPart = newNode(dt.getKind(), dt.pos, content.substring(0, breakOffset).stripTrailing());\n+                                    fs.add(fsPart);\n+                                    int wsOffset = skipWhiteSpace(content, breakOffset);\n+                                    if (wsOffset > 0) {\n+                                        var bodyPart = newNode(dt.getKind(), dt.pos + wsOffset, content.substring(wsOffset));\n+                                        body.add(bodyPart);\n+                                    }\n+                                    foundFirstSentence = true;\n+                                } else if (peekedNext != null && isSentenceBreak(peekedNext, false)) {\n+                                    \/\/ the next node is a sentence break, so this is the end of the first sentence;\n+                                    \/\/ remove trailing spaces\n+                                    var fsPart = newNode(dt.getKind(), dt.pos, content.stripTrailing());\n+                                    fs.add(fsPart);\n+                                    foundFirstSentence = true;\n+                                } else {\n+                                    \/\/ no sentence break found; keep scanning\n+                                    fs.add(dt);\n+                                }\n@@ -654,0 +660,5 @@\n+        private static final Pattern INDENT = Pattern.compile(\" {4}| {0,3}\\t\");\n+        private boolean isIndented(String s) {\n+            return INDENT.matcher(s).lookingAt();\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1470,1 +1470,1 @@\n-                    print(Convert.quote(String.valueOf((char)((Number)tree.value).intValue())));\n+                    print(Convert.quote((char)((Number)tree.value).intValue(), true));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,2 @@\n-    baseField = type.getAddressField(\"_narrow_oop._base\");\n-    shiftField = type.getCIntegerField(\"_narrow_oop._shift\");\n+    baseField = type.getAddressField(\"_base\");\n+    shiftField = type.getCIntegerField(\"_shift\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/CompressedOops.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-    raw_unextendedSP = getFP();\n+    \/\/ Nothing to do. senderForInterpreterFrame finds the correct unextendedSP.\n@@ -350,0 +350,1 @@\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+                        String reason;\n@@ -108,1 +109,1 @@\n-                            throw runtime.exitHotSpotWithMessage(1, \"JVMCI compiler '%s' not found in JVMCI native library.%n\" +\n+                            reason = String.format(\"JVMCI compiler '%s' not found in JVMCI native library.%n\" +\n@@ -111,0 +112,2 @@\n+                        } else {\n+                            reason = String.format(\"JVMCI compiler '%s' specified by %s not found%n\", compilerName, compPropertyName);\n@@ -112,1 +115,1 @@\n-                        throw runtime.exitHotSpotWithMessage(1, \"JVMCI compiler '%s' specified by %s not found%n\", compilerName, compPropertyName);\n+                        factory = new DummyCompilerFactory(reason, runtime);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -363,2 +363,5 @@\n-section[id$=-description] :is(dl, ol, ul, p, div, blockquote, pre):last-child,\n-section[id$=-description] :is(dl, ol, ul):last-child > :is(li, dd):last-child {\n+\/* Compensate for non-collapsing margins between element description and summary tables *\/\n+div.horizontal-scroll > section[id$=-description] > :is(dl, ol, ul, p, div, blockquote, pre):last-child,\n+div.horizontal-scroll > section[id$=-description] > :last-child > :is(li, dd):last-child,\n+section.class-description > div.horizontal-scroll > :is(dl, ol, ul, p, div, blockquote, pre):last-child,\n+section.class-description > div.horizontal-scroll > :last-child > :is(li, dd):last-child {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.time.LocalDateTime;\n@@ -291,37 +290,0 @@\n-\n-    static String expandFilename(String filename) {\n-        if (filename == null || filename.indexOf('%') == -1) {\n-            return filename;\n-        }\n-\n-        String pid = null;\n-        String time = null;\n-        StringBuilder sb = new StringBuilder();\n-        for (int i = 0; i < filename.length(); i++) {\n-            char c = filename.charAt(i);\n-            if (c == '%' && i < filename.length() - 1) {\n-                char nc = filename.charAt(i + 1);\n-                if (nc == '%') { \/\/ %% ==> %\n-                    sb.append('%');\n-                    i++;\n-                } else if (nc == 'p') {\n-                    if (pid == null) {\n-                        pid = JVM.getPid();\n-                    }\n-                    sb.append(pid);\n-                    i++;\n-                } else if (nc == 't') {\n-                    if (time == null) {\n-                        time = ValueFormatter.formatDateTime(LocalDateTime.now());\n-                    }\n-                    sb.append(time);\n-                    i++;\n-                } else {\n-                    sb.append('%');\n-                }\n-            } else {\n-                sb.append(c);\n-            }\n-        }\n-        return sb.toString();\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.time.LocalDateTime;\n@@ -34,0 +35,2 @@\n+\n+import jdk.jfr.internal.JVM;\n@@ -36,0 +39,1 @@\n+import jdk.jfr.internal.util.ValueFormatter;\n@@ -229,0 +233,1 @@\n+            case \"FILE\" -> text == null ? \"\" : parseFilename(text);\n@@ -233,0 +238,43 @@\n+    \/**\n+     * Expands filename arguments replacing '%p' with the PID\n+     * and '%t' with the time in 'yyyy_MM_dd_HH_mm_ss' format.\n+     * @param filename a filename to be expanded\n+     * @return filename with expanded arguments\n+     *\/\n+    private String parseFilename(String filename) {\n+        if (filename == null || filename.indexOf('%') == -1) {\n+            return filename;\n+        }\n+\n+        String pid = null;\n+        String time = null;\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < filename.length(); i++) {\n+            char c = filename.charAt(i);\n+            if (c == '%' && i < filename.length() - 1) {\n+                char nc = filename.charAt(i + 1);\n+                if (nc == '%') { \/\/ %% ==> %\n+                    sb.append('%');\n+                    i++;\n+                } else if (nc == 'p') {\n+                    if (pid == null) {\n+                        pid = JVM.getPid();\n+                    }\n+                    sb.append(pid);\n+                    i++;\n+                } else if (nc == 't') {\n+                    if (time == null) {\n+                        time = ValueFormatter.formatDateTime(LocalDateTime.now());\n+                    }\n+                    sb.append(time);\n+                    i++;\n+                } else {\n+                    sb.append('%');\n+                }\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/ArgumentParser.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        String filename = expandFilename(parser.getOption(\"filename\"));\n+        String filename = parser.getOption(\"filename\");\n@@ -233,1 +233,1 @@\n-                                  the specified directory. (STRING, no default value)\n+                                  the specified directory. (FILE, no default value)\n@@ -287,1 +287,1 @@\n-               \"STRING\", false, true, null, false),\n+               \"FILE\", false, true, null, false),\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        String path = expandFilename(parser.getOption(\"filename\"));\n+        String path = parser.getOption(\"filename\");\n@@ -380,1 +380,1 @@\n-                                  directory. (STRING, no default value)\n+                                  directory. (FILE, no default value)\n@@ -504,1 +504,1 @@\n-                \"STRING\", false, true, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+                \"FILE\", false, true, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        String filename = expandFilename(parser.getOption(\"filename\"));\n+        String filename = parser.getOption(\"filename\");\n@@ -83,1 +83,1 @@\n-                           is discarded. (STRING, no default value)\n+                           is discarded. (FILE, no default value)\n@@ -110,1 +110,1 @@\n-                \"STRING\", false, true, null, false)\n+                \"FILE\", false, true, null, false)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListResourceBundle;\n+import java.util.Map;\n@@ -30,0 +34,2 @@\n+import static java.util.stream.Collectors.toMap;\n+import java.util.stream.Stream;\n@@ -34,4 +40,1 @@\n-        if (PLATFORM.containsKey(key)) {\n-            return PLATFORM.getString(key);\n-        }\n-        return SHARED.getString(key);\n+        return BUNDLE.getString(key);\n@@ -40,2 +43,22 @@\n-    private static final ResourceBundle SHARED = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MainResources\");\n+    private static class MultiResourceBundle extends ListResourceBundle {\n+\n+        MultiResourceBundle(ResourceBundle... bundles) {\n+            contents = Stream.of(bundles).map(bundle -> {\n+                return bundle.keySet().stream().map(key -> {\n+                    return Map.entry(key, bundle.getObject(key));\n+                });\n+            }).flatMap(x -> x).collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (o, n) -> {\n+                \/\/ Override old value with the new one\n+                return n;\n+            })).entrySet().stream().map(e -> {\n+                return new Object[]{e.getKey(), e.getValue()};\n+            }).toArray(Object[][]::new);\n+        }\n+\n+        @Override\n+        protected Object[][] getContents() {\n+            return contents;\n+        }\n+\n+        private final Object[][] contents;\n+    }\n@@ -43,1 +66,1 @@\n-    private static final ResourceBundle PLATFORM;\n+    private static final MultiResourceBundle BUNDLE;\n@@ -46,0 +69,4 @@\n+        List<String> bundleNames = new ArrayList<>();\n+\n+        bundleNames.add(\"jdk.jpackage.internal.resources.MainResources\");\n+\n@@ -47,2 +74,1 @@\n-            PLATFORM = ResourceBundle.getBundle(\n-                    \"jdk.jpackage.internal.resources.LinuxResources\");\n+            bundleNames.add(\"jdk.jpackage.internal.resources.LinuxResources\");\n@@ -50,2 +76,2 @@\n-            PLATFORM = ResourceBundle.getBundle(\n-                    \"jdk.jpackage.internal.resources.WinResources\");\n+            bundleNames.add(\"jdk.jpackage.internal.resources.WinResources\");\n+            bundleNames.add(\"jdk.jpackage.internal.resources.WinResourcesNoL10N\");\n@@ -53,2 +79,1 @@\n-            PLATFORM = ResourceBundle.getBundle(\n-                    \"jdk.jpackage.internal.resources.MacResources\");\n+            bundleNames.add(\"jdk.jpackage.internal.resources.MacResources\");\n@@ -58,0 +83,3 @@\n+\n+        BUNDLE = new MultiResourceBundle(bundleNames.stream().map(ResourceBundle::getBundle)\n+                .toArray(ResourceBundle[]::new));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/I18N.java","additions":42,"deletions":14,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-resource.wxl-file-name=MsiInstallerStrings_en.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+#\n+\n+\n+resource.wxl-file-name=MsiInstallerStrings_en.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResourcesNoL10N.properties","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+#\n+\n+\n+resource.wxl-file-name=MsiInstallerStrings_de.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResourcesNoL10N_de.properties","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+#\n+\n+\n+resource.wxl-file-name=MsiInstallerStrings_ja.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResourcesNoL10N_ja.properties","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+#\n+\n+\n+resource.wxl-file-name=MsiInstallerStrings_zh_CN.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResourcesNoL10N_zh_CN.properties","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -38,1 +38,0 @@\n-resource.wxl-file-name=MsiInstallerStrings_de.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-resource.wxl-file-name=MsiInstallerStrings_ja.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-resource.wxl-file-name=MsiInstallerStrings_zh_CN.wxl\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorage.inline.hpp\"\n@@ -29,0 +29,3 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -35,0 +38,3 @@\n+using ::testing::HasSubstr;\n+using ::testing::Not;\n+\n@@ -86,0 +92,2 @@\n+\n+  class VM_PrintAtSafepoint;\n@@ -99,0 +107,74 @@\n+\n+class OopStorageSetTest::VM_PrintAtSafepoint : public VM_GTestExecuteAtSafepoint {\n+private:\n+  class PrintContainingClosure : public Closure {\n+    public:\n+      void do_oop(oop* addr) {\n+        \/\/ Direct slot hit.\n+        {\n+          stringStream ss;\n+          bool printed = OopStorageSet::print_containing(addr, &ss);\n+          ASSERT_TRUE(printed);\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"is a pointer\"));\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"into block\"));\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"in oop storage\"));\n+          ASSERT_THAT(ss.freeze(), Not(HasSubstr(\"(unaligned)\")));\n+        }\n+\n+        \/\/ Unaligned pointer to adjacent slot, should still be in oop storage range.\n+        {\n+          char* unaligned_addr = (char*)addr + 1;\n+          stringStream ss;\n+          bool printed = OopStorageSet::print_containing(unaligned_addr, &ss);\n+          ASSERT_TRUE(printed);\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"is a pointer\"));\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"into block\"));\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"in oop storage\"));\n+          ASSERT_THAT(ss.freeze(), HasSubstr(\"(unaligned)\"));\n+        }\n+      }\n+  };\n+\n+public:\n+  void doit() {\n+    PrintContainingClosure cl;\n+    for (OopStorage* storage : OopStorageSet::Range<OopStorageSet::Id>()) {\n+      storage->oops_do(&cl);\n+    }\n+  }\n+};\n+\n+TEST_VM_F(OopStorageSetTest, print_containing) {\n+  \/\/ nullptrs print nothing\n+  {\n+    stringStream ss;\n+    bool printed = OopStorageSet::print_containing(nullptr, &ss);\n+    ASSERT_FALSE(printed);\n+    EXPECT_STREQ(\"\", ss.freeze());\n+  }\n+\n+  \/\/ Goofy values print nothing: unaligned out of storage pointer.\n+  {\n+    stringStream ss;\n+    bool printed = OopStorageSet::print_containing((char*)0x1, &ss);\n+    ASSERT_FALSE(printed);\n+    EXPECT_STREQ(\"\", ss.freeze());\n+  }\n+\n+  \/\/ Goofy values print nothing: aligned out of storage pointer.\n+  {\n+    stringStream ss;\n+    bool printed = OopStorageSet::print_containing((char*)alignof(oop), &ss);\n+    ASSERT_FALSE(printed);\n+    EXPECT_STREQ(\"\", ss.freeze());\n+  }\n+\n+  \/\/ All slot addresses should print well.\n+  {\n+    VM_PrintAtSafepoint op;\n+    {\n+      ThreadInVMfromNative invm(JavaThread::current());\n+      VMThread::execute(&op);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorageSet.cpp","additions":83,"deletions":1,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+applications\/ctw\/modules\/java_base.java 8340683 generic-all\n@@ -118,1 +119,0 @@\n-runtime\/Thread\/TestAlwaysPreTouchStacks.java 8335167 macosx-aarch64\n@@ -139,0 +139,2 @@\n+serviceability\/dcmd\/vm\/SystemDumpMapTest.java 8340401 windows-all\n+serviceability\/dcmd\/vm\/SystemMapTest.java 8340401 windows-all\n@@ -175,0 +177,1 @@\n+vmTestbase\/gc\/memory\/Nio\/Nio.java 8340728 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8252219 8256535 8317349\n+ * @bug 8252219 8256535 8317349 8319879 8335334\n@@ -51,0 +51,8 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ *      compiler.arguments.TestStressOptions\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining -XX:StressSeed=42\n+ *      compiler.arguments.TestStressOptions\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressUnstableIfTraps\n+ *      compiler.arguments.TestStressOptions\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressUnstableIfTraps -XX:StressSeed=42\n+ *      compiler.arguments.TestStressOptions\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestStressOptions.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPrunedExHandler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test c1 to record type profile with CHA optimization\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver compiler.cha.TypeProfileFinalMethod\n+ *\/\n+package compiler.cha;\n+\n+import java.io.File;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TypeProfileFinalMethod {\n+    public static void main(String[] args) throws Exception {\n+       ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+           \"-Xbootclasspath\/a:.\",\n+           \"-Xbatch\", \"-XX:-UseOnStackReplacement\",\n+           \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+WhiteBoxAPI\",\n+           \"-XX:Tier3InvocationThreshold=200\", \"-XX:Tier4InvocationThreshold=5000\",\n+           Launcher.class.getName());\n+       OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+       System.out.println(\"debug output\");\n+       System.out.println(output.getOutput());\n+       System.out.println(\"debug output end\");\n+       output.shouldHaveExitValue(0);\n+       output.shouldNotContain(\"failed to inline: virtual call\");\n+       Pattern pattern = Pattern.compile(\"Child1::m.*  inline \");\n+       Matcher matcher = pattern.matcher(output.getOutput());\n+       int matchCnt = 0;\n+       while (matcher.find()) {\n+         matchCnt++;\n+       }\n+       Asserts.assertEquals(matchCnt, 2);  \/\/ inline Child1::m() twice\n+    }\n+\n+    static class Launcher {\n+        public static void main(String[] args) throws Exception {\n+            addCompilerDirectives();\n+            int cnt = 5300;\n+            \/\/ warmup test1 to be compiled with c1 and c2\n+            \/\/ and only compile test2 with c1\n+            for (int i = 0; i < cnt; i++) {\n+                test1(i);\n+            }\n+            for (int i = 0; i < cnt; i++) {\n+                test2(i);\n+            }\n+            Parent c = new TypeProfileFinalMethod.Child2();\n+            System.out.println(\"======== break CHA\");\n+            \/\/ trigger c2 to compile test2\n+            for (int i = 0; i < 100; i++) {\n+                test2(i);\n+            }\n+        }\n+\n+        static void addCompilerDirectives() {\n+            WhiteBox WB = WhiteBox.getWhiteBox();\n+            \/\/ do not inline getInstance() for test1() and test2()\n+            String directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test1\\\"],\" +\n+                \"inline:[\\\"-\" + Launcher.class.getName()+\"::getInstance()\\\"] }]\";\n+            WB.addCompilerDirective(directive);\n+\n+            directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test2\\\"],\" +\n+                \"inline:[\\\"-\" + Launcher.class.getName()+\"::getInstance()\\\"] }]\";\n+            WB.addCompilerDirective(directive);\n+\n+            \/\/ do not inline test1() for test2() in c1 compilation\n+            directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test2\\\"],\" +\n+                \"c1: { inline:[\\\"-\" + Launcher.class.getName()+\"::test1()\\\"] } }]\";\n+            WB.addCompilerDirective(directive);\n+\n+            \/\/ print inline tree for checking\n+            directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test2\\\"],\" +\n+                \"c2: { PrintInlining: true } }]\";\n+            WB.addCompilerDirective(directive);\n+        }\n+\n+        static int test1(int i) {\n+            int ret = 0;\n+            Parent ix = getInstance();\n+            if (i<200) {\n+                return ix.m();\n+            }\n+            for (int j = 0; j < 50; j++) {\n+                ret += ix.m();     \/\/ the callsite we are interesting\n+            }\n+            return ret;\n+        }\n+\n+        static int test2(int i) {\n+            return test1(i);\n+        }\n+\n+        static Parent getInstance() {\n+            return new TypeProfileFinalMethod.Child1();\n+        }\n+    }\n+\n+    static abstract class Parent {\n+        abstract public int m();\n+    }\n+\n+    final static class Child1 extends Parent {\n+        public int m() {\n+            return 1;\n+        }\n+    }\n+\n+    final static class Child2 extends Parent {\n+        public int m() {\n+            return 2;\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/TypeProfileFinalMethod.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/MaterializeVirtualObjectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestExplicitRangeChecks.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires !vm.graal.enabled\n+ * @requires !vm.graal.enabled & (vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps)\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestUnstableIfTrap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-        testMismatched(Test::testZ_J, Test::changeZ);\n+        testMismatched(Test::testZ_J, Test::changeZ, false, ARRAY_BOOLEAN_BASE_OFFSET == ARRAY_LONG_BASE_OFFSET);\n@@ -249,1 +249,1 @@\n-        testMismatched(Test::testZ_D, Test::changeZ);\n+        testMismatched(Test::testZ_D, Test::changeZ, false, ARRAY_BOOLEAN_BASE_OFFSET == ARRAY_DOUBLE_BASE_OFFSET);\n@@ -257,1 +257,1 @@\n-        testMismatched(Test::testB_J, Test::changeB);\n+        testMismatched(Test::testB_J, Test::changeB, false, ARRAY_BYTE_BASE_OFFSET == ARRAY_LONG_BASE_OFFSET);\n@@ -259,1 +259,1 @@\n-        testMismatched(Test::testB_D, Test::changeB);\n+        testMismatched(Test::testB_D, Test::changeB, false, ARRAY_BYTE_BASE_OFFSET == ARRAY_DOUBLE_BASE_OFFSET);\n@@ -267,1 +267,1 @@\n-        testMismatched(Test::testS_J, Test::changeS);\n+        testMismatched(Test::testS_J, Test::changeS, false, ARRAY_SHORT_BASE_OFFSET == ARRAY_LONG_BASE_OFFSET);\n@@ -269,1 +269,1 @@\n-        testMismatched(Test::testS_D, Test::changeS);\n+        testMismatched(Test::testS_D, Test::changeS, false, ARRAY_SHORT_BASE_OFFSET == ARRAY_DOUBLE_BASE_OFFSET);\n@@ -277,1 +277,1 @@\n-        testMismatched(Test::testC_J, Test::changeC);\n+        testMismatched(Test::testC_J, Test::changeC, false, ARRAY_CHAR_BASE_OFFSET == ARRAY_LONG_BASE_OFFSET);\n@@ -279,1 +279,1 @@\n-        testMismatched(Test::testC_D, Test::changeC);\n+        testMismatched(Test::testC_D, Test::changeC, false, ARRAY_CHAR_BASE_OFFSET == ARRAY_DOUBLE_BASE_OFFSET);\n@@ -287,1 +287,1 @@\n-        testMismatched(Test::testI_J, Test::changeI);\n+        testMismatched(Test::testI_J, Test::changeI, false, ARRAY_INT_BASE_OFFSET == ARRAY_LONG_BASE_OFFSET);\n@@ -289,1 +289,1 @@\n-        testMismatched(Test::testI_D, Test::changeI);\n+        testMismatched(Test::testI_D, Test::changeI, false, ARRAY_INT_BASE_OFFSET == ARRAY_DOUBLE_BASE_OFFSET);\n@@ -307,1 +307,1 @@\n-        testMismatched(Test::testF_J, Test::changeF);\n+        testMismatched(Test::testF_J, Test::changeF, false, ARRAY_FLOAT_BASE_OFFSET == ARRAY_LONG_BASE_OFFSET);\n@@ -309,1 +309,1 @@\n-        testMismatched(Test::testF_D, Test::changeF);\n+        testMismatched(Test::testF_D, Test::changeF, false, ARRAY_FLOAT_BASE_OFFSET == ARRAY_DOUBLE_BASE_OFFSET);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeGetStableArrayElement.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeFramesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,24 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/TEST.properties","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires !vm.opt.final.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestAllocateHeapAt.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires !vm.opt.final.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestAllocateHeapAt.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @test id=preTouch\n+ * @test id=preTouchTest\n@@ -48,10 +48,0 @@\n-\/*\n- * @test id=noPreTouch\n- * @summary Test that only touched committed memory is reported as thread stack usage.\n- * @requires os.family != \"aix\"\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver TestAlwaysPreTouchStacks noPreTouch\n- *\/\n-\n@@ -61,1 +51,1 @@\n-    final static int MB = 1024*1024;\n+    final static int MB = 1024 * 1024;\n@@ -65,0 +55,3 @@\n+    static long min_stack_usage_with_pretouch = 1 * MB;\n+    static long max_stack_usage_with_pretouch = (long)(0.75 * threadStackSizeMB * MB);\n+\n@@ -82,0 +75,3 @@\n+        \/\/ Let test threads run as daemons to ensure that they are still running and\n+        \/\/ that their stacks are still allocated when the JVM shuts down and the final\n+        \/\/ NMT report is printed.\n@@ -86,0 +82,63 @@\n+    private static long runPreTouchTest(boolean preTouch) throws Exception {\n+      long reserved = 0L, committed = 0L;\n+      ArrayList<String> vmArgs = new ArrayList<>();\n+      Collections.addAll(vmArgs,\n+              \"-XX:+UnlockDiagnosticVMOptions\",\n+              \"-Xmx100M\",\n+              \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\");\n+      if (preTouch){\n+          vmArgs.add(\"-XX:+AlwaysPreTouchStacks\");\n+      }\n+      if (System.getProperty(\"os.name\").contains(\"Linux\")) {\n+          vmArgs.add(\"-XX:-UseMadvPopulateWrite\");\n+      }\n+      Collections.addAll(vmArgs, \"TestAlwaysPreTouchStacks\", \"test\");\n+      ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmArgs);\n+      OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+      output.shouldHaveExitValue(0);\n+\n+      for (int i = 0; i < numThreads; i++) {\n+          output.shouldContain(\"Alive: \" + i);\n+      }\n+\n+      \/\/ If using -XX:+AlwaysPreTouchStacks, we want to see, in the final NMT printout,\n+      \/\/ a committed thread stack size very close to reserved stack size. Like this:\n+      \/\/ -                    Thread (reserved=10332400KB, committed=10284360KB)\n+      \/\/                      (thread #10021)\n+      \/\/                      (stack: reserved=10301560KB, committed=10253520KB)   <<<<\n+      \/\/\n+      \/\/ ... without -XX:+AlwaysPreTouchStacks, the committed\/reserved ratio for thread stacks should be\n+      \/\/ a lot lower, e.g.:\n+      \/\/ -                    Thread (reserved=10332400KB, committed=331828KB)\n+      \/\/                      (thread #10021)\n+      \/\/                      (stack: reserved=10301560KB, committed=300988KB)  <<<\n+\n+      output.shouldMatch(\"- *Thread.*reserved.*committed\");\n+      output.reportDiagnosticSummary();\n+      Pattern pat = Pattern.compile(\".*stack: reserved=(\\\\d+), committed=(\\\\d+).*\");\n+      boolean foundLine = false;\n+      for (String line : output.asLines()) {\n+        Matcher m = pat.matcher(line);\n+        if (m.matches()) {\n+          reserved = Long.parseLong(m.group(1));\n+          committed = Long.parseLong(m.group(2));\n+          System.out.println(\">>>>> \" + line + \": \" + reserved + \" - \" + committed);\n+          \/\/ Added sanity tests: we expect our test threads to be still alive when NMT prints its final\n+          \/\/ report, so their stacks should dominate the NMT-reported total stack size.\n+          long max_reserved = memoryCeilingMB * 3 * MB;\n+          long min_reserved = memoryCeilingMB * MB;\n+          if (reserved >= max_reserved || reserved < min_reserved) {\n+              throw new RuntimeException(\"Total reserved stack sizes outside of our expectations (\" + reserved +\n+                                          \", expected \" + min_reserved + \"..\" + max_reserved + \")\");\n+          }\n+          foundLine = true;\n+          break;\n+        }\n+      }\n+      if (!foundLine) {\n+          throw new RuntimeException(\"Did not find expected NMT output\");\n+      }\n+      return committed;\n+    }\n+\n@@ -106,77 +165,17 @@\n-            boolean preTouch;\n-            if (args.length == 1 && args[0].equals(\"noPreTouch\")){\n-                preTouch = false;\n-            } else if (args.length == 1 && args[0].equals(\"preTouch\")){\n-                preTouch = true;\n-            } else {\n-                throw new RuntimeException(\"Invalid test input. Must be 'preTouch' or 'noPreTouch'.\");\n-            }\n-            ArrayList<String> vmArgs = new ArrayList<>();\n-            Collections.addAll(vmArgs,\n-                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                    \"-Xmx100M\",\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\");\n-            if (preTouch){\n-                vmArgs.add(\"-XX:+AlwaysPreTouchStacks\");\n-            }\n-            if (System.getProperty(\"os.name\").contains(\"Linux\")) {\n-                vmArgs.add(\"-XX:-UseMadvPopulateWrite\");\n-            }\n-            Collections.addAll(vmArgs, \"TestAlwaysPreTouchStacks\", \"test\");\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmArgs);\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.reportDiagnosticSummary();\n-\n-            output.shouldHaveExitValue(0);\n-\n-            for (int i = 0; i < numThreads; i++) {\n-                output.shouldContain(\"Alive: \" + i);\n-            }\n-\n-            \/\/ If using -XX:+AlwaysPreTouchStacks, we want to see, in the final NMT printout,\n-            \/\/ a committed thread stack size very close to reserved stack size. Like this:\n-            \/\/ -                    Thread (reserved=10332400KB, committed=10284360KB)\n-            \/\/                      (thread #10021)\n-            \/\/                      (stack: reserved=10301560KB, committed=10253520KB)   <<<<\n-            \/\/\n-            \/\/ ... without -XX:+AlwaysPreTouchStacks, the committed\/reserved ratio for thread stacks should be\n-            \/\/ a lot lower, e.g.:\n-            \/\/ -                    Thread (reserved=10332400KB, committed=331828KB)\n-            \/\/                      (thread #10021)\n-            \/\/                      (stack: reserved=10301560KB, committed=300988KB)  <<<\n-\n-            output.shouldMatch(\"- *Thread.*reserved.*committed\");\n-            Pattern pat = Pattern.compile(\".*stack: reserved=(\\\\d+), committed=(\\\\d+).*\");\n-            boolean foundLine = false;\n-            for (String line : output.asLines()) {\n-                Matcher m = pat.matcher(line);\n-                if (m.matches()) {\n-                    long reserved = Long.parseLong(m.group(1));\n-                    long committed = Long.parseLong(m.group(2));\n-                    System.out.println(\">>>>> \" + line + \": \" + reserved + \" - \" + committed);\n-                    \/\/ This is a bit fuzzy: even with PreTouch we don't commit the full range of what NMT counts\n-                    \/\/ as thread stack. But without pre-touching, the thread stacks would be committed to about 1\/5th\n-                    \/\/ of their reserved size. Requiring them to be committed for over 3\/4th shows that pretouch is\n-                    \/\/ really working.\n-                    if (preTouch && (double)committed < ((double)reserved * 0.75)) {\n-                        throw new RuntimeException(\"Expected a higher ratio between stack committed and reserved.\");\n-                    } else if (!preTouch && (double)committed > ((double)reserved * 0.50)){\n-                        throw new RuntimeException(\"Expected a lower ratio between stack committed and reserved.\");\n-                    }\n-                    \/\/ Added sanity tests: we expect our test threads to be still alive when NMT prints its final\n-                    \/\/ report, so their stacks should dominate the NMT-reported total stack size.\n-                    long max_reserved = memoryCeilingMB * 3 * MB;\n-                    long min_reserved = memoryCeilingMB * MB;\n-                    if (reserved >= max_reserved || reserved < min_reserved) {\n-                        throw new RuntimeException(\"Total reserved stack sizes outside of our expectations (\" + reserved +\n-                                                   \", expected \" + min_reserved + \"..\" + max_reserved + \")\");\n-                    }\n-                    foundLine = true;\n-                    break;\n-                }\n-            }\n-            if (!foundLine) {\n-                throw new RuntimeException(\"Did not find expected NMT output\");\n-            }\n-        }\n-\n+          long pretouch_committed = runPreTouchTest(true);\n+          long no_pretouch_committed = runPreTouchTest(false);\n+          if (pretouch_committed == 0 || no_pretouch_committed == 0) {\n+            throw new RuntimeException(\"Could not run with PreTouch flag.\");\n+          }\n+          long expected_delta = numThreads * (max_stack_usage_with_pretouch - min_stack_usage_with_pretouch);\n+          long actual_delta = pretouch_committed - no_pretouch_committed;\n+          if (pretouch_committed <= (no_pretouch_committed + expected_delta)) {\n+            throw new RuntimeException(\"Expected a higher amount of committed with pretouch stacks\" +\n+                                       \"PreTouch amount: \" + pretouch_committed +\n+                                       \"NoPreTouch amount: \" + (no_pretouch_committed + expected_delta));\n+          }\n+          if (actual_delta < expected_delta) {\n+            throw new RuntimeException(\"Expected a higher delta between stack committed of with and without pretouch.\" +\n+                                       \"Expected: \" + expected_delta + \" Actual: \" + actual_delta);\n+          }\n+      }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":88,"deletions":89,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -109,0 +109,13 @@\n+\n+        \/\/ (5) AOTMode=on\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"--show-version\",\n+            \"-Xlog:cds\",\n+            \"-XX:AOTMode=on\",\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"prod\");\n+        out.shouldContain(\", sharing\");\n+        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Hello World\");\n+        out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/AOTFlags.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -519,0 +519,2 @@\n+com\/sun\/management\/DiagnosticCommandMBean\/DcmdMBeanPermissionsTest.java 8340401 windows-all\n+\n@@ -564,0 +566,2 @@\n+java\/nio\/Buffer\/LimitDirectMemory.java                          8340728 generic-all\n+\n@@ -568,1 +572,1 @@\n-java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8308807 aix-ppc64\n+java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8308807,8144003 aix-ppc64,macosx-all\n@@ -572,0 +576,3 @@\n+java\/nio\/channels\/DatagramChannel\/BasicMulticastTests.java      8144003 macosx-all\n+java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java 8144003 macosx-all\n+java\/nio\/channels\/DatagramChannel\/Promiscuous.java              8144003 macosx-all\n@@ -792,0 +799,1 @@\n+java\/awt\/Focus\/InactiveFocusRace.java 8023263 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 4151949\n+ * @summary Verifies that Components are reshaped to their preferred size\n+ *          when their Container is packed.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual CheckChoiceTest\n+ *\/\n+\n+public class CheckChoiceTest {\n+\n+    private static JComponent componentToFocus;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Verify that the widths of the Choice components are all the same\n+            and that none is the minimum possible size.\n+            (The Choices should be at least as wide as the Frame.)\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .title(\"CheckChoiceTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 3)\n+                .columns(45)\n+                .testUI(CheckChoiceTest::createAndShowUI)\n+                .splitUIBottom(CheckChoiceTest::createComponentToFocus)\n+                .build();\n+\n+        \/\/ focus away from the window with choices\n+        Thread.sleep(300);\n+        SwingUtilities.invokeAndWait(() -> componentToFocus.requestFocus());\n+\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    private static JComponent createComponentToFocus() {\n+        componentToFocus = new JPanel();\n+        return componentToFocus;\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        Frame f = new Frame(\"Check Choice\");\n+        f.setLayout(new BorderLayout());\n+\n+        Choice choice1 = new Choice();\n+        Choice choice2 = new Choice();\n+        Choice choice3 = new Choice();\n+\n+        f.add(choice1, BorderLayout.NORTH);\n+        f.add(choice3, BorderLayout.CENTER);\n+        f.add(choice2, BorderLayout.SOUTH);\n+        f.pack();\n+\n+        choice1.add(\"I am Choice, yes I am : 0\");\n+        choice2.add(\"I am the same, yes I am : 0\");\n+        choice3.add(\"I am the same, yes I am : 0\");\n+\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/CheckChoiceTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import java.awt.FlowLayout;\n+import java.awt.Window;\n+\n+\/*\n+ * @test\n+ * @bug 4288285\n+ * @summary Verifies choice works with many items\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ChoiceBigTest\n+ *\/\n+\n+public class ChoiceBigTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Click the Choice button, press Pass if:\n+\n+            - all looks good.\n+            - if you can select the item 1000\n+\n+            Otherwise press Fail.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ChoiceBigTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 3)\n+                .columns(45)\n+                .testUI(ChoiceBigTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createAndShowUI() {\n+        Frame frame = new Frame(\"Check Choice\");\n+        frame.setLayout(new FlowLayout());\n+        Choice choice = new Choice();\n+        frame.setSize(400, 200);\n+        for (int i = 1; i < 1001; ++i) {\n+            choice.add(\"I am Choice, yes I am : \" + i);\n+        }\n+        frame.add(choice);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceBigTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Window;\n+\n+\/*\n+ * @test\n+ * @bug 4927930\n+ * @summary Verify that the focus is set to the selected item after calling the java.awt.Choice.select() method\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ChoiceFocusTest\n+ *\/\n+\n+public class ChoiceFocusTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1. Use the mouse to select Item 5 in the Choice list.\n+            2. Click on the Choice. Item5 is now selected and highlighted. This is the correct behavior.\n+            3. Select Item 1 in the Choice list.\n+            4. Click the \"choice.select(5)\" button. This causes a call to Choice.select(5). Item 5 is now selected.\n+            5. Click on the Choice.\n+            6. If the cursor and focus are on item 5, the test passes. Otherwise, it fails.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ChoiceFocusTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 3)\n+                .columns(50)\n+                .testUI(ChoiceFocusTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createAndShowUI() {\n+        Panel panel = new Panel();\n+        Choice choice = new Choice();\n+        Button button = new Button(\"choice.select(5);\");\n+\n+        for (int i = 0; i < 10; i++) {\n+            choice.add(String.valueOf(i));\n+        }\n+\n+        button.addActionListener(e -> choice.select(5));\n+\n+        panel.add(button);\n+        panel.add(choice);\n+\n+        Frame frame = new Frame(\"ChoiceFocusTest\");\n+        frame.add(panel);\n+        frame.pack();\n+\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceFocusTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @bug 4075194\n+ * @summary 4075194, Choice may not be displayed at the location requested\n+ * @key headful\n+ *\/\n+\n+public class ChoicePosTest {\n+\n+    private static Robot robot;\n+    private static Frame frame;\n+    private static final int GAP = 10;\n+    private static volatile Choice c1,c2;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(ChoicePosTest::createAndShowGUI);\n+\n+            robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            captureAndTestChoices();\n+        } finally {\n+            EventQueue.invokeAndWait(frame::dispose);\n+        }\n+\n+        System.out.println(\"Passed\");\n+    }\n+\n+    private static void createAndShowGUI() {\n+        frame = new Frame(\"ChoicePosTest\");\n+        Insets insets = frame.getInsets();\n+        frame.setSize( insets.left + 400 + insets.right, insets.top + 400 + insets.bottom );\n+        frame.setBackground(Color.RED);\n+        frame.setLayout(null);\n+        frame.setLocationRelativeTo(null);\n+\n+        c1 = new Choice();\n+        c1.setBackground(Color.GREEN);\n+        frame.add( c1 );\n+        c1.setBounds( 20, 50, 100, 100 );\n+\n+        c2 = new Choice();\n+        c2.setBackground(Color.GREEN);\n+        frame.add(c2);\n+        c2.addItem(\"One\");\n+        c2.addItem(\"Two\");\n+        c2.addItem(\"Three\");\n+        c2.setBounds( 125, 50, 100, 100 );\n+\n+        frame.validate();\n+        frame.setVisible(true);\n+    }\n+\n+    private static void captureAndTestChoices() {\n+        Point c1loc = c1.getLocationOnScreen();\n+        Point c2loc = c2.getLocationOnScreen();\n+\n+        int startX = c1loc.x - GAP;\n+        int startY = c1loc.y - GAP;\n+        int captureWidth = c2loc.x + c2.getWidth() + GAP - startX;\n+        int captureHeight = c2loc.y + c2.getHeight() + GAP - startY;\n+\n+        BufferedImage bi = robot.createScreenCapture(\n+                new Rectangle(startX, startY, captureWidth, captureHeight)\n+        );\n+\n+        int redPix = Color.RED.getRGB();\n+\n+        int lastNonRedCount = 0;\n+\n+        for (int y = 0; y < captureHeight; y++) {\n+            int nonRedCount = 0;\n+            for (int x = 0; x < captureWidth; x++) {\n+                int pix = bi.getRGB(x, y);\n+                if (pix != redPix) {\n+                    nonRedCount++;\n+                }\n+            }\n+\n+            if (nonRedCount > 0 && lastNonRedCount > 0) {\n+                if (lastNonRedCount - nonRedCount > 0) {\n+                    System.err.printf(\n+                            \"Failed at %d, nonRedCount: %d lastNonRedCount: %d\\n\",\n+                            y, nonRedCount, lastNonRedCount\n+                    );\n+\n+                    try {\n+                        ImageIO.write(bi, \"png\", new File(\"choices.png\"));\n+                    } catch (IOException ignored) {\n+                    }\n+\n+                    throw new RuntimeException(\"Choices are not aligned\");\n+                }\n+            }\n+\n+            lastNonRedCount = nonRedCount;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoicePosTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @bug 4134619\n+ * @summary    Tests that the EventDispatchThread doesn't deadlock with\n+ *             user threads which are modifying a Choice component.\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jdk.test.lib.Platform\n+ * @run main\/manual DeadlockTest\n+ *\/\n+\n+public class DeadlockTest extends Thread {\n+\n+    static volatile Choice choice1;\n+    static volatile Choice choice2;\n+    static volatile Choice choice3;\n+    static volatile Frame frame;\n+    static int itemCount = 0;\n+\n+    private static final boolean isWindows = Platform.isWindows();\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Click on the top Choice component and hold the mouse still briefly.\n+            Then, without releasing the mouse button, move the cursor to a menu\n+            item and then again hold the mouse still briefly.\n+            %s\n+            Release the button and repeat this process.\n+\n+            Verify that this does not cause a deadlock\n+            or crash within a reasonable amount of time.\n+            \"\"\".formatted(\n+                isWindows\n+                    ? \"(menu can automatically collapse sometimes, this is ok)\\n\"\n+                    : \"\"\n+\n+    )       ;\n+\n+    public static void main(String[] args) throws Exception {\n+        DeadlockTest deadlockTest = new DeadlockTest();\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .title(\"DeadlockTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(deadlockTest::createAndShowUI)\n+                .build();\n+\n+        deadlockTest.start();\n+\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+   public Frame createAndShowUI() {\n+       frame = new Frame(\"Check Choice\");\n+       frame.setLayout(new BorderLayout());\n+       choice1 = new Choice();\n+       choice2 = new Choice();\n+       choice3 = new Choice();\n+       frame.add(choice1, BorderLayout.NORTH);\n+       frame.add(choice3, BorderLayout.CENTER);\n+       frame.add(choice2, BorderLayout.SOUTH);\n+       frame.pack();\n+       return frame;\n+   }\n+\n+    public void run() {\n+        while (true) {\n+            if (choice1 != null && itemCount < 40) {\n+                choice1.add(\"I am Choice, yes I am : \" + itemCount * itemCount);\n+                choice2.add(\"I am the same, yes I am : \" + itemCount * itemCount);\n+                choice3.add(\"I am the same, yes I am : \" + itemCount * itemCount);\n+                itemCount++;\n+            }\n+            if (itemCount >= 20 && choice1 != null &&\n+                    choice1.getItemCount() > 0) {\n+                choice1.removeAll();\n+                choice2.removeAll();\n+                choice3.removeAll();\n+                itemCount = 0;\n+            }\n+            frame.validate();\n+            try {\n+                Thread.sleep(1000);\n+            } catch (Exception ignored) {}\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/DeadlockTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import java.awt.Window;\n+import java.awt.event.ItemEvent;\n+\n+\/*\n+ * @test\n+ * @bug 6476183\n+ * @summary Drop down of a Choice changed to enabled state has a disabled like appearance\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DisabledList\n+ *\/\n+\n+public class DisabledList {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1) Select the checkbox\n+            2) Open Choice\n+            3) Drag mouse over the scrollbar or drag out it the choice\n+            4) If choice's items become disabled press fail, otherwise pass\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"DisabledList Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 3)\n+                .columns(45)\n+                .testUI(DisabledList::createAndShowUI)\n+                .logArea(4)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createAndShowUI() {\n+        Frame frame = new Frame(\"DisabledList\");\n+        frame.setSize(200, 200);\n+        frame.validate();\n+        Checkbox checkbox = new Checkbox(\"checkbox\");\n+        final Choice choice = new Choice();\n+        choice.setEnabled(false);\n+        for (int i = 0; i < 15; i++) {\n+            choice.addItem(\"Item\" + i);\n+        }\n+        checkbox.addItemListener(event -> {\n+            PassFailJFrame.log(\"CheckBox.itemStateChanged occurred\");\n+            choice.setEnabled(event.getStateChange() == ItemEvent.SELECTED);\n+        });\n+        frame.add(BorderLayout.NORTH, checkbox);\n+        frame.add(BorderLayout.CENTER, choice);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/DisabledList.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+\n+\/*\n+ * @test\n+ * @bug 4293346\n+ * @summary Checks that Choice does update its dimensions on font change\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SetFontTest\n+ *\/\n+\n+public class SetFontTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Choice component used to not update its dimension on font change.\n+            Select one of fonts on the choice pull down list.\n+            Pull down the list after the font change; if items in the list are\n+            shown correctly the test is passed, otherwise it failed.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"SetFontTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(SetFontTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        Frame frame = new Frame(\"SetFontTest\");\n+        Choice choice = new Choice();\n+        frame.setBounds(100, 400, 400, 100);\n+        choice.addItem(\"dummy\");\n+        choice.addItem(\"Set LARGE Font\");\n+        choice.addItem(\"Set small Font\");\n+        choice.addItem(\"addNewItem\");\n+        choice.addItem(\"deleteItem\");\n+\n+        choice.addItemListener(e -> {\n+            if (e.getItem().toString().equals(\"addNewItem\")) {\n+                choice.addItem(\"very very very very long item\");\n+                frame.validate();\n+            } else if (e.getItem().toString().equals(\"deleteItem\")) {\n+                if (choice.getItemCount() > 4) {\n+                    choice.remove(4);\n+                    frame.validate();\n+                }\n+            } else if (e.getItem().toString().equals(\"Set LARGE Font\")) {\n+                choice.setFont(new Font(\"Dialog\", Font.PLAIN, 24));\n+                frame.validate();\n+            } else if (e.getItem().toString().equals(\"Set small Font\")) {\n+                choice.setFont(new Font(\"Dialog\", Font.PLAIN, 10));\n+                frame.validate();\n+            }\n+        });\n+        Panel panel = new Panel();\n+        panel.add(choice);\n+        frame.add(panel, BorderLayout.CENTER);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/SetFontTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key printer\n+ * @bug 6255196\n+ * @summary  Verifies the function of methods edit(java.io.File file) and\n+ *           print(java.io.File file)\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual EditAndPrintTest\n+ *\/\n+\n+import java.awt.Desktop;\n+import java.awt.Desktop.Action;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.JPanel;\n+\n+public class EditAndPrintTest extends JPanel {\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+            This test tries to edit and print a directory, which will expectedly raise IOException.\n+            Then this test would edit and print a .txt file, which should be successful.\n+            After test execution close the editor if it was launched by test.\n+            If you see any EXCEPTION messages in the output press FAIL.\n+            \"\"\";\n+\n+    public EditAndPrintTest() {\n+        if (!Desktop.isDesktopSupported()) {\n+            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n+                    \"current platform. Further testing will not be performed\");\n+            PassFailJFrame.forcePass();\n+        }\n+\n+        Desktop desktop = Desktop.getDesktop();\n+\n+        if (!desktop.isSupported(Action.PRINT) && !desktop.isSupported(Action.EDIT)) {\n+            PassFailJFrame.log(\"Neither EDIT nor PRINT actions are supported. Nothing to test.\");\n+            PassFailJFrame.forcePass();\n+        }\n+\n+        \/*\n+         * Part 1: print or edit a directory, which should throw an IOException.\n+         *\/\n+        File userHome = new File(System.getProperty(\"user.home\"));\n+        try {\n+            if (desktop.isSupported(Action.EDIT)) {\n+                PassFailJFrame.log(\"Trying to edit \" + userHome);\n+                desktop.edit(userHome);\n+                PassFailJFrame.log(\"No exception has been thrown for editing \" +\n+                        \"directory \" + userHome.getPath());\n+                PassFailJFrame.log(\"Test failed.\");\n+            } else {\n+                PassFailJFrame.log(\"Action EDIT is unsupported.\");\n+            }\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"Expected IOException is caught.\");\n+        }\n+\n+        try {\n+            if (desktop.isSupported(Action.PRINT)) {\n+                PassFailJFrame.log(\"Trying to print \" + userHome);\n+                desktop.print(userHome);\n+                PassFailJFrame.log(\"No exception has been thrown for printing \" +\n+                        \"directory \" + userHome.getPath());\n+                PassFailJFrame.log(\"Test failed.\");\n+            } else {\n+                PassFailJFrame.log(\"Action PRINT is unsupported.\\n\");\n+            }\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"Expected IOException is caught.\");\n+        }\n+\n+        \/*\n+         * Part 2: print or edit a normal .txt file, which may succeed if there\n+         * is associated application to print or edit the given file. It fails\n+         * otherwise.\n+         *\/\n+        \/\/ Create a temp .txt file for test.\n+        String testFilePath = System.getProperty(\"java.io.tmpdir\") + File.separator + \"JDIC-test.txt\";\n+        File testFile = null;\n+        try {\n+            PassFailJFrame.log(\"Creating temporary file.\");\n+            testFile = File.createTempFile(\"JDIC-test\", \".txt\", new File(System.getProperty(\"java.io.tmpdir\")));\n+            testFile.deleteOnExit();\n+            FileWriter writer = new FileWriter(testFile);\n+            writer.write(\"This is a temp file used to test print() method of Desktop.\");\n+            writer.flush();\n+            writer.close();\n+        } catch (java.io.IOException ioe){\n+            PassFailJFrame.log(\"EXCEPTION: \" + ioe.getMessage());\n+            PassFailJFrame.forceFail(\"Failed to create temp file for testing.\");\n+        }\n+\n+        try {\n+            if (desktop.isSupported(Action.EDIT)) {\n+                PassFailJFrame.log(\"Try to edit \" + testFile);\n+                desktop.edit(testFile);\n+                PassFailJFrame.log(\"Succeed.\");\n+            }\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+\n+        try {\n+            if (desktop.isSupported(Action.PRINT)) {\n+                PassFailJFrame.log(\"Trying to print \" + testFile);\n+                desktop.print(testFile);\n+                PassFailJFrame.log(\"Succeed.\");\n+            }\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+    }\n+\n+    public static void main(String args[]) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Edit and Print test\")\n+                .splitUI(EditAndPrintTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(60)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Desktop\/EditAndPrintTest\/EditAndPrintTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4524015\n+ * @summary Tests that when user switches between windows using Alt-tab then the appropriate events are generated\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual AltTabEventsTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+import java.awt.event.ActionListener;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+public class AltTabEventsTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+           This test verifies that when user switches between windows using Alt-tab\n+           key combination then appropriate window events are generated. Also, when\n+           user interacts with Menu bar, Popup menu, Choice then no excessive window\n+           event is generated.\n+\n+           After test started you will see Frame('Test for 4524015')-F1 with some\n+           components and Frame('Another frame')-F2 with no components.\n+           1. Make F1 active by clicking on it.\n+           2. Press Alt-tab.\n+           In the messqge dialog area you should see that\n+           WINDOW_DEACTIVATED, WINDOW_LOST_FOCUS event were generated.\n+           If you switched to F2 then also WINDOW_ACTIVATED, WINDOW_GAINED_FOCUS\n+           were generated.\n+           If no events were generated the test FAILED.\n+           Repeat the 2) with different circumstances.\n+\n+           3. Make F1 active by clicking on it.\n+           4. Click on Menu bar\/Button 'popup'\/Choice and select some item from\n+           the list shown. If any of the window events appeared in the output then\n+           the test FAILED.\n+\n+           else the test PASSED.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"AltTabEventsTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 5)\n+                .columns(35)\n+                .testUI(Test::new)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+}\n+\n+\n+class Test extends Frame {\n+    PopupMenu pop;\n+    Frame f;\n+\n+    void println(String messageIn) {\n+        PassFailJFrame.log(messageIn);\n+    }\n+\n+    public Test() {\n+        super(\"Test for 4524015\");\n+        WindowAdapter wa = new WindowAdapter() {\n+                public void windowActivated(WindowEvent e) {\n+                    println(e.toString());\n+                }\n+                public void windowDeactivated(WindowEvent e) {\n+                    println(e.toString());\n+                }\n+                public void windowGainedFocus(WindowEvent e) {\n+                    println(e.toString());\n+                }\n+                public void windowLostFocus(WindowEvent e) {\n+                    println(e.toString());\n+                }\n+            };\n+        addWindowListener(wa);\n+        addWindowFocusListener(wa);\n+\n+        f = new Frame(\"Another frame\");\n+        f.addWindowListener(wa);\n+        f.addWindowFocusListener(wa);\n+        f.setBounds(800, 300, 300, 100);\n+        f.setVisible(true);\n+\n+        setLayout(new FlowLayout());\n+        Button b = new Button(\"popup\");\n+        add(b);\n+        b.addActionListener(new ActionListener() {\n+                public void actionPerformed(ActionEvent e) {\n+                    pop.show((Component)e.getSource(), 10, 10);\n+                }\n+            });\n+        Choice cho = new Choice();\n+        add(cho);\n+        cho.addItem(\"1\");\n+        cho.addItem(\"2\");\n+        cho.addItem(\"3\");\n+\n+        MenuBar bar = new MenuBar();\n+        Menu menu = new Menu(\"menu\");\n+        MenuItem item = new MenuItem(\"first\");\n+        menu.add(item);\n+        item = new MenuItem(\"second\");\n+        menu.add(item);\n+        bar.add(menu);\n+        setMenuBar(bar);\n+\n+        pop = new PopupMenu();\n+        pop.add(\"1\");\n+        pop.add(\"@\");\n+        add(pop);\n+        setSize(300, 100);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/AltTabEventsTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4982943\n+ * @key headful\n+ * @summary focus lost in text fields or text areas, unable to enter characters from keyboard\n+ * @run main ComponentLostFocusTest\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+public class ComponentLostFocusTest {\n+\n+    static Frame frame;\n+    static TextField tf;\n+    static Robot r;\n+    static Dialog dialog = null;\n+    static volatile boolean passed;\n+    static volatile Point loc;\n+    static volatile int width;\n+    static volatile int top;\n+\n+    private static void createTestUI() {\n+\n+        dialog = new Dialog(frame, \"Dialog\", true);\n+\n+        frame = new Frame(\"ComponentLostFocusTest Frame\");\n+        frame.setLayout(new FlowLayout());\n+        frame.addWindowFocusListener(new WindowAdapter() {\n+            public void windowGainedFocus(WindowEvent e) {\n+                System.out.println(\"Frame gained focus: \"+e);\n+            }\n+        });\n+        tf = new TextField(\"Text Field\");\n+        frame.add(tf);\n+        frame.setSize(400,300);\n+        frame.setVisible(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.validate();\n+    }\n+\n+    public static void doTest() {\n+        System.out.println(\"dialog.setVisible.... \");\n+        new Thread(new Runnable() {\n+            public void run() {\n+                dialog.setVisible(true);\n+            }\n+        }).start();\n+\n+        \/\/ The bug is that this construction leads to the redundant xRequestFocus\n+        \/\/ By the way, the requestFocusInWindow() works fine before the fix\n+        System.out.println(\"requesting.... \");\n+        frame.requestFocus();\n+\n+        r.delay(1000);\n+\n+        \/\/ Returning the focus to the initial frame will work correctly after the fix\n+        System.out.println(\"disposing.... \");\n+        dialog.dispose();\n+\n+        r.delay(1000);\n+\n+        \/\/ We want to track the GAIN_FOCUS from this time\n+        tf.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent e) {\n+                System.out.println(\"TextField gained focus: \" + e);\n+                passed = true;\n+            }\n+        });\n+\n+    }\n+\n+    private static void doRequestFocusToTextField() {\n+        \/\/ do activation using press title\n+        r.mouseMove(loc.x + width \/ 2, loc.y + top \/ 2);\n+        r.waitForIdle();\n+        r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        r.waitForIdle();\n+\n+        \/\/ request focus to the text field\n+        tf.requestFocus();\n+    }\n+\n+    public static final void main(String args[]) throws Exception {\n+        r = new Robot();\n+        r.setAutoDelay(100);\n+\n+        EventQueue.invokeAndWait(() -> createTestUI());\n+        r.waitForIdle();\n+        r.delay(1000);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                doTest();\n+                loc = frame.getLocationOnScreen();\n+                width = frame.getWidth();\n+                top = frame.getInsets().top;\n+            });\n+            doRequestFocusToTextField();\n+\n+            System.out.println(\"Focused window: \" +\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                                     getFocusedWindow());\n+            System.out.println(\"Focus owner: \" +\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                                     getFocusOwner());\n+\n+            if (!passed) {\n+                throw new RuntimeException(\"TextField got no focus! Test failed.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/ComponentLostFocusTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4700276\n+ * @summary Peers process KeyEvents before KeyEventPostProcessors\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ConsumedKeyEventTest\n+*\/\n+\n+import java.awt.Canvas;\n+import java.awt.Component;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.KeyEventPostProcessor;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class ConsumedKeyEventTest implements KeyEventPostProcessor {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This is a Windows-only test.\n+            When the test starts, you will see a Frame with two components in it,\n+            components look like colored rectangles, one of them is lightweight, one is heavyweight.\n+            Do the following:\n+            1. Click the mouse on the left component.\n+               If it isn't yellow after the click (that means it doesn't have focus), the test fails.\n+            2. Press and release ALT key.\n+               In the output window, the text should appear stating that those key events were consumed.\n+               If no output appears, the test fails.\n+            3. Press space bar. If system menu drops down, the test fails.\n+            4. Click the right rectangle.\n+               It should become red after the click. If it doesn't, it means that it didn't get the focus, and the test fails.\n+            5. Repeat steps 2. and 3.\n+            6. If the test didn't fail on any of the previous steps, the test passes.\"\"\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ConsumedKeyEventTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 5)\n+                .columns(35)\n+                .testUI(ConsumedKeyEventTest::createTestUI)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+            addKeyEventPostProcessor((e) -> {\n+                System.out.println(\"postProcessor(\" + e + \")\");\n+                \/\/ consumes all ALT-events\n+                if (e.getKeyCode() == KeyEvent.VK_ALT) {\n+                    println(\"consumed \" + e);\n+                    e.consume();\n+                    return true;\n+                }\n+                return false;\n+        });\n+        FocusRequestor requestor = new FocusRequestor();\n+        Frame frame = new Frame(\"Main Frame\");\n+        frame.setLayout(new FlowLayout());\n+\n+        Canvas canvas = new CustomCanvas();\n+        canvas.addMouseListener(requestor);\n+        frame.add(canvas);\n+        canvas.requestFocus();\n+\n+        Component lwComp = new LWComponent();\n+        lwComp.addMouseListener(requestor);\n+        frame.add(lwComp);\n+\n+        frame.pack();\n+\n+        return frame;\n+    }\n+\n+    public boolean postProcessKeyEvent(KeyEvent e) {\n+        System.out.println(\"postProcessor(\" + e + \")\");\n+        \/\/ consumes all ALT-events\n+        if (e.getKeyCode() == KeyEvent.VK_ALT) {\n+            println(\"consumed \" + e);\n+            e.consume();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    static void println(String messageIn) {\n+        PassFailJFrame.log(messageIn);\n+    }\n+}\/\/ class ConsumedKeyEventTest\n+\n+class CustomCanvas extends Canvas {\n+    CustomCanvas() {\n+        super();\n+        setName(\"HWComponent\");\n+        setSize(100, 100);\n+        addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                repaint();\n+            }\n+\n+            public void focusLost(FocusEvent fe) {\n+                repaint();\n+            }\n+        });\n+    }\n+\n+    public void paint(Graphics g) {\n+        if (isFocusOwner()) {\n+            g.setColor(Color.YELLOW);\n+        } else {\n+            g.setColor(Color.GREEN);\n+        }\n+        g.fillRect(0, 0, 100, 100);\n+    }\n+\n+}\n+\n+class LWComponent extends Component {\n+    LWComponent() {\n+        super();\n+        setName(\"LWComponent\");\n+        addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                repaint();\n+            }\n+\n+            public void focusLost(FocusEvent fe) {\n+                repaint();\n+            }\n+        });\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(100, 100);\n+    }\n+\n+    public void paint(Graphics g) {\n+        if (isFocusOwner()) {\n+            g.setColor(Color.RED);\n+        } else {\n+            g.setColor(Color.BLACK);\n+        }\n+        g.fillRect(0, 0, 100, 100);\n+    }\n+\n+}\n+\n+class FocusRequestor extends MouseAdapter {\n+    static int counter = 0;\n+    public void mouseClicked(MouseEvent me) {\n+        System.out.println(\"mouseClicked on \" + me.getComponent().getName());\n+    }\n+    public void mousePressed(MouseEvent me) {\n+        System.out.println(\"mousePressed on \" + me.getComponent().getName());\n+        me.getComponent().requestFocus();\n+    }\n+    public void mouseReleased(MouseEvent me) {\n+        System.out.println(\"mouseReleased on \" + me.getComponent().getName());\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/ConsumedKeyEventTest.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4380809\n+ * @summary Focus disappears after deiconifying frame\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DeiconifyTest\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+\n+public class DeiconifyTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         1. Activate frame \\\"Main frame\\\"\n+         be sure that button has focus\n+         2. Minimize frame and then restore it.\n+         If the button has focus then test passed, else failed\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"DeiconifyTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(DeiconifyTest::createTestUI)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI()   {\n+        Frame frame = new Frame(\"Main frame\");\n+        Button button = new Button(\"button\");\n+        button.addFocusListener(new FocusListener() {\n+              public void focusGained(FocusEvent fe) {\n+                  println(\"focus gained\");\n+              }\n+              public void focusLost(FocusEvent fe) {\n+                  println(\"focus lost\");\n+              }\n+          });\n+        frame.add(button);\n+        frame.setSize(300, 100);\n+\n+        return frame;\n+    }\n+\n+    static void println(String messageIn) {\n+        PassFailJFrame.log(messageIn);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/DeiconifyTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4464723\n+ * @summary Tests simple KeyAdapter \/ KeyListener on an empty, focusable window\n+ * @key headful\n+ * @run main EmptyWindowKeyTest\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Frame;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.Robot;\n+\n+public class EmptyWindowKeyTest {\n+\n+    static volatile boolean passed1, passed2;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        MainFrame mainFrame = new MainFrame();\n+        mainFrame.setSize(50,50);\n+        mainFrame.addKeyListener(new KeyboardTracker());\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+        robot.keyPress(KeyEvent.VK_A);\n+        robot.keyRelease(KeyEvent.VK_A);\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+        if (!passed1 || !passed2) {\n+            throw new RuntimeException(\"KeyPress\/keyRelease not seen,\" +\n+                       \"passed1 \" + passed1 + \" passed2 \" + passed2);\n+        }\n+    }\n+\n+    static public class KeyboardTracker extends KeyAdapter {\n+        public KeyboardTracker() { }\n+        public void keyTyped(KeyEvent e) {}\n+\n+        public void keyPressed(KeyEvent e) {\n+            if (e.getKeyText(e.getKeyCode()).equals(\"A\")) {\n+                passed1 = true;\n+            }\n+        }\n+        public void keyReleased(KeyEvent e) {\n+            if (e.getKeyText(e.getKeyCode()).equals(\"A\")) {\n+                passed2 = true;\n+            }\n+        }\n+    }\n+\n+    static public class MainFrame extends Frame {\n+\n+        public MainFrame() {\n+            super();\n+            enableEvents(AWTEvent.KEY_EVENT_MASK);\n+            setVisible(true);\n+        }\n+\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/EmptyWindowKeyTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4128659\n+ * @summary Tests whether a focus request will work on a focus lost event.\n+ * @key headful\n+ * @run main FocusKeepTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+\n+public class FocusKeepTest {\n+\n+    static JFrame frame;\n+    static JTextField tf;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createTestUI());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_TAB);\n+            robot.keyRelease(KeyEvent.VK_TAB);\n+            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() instanceof JTextField tf1) {\n+                if (!tf1.getText().equals(\"TextField 1\")) {\n+                    throw new RuntimeException(\"Focus on wrong textfield\");\n+                }\n+            } else {\n+                throw new RuntimeException(\"Focus not on correct component\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createTestUI() {\n+        frame = new JFrame(\"FocusKeepTest\");\n+        tf = new JTextField(\"TextField 1\");\n+        tf.addFocusListener(new MyFocusAdapter(\"TextField 1\"));\n+        frame.add(tf, BorderLayout.NORTH);\n+\n+        tf = new JTextField(\"TextField 2\");\n+        tf.addFocusListener(new MyFocusAdapter(\"TextField 2\"));\n+        frame.add(tf, BorderLayout.SOUTH);\n+\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    static class MyFocusAdapter extends FocusAdapter {\n+        private String myName;\n+\n+        public MyFocusAdapter (String name) {\n+            myName = name;\n+        }\n+\n+        public void focusLost (FocusEvent e) {\n+            if (myName.equals (\"TextField 1\")) {\n+                e.getComponent().requestFocus ();\n+            }\n+        }\n+\n+        public void focusGained (FocusEvent e) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/FocusKeepTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 4157017\n+ * @summary Checks whether focus can be traversed when component not visible\n+           within parent container.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual HiddenTraversalTest\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+\n+public class HiddenTraversalTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         Examine the Frame. If six buttons are visible, resize the frame\n+         so that only four are visible. If fewer than six buttons are\n+         visible, do nothing.\\n\n+         Now, repeatedly press the tab key. Focus should cycle through the\n+         visible and invisible buttons. If after six presses of the tab\n+         button 'Button 0' has focus, the test passes. If focus is instead\n+         stuck at 'Button 3', the test fails.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"HiddenTraversalTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(HiddenTraversalTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame f = new Frame(\"Focus test\");\n+        Panel p = new Panel(new FlowLayout());\n+        for (int i = 0; i < 6; i++) {\n+            p.add(new Button(\"Button \" + i));\n+        }\n+        f.add(p);\n+        f.setSize(200, 100);\n+        return f;\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/HiddenTraversalTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4697451\n+ * @summary Test that there is no race between focus component in inactive window and window activation\n+ * @key headful\n+ * @run main InactiveFocusRace\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.InputEvent;\n+\n+public class InactiveFocusRace {\n+\n+    static Frame activeFrame, inactiveFrame;\n+    Button activeButton, inactiveButton1, inactiveButton2;\n+    Semaphore sema;\n+    final static int TIMEOUT = 10000;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            InactiveFocusRace test = new InactiveFocusRace();\n+            test.init();\n+            test.start();\n+        } finally {\n+            if (activeFrame != null) {\n+                activeFrame.dispose();\n+            }\n+            if (inactiveFrame != null) {\n+                inactiveFrame.dispose();\n+            }\n+        }\n+    }\n+\n+    public void init() {\n+        activeButton = new Button(\"active button\");\n+        inactiveButton1 = new Button(\"inactive button1\");\n+        inactiveButton2 = new Button(\"inactive button2\");\n+        activeFrame = new Frame(\"Active frame\");\n+        inactiveFrame = new Frame(\"Inactive frame\");\n+        inactiveFrame.setLayout(new FlowLayout());\n+        activeFrame.add(activeButton);\n+        inactiveFrame.add(inactiveButton1);\n+        inactiveFrame.add(inactiveButton2);\n+        activeFrame.pack();\n+        activeFrame.setLocation(300, 10);\n+        inactiveFrame.pack();\n+        inactiveFrame.setLocation(300, 300);\n+        sema = new Semaphore();\n+\n+        inactiveButton1.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent e) {\n+                System.err.println(\"Button 1 got focus\");\n+            }\n+        });\n+        inactiveButton2.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent e) {\n+                System.err.println(\"Button2 got focus\");\n+                sema.raise();\n+            }\n+        });\n+        activeFrame.addWindowListener(new WindowAdapter() {\n+            public void windowActivated(WindowEvent e) {\n+                System.err.println(\"Window activated\");\n+                sema.raise();\n+            }\n+        });\n+    }\n+\n+    public void start() {\n+        Robot robot = null;\n+        try {\n+            robot = new Robot();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to create robot\");\n+        }\n+\n+        inactiveFrame.setVisible(true);\n+        activeFrame.setVisible(true);\n+\n+        \/\/ Wait for active frame to become active\n+        try {\n+            sema.doWait(TIMEOUT);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Wait was interrupted\");\n+        }\n+        if (!sema.getState()) {\n+            throw new RuntimeException(\"Frame doesn't become active on show\");\n+        }\n+        sema.setState(false);\n+\n+        \/\/ press on second button in inactive frame\n+        Point loc = inactiveButton2.getLocationOnScreen();\n+        robot.mouseMove(loc.x+5, loc.y+5);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        \/\/ after all second button should be focus owner.\n+        try {\n+            sema.doWait(TIMEOUT);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Wait was interrupted\");\n+        }\n+        if (!sema.getState()) {\n+            throw new RuntimeException(\"Button2 didn't become focus owner\");\n+        }\n+        Toolkit.getDefaultToolkit().sync();\n+        robot.waitForIdle();\n+        if (!(KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() == inactiveButton2)) {\n+            throw new RuntimeException(\"Button2 should be the focus owner after all\");\n+        }\n+\n+    }\n+\n+}\n+\n+class Semaphore {\n+    boolean state = false;\n+    int waiting = 0;\n+    public Semaphore() {\n+    }\n+    public void doWait() throws InterruptedException {\n+        synchronized(this) {\n+            if (state) return;\n+            waiting++;\n+            wait();\n+            waiting--;\n+        }\n+    }\n+    public void doWait(int timeout) throws InterruptedException {\n+        synchronized(this) {\n+            if (state) return;\n+            waiting++;\n+            wait(timeout);\n+            waiting--;\n+        }\n+    }\n+    public void raise() {\n+        synchronized(this) {\n+            state = true;\n+            if (waiting > 0) {\n+                notifyAll();\n+            }\n+        }\n+    }\n+    public boolean getState() {\n+        synchronized(this) {\n+            return state;\n+        }\n+    }\n+    public void setState(boolean newState) {\n+        synchronized(this) {\n+            state = newState;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/InactiveFocusRace.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4688591\n+ * @summary Tab key hangs in Native Print Dialog on win32\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual InitialPrintDlgFocusTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.JobAttributes;\n+import java.awt.PageAttributes;\n+import java.awt.PrintJob;\n+import java.awt.Toolkit;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+\n+public class InitialPrintDlgFocusTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            After the tests starts you will see a frame titled \"PrintTest\".\n+            Press the \"Print\" button and the print dialog should appear.\n+            If you are able to transfer focus between components of the Print dialog\n+            using the TAB key, then the test passes else the test fails.\n+\n+            Note: close the Print dialog before clicking on \"Pass\" or \"Fail\" buttons.\"\"\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"InitialPrintDlgFocusTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(InitialPrintDlgFocusTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+        return new PrintTest();\n+\n+    }\n+}\n+\n+class PrintTest extends JFrame implements ActionListener {\n+\n+    JButton b;\n+    JobAttributes jbattrib;\n+    Toolkit tk ;\n+    PageAttributes pgattrib;\n+\n+    public PrintTest() {\n+        setTitle(\"PrintTest\");\n+        setSize(500, 400);\n+\n+        b = new JButton(\"Print\");\n+        jbattrib = new JobAttributes();\n+        tk = Toolkit.getDefaultToolkit();\n+        pgattrib = new PageAttributes();\n+        getContentPane().setLayout(new FlowLayout());\n+        getContentPane().add(b);\n+\n+        b.addActionListener(this);\n+\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        if(ae.getSource()==b)\n+            jbattrib.setDialog(JobAttributes.DialogType.NATIVE);\n+\n+        PrintJob pjob = tk.getPrintJob(this, \"Printing Test\",\n+                                       jbattrib, pgattrib);\n+\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/InitialPrintDlgFocusTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4845868\n+ * @summary REGRESSION: First keystroke after JDialog is closed is lost\n+ * @key headful\n+ * @run main KeyStrokeTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+\n+public class KeyStrokeTest {\n+    static boolean keyTyped;\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            KeyStrokeTest test = new KeyStrokeTest();\n+            test.doTest();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+\n+    private static void doTest() throws Exception {\n+        final Object monitor = new Object();\n+        frame = new Frame();\n+        TextField textField = new TextField() {\n+                public void transferFocus() {\n+                    System.err.println(\"transferFocus()\");\n+                    final Dialog dialog = new Dialog(frame, true);\n+                    Button btn = new Button(\"Close It\");\n+                    btn.addActionListener(new ActionListener() {\n+                            public void actionPerformed(ActionEvent e) {\n+                                System.err.println(\"action performed\");\n+                                dialog.setVisible(false);\n+                            }\n+                        });\n+                    dialog.add(btn);\n+                    dialog.setSize(200, 200);\n+                    dialog.setVisible(true);\n+                }\n+            };\n+\n+        textField.addKeyListener(new KeyAdapter() {\n+                public void keyTyped(KeyEvent e) {\n+                    System.err.println(e);\n+                    if (e.getKeyChar() == 'a') {\n+                        keyTyped = true;\n+                    }\n+\n+                    synchronized (monitor) {\n+                        monitor.notifyAll();\n+                    }\n+                }\n+            });\n+        frame.add(textField);\n+        frame.setSize(400, 400);\n+        frame.setVisible(true);\n+\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+        robot.keyPress(KeyEvent.VK_TAB);\n+        robot.keyRelease(KeyEvent.VK_TAB);\n+\n+        robot.delay(1000);\n+        robot.keyPress(KeyEvent.VK_SPACE);\n+        robot.keyRelease(KeyEvent.VK_SPACE);\n+\n+        robot.delay(1000);\n+        synchronized (monitor) {\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            monitor.wait(3000);\n+        }\n+\n+        if (!keyTyped) {\n+            throw new RuntimeException(\"TEST FAILED\");\n+        }\n+\n+        System.out.println(\"Test passed\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/KeyStrokeTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4472032\n+ * @summary Switching between lightweight menus by horizontal arrow key works incorrect\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual LightweightPopupTest\n+*\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+\n+public class LightweightPopupTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            When the test starts, you will see a frame titled\n+            'Lightweight Popup Test', which contains a button\n+            (titled 'JButton') and two menus ('Menu 1' and 'Menu 2').\n+            Make sure that both menus, when expanded, fit entirely\n+            into the frame. Now take the following steps:\n+                1. Click on 'JButton' to focus it.\n+                2. Click 'Menu 1' to expand it.\n+                3. Press right arrow to select 'Menu 2'.\n+            Now check where the focus is. If it is on 'JButton'\n+            (you can press space bar to see if it is there), then\n+            the test failed. If 'JButton' is not focused, then\n+            the test passed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"LightweightPopupTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(LightweightPopupTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+\n+        JFrame frame = new JFrame(\"Lightweight Popup Test\");\n+        JButton button = new JButton(\"JButton\");\n+        JMenuBar menuBar = new JMenuBar();\n+        JMenu menu1 = new JMenu(\"Menu 1\");\n+        menu1.add(new JMenuItem(\"Menu Item 1\"));\n+        menu1.add(new JMenuItem(\"Menu Item 2\"));\n+        menuBar.add(menu1);\n+        JMenu menu2 = new JMenu(\"Menu 2\");\n+        menu2.add(new JMenuItem(\"Menu Item 3\"));\n+        menu2.add(new JMenuItem(\"Menu Item 4\"));\n+        menuBar.add(menu2);\n+\n+        frame.add(button);\n+        frame.setJMenuBar(menuBar);\n+        frame.setSize(300, 200);\n+        return frame;\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/LightweightPopupTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4396407\n+ * @summary Tests that after a proxied window is hidden, focus is being restored correctly\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ProxiedWindowHideTest\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Container;\n+import javax.swing.Box;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+\n+public class ProxiedWindowHideTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+           You will see a JFrame.\n+           Click on JComboBox, list will expand then select any item in it.\n+           After selection, list should collapse.\n+           Click on Button('Push').\n+           If you are able to make it focused by mouse click,\n+           (black rectangle will appear around it) the test is PASSED,\n+           otherwise the test is FAILED.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ProxiedWindowHideTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(ProxiedWindowHideTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+        JFrame frame = new JFrame(\"ProxiedWindowHideTest frame\");\n+        String[] petStrings = { \"Bird\", \"Cat\", \"Dog\", \"Rabbit\", \"Pig\" };\n+        JComboBox cb = new JComboBox(petStrings);\n+\n+        cb.setLightWeightPopupEnabled(false);\n+        Container parent = Box.createVerticalBox();\n+        parent.add(new Button(\"Push\"));\n+        parent.add(cb);\n+        frame.add(parent, BorderLayout.CENTER);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Focus\/ProxiedWindowHideTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+\n+\/*\n+ * @test\n+ * @bug 4085599\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test default location for frame\n+ * @run main\/manual DefaultLocationTest\n+ *\/\n+\n+public class DefaultLocationTest {\n+    private static Frame f;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                A small frame containing the label 'Hello World' should\n+                appear in the upper left hand corner of the screen. The\n+                exact location is dependent upon the window manager.\n+\n+                On Linux and Mac machines, the default location for frame\n+                is below the taskbar or close to top-left corner.\n+\n+                Upon test completion, click Pass or Fail appropriately.\"\"\";\n+\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"DefaultLocationTest \" +\n+                \" Instructions\", INSTRUCTIONS, 5, 10, 40);\n+        EventQueue.invokeAndWait(DefaultLocationTest::createAndShowUI);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    private static void createAndShowUI() {\n+        f = new Frame(\"DefaultLocation\");\n+        f.add(\"Center\", new Label(\"Hello World\"));\n+        f.pack();\n+        PassFailJFrame.addTestWindow(f);\n+        PassFailJFrame.positionTestWindow(\n+                null, PassFailJFrame.Position.HORIZONTAL);\n+        f.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/DefaultLocationTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @bug 4237529\n+ * @key headful\n+ * @summary Test repainting of an empty frame\n+ * @run main EmptyFrameTest\n+ *\/\n+\n+public class EmptyFrameTest {\n+    private static Frame f;\n+    private static Robot robot;\n+    private static volatile Point p;\n+    private static volatile Dimension d;\n+    private static final int TOLERANCE = 5;\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                createAndShowUI();\n+            });\n+            robot.delay(1000);\n+            f.setSize(50, 50);\n+            robot.delay(500);\n+            EventQueue.invokeAndWait(() -> {\n+                p = f.getLocation();\n+                d = f.getSize();\n+            });\n+            Rectangle rect = new Rectangle(p, d);\n+            BufferedImage img = robot.createScreenCapture(rect);\n+            if (chkImgBackgroundColor(img)) {\n+                try {\n+                    ImageIO.write(img, \"png\", new File(\"Frame.png\"));\n+                } catch (IOException ignored) {}\n+                throw new RuntimeException(\"Frame doesn't repaint itself on resize\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        f = new Frame(\"EmptyFrameTest\");\n+        f.setUndecorated(true);\n+        f.setBackground(Color.RED);\n+        f.setVisible(true);\n+    }\n+\n+    private static boolean chkImgBackgroundColor(BufferedImage img) {\n+        for (int x = 1; x < img.getWidth() - 1; ++x) {\n+            for (int y = 1; y < img.getHeight() - 1; ++y) {\n+                Color c = new Color(img.getRGB(x, y));\n+                if ((c.getRed() - Color.RED.getRed()) > TOLERANCE) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/EmptyFrameTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4173503\n+ * @library \/java\/awt\/regtesthelpers\n+ * @requires (os.family == \"windows\")\n+ * @build PassFailJFrame\n+ * @summary Tests that frame layout is performed when frame is maximized from taskbar\n+ * @run main\/manual FrameLayoutTest\n+ *\/\n+\n+public class FrameLayoutTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Right-click on the taskbar button for this test. In the menu appeared,\n+                choose Maximize. The frame will be maximized. Check if buttons inside\n+                the frame are laid out properly, i.e. they occupy the frame entirely.\n+\n+                If so, test passes. If buttons occupy small rectangle in the top left\n+                corner, test fails.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Frame's Layout Test Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(FrameLayoutTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"Maximize Test\");\n+        f.add(new Button(\"North\"), BorderLayout.NORTH);\n+        f.add(new Button(\"South\"), BorderLayout.SOUTH);\n+        f.add(new Button(\"East\"), BorderLayout.EAST);\n+        f.add(new Button(\"West\"), BorderLayout.WEST);\n+        f.add(new Button(\"Cent\"), BorderLayout.CENTER);\n+        f.pack();\n+        f.setState(Frame.ICONIFIED);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameLayoutTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4320050\n+ * @key headful\n+ * @summary Minimum size for java.awt.Frame is not being enforced.\n+ * @run main FrameSetMinimumSizeTest\n+ *\/\n+\n+public class FrameSetMinimumSizeTest {\n+    private static Frame f;\n+    private static volatile boolean passed;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            try {\n+                createAndShowUI();\n+\n+                f.setSize(200, 200);\n+                passed = verifyFrameSize(new Dimension(300, 300));\n+                isFrameSizeOk(passed);\n+\n+                f.setSize(200, 400);\n+                passed = verifyFrameSize(new Dimension(300, 400));\n+                isFrameSizeOk(passed);\n+\n+                f.setSize(400, 200);\n+                passed = verifyFrameSize(new Dimension(400, 300));\n+                isFrameSizeOk(passed);\n+\n+                f.setMinimumSize(null);\n+\n+                f.setSize(200, 200);\n+                passed = verifyFrameSize(new Dimension(200, 200));\n+                isFrameSizeOk(passed);\n+            } finally {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            }\n+        });\n+    }\n+\n+    private static void createAndShowUI() {\n+        f = new Frame(\"Minimum Size Test\");\n+        f.setSize(300, 300);\n+        f.setMinimumSize(new Dimension(300, 300));\n+        f.setVisible(true);\n+    }\n+\n+    private static boolean verifyFrameSize(Dimension expected) {\n+\n+        if (f.getSize().width != expected.width || f.getSize().height != expected.height) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static void isFrameSizeOk(boolean passed) {\n+        if (!passed) {\n+            throw new RuntimeException(\"Frame's setMinimumSize not honoured for the\" +\n+                    \" frame size: \" + f.getSize());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameSetMinimumSizeTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.TextField;\n+\n+\/*\n+ * @test\n+ * @bug 4097744\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary packing a frame twice stops it resizing\n+ * @run main\/manual PackTwiceTest\n+ *\/\n+\n+public class PackTwiceTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. You would see a Frame titled 'TestFrame'\n+                2. The Frame displays a text as below:\n+                    'I am a lengthy sentence...can you see me?'\n+                3. If you can see the full text without resizing the frame\n+                   using mouse, press 'Pass' else press 'Fail'.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PackTwiceTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(PackTwiceTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"PackTwiceTest TestFrame\");\n+        TextField tf = new TextField();\n+        f.add(tf, \"Center\");\n+        tf.setText(\"I am a short sentence\");\n+        f.pack();\n+        f.pack();\n+        tf.setText(\"I am a lengthy sentence...can you see me?\");\n+        f.pack();\n+        f.requestFocus();\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/PackTwiceTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+\n+\/*\n+ * @test\n+ * @bug 4700350\n+ * @requires os.family != \"mac\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Tests menu item font is big\n+ * @run main\/manual GiantFontTest\n+ *\/\n+\n+public class GiantFontTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                        A frame with one menu will appear.\n+                        On Linux, the menu's (present on menu bar) font should\n+                        be quite large (48 point).\n+                        If not, test fails.\n+\n+                        On Windows, the menu's (present on menu bar) font\n+                        should be normal size.\n+                        If the menu text is clipped by the title bar, or is painted over\n+                        the title bar or client area, the test fails.\n+\n+                        On both Windows and Linux, the menu items in the popup\n+                        menu should be large.\n+\n+                        If so, test passes.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"GiantFontTest\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(GiantFontTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        Font giantFont = new Font(\"Dialog\", Font.PLAIN, 48);\n+        Frame f = new Frame(\"GiantFontTest\");\n+        MenuBar mb = new MenuBar();\n+        Menu m = new Menu(\"My font is too big!\");\n+        m.setFont(giantFont);\n+        for (int i = 0; i < 5; i++) {\n+            m.add(new MenuItem(\"Some MenuItems\"));\n+        }\n+        mb.add(m);\n+        f.setMenuBar(mb);\n+        f.setSize(450, 400);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/MenuItem\/GiantFontTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4175790\n+ * @requires os.family == \"windows\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Win32: Running out of command ids for menu items\n+ * @run main\/manual LotsOfMenuItemsTest\n+ *\/\n+\n+public class LotsOfMenuItemsTest extends ComponentAdapter {\n+    private static final int NUM_WINDOWS = 400;\n+    private static TestFrame firstFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        LotsOfMenuItemsTest obj = new LotsOfMenuItemsTest();\n+        String INSTRUCTIONS = \"\"\"\n+                This test creates lots of frames with menu bars.\n+                When it's done you will see two frames.\n+                Try to select menu items from each of them.\n+\n+                If everything seems to work - test passed.\n+                Click \"Pass\" button in the test harness window.\n+\n+                If test crashes on you - test failed.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"LotsOfMenuItemsTest\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(obj::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private Frame createAndShowUI() {\n+        firstFrame = new TestFrame(\"First frame\");\n+        firstFrame.addComponentListener(this);\n+        return firstFrame;\n+    }\n+\n+    @Override\n+    public void componentShown(ComponentEvent e) {\n+        final int x = firstFrame.getX();\n+        final int y = firstFrame.getY() + firstFrame.getHeight() + 8;\n+        TestFrame testFrame;\n+        for (int i = 1; i < NUM_WINDOWS - 1; ++i) {\n+            testFrame = new TestFrame(\"Running(\" + i + \")...\", x, y);\n+            testFrame.setVisible(false);\n+            testFrame.dispose();\n+        }\n+        testFrame = new TestFrame(\"Last Frame\", x, y);\n+        PassFailJFrame.addTestWindow(testFrame);\n+    }\n+\n+    private static class TestFrame extends Frame {\n+        static int n = 0;\n+\n+        public TestFrame(String title) {\n+            this(title, 0, 0, false);\n+        }\n+\n+        public TestFrame(String s, int x, int y) {\n+            this(s, x, y, true);\n+        }\n+\n+        private TestFrame(String title, int x, int y, boolean visible) {\n+            super(title);\n+            MenuBar mb = new MenuBar();\n+            for (int i = 0; i < 10; ++i) {\n+                Menu m = new Menu(\"Menu_\" + (i + 1));\n+                for (int j = 0; j < 20; ++j) {\n+                    MenuItem mi = new MenuItem(\"Menu item \" + ++n);\n+                    m.add(mi);\n+                }\n+                mb.add(m);\n+            }\n+            setMenuBar(mb);\n+            setLocation(x, y);\n+            setSize(450, 150);\n+            if (visible) {\n+                setVisible(true);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/MenuItem\/LotsOfMenuItemsTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+\n+\/*\n+ * @test\n+ * @bug 4066657 8009454\n+ * @requires os.family != \"mac\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Tests that setting a font on the Menu with MenuItem takes effect.\n+ * @run main\/manual MenuSetFontTest\n+ *\/\n+\n+public class MenuSetFontTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                    Look at the menu in the upper left corner of the 'SetFont Test' frame.\n+                    Click on the \"File\" menu. You will see \"menu item\" item.\n+                    Press Pass if menu item is displayed using bold and large font,\n+                    otherwise press Fail.\n+                    If you do not see menu at all, press Fail.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"MenuSetFontTest\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(MenuSetFontTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        Frame frame = new Frame(\"SetFont Test\");\n+        MenuBar menuBar = new MenuBar();\n+        Menu menu = new Menu(\"File\");\n+        MenuItem item = new MenuItem(\"menu item\");\n+        menu.add(item);\n+        menuBar.add(menu);\n+        menuBar.setFont(new Font(Font.MONOSPACED, Font.BOLD, 24));\n+        frame.setMenuBar(menuBar);\n+        frame.setSize(300, 200);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/MenuItem\/MenuSetFontTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4251036\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary MenuItem setLabel(null\/\"\") behaves differently under Win32 and Solaris\n+ * @run main\/manual NullOrEmptyStringLabelTest\n+ *\/\n+\n+public class NullOrEmptyStringLabelTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                The bug is reproducible under Win32 and Solaris.\n+                Setting 'null' and \"\" as a label of menu item\n+                should set blank label on all platforms according to the specification.\n+                But under Solaris setting \"\" as a label of menu item used to\n+                cause some garbage to be set as label.\n+                Under Win32 setting 'null' as a label used to result in\n+                throwing NullPointerException.\n+\n+                If you see any of these things happen test fails otherwise\n+                it passes.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"NullOrEmptyStringLabelTest\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(NullOrEmptyStringLabelTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        Frame frame = new Frame(\"Null Or Empty String Label Test\");\n+        Menu menu = new Menu(\"Menu\");\n+        MenuItem mi = new MenuItem(\"Item\");\n+        MenuBar mb = new MenuBar();\n+        Button button1 = new Button(\"Set MenuItem label to 'null'\");\n+        Button button2 = new Button(\"Set MenuItem label to \\\"\\\"\");\n+        Button button3 = new Button(\"Set MenuItem label to 'text'\");\n+        button1.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent ev) {\n+                System.out.println(\"Setting MenuItem label to null\");\n+                mi.setLabel(null);\n+            }\n+        });\n+        button2.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent ev) {\n+                System.out.println(\"Setting MenuItem label to \\\"\\\"\");\n+                mi.setLabel(\"\");\n+            }\n+        });\n+        button3.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent ev) {\n+                System.out.println(\"Setting MenuItem label to 'text'\");\n+                mi.setLabel(\"text\");\n+            }\n+        });\n+        menu.add(mi);\n+        mb.add(menu);\n+        frame.add(button1, BorderLayout.NORTH);\n+        frame.add(button2, BorderLayout.CENTER);\n+        frame.add(button3, BorderLayout.SOUTH);\n+        frame.setMenuBar(mb);\n+        frame.setSize(200, 135);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/MenuItem\/NullOrEmptyStringLabelTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+\n+\/*\n+ * @test\n+ * @bug 4099695\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary menu items with Unicode labels treated as separators\n+ * @run main\/manual UnicodeMenuItemTest\n+ *\/\n+\n+public class UnicodeMenuItemTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Click on the \"Menu\" on the top-left corner of frame.\n+\n+                The menu should have four entries:\n+                1) a row of five unicode characters: \\u00c4\\u00cb\\u00cf\\u00d6\\u00dc\n+                2) a menu separator\n+                3) a unicode character:  \\u012d\n+                4) a unicode character:  \\u022d\n+\n+                If the menu items look like the list above, the test passes.\n+                It is okay if the unicode characters look like empty boxes\n+                or something - as long as they are not separators.\n+\n+                If either of the last two menu items show up as separators,\n+                the test FAILS.\n+\n+                Press 'Pass' if above instructions hold good else press 'Fail'.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"UnicodeMenuItemTest\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(UnicodeMenuItemTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+    private static Frame createAndShowUI() {\n+        Frame frame = new Frame(\"Unicode MenuItem Test\");\n+        MenuBar mb = new MenuBar();\n+        Menu m = new Menu(\"Menu\");\n+\n+        MenuItem mi1 = new MenuItem(\"\\u00c4\\u00cb\\u00cf\\u00d6\\u00dc\");\n+        m.add(mi1);\n+\n+        MenuItem separator = new MenuItem(\"-\");\n+        m.add(separator);\n+\n+        MenuItem mi2 = new MenuItem(\"\\u012d\");\n+        m.add(mi2);\n+\n+        MenuItem mi3 = new MenuItem(\"\\u022d\");\n+        m.add(mi3);\n+\n+        mb.add(m);\n+\n+        frame.setMenuBar(mb);\n+        frame.setSize(450, 150);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/MenuItem\/UnicodeMenuItemTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4100188\n+ * @key headful\n+ * @summary Make sure that TextFields contain all of,\n+ * and exactly, the text that was entered into them.\n+ * @run main GetTextTest\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class GetTextTest extends Frame implements ActionListener {\n+    private final String s = \"test string\";\n+    private volatile String ac;\n+    private TextField t;\n+    private Point location;\n+    private Dimension size;\n+\n+    public void setupGUI() {\n+        setLayout(new FlowLayout(FlowLayout.LEFT));\n+\n+        t = new TextField(s, 32);\n+        add(new Label(\"Hit <CR> after text\"));\n+        add(t);\n+        t.addActionListener(this);\n+        setLocationRelativeTo(null);\n+        pack();\n+        setVisible(true);\n+    }\n+\n+    public void actionPerformed(ActionEvent evt) {\n+        ac = evt.getActionCommand();\n+    }\n+\n+    public void performTest() throws AWTException, InterruptedException,\n+            InvocationTargetException {\n+        EventQueue.invokeAndWait(() -> {\n+            location = t.getLocationOnScreen();\n+            size = t.getSize();\n+        });\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(50);\n+        robot.delay(1000);\n+        robot.waitForIdle();\n+        robot.mouseMove(location.x + size.width - 3, location.y + (size.height \/ 2));\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(1000);\n+        robot.waitForIdle();\n+        robot.keyPress(KeyEvent.VK_ENTER);\n+        robot.keyRelease(KeyEvent.VK_ENTER);\n+        robot.delay(1000);\n+        if (!s.equals(ac)) {\n+            throw new RuntimeException(\"Action command should be the same as text field content\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException, AWTException {\n+        GetTextTest test = new GetTextTest();\n+        EventQueue.invokeAndWait(test::setupGUI);\n+        try {\n+            test.performTest();\n+        } finally {\n+            EventQueue.invokeAndWait(test::dispose);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TextField\/GetTextTest\/GetTextTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4222122\n+ * @summary TextField.setEchoCharacter() seems to be broken\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SetEchoCharTest3\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.TextField;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class SetEchoCharTest3 extends Frame {\n+    static String INSTRUCTIONS = \"\"\"\n+             Type in the text field and \"*\" characters should echo.\n+             If only one \"*\" echoes and then the system beeps after\n+             the second character is typed, then press Fail, otherwise press Pass.\n+             \"\"\";\n+    public SetEchoCharTest3() {\n+        setLayout(new FlowLayout());\n+        add(new Label(\"Enter text:\"));\n+        TextField tf = new TextField(15);\n+        tf.setEchoChar('*');\n+        add(tf);\n+        pack();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Set Echo Char Test 3\")\n+                .testUI(SetEchoCharTest3::new)\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TextField\/SetEchoCharTest3\/SetEchoCharTest3.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.test.lib.Platform;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+\/*\n+ * @test\n+ * @bug 4724007\n+ * @key headful\n+ * @summary Tests that KeyTyped events are fired for the Numpad1 key\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main Numpad1KeyTyped\n+ *\/\n+public final class Numpad1KeyTyped extends FocusAdapter implements KeyListener {\n+\n+    private static final String ORIGINAL = \"0123456789\";\n+    private static final String EXPECTED = \"10123456789\";\n+\n+    private final CountDownLatch typedNum1 = new CountDownLatch(1);\n+    private final CountDownLatch focusGained = new CountDownLatch(1);\n+\n+    public static void main(String[] args) throws Exception {\n+        Numpad1KeyTyped test = new Numpad1KeyTyped();\n+        test.start();\n+    }\n+\n+    private void start() throws Exception {\n+        Toolkit toolkit = Toolkit.getDefaultToolkit();\n+        Boolean oldState = null;\n+\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+\n+        Frame frame = new Frame(\"Numpad1KeyTyped\");\n+        TextField tf = new TextField(ORIGINAL, 20);\n+        frame.add(tf);\n+        tf.addKeyListener(this);\n+\n+        tf.addFocusListener(this);\n+\n+        frame.setSize(300, 100);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        tf.requestFocusInWindow();\n+\n+        if (!focusGained.await(2, SECONDS)) {\n+            throw new RuntimeException(\"TextField didn't receive focus\");\n+        }\n+        robot.waitForIdle();\n+\n+        try {\n+            \/\/ Move cursor to start of TextField\n+            robot.keyPress(KeyEvent.VK_HOME);\n+            robot.keyRelease(KeyEvent.VK_HOME);\n+            robot.waitForIdle();\n+\n+            if (Platform.isLinux()) {\n+                \/\/ Press but don't release NumLock\n+                robot.keyPress(KeyEvent.VK_NUM_LOCK);\n+            }\n+            if (Platform.isWindows()) {\n+                oldState = toolkit.getLockingKeyState(KeyEvent.VK_NUM_LOCK);\n+                toolkit.setLockingKeyState(KeyEvent.VK_NUM_LOCK, true);\n+            }\n+\n+            \/\/ Press and release Numpad-1\n+            robot.keyPress(KeyEvent.VK_NUMPAD1);\n+            robot.keyRelease(KeyEvent.VK_NUMPAD1);\n+\n+            if (!typedNum1.await(2, SECONDS)) {\n+                throw new RuntimeException(\"TextField didn't receive keyTyped('1') - too slow\");\n+            }\n+\n+            final String text = tf.getText();\n+            if (!text.equals(EXPECTED)) {\n+                throw new RuntimeException(\"Test FAILED: wrong string '\"\n+                                           + text + \"' vs \"\n+                                           + \"expected '\" + EXPECTED + \"'\");\n+            }\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            if (Platform.isLinux()) {\n+                \/\/ \"release\" + \"press and release\" NumLock to disable numlock\n+                robot.keyRelease(KeyEvent.VK_NUM_LOCK);\n+                robot.keyPress(KeyEvent.VK_NUM_LOCK);\n+                robot.keyRelease(KeyEvent.VK_NUM_LOCK);\n+            }\n+            if (oldState != null) {\n+                toolkit.setLockingKeyState(KeyEvent.VK_NUM_LOCK, oldState);\n+            }\n+\n+            frame.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public void focusGained(FocusEvent e) {\n+        System.out.println(\"tf.focusGained\");\n+        focusGained.countDown();\n+    }\n+\n+    @Override\n+    public void keyPressed(KeyEvent evt) {\n+        printKey(evt);\n+    }\n+\n+    @Override\n+    public void keyTyped(KeyEvent evt) {\n+        printKey(evt);\n+\n+        int keychar = evt.getKeyChar();\n+        if (keychar == '1') {\n+            typedNum1.countDown();\n+        }\n+    }\n+\n+    @Override\n+    public void keyReleased(KeyEvent evt) {\n+        printKey(evt);\n+        System.out.println();\n+    }\n+\n+    private static void printKey(KeyEvent evt) {\n+        int id = evt.getID();\n+        if (id != KeyEvent.KEY_TYPED\n+            && id != KeyEvent.KEY_PRESSED\n+            && id != KeyEvent.KEY_RELEASED) {\n+\n+            System.out.println(\"Other Event\");\n+            return;\n+        }\n+\n+        System.out.println(\"params= \" + evt.paramString() + \"  \\n\" +\n+          \"KeyChar: \" + evt.getKeyChar() + \" = \" + (int) evt.getKeyChar() +\n+          \"   KeyCode: \" + evt.getKeyCode() +\n+          \"   Modifiers: \" + evt.getModifiersEx());\n+\n+        if (evt.isActionKey()) {\n+            System.out.println(\"   Action Key\");\n+        }\n+\n+        System.out.println(\"keyText= \" + KeyEvent.getKeyText(evt.getKeyCode()) + \"\\n\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/KeyTyped\/Numpad1KeyTyped.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4309915\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Check that Antialiased text drawn on a BYTE_GRAY image\n+ *              resolves the color correctly\n+ * @run main\/manual GrayAATextTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.RenderingHints;\n+import java.awt.image.BufferedImage;\n+\n+public class GrayAATextTest extends Panel {\n+\n+    public static final int WIDTH = 600;\n+    public static final int HEIGHT = 200;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        All of the strings in a given column should be drawn\n+        in the same color.  If the bug is present, then the\n+        Antialiased strings will all be of a fixed color that\n+        is not the same as the other strings in their column.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"GrayAATextTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(GrayAATextTest::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public void paint(Graphics g) {\n+        BufferedImage bi = new BufferedImage(WIDTH, HEIGHT,\n+                                             BufferedImage.TYPE_BYTE_GRAY);\n+        Graphics2D g2d = bi.createGraphics();\n+        g2d.setFont(new Font(\"Helvetica\", Font.PLAIN, 24));\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, WIDTH \/ 2, HEIGHT);\n+        drawText(g2d, Color.black, \"Black\", 25);\n+        drawText(g2d, Color.lightGray, \"Light Gray\", 175);\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(WIDTH \/ 2, 0, WIDTH \/ 2, HEIGHT);\n+        drawText(g2d, Color.white, \"White\", 325);\n+        drawText(g2d, Color.lightGray, \"Light Gray\", 475);\n+        g2d.dispose();\n+        g.drawImage(bi, 0, 0, null);\n+    }\n+\n+    public void drawText(Graphics2D g2d, Color c, String colorname, int x) {\n+        g2d.setColor(c);\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_OFF);\n+        g2d.drawString(colorname, x, 50);\n+        g2d.drawString(\"Aliased\", x, 100);\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_ON);\n+        g2d.drawString(\"Antialiased\", x, 150);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(WIDTH, HEIGHT);\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame f = new Frame(\"GrayAATextTest Frame\");\n+        f.add(new GrayAATextTest());\n+        f.setSize(WIDTH, HEIGHT);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/BufferedImage\/GrayAATextTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4243044\n+ * @summary This test should show two windows filled with checker\n+ *          board pattern. The transparency should runs from left to right from\n+ *          total transparent to total opaque.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual GrayAlpha\n+ *\/\n+\n+import java.util.List;\n+import java.awt.Frame;\n+import java.awt.color.ColorSpace;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.awt.Point;\n+import java.awt.Panel;\n+import java.awt.Transparency;\n+import java.awt.Window;\n+\n+public class GrayAlpha extends Panel {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        This test should show two windows filled with checker board\n+        vpattern. The transparency should runs from left to right from\n+        totally transparent to totally opaque. If either the pattern or\n+        the transparency is not shown correctly, click Fail, otherwise\n+        click Pass.\"\"\";\n+\n+    BufferedImage bi;\n+    AffineTransform identityTransform = new AffineTransform();\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"GrayAlpha Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int)INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(GrayAlpha::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+\n+    public GrayAlpha(int width, int height,\n+                     boolean hasAlpha, boolean isAlphaPremultiplied,\n+                     boolean useRGB) {\n+        boolean isAlphaPremuliplied = true;\n+        int bands = useRGB ? 3 : 1;\n+        bands = hasAlpha ? bands + 1 : bands;\n+\n+        ColorSpace cs = useRGB ?\n+            ColorSpace.getInstance(ColorSpace.CS_sRGB) :\n+            ColorSpace.getInstance(ColorSpace.CS_GRAY);\n+        int transparency = hasAlpha ?\n+            Transparency.TRANSLUCENT : Transparency.OPAQUE;\n+        int[] bits = new int[bands];\n+        for (int i = 0; i < bands; i++) {\n+            bits[i] = 8;\n+        }\n+\n+        ColorModel cm = new ComponentColorModel(cs,\n+                                                bits,\n+                                                hasAlpha,\n+                                                isAlphaPremultiplied,\n+                                                transparency,\n+                                                DataBuffer.TYPE_BYTE);\n+        WritableRaster wr =\n+            Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                           width, height, bands,\n+                                           new Point(0, 0));\n+\n+        for (int b = 0; b < bands; b++) {\n+            for (int y = 0; y < height; y++) {\n+                for (int x = 0; x < width; x++) {\n+                    int s;\n+\n+                    if (b != bands - 1 || !hasAlpha) {\n+                        \/\/ Gray band(s), fill with a checkerboard pattern\n+                        if (((x \/ 10) % 2) == ((y \/ 10) % 2)) {\n+                            s = 255;\n+                        } else {\n+                            s = 0;\n+                        }\n+                        if (isAlphaPremultiplied) {\n+                            int alpha = (x*255)\/(width - 1);\n+                            s = (s*alpha)\/255;\n+                        }\n+                    } else {\n+                        \/\/ Alpha band, increase opacity left to right\n+                        s = (x*255)\/(width - 1);\n+                    }\n+\n+                    wr.setSample(x, y, b, s);\n+                }\n+            }\n+        }\n+\n+        this.bi = new BufferedImage(cm, wr, isAlphaPremultiplied, null);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(bi.getWidth(), bi.getHeight());\n+    }\n+\n+    public void paint(Graphics g) {\n+        if (bi != null) {\n+            ((Graphics2D)g).drawImage(bi, 0, 0, null);\n+        }\n+    }\n+\n+    public static Frame makeFrame(String title,\n+                                 int x, int y, int width, int height,\n+                                 boolean hasAlpha,\n+                                 boolean isAlphaPremultiplied,\n+                                 boolean useRGB) {\n+        Frame f = new Frame(title);\n+        f.add(new GrayAlpha(width, height,\n+                            hasAlpha, isAlphaPremultiplied, useRGB));\n+        f.pack();\n+        f.setLocation(x, y);\n+        return f;\n+    }\n+\n+    private static List<Window> createTestUI() {\n+        int width = 200;\n+        int height = 200;\n+\n+        int x = 100;\n+        int y = 100;\n+\n+        Frame f1 = makeFrame(\"Gray (non-premultiplied)\",\n+                  x, y, width, height,\n+                  true, false, false);\n+        x += width + 20;\n+\n+        Frame f2 = makeFrame(\"Gray (premultiplied)\",\n+                  x, y, width, height,\n+                  true, true, false);\n+\n+        return List.of(f1, f2);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/GrayAlpha.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4259548\n+ * @summary tests that MemoryImageSource correctly handles images with offsets\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ImageOffsetTest\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Panel;\n+import java.awt.Toolkit;\n+import java.awt.image.ColorModel;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.MemoryImageSource;\n+\n+public class ImageOffsetTest {\n+\n+    static int height = 100;\n+    static int width  = 100;\n+    static int levels = 3;\n+    static IndexColorModel cm;\n+    static Image image;\n+    static boolean first = true;\n+\n+    static byte[] db = new byte[height * width * levels] ;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+         If on the appeared 'Test frame' all color squares are of one color\n+         test failed, otherwise it's passed.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .title(\"ImageOffsetTest\")\n+                      .instructions(INSTRUCTIONS)\n+                      .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                      .columns(35)\n+                      .testUI(ImageOffsetTest::createUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame frame = new Frame(\"ImageOffset Frame\");\n+        frame.add(new Panel() {\n+            public void paint(Graphics g) {\n+                for ( int i=0 ; i<3 ; i++ ) {\n+                    g.drawImage(\n+                        generateBuggyImage(i * width * height), 10 + i * 110, 10, null);\n+                }\n+            }\n+        });\n+        frame.setSize(400, 200);\n+        frame.setLocation(300, 200);\n+        createColorModel();\n+        int l = 0;\n+        for (int k = 0; k < levels; k++) {\n+            for (int i = 0; i < height; i++) {\n+                for (int j = 0; j < width; j++) {\n+                    if( k == 0) {\n+                        db[l] = (byte)(70 & 0xff) ;\n+                    }\n+                    if (k == 1) {\n+                        db[l] = (byte)(150 & 0xff) ;\n+                    }\n+                    if (k == 2) {\n+                        db[l] = (byte)(230 & 0xff) ;\n+                    }\n+                    l++ ;\n+                }\n+            }\n+        }\n+        return frame;\n+    }\n+\n+    private static void createColorModel() {\n+        byte[] red = new byte[256];\n+        byte[] green = new byte[256];\n+        byte[] blue = new byte[256];\n+\n+        for (int i = 0; i < 256; i++) {\n+            red[i]   = (byte)(i & 0xff);\n+            \/\/green[i] = (byte)( i & 0xff ) ;\n+            blue[i]  = (byte)( i & 0xff ) ;\n+            \/\/commented out green so I could get purple\n+        }\n+\n+        cm = new IndexColorModel( 8, 256, red, green, blue ) ;\n+    }\n+\n+    private static Image generateBuggyImage(int offset) {\n+        \/\/ Initialize the database, Three slices, different shades of grey\n+        \/\/ Here the image is created using the offset,\n+        return Toolkit.getDefaultToolkit().createImage(\n+                new MemoryImageSource(width, height, (ColorModel)cm,\n+                                      db, offset, width));\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ImageOffsetTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4090743\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Make sure that there is no garbage drawn on the rotated image\n+ * @run main\/manual TransformImage\n+ *\/\n+\n+import java.net.URL;\n+import java.net.MalformedURLException;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.AffineTransform;\n+import java.awt.Image;\n+import java.awt.image.ImageObserver;\n+import java.awt.MediaTracker;\n+import java.awt.Toolkit;\n+\n+public class TransformImage extends Canvas  {\n+    static Image image;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            The rotated image should be drawn without garbage.\"\"\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"TransformImage Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows(5)\n+                .columns(35)\n+                .testUI(TransformImage::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Frame f = new Frame();\n+        String dir = System.getProperty(\"test.src\");\n+        String sep = System.getProperty(\"file.separator\");\n+        if (dir == null) {\n+            dir = \".\";\n+        }\n+        image = Toolkit.getDefaultToolkit().getImage(dir+sep+\"duke.gif\");\n+        f.add(new TransformImage());\n+\n+        f.pack();\n+        return f;\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension (256, 256);\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return getPreferredSize();\n+    }\n+\n+    public void paint(Graphics g) {\n+        int w, h;\n+        java.awt.Graphics2D g2d = (Graphics2D) g;\n+        AffineTransform at = new AffineTransform();\n+\n+        MediaTracker mt = new MediaTracker(this);\n+        mt.addImage(image, 0);\n+        try {\n+            mt.waitForAll();\n+        } catch (InterruptedException e) {\n+            System.err.println(\"can't track\");\n+            return;\n+        }\n+        w = image.getWidth(this);\n+        h = image.getHeight(this);\n+        g2d.drawImage(image, 0, 0, this);\n+        g2d.drawRect(0, 0, w, h);\n+\n+        double rad = .5;\n+        at.rotate(-rad);\n+        g2d.setTransform(at);\n+        g2d.drawImage(image, 0, 100, this);\n+        g2d.drawRect(0, 100, w, h);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/TransformImage.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/image\/duke.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/image\/VolatileImage\/duke.gif","status":"copied"},{"patch":"@@ -162,1 +162,1 @@\n- *     <li>to add a log area<\/li>,\n+ *     <li>to add a log area,<\/li>\n@@ -352,1 +352,1 @@\n-            } else if (builder.testWindows.size() == 1) {\n+            } else {\n@@ -355,2 +355,0 @@\n-            } else {\n-                positionTestWindow(null, builder.position);\n@@ -1116,1 +1114,2 @@\n-     * {@link Builder#logArea()} or {@link Builder#logArea(int)}.\n+     * {@link Builder#logArea() logArea()} or\n+     * {@link Builder#logArea(int) logArea(int)}.\n@@ -1118,1 +1117,1 @@\n-     * @param message to log\n+     * @param message the message to log\n@@ -1127,1 +1126,2 @@\n-     * {@link Builder#logArea()} or {@link Builder#logArea(int)}.\n+     * {@link Builder#logArea() logArea()} or\n+     * {@link Builder#logArea(int) logArea(int)}.\n@@ -1136,1 +1136,3 @@\n-     * {@link Builder#logArea()} or {@link Builder#logArea(int)}.\n+     * {@link Builder#logArea() logArea()} or\n+     * {@link Builder#logArea(int) logArea(int)}.\n+     *\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -972,0 +972,394 @@\n+        failures += testTanhAdditionalTests();\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test accuracy of {Math, StrictMath}.tanh using quad precision\n+     * tanh implementation as the reference. There are additional tests.\n+     * The specified accuracy is 2.5 ulps.\n+     *\n+     *\/\n+    static int testTanhAdditionalTests() {\n+        int failures = 0;\n+        \/*\n+         * Array elements below are generated using a quad precision tanh\n+         * implementation (libquadmath). Rounded to a double, the quad result\n+         * *should* be correctly rounded, unless we are quite unlucky.\n+         * Assuming the quad value is a correctly rounded double, the\n+         * allowed error is 3.0 ulps instead of 2.5 since the quad\n+         * value rounded to double can have its own 1\/2 ulp error.\n+         *\/\n+        double[][] testCases = {\n+            \/\/ x                                                   tanh(x)\n+            {1.09951162777600024414062500000000000e+12,            1.00000000000000000000000000000000000e+00},\n+            {1.56250000000000416333634234433702659e-02,            1.56237285584089068255495133849899136e-02},\n+            {1.61254882812500000000000000000000000e+01,            9.99999999999980293529906376885389048e-01},\n+            {2.53165043529127054000582575099542737e-01,            2.47891535884497437358843835970604812e-01},\n+            {2.05669906337718799704816774465143681e+00,            9.67821952180774991463712302156014956e-01},\n+            {8.73243486124784240587359818164259195e+00,            9.99999947984421044859570034536492937e-01},\n+            {1.35302734375000000000000000000000000e+00,            8.74765946489987955543753077657414741e-01},\n+            {7.51299319580434721288497712521348149e-01,            6.35923468395323117288273690770900477e-01},\n+            {9.53088818012631927567568368431238923e-02,            9.50213381512267711017656118902912332e-02},\n+            {7.64443165964961757197215774795040488e-01,            6.43686625696507143760198874608796949e-01},\n+            {9.80772770147126660145175947036477737e-02,            9.77640088885469645387119927980991050e-02},\n+            {8.00000000000000044408920985006261617e-01,            6.64036770267848988511881426480887109e-01},\n+            {6.58800443825626694943631278533757722e-03,            6.58790912948844334160953310959647563e-03},\n+            {3.50634723606509357551885841530747712e+00,            9.98200861366828007281302037717336212e-01},\n+            {8.80951107580675074615328412619419396e-01,            7.06895478355484050029724917425086249e-01},\n+            {9.41693953354077795125931515940465033e-01,            7.35999567964351009171211613664845735e-01},\n+            {4.86714106743433794211028953213826753e-01,            4.51604571680788935707314000261162601e-01},\n+            {4.99999999970896114032115065128891729e-01,            4.62117157237121073362068671381593592e-01},\n+            {1.27999999999999971578290569595992565e+02,            1.00000000000000000000000000000000000e+00},\n+            {1.00000000000000022204460492503130808e+00,            7.61594155955764981372495044941331753e-01},\n+            {1.09951162777600024414062500000000000e+12,            1.00000000000000000000000000000000000e+00},\n+            {5.00000000000000777156117237609578297e-01,            4.62117157260010369694985045764006657e-01},\n+            {3.90625000000001474514954580286030250e-03,            3.90623013190635482599726614938805467e-03},\n+            {1.56250000000000659194920871186695877e-02,            1.56237285584089311057499113400637264e-02},\n+            {1.25000000000001332267629550187848508e-01,            1.24353001771597519720531117125519878e-01},\n+            {1.56250000000005169475958410885141348e-02,            1.56237285584093820237573019342883109e-02},\n+            {2.00000000000022737367544323205947876e+00,            9.64027580075832948084133680630298643e-01},\n+            {6.25000000000080352391407245704613160e-02,            6.24187467475205184231888372622987839e-02},\n+            {2.50000000000049737991503207013010979e-01,            2.44918662403755883728363950973251081e-01},\n+            {2.50000000000454747350886464118957520e-01,            2.44918662404136598540089724354621762e-01},\n+            {7.81250000001537658889105841808486730e-03,            7.81234105817638947180855590780540396e-03},\n+            {8.00000000002179945113311987370252609e+00,            9.99999774929675899622836792366347278e-01},\n+            {8.00000000002182787284255027770996094e+00,            9.99999774929675899635630557632573807e-01},\n+            {1.00000000004506106598967107856879011e+00,            7.61594155974689379640247120538425632e-01},\n+            {5.00000000024432678102925819985102862e-01,            4.62117157279224782806433798595181278e-01},\n+            {5.00000000124148025193449029757175595e-01,            4.62117157357645691462301850285961295e-01},\n+            {1.25000000043655745685100555419921875e-01,            1.24353001814576875736126314329404676e-01},\n+            {1.56250130385160446166992187500000000e-02,            1.56237415937421937398207048034470765e-02},\n+            {6.25000596046447753906250000000000000e-02,            6.24188061199314157260056878713262148e-02},\n+            {6.25001570879248902201652526855468750e-02,            6.24189032234056148184566765458350515e-02},\n+            {3.12509536743164062500000000000000000e-02,            3.12407841896026978197614959195842857e-02},\n+            {1.00024414062500000000000000000000000e+00,            7.61696669690972358277739369649969500e-01},\n+            {1.25091552734375000000000000000000000e-01,            1.24443137738349286849917747910445080e-01},\n+            {6.25703578334750876166481248219497502e-02,            6.24888301519391612116796252071905868e-02},\n+            {2.52525252525252597024518763646483421e-01,            2.47290965006585965880182136581880733e-01},\n+            {1.00000000164410457817454336293394590e-03,            9.99999668310902934017090322313224382e-04},\n+            {1.00000000966720672609944209341392707e-03,            9.99999676333997058845099107943491685e-04},\n+            {5.13687551499984795810860305209644139e-01,            4.72813376851263299460550751434331149e-01},\n+            {1.03125000000000000000000000000000000e+00,            7.74409187434213568286703209738132986e-01},\n+            {1.03372912114974835340319714305223897e+00,            7.75399652279487427958938283855319050e-01},\n+            {8.73243486124791523650401359191164374e+00,            9.99999947984421044867146689152891277e-01},\n+            {5.46364074509520181166521979321260005e-01,            4.97790203319363272413440879555555135e-01},\n+            {5.48776992118357842542764046811498702e-01,            4.99603030846724465253358333732665160e-01},\n+            {8.62884521484375000000000000000000000e-03,            8.62863106199946057455229821459862778e-03},\n+            {5.56840723899044820477399753144709393e-01,            5.05629619734278492036257594911833276e-01},\n+            {1.12042968912429174999090264464030042e+00,            8.07718324543002512898290101804260243e-01},\n+            {2.80761718750000000000000000000000000e-01,            2.73609921989813966516244201735889906e-01},\n+            {4.50982142857161694138312668655999005e+00,            9.99758010610690750512553927515350523e-01},\n+            {1.79803946803892764072507759465224808e-02,            1.79784572761372499903768063141254578e-02},\n+            {2.90674624105783541150316295897937380e-01,            2.82755618405959946459876962574827861e-01},\n+            {3.00000000019552404140199541870970279e-01,            2.91312612469484033539387970973996561e-01},\n+            {1.52306844600212459850396840010944288e-01,            1.51139964502163284820786391222343666e-01},\n+            {1.21913138136517762433186362613923848e+00,            8.39397762830401796350294214789399315e-01},\n+            {1.91612901016097944562055488404439529e-02,            1.91589453912240029886209020645693670e-02},\n+            {1.23194037796136601770058405236341059e+00,            8.43141232466373734055029303451281784e-01},\n+            {5.14544145441922751160745974630117416e+00,            9.99932120037417992977353814124626761e-01},\n+            {1.29608715898613313655118872702587396e+00,            8.60712461444305632100271902930674052e-01},\n+            {1.35302734375000000000000000000000000e+00,            8.74765946489987955543753077657414741e-01},\n+            {6.89141205308152926534148718928918242e-01,            5.97430012402391408227990740295335202e-01},\n+            {2.16702398900134561576802383342510439e-02,            2.16668484172600518601166701940771309e-02},\n+            {6.95330121814107471323040954302996397e-01,            6.01395252733578654705526153849150843e-01},\n+            {1.70127028180982076566857275068400668e-04,            1.70127026539641570641832179464678521e-04},\n+            {6.98731899876564921392230189667316154e-01,            6.03562246839061712657431798989209285e-01},\n+            {2.82308042901865396956395670713391155e+00,            9.92962754889608618611084237181745775e-01},\n+            {8.85009765625000000000000000000000000e-02,            8.82706391518277914218106043840064600e-02},\n+            {1.44086021505376304929768593865446746e+00,            8.93870759190524111186764508137227647e-01},\n+            {4.52708479240923750142044923450157512e-02,            4.52399464814195843886615749285771251e-02},\n+            {7.42434201630502221824770003877347335e-01,            6.30613596749571014884527941122811076e-01},\n+            {7.47314453125000000000000000000000000e-01,            6.33544059591028741704251380359792317e-01},\n+            {2.33572976827208893257914468222224968e-02,            2.33530509808936286709795071423335732e-02},\n+            {7.51392746195329142011587464367039502e-01,            6.35979110106607807348963004903609067e-01},\n+            {7.51649175412362091641682582121575251e-01,            6.36131796640758591543062918907122080e-01},\n+            {7.62560692649938864917658065678551793e-01,            6.42582785959772486552828548950126373e-01},\n+            {7.64660852335945273594575155584607273e-01,            6.43814099671361386286313072270915932e-01},\n+            {1.92871093750000000000000000000000000e-01,            1.90514597602311764623059750704793759e-01},\n+            {2.43864313521849479515779535176989157e-02,            2.43815983142663741885939851467013521e-02},\n+            {3.97705078125000000000000000000000000e-01,            3.77983627858614640283948547303348236e-01},\n+            {7.98034667968750000000000000000000000e-01,            6.62936606884708330125541187161682941e-01},\n+            {7.99316406250000000000000000000000000e-01,            6.63654430152659513562528989372441102e-01},\n+            {1.99890136718750000000000000000000000e-01,            1.97269734600247465099938891830640889e-01},\n+            {2.00000000008910994164779140191967599e-01,            1.97375320233467849151455260287892058e-01},\n+            {4.00000000093461316463816501709516160e-01,            3.79948962335194012629557116519596150e-01},\n+            {2.00000000069810862646235705142316874e-01,            1.97375320291995240418209079080646997e-01},\n+            {1.00000000056612609045103567950718571e-01,            9.96679946810060529704707312198636589e-02},\n+            {1.00000000080404896629637789828848327e-01,            9.96679947045619948897444345018478492e-02},\n+            {1.66666666666666696272613990004174411e+00,            9.31109608667577693190680177920119455e-01},\n+            {1.31034851074218750000000000000000000e-02,            1.31027351970209980614612589861988504e-02},\n+            {8.43444227005861080215254332870244980e-01,            6.87629045782656322925865941652078512e-01},\n+            {4.25596815032856623517432126391213387e-01,            4.01634947321531793299729470086813678e-01},\n+            {8.54614885269050605920426733064232394e-01,            6.93472710492835200064966331725774025e-01},\n+            {8.63777419830865200722769259300548583e-01,            6.98198780318331041148483592329099127e-01},\n+            {2.70117449276632004551146337689715438e-02,            2.70051772786722224566765342032635559e-02},\n+            {2.16282487792377908775165451515931636e-01,            2.12971988592557031781365419455581001e-01},\n+            {1.73204653003120601084674490266479552e+00,            9.39297315789076214802641716736658105e-01},\n+            {2.71436010781672190650404274947504746e-02,            2.71369367992428389623549774823710978e-02},\n+            {8.69092640155437079485523099720012397e-01,            7.00912831250687651307196017605464473e-01},\n+            {2.78015136718750000000000000000000000e-02,            2.77943530651526982827985645341156701e-02},\n+            {9.10156250000000000000000000000000000e-01,            7.21207240669352050307412688531998165e-01},\n+            {2.27787862235060922788676407435559668e-01,            2.23928183342045426304404589794035157e-01},\n+            {5.71524498377538048288215577485971153e-02,            5.70903033991663026980553749418981725e-02},\n+            {3.66406250000000000000000000000000000e+00,            9.98687254335130669671645868977829517e-01},\n+            {5.72863132979952241474741470028675394e-02,            5.72237295373843844708720164610859507e-02},\n+            {1.15265335196343660095763539175095502e-01,            1.14757558082362397172277983632352767e-01},\n+            {9.22871508732805212460448274214286357e-01,            7.27253018562057912939305739474564638e-01},\n+            {1.44882202148437500000000000000000000e-02,            1.44872065663080247568859985337817684e-02},\n+            {2.33459472656250000000000000000000000e-01,            2.29308506606965514793638071915067313e-01},\n+            {4.67608948699241744328958247933769599e-01,            4.36265367328226513916944408221096440e-01},\n+            {2.34375000000000000000000000000000000e-01,            2.30175711032132981819570603563403063e-01},\n+            {2.93977526337722387672624080323657836e-02,            2.93892867747176836833509722656208701e-02},\n+            {1.89257812500000000000000000000000000e+00,            9.55597542193888546329823463414294394e-01},\n+            {2.95798696005085230698039566732404637e-02,            2.95712454656271068251835101101858187e-02},\n+            {1.89360756176453159937977943627629429e+00,            9.55686843743833788059988471898348142e-01},\n+            {4.74943000289441419337066463413066231e-01,            4.42184502480986035803118250513914071e-01},\n+            {4.76562500000000000000000000000000000e-01,            4.43486412595195826790440814160101630e-01},\n+            {9.59027831303091549131067949929274619e-01,            7.43842915769532264613887042424467929e-01},\n+            {3.09784640940728682456661857713697827e-02,            3.09685582448730820784897541732374591e-02},\n+            {1.98437499999999977795539507496869192e+00,            9.62906870975765387287608356129776957e-01},\n+            {9.97205648659918675313917901803506538e-01,            7.60418100316000600203658397859135661e-01},\n+            {3.90291213989257769131913100579822640e-03,            3.90289232268659551022766662201699736e-03},\n+            {3.90481948852539019131913100579822640e-03,            3.90479964225138860483705936617354227e-03},\n+            {3.12423706054687500000000000000000000e-02,            3.12322094954161727499363714231262395e-02},\n+            {3.90535406768321947598709975579822640e-03,            3.90533421325712750455622728849037270e-03},\n+            {7.81154632568359288263826201159645279e-03,            7.81138744204279466358299901763388375e-03},\n+            {1.24999789521095569511111023075500270e-01,            1.24352794547462473786771370350680283e-01},\n+            {9.99999444341875043384959553804947063e-01,            7.61593922593510941370556728778707492e-01},\n+            {9.99999895691871532044103787484345958e-01,            7.61594112149023829770882693858011645e-01},\n+            {2.49999998130078865399283927217766177e-01,            2.44918660645955495851244772320875652e-01},\n+            {2.49999998603016110321206610933586489e-01,            2.44918661090523528987141309434443089e-01},\n+            {4.99999999970896114032115065128891729e-01,            4.62117157237121073362068671381593592e-01},\n+            {9.99999999999829358721115113439736888e-01,            7.61594155955693223160706417649502130e-01},\n+            {3.12499999999979183318288278314867057e-02,            3.12398314460291771315638233977623908e-02},\n+            {6.24999999999973701592104191604448715e-02,            6.24187467475098948954758673929811576e-02},\n+            {9.99999999999998556710067987296497449e-01,            7.61594155955764281974719327416526334e-01},\n+            {1.27999999999999971578290569595992565e+02,            1.00000000000000000000000000000000000e+00},\n+            {3.44827586206896546938693859374325257e-02,            3.44690977543900329082306735053903756e-02},\n+            {6.89655172413793093877387718748650514e-02,            6.88563859490195017187269420471893052e-02},\n+            {1.03448275862068964081608157812297577e-01,            1.03080829858086020470241143281488892e-01},\n+            {1.37931034482758618775477543749730103e-01,            1.37062928881132531260309423128680656e-01},\n+            {1.72413793103448287347134737501619384e-01,            1.70725445282084714146447066718646674e-01},\n+            {2.06896551724137955918791931253508665e-01,            2.03994088403983264406130799853712156e-01},\n+            {2.41379310344827624490449125005397946e-01,            2.36798141876826809207868665407968027e-01},\n+            {2.75862068965517293062106318757287227e-01,            2.69071023201531202536913498454407638e-01},\n+            {3.10344827586206961633763512509176508e-01,            3.00750767242988858303859696730149916e-01},\n+            {3.44827586206896630205420706261065789e-01,            3.31780427497542984412066808006924260e-01},\n+            {3.79310344827586298777077900012955070e-01,            3.62108391409330839416919529705937418e-01},\n+            {4.13793103448275967348735093764844351e-01,            3.91688608393346163715111892758489641e-01},\n+            {4.48275862068965635920392287516733631e-01,            4.20480731486975012003415012347372452e-01},\n+            {4.82758620689655304492049481268622912e-01,            4.48450175615929701255698232730127770e-01},\n+            {5.17241379310344973063706675020512193e-01,            4.75568097261544496368767486763625886e-01},\n+            {5.51724137931034586124212637514574453e-01,            5.01811301809605377924874787743959204e-01},\n+            {5.86206896551724199184718600008636713e-01,            5.27162086020673527345538794213535134e-01},\n+            {6.20689655172413812245224562502698973e-01,            5.51608023880856575817362987825134405e-01},\n+            {6.55172413793103425305730524996761233e-01,            5.75141704579102279221464447290041163e-01},\n+            {6.89655172413793038366236487490823492e-01,            5.97760431534850182076591161239096491e-01},\n+            {7.24137931034482651426742449984885752e-01,            6.19465891301270655454827665546029664e-01},\n+            {7.58620689655172264487248412478948012e-01,            6.40263800834536321750527885396253899e-01},\n+            {7.93103448275861877547754374973010272e-01,            6.60163541092833363676687202005166905e-01},\n+            {8.27586206896551490608260337467072532e-01,            6.79177784255529339466238655218797135e-01},\n+            {8.62068965517241103668766299961134791e-01,            6.97322121077226884958095667604561029e-01},\n+            {8.96551724137930716729272262455197051e-01,            7.14614694054361357412620518070189428e-01},\n+            {9.31034482758620329789778224949259311e-01,            7.31075841220047215751737025073520835e-01},\n+            {9.65517241379309942850284187443321571e-01,            7.46727754527182387965057729340710925e-01},\n+            {9.99999999999999555910790149937383831e-01,            7.61594155955764701613384757931622516e-01},\n+            {1.26765060022822940149670320537600000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.33436905287182034855574634496000000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.40108750551541129561478948454400000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.46780595815900224267383262412800000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.53452441080259318973287576371200000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.60124286344618413679191890329600000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.66796131608977508385096204288000000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.73467976873336603091000518246400000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.80139822137695697796904832204800000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.86811667402054792502809146163200000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.93483512666413887208713460121600000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.00155357930772981914617774080000000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.06827203195132076620522088038400000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.13499048459491171326426401996800000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.20170893723850266032330715955200000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.26842738988209360738235029913600000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.33514584252568455444139343872000000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.40186429516927550150043657830400000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.46858274781286644855947971788800000e+30,            1.00000000000000000000000000000000000e+00},\n+            {2.53530120045645739561852285747200000e+30,            1.00000000000000000000000000000000000e+00},\n+            {1.60693804425899027554196209234116260e+60,            1.00000000000000000000000000000000000e+00},\n+            {1.69151373079893703825155926128281056e+60,            1.00000000000000000000000000000000000e+00},\n+            {1.77608941733888380096115643022445853e+60,            1.00000000000000000000000000000000000e+00},\n+            {1.86066510387883056367075359916610649e+60,            1.00000000000000000000000000000000000e+00},\n+            {1.94524079041877732638035076810775445e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.02981647695872408908994793704940241e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.11439216349867085179954510599105038e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.19896785003861761450914227493269834e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.28354353657856437721873944387434630e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.36811922311851113992833661281599426e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.45269490965845790263793378175764222e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.53727059619840466534753095069929019e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.62184628273835142805712811964093815e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.70642196927829819076672528858258611e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.79099765581824495347632245752423407e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.87557334235819171618591962646588203e+60,            1.00000000000000000000000000000000000e+00},\n+            {2.96014902889813847889551679540753000e+60,            1.00000000000000000000000000000000000e+00},\n+            {3.04472471543808524160511396434917796e+60,            1.00000000000000000000000000000000000e+00},\n+            {3.12930040197803200431471113329082592e+60,            1.00000000000000000000000000000000000e+00},\n+            {3.21387608851797876702430830223247388e+60,            1.00000000000000000000000000000000000e+00},\n+            {1.07150860718626732094842504906000181e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.12790379703817606470289337889334663e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.18429898689008480845736170872669145e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.24069417674199355221183003856003627e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.29708936659390229596629836839338109e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.35348455644581103972076669822672591e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.40987974629771978347523502806007073e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.46627493614962852722970335789341555e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.52267012600153727098417168772676037e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.57906531585344601473864001756010519e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.63546050570535475849310834739345001e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.69185569555726350224757667722679483e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.74825088540917224600204500706013965e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.80464607526108098975651333689348447e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.86104126511298973351098166672682928e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.91743645496489847726544999656017410e+301,           1.00000000000000000000000000000000000e+00},\n+            {1.97383164481680722101991832639351892e+301,           1.00000000000000000000000000000000000e+00},\n+            {2.03022683466871596477438665622686374e+301,           1.00000000000000000000000000000000000e+00},\n+            {2.08662202452062470852885498606020856e+301,           1.00000000000000000000000000000000000e+00},\n+            {2.14301721437253345228332331589355338e+301,           1.00000000000000000000000000000000000e+00},\n+            {4.94065645841246544176568792868221372e-324,           4.94065645841246544176568792868221372e-324},\n+            {4.94065645841246544176568792868221372e-324,           4.94065645841246544176568792868221372e-324},\n+            {4.99999999999999944488848768742172979e-01,            4.62117157260009714845699443492203290e-01},\n+            {5.00000000000000000000000000000000000e-01,            4.62117157260009758502318483643672557e-01},\n+            {5.00000000000000111022302462515654042e-01,            4.62117157260009845815556563946604302e-01},\n+            {5.49306144334054669009503868437604979e-01,            4.99999999999999867483910937482244858e-01},\n+            {5.49306144334054780031806330953259021e-01,            4.99999999999999950750637784368995452e-01},\n+            {5.49306144334054891054108793468913063e-01,            5.00000000000000034017364631255736851e-01},\n+            {2.19999999999999964472863211994990706e+01,            9.99999999999999999844377355177323009e-01},\n+            {2.20000000000000000000000000000000000e+01,            9.99999999999999999844377355177324068e-01},\n+            {2.20000000000000035527136788005009294e+01,            9.99999999999999999844377355177325223e-01},\n+            {6.93147180559945397249066445510834455e-01,            6.00000000000000056212373967393698031e-01},\n+            {6.93147180559945286226763982995180413e-01,            5.99999999999999985158100391383682202e-01},\n+            {6.93147180559945175204461520479526371e-01,            5.99999999999999914103826815373657032e-01},\n+            {3.46573590279972698624533222755417228e-01,            3.33333333333333372369704144023402903e-01},\n+            {3.46573590279972643113381991497590207e-01,            3.33333333333333323026458605127557235e-01},\n+            {3.46573590279972587602230760239763185e-01,            3.33333333333333273683213066231709688e-01},\n+            {1.73286795139986349312266611377708614e-01,            1.71572875253809923708199182915954510e-01},\n+            {1.73286795139986321556690995748795103e-01,            1.71572875253809896769671427846052946e-01},\n+            {1.73286795139986293801115380119881593e-01,            1.71572875253809869831143672776151118e-01},\n+            {8.66433975699931746561333056888543069e-02,            8.64272337258898029408455765418952337e-02},\n+            {8.66433975699931607783454978743975516e-02,            8.64272337258897891667202185946638536e-02},\n+            {8.66433975699931469005576900599407963e-02,            8.64272337258897753925948606474324374e-02},\n+            {4.33216987849965873280666528444271535e-02,            4.32946174993891841617996586480128793e-02},\n+            {4.33216987849965803891727489371987758e-02,            4.32946174993891772359121833444914284e-02},\n+            {4.33216987849965734502788450299703982e-02,            4.32946174993891703100247080409699774e-02},\n+            {2.16608493924982936640333264222135767e-02,            2.16574623262262954492383391751347008e-02},\n+            {2.16608493924982901945863744685993879e-02,            2.16574623262262919814187163069359478e-02},\n+            {2.16608493924982867251394225149851991e-02,            2.16574623262262885135990934387371889e-02},\n+            {2.16608493924982867251394225149851991e-02,            2.16574623262262885135990934387371889e-02},\n+            {2.16608493924982901945863744685993879e-02,            2.16574623262262919814187163069359478e-02},\n+            {2.16608493924982936640333264222135767e-02,            2.16574623262262954492383391751347008e-02},\n+            {4.33216987849965734502788450299703982e-02,            4.32946174993891703100247080409699774e-02},\n+            {4.33216987849965803891727489371987758e-02,            4.32946174993891772359121833444914284e-02},\n+            {4.33216987849965873280666528444271535e-02,            4.32946174993891841617996586480128793e-02},\n+            {8.66433975699931469005576900599407963e-02,            8.64272337258897753925948606474324374e-02},\n+            {8.66433975699931607783454978743975516e-02,            8.64272337258897891667202185946638536e-02},\n+            {8.66433975699931746561333056888543069e-02,            8.64272337258898029408455765418952337e-02},\n+            {1.73286795139986293801115380119881593e-01,            1.71572875253809869831143672776151118e-01},\n+            {1.73286795139986321556690995748795103e-01,            1.71572875253809896769671427846052946e-01},\n+            {1.73286795139986349312266611377708614e-01,            1.71572875253809923708199182915954510e-01},\n+            {3.46573590279972587602230760239763185e-01,            3.33333333333333273683213066231709688e-01},\n+            {3.46573590279972643113381991497590207e-01,            3.33333333333333323026458605127557235e-01},\n+            {3.46573590279972698624533222755417228e-01,            3.33333333333333372369704144023402903e-01},\n+            {6.93147180559945175204461520479526371e-01,            5.99999999999999914103826815373657032e-01},\n+            {6.93147180559945286226763982995180413e-01,            5.99999999999999985158100391383682202e-01},\n+            {6.93147180559945397249066445510834455e-01,            6.00000000000000056212373967393698031e-01},\n+            {7.09782712893383859409368596971035004e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.09782712893383973096206318587064743e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.09782712893384086783044040203094482e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.41782712893384086783044040203094482e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.41782712893383973096206318587064743e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.41782712893383859409368596971035004e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.10475860073943749739555642008781433e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.10475860073943863426393363624811172e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.10475860073943977113231085240840912e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.09782712893384086783044040203094482e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.09782712893383973096206318587064743e+02,            1.00000000000000000000000000000000000e+00},\n+            {7.09782712893383859409368596971035004e+02,            1.00000000000000000000000000000000000e+00},\n+            {9.22337203685477478400000000000000000e+18,            1.00000000000000000000000000000000000e+00},\n+            {9.22337203685477580800000000000000000e+18,            1.00000000000000000000000000000000000e+00},\n+            {9.22337203685477785600000000000000000e+18,            1.00000000000000000000000000000000000e+00},\n+            {1.34217727999999985098838806152343750e+08,            1.00000000000000000000000000000000000e+00},\n+            {1.34217728000000000000000000000000000e+08,            1.00000000000000000000000000000000000e+00},\n+            {1.34217728000000029802322387695312500e+08,            1.00000000000000000000000000000000000e+00},\n+            {1.67772159999999981373548507690429688e+07,            1.00000000000000000000000000000000000e+00},\n+            {1.67772160000000000000000000000000000e+07,            1.00000000000000000000000000000000000e+00},\n+            {1.67772160000000037252902984619140625e+07,            1.00000000000000000000000000000000000e+00},\n+            {3.19999999999999964472863211994990706e+01,            9.99999999999999999999999999679237812e-01},\n+            {3.20000000000000000000000000000000000e+01,            9.99999999999999999999999999679237812e-01},\n+            {3.20000000000000071054273576010018587e+01,            9.99999999999999999999999999679237812e-01},\n+            {1.59999999999999982236431605997495353e+01,            9.99999999999974671668901811879331665e-01},\n+            {1.60000000000000000000000000000000000e+01,            9.99999999999974671668901811969315927e-01},\n+            {1.60000000000000035527136788005009294e+01,            9.99999999999974671668901812149284547e-01},\n+            {7.99999999999999911182158029987476766e+00,            9.99999774929675889809619027791781323e-01},\n+            {8.00000000000000000000000000000000000e+00,            9.99999774929675889810018832956368404e-01},\n+            {8.00000000000000177635683940025046468e+00,            9.99999774929675889810818443285542469e-01},\n+            {3.99999999999999955591079014993738383e+00,            9.99329299739067043196741615068852355e-01},\n+            {4.00000000000000000000000000000000000e+00,            9.99329299739067043792243344341724993e-01},\n+            {4.00000000000000088817841970012523234e+00,            9.99329299739067044983246802887468536e-01},\n+            {1.99999999999999977795539507496869192e+00,            9.64027580075816868258779231952432911e-01},\n+            {2.00000000000000000000000000000000000e+00,            9.64027580075816883946413724100923171e-01},\n+            {2.00000000000000044408920985006261617e+00,            9.64027580075816915321682708397883469e-01},\n+            {9.99999999999999888977697537484345958e-01,            7.61594155955764841492939901436512668e-01},\n+            {1.00000000000000000000000000000000000e+00,            7.61594155955764888119458282604793657e-01},\n+            {1.00000000000000022204460492503130808e+00,            7.61594155955764981372495044941331753e-01},\n+            {4.99999999999999944488848768742172979e-01,            4.62117157260009714845699443492203290e-01},\n+            {5.00000000000000000000000000000000000e-01,            4.62117157260009758502318483643672557e-01},\n+            {5.00000000000000111022302462515654042e-01,            4.62117157260009845815556563946604302e-01},\n+            {2.49999999999999972244424384371086489e-01,            2.44918662403709103187147915631612892e-01},\n+            {2.50000000000000000000000000000000000e-01,            2.44918662403709129277801131491016945e-01},\n+            {2.50000000000000055511151231257827021e-01,            2.44918662403709181459107563209824042e-01},\n+            {1.24999999999999986122212192185543245e-01,            1.24353001771596194391460985792144305e-01},\n+            {1.25000000000000000000000000000000000e-01,            1.24353001771596208054647275805892707e-01},\n+            {1.25000000000000027755575615628913511e-01,            1.24353001771596235381019855833389378e-01},\n+            {6.24999999999999930611060960927716224e-02,            6.24187467475125075782836114480350829e-02},\n+            {6.25000000000000000000000000000000000e-02,            6.24187467475125144901428911942113317e-02},\n+            {6.25000000000000138777878078144567553e-02,            6.24187467475125283138614506865638292e-02},\n+            {3.12499999999999965305530480463858112e-02,            3.12398314460312533021176543496182149e-02},\n+            {3.12500000000000000000000000000000000e-02,            3.12398314460312567681786791091369499e-02},\n+            {3.12500000000000069388939039072283776e-02,            3.12398314460312637003007286281744168e-02},\n+            {1.56249999999999982652765240231929056e-02,            1.56237285584088634680488027509294906e-02},\n+            {1.56250000000000000000000000000000000e-02,            1.56237285584088652023488311762919065e-02},\n+            {1.56250000000000034694469519536141888e-02,            1.56237285584088686709488880270167445e-02},\n+            {6.10351562499999932237364219655972875e-05,            6.10351561742087681889301535131725312e-05},\n+            {6.10351562500000000000000000000000000e-05,            6.10351561742087749651937063040263414e-05},\n+            {6.10351562500000135525271560688054251e-05,            6.10351561742087885177208118857339557e-05},\n+            {9.31322574615478412227423430871540641e-10,            9.31322574615478411958158908556102005e-10},\n+            {9.31322574615478515625000000000000000e-10,            9.31322574615478515355735477684561274e-10},\n+            {9.31322574615478722420153138256918718e-10,            9.31322574615478722150888615941479902e-10},\n+            {2.77555756156289104291028806826931429e-17,            2.77555756156289104291028806826931349e-17},\n+            {2.77555756156289135105907917022705078e-17,            2.77555756156289135105907917022704998e-17},\n+            {2.77555756156289196735666137414252376e-17,            2.77555756156289196735666137414252322e-17},\n+            {1.79769313486231570814527423731704357e+308,           1.00000000000000000000000000000000000e+00},\n+            {1.79769313486231570814527423731704357e+308,           1.00000000000000000000000000000000000e+00},\n+            {1.79769313486231570814527423731704357e+308,           1.00000000000000000000000000000000000e+00},\n+            {1.79769313486231550856124328384506240e+308,           1.00000000000000000000000000000000000e+00},\n+            {3.14159265358979311599796346854418516e+00,            9.96272076220749943353314537833579484e-01},\n+            {1.57079632679489655799898173427209258e+00,            9.17152335667274336647462811870662140e-01},\n+            {1.00000000000000022204460492503130808e+00,            7.61594155955764981372495044941331753e-01},\n+            {1.00000000000000000000000000000000000e+00,            7.61594155955764888119458282604793657e-01},\n+            {9.99999999999999888977697537484345958e-01,            7.61594155955764841492939901436512668e-01},\n+            {7.85398163397448278999490867136046290e-01,            6.55794202632672418203926030568705821e-01},\n+            {2.22507385850720187715587855857894824e-308,           2.22507385850720187715587855857894824e-308},\n+            {2.22507385850720138309023271733240406e-308,           2.22507385850720138309023271733240406e-308},\n+            {2.22507385850720088902458687608585989e-308,           2.22507385850720088902458687608585989e-308},\n+            {2.22507385850720039495894103483931571e-308,           2.22507385850720039495894103483931571e-308},\n+            {9.88131291682493088353137585736442745e-324,           9.88131291682493088353137585736442745e-324},\n+            {4.94065645841246544176568792868221372e-324,           4.94065645841246544176568792868221372e-324},\n+        };\n+\n+        for (int i = 0; i < testCases.length; i++) {\n+            double[] testCase = testCases[i];\n+            failures += testTanhCaseWithUlpDiff(testCase[0],\n+                    testCase[1],\n+                    3.0);\n+        }\n+\n","filename":"test\/jdk\/java\/lang\/Math\/HyperbolicTests.java","additions":395,"deletions":1,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpServer;\n@@ -27,0 +29,2 @@\n+import jdk.test.lib.util.FileUtils;\n+import sun.net.www.ParseUtil;\n@@ -28,0 +32,1 @@\n+import java.io.Closeable;\n@@ -29,0 +34,2 @@\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n@@ -30,3 +37,11 @@\n-import java.nio.file.*;\n-\n-import java.security.Provider;\n+import java.lang.reflect.Method;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.nio.CharBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n@@ -34,0 +49,1 @@\n+import java.time.Instant;\n@@ -35,1 +51,0 @@\n-import java.util.Arrays;\n@@ -37,1 +52,8 @@\n-import java.util.Optional;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -41,2 +63,4 @@\n- * @summary Throw error if default java.security file is missing\n- * @bug 8155246 8292297 8292177 8281658\n+ * @summary Tests security properties passed through java.security,\n+ *   java.security.properties or included from other properties files.\n+ * @bug 8155246 8292297 8292177 8281658 8319332\n+ * @modules java.base\/sun.net.www\n@@ -46,0 +70,1 @@\n+\n@@ -47,0 +72,47 @@\n+    static final String SEPARATOR_THIN = \"----------------------------\";\n+\n+    private static void printTestHeader(String testName) {\n+        System.out.println();\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println(testName);\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 1 && Executor.RUNNER_ARG.equals(args[0])) {\n+            \/\/ Executed by a test-launched JVM.\n+            \/\/ Force the initialization of java.security.Security.\n+            Security.getProviders();\n+            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n+            System.out.println(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                    Security.getProperty(FilesManager.LAST_FILE_PROP_NAME));\n+            assertTestSecuritySetPropertyShouldNotInclude();\n+        } else {\n+            \/\/ Executed by the test JVM.\n+            try (FilesManager filesMgr = new FilesManager()) {\n+                for (Method m : ConfigFileTest.class.getDeclaredMethods()) {\n+                    if (m.getName().startsWith(\"test\")) {\n+                        printTestHeader(m.getName());\n+                        Executor.run(m, filesMgr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Success cases\n+     *\/\n+\n+    static void testShowSettings(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Sanity test passing the -XshowSettings:security option.\n+        ex.addJvmArg(\"-XshowSettings:security\");\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Security properties:\")\n+                .shouldContain(\"Security provider static configuration:\")\n+                .shouldContain(\"Security TLS configuration\");\n+    }\n@@ -48,2 +120,7 @@\n-    private static final String EXPECTED_DEBUG_OUTPUT =\n-        \"Initial security property: crypto.policy=unlimited\";\n+    static void testIncludeBasic(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+        PropsFile file2 = filesMgr.newFile(\"dir1\/dir2\/file2.properties\");\n@@ -51,2 +128,3 @@\n-    private static final String UNEXPECTED_DEBUG_OUTPUT =\n-            \"Initial security property: postInitTest=shouldNotRecord\";\n+        masterFile.addAbsoluteInclude(file0);\n+        extraFile.addRelativeInclude(file2);\n+        file2.addAbsoluteInclude(file1);\n@@ -54,1 +132,4 @@\n-    private static boolean overrideDetected = false;\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, Executor.ExtraMode.FILE_URI, false);\n+        ex.assertSuccess();\n+    }\n@@ -56,2 +137,5 @@\n-    private static Path COPY_JDK_DIR = Path.of(\".\/jdk-8155246-tmpdir\");\n-    private static Path COPIED_JAVA = COPY_JDK_DIR.resolve(\"bin\", \"java\");\n+    static void testRepeatedInclude(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n@@ -59,12 +143,64 @@\n-    public static void main(String[] args) throws Exception {\n-        Path copyJdkDir = Path.of(\".\/jdk-8155246-tmpdir\");\n-        Path copiedJava = Optional.of(\n-                        Path.of(copyJdkDir.toString(), \"bin\", \"java\"))\n-                .orElseThrow(() -> new RuntimeException(\"Unable to locate new JDK\")\n-                );\n-\n-        if (args.length == 1) {\n-            \/\/ set up is complete. Run code to exercise loading of java.security\n-            Provider[] provs = Security.getProviders();\n-            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n-            System.out.println(Arrays.toString(provs) + \"NumProviders: \" + provs.length);\n+        masterFile.addAbsoluteInclude(file0);\n+        masterFile.addAbsoluteInclude(file1);\n+        masterFile.addAbsoluteInclude(file0);\n+        file1.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testIncludeWithOverrideAll(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        masterFile.addRelativeInclude(file0);\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void extraPropertiesByHelper(Executor ex, FilesManager filesMgr,\n+            Executor.ExtraMode mode) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, mode, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testExtraPropertiesByPathAbsolute(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_ABS);\n+    }\n+\n+    static void testExtraPropertiesByPathRelative(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_REL);\n+    }\n+\n+    static void specialCharsIncludes(Executor ex, FilesManager filesMgr,\n+            char specialChar, Executor.ExtraMode extraMode,\n+            boolean useRelativeIncludes) throws Exception {\n+        String suffix = specialChar + \".properties\";\n+        ExtraPropsFile extraFile;\n+        PropsFile file0, file1;\n+        try {\n+            extraFile = filesMgr.newExtraFile(\"extra\" + suffix);\n+            file0 = filesMgr.newFile(\"file0\" + suffix);\n+            file1 = filesMgr.newFile(\"file1\" + suffix);\n+        } catch (InvalidPathException ipe) {\n+            \/\/ The platform encoding may not allow to create files with some\n+            \/\/ special characters. Skip the test in these cases.\n+            return;\n+        }\n+\n+        if (useRelativeIncludes) {\n+            extraFile.addRelativeInclude(file0);\n@@ -72,52 +208,150 @@\n-            Files.createDirectory(copyJdkDir);\n-            Path jdkTestDir = Path.of(Optional.of(System.getProperty(\"test.jdk\"))\n-                            .orElseThrow(() -> new RuntimeException(\"Couldn't load JDK Test Dir\"))\n-            );\n-\n-            copyJDK(jdkTestDir, copyJdkDir);\n-            String extraPropsFile = Path.of(System.getProperty(\"test.src\"), \"override.props\").toString();\n-\n-            \/\/ sanity test -XshowSettings:security option\n-            exerciseShowSettingsSecurity(buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-XshowSettings:security\", \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ exercise some debug flags while we're here\n-            \/\/ regular JDK install - should expect success\n-            exerciseSecurity(0, \"java\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\", \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ given an overriding security conf file that doesn't exist, we shouldn't\n-            \/\/ overwrite the properties from original\/master security conf file\n-            exerciseSecurity(0, \"SUN version\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"-Djava.security.properties==file:\/\/\/\" + extraPropsFile + \"badFileName\",\n-                    \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ test JDK launch with customized properties file\n-            exerciseSecurity(0, \"NumProviders: 6\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"-Djava.security.properties==file:\/\/\/\" + extraPropsFile,\n-                    \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ delete the master conf file\n-            Files.delete(Path.of(copyJdkDir.toString(), \"conf\",\n-                    \"security\",\"java.security\"));\n-\n-            \/\/ launch JDK without java.security file being present or specified\n-            exerciseSecurity(1, \"Error loading java.security file\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ test the override functionality also. Should not be allowed since\n-            \/\/ \"security.overridePropertiesFile=true\" Security property is missing.\n-            exerciseSecurity(1, \"Error loading java.security file\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"-Djava.security.properties==file:\/\/\/\" + extraPropsFile, \"ConfigFileTest\", \"runner\"));\n-\n-            if (!overrideDetected) {\n-                throw new RuntimeException(\"Override scenario not seen\");\n+            extraFile.addAbsoluteInclude(file0);\n+        }\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, extraMode, false);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testUnicodeIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testUnicodeIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testUnicodeIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testUnicodeIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void testSpaceIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testSpaceIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testSpaceIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testSpaceIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void notOverrideOnFailureHelper(Executor ex, FilesManager filesMgr,\n+            String nonExistentExtraFile) throws Exception {\n+        \/\/ An overriding extra properties file that does not exist\n+        \/\/ should not erase properties from the master file.\n+        ex.setIgnoredExtraFile(nonExistentExtraFile, true);\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer().shouldContain(\"unable to load security \" +\n+                \"properties from \" + nonExistentExtraFile);\n+    }\n+\n+    static void testNotOverrideOnEmptyFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"\");\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Empty extra properties file path\");\n+    }\n+\n+    static void testNotOverrideOnURLFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr,\n+                \"file:\/\/\/nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnPathFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnDirFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/\");\n+        ex.getOutputAnalyzer().shouldContain(\"Is a directory\");\n+    }\n+\n+    static void testNotOverrideOnBadFileURLFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/%00\");\n+    }\n+\n+    static void testDisabledExtraPropertiesFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        masterFile.addRawProperty(\"security.overridePropertiesFile\", \"false\");\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setIgnoredExtraFile(file0.path.toString(), true);\n+        ex.assertSuccess();\n+    }\n+\n+    static final String SECURITY_SET_PROP_FILE_PATH =\n+            \"testSecuritySetPropertyShouldNotInclude.propsFilePath\";\n+\n+    static void testSecuritySetPropertyShouldNotInclude(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        ex.addSystemProp(SECURITY_SET_PROP_FILE_PATH, file0.path.toString());\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void assertTestSecuritySetPropertyShouldNotInclude() {\n+        \/\/ This check is executed by the launched JVM.\n+        String propsFilePath = System.getProperty(SECURITY_SET_PROP_FILE_PATH);\n+        if (propsFilePath != null) {\n+            String name = Path.of(propsFilePath).getFileName().toString();\n+            String setPropInvokeRepr = \"Security.setProperty(\\\"include\\\", \" +\n+                    \"\\\"\" + propsFilePath + \"\\\")\";\n+            try {\n+                Security.setProperty(\"include\", propsFilePath);\n+                throw new RuntimeException(setPropInvokeRepr + \" was \" +\n+                        \"expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n+            if (FilesManager.APPLIED_PROP_VALUE.equals(\n+                    Security.getProperty(name))) {\n+                throw new RuntimeException(setPropInvokeRepr + \" caused \" +\n+                        \"a file inclusion.\");\n@@ -125,0 +359,5 @@\n+            try {\n+                Security.getProperty(\"include\");\n+                throw new RuntimeException(\"Security.getProperty(\\\"include\\\")\" +\n+                        \" was expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n@@ -128,5 +367,16 @@\n-    private static ProcessBuilder buildCommand(String... command) {\n-        ArrayList<String> args = new ArrayList<>();\n-        args.add(COPIED_JAVA.toString());\n-        Collections.addAll(args, Utils.prependTestJavaOpts(command));\n-        return new ProcessBuilder(args);\n+    \/*\n+     * Error cases\n+     *\/\n+\n+    static void testCannotResolveRelativeFromHTTPServed(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n+        ex.assertError(\"InternalError: Cannot resolve '\" + file0.fileName +\n+                \"' relative path when included from a non-regular \" +\n+                \"properties file (e.g. HTTP served file)\");\n@@ -135,4 +385,10 @@\n-    private static void exerciseSecurity(int exitCode, String output, ProcessBuilder process) throws Exception {\n-        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n-        oa.shouldHaveExitValue(exitCode)\n-                .shouldContain(output);\n+    static void testCannotIncludeCycles(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        \/\/ Includes chain: master -> file0 -> file1 -> master.\n+        file1.addRelativeInclude(masterFile);\n+        file0.addRelativeInclude(file1);\n+        masterFile.addRelativeInclude(file0);\n@@ -140,8 +396,88 @@\n-        \/\/ extra checks on debug output\n-        if (exitCode != 1) {\n-            if (oa.getStderr().contains(\"overriding other security properties files!\")) {\n-                overrideDetected = true;\n-                \/\/ master file is not in use - only provider properties are set in custom file\n-                oa.shouldContain(\"security.provider.2=SunRsaSign\")\n-                        .shouldNotContain(EXPECTED_DEBUG_OUTPUT)\n-                        .shouldNotContain(UNEXPECTED_DEBUG_OUTPUT);\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\n+                \"InternalError: Cyclic include of '\" + masterFile.path + \"'\");\n+    }\n+\n+    static void testCannotIncludeURL(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+\n+        masterFile.addRawProperty(\"include\", extraFile.url.toString());\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\"InternalError: Unable to include 'http:\/\/127.0.0.1:\");\n+    }\n+\n+    static void testCannotIncludeNonexistentFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+\n+        String nonexistentPath = \"\/nonExistentFile.properties\";\n+        masterFile.addRawProperty(\"include\", nonexistentPath);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\n+                \"InternalError: Unable to include '\" + nonexistentPath + \"'\");\n+    }\n+\n+    static void testMustHaveMasterFile(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present.\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+\n+    static void testMustHaveMasterFileEvenWithExtraFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present, but with an\n+        \/\/ extra file passed. Since the \"security.overridePropertiesFile=true\"\n+        \/\/ security property is missing, it should fail anyway.\n+        ex.setExtraFile(\n+                filesMgr.newExtraFile(), Executor.ExtraMode.FILE_URI, true);\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+}\n+\n+sealed class PropsFile permits ExtraPropsFile {\n+    protected static final class Include {\n+        final PropsFile propsFile;\n+        final String value;\n+\n+        private Include(PropsFile propsFile, String value) {\n+            this.propsFile = propsFile;\n+            this.value = value;\n+        }\n+\n+        static Include of(PropsFile propsFile) {\n+            return new Include(propsFile, propsFile.path.toString());\n+        }\n+\n+        static Include of(PropsFile propsFile, String value) {\n+            return new Include(propsFile, value);\n+        }\n+    }\n+\n+    protected final List<Include> includes = new ArrayList<>();\n+    protected final PrintWriter writer;\n+    protected boolean includedFromExtra = false;\n+    final String fileName;\n+    final Path path;\n+\n+    PropsFile(String fileName, Path path) throws IOException {\n+        this.fileName = fileName;\n+        this.path = path;\n+        this.writer = new PrintWriter(Files.newOutputStream(path,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND), true);\n+    }\n+\n+    private static String escape(String text, boolean escapeSpace) {\n+        StringBuilder sb = new StringBuilder(text.length());\n+        CharBuffer cb = CharBuffer.wrap(text);\n+        while (cb.hasRemaining()) {\n+            char c = cb.get();\n+            if (c == '\\\\' || escapeSpace && c == ' ') {\n+                sb.append('\\\\');\n+            }\n+            if (Character.UnicodeBlock.of(c) ==\n+                    Character.UnicodeBlock.BASIC_LATIN) {\n+                sb.append(c);\n@@ -149,2 +485,1 @@\n-                oa.shouldContain(EXPECTED_DEBUG_OUTPUT)\n-                        .shouldNotContain(UNEXPECTED_DEBUG_OUTPUT);\n+                sb.append(\"\\\\u%04x\".formatted((int) c));\n@@ -153,0 +488,1 @@\n+        return sb.toString();\n@@ -155,7 +491,61 @@\n-    \/\/ exercise the -XshowSettings:security launcher\n-    private static void exerciseShowSettingsSecurity(ProcessBuilder process) throws Exception {\n-        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n-        oa.shouldHaveExitValue(0)\n-                .shouldContain(\"Security properties:\")\n-                .shouldContain(\"Security provider static configuration:\")\n-                .shouldContain(\"Security TLS configuration\");\n+    private void addRawProperty(String key, String value, String sep) {\n+        writer.println(escape(key, true) + sep + escape(value, false));\n+    }\n+\n+    protected void addIncludeDefinition(Include include) {\n+        if (include.propsFile instanceof ExtraPropsFile) {\n+            throw new RuntimeException(\"ExtraPropsFile should not be included\");\n+        }\n+        includes.add(include);\n+        addRawProperty(\"include\", include.value, \" \");\n+    }\n+\n+    void addComment(String comment) {\n+        writer.println(\"# \" + comment);\n+    }\n+\n+    void addRawProperty(String key, String value) {\n+        addRawProperty(key, value, \"=\");\n+    }\n+\n+    void addAbsoluteInclude(PropsFile propsFile) {\n+        addIncludeDefinition(Include.of(propsFile));\n+    }\n+\n+    void addRelativeInclude(PropsFile propsFile) {\n+        addIncludeDefinition(Include.of(propsFile,\n+                path.getParent().relativize(propsFile.path).toString()));\n+    }\n+\n+    void assertApplied(OutputAnalyzer oa) {\n+        oa.shouldContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            include.propsFile.assertApplied(oa);\n+            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n+            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n+        }\n+    }\n+\n+    void assertWasOverwritten(OutputAnalyzer oa) {\n+        oa.shouldNotContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            if (!include.propsFile.includedFromExtra) {\n+                include.propsFile.assertWasOverwritten(oa);\n+            }\n+            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n+            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n+        }\n+    }\n+\n+    void markAsIncludedFromExtra() {\n+        includedFromExtra = true;\n+        for (Include include : includes) {\n+            include.propsFile.markAsIncludedFromExtra();\n+        }\n+    }\n+\n+    PropsFile getLastFile() {\n+        return includes.isEmpty() ?\n+                this : includes.getLast().propsFile.getLastFile();\n@@ -164,4 +554,77 @@\n-    private static void copyJDK(Path src, Path dst) throws Exception {\n-        Files.walk(src)\n-            .skip(1)\n-            .forEach(file -> {\n+    void close() {\n+        writer.close();\n+    }\n+}\n+\n+final class ExtraPropsFile extends PropsFile {\n+    private final Map<String, String> systemProps = new LinkedHashMap<>();\n+    final URI url;\n+\n+    ExtraPropsFile(String fileName, URI url, Path path) throws IOException {\n+        super(fileName, path);\n+        this.url = url;\n+    }\n+\n+    @Override\n+    protected void addIncludeDefinition(Include include) {\n+        if (includes.isEmpty()) {\n+            String propName = \"props.fileName\";\n+            systemProps.put(propName, include.propsFile.fileName);\n+            include = Include.of(include.propsFile,\n+                    include.value.replace(include.propsFile.fileName,\n+                            \"${props.none}${\" + propName + \"}\"));\n+        }\n+        include.propsFile.markAsIncludedFromExtra();\n+        super.addIncludeDefinition(include);\n+    }\n+\n+    Map<String, String> getSystemProperties() {\n+        return Collections.unmodifiableMap(systemProps);\n+    }\n+}\n+\n+final class FilesManager implements Closeable {\n+    private static final Path ROOT_DIR =\n+            Path.of(ConfigFileTest.class.getSimpleName()).toAbsolutePath();\n+    private static final Path PROPS_DIR = ROOT_DIR.resolve(\"properties\");\n+    private static final Path JDK_DIR = ROOT_DIR.resolve(\"jdk\");\n+    private static final Path MASTER_FILE =\n+            JDK_DIR.resolve(\"conf\/security\/java.security\");\n+    private static final Path MASTER_FILE_TEMPLATE =\n+            MASTER_FILE.resolveSibling(\"java.security.template\");\n+    static final String JAVA_EXECUTABLE =\n+            JDK_DIR.resolve(\"bin\/java\").toString();\n+    static final String LAST_FILE_PROP_NAME = \"last-file\";\n+    static final String APPLIED_PROP_VALUE = \"applied\";\n+\n+    private final List<PropsFile> createdFiles;\n+    private final Set<String> fileNamesInUse;\n+    private final HttpServer httpServer;\n+    private final URI serverUri;\n+    private final long masterFileLines;\n+\n+    FilesManager() throws Exception {\n+        createdFiles = new ArrayList<>();\n+        fileNamesInUse = new HashSet<>();\n+        httpServer = HttpServer.create(\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        httpServer.createContext(\"\/\", this::handleRequest);\n+        InetSocketAddress address = httpServer.getAddress();\n+        httpServer.start();\n+        serverUri = new URI(\"http\", null, address.getHostString(),\n+                address.getPort(), null, null, null);\n+        copyJDK();\n+        try (Stream<String> s = Files.lines(MASTER_FILE_TEMPLATE)) {\n+            masterFileLines = s.count();\n+        }\n+    }\n+\n+    private static void copyJDK() throws Exception {\n+        Path testJDK = Path.of(Objects.requireNonNull(\n+                System.getProperty(\"test.jdk\"), \"unspecified test.jdk\"));\n+        if (!Files.exists(testJDK)) {\n+            throw new RuntimeException(\"test.jdk -> nonexistent JDK\");\n+        }\n+        Files.createDirectories(JDK_DIR);\n+        try (Stream<Path> pathStream = Files.walk(testJDK)) {\n+            pathStream.skip(1).forEach((Path file) -> {\n@@ -169,1 +632,2 @@\n-                    Files.copy(file, dst.resolve(src.relativize(file)), StandardCopyOption.COPY_ATTRIBUTES);\n+                    Files.copy(file, JDK_DIR.resolve(testJDK.relativize(file)),\n+                            StandardCopyOption.COPY_ATTRIBUTES);\n@@ -174,0 +638,288 @@\n+        }\n+        Files.move(MASTER_FILE, MASTER_FILE_TEMPLATE);\n+    }\n+\n+    private void handleRequest(HttpExchange x) throws IOException {\n+        String rawPath = x.getRequestURI().getRawPath();\n+        Path f = ROOT_DIR.resolve(x.getRequestURI().getPath().substring(1));\n+        int statusCode;\n+        byte[] responseBody;\n+        \/\/ Check for unescaped space, unresolved parent or backward slash.\n+        if (rawPath.matches(\"^.*( |(\\\\.|%2[Ee]){2}|\\\\\\\\|%5[Cc]).*$\")) {\n+            statusCode = HttpURLConnection.HTTP_BAD_REQUEST;\n+            responseBody = new byte[0];\n+        } else if (Files.isRegularFile(f)) {\n+            x.getResponseHeaders().add(\"Content-type\", \"text\/plain\");\n+            statusCode = HttpURLConnection.HTTP_OK;\n+            responseBody = Files.readAllBytes(f);\n+        } else {\n+            statusCode = HttpURLConnection.HTTP_NOT_FOUND;\n+            responseBody = new byte[0];\n+        }\n+        System.out.println(\"[\" + Instant.now() + \"] \" +\n+                getClass().getSimpleName() + \": \" +\n+                x.getRequestMethod() + \" \" + rawPath + \" -> \" +\n+                statusCode + \" (\" + responseBody.length + \" bytes)\");\n+        try (OutputStream responseStream = x.getResponseBody()) {\n+            x.sendResponseHeaders(statusCode, responseBody.length);\n+            responseStream.write(responseBody);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface PropsFileBuilder {\n+        PropsFile build(String fileName, Path path) throws IOException;\n+    }\n+\n+    private PropsFile newFile(Path path, PropsFileBuilder builder)\n+            throws IOException {\n+        String fileName = path.getFileName().toString();\n+        if (!fileNamesInUse.add(fileName)) {\n+            \/\/ Names must be unique in order for the special\n+            \/\/ property <fileName>=<APPLIED_PROP_VALUE> to work.\n+            throw new RuntimeException(fileName + \" is repeated\");\n+        }\n+        Files.createDirectories(path.getParent());\n+        PropsFile propsFile = builder.build(fileName, path);\n+        propsFile.addComment(\"Property to determine if this properties file \" +\n+                \"was parsed and not overwritten:\");\n+        propsFile.addRawProperty(fileName, APPLIED_PROP_VALUE);\n+        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n+        propsFile.addComment(\"Property to be overwritten by every properties \" +\n+                \"file (master, extra or included):\");\n+        propsFile.addRawProperty(LAST_FILE_PROP_NAME, fileName);\n+        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n+        createdFiles.add(propsFile);\n+        return propsFile;\n+    }\n+\n+    PropsFile newFile(String relPathStr) throws IOException {\n+        return newFile(PROPS_DIR.resolve(relPathStr), PropsFile::new);\n+    }\n+\n+    PropsFile newMasterFile() throws IOException {\n+        Files.copy(MASTER_FILE_TEMPLATE, MASTER_FILE);\n+        return newFile(MASTER_FILE, PropsFile::new);\n+    }\n+\n+    ExtraPropsFile newExtraFile() throws IOException {\n+        return newExtraFile(\"extra.properties\");\n+    }\n+\n+    ExtraPropsFile newExtraFile(String extraFileName) throws IOException {\n+        return (ExtraPropsFile) newFile(PROPS_DIR.resolve(extraFileName),\n+                (fileName, path) -> {\n+                    URI uri = serverUri.resolve(ParseUtil.encodePath(\n+                            ROOT_DIR.relativize(path).toString()));\n+                    return new ExtraPropsFile(fileName, uri, path);\n+                });\n+    }\n+\n+    void reportCreatedFiles() throws IOException {\n+        for (PropsFile propsFile : createdFiles) {\n+            System.err.println();\n+            System.err.println(propsFile.path.toString());\n+            System.err.println(ConfigFileTest.SEPARATOR_THIN.repeat(3));\n+            try (Stream<String> lines = Files.lines(propsFile.path)) {\n+                long lineNumber = 1L;\n+                Iterator<String> it = lines.iterator();\n+                while (it.hasNext()) {\n+                    String line = it.next();\n+                    if (!propsFile.path.equals(MASTER_FILE) ||\n+                            lineNumber > masterFileLines) {\n+                        System.err.println(line);\n+                    }\n+                    lineNumber++;\n+                }\n+            }\n+            System.err.println();\n+        }\n+    }\n+\n+    void clear() throws IOException {\n+        if (!createdFiles.isEmpty()) {\n+            for (PropsFile propsFile : createdFiles) {\n+                propsFile.close();\n+                Files.delete(propsFile.path);\n+            }\n+            FileUtils.deleteFileTreeUnchecked(PROPS_DIR);\n+            createdFiles.clear();\n+            fileNamesInUse.clear();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        clear();\n+        httpServer.stop(0);\n+        FileUtils.deleteFileTreeUnchecked(ROOT_DIR);\n+    }\n+}\n+\n+final class Executor {\n+    enum ExtraMode {\n+        HTTP_SERVED, FILE_URI, RAW_FILE_URI1, RAW_FILE_URI2, PATH_ABS, PATH_REL\n+    }\n+    static final String RUNNER_ARG = \"runner\";\n+    static final String INITIAL_PROP_LOG_MSG = \"Initial security property: \";\n+    private static final String OVERRIDING_LOG_MSG =\n+            \"overriding other security properties files!\";\n+    private static final String[] ALWAYS_UNEXPECTED_LOG_MSGS = {\n+            \"java.lang.AssertionError\",\n+            INITIAL_PROP_LOG_MSG + \"postInitTest=shouldNotRecord\",\n+            INITIAL_PROP_LOG_MSG + \"include=\",\n+    };\n+    private static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    private static final String JAVA_SEC_PROPS = \"java.security.properties\";\n+    private static final String CLASS_PATH = Objects.requireNonNull(\n+            System.getProperty(\"test.classes\"), \"unspecified test.classes\");\n+    private static final String DEBUG_ARG =\n+            \"-Xrunjdwp:transport=dt_socket,address=localhost:8000,suspend=y\";\n+    private final Map<String, String> systemProps = new LinkedHashMap<>(\n+            Map.of(\"java.security.debug\", \"all\", \"javax.net.debug\", \"all\",\n+                    \/\/ Ensure we get UTF-8 debug outputs in Windows:\n+                    \"stderr.encoding\", \"UTF-8\", \"stdout.encoding\", \"UTF-8\"));\n+    private final List<String> jvmArgs = new ArrayList<>(\n+            List.of(FilesManager.JAVA_EXECUTABLE, \"-enablesystemassertions\",\n+                    \/\/ Uncomment DEBUG_ARG to debug test-launched JVMs:\n+                    \"-classpath\", CLASS_PATH\/\/, DEBUG_ARG\n+            ));\n+    private PropsFile masterPropsFile;\n+    private ExtraPropsFile extraPropsFile;\n+    private boolean expectedOverrideAll = false;\n+    private OutputAnalyzer oa;\n+\n+    static void run(Method m, FilesManager filesMgr) throws Exception {\n+        try {\n+            m.invoke(null, new Executor(), filesMgr);\n+        } catch (Throwable e) {\n+            filesMgr.reportCreatedFiles();\n+            throw e;\n+        } finally {\n+            filesMgr.clear();\n+        }\n+    }\n+\n+    void addSystemProp(String key, String value) {\n+        systemProps.put(key, value);\n+    }\n+\n+    private void setRawExtraFile(String extraFile, boolean overrideAll) {\n+        addSystemProp(JAVA_SEC_PROPS, (overrideAll ? \"=\" : \"\") + extraFile);\n+    }\n+\n+    void setMasterFile(PropsFile masterPropsFile) {\n+        this.masterPropsFile = masterPropsFile;\n+    }\n+\n+    void setExtraFile(ExtraPropsFile extraPropsFile, ExtraMode mode,\n+            boolean overrideAll) {\n+        this.extraPropsFile = extraPropsFile;\n+        expectedOverrideAll = overrideAll;\n+        setRawExtraFile(switch (mode) {\n+            case HTTP_SERVED -> extraPropsFile.url.toString();\n+            case FILE_URI -> extraPropsFile.path.toUri().toString();\n+            case RAW_FILE_URI1 -> \"file:\" + extraPropsFile.path;\n+            case RAW_FILE_URI2 -> \"file:\/\/\" +\n+                    (extraPropsFile.path.startsWith(\"\/\") ? \"\" : \"\/\") +\n+                    extraPropsFile.path;\n+            case PATH_ABS -> extraPropsFile.path.toString();\n+            case PATH_REL -> CWD.relativize(extraPropsFile.path).toString();\n+        }, overrideAll);\n+    }\n+\n+    void setIgnoredExtraFile(String extraPropsFile, boolean overrideAll) {\n+        setRawExtraFile(extraPropsFile, overrideAll);\n+        expectedOverrideAll = false;\n+    }\n+\n+    void addJvmArg(String arg) {\n+        jvmArgs.add(arg);\n+    }\n+\n+    private void execute(boolean successExpected) throws Exception {\n+        List<String> command = new ArrayList<>(jvmArgs);\n+        Collections.addAll(command, Utils.getTestJavaOpts());\n+        addSystemPropertiesAsJvmArgs(command);\n+        command.add(ConfigFileTest.class.getSimpleName());\n+        command.add(RUNNER_ARG);\n+        oa = ProcessTools.executeProcess(new ProcessBuilder(command));\n+        oa.shouldHaveExitValue(successExpected ? 0 : 1);\n+        for (String output : ALWAYS_UNEXPECTED_LOG_MSGS) {\n+            oa.shouldNotContain(output);\n+        }\n+    }\n+\n+    private void addSystemPropertiesAsJvmArgs(List<String> command) {\n+        Map<String, String> allSystemProps = new LinkedHashMap<>(systemProps);\n+        if (extraPropsFile != null) {\n+            allSystemProps.putAll(extraPropsFile.getSystemProperties());\n+        }\n+        for (Map.Entry<String, String> e : allSystemProps.entrySet()) {\n+            command.add(\"-D\" + e.getKey() + \"=\" + e.getValue());\n+        }\n+    }\n+\n+    void assertSuccess() throws Exception {\n+        execute(true);\n+\n+        \/\/ Ensure every file was processed by checking a unique property used as\n+        \/\/ a flag. Each file defines <fileName>=applied.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   file0=applied\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   file1=applied\n+        \/\/\n+        \/\/ The assertion would be file0 == applied AND file1 == applied.\n+        \/\/\n+        if (extraPropsFile != null) {\n+            extraPropsFile.assertApplied(oa);\n+        }\n+        if (expectedOverrideAll) {\n+            \/\/ When overriding with an extra file, check that neither\n+            \/\/ the master file nor its includes are visible.\n+            oa.shouldContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertWasOverwritten(oa);\n+        } else {\n+            oa.shouldNotContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertApplied(oa);\n+        }\n+\n+        \/\/ Ensure the last included file overwrote a fixed property. Each file\n+        \/\/ defines last-file=<fileName>.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   last-file=file0\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   last-file=file1\n+        \/\/\n+        \/\/ The assertion would be last-file == file1.\n+        \/\/\n+        PropsFile lastFile = (extraPropsFile == null ?\n+                masterPropsFile : extraPropsFile).getLastFile();\n+        oa.shouldContain(FilesManager.LAST_FILE_PROP_NAME + \"=\" +\n+                lastFile.fileName);\n+        oa.stdoutShouldContain(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                lastFile.fileName);\n+    }\n+\n+    void assertError(String message) throws Exception {\n+        execute(false);\n+        oa.shouldContain(message);\n+    }\n+\n+    OutputAnalyzer getOutputAnalyzer() {\n+        return oa;\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":861,"deletions":109,"binary":false,"changes":970,"status":"modified"},{"patch":"@@ -1,7 +0,0 @@\n-# exercise ServiceLoader and legacy (class load) approach\n-security.provider.1=sun.security.provider.Sun\n-security.provider.2=SunRsaSign\n-security.provider.3=sun.security.ssl.SunJSSE\n-security.provider.4=com.sun.crypto.provider.SunJCE\n-security.provider.5=SunJGSS\n-security.provider.6=SunSASL\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/override.props","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.List;\n@@ -55,3 +54,2 @@\n-\n-    private static final String STATIC_PROPS =\n-        Paths.get(TEST_SRC, \"Static.props\").toString();\n+    private static final Path STATIC_PROPS =\n+        Paths.get(TEST_SRC, \"Static.props\");\n@@ -92,1 +90,1 @@\n-            \"-Djava.security.properties=file:\" + STATIC_PROPS,\n+            \"-Djava.security.properties=\" + STATIC_PROPS.toUri(),\n","filename":"test\/jdk\/java\/security\/Security\/signedfirst\/DynStatic.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -39,1 +38,0 @@\n-import java.util.Arrays;\n@@ -49,0 +47,4 @@\n+\n+    \/\/ Entry names produced in this test are fixed-length\n+    public static final int NAME_LENGTH = 10;\n+\n@@ -62,3 +64,2 @@\n-     *\n-     *  Since ZipOutputStream does not enforce the 'combined length' clause,\n-     *  we simply use 65,535 (0xFFFF) for the purpose of this test.\n+     *.\n+     * Create a maximum extra field which does not exceed 65,535 bytes\n@@ -66,1 +67,1 @@\n-    static final int MAX_EXTRA_FIELD_SIZE = 65_535;\n+    static final int MAX_EXTRA_FIELD_SIZE = 65_535 - ZipFile.CENHDR - NAME_LENGTH;\n@@ -75,3 +76,0 @@\n-    \/\/ Entry names produced in this test are fixed-length\n-    public static final int NAME_LENGTH = 10;\n-\n@@ -87,4 +85,0 @@\n-    \/\/ Helps SparseOutputStream detect write of the last CEN entry\n-    private static final String LAST_CEN_COMMENT = \"LastCEN\";\n-    private static final byte[] LAST_CEN_COMMENT_BYTES = LAST_CEN_COMMENT.getBytes(StandardCharsets.UTF_8);\n-\n@@ -97,0 +91,4 @@\n+    private static final byte[] EXTRA_BYTES = makeLargeExtraField();\n+    \/\/ Helps SparseOutputStream detect write of the last CEN entry\n+    private static final byte[] LAST_EXTRA_BYTES = makeLargeExtraField();\n+\n@@ -128,4 +126,0 @@\n-                if (i == NUM_ENTRIES -1) {\n-                    \/\/ Help SparseOutputStream detect the last CEN entry write\n-                    entry.setComment(LAST_CEN_COMMENT);\n-                }\n@@ -134,2 +128,0 @@\n-\n-\n@@ -141,1 +133,0 @@\n-            byte[] extra = makeLargeExtraField();\n@@ -143,1 +134,1 @@\n-                entry.setExtra(extra);\n+                entry.setExtra(EXTRA_BYTES);\n@@ -145,0 +136,2 @@\n+            \/\/ Help SparseOutputSream detect the last entry\n+            entries[entries.length-1].setExtra(LAST_EXTRA_BYTES);\n@@ -168,1 +161,1 @@\n-    private byte[] makeLargeExtraField() {\n+    private static byte[] makeLargeExtraField() {\n@@ -206,1 +199,1 @@\n-                if (Arrays.equals(LAST_CEN_COMMENT_BYTES, 0, LAST_CEN_COMMENT_BYTES.length, b, off, len)) {\n+                if (b == LAST_EXTRA_BYTES) {\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeTooLarge.java","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8340684\n+   @summary Verify unspecified, but long-standing behavior when reading\n+   from an input stream obtained using ZipFile::getInputStream after\n+   the ZipFile has been closed.\n+   @run junit ReadAfterClose\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class ReadAfterClose {\n+\n+    \/\/ ZIP file used in this test\n+    private Path zip = Path.of(\"read-after-close.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        byte[] content = \"hello\".repeat(1000).getBytes(StandardCharsets.UTF_8);\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            {\n+                zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+                zo.write(content);\n+            }\n+            {\n+                ZipEntry entry = new ZipEntry(\"stored.txt\");\n+                entry.setMethod(ZipEntry.STORED);\n+                CRC32 crc = new CRC32();\n+                crc.update(content);\n+                entry.setCrc(crc.getValue());\n+                entry.setSize(content.length);\n+                zo.putNextEntry(entry);\n+                zo.write(content);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Produce arguments with a variation of stored \/ deflated entries,\n+     * and read behavior before closing the ZipFile.\n+     * @return\n+     *\/\n+    public static Stream<Arguments> arguments() {\n+        return Stream.of(\n+                Arguments.of(\"stored.txt\",   true),\n+                Arguments.of(\"stored.txt\",   false),\n+                Arguments.of(\"deflated.txt\", true),\n+                Arguments.of(\"deflated.txt\", false)\n+        );\n+    }\n+    \/**\n+     * Attempting to read from an InputStream obtained by ZipFile.getInputStream\n+     * after the backing ZipFile is closed should throw IOException\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    public void readAfterClose(String entryName, boolean readFirst) throws IOException {\n+        \/\/ Retain a reference to an input stream backed by a closed ZipFile\n+        InputStream in;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            in = zf.getInputStream(new ZipEntry(entryName));\n+            \/\/ Optionally consume a single byte from the stream before closing\n+            if (readFirst) {\n+                in.read();\n+            }\n+        }\n+\n+        assertThrows(IOException.class, () -> {\n+            in.read();\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadAfterClose.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8336025\n+ * @summary Verify that ZipOutputStream throws a ZipException when the\n+ * CEN header size + name length + comment length + extra length exceeds\n+ * 65,535 bytes\n+ * @run junit ZipOutputStreamMaxCenHdrTest\n+ *\/\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ZipOutputStreamMaxCenHdrTest {\n+\n+    \/\/ CEN header size + name length + comment length + extra length\n+    \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+    \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+    static final int MAX_COMBINED_CEN_HEADER_SIZE = 0xFFFF;\n+\n+    \/\/ Maximum possible size of name length + comment length + extra length\n+    \/\/ for entries in order to not exceed 65,489 bytes minus 46 bytes for the CEN\n+    \/\/ header length\n+    static final int MAX_NAME_COMMENT_EXTRA_SIZE =\n+            MAX_COMBINED_CEN_HEADER_SIZE - ZipFile.CENHDR;\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ ZIP file to be used by the tests\n+    static final Path ZIP_FILE = Path.of(\"maxCENHdrTest.zip\");\n+\n+    \/**\n+     * Clean up prior to test run\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeEach\n+    public void startUp() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n+\n+    \/**\n+     * Validate a ZipException is thrown when the combined CEN Header, name\n+     * length, comment length, and extra data length exceeds 65,535 bytes when\n+     * the ZipOutputStream is closed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n+    void setCommentTest(int length) throws IOException {\n+        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        final byte[] bytes = new byte[length];\n+        Arrays.fill(bytes, (byte) 'a');\n+        ZipEntry zipEntry = new ZipEntry(\"\");\n+        \/\/ The comment length will trigger the ZipException\n+        zipEntry.setComment(new String(bytes, StandardCharsets.UTF_8));\n+        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n+        assertEquals(receivedException, expectZipException);\n+    }\n+\n+    \/**\n+     * Validate an ZipException is thrown when the combined CEN Header, name\n+     * length, comment length, and extra data length exceeds 65,535 bytes when\n+     * the ZipOutputStream is closed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n+    void setNameTest(int length) throws IOException {\n+        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        final byte[] bytes = new byte[length];\n+        Arrays.fill(bytes, (byte) 'a');\n+        \/\/ The name length will trigger the ZipException\n+        ZipEntry zipEntry = new ZipEntry(new String(bytes, StandardCharsets.UTF_8));\n+        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n+        assertEquals(receivedException, expectZipException);\n+    }\n+\n+    \/**\n+     * Validate an ZipException is thrown when the combined CEN Header, name\n+     * length, comment length, and extra data length exceeds 65,535 bytes when\n+     * the ZipOutputStream is closed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n+    void setExtraTest(int length) throws IOException {\n+        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        final byte[] bytes = new byte[length];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort((short) (length - 2 * Short.BYTES));\n+        ZipEntry zipEntry = new ZipEntry(\"\");\n+        \/\/ The extra data length will trigger the ZipException\n+        zipEntry.setExtra(bytes);\n+        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n+        assertEquals(receivedException, expectZipException);\n+    }\n+\n+    \/**\n+     * Write a single Zip entry using ZipOutputStream\n+     * @param zipEntry the ZipEntry to write\n+     * @param expectZipException true if a ZipException is expected, false otherwse\n+     * @return true if a ZipException was thrown\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static boolean writeZipEntry(ZipEntry zipEntry, boolean expectZipException)\n+            throws IOException {\n+        boolean receivedException = false;\n+        try (ZipOutputStream zos = new ZipOutputStream(\n+                new BufferedOutputStream(Files.newOutputStream(ZIP_FILE)))) {\n+            zos.putNextEntry(zipEntry);\n+            if (expectZipException) {\n+                ZipException ex = assertThrows(ZipException.class, zos::close);\n+                assertTrue(ex.getMessage().matches(\".*bad header size.*\"),\n+                        \"Unexpected ZipException message: \" + ex.getMessage());\n+                receivedException = true;\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Received Unexpected Exception\", e);\n+        }\n+        return receivedException;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/ZipOutputStreamMaxCenHdrTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304031 8338406\n+ * @bug 8304031 8338406 8338546\n@@ -28,0 +28,2 @@\n+ * @modules java.base\/jdk.internal.constant\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -39,0 +42,4 @@\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n+import jdk.internal.constant.ConstantUtils;\n@@ -41,0 +48,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -105,0 +114,54 @@\n+\n+    static Stream<ClassDesc> classOrInterfaceEntries() {\n+        return Stream.of(\n+                CD_Object, CD_Float, CD_Long, CD_String, ClassDesc.of(\"Ape\"),\n+                CD_String.nested(\"Whatever\"), CD_MethodHandles_Lookup, ClassDesc.ofInternalName(\"one\/Two\"),\n+                ClassDesc.ofDescriptor(\"La\/b\/C;\"), ConstantDescSymbolsTest.class.describeConstable().orElseThrow(),\n+                CD_Boolean, CD_ConstantBootstraps, CD_MethodHandles\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"classOrInterfaceEntries\")\n+    void testConstantPoolBuilderClassOrInterfaceEntry(ClassDesc cd) {\n+        assertTrue(cd.isClassOrInterface());\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var internal = ConstantUtils.dropFirstAndLastChar(cd.descriptorString());\n+\n+        \/\/ 1. ClassDesc\n+        var ce = cp.classEntry(cd);\n+        assertSame(cd, ce.asSymbol(), \"Symbol propagation on create\");\n+\n+        \/\/ 1.1. Bare addition\n+        assertTrue(ce.name().equalsString(internal), \"Adding to bare pool\");\n+\n+        \/\/ 1.2. Lookup existing\n+        assertSame(ce, cp.classEntry(cd), \"Finding by identical CD\");\n+\n+        \/\/ 1.3. Lookup existing - equal but different ClassDesc\n+        var cd1 = ClassDesc.ofDescriptor(cd.descriptorString());\n+        assertSame(ce, cp.classEntry(cd1), \"Finding by another equal CD\");\n+\n+        \/\/ 1.3.1. Lookup existing - equal but different ClassDesc, equal but different string\n+        var cd2 = ClassDesc.ofDescriptor(\"\" + cd.descriptorString());\n+        assertSame(ce, cp.classEntry(cd2), \"Finding by another equal CD\");\n+\n+        \/\/ 1.4. Lookup existing - with utf8 internal name\n+        var utf8 = cp.utf8Entry(internal);\n+        assertSame(ce, cp.classEntry(utf8), \"Finding CD by UTF8\");\n+\n+        \/\/ 2. ClassEntry exists, no ClassDesc\n+        cp = ConstantPoolBuilder.of();\n+        utf8 = cp.utf8Entry(internal);\n+        ce = cp.classEntry(utf8);\n+        var found = cp.classEntry(cd);\n+        assertSame(ce, found, \"Finding non-CD CEs with CD\");\n+        assertEquals(cd, ce.asSymbol(), \"Symbol propagation on find\");\n+\n+        \/\/ 3. Utf8Entry exists, no ClassEntry\n+        cp = ConstantPoolBuilder.of();\n+        utf8 = cp.utf8Entry(internal);\n+        ce = cp.classEntry(cd);\n+        assertSame(utf8, ce.name(), \"Reusing existing utf8 entry\");\n+        assertEquals(cd, ce.asSymbol(), \"Symbol propagation on create with utf8\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8338546\n@@ -27,0 +28,4 @@\n+ * @library java.base\n+ * @modules java.base\/jdk.internal.constant\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build java.base\/jdk.internal.classfile.impl.*\n@@ -29,1 +34,0 @@\n-import java.lang.classfile.ClassFile;\n@@ -32,1 +36,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -34,1 +37,3 @@\n-import java.util.BitSet;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n@@ -38,0 +43,2 @@\n+import jdk.internal.classfile.impl.UtilAccess;\n+import jdk.internal.constant.ConstantUtils;\n@@ -87,0 +94,44 @@\n+    @Test\n+    void testPow31() {\n+        int p = 1;\n+        \/\/ Our calculation only prepares up to 65536,\n+        \/\/ max length of CP Utf8 + 1\n+        for (int i = 0; i <= 65536; i++) {\n+            final int t = i;\n+            assertEquals(p, Util.pow31(i), () -> \"31's power to \" + t);\n+            p *= 31;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(classes = {\n+            Long.class,\n+            Object.class,\n+            Util.class,\n+            Test.class,\n+            CopyOnWriteArrayList.class,\n+            AtomicReferenceFieldUpdater.class\n+    })\n+    void testInternalNameHash(Class<?> type) {\n+        var cd = type.describeConstable().orElseThrow();\n+        assertEquals(ConstantUtils.binaryToInternal(type.getName()).hashCode(), Util.internalNameHash(cd.descriptorString()));\n+    }\n+\n+    \/\/ Ensures the initialization statement of the powers array is filling in the right values\n+    @Test\n+    void testPowersArray() {\n+        int[] powers = new int[7 * UtilAccess.significantOctalDigits()];\n+        for (int i = 1, k = 31; i <= 7; i++, k *= 31) {\n+            int t = powers[UtilAccess.powersIndex(i, 0)] = k;\n+\n+            for (int j = 1; j < UtilAccess.significantOctalDigits(); j++) {\n+                t *= t;\n+                t *= t;\n+                t *= t;\n+                powers[UtilAccess.powersIndex(i, j)] = t;\n+            }\n+        }\n+\n+        assertArrayEquals(powers, UtilAccess.powersTable());\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+public final class UtilAccess {\n+    public static int significantOctalDigits() {\n+        return Util.SIGNIFICANT_OCTAL_DIGITS;\n+    }\n+\n+    public static int powersIndex(int digit, int index) {\n+        return Util.powersIndex(digit, index);\n+    }\n+\n+    public static int[] powersTable() {\n+        return Util.powers;\n+    }\n+\n+    public static int reverse31() {\n+        return Util.INVERSE_31;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/java.base\/jdk\/internal\/classfile\/impl\/UtilAccess.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -56,0 +56,1 @@\n+ * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestDeoptimization.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4184283\n+ * @summary Checks rendering of dithered byte packed image does not crash.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.MemoryImageSource;\n+import java.awt.image.WritableRaster;\n+\n+public class DitherTest extends Component {\n+\n+    final static int NOOP = 0;\n+    final static int RED = 1;\n+    final static int GREEN = 2;\n+    final static int BLUE = 3;\n+    final static int ALPHA = 4;\n+    final static int SATURATION = 5;\n+\n+    final static byte red[] = {(byte)0, (byte)132, (byte)0, (byte)132, (byte)0, (byte)132,\n+                         (byte)0, (byte)198, (byte)198, (byte)165, (byte)255, (byte)165, (byte)132,\n+                         (byte)255, (byte)0, (byte)255};\n+\n+    final static byte green[] = {(byte)0, (byte)0, (byte)130, (byte)130, (byte)0,\n+                           (byte)0, (byte)130, (byte)195, (byte)223, (byte)203, (byte)251, (byte)162,\n+                           (byte)132, (byte)0, (byte)255, (byte)255};\n+\n+    final static byte blue[] = {(byte)0, (byte)0, (byte)0, (byte)0, (byte)132, (byte)132,\n+                          (byte)132, (byte)198, (byte)198, (byte)247, (byte)247, (byte)165, (byte)132,\n+                          (byte)0, (byte)0, (byte)0};\n+\n+    static IndexColorModel cm16 = new IndexColorModel( 4, 16, red, green, blue);\n+\n+\n+    public static void main(String args[]) {\n+\n+        int imageWidth = 256;\n+        int imageHeight = 256;\n+        WritableRaster raster = cm16.createCompatibleWritableRaster(imageWidth, imageHeight);\n+        BufferedImage intermediateImage = new BufferedImage(cm16, raster, false, null);\n+        Image calculatedImage = calculateImage();\n+\n+        Graphics2D ig = intermediateImage.createGraphics();\n+        \/\/ Clear background and fill a red rectangle just to prove that we can draw on intermediateImage\n+        ig.setColor(Color.white);\n+        ig.fillRect(0,0,imageWidth,imageHeight);\n+        ig.drawImage(calculatedImage, 0, 0, imageWidth, imageHeight, null);\n+        ig.setColor(Color.red);\n+        ig.fillRect(0,0,5,5);\n+\n+        BufferedImage destImage = new BufferedImage(imageWidth, imageWidth, BufferedImage.TYPE_INT_RGB);\n+        Graphics2D dg = destImage.createGraphics();\n+        dg.drawImage(intermediateImage, 0, 0, imageWidth, imageHeight, null);\n+    }\n+\n+    private static void applymethod(int c[], int method, int step, int total, int vals[]) {\n+        if (method == NOOP)\n+            return;\n+        int val = ((total < 2)\n+                   ? vals[0]\n+                   : vals[0] + ((vals[1] - vals[0]) * step \/ (total - 1)));\n+        switch (method) {\n+        case RED:\n+            c[0] = val;\n+            break;\n+        case GREEN:\n+            c[1] = val;\n+            break;\n+        case BLUE:\n+            c[2] = val;\n+            break;\n+        case ALPHA:\n+            c[3] = val;\n+            break;\n+        case SATURATION:\n+            int max = Math.max(Math.max(c[0], c[1]), c[2]);\n+            int min = max * (255 - val) \/ 255;\n+            if (c[0] == 0) c[0] = min;\n+            if (c[1] == 0) c[1] = min;\n+            if (c[2] == 0) c[2] = min;\n+            break;\n+        }\n+    }\n+\n+    private static Image calculateImage() {\n+\n+        int xvals[] = { 0, 255 };\n+        int yvals[] = { 0, 255 };\n+        int xmethod = RED;\n+        int ymethod = BLUE;\n+        int width = 256;\n+        int height = 256;\n+        int pixels[] = new int[width * height];\n+        int c[] = new int[4];\n+        int index = 0;\n+        for (int j = 0; j < height; j++) {\n+            for (int i = 0; i < width; i++) {\n+                c[0] = c[1] = c[2] = 0;\n+                c[3] = 255;\n+                if (xmethod < ymethod) {\n+                    applymethod(c, xmethod, i, width, xvals);\n+                    applymethod(c, ymethod, j, height, yvals);\n+                } else {\n+                    applymethod(c, ymethod, j, height, yvals);\n+                    applymethod(c, xmethod, i, width, xvals);\n+                }\n+                pixels[index++] = ((c[3] << 24) |\n+                                   (c[0] << 16) |\n+                                   (c[1] << 8) |\n+                                   (c[2] << 0));\n+            }\n+        }\n+\n+        DitherTest dt = new DitherTest();\n+        return dt.createImage(new MemoryImageSource(width, height, ColorModel.getRGBdefault(), pixels, 0, width));\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/awt\/image\/BytePackedRaster\/DitherTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4213160\n+ * @summary Should generate a black image\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.awt.geom.AffineTransform;\n+\n+public class MultiOp {\n+\n+    public static void main(String[] argv) {\n+\n+       int width = 256;\n+       int height = 256;\n+\n+       int pixelBits = 2; \/\/ 1, 2, 4, or 8\n+       \/\/ 1 and 8 make the code throw ImagingOpException, 2 and 4\n+       \/\/ make the code SEGV on Sol.\n+\n+       byte[] lut1Arr = new byte[] {0, (byte)255 };\n+       byte[] lut2Arr = new byte[] {0, (byte)85, (byte)170, (byte)255};\n+       byte[] lut4Arr = new byte[] {0, (byte)17, (byte)34, (byte)51,\n+                                  (byte)68, (byte)85,(byte) 102, (byte)119,\n+                                  (byte)136, (byte)153, (byte)170, (byte)187,\n+                                  (byte)204, (byte)221, (byte)238, (byte)255};\n+       byte[] lut8Arr = new byte[256];\n+       for (int i = 0; i < 256; i++) {\n+           lut8Arr[i] = (byte)i;\n+       }\n+\n+       \/\/ Create the binary image\n+       int bytesPerRow = width * pixelBits \/ 8;\n+       byte[] imageData = new byte[height * bytesPerRow];\n+       ColorModel cm = null;\n+\n+       switch (pixelBits) {\n+       case 1:\n+           cm = new IndexColorModel(pixelBits, lut1Arr.length,\n+                                    lut1Arr, lut1Arr, lut1Arr);\n+           break;\n+       case 2:\n+           cm = new IndexColorModel(pixelBits, lut2Arr.length,\n+                                    lut2Arr, lut2Arr, lut2Arr);\n+           break;\n+       case 4:\n+           cm = new IndexColorModel(pixelBits, lut4Arr.length,\n+                                    lut4Arr, lut4Arr, lut4Arr);\n+           break;\n+       case 8:\n+           cm = new IndexColorModel(pixelBits, lut8Arr.length,\n+                                    lut8Arr, lut8Arr, lut8Arr);\n+           break;\n+       default:\n+           {new Exception(\"Invalid # of bit per pixel\").printStackTrace();}\n+       }\n+\n+       DataBuffer db = new DataBufferByte(imageData, imageData.length);\n+       WritableRaster r = Raster.createPackedRaster(db, width, height,\n+                                                    pixelBits, null);\n+       BufferedImage srcImage = new BufferedImage(cm, r, false, null);\n+\n+       BufferedImage destImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+       Graphics2D g = destImage.createGraphics();\n+       AffineTransform af = AffineTransform.getScaleInstance(.5, .5);\n+       \/\/ This draw image is the problem\n+       g.drawImage(srcImage, af, null);\n+       int blackPixel = Color.black.getRGB();\n+       for (int x = 0; x < width; x++) {\n+           for (int y = 0; y < height; y++) {\n+              if (destImage.getRGB(x, y) != blackPixel) {\n+                  throw new RuntimeException(\"Not black\");\n+              }\n+          }\n+      }\n+   }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/BytePackedRaster\/MultiOp.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4673490\n+ * @summary This test verifies that Toolkit images with a 1-bit\n+ * IndexColorModel (known as ByteBinary) and a transparent index are rendered properly.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+\n+public class ByteBinaryBitmask {\n+\n+    public static void main(String argv[]) throws Exception {\n+\n+        \/* Create the image *\/\n+        int w = 16, h = 16;\n+        byte[] bw = { (byte)255, (byte)0, };\n+        IndexColorModel icm = new IndexColorModel(1, 2, bw, bw, bw, 0);\n+        BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_BINARY, icm);\n+        Graphics2D g2d = img.createGraphics();\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.black);\n+        int xoff = 5;\n+        g2d.fillRect(xoff, 5, 1, 10); \/\/ 1 pixel wide\n+\n+        int dw = 200, dh = 50;\n+        BufferedImage dest = new BufferedImage(dw, dh, BufferedImage.TYPE_INT_RGB);\n+        Graphics2D g = dest.createGraphics();\n+        g.setColor(Color.green);\n+        g.fillRect(0, 0, dw, dh);\n+        int x1 = 10;\n+        int x2 = 50;\n+        int x3 = 90;\n+        int x4 = 130;\n+        g.drawImage(img, x1, 10, null);\n+        g.drawImage(img, x2, 10, null);\n+        g.drawImage(img, x3, 10, null);\n+        g.drawImage(img, x4, 10, null);\n+\n+        int blackPix = Color.black.getRGB();\n+        for (int y = 0; y < dh; y++) {\n+            boolean isBlack = false;\n+            for (int x = 0; x < dw; x++) {\n+               int rgb = dest.getRGB(x, y);\n+               if (rgb == blackPix) {\n+                   \/* Src image has a one pixel wide vertical rect at off \"xoff\" and\n+                    * this is drawn at x1\/x2\/x3\/x4) so the sum of those are the x locations\n+                    * to expect black.\n+                    *\/\n+                   if (x != (x1 + xoff) && x != (x2 + xoff) && x != (x3 + xoff) && x!= (x4 + xoff)) {\n+                       throw new RuntimeException(\"wrong x location: \" +x);\n+                   }\n+                   if (isBlack) {\n+                       throw new RuntimeException(\"black after black\");\n+                   }\n+               }\n+               isBlack = rgb == blackPix;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/ImageRepresentation\/ByteBinaryBitmask.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 4192756\n+ * @summary Tests that using a non-default colormodel generates correct images under 16\/24 bit mode\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.MemoryImageSource;\n+import java.util.Arrays;\n+\n+\/*\n+ * NOTE: This bug only appears under specific conditions.  If the background of\n+ * the surface is red, then you are not running under the conditions necessary\n+ * to test for the regression so the results of this test will be inconclusive.\n+ *\n+ * The test should be run under any of the following screen depths\/surfaces:\n+ *\n+ * 15-bit, otherwise known as 555 RGB or 32768 (thousands) colors\n+ * 16-bit, otherwise known as 565 RGB or 65536 (thousands) colors\n+ * 24-bit, otherwise known as 16777216 (millions) colors\n+ *\n+ * The test draws 2 rectangles.  Both rectangles should be half black (left)\n+ * and half blue (right).  If the top rectangle is all black, the test fails.\n+ * If the background is red, the results are inconclusive (see above).\n+*\/\n+\n+public class CustomSourceCM extends Component {\n+\n+    public static int IMG_W = 80;\n+    public static int IMG_H = 30;\n+\n+    static void test(int imageType) {\n+\n+        int w = IMG_W + 20;\n+        int h = IMG_H * 2 + 40;\n+        BufferedImage bi = new BufferedImage(w, h, imageType);\n+\n+        DirectColorModel dcm;\n+\n+        \/* the next dozen lines or so are intended to help\n+         * ascertain if the destination surface is of the type\n+         * that exhibited the original bug, making the background\n+         * white in those cases. It is not strictly necessary.\n+         * It is only for a manual tester to be able to tell by looking.\n+         * The real test is the check for black and blue later on.\n+         *\/\n+        Graphics2D g = bi.createGraphics();\n+        g.setColor(Color.red);\n+        g.fillRect(0, 0, w, h);\n+\n+        ColorModel cm = bi.getColorModel();\n+        if (cm instanceof ComponentColorModel) {\n+            g.setColor(Color.white);\n+            g.fillRect(0, 0, w, h);\n+        } else if (cm instanceof DirectColorModel) {\n+            dcm = (DirectColorModel) cm;\n+            if (dcm.getPixelSize() < 24) {\n+                g.setColor(Color.white);\n+                g.fillRect(0, 0, w, h);\n+            }\n+        }\n+\n+        \/\/ Construct a ColorModel and data for a 16-bit 565 image...\n+        dcm = new DirectColorModel(16, 0x1f, 0x7e0, 0xf800);\n+\n+        \/\/ Create an image which is black on the left, blue on the right.\n+        int[] pixels = new int[IMG_W * IMG_H];\n+        int blue = dcm.getBlueMask();\n+        int off = 0;\n+        for (int y = 0; y < IMG_H; y++) {\n+            Arrays.fill(pixels, off, off+IMG_W\/2, 0);\n+            Arrays.fill(pixels, off+IMG_W\/2, off+IMG_W, blue);\n+            off += IMG_W;\n+        }\n+        MemoryImageSource mis = new MemoryImageSource(IMG_W, IMG_H, dcm,\n+                                                      pixels, 0, IMG_W);\n+        CustomSourceCM comp = new CustomSourceCM();\n+        Image img = comp.createImage(mis);\n+\n+        \/\/ Draw the image on to the surface.\n+        g.drawImage(img, 10, 10, null);\n+\n+        \/\/ Create a similar effect with 2 fillrects, below the image.\n+        g.setColor(Color.black);\n+        g.fillRect(10, 60, IMG_W\/2, IMG_H);\n+        g.setColor(Color.blue);\n+        g.fillRect(10+IMG_W\/2, 60, IMG_W\/2, IMG_H);\n+\n+        \/\/ Now sample points in the image to confirm they are the expected color.\n+        int bluePix = Color.blue.getRGB();\n+        int blackPix = Color.black.getRGB();\n+        int black_topLeft = bi.getRGB(10+IMG_W\/4, 10+IMG_H\/2);\n+        int blue_topRight = bi.getRGB(10+IMG_W*3\/4, 10+IMG_H\/2);\n+        int black_bottomLeft = bi.getRGB(10+IMG_W\/4, 60+IMG_H\/2);\n+        int blue_bottomRight = bi.getRGB(10+IMG_W*3\/4, 60+IMG_H\/2);\n+        if ((black_topLeft != blackPix) || (black_bottomLeft != blackPix) ||\n+            (blue_topRight != bluePix) ||  (blue_bottomRight != bluePix)) {\n+\n+            String fileName = \"failed \" + imageType + \".png\";\n+            try {\n+                javax.imageio.ImageIO.write(bi, \"png\", new java.io.File(fileName));\n+            } catch (Exception e) { };\n+            throw new RuntimeException(\"unexpected colors\");\n+        }\n+    }\n+\n+    public static void main(String argv[]) {\n+        test(BufferedImage.TYPE_USHORT_555_RGB);\n+        test(BufferedImage.TYPE_USHORT_565_RGB);\n+        test(BufferedImage.TYPE_3BYTE_BGR);\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/ImageRepresentation\/CustomSourceCM.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4238978\n+ * @summary This test verifies that the correct blitting loop is being used.\n+ *          The correct output should have a yellow border on the top and\n+ *          left sides of a red box.  The incorrect output would have only\n+ *          a red box -- no yellow border.\"\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+\n+public class ARGBBgToRGB {\n+\n+    public static void main(String[] argv) {\n+        BufferedImage bi = new BufferedImage(256, 256, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D big = bi.createGraphics();\n+        big.setColor(Color.red);\n+        big.fillRect(30, 30, 150, 150);\n+\n+        BufferedImage bi2 = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D big2 = bi2.createGraphics();\n+        big2.drawImage(bi, 0, 0, Color.yellow, null);\n+\n+        int expectYellowPix = bi2.getRGB(0, 0);\n+        int expectRedPix = bi2.getRGB(50, 50);\n+        if ((expectYellowPix != Color.yellow.getRGB()) ||\n+            (expectRedPix != Color.red.getRGB()))\n+        {\n+           throw new RuntimeException(\"Unexpected colors \" + expectYellowPix + \" \" + expectRedPix);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/ARGBBgToRGB.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4188744\n+ * @summary This test verifies that copyArea performs correctly for negative offset values.\n+ *          The correct output shows that the text area is moved to the left and down,\n+ *          leaving some garbage on the right and the top.\n+ *          The incorrect copy would show the text area garbled and no text is legible.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual CopyNegative\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Panel;\n+\n+public class CopyNegative extends Panel {\n+\n+   private static final String INSTRUCTIONS = \"\"\"\n+       This test verifies that copyArea performs correctly for negative offset values.\n+       The test draws text in an image, then copies the contents repeatedly.\n+       The correct output shows that the text is moved to the left and down,\n+       leaving some garbage on the top \/ right and some legible text at the bottom left.\n+       The incorrect copy would show the whole text area garbled and no text is legible.\n+       \"\"\";\n+\n+    public static void main(String[] argv) throws Exception {\n+       PassFailJFrame.builder()\n+            .title(\"CopyNegativeTest\")\n+            .instructions(INSTRUCTIONS)\n+            .testUI(CopyNegative::createUI)\n+            .testTimeOut(5)\n+            .rows(10)\n+            .columns(50)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    Image img;\n+\n+    static final int W = 200, H = 200;\n+\n+    static Frame createUI() {\n+        Frame f = new Frame(\"CopyNegative\");\n+        f.add(new CopyNegative());\n+        f.pack();\n+        return f;\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(W, H);\n+    }\n+\n+    private void doCopy() {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, W, H);\n+        g.setColor(Color.black);\n+        String text = \"Some Text To Display, it is long enough to fill the entire display line.\";\n+        StringBuffer sb = new StringBuffer(text);\n+\n+        for (int i = 1; i < 50; i++) {\n+            g.drawString(sb.toString(), 5,20 * i - 10);\n+            sb.insert(0, Integer.toString(i));\n+        }\n+        for (int i = 0 ; i < 20 ; i++ ) {\n+            g.copyArea(0, 0, W, H, -3, 3);\n+        }\n+    }\n+\n+    public void paint(Graphics g) {\n+        img = createImage(W, H);\n+        doCopy();\n+        g.drawImage(img, 0, 0, this);\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/CopyNegative.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 4181172\n+ * @summary Confirm that solid white fill is not dithered on an 8-bit indexed surface.\n+ *          The test draws two areas filled with white solid color.\n+ *          The upper left square is filled in aliasing mode and\n+ *          the lower right square is filled in anti-aliasing mode.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.image.BufferedImage;\n+\n+public class DitheredSolidFill {\n+\n+    public static void main(String args[]) {\n+       BufferedImage bi = new BufferedImage(120, 120, BufferedImage.TYPE_BYTE_INDEXED);\n+       Graphics2D g2D = bi.createGraphics();\n+\n+        g2D.setColor(Color.black);\n+        g2D.fillRect(0, 0, 100, 100);\n+\n+        g2D.setColor(Color.white);\n+        g2D.fillRect(5, 5, 40, 40);\n+        checkPixels(bi, 5, 5, 40, 40);\n+\n+        g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+        g2D.fillRect(55, 55, 40, 40);\n+        checkPixels(bi, 55, 55, 40, 40);\n+    }\n+\n+    static void checkPixels(BufferedImage bi, int x, int y, int w, int h) {\n+       \/\/ pixel can be off white, but must be the same in all cases.\n+       int expectedPix = bi.getRGB(x, y);\n+       for (int x0 = x; x0 < x + w; x0++) {\n+           for (int y0 = y; y0 < y + h; y0++) {\n+              if (bi.getRGB(x0, y0) != expectedPix) {\n+                  try {\n+                      javax.imageio.ImageIO.write(bi, \"png\", new java.io.File(\"failed.png\"));\n+                  } catch (Exception e) {\n+                  }\n+                  throw new RuntimeException(\"Not expected pix : \" +\n+                                             Integer.toHexString(bi.getRGB(x0, y0)) +\n+                                             \" at \" + x0 + \",\" + y0);\n+              }\n+           }\n+       }\n+   }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/DitheredSolidFill.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4236576\n+  @summary tests that a BufferedImage in TYPE_3BYTE_BGR format is correctly\n+           drawn when there is an offset between the Graphics clip bounds\n+           and the clip box of the underlying device context.\n+  @run main OffsetCalculationTest\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+\n+public class OffsetCalculationTest {\n+\n+    public static void main(String[] args) {\n+        BufferedImage srcImage = new BufferedImage(500, 500, BufferedImage.TYPE_3BYTE_BGR);\n+\n+        DataBuffer buffer = srcImage.getRaster().getDataBuffer();\n+        for (int i = 2; i < buffer.getSize(); i+=3) {\n+            \/\/ setting each pixel to blue via the data buffer elements.\n+            buffer.setElem(i - 2, 0xff);\n+            buffer.setElem(i - 1, 0);\n+            buffer.setElem(i, 0);\n+        }\n+\n+        int w = 200, h = 200;\n+        BufferedImage destImage = new BufferedImage(w, h, BufferedImage.TYPE_3BYTE_BGR);\n+        Graphics2D g = destImage.createGraphics();\n+        Rectangle r = new Rectangle(0, 0, w, h);\n+        g.setClip(r.x - 1, r.y, r.width + 1, r.height);\n+        g.drawImage(srcImage, 0, 0, null);\n+\n+        int bluepix = Color.blue.getRGB();\n+        for (int y = 0; y < w; y++) {\n+            for (int x = 0; x < h; x++) {\n+                if (destImage.getRGB(x, y) != bluepix) {\n+                     throw new RuntimeException(\"Not Blue\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/OffsetCalculationTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4088173\n+ * @summary This interactive test verifies that the XOR mode is not affecting\n+ *          the clearRect() call. The correct output looks like:\n+ *\n+ *          \\      \/\n+ *           \\    \/\n+ *                     The backgound is blue.\n+ *                     The lines outside the central rectangle are green.\n+ *                     The central rectangle is also blue (the result of clearRect())\n+ *           \/    \\\n+ *          \/      \\\n+ *\n+ * @key headful\n+ * @run main XORClearRect\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+\n+public class XORClearRect extends Panel {\n+\n+    public static void main(String args[]) throws Exception {\n+        EventQueue.invokeAndWait(XORClearRect::createUI);\n+        try {\n+             Robot robot = new Robot();\n+             robot.waitForIdle();\n+             robot.delay(2000);\n+             Point p = frame.getLocationOnScreen();\n+             int pix = robot.getPixelColor(p.x + 100, p.y + 100).getRGB();\n+             if (pix != Color.blue.getRGB()) {\n+                 throw new RuntimeException(\"Not blue\");\n+             }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+\n+    static volatile Frame frame;\n+\n+    static void createUI() {\n+        frame = new Frame(\"XORClearRect\");\n+        frame.setBackground(Color.blue);\n+        XORClearRect xor = new XORClearRect();\n+        frame.add(xor);\n+        frame.setSize(200,200);\n+        frame.setVisible(true);\n+    }\n+\n+    public XORClearRect() {\n+       setBackground(Color.blue);\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.setColor(Color.green);\n+        g.drawLine(0,0,200,200);\n+        g.drawLine(0,200,200,0);\n+        g.setXORMode(Color.blue);\n+        g.clearRect(50,50,100,100); \/\/expecting the rectangle to be filled\n+                                    \/\/ with the background color (blue)\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/XORClearRect.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8067437\n- * @summary Verify Multiple JRE version support has been removed.\n- * @modules jdk.compiler\n- *          jdk.zipfs\n- * @build TestHelper\n- * @run main MultipleJRERemoved\n- *\/\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.*;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarOutputStream;\n-import java.util.jar.Manifest;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import java.util.zip.ZipEntry;\n-\n-public class MultipleJRERemoved extends TestHelper {\n-\n-    public static final String VERSION_JAR = \"version.jar\";\n-    public static final String PRINT_VERSION_CLASS = \"PrintVersion\";\n-    private final File javaFile = new File(PRINT_VERSION_CLASS + \".java\");\n-    private final File clsFile = new File(PRINT_VERSION_CLASS + \".class\");\n-\n-    private MultipleJRERemoved() {\n-    }\n-\n-    \/**\n-     * @param args the command line arguments\n-     * @throws java.io.FileNotFoundException\n-     *\/\n-    public static void main(String[] args) throws Exception {\n-        MultipleJRERemoved a = new MultipleJRERemoved();\n-        a.run(args);\n-    }\n-\n-    \/**\n-     * Check all combinations of flags: \"-version:\", \"-jre-restrict-search\", \"-jre-no-restrict-search\". Test expects to see errors.\n-     *\/\n-    @Test\n-    public void allFlagCombinations() throws IOException {\n-        final Pattern newLine = Pattern.compile(\"\\n\");\n-        createJar(Collections.emptyMap());\n-\n-        for (Flag flag1 : Flag.values()) {\n-            for (Flag flag2 : Flag.values()) {\n-                for (Flag flag3 : Flag.values()) {\n-                    List<Flag> flags = Stream.of(flag1, flag2, flag3)\n-                            .filter(f -> !Flag.EMPTY.equals(f))\n-                            .collect(Collectors.toList());\n-\n-                    if (flags.size() == 0) continue;\n-\n-                    List<String> flagValues = flags.stream()\n-                            .map(Flag::value)\n-                            .collect(Collectors.toList());\n-\n-                    List<String> errorMessages = flags.stream()\n-                            .map(Flag::errorMessage)\n-                            .flatMap(newLine::splitAsStream)\n-                            .collect(Collectors.toList());\n-\n-                    List<String> jarCmd = new ArrayList<>();\n-                    jarCmd.add(javaCmd);\n-                    jarCmd.addAll(flagValues);\n-                    jarCmd.add(\"-jar\");\n-                    jarCmd.add(\"version.jar\");\n-\n-                    check(jarCmd, errorMessages);\n-\n-                    List<String> cmd = new ArrayList<>();\n-                    cmd.add(javaCmd);\n-                    cmd.addAll(flagValues);\n-                    cmd.add(PRINT_VERSION_CLASS);\n-\n-                    check(cmd, errorMessages);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void check(List<String> cmd, List<String> errorMessages) {\n-        TestResult tr = doExec(cmd.toArray(new String[cmd.size()]));\n-        tr.checkNegative();\n-        tr.isNotZeroOutput();\n-        errorMessages.forEach(tr::contains);\n-\n-        if (!tr.testStatus) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"test case: failed\\n\" + cmd);\n-        }\n-    }\n-\n-    \/**\n-     * Verifies that java -help output doesn't contain information about \"mJRE\" flags.\n-     *\/\n-    @Test\n-    public void javaHelp() {\n-        TestResult tr = doExec(javaCmd, \"-help\");\n-        tr.checkPositive();\n-        tr.isNotZeroOutput();\n-        tr.notContains(\"-version:<value>\");\n-        tr.notContains(\"-jre-restrict-search\");\n-        tr.notContains(\"-jre-no-restrict-search\");\n-        tr.notContains(\"-no-jre-restrict-search\");  \/\/it's not a typo in flag name.\n-        if (!tr.testStatus) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Failed. java -help output contains obsolete flags.\\n\");\n-        }\n-    }\n-\n-    \/**\n-     * Verifies that java -jar version.jar output ignores \"mJRE\" manifest directives.\n-     *\/\n-    @Test\n-    public void manifestDirectives() throws IOException {\n-        Map<String, String> manifest = new TreeMap<>();\n-        manifest.put(\"JRE-Version\", \"1.8\");\n-        manifest.put(\"JRE-Restrict-Search\", \"1.8\");\n-        createJar(manifest);\n-\n-        TestResult tr = doExec(javaCmd, \"-jar\", VERSION_JAR);\n-        tr.checkPositive();\n-        tr.contains(System.getProperty(\"java.version\"));\n-        if (!tr.testStatus) {\n-            System.out.println(tr);\n-            throw new RuntimeException(\"Failed.\\n\");\n-        }\n-    }\n-\n-    private void emitFile() throws IOException {\n-        List<String> scr = new ArrayList<>();\n-        scr.add(\"public class PrintVersion {\");\n-        scr.add(\"    public static void main(String... args) {\");\n-        scr.add(\"       System.out.println(System.getProperty(\\\"java.version\\\"));\");\n-        scr.add(\"    }\");\n-        scr.add(\"}\");\n-        createFile(javaFile, scr);\n-        compile(javaFile.getName());\n-    }\n-\n-    private void createJar(Map<String, String> manifestAttributes) throws IOException {\n-        emitFile();\n-\n-        Manifest manifest = new Manifest();\n-        final Attributes mainAttributes = manifest.getMainAttributes();\n-        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n-        mainAttributes.putValue(\"Main-Class\", PRINT_VERSION_CLASS);\n-        manifestAttributes.forEach(mainAttributes::putValue);\n-\n-        try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(VERSION_JAR), manifest)) {\n-            jar.putNextEntry(new ZipEntry(PRINT_VERSION_CLASS + \".class\"));\n-            jar.write(Files.readAllBytes(clsFile.toPath()));\n-            jar.closeEntry();\n-        } finally {\n-            javaFile.delete();\n-        }\n-    }\n-\n-    private enum Flag {\n-        EMPTY(\"\", \"\"),\n-        VERSION(\"-version:1.9\", \"Error: Specifying an alternate JDK\/JRE version is no longer supported.\\n\" +\n-                \"The use of the flag '-version:' is no longer valid.\\n\" +\n-                \"Please download and execute the appropriate version.\"),\n-        JRE_RESTRICT_SEARCH(\"-jre-restrict-search\", \"Error: Specifying an alternate JDK\/JRE is no longer supported.\\n\" +\n-                \"The related flags -jre-restrict-search | -jre-no-restrict-search are also no longer valid.\"),\n-        JRE_NO_RESTRICT_SEARCH(\"-jre-no-restrict-search\", \"Error: Specifying an alternate JDK\/JRE is no longer supported.\\n\" +\n-                \"The related flags -jre-restrict-search | -jre-no-restrict-search are also no longer valid.\");\n-        private final String flag;\n-        private final String errorMessage;\n-\n-        Flag(String flag, String errorMessage) {\n-            this.flag = flag;\n-            this.errorMessage = errorMessage;\n-        }\n-\n-        String value() {\n-            return flag;\n-        }\n-\n-        String errorMessage() {\n-            return errorMessage;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/tools\/launcher\/MultipleJRERemoved.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -390,0 +390,1 @@\n+        vmOptFinalFlag(map, \"UseLargePages\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -489,0 +489,103 @@\n+\n+    @Test\n+    public void testLeadingCodeBlock(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/     Leading code block\n+                    \/\/\/ Lorum ipsum.\n+                    public class C { }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ check first sentence is empty in package summary file\n+        checkOutput(\"p\/package-summary.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color class-summary class-summary-tab2\"><a href=\"C.html\" title=\"class in p\">C<\/a><\/div>\n+                    <div class=\"col-last even-row-color class-summary class-summary-tab2\">&nbsp;<\/div>\"\"\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><pre><code>Leading code block\n+                    <\/code><\/pre>\n+                    <p>Lorum ipsum.<\/p>\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testTrailingCodeBlock(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Lorum ipsum.\n+                    \/\/\/\n+                    \/\/\/     Trailing code block\n+                    public class C { }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>Lorum ipsum.<\/p>\n+                    <pre><code>Trailing code block\n+                    <\/code><\/pre>\n+                    <\/div>\"\"\");\n+    }\n+\n+    \/\/ this example is derived from the test case in JDK-8338525\n+    @Test\n+    public void testLeadingTrailingCodeBlockWithAnnotations(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/     @Override\n+                        \/\/\/     void m() {}\n+                        \/\/\/\n+                        \/\/\/ Plain text\n+                        \/\/\/\n+                        \/\/\/     @Override\n+                        \/\/\/     void m() {}\n+                        public void m() {}\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color method-summary-table method-summary-table-tab2 \\\n+                    method-summary-table-tab4\"><code>void<\/code><\/div>\n+                    <div class=\"col-second even-row-color method-summary-table method-summary-table-tab2 \\\n+                    method-summary-table-tab4\"><code><a href=\"#m()\" class=\"member-name-link\">m<\/a>()<\/code><\/div>\n+                    <div class=\"col-last even-row-color method-summary-table method-summary-table-tab2 \\\n+                    method-summary-table-tab4\">&nbsp;<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;\\\n+                    <span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                    <div class=\"block\"><pre><code>@Override\n+                    void m() {}\n+                    <\/code><\/pre>\n+                    <p>Plain text<\/p>\n+                    <pre><code>@Override\n+                    void m() {}\n+                    <\/code><\/pre>\n+                    <\/div>\"\"\");\n+\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownCodeBlocks.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1046,0 +1046,1 @@\n+        \/\/ See comment in MarkdownTest for explanation of dummy and Override\n@@ -1047,1 +1048,1 @@\n-            return s.replaceAll(\"\\n[ \\t]+@(?!([@*]|dummy))\", \"\\n@\");\n+            return s.replaceAll(\"\\n[ \\t]+@(?!([@*]|(dummy|Override)))\", \"\\n@\");\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * (\"@Override\" is also treated the same way, as a commonly found annotation.)\n@@ -412,0 +413,26 @@\n+*\/\n+\n+    \/\/\/     Indented Code Block\n+    \/\/\/ Lorum ipsum.\n+    void indentedCodeBlock_leading() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: 1\n+    RawText[MARKDOWN, pos:0, ____Indented_Code_Block|Lorum_ipsum.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/ Lorum ipsum.\n+    \/\/\/\n+    \/\/\/     Indented Code Block\n+    void indentedCodeBlock_trailing() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Lorum_ipsum.]\n+  body: 1\n+    RawText[MARKDOWN, pos:18, Indented_Code_Block]\n+  block tags: empty\n+]\n@@ -616,0 +643,19 @@\n+\/\/ The following test case is derived from the test case in JDK-8338525.\n+\n+    \/\/\/     @Override\n+    \/\/\/     void m() { }\n+    \/\/\/\n+    \/\/\/ Plain text\n+    \/\/\/\n+    \/\/\/     @Override\n+    \/\/\/     void m() { }\n+    void leadingTrailingCodeBlocksWithAnnos() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: 1\n+    RawText[MARKDOWN, pos:0, ____@Override|____void_m()_{_}||...||____@Override|____void_m()_{_}]\n+  block tags: empty\n+]\n+*\/\n+\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340568\n+ * @summary Incorrect escaping of single quotes when pretty-printing character literals\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *\/\n+\n+import com.sun.tools.javac.file.JavacFileManager;\n+import com.sun.tools.javac.tree.Pretty;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.util.Context;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+\n+public class PrettyCharLiteral {\n+    public static void main(String... args) throws Exception {\n+        new PrettyCharLiteral().run();\n+    }\n+\n+    private final TreeMaker make;\n+\n+    private PrettyCharLiteral() {\n+        Context ctx = new Context();\n+        JavacFileManager.preRegister(ctx);\n+        this.make = TreeMaker.instance(ctx);\n+    }\n+\n+    void run() throws Exception {\n+        assertEquals(\n+                prettyPrintLiteral('\\''),\n+                \"\"\"\n+                '\\\\''\n+                \"\"\".trim());\n+        assertEquals(\n+                prettyPrintLiteral('\"'),\n+                \"\"\"\n+                '\"'\n+                \"\"\".trim());\n+        assertEquals(\n+                prettyPrintLiteral(\"'\"),\n+                \"\"\"\n+                \"'\"\n+                \"\"\".trim());\n+        assertEquals(\n+                prettyPrintLiteral(\"\\\"\"),\n+                \"\"\"\n+                \"\\\\\"\"\n+                \"\"\".trim());\n+    }\n+\n+    private void assertEquals(String actual, String expected) {\n+        if (!actual.equals(expected)) {\n+            throw new AssertionError(\"expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+    private String prettyPrintLiteral(Object value) throws IOException {\n+        StringWriter sw = new StringWriter();\n+        new Pretty(sw, true).printExpr(make.Literal(value));\n+        return sw.toString();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/tree\/PrettyCharLiteral.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -95,12 +96,8 @@\n-            try {\n-                if (files.memory() != null) {\n-                    Files.delete(files.memory());\n-                }\n-                if (files.cpu() != null) {\n-                    Files.delete(files.cpu());\n-                }\n-                if (files.sliceDotDDir() != null) {\n-                    FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n-                }\n-            } catch (NoSuchFileException e) {\n-                \/\/ ignore\n+            cleanupFiles(files);\n+        }\n+    }\n+\n+    private static void cleanupFiles(ResultFiles files) throws IOException {\n+        try {\n+            if (files.memory() != null) {\n+                Files.delete(files.memory());\n@@ -108,0 +105,8 @@\n+            if (files.cpu() != null) {\n+                Files.delete(files.cpu());\n+            }\n+            if (files.sliceDotDDir() != null) {\n+                FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n+            }\n+        } catch (NoSuchFileException e) {\n+            \/\/ ignore\n@@ -138,1 +143,3 @@\n-            Files.createDirectory(sliceDotDDir);\n+            \/\/ Using createDirectories since we only need to ensure the directory\n+            \/\/ exists. Ignore it if already existent.\n+            Files.createDirectories(sliceDotDDir);\n@@ -142,1 +149,4 @@\n-                Files.writeString(memoryConfig, getMemoryDSliceContent(runOpts));\n+                Files.writeString(memoryConfig,\n+                                  getMemoryDSliceContent(runOpts),\n+                                  StandardOpenOption.TRUNCATE_EXISTING,\n+                                  StandardOpenOption.CREATE);\n@@ -146,1 +156,4 @@\n-                Files.writeString(cpuConfig, getCPUDSliceContent(runOpts));\n+                Files.writeString(cpuConfig,\n+                                  getCPUDSliceContent(runOpts),\n+                                  StandardOpenOption.TRUNCATE_EXISTING,\n+                                  StandardOpenOption.CREATE);\n@@ -162,1 +175,1 @@\n-        systemdDaemonReload(cpu);\n+        systemdDaemonReload(cpu, memory, sliceDotDDir);\n@@ -178,1 +191,1 @@\n-    private static void systemdDaemonReload(Path cpu) throws Exception {\n+    private static void systemdDaemonReload(Path cpu, Path memory, Path sliceDdir) throws Exception {\n@@ -183,1 +196,14 @@\n-            throw new AssertionError(\"Failed to reload systemd daemon\");\n+            if (RUN_AS_USER) {\n+                cleanupFiles(new ResultFiles(cpu, memory, sliceDdir));\n+                \/\/ When run as user the systemd user manager needs to be\n+                \/\/ accessible and working. This is usually the case when\n+                \/\/ connected via SSH or user login, but may not work for\n+                \/\/ sessions set up via 'su <user>' or similar.\n+                \/\/ In that case, 'systemctl --user status' usually doesn't\n+                \/\/ work. There is no other option than skip the test.\n+                String msg = \"Service user@.service not properly configured. \" +\n+                             \"Skipping the test!\";\n+                throw new SkippedException(msg);\n+            } else {\n+                throw new AssertionError(\"Failed to reload systemd daemon\");\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdTestUtils.java","additions":44,"deletions":18,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.reflect.proxy;\n-\n-import java.util.List;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Benchmark measuring java.lang.reflect.ProxyGenerator.generateProxyClass.\n- * It bypasses the cache of proxies to measure the time to construct a proxy.\n- *\/\n-@Warmup(iterations = 5)\n-@Measurement(iterations = 10)\n-@Fork(value = 1)\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-public class ProxyPerf {\n-\n-    \/**\n-     * Sample results from a Dell T7610.\n-     * Benchmark                        Mode  Cnt      Score      Error  Units\n-     *      ProxyPerf.genIntf_1              avgt   10  35325.428 +\/-  780.459  ns\/op\n-     *      ProxyPerf.genIntf_1_V49          avgt   10  34309.423 +\/-  727.188  ns\/op\n-     *      ProxyPerf.genStringsIntf_3       avgt   10  46600.366 +\/-  663.812  ns\/op\n-     *      ProxyPerf.genStringsIntf_3_V49   avgt   10  45911.817 +\/- 1598.536  ns\/op\n-     *      ProxyPerf.genZeroParams          avgt   10  33245.048 +\/-  437.988  ns\/op\n-     *      ProxyPerf.genZeroParams_V49      avgt   10  32954.254 +\/- 1041.932  ns\/op\n-     *      ProxyPerf.getPrimsIntf_2         avgt   10  43987.819 +\/-  837.443  ns\/op\n-     *      ProxyPerf.getPrimsIntf_2_V49     avgt   10  42863.462 +\/- 1193.480  ns\/op\n-     *\/\n-\n-    public interface Intf_1 {\n-        public Object mL(Object o);\n-    }\n-\n-    public interface Intf_2 {\n-        public int m1I(int i);\n-        public long m2IJ(int i, long l);\n-    }\n-\n-    public interface Intf_3 {\n-        public void mString(String s1);\n-        public String m2String(String s1);\n-        public String m2String(String s1, String s2);\n-    }\n-\n-    private InvocationHandler handler;\n-    private ClassLoader classloader;\n-    private Method proxyGen;\n-    private Method proxyGenV49;\n-\n-    @Setup\n-    public void setup() {\n-        try {\n-            handler = (Object proxy, Method method, Object[] args) -> null;\n-            classloader = ClassLoader.getSystemClassLoader();\n-            Class<?> proxyGenClass = Class.forName(\"java.lang.reflect.ProxyGenerator\");\n-            proxyGen = proxyGenClass.getDeclaredMethod(\"generateProxyClass\",\n-                    ClassLoader.class, String.class, java.util.List.class, int.class);\n-            proxyGen.setAccessible(true);\n-\n-            \/\/ Init access to the old Proxy generator\n-            Class<?> proxyGenClassV49 = Class.forName(\"java.lang.reflect.ProxyGenerator_v49\");\n-            proxyGenV49 = proxyGenClassV49.getDeclaredMethod(\"generateProxyClass\",\n-                    String.class, java.util.List.class, int.class);\n-            proxyGenV49.setAccessible(true);\n-\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(\"ProxyClass setup fails\", ex);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void genZeroParams(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Runnable.class);\n-        bh.consume(proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1));\n-    }\n-\n-    @Benchmark\n-    public void genIntf_1(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Intf_1.class);\n-        bh.consume(proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1));\n-    }\n-\n-    @Benchmark\n-    public void getPrimsIntf_2(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Intf_2.class);\n-        bh.consume(proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1));\n-    }\n-    @Benchmark\n-    public void genStringsIntf_3(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Intf_3.class);\n-        bh.consume(proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1));\n-    }\n-\n-    \/\/ Generate using the V49inal generator for comparison\n-\n-    @Benchmark\n-    public void genZeroParams_V49(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Runnable.class);\n-        bh.consume(proxyGenV49.invoke(null, \"ProxyImpl\", interfaces, 1));\n-    }\n-\n-    @Benchmark\n-    public void genIntf_1_V49(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Intf_1.class);\n-        bh.consume(proxyGenV49.invoke(null, \"ProxyImpl\", interfaces, 1));\n-    }\n-\n-    @Benchmark\n-    public void getPrimsIntf_2_V49(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Intf_2.class);\n-        bh.consume(proxyGenV49.invoke(null, \"ProxyImpl\", interfaces, 1));\n-    }\n-    @Benchmark\n-    public void genStringsIntf_3_V49(Blackhole bh) throws Exception {\n-        List<Class<?>> interfaces = List.of(Intf_3.class);\n-        bh.consume(proxyGenV49.invoke(null, \"ProxyImpl\", interfaces, 1));\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/Proxy\/ProxyPerf.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/proxy\/ProxyBench.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/Proxy\/ProxyBench.java","status":"renamed"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.reflect.proxy;\n+\n+import java.util.List;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark measuring java.lang.reflect.ProxyGenerator.generateProxyClass.\n+ * It bypasses the cache of proxies to measure the time to construct a proxy.\n+ *\/\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 1, jvmArgsPrepend = \"--add-opens=java.base\/java.lang.reflect=ALL-UNNAMED\")\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class ProxyGeneratorBench {\n+\n+    \/**\n+     * Sample results from a Dell T7610.\n+     * Benchmark                        Mode  Cnt      Score      Error  Units\n+     *      ProxyPerf.genIntf_1              avgt   10  35325.428 +\/-  780.459  ns\/op\n+     *      ProxyPerf.genStringsIntf_3       avgt   10  46600.366 +\/-  663.812  ns\/op\n+     *      ProxyPerf.genZeroParams          avgt   10  33245.048 +\/-  437.988  ns\/op\n+     *      ProxyPerf.genPrimsIntf_2         avgt   10  43987.819 +\/-  837.443  ns\/op\n+     *\/\n+\n+    public interface Intf_1 {\n+        public Object mL(Object o);\n+    }\n+\n+    public interface Intf_2 {\n+        public int m1I(int i);\n+        public long m2IJ(int i, long l);\n+    }\n+\n+    public interface Intf_3 {\n+        public void mString(String s1);\n+        public String m2String(String s1);\n+        public String m2String(String s1, String s2);\n+    }\n+\n+    private ClassLoader classloader;\n+    private Method proxyGen;\n+    private Method proxyGenV49;\n+\n+    @Setup\n+    public void setup() {\n+        try {\n+            classloader = ClassLoader.getSystemClassLoader();\n+            Class<?> proxyGenClass = Class.forName(\"java.lang.reflect.ProxyGenerator\");\n+            proxyGen = proxyGenClass.getDeclaredMethod(\"generateProxyClass\",\n+                    ClassLoader.class, String.class, java.util.List.class, int.class);\n+            proxyGen.setAccessible(true);\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(\"ProxyClass setup fails\", ex);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object genZeroParams() throws Exception {\n+        List<Class<?>> interfaces = List.of(Runnable.class);\n+        return proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1);\n+    }\n+\n+    @Benchmark\n+    public Object genIntf_1() throws Exception {\n+        List<Class<?>> interfaces = List.of(Intf_1.class);\n+        return proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1);\n+    }\n+\n+    @Benchmark\n+    public Object genPrimsIntf_2() throws Exception {\n+        List<Class<?>> interfaces = List.of(Intf_2.class);\n+        return proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1);\n+    }\n+\n+    @Benchmark\n+    public Object genStringsIntf_3() throws Exception {\n+        List<Class<?>> interfaces = List.of(Intf_3.class);\n+        return proxyGen.invoke(null, classloader, \"ProxyImpl\", interfaces, 1);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        var benchmark = new ProxyGeneratorBench();\n+        benchmark.setup();\n+        benchmark.genZeroParams();\n+        benchmark.genIntf_1();\n+        benchmark.genPrimsIntf_2();\n+        benchmark.genStringsIntf_3();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/proxy\/ProxyGeneratorBench.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.openjdk.bench.jdk.classfile.TestConstants.*;\n+\n+\/**\n+ * Tests constant pool builder lookup performance for ClassEntry.\n+ * Note that ClassEntry is available only for reference types.\n+ *\/\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 5)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsAppend = {\"--enable-preview\"})\n+@State(Scope.Benchmark)\n+public class ConstantPoolBuildingClassEntry {\n+    \/\/ JDK-8338546\n+    ConstantPoolBuilder builder;\n+    List<ClassDesc> classDescs;\n+    List<ClassDesc> nonIdenticalClassDescs;\n+    List<String> internalNames;\n+    List<ClassDesc> nonDuplicateClassDescs;\n+    List<String> nonDuplicateInternalNames;\n+    int size;\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        builder = ConstantPoolBuilder.of();\n+        \/\/ Note these can only be reference types, no primitives\n+        classDescs = List.of(\n+                CD_Byte, CD_Object, CD_Long.arrayType(), CD_String, CD_String, CD_Object, CD_Short,\n+                CD_MethodHandle, CD_MethodHandle, CD_Object, CD_Character, CD_List, CD_ArrayList,\n+                CD_List, CD_Set, CD_Integer, CD_Object.arrayType(), CD_Enum, CD_Object, CD_MethodHandles_Lookup,\n+                CD_Long, CD_Set, CD_Object, CD_Character, CD_Integer, CD_System, CD_String, CD_String,\n+                CD_CallSite, CD_Collection, CD_List, CD_Collection, CD_String, CD_int.arrayType()\n+        );\n+        size = classDescs.size();\n+        nonIdenticalClassDescs = classDescs.stream().map(cd -> {\n+            var ret = ClassDesc.ofDescriptor(new String(cd.descriptorString()));\n+            ret.hashCode(); \/\/ pre-compute hash code for cd\n+            return ret;\n+        }).toList();\n+        internalNames = classDescs.stream().map(cd -> {\n+            \/\/ also sets up builder\n+            cd.hashCode(); \/\/ pre-computes hash code for cd\n+            var ce = builder.classEntry(cd);\n+            var ret = ce.name().stringValue();\n+            ret.hashCode(); \/\/ pre-computes hash code for stringValue\n+            return ret;\n+        }).toList();\n+        nonDuplicateClassDescs = List.copyOf(new LinkedHashSet<>(classDescs));\n+        nonDuplicateInternalNames = nonDuplicateClassDescs.stream().map(cd ->\n+                builder.classEntry(cd).asInternalName()).toList();\n+    }\n+\n+    \/\/ Copied from jdk.internal.classfile.impl.Util::toInternalName\n+    \/\/ to reduce internal dependencies\n+    public static String toInternalName(ClassDesc cd) {\n+        var desc = cd.descriptorString();\n+        if (desc.charAt(0) == 'L')\n+            return desc.substring(1, desc.length() - 1);\n+        throw new IllegalArgumentException(desc);\n+    }\n+\n+    \/**\n+     * Looking up with identical ClassDesc objects. Happens in bytecode generators reusing\n+     * constant CD_Xxx.\n+     *\/\n+    @Benchmark\n+    public void identicalLookup(Blackhole bh) {\n+        for (var cd : classDescs) {\n+            bh.consume(builder.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Looking up with non-identical ClassDesc objects. Happens in bytecode generators\n+     * using ad-hoc Class.describeConstable().orElseThrow() or other parsed ClassDesc.\n+     * Cannot use identity fast path compared to {@link #identicalLookup}.\n+     *\/\n+    @Benchmark\n+    public void nonIdenticalLookup(Blackhole bh) {\n+        for (var cd : nonIdenticalClassDescs) {\n+            bh.consume(builder.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Looking up with internal names. Closest to ASM behavior.\n+     * Baseline for {@link #identicalLookup}.\n+     *\/\n+    @Benchmark\n+    public void internalNameLookup(Blackhole bh) {\n+        for (var name : internalNames) {\n+            bh.consume(builder.classEntry(builder.utf8Entry(name)));\n+        }\n+    }\n+\n+    \/**\n+     * The default implementation provided by {@link ConstantPoolBuilder#classEntry(ClassDesc)}.\n+     * Does substring so needs to rehash and has no caching, should be very slow.\n+     *\/\n+    @Benchmark\n+    public void oldStyleLookup(Blackhole bh) {\n+        for (var cd : classDescs) {\n+            var s = cd.isClassOrInterface() ? toInternalName(cd) : cd.descriptorString();\n+            bh.consume(builder.classEntry(builder.utf8Entry(s)));\n+        }\n+    }\n+\n+    \/**\n+     * Measures performance of creating new class entries in new constant pools with symbols.\n+     *\/\n+    @Benchmark\n+    public void freshCreationWithDescs(Blackhole bh) {\n+        var cp = ConstantPoolBuilder.of();\n+        for (var cd : nonDuplicateClassDescs) {\n+            bh.consume(cp.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Measures performance of creating new class entries in new constant pools with internal names.\n+     *\/\n+    @Benchmark\n+    public void freshCreationWithInternalNames(Blackhole bh) {\n+        var cp = ConstantPoolBuilder.of();\n+        for (var name : nonDuplicateInternalNames) {\n+            bh.consume(cp.classEntry(cp.utf8Entry(name)));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ConstantPoolBuildingClassEntry.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}