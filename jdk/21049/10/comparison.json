{"files":[{"patch":"@@ -432,0 +432,3 @@\n+\n+    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n+    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -92,1 +93,2 @@\n-    private static final class Transform extends SoftReference<LambdaForm> {\n+    private static final class Transform {\n+        final Object cache;\n@@ -97,1 +99,5 @@\n-            super(result);\n+            if (USE_SOFT_CACHE) {\n+                cache = new SoftReference<LambdaForm>(result);\n+            } else {\n+                cache = result;\n+            }\n@@ -138,0 +144,9 @@\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        public LambdaForm get() {\n+            if (cache instanceof LambdaForm lf) {\n+                return lf;\n+            } else {\n+                return ((SoftReference<LambdaForm>)cache).get();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -34,0 +35,1 @@\n+import java.util.Properties;\n@@ -693,0 +695,19 @@\n+\n+    \/\/--- AOTCache support\n+\n+    \/**\n+     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n+     * use soft references to allow class unloading.\n+     *\n+     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n+     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n+     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n+     * Such classes will never be unloaded, so it's OK to use hard references.\n+     *\/\n+    static final boolean USE_SOFT_CACHE;\n+\n+    static {\n+        Properties props = GetPropertyAction.privilegedGetProperties();\n+        USE_SOFT_CACHE = Boolean.parseBoolean(\n+                props.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -54,1 +55,1 @@\n-    final SoftReference<MethodHandle>[] methodHandles;\n+    private final Object[] methodHandles;\n@@ -64,1 +65,1 @@\n-    final SoftReference<LambdaForm>[] lambdaForms;\n+    private final Object[] lambdaForms;\n@@ -112,0 +113,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -113,2 +115,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = methodHandles[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof MethodHandle mh) {\n+            return mh;\n+        } else {\n+            return ((SoftReference<MethodHandle>)entry).get();\n+        }\n@@ -119,6 +127,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        if (entry != null) {\n-            MethodHandle prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        MethodHandle prev = cachedMethodHandle(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (USE_SOFT_CACHE) {\n+            methodHandles[which] = new SoftReference<>(mh);\n+        } else {\n+            methodHandles[which] = mh;\n@@ -126,1 +136,0 @@\n-        methodHandles[which] = new SoftReference<>(mh);\n@@ -130,0 +139,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -131,2 +141,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = lambdaForms[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof LambdaForm lf) {\n+            return lf;\n+        } else {\n+            return ((SoftReference<LambdaForm>)entry).get();\n+        }\n@@ -137,6 +153,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        if (entry != null) {\n-            LambdaForm prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        LambdaForm prev = cachedLambdaForm(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (USE_SOFT_CACHE) {\n+            lambdaForms[which] = new SoftReference<>(form);\n+        } else {\n+            lambdaForms[which] = form;\n@@ -144,1 +162,0 @@\n-        lambdaForms[which] = new SoftReference<>(form);\n@@ -194,2 +211,2 @@\n-            this.lambdaForms   = new SoftReference[LF_LIMIT];\n-            this.methodHandles = new SoftReference[MH_LIMIT];\n+            this.lambdaForms   = new Object[LF_LIMIT];\n+            this.methodHandles = new Object[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"}]}