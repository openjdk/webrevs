{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import static java.lang.invoke.MethodHandleStatics.NO_SOFT_CACHE;\n@@ -92,1 +93,2 @@\n-    private static final class Transform extends SoftReference<LambdaForm> {\n+    private static final class Transform {\n+        final Object cache;\n@@ -97,1 +99,5 @@\n-            super(result);\n+            if (NO_SOFT_CACHE) {\n+                cache = result;\n+            } else {\n+                cache = new SoftReference<LambdaForm>(result);\n+            }\n@@ -138,0 +144,9 @@\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        public LambdaForm get() {\n+            if (cache instanceof LambdaForm lf) {\n+                return lf;\n+            } else {\n+                return ((SoftReference<LambdaForm>)cache).get();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    static final boolean NO_SOFT_CACHE; \/\/ Don't use SoftReference in LambdaFormEditor and MethodTypeForm so they can be archived by CDS.\n@@ -91,0 +92,1 @@\n+        NO_SOFT_CACHE = CDS.disableMethodHandleSoftCache();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static java.lang.invoke.MethodHandleStatics.NO_SOFT_CACHE;\n@@ -54,1 +55,1 @@\n-    final SoftReference<MethodHandle>[] methodHandles;\n+    private final Object[] methodHandles;\n@@ -64,1 +65,1 @@\n-    final SoftReference<LambdaForm>[] lambdaForms;\n+    private final Object[] lambdaForms;\n@@ -112,0 +113,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -113,2 +115,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = methodHandles[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof MethodHandle mh) {\n+            return mh;\n+        } else {\n+            return ((SoftReference<MethodHandle>)entry).get();\n+        }\n@@ -119,6 +127,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        if (entry != null) {\n-            MethodHandle prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        MethodHandle prev = cachedMethodHandle(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (NO_SOFT_CACHE) {\n+            methodHandles[which] = mh;\n+        } else {\n+            methodHandles[which] = new SoftReference<>(mh);\n@@ -126,1 +136,0 @@\n-        methodHandles[which] = new SoftReference<>(mh);\n@@ -130,0 +139,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -131,2 +141,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = lambdaForms[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof LambdaForm lf) {\n+            return lf;\n+        } else {\n+            return ((SoftReference<LambdaForm>)entry).get();\n+        }\n@@ -137,6 +153,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        if (entry != null) {\n-            LambdaForm prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        LambdaForm prev = cachedLambdaForm(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (NO_SOFT_CACHE) {\n+            lambdaForms[which] = form;\n+        } else {\n+            lambdaForms[which] = new SoftReference<>(form);\n@@ -144,1 +162,0 @@\n-        lambdaForms[which] = new SoftReference<>(form);\n@@ -194,2 +211,2 @@\n-            this.lambdaForms   = new SoftReference[LF_LIMIT];\n-            this.methodHandles = new SoftReference[MH_LIMIT];\n+            this.lambdaForms   = new Object[LF_LIMIT];\n+            this.methodHandles = new Object[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -79,0 +79,10 @@\n+    \/*\n+     * When dumping the static archive, CDS is able to archive MethodHandles.\n+     * However, CDS cannot archive SoftReference objects, so we need to\n+     * make sure the archived MethodHandles do not directly or indirectly use\n+     * SoftReferences.\n+     *\/\n+    public static boolean disableMethodHandleSoftCache() {\n+        return isDumpingStaticArchive();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}