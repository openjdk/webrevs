{"files":[{"patch":"@@ -2426,1 +2426,8 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n+        try {\n+            return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n+        } catch (ClassFinder.BadClassFile err) {\n+            return new BadClassFileError(err);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return typeNotFound;\n+        }\n@@ -2498,1 +2505,8 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name));\n+        try {\n+            return checkNonExistentType(checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name));\n+        } catch (ClassFinder.BadClassFile err) {\n+            return new BadClassFileError(err);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return typeNotFound;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8198378\n+ * @bug 8198378 8335385\n@@ -56,1 +56,3 @@\n-                   \"package p; public class B { public static class I { } }\")\n+                   \"package p; public class B { public static class I { } }\",\n+                   \"package m; public class A { }\",\n+                   \"package m; public class B { public static class I { } }\")\n@@ -68,0 +70,3 @@\n+        Files.delete(Paths.get(\".\", \"m\", \"A.class\"));\n+        Files.delete(Paths.get(\".\", \"m\", \"B$I.class\"));\n+\n@@ -72,0 +77,4 @@\n+        doTest(\"import m.A;\",\n+               \"\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"1 error\");\n@@ -77,0 +86,5 @@\n+        doTest(\"import m.A;\",\n+               \"A a;\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"Test.java:2:33: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -82,0 +96,5 @@\n+        doTest(\"import m.A;\",\n+               \"void test() { A a; }\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"Test.java:2:47: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -85,0 +104,3 @@\n+        doTest(\"import m.*;\",\n+               \"\",\n+               (String[]) null);\n@@ -89,0 +111,4 @@\n+        doTest(\"import m.*;\",\n+               \"A a;\",\n+               \"Test.java:2:33: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -93,0 +119,4 @@\n+        doTest(\"import m.*;\",\n+               \"void test() { A a; }\",\n+               \"Test.java:2:47: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -98,0 +128,4 @@\n+        doTest(\"import m.B.I;\",\n+               \"\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -101,1 +135,7 @@\n-               \"1 error\");\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"import m.B.I;\",\n+               \"I i;\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -105,1 +145,7 @@\n-               \"1 error\");\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"import m.B.I;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -109,0 +155,3 @@\n+        doTest(\"import m.B.*;\",\n+               \"\",\n+               (String[]) null);\n@@ -113,0 +162,8 @@\n+        doTest(\"import m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n+        doTest(\"import m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -117,0 +174,4 @@\n+        doTest(\"import m.B.*;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -122,0 +183,4 @@\n+        doTest(\"import static m.B.I;\",\n+               \"\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -126,0 +191,4 @@\n+        doTest(\"import static m.B.I;\",\n+               \"I i;\",\n+               \"Test.java:2:42: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -130,0 +199,5 @@\n+        doTest(\"import static m.B.I;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:56: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -134,0 +208,4 @@\n+        doTest(\"import static m.B.*;\",\n+               \"\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -138,0 +216,4 @@\n+        doTest(\"import static m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:42: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -142,0 +224,5 @@\n+        doTest(\"import static m.B.*;\",\n+               \"void test() { M m; }\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:56: compiler.err.cant.resolve.location: kindname.class, M, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -149,1 +236,2 @@\n-                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS,\n+                     expectedOutput != null ? 1 : 0)\n","filename":"test\/langtools\/tools\/javac\/importscope\/BadClassFileDuringImport.java","additions":94,"deletions":6,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335385\n+ * @summary Verify that BadClassFile related to imports are handled properly.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ASTAttributesFilledForReferencesOnMissingTypes\n+ *\/\n+\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.Element;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ASTAttributesFilledForReferencesOnMissingTypes {\n+    public static void main(String... args) throws Exception {\n+        new ASTAttributesFilledForReferencesOnMissingTypes().run();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    void run() throws Exception {\n+        new JavacTask(tb)\n+          .outdir(\".\")\n+          .sources(\"package p; public class A { }\",\n+                   \"package p; public class B { public static class I { } public static class M { } }\",\n+                   \"package p; public class C { }\")\n+          .run()\n+          .writeAll();\n+\n+        try (OutputStream out = Files.newOutputStream(Paths.get(\".\", \"p\", \"A.class\"))) {\n+            out.write(\"broken\".getBytes(\"UTF-8\"));\n+        }\n+\n+        try (OutputStream out = Files.newOutputStream(Paths.get(\".\", \"p\", \"B$I.class\"))) {\n+            out.write(\"broken\".getBytes(\"UTF-8\"));\n+        }\n+\n+        Files.delete(Paths.get(\".\", \"p\", \"C.class\"));\n+        Files.delete(Paths.get(\".\", \"p\", \"B$M.class\"));\n+\n+        \/\/tests for findIdent (must be in some global scope):\n+        doTest(\"\"\"\n+               package p;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.*;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               package p;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, p.Test, null)\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.*;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n+\n+        \/\/tests for findIdentInPackage:\n+        doTest(\"\"\"\n+               import p.A;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:1:9: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.A a;\n+               }\n+               \"\"\",\n+               \"Test.java:2:6: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.C;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:1:9: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.package, p, null)\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.C c;\n+               }\n+               \"\"\",\n+               \"Test.java:2:6: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.package, p, null)\",\n+               \"1 error\");\n+\n+        \/\/tests for findIdentInType:\n+        doTest(\"\"\"\n+               import p.B.I;\n+               public class Test {\n+                   I i;\n+               }\n+               \"\"\",\n+               \"Test.java:1:11: compiler.err.cant.access: p.B.I, (compiler.misc.bad.class.file.header: B$I.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               import p.B.M;\n+               public class Test {\n+                   M m;\n+               }\n+               \"\"\",\n+               \"Test.java:1:11: compiler.err.cant.access: p.B.M, (compiler.misc.class.file.not.found: p.B$M)\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, M, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.B.I i;\n+               }\n+               \"\"\",\n+               \"Test.java:2:8: compiler.err.cant.access: p.B.I, (compiler.misc.bad.class.file.header: B$I.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.B.M m;\n+               }\n+               \"\"\",\n+               \"Test.java:2:8: compiler.err.cant.access: p.B.M, (compiler.misc.class.file.not.found: p.B$M)\",\n+               \"1 error\");\n+    }\n+\n+    void doTest(String code, String... expectedOutput) {\n+        List<String> log = new JavacTask(tb)\n+                .classpath(\".\")\n+                .sources(code)\n+                .options(\"-XDrawDiagnostics\")\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            if (e.getKind() != TaskEvent.Kind.ANALYZE) {\n+                                return ;\n+                            }\n+                            Trees trees = Trees.instance(task);\n+                            new TreePathScanner<Void, Void>() {\n+                                @Override\n+                                public Void visitIdentifier(IdentifierTree node, Void p) {\n+                                    validateAttributes();\n+                                    return super.visitIdentifier(node, p);\n+                                }\n+                                @Override\n+                                public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+                                    if (!node.getIdentifier().contentEquals(\"*\")) {\n+                                        validateAttributes();\n+                                    }\n+                                    return super.visitMemberSelect(node, p);\n+                                }\n+                                void validateAttributes() {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    if (el == null) {\n+                                        throw new AssertionError(\"A null sym attribute for: \" + getCurrentPath().getLeaf() + \"!\");\n+                                    }\n+                                }\n+                            }.scan(e.getCompilationUnit(), null);\n+                        }\n+                    });\n+                })\n+                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS,\n+                     expectedOutput != null ? 1 : 0)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (expectedOutput != null && !log.equals(Arrays.asList(expectedOutput))) {\n+            throw new AssertionError(\"Unexpected output: \" + log);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/tree\/ASTAttributesFilledForReferencesOnMissingTypes.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"}]}