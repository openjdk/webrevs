{"files":[{"patch":"@@ -409,1 +409,1 @@\n-  if (is_optimized_multiplication()) {\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n@@ -415,3 +415,0 @@\n-  int in1_op = in1->Opcode();\n-\n-  bool matched = false;\n@@ -419,0 +416,6 @@\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_subtraction_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; \/\/ +1 for the in2 term\n@@ -420,6 +423,8 @@\n-  \/\/ Convert (a + a) + a to 3 * a\n-  \/\/ Look for LHS pattern: AddNode(a, a)\n-  if (in1_op == Op_Add(bt) && in1->in(1) == in1->in(2)) {\n-    if (in1->in(1) != in2) {\n-      return nullptr;\n-    }\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in(2), bt);\n+  }\n+\n+  return nullptr;\n+}\n@@ -427,2 +432,6 @@\n-    multiplier = 2;\n-    matched = true;\n+\/\/ Match `a + a`, extract `a` and `2`\n+Node* AddNode::find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Look for pattern: AddNode(a, a)\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n+    *multiplier = 2;\n+    return n->in(1);\n@@ -431,8 +440,2 @@\n-  \/\/ Convert (a << CON) + a to a * ((1 << CON) + 1))\n-  \/\/ Look for LHS pattern: LShiftNode(a, CON)\n-  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n-  if (in1_op == Op_LShift(bt) && in1->in(2)->is_Con()) {\n-    Node* base = in1->in(1);\n-    if (base != in2) {\n-      return nullptr;\n-    }\n+  return nullptr;\n+}\n@@ -440,3 +443,7 @@\n-    Node* con = in1->in(2);\n-    BasicType con_bt = phase->type(con)->basic_type();\n-    if (con_bt == T_VOID) { \/\/ const could potentially be void type\n+\/\/ Match `a << CON`, extract `a` and `1 << CON`\n+Node* AddNode::find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Look for pattern: LShiftNode(a, CON)\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n+    Node* con = n->in(2);\n+    if (con->is_top()) {\n@@ -446,2 +453,2 @@\n-    multiplier = (jlong) 1 << con->get_integer_as_long(con_bt);\n-    matched = true;\n+    *multiplier = ((jlong) 1 << con->get_int());\n+    return n->in(1);\n@@ -450,2 +457,6 @@\n-  \/\/ Convert (CON * a) + a to (CON + 1) * a\n-  \/\/ Look for LHS patterns:\n+  return nullptr;\n+}\n+\n+\/\/ Match `CON * a`, extract `a` and `CON`\n+Node* AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Look for patterns:\n@@ -455,4 +466,7 @@\n-  if (in1_op == Op_Mul(bt) && (in1->in(1)->is_Con() || in1->in(2)->is_Con())) {\n-    Node* base = in1->in(1)->is_Con() ? in1->in(2) : in1->in(1);\n-    if (base != in2) {\n-      return nullptr;\n+  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n+    Node* con = n->in(1);\n+    Node* base = n->in(2);\n+\n+    \/\/ swap ConNode to lhs for easier matching\n+    if (!con->is_Con()) {\n+      swap(con, base);\n@@ -461,3 +475,1 @@\n-    Node* con = in1->in(1)->is_Con() ? in1->in(1) : in1->in(2);\n-    BasicType con_bt = phase->type(con)->basic_type();\n-    if (con_bt == T_VOID) { \/\/ const could potentially be void type\n+    if (con->is_top()) {\n@@ -467,2 +479,2 @@\n-    multiplier = con->get_integer_as_long(con_bt);\n-    matched = true;\n+    *multiplier = con->get_integer_as_long(bt);\n+    return base;\n@@ -471,22 +483,2 @@\n-  \/\/ Due to potential power-of-2 multiplication optimization, e.g., ((a << CON1) + (a << CON2)) + a,\n-  \/\/ we also look for LHS patterns:\n-  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n-  if (in1_op == Op_Add(bt) && in1->isa_Add()->is_optimized_multiplication()) {\n-    Node* lhs = in1->in(1);\n-    Node* rhs = in1->in(2);\n-\n-    Node* lhs_base = lhs->is_LShift() ? lhs->in(1) : lhs;\n-    Node* rhs_base = rhs->is_LShift() ? rhs->in(1) : rhs;\n-\n-    Node* nodes[] = {lhs, rhs};\n-    Node* bases[] = {lhs_base, rhs_base};\n-    jlong multipliers[] = {1, 1};\n-\n-    \/\/ AddNode(LShiftNode(a, CON1), LShiftNode(a, CON2)\/a)\n-    \/\/ AddNode(LShiftNode(a, CON1)\/a, LShiftNode(a, CON2))\n-    for (int i = 0; i < 2; i++) {\n-      if (nodes[i]->is_LShift()) {\n-        Node* con = nodes[i]->in(2);\n-        if (bases[i] != in2 || bases[0] != bases[1] || !con->is_Con()) {\n-          return nullptr;\n-        }\n+  return nullptr;\n+}\n@@ -494,4 +486,10 @@\n-        BasicType con_bt = phase->type(con)->basic_type();\n-        if (con_bt == T_VOID) {\n-          return nullptr;\n-        }\n+\/\/ Match `(a << CON1) + (a << CON2)`, extract `a` and `(1 << CON1) + (1 << CON2)`\n+\/\/ Note that one of the term could simply be `a`\n+Node* AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Look for patterns:\n+  \/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+  \/\/ given that lhs is different from rhs\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n+    Node* lhs = n->in(1);\n+    Node* rhs = n->in(2);\n@@ -499,2 +497,3 @@\n-        multipliers[i] = ((jlong) 1 << con->get_integer_as_long(con_bt));\n-      }\n+    \/\/ swap LShiftNode to lhs for easier matching\n+    if (!lhs->is_LShift()) {\n+      swap(lhs, rhs);\n@@ -503,3 +502,4 @@\n-    multiplier = multipliers[0] + multipliers[1];\n-    matched = true;\n-  }\n+    \/\/ AddNode(LShiftNode(a, CON), *)?\n+    if (!lhs->is_LShift() || !lhs->in(2)->is_Con()) {\n+      return nullptr;\n+    }\n@@ -507,5 +507,6 @@\n-  \/\/ Due to potential power-of-2 multiplication optimization, e.g., ((a << CON) - a) + a,\n-  \/\/     - SubNode(LShiftNode(a, CON), a)\n-  if (in1_op == Op_Sub(bt) && in1->in(1)->is_LShift() && in1->in(1)->in(2)->is_Con()) {\n-    Node* lshift = in1->in(1);\n-    Node* base = in1->in(2);\n+    jlong lhs_multiplier = 0;\n+    if (multiplier != nullptr) {\n+      Node* con = lhs->in(2);\n+      if (con->is_top()) {\n+        return nullptr;\n+      }\n@@ -513,3 +514,1 @@\n-    Node* lshift_base = lshift->in(1);\n-    if (lshift_base != base || lshift_base != in2) {\n-      return nullptr;\n+      lhs_multiplier = (jlong) 1 << con->get_int();\n@@ -518,4 +517,7 @@\n-    Node* con = lshift->in(2);\n-    BasicType con_bt = phase->type(con)->basic_type();\n-    if (con_bt == T_VOID) { \/\/ const could potentially be void type\n-      return nullptr;\n+    \/\/ AddNode(LShiftNode(a, CON), a)?\n+    if (lhs->in(1) == rhs) {\n+      if (multiplier != nullptr) {\n+        *multiplier = lhs_multiplier + 1;\n+      }\n+\n+      return rhs;\n@@ -524,4 +526,7 @@\n-    \/\/ We can't simply return the lshift node even if ((a << CON) - a) + a cancels out. Ideal() must return a new node.\n-    multiplier = ((jlong) 1 << con->get_integer_as_long(con_bt)) - 1;\n-    matched = true;\n-  }\n+    \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n+    if (rhs->is_LShift() && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n+      if (multiplier != nullptr) {\n+        Node* con = rhs->in(2);\n+        if (con->is_top()) {\n+          return nullptr;\n+        }\n@@ -529,3 +534,2 @@\n-  if (!matched) {\n-    return nullptr;\n-  }\n+        *multiplier = lhs_multiplier + ((jlong) 1 << con->get_int());\n+      }\n@@ -533,5 +537,2 @@\n-  multiplier++; \/\/ + 1 for current addition\n-  Node* con = (bt == T_INT)\n-              ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n-              : (Node*) phase->longcon(multiplier);\n-  Node* mul = MulNode::make(con, in2, bt);\n+      return lhs->in(1);\n+    }\n@@ -539,3 +540,1 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-  if (igvn != nullptr) {\n-    mul = igvn->register_new_node_with_optimizer(mul);\n+    return nullptr;\n@@ -544,1 +543,1 @@\n-  return mul;\n+  return nullptr;\n@@ -547,4 +546,6 @@\n-\/\/ MulINode::Ideal() optimizes a multiplication to an addition of at most two terms if possible.\n-bool AddNode::is_optimized_multiplication() {\n-  Node* lhs = in(1);\n-  Node* rhs = in(2);\n+\/\/ Match `(a << CON) - a`, extract `a` and `(1 << CON) - 1`\n+Node* AddNode::find_power_of_two_subtraction_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Look for pattern: SubNode(LShiftNode(a, CON), a)\n+  if (n->Opcode() == Op_Sub(bt) && n->in(1)->is_LShift() && n->in(1)->in(2)->is_Con()) {\n+    Node* lshift = n->in(1);\n+    Node* base = n->in(2);\n@@ -552,19 +553,4 @@\n-  \/\/ Look for patterns:\n-  \/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n-  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n-  \/\/ given that lhs is different from rhs\n-  if (lhs == rhs) {\n-    return false;\n-  }\n-\n-  \/\/ swap LShiftNode to lhs for easier matching\n-  if (!lhs->is_LShift()) {\n-    Node* tmp = lhs;\n-    lhs = rhs;\n-    rhs = tmp;\n-  }\n-\n-  \/\/ AddNode(LShiftNode(a, CON), *)?\n-  if (!lhs->is_LShift() || !lhs->in(2)->is_Con()) {\n-    return false;\n-  }\n+    Node* lshift_base = lshift->in(1);\n+    if (lshift_base != base) {\n+      return nullptr;\n+    }\n@@ -572,4 +558,4 @@\n-  \/\/ AddNode(LShiftNode(a, CON), a)?\n-  if (lhs->in(1) == rhs) {\n-    return true;\n-  }\n+    Node* con = lshift->in(2);\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n@@ -577,3 +563,3 @@\n-  \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n-  if (rhs->is_LShift() && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n-    return true;\n+    \/\/ We can't simply return the lshift node even if ((a << CON) - a) + a cancels out. Ideal() must return a new node.\n+    *multiplier = ((jlong) 1 << con->get_int()) - 1;\n+    return base;\n@@ -582,1 +568,1 @@\n-  return false;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":112,"deletions":126,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -48,1 +48,5 @@\n-  bool is_optimized_multiplication();\n+  static Node* find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_power_of_two_subtraction_pattern(Node* n, BasicType bt, jlong* multiplier);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}