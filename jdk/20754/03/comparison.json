{"files":[{"patch":"@@ -398,0 +398,6 @@\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, can_reshape, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n+\n@@ -401,0 +407,139 @@\n+\/\/ Convert a + a + ... + a into a*n\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  Node* base = nullptr;\n+  \/\/ During IGVN, to avoid same transformation applied to the every con in a subgraph, we use a depth limit to avoid\n+  \/\/ transforming a huge subgraph in one go and the risk of associated performance issues. Untransformed nodes will be\n+  \/\/ added to the worklist. Being iterative, the algorithm eventually transforms the whole subgraph.\n+  jlong factor = extract_base_operand_from_serial_additions(phase, this, bt, can_reshape ? 5 : -1, &base);\n+\n+  \/\/ The subgraph cannot be transformed if:\n+  \/\/ 1. no common base operand can be extracted, i.e., nullptr\n+  \/\/ 2. the base operand is the same as the current con, i.e., a + b\n+  \/\/ 3. input is an already-optimized multiplication, i.e., a*6 => (a<<1) + (a<<2)\n+  \/\/ 4. is simple additions not worth transforming, i.e., a + a\n+  if (base == nullptr\n+      || base == this\n+      || is_optimized_multiplication(this, bt, base)\n+      || (base == in(1) && base == in(2))) {\n+    return nullptr;\n+  }\n+\n+  Node* con = (bt == T_INT)\n+              ? (Node*) phase->intcon((jint) factor) \/\/ intentional type narrowing to allow overflow at max_jint\n+              : (Node*) phase->longcon(factor);\n+  Node* mul = MulNode::make(con, base, bt);\n+\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (igvn != nullptr) {\n+    mul = igvn->register_new_node_with_optimizer(mul);\n+  }\n+\n+  return mul;\n+}\n+\n+\/\/ MulINode::Ideal() optimizes a multiplication to an addition of at most two terms if possible.\n+bool AddNode::is_optimized_multiplication(Node* node, BasicType bt, Node* base) {\n+  int op = node->Opcode();\n+\n+  \/\/ Look for pattern: LShiftNode(a, CON)\n+  if (op == Op_LShift(bt) && node->in(2)->is_Con()) {\n+    return base == node->isa_LShift()->in(1);\n+  }\n+\n+  \/\/ Look for patterns:\n+  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+  \/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+  \/\/ given that lhs is different from rhs\n+  if (op == Op_Add(bt)\n+      && node->in(1) != node->in(2)\n+      && (\n+          (node->in(1)->is_LShift() && node->in(1)->in(2)->is_Con()) \/\/ AddNode(LShiftNode(a, CON), *)\n+              || (node->in(2)->is_LShift() && node->in(2)->in(2)->is_Con()) \/\/ AddNode(*, LShiftNode(a, CON))\n+      )) {\n+    Node* lhs = node->in(1);\n+    Node* rhs = node->in(2);\n+\n+    Node* lhs_base = lhs->is_LShift() ? lhs->in(1) : lhs;\n+    Node* rhs_base = rhs->is_LShift() ? rhs->in(1) : rhs;\n+\n+    if (lhs == rhs_base || rhs == lhs_base) {\n+      return (lhs == rhs_base && lhs == base)\n+          || (rhs == lhs_base && rhs == base);\n+    }\n+\n+    return lhs_base == rhs_base && base == lhs_base;\n+  }\n+\n+  \/\/ Look for pattern: SubNode(LShiftNode(a, CON), a)\n+  if (op == Op_Sub(bt) && node->in(1)->Opcode() == Op_LShift(bt) && node->in(1)->in(2)->is_Con()) {\n+    Node* a1 = node->in(1)->in(1);\n+    Node* a2 = node->in(2);\n+\n+    return a1 == a2 && base == a1;\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ For a series of additions, extract the base operand and the multiplier. E.g., extract a*n from a + a + ... + a\n+jlong AddNode::extract_base_operand_from_serial_additions(PhaseGVN* phase, Node* node, BasicType bt, int depth_limit, Node** base) {\n+  *base = node;\n+\n+  if (depth_limit == 0) {\n+    return 1;\n+  }\n+\n+  int op = node->Opcode();\n+\n+  \/\/ MulNode(any, const), e.g., a*2\n+  if (op == Op_Mul(bt)\n+      && (node->in(1)->is_Con() || node->in(2)->is_Con())) {\n+    Node* const_node = node->in(1)->is_Con() ? node->in(1) : node->in(2);\n+    Node* operand_node = node->in(1)->is_Con() ? node->in(2) : node->in(1);\n+    BasicType const_bt = phase->type(const_node)->basic_type();\n+\n+    if (const_bt == T_INT || const_bt == T_LONG) { \/\/ const could potentially be void type\n+      Node* mul_base;\n+      jlong multiplier = extract_base_operand_from_serial_additions(phase, operand_node, bt, depth_limit - 1, &mul_base);\n+\n+      *base = mul_base;\n+      return multiplier * const_node->get_integer_as_long(const_bt);\n+    }\n+  }\n+\n+  \/\/ LShiftNode(any, const), e.g, a<<2 => a*4\n+  if (op == Op_LShift(bt) && node->in(2)->is_Con()) {\n+    Node* const_node = node->in(2);\n+    Node* operand_node = node->in(1);\n+    BasicType const_bt = phase->type(const_node)->basic_type();\n+\n+    if (const_bt == T_INT || const_bt == T_LONG) { \/\/ const could potentially be void type\n+      Node* shift_base;\n+      jlong multiplier = extract_base_operand_from_serial_additions(phase, operand_node, bt, depth_limit - 1, &shift_base);\n+\n+      *base = shift_base;\n+      return multiplier * ((jlong) 1 << const_node->get_integer_as_long(const_bt)); \/\/ const could be void type\n+    }\n+  }\n+\n+  \/\/ AddNode(any, any), e.g., a + a => a*2 or (a<<2) + a => a*5\n+  \/\/ SubNode(any, any), e.g., a<<3 - a => a*7\n+  if (op == Op_Add(bt) || op == Op_Sub(bt)) {\n+    Node* operand_node_left = node->in(1);\n+    Node* operand_node_right = node->in(2);\n+\n+    Node* base_left;\n+    Node* base_right;\n+    jlong multiplier_left = extract_base_operand_from_serial_additions(phase, operand_node_left, bt,\n+                                                                       depth_limit - 1, &base_left);\n+    jlong multiplier_right = extract_base_operand_from_serial_additions(phase, operand_node_right, bt,\n+                                                                        depth_limit - 1, &base_right);\n+\n+    if (base_left == base_right) {\n+      *base = base_left;\n+      return op == Op_Add(bt) ? multiplier_left + multiplier_right : multiplier_left - multiplier_right;\n+    }\n+  }\n+\n+  return 1;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -45,0 +45,6 @@\n+\n+private:\n+  Node* convert_serial_additions(PhaseGVN* phase, bool can_reshape, BasicType bt);\n+  static bool is_optimized_multiplication(Node* node, BasicType bt, Node* base);\n+  static jlong extract_base_operand_from_serial_additions(PhaseGVN* phase, Node* node, BasicType bt, int depth_limit, Node** base);\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8325495\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestSerialAdditions\n+ *\/\n+public class TestSerialAdditions {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(int base, int factor, int observed) {\n+        int expected = base * factor; \/\/ compute expected result here while making sure not inlined in callers\n+        if (expected != observed) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + observed);\n+        }\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(long base, long factor, long observed) {\n+        long expected = base * factor;\n+        if (expected != observed) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + observed);\n+        }\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = {IRNode.LSHIFT_I})\n+    private static void addTo2(int a) {\n+        int sum = a + a; \/\/ Simple additions like a + a should be kept as-is\n+        verifyResult(a, 2, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo3(int a) {\n+        int sum = a + a + a; \/\/ a*3 => (a<<1) + a\n+        verifyResult(a, 3, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo4(int a) {\n+        int sum = a + a + a + a; \/\/ a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void shiftAndAddTo4(int a) {\n+        int sum = (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void mulAndAddTo4(int a) {\n+        int sum = a * 3 + a; \/\/ a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo5L(int a) {\n+        int sum = a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+        verifyResult(a, 5, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"2\"})\n+    private static void addTo6L(int a) {\n+        int sum = a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+        verifyResult(a, 6, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    private static void addTo7(int a) {\n+        int sum = a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+        verifyResult(a, 7, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo8(int a) {\n+        int sum = a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+        verifyResult(a, 8, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo16(int a) {\n+        int sum = a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+        verifyResult(a, 16, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addAndShiftTo16(int a) {\n+        int sum = (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+        verifyResult(a, 16, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void addTo42(int a) {\n+        int sum = a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+        verifyResult(a, 42, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void mulAndAddTo42(int a) {\n+        int sum = a * 40 + a + a; \/\/ a*41 + a => a*42\n+        verifyResult(a, 42, sum);\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    private static void mulAndAddToMax(int a) {\n+        int sum = a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<31) - 1\n+        verifyResult(a, Integer.MAX_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static void mulAndAddToOverflow(int a) {\n+        int sum = a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+        verifyResult(a, Integer.MIN_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static void mulAndAddToZero(int a) {\n+        int sum = a*-1 + a; \/\/ 0\n+        verifyResult(a, 0, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    @IR(counts = { IRNode.SUB_I, \"1\" })\n+    private static void mulAndAddToMinus1(int a) {\n+        int sum = a*-2 + a; \/\/ a*-1 => a - (a<<1)\n+        verifyResult(a, -1, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void mulAndAddToMinus42(int a) {\n+        int sum = a*-43 + a; \/\/ a*-42\n+        verifyResult(a, -42, sum);\n+    }\n+\n+    \/\/ --- long tests ---\n+    private static final long INT_MAX_PLUS_ONE = (long) Integer.MAX_VALUE + 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static void mulAndAddToIntOverflowL(long a) {\n+        long sum = a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+        verifyResult(a, INT_MAX_PLUS_ONE, sum);\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    private static void mulAndAddToMaxL(long a) {\n+        long sum = a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+        verifyResult(a, Long.MAX_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static void mulAndAddToOverflowL(long a) {\n+        long sum = a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+        verifyResult(a, Long.MIN_VALUE, sum);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -96,2 +96,2 @@\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Optimized into x << 2 by JDK-8325495\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Optimized into x << 2 by JDK-8325495\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}