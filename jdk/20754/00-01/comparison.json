{"files":[{"patch":"@@ -398,14 +398,4 @@\n-  \/\/ Convert a + a+ ... + a into a*n\n-  Node* repeated_operand = nullptr;\n-  int terms = 0;\n-  jlong factor = find_repeated_operand_in_chained_addition(phase, this, &repeated_operand, &terms);\n-\n-  \/\/ Check if there is a more optimal way to represent the multiplication\n-  \/\/ MulINode::Ideal() optimizes a multiplication to an addition of at most two terms (if possible)\n-  if (repeated_operand != nullptr && repeated_operand != this && terms > 2) {\n-    Node* node = (bt == T_INT) ? (Node*) phase->intcon((jint) factor) : (Node*) phase->longcon(factor);\n-    BasicType bt2 = phase->type(repeated_operand)->basic_type();\n-\n-    if (bt2 == T_INT || bt2 == T_LONG) { \/\/ to avoid void constant types\n-      return MulNode::make(repeated_operand, node, bt2);\n-    }\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, can_reshape, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n@@ -417,4 +407,19 @@\n-jlong AddNode::find_repeated_operand_in_chained_addition(PhaseGVN* phase, Node* node, Node** operand, int* terms) {\n-  *operand = node;\n-  *terms = 1;\n-  jlong factor = 1;\n+\/\/ Convert a + a + ... + a into a*n\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  Node* base = nullptr;\n+  \/\/ During IGVN, to avoid same transformation applied to the every con in a subgraph, we use a depth limit to avoid\n+  \/\/ transforming a huge subgraph in one go and the risk of associated performance issues. Untransformed nodes will be\n+  \/\/ added to the worklist. Being iterative, the algorithm eventually transforms the whole subgraph.\n+  jlong factor = extract_base_operand_from_serial_additions(phase, this, &base, can_reshape ? 5 : -1);\n+\n+  \/\/ The subgraph cannot be transformed if:\n+  \/\/ 1. no common base operand can be extracted, i.e., nullptr\n+  \/\/ 2. the base operand is the same as the current con, i.e., a + b\n+  \/\/ 3. input is an already-optimized multiplication, i.e., a*6 => (a<<1) + (a<<2)\n+  \/\/ 4. is simple additions not worth transforming, i.e., a + a\n+  if (base == nullptr\n+      || base == this\n+      || is_optimized_multiplication(this, base)\n+      || (base == in(1) && base == in(2))) {\n+    return nullptr;\n+  }\n@@ -422,7 +427,2 @@\n-  \/\/ ADD: e.g., a + a => a*2 or (a<<2) + a => a*5\n-  \/\/ SUB: e.g., a<<3 - a => a*7\n-  if (node->is_Add() || node->is_Sub()) {\n-    Node* base_left = nullptr;\n-    Node* base_right = nullptr;\n-    int terms_left = 0;\n-    int terms_right = 0;\n+  Node* con = (bt == T_INT) ? (Node*) phase->intcon((jint) factor) : (Node*) phase->longcon(factor);\n+  Node* mul = MulNode::make(base, con, bt);\n@@ -430,2 +430,4 @@\n-    jlong multiplier_left = find_repeated_operand_in_chained_addition(phase, node->in(1), &base_left, &terms_left);\n-    jlong multiplier_right = find_repeated_operand_in_chained_addition(phase, node->in(2), &base_right, &terms_right);\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (igvn != nullptr) {\n+    mul = igvn->register_new_node_with_optimizer(mul);\n+  }\n@@ -433,4 +435,59 @@\n-    if (base_left == base_right) {\n-      *operand = base_left;\n-      *terms = terms_left + terms_right;\n-      factor = node->is_Add() ? multiplier_left + multiplier_right : multiplier_left - multiplier_right;\n+  return mul;\n+}\n+\n+\/\/ MulINode::Ideal() optimizes a multiplication to an addition of at most two terms if possible.\n+bool AddNode::is_optimized_multiplication(Node* node, Node* base) {\n+  \/\/ Look for pattern: LShiftNode(a, CON)\n+  if (node->is_LShift() && node->in(2)->is_Con()) {\n+    return base == node->isa_LShift()->in(1);\n+  }\n+\n+  \/\/ Look for patterns:\n+  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+  \/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+  \/\/ giving that lhs is different from rhs\n+  if (node->is_Add()\n+      && node->in(1) != node->in(2)\n+      && (\n+          (node->in(1)->is_LShift() && node->in(1)->in(2)->is_Con()) \/\/ AddNode(LShiftNode(a, CON), *)\n+              || (node->in(2)->is_LShift() && node->in(2)->in(2)->is_Con()) \/\/ AddNode(*, LShiftNode(a, CON))\n+      )) {\n+    Node* a1 = node->in(1)->is_LShift() ? node->in(1)->in(1) : node->in(1);\n+    Node* a2 = node->in(2)->is_LShift() ? node->in(2)->in(1) : node->in(2);\n+\n+    return a1 == a2 && base == a1;\n+  }\n+\n+  \/\/ Look for pattern: SubNode(LShiftNode(a, CON), a)\n+  if (node->is_Sub() && node->in(1)->is_LShift() && node->in(1)->in(2)->is_Con()) {\n+    Node* a1 = node->in(1)->in(1);\n+    Node* a2 = node->in(2);\n+\n+    return a1 == a2 && base == a1;\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ For a series of additions, extract the base operand and the multiplier. E.g., extract a*n from a + a + ... + a\n+jlong AddNode::extract_base_operand_from_serial_additions(PhaseGVN* phase, Node* node, Node** base, int depth_limit) {\n+  *base = node;\n+\n+  if (depth_limit == 0) {\n+    return 1;\n+  }\n+\n+  \/\/ MulNode(any, const), e.g., a*2\n+  if (node->is_Mul()\n+      && node->Opcode() != Op_AndI && node->Opcode() != Op_AndL \/\/ AndNode extends MulNode for some reason\n+      && (node->in(1)->is_Con() || node->in(2)->is_Con())) {\n+    Node* const_node = node->in(1)->is_Con() ? node->in(1) : node->in(2);\n+    Node* operand_node = node->in(1)->is_Con() ? node->in(2) : node->in(1);\n+    BasicType bt = phase->type(const_node)->basic_type();\n+\n+    if (bt == T_INT || bt == T_LONG) { \/\/ const could potentially be void type\n+      Node* mul_base;\n+      jlong multiplier = extract_base_operand_from_serial_additions(phase, operand_node, &mul_base, depth_limit - 1);\n+\n+      *base = mul_base;\n+      return multiplier * const_node->get_integer_as_long(bt);\n@@ -440,1 +497,1 @@\n-  \/\/ e.g., a<<2 => a*4\n+  \/\/ LShiftNode(any, const), e.g, a<<2 => a*4\n@@ -442,1 +499,7 @@\n-    BasicType bt = phase->type(node->in(2))->basic_type();\n+    Node* const_node = node->in(2);\n+    Node* operand_node = node->in(1);\n+    BasicType bt = phase->type(const_node)->basic_type();\n+\n+    if (bt == T_INT || bt == T_LONG) { \/\/ const could potentially be void type\n+      Node* shift_base;\n+      jlong multiplier = extract_base_operand_from_serial_additions(phase, operand_node, &shift_base, depth_limit - 1);\n@@ -444,4 +507,2 @@\n-    if (bt == T_INT || bt == T_LONG) {\n-      *operand = node->in(1);\n-      *terms = 1;\n-      factor = jlong(1) << node->in(2)->get_integer_as_long(bt);\n+      *base = shift_base;\n+      return multiplier * ((jlong) 1 << const_node->get_integer_as_long(bt)); \/\/ const could be void type\n@@ -451,5 +512,12 @@\n-  \/\/ e.g., a*2\n-  if (node->is_Mul() && node->Opcode() != Op_AndI && node->Opcode() != Op_AndL \/\/ AndNode extends MulNode for some reason\n-      && (node->in(1)->is_Con() || node->in(2)->is_Con())) { \/\/ node->is_Mul()\n-    Node *multiplier_node = node->in(1)->is_Con() ? node->in(1) : node->in(2);\n-    BasicType bt = phase->type(multiplier_node)->basic_type();\n+  \/\/ AddNode(any, any), e.g., a + a => a*2 or (a<<2) + a => a*5\n+  \/\/ SubNode(any, any), e.g., a<<3 - a => a*7\n+  if (node->is_Add() || node->is_Sub()) {\n+    Node* operand_node_left = node->in(1);\n+    Node* operand_node_right = node->in(2);\n+\n+    Node* base_left;\n+    Node* base_right;\n+    jlong multiplier_left = extract_base_operand_from_serial_additions(phase, operand_node_left, &base_left,\n+                                                                       depth_limit - 1);\n+    jlong multiplier_right = extract_base_operand_from_serial_additions(phase, operand_node_right, &base_right,\n+                                                                        depth_limit - 1);\n@@ -457,4 +525,3 @@\n-    if (bt == T_INT || bt == T_LONG) {\n-      *operand = node->in(1)->is_Con() ? node->in(2) : node->in(1);\n-      *terms = 2; \/\/ discourages multiplication nodes\n-      factor = multiplier_node->get_integer_as_long(bt);\n+    if (base_left == base_right) {\n+      *base = base_left;\n+      return node->is_Add() ? multiplier_left + multiplier_right : multiplier_left - multiplier_right;\n@@ -464,1 +531,1 @@\n-  return factor;\n+  return 1;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":114,"deletions":47,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -47,1 +47,3 @@\n-  static jlong find_repeated_operand_in_chained_addition(PhaseGVN* phase, Node* node, Node** operand, int* terms);\n+  Node* convert_serial_additions(PhaseGVN* phase, bool can_reshape, BasicType bt);\n+  static bool is_optimized_multiplication(Node* node, Node* base);\n+  static jlong extract_base_operand_from_serial_additions(PhaseGVN* phase, Node* node, Node** base, int depth_limit);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-package compiler.c2.arithmeticCanonicalization;\n+package compiler.c2;\n@@ -27,0 +27,1 @@\n+import compiler.lib.ir_framework.Test;\n@@ -33,1 +34,1 @@\n- * @run driver compiler.c2.arithmeticCanonicalization.SerialAdditionCanonicalization\n+ * @run driver compiler.c2.TestSerialAdditions\n@@ -35,1 +36,1 @@\n-public class SerialAdditionCanonicalization {\n+public class TestSerialAdditions {\n@@ -57,0 +58,9 @@\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = {IRNode.LSHIFT_I})\n+    private static void addTo2(int a) {\n+        int sum = a + a; \/\/ Simple additions like a + a should be kept as-is\n+        verifyResult(a, 2, sum);\n+    }\n+\n@@ -140,0 +150,9 @@\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addAndShiftTo16(int a) {\n+        int sum = (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+        verifyResult(a, 16, sum);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":22,"deletions":3,"binary":false,"changes":25,"previous_filename":"test\/hotspot\/jtreg\/compiler\/c2\/arithmeticCanonicalization\/SerialAdditionCanonicalization.java","status":"renamed"}]}