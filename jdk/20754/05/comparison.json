{"files":[{"patch":"@@ -398,0 +398,6 @@\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, can_reshape, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n+\n@@ -401,0 +407,177 @@\n+\/\/ Convert a + a + ... + a into a*n\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  if (is_optimized_multiplication()) {\n+    return nullptr;\n+  }\n+\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  int in1_op = in1->Opcode();\n+\n+  bool matched = false;\n+  jlong multiplier;\n+\n+  \/\/ Convert (a + a) + a to 3 * a\n+  \/\/ Look for LHS pattern: AddNode(a, a)\n+  if (in1_op == Op_Add(bt) && in1->in(1) == in1->in(2)) {\n+    if (in1->in(1) != in2) {\n+      return nullptr;\n+    }\n+\n+    multiplier = 2;\n+    matched = true;\n+  }\n+\n+  \/\/ Convert (a << CON) + a to a * ((1 << CON) + 1))\n+  \/\/ Look for LHS pattern: LShiftNode(a, CON)\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (in1_op == Op_LShift(bt) && in1->in(2)->is_Con()) {\n+    Node* base = in1->in(1);\n+    if (base != in2) {\n+      return nullptr;\n+    }\n+\n+    Node* con = in1->in(2);\n+    BasicType con_bt = phase->type(con)->basic_type();\n+    if (con_bt == T_VOID) { \/\/ const could potentially be void type\n+      return nullptr;\n+    }\n+\n+    multiplier = (jlong) 1 << con->get_integer_as_long(con_bt);\n+    matched = true;\n+  }\n+\n+  \/\/ Convert (CON * a) + a to (CON + 1) * a\n+  \/\/ Look for LHS patterns:\n+  \/\/     - MulNode(CON, a)\n+  \/\/     - MulNode(a, CON)\n+  \/\/ This optimization technically only produces MulNode(CON, a), but we might as well transform (a * CON) + a, too.\n+  if (in1_op == Op_Mul(bt) && (in1->in(1)->is_Con() || in1->in(2)->is_Con())) {\n+    Node* base = in1->in(1)->is_Con() ? in1->in(2) : in1->in(1);\n+    if (base != in2) {\n+      return nullptr;\n+    }\n+\n+    Node* con = in1->in(1)->is_Con() ? in1->in(1) : in1->in(2);\n+    BasicType con_bt = phase->type(con)->basic_type();\n+    if (con_bt == T_VOID) { \/\/ const could potentially be void type\n+      return nullptr;\n+    }\n+\n+    multiplier = con->get_integer_as_long(con_bt);\n+    matched = true;\n+  }\n+\n+  \/\/ Due to potential power-of-2 multiplication optimization, e.g., ((a << CON1) + (a << CON2)) + a,\n+  \/\/ we also look for LHS patterns:\n+  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+  if (in1_op == Op_Add(bt) && in1->isa_Add()->is_optimized_multiplication()) {\n+    Node* lhs = in1->in(1);\n+    Node* rhs = in1->in(2);\n+\n+    Node* lhs_base = lhs->is_LShift() ? lhs->in(1) : lhs;\n+    Node* rhs_base = rhs->is_LShift() ? rhs->in(1) : rhs;\n+\n+    Node* nodes[] = {lhs, rhs};\n+    Node* bases[] = {lhs_base, rhs_base};\n+    jlong multipliers[] = {1, 1};\n+\n+    \/\/ AddNode(LShiftNode(a, CON1), LShiftNode(a, CON2)\/a)\n+    \/\/ AddNode(LShiftNode(a, CON1)\/a, LShiftNode(a, CON2))\n+    for (int i = 0; i < 2; i++) {\n+      if (nodes[i]->is_LShift()) {\n+        Node* con = nodes[i]->in(2);\n+        if (bases[i] != in2 || bases[0] != bases[1] || !con->is_Con()) {\n+          return nullptr;\n+        }\n+\n+        BasicType con_bt = phase->type(con)->basic_type();\n+        if (con_bt == T_VOID) {\n+          return nullptr;\n+        }\n+\n+        multipliers[i] = ((jlong) 1 << con->get_integer_as_long(con_bt));\n+      }\n+    }\n+\n+    multiplier = multipliers[0] + multipliers[1];\n+    matched = true;\n+  }\n+\n+  \/\/ Due to potential power-of-2 multiplication optimization, e.g., ((a << CON) - a) + a,\n+  \/\/     - SubNode(LShiftNode(a, CON), a)\n+  if (in1_op == Op_Sub(bt) && in1->in(1)->is_LShift() && in1->in(1)->in(2)->is_Con()) {\n+    Node* lshift = in1->in(1);\n+    Node* base = in1->in(2);\n+\n+    Node* lshift_base = lshift->in(1);\n+    if (lshift_base != base || lshift_base != in2) {\n+      return nullptr;\n+    }\n+\n+    Node* con = lshift->in(2);\n+    BasicType con_bt = phase->type(con)->basic_type();\n+    if (con_bt == T_VOID) { \/\/ const could potentially be void type\n+      return nullptr;\n+    }\n+\n+    \/\/ We can't simply return the lshift node even if ((a << CON) - a) + a cancels out. Ideal() must return a new node.\n+    multiplier = ((jlong) 1 << con->get_integer_as_long(con_bt)) - 1;\n+    matched = true;\n+  }\n+\n+  if (!matched) {\n+    return nullptr;\n+  }\n+\n+  multiplier++; \/\/ + 1 for current addition\n+  Node* con = (bt == T_INT)\n+              ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n+              : (Node*) phase->longcon(multiplier);\n+  Node* mul = MulNode::make(con, in2, bt);\n+\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (igvn != nullptr) {\n+    mul = igvn->register_new_node_with_optimizer(mul);\n+  }\n+\n+  return mul;\n+}\n+\n+\/\/ MulINode::Ideal() optimizes a multiplication to an addition of at most two terms if possible.\n+bool AddNode::is_optimized_multiplication() {\n+  Node* lhs = in(1);\n+  Node* rhs = in(2);\n+\n+  \/\/ Look for patterns:\n+  \/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+  \/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+  \/\/ given that lhs is different from rhs\n+  if (lhs == rhs) {\n+    return false;\n+  }\n+\n+  \/\/ swap LShiftNode to lhs for easier matching\n+  if (!lhs->is_LShift()) {\n+    Node* tmp = lhs;\n+    lhs = rhs;\n+    rhs = tmp;\n+  }\n+\n+  \/\/ AddNode(LShiftNode(a, CON), *)?\n+  if (!lhs->is_LShift() || !lhs->in(2)->is_Con()) {\n+    return false;\n+  }\n+\n+  \/\/ AddNode(LShiftNode(a, CON), a)?\n+  if (lhs->in(1) == rhs) {\n+    return true;\n+  }\n+\n+  \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n+  if (rhs->is_LShift() && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":183,"deletions":0,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -45,0 +45,5 @@\n+\n+private:\n+  Node* convert_serial_additions(PhaseGVN* phase, bool can_reshape, BasicType bt);\n+  bool is_optimized_multiplication();\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8325495\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestSerialAdditions\n+ *\/\n+public class TestSerialAdditions {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(int base, int factor, int observed) {\n+        int expected = base * factor; \/\/ compute expected result here while making sure not inlined in callers\n+        if (expected != observed) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + observed);\n+        }\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(long base, long factor, long observed) {\n+        long expected = base * factor;\n+        if (expected != observed) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + observed);\n+        }\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = {IRNode.LSHIFT_I})\n+    private static void addTo2(int a) {\n+        int sum = a + a; \/\/ Simple additions like a + a should be kept as-is\n+        verifyResult(a, 2, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo3(int a) {\n+        int sum = a + a + a; \/\/ a*3 => (a<<1) + a\n+        verifyResult(a, 3, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo4(int a) {\n+        int sum = a + a + a + a; \/\/ a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void shiftAndAddTo4(int a) {\n+        int sum = (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void mulAndAddTo4(int a) {\n+        int sum = a * 3 + a; \/\/ a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo5L(int a) {\n+        int sum = a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+        verifyResult(a, 5, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"2\"})\n+    private static void addTo6L(int a) {\n+        int sum = a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+        verifyResult(a, 6, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    private static void addTo7(int a) {\n+        int sum = a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+        verifyResult(a, 7, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo8(int a) {\n+        int sum = a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+        verifyResult(a, 8, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo16(int a) {\n+        int sum = a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+        verifyResult(a, 16, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addAndShiftTo16(int a) {\n+        int sum = (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+        verifyResult(a, 16, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void addTo42(int a) {\n+        int sum = a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+        verifyResult(a, 42, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void mulAndAddTo42(int a) {\n+        int sum = a * 40 + a + a; \/\/ a*41 + a => a*42\n+        verifyResult(a, 42, sum);\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    private static void mulAndAddToMax(int a) {\n+        int sum = a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<31) - 1\n+        verifyResult(a, Integer.MAX_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static void mulAndAddToOverflow(int a) {\n+        int sum = a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+        verifyResult(a, Integer.MIN_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static void mulAndAddToZero(int a) {\n+        int sum = a*-1 + a; \/\/ 0\n+        verifyResult(a, 0, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    @IR(counts = { IRNode.SUB_I, \"1\" })\n+    private static void mulAndAddToMinus1(int a) {\n+        int sum = a*-2 + a; \/\/ a*-1 => a - (a<<1)\n+        verifyResult(a, -1, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void mulAndAddToMinus42(int a) {\n+        int sum = a*-43 + a; \/\/ a*-42\n+        verifyResult(a, -42, sum);\n+    }\n+\n+    \/\/ --- long tests ---\n+    private static final long INT_MAX_PLUS_ONE = (long) Integer.MAX_VALUE + 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static void mulAndAddToIntOverflowL(long a) {\n+        long sum = a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+        verifyResult(a, INT_MAX_PLUS_ONE, sum);\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    private static void mulAndAddToMaxL(long a) {\n+        long sum = a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+        verifyResult(a, Long.MAX_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static void mulAndAddToOverflowL(long a) {\n+        long sum = a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+        verifyResult(a, Long.MIN_VALUE, sum);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"}]}