{"files":[{"patch":"@@ -398,0 +398,16 @@\n+  \/\/ Convert a + a+ ... + a into a*n\n+  Node* repeated_operand = nullptr;\n+  int terms = 0;\n+  jlong factor = find_repeated_operand_in_chained_addition(phase, this, &repeated_operand, &terms);\n+\n+  \/\/ Check if there is a more optimal way to represent the multiplication\n+  \/\/ MulINode::Ideal() optimizes a multiplication to an addition of at most two terms (if possible)\n+  if (repeated_operand != nullptr && repeated_operand != this && terms > 2) {\n+    Node* node = (bt == T_INT) ? (Node*) phase->intcon((jint) factor) : (Node*) phase->longcon(factor);\n+    BasicType bt2 = phase->type(repeated_operand)->basic_type();\n+\n+    if (bt2 == T_INT || bt2 == T_LONG) { \/\/ to avoid void constant types\n+      return MulNode::make(repeated_operand, node, bt2);\n+    }\n+  }\n+\n@@ -401,0 +417,49 @@\n+jlong AddNode::find_repeated_operand_in_chained_addition(PhaseGVN* phase, Node* node, Node** operand, int* terms) {\n+  *operand = node;\n+  *terms = 1;\n+  jlong factor = 1;\n+\n+  \/\/ ADD: e.g., a + a => a*2 or (a<<2) + a => a*5\n+  \/\/ SUB: e.g., a<<3 - a => a*7\n+  if (node->is_Add() || node->is_Sub()) {\n+    Node* base_left = nullptr;\n+    Node* base_right = nullptr;\n+    int terms_left = 0;\n+    int terms_right = 0;\n+\n+    jlong multiplier_left = find_repeated_operand_in_chained_addition(phase, node->in(1), &base_left, &terms_left);\n+    jlong multiplier_right = find_repeated_operand_in_chained_addition(phase, node->in(2), &base_right, &terms_right);\n+\n+    if (base_left == base_right) {\n+      *operand = base_left;\n+      *terms = terms_left + terms_right;\n+      factor = node->is_Add() ? multiplier_left + multiplier_right : multiplier_left - multiplier_right;\n+    }\n+  }\n+\n+  \/\/ e.g., a<<2 => a*4\n+  if (node->is_LShift() && node->isa_LShift()->in(2)->is_Con()) {\n+    BasicType bt = phase->type(node->in(2))->basic_type();\n+\n+    if (bt == T_INT || bt == T_LONG) {\n+      *operand = node->in(1);\n+      *terms = 1;\n+      factor = jlong(1) << node->in(2)->get_integer_as_long(bt);\n+    }\n+  }\n+\n+  \/\/ e.g., a*2\n+  if (node->is_Mul() && node->Opcode() != Op_AndI && node->Opcode() != Op_AndL \/\/ AndNode extends MulNode for some reason\n+      && (node->in(1)->is_Con() || node->in(2)->is_Con())) { \/\/ node->is_Mul()\n+    Node *multiplier_node = node->in(1)->is_Con() ? node->in(1) : node->in(2);\n+    BasicType bt = phase->type(multiplier_node)->basic_type();\n+\n+    if (bt == T_INT || bt == T_LONG) {\n+      *operand = node->in(1)->is_Con() ? node->in(2) : node->in(1);\n+      *terms = 2; \/\/ discourages multiplication nodes\n+      factor = multiplier_node->get_integer_as_long(bt);\n+    }\n+  }\n+\n+  return factor;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+\n+private:\n+  static jlong find_repeated_operand_in_chained_addition(PhaseGVN* phase, Node* node, Node** operand, int* terms);\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.arithmeticCanonicalization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8325495\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.arithmeticCanonicalization.SerialAdditionCanonicalization\n+ *\/\n+public class SerialAdditionCanonicalization {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(int base, int factor, int observed) {\n+        int expected = base * factor; \/\/ compute expected result here while making sure not inlined in callers\n+        if (expected != observed) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + observed);\n+        }\n+    }\n+\n+    @DontInline\n+    private static void verifyResult(long base, long factor, long observed) {\n+        long expected = base * factor;\n+        if (expected != observed) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + observed);\n+        }\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo3(int a) {\n+        int sum = a + a + a; \/\/ a*3 => (a<<1) + a\n+        verifyResult(a, 3, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo4(int a) {\n+        int sum = a + a + a + a; \/\/ a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void shiftAndAddTo4(int a) {\n+        int sum = (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void mulAndAddTo4(int a) {\n+        int sum = a * 3 + a; \/\/ a*4 => a<<2\n+        verifyResult(a, 4, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo5L(int a) {\n+        int sum = a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+        verifyResult(a, 5, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(counts = {IRNode.LSHIFT_I, \"2\"})\n+    private static void addTo6L(int a) {\n+        int sum = a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+        verifyResult(a, 6, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    private static void addTo7(int a) {\n+        int sum = a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+        verifyResult(a, 7, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo8(int a) {\n+        int sum = a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+        verifyResult(a, 8, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = {IRNode.LSHIFT_I, \"1\"})\n+    private static void addTo16(int a) {\n+        int sum = a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+        verifyResult(a, 16, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void addTo42(int a) {\n+        int sum = a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+        verifyResult(a, 42, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void mulAndAddTo42(int a) {\n+        int sum = a * 40 + a + a; \/\/ a*41 + a => a*42\n+        verifyResult(a, 42, sum);\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    private static void mulAndAddToMax(int a) {\n+        int sum = a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<31) - 1\n+        verifyResult(a, Integer.MAX_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static void mulAndAddToOverflow(int a) {\n+        int sum = a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+        verifyResult(a, Integer.MIN_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static void mulAndAddToZero(int a) {\n+        int sum = a*-1 + a; \/\/ 0\n+        verifyResult(a, 0, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    @IR(counts = { IRNode.SUB_I, \"1\" })\n+    private static void mulAndAddToMinus1(int a) {\n+        int sum = a*-2 + a; \/\/ a*-1 => a - (a<<1)\n+        verifyResult(a, -1, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static void mulAndAddToMinus42(int a) {\n+        int sum = a*-43 + a; \/\/ a*-42\n+        verifyResult(a, -42, sum);\n+    }\n+\n+    \/\/ --- long tests ---\n+    private static final long INT_MAX_PLUS_ONE = (long) Integer.MAX_VALUE + 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static void mulAndAddToIntOverflowL(long a) {\n+        long sum = a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+        verifyResult(a, INT_MAX_PLUS_ONE, sum);\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    private static void mulAndAddToMaxL(long a) {\n+        long sum = a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+        verifyResult(a, Long.MAX_VALUE, sum);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static void mulAndAddToOverflowL(long a) {\n+        long sum = a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+        verifyResult(a, Long.MIN_VALUE, sum);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/arithmeticCanonicalization\/SerialAdditionCanonicalization.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -96,2 +96,2 @@\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Optimized into x << 2 by JDK-8325495\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Optimized into x << 2 by JDK-8325495\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}