{"files":[{"patch":"@@ -368,2 +368,2 @@\n-Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {\n-  const char* utf8_str = (char*)symbol->bytes();\n+Handle java_lang_String::create_from_symbol(const Symbol* symbol, TRAPS) {\n+  const char* utf8_str = symbol->get_utf8();\n@@ -392,1 +392,2 @@\n-  {\n+  \/\/ This check is too strict when the symbol does not contain valid UTF8.\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, utf8_len, false)) {\n@@ -739,1 +740,1 @@\n-bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {\n+bool java_lang_String::equals(oop java_string, const jchar* chars, int num_unicode_points) {\n@@ -744,1 +745,1 @@\n-  if (length != len) {\n+  if (length != num_unicode_points) {\n@@ -749,1 +750,1 @@\n-    for (int i = 0; i < len; i++) {\n+    for (int i = 0; i < num_unicode_points; i++) {\n@@ -755,1 +756,1 @@\n-    for (int i = 0; i < len; i++) {\n+    for (int i = 0; i < num_unicode_points; i++) {\n@@ -764,0 +765,28 @@\n+bool java_lang_String::equals(oop java_string, const char* utf8_string, int num_unicode_points) {\n+  assert(java_string->klass() == vmClasses::String_klass(),\n+         \"must be java_string\");\n+  typeArrayOop value = java_lang_String::value_no_keepalive(java_string);\n+  int length = java_lang_String::length(java_string, value);\n+  if (length != num_unicode_points) {\n+    return false;\n+  }\n+  bool is_latin1 = java_lang_String::is_latin1(java_string);\n+  jchar c;\n+  if (!is_latin1) {\n+    for (int i = 0; i < num_unicode_points; i++) {\n+      utf8_string = UTF8::next(utf8_string, &c);\n+      if (value->char_at(i) != c) {\n+        return false;\n+      }\n+    }\n+  } else {\n+    for (int i = 0; i < num_unicode_points; i++) {\n+      utf8_string = UTF8::next(utf8_string, &c);\n+      if ((((jchar) value->byte_at(i)) & 0xff) != c) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -102,1 +103,1 @@\n-  static Handle create_from_symbol(Symbol* symbol, TRAPS);\n+  static Handle create_from_symbol(const Symbol* symbol, TRAPS);\n@@ -183,0 +184,11 @@\n+  static unsigned int hash_code(const char *utf8_str, int num_unicode_points) {\n+    unsigned int h = 0;\n+\n+    jchar a;\n+    while (num_unicode_points-- > 0) {\n+      utf8_str = UTF8::next(utf8_str, &a);\n+      h = 31 * h + ((unsigned int)a);\n+    }\n+    return h;\n+  }\n+\n@@ -186,1 +198,2 @@\n-  static bool equals(oop java_string, const jchar* chars, int len);\n+  static bool equals(oop java_string, const jchar* chars, int num_unicode_points);\n+  static bool equals(oop java_string, const char* chars, int num_unicode_points);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -102,1 +103,1 @@\n-  const jchar*, oop,\n+  StringTable::StringWrapper, oop,\n@@ -104,1 +105,1 @@\n-  java_lang_String::equals> SharedStringTable;\n+  StringTable::wrapped_string_equals> SharedStringTable;\n@@ -132,0 +133,30 @@\n+unsigned int StringTable::hash_wrapped_string(StringWrapper wrapped_str, int len) {\n+  switch (wrapped_str.type) {\n+  case StringType::OopStr:\n+    return java_lang_String::hash_code(wrapped_str.oop_str());\n+  case StringType::UnicodeStr:\n+    return java_lang_String::hash_code(wrapped_str.unicode_str, len);\n+  case StringType::SymbolStr:\n+    return java_lang_String::hash_code(wrapped_str.symbol_str->get_utf8(), len);\n+  case StringType::UTF8Str:\n+    return java_lang_String::hash_code(wrapped_str.utf8_str, len);\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n+bool StringTable::wrapped_string_equals(oop java_string, StringWrapper wrapped_str, int len) {\n+  switch (wrapped_str.type) {\n+  case StringType::OopStr:\n+    return java_lang_String::equals(java_string, wrapped_str.oop_str());\n+  case StringType::UnicodeStr:\n+    return java_lang_String::equals(java_string, wrapped_str.unicode_str, len);\n+  case StringType::SymbolStr:\n+    return java_lang_String::equals(java_string, wrapped_str.symbol_str->get_utf8(), len);\n+  case StringType::UTF8Str:\n+    return java_lang_String::equals(java_string, wrapped_str.utf8_str, len);\n+  }\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n@@ -166,3 +197,1 @@\n-class StringTableLookupJchar : StackObj {\n- private:\n-  Thread* _thread;\n+class StringTableLookup : StackObj {\n@@ -170,2 +199,3 @@\n-  int _len;\n-  const jchar* _str;\n+\n+protected:\n+  Thread* _thread;\n@@ -174,6 +204,7 @@\n- public:\n-  StringTableLookupJchar(Thread* thread, uintx hash, const jchar* key, int len)\n-    : _thread(thread), _hash(hash), _len(len), _str(key) {\n-  }\n-  uintx get_hash() const {\n-    return _hash;\n+public:\n+  StringTableLookup(Thread* thread, uintx hash)\n+      : _hash(hash), _thread(thread) {}\n+  uintx get_hash() const { return _hash; }\n+  bool is_dead(WeakHandle* value) {\n+    oop val_oop = value->peek();\n+    return val_oop == nullptr;\n@@ -181,0 +212,11 @@\n+};\n+\n+class StringTableLookupUnicode : public StringTableLookup {\n+private:\n+  const jchar* _str;\n+  int _len;\n+\n+public:\n+  StringTableLookupUnicode(Thread* thread, uintx hash, const jchar* key, int len)\n+      : StringTableLookup(thread, hash), _str(key), _len(len) {}\n+\n@@ -191,1 +233,1 @@\n-     _found = Handle(_thread, value->resolve());\n+    _found = Handle(_thread, value->resolve());\n@@ -194,1 +236,12 @@\n-  bool is_dead(WeakHandle* value) {\n+};\n+\n+class StringTableLookupUTF8 : public StringTableLookup {\n+private:\n+  const char* _str;\n+  int _len;\n+\n+public:\n+  StringTableLookupUTF8(Thread* thread, uintx hash, const char* key, int len)\n+      : StringTableLookup(thread, hash), _str(key), _len(len) {}\n+\n+  bool equals(WeakHandle* value) {\n@@ -196,1 +249,10 @@\n-    return val_oop == nullptr;\n+    if (val_oop == nullptr) {\n+      return false;\n+    }\n+    bool equals = java_lang_String::equals(val_oop, _str, _len);\n+    if (!equals) {\n+      return false;\n+    }\n+    \/\/ Need to resolve weak handle and Handleize through possible safepoint.\n+    _found = Handle(_thread, value->resolve());\n+    return true;\n@@ -200,4 +262,2 @@\n-class StringTableLookupOop : public StackObj {\n- private:\n-  Thread* _thread;\n-  uintx _hash;\n+class StringTableLookupOop : public StringTableLookup {\n+private:\n@@ -205,5 +265,0 @@\n-  Handle _found;  \/\/ Might be a different oop with the same value that's already\n-                  \/\/ in the table, which is the point.\n- public:\n-  StringTableLookupOop(Thread* thread, uintx hash, Handle handle)\n-    : _thread(thread), _hash(hash), _find(handle) { }\n@@ -211,3 +266,3 @@\n-  uintx get_hash() const {\n-    return _hash;\n-  }\n+public:\n+  StringTableLookupOop(Thread* thread, uintx hash, Handle handle)\n+      : StringTableLookup(thread, hash), _find(handle) {}\n@@ -228,5 +283,0 @@\n-\n-  bool is_dead(WeakHandle* value) {\n-    oop val_oop = value->peek();\n-    return val_oop == nullptr;\n-  }\n@@ -294,1 +344,2 @@\n-  oop string = lookup_shared(name, len, hash);\n+  StringWrapper wrapped_name(name);\n+  oop string = lookup_shared(wrapped_name, len, hash);\n@@ -301,1 +352,1 @@\n-  return do_lookup(name, len, hash);\n+  return do_lookup(wrapped_name, len, hash);\n@@ -326,1 +377,1 @@\n-oop StringTable::do_lookup(const jchar* name, int len, uintx hash) {\n+oop StringTable::do_lookup(StringWrapper name, int len, uintx hash) {\n@@ -328,1 +379,0 @@\n-  StringTableLookupJchar lookup(thread, hash, name, len);\n@@ -331,1 +381,26 @@\n-  _local_table->get(thread, lookup, stg, &rehash_warning);\n+\n+  switch (name.type) {\n+  case StringType::OopStr: {\n+    StringTableLookupOop lookup(thread, hash, name.oop_str);\n+    _local_table->get(thread, lookup, stg, &rehash_warning);\n+    break;\n+  }\n+  case StringType::UnicodeStr: {\n+    StringTableLookupUnicode lookup(thread, hash, name.unicode_str, len);\n+    _local_table->get(thread, lookup, stg, &rehash_warning);\n+    break;\n+  }\n+  case StringType::SymbolStr: {\n+    StringTableLookupUTF8 lookup(thread, hash, name.symbol_str->get_utf8(), len);\n+    _local_table->get(thread, lookup, stg, &rehash_warning);\n+    break;\n+  }\n+  case StringType::UTF8Str: {\n+    StringTableLookupUTF8 lookup(thread, hash, name.utf8_str, len);\n+    _local_table->get(thread, lookup, stg, &rehash_warning);\n+    break;\n+  }\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n@@ -336,0 +411,36 @@\n+const jchar *StringTable::to_unicode(StringWrapper wrapped_str, int len, TRAPS) {\n+  switch (wrapped_str.type) {\n+  case StringType::UnicodeStr:\n+    return wrapped_str.unicode_str;\n+  case StringType::OopStr:\n+    return java_lang_String::as_unicode_string(wrapped_str.oop_str(), len, CHECK_NULL);\n+  case StringType::SymbolStr: {\n+    jchar *chars = NEW_RESOURCE_ARRAY(jchar, len);\n+    UTF8::convert_to_unicode(wrapped_str.symbol_str->get_utf8(), chars, len);\n+    return chars;\n+  }\n+  case StringType::UTF8Str: {\n+    jchar *chars = NEW_RESOURCE_ARRAY(jchar, len);\n+    UTF8::convert_to_unicode(wrapped_str.utf8_str, chars, len);\n+    return chars;\n+  }\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+Handle StringTable::to_handle(StringWrapper wrapped_str, int len, TRAPS) {\n+  switch (wrapped_str.type) {\n+  case StringType::OopStr:\n+    return wrapped_str.oop_str;\n+  case StringType::UnicodeStr:\n+    return java_lang_String::create_from_unicode(wrapped_str.unicode_str, len, THREAD);\n+  case StringType::SymbolStr:\n+    return java_lang_String::create_from_symbol(wrapped_str.symbol_str, THREAD);\n+  case StringType::UTF8Str:\n+    return java_lang_String::create_from_str(wrapped_str.utf8_str, THREAD);\n+  }\n+  ShouldNotReachHere();\n+  return Handle();\n+}\n+\n@@ -339,5 +450,3 @@\n-  ResourceMark rm(THREAD);\n-  int length;\n-  jchar* chars = symbol->as_unicode(length);\n-  Handle string;\n-  oop result = intern(string, chars, length, CHECK_NULL);\n+  int length = UTF8::unicode_length(symbol->get_utf8(), symbol->utf8_length());\n+  StringWrapper name(symbol);\n+  oop result = intern(name, length, CHECK_NULL);\n@@ -349,2 +458,1 @@\n-  ResourceMark rm(THREAD);\n-  int length;\n+  int length = java_lang_String::length(string);\n@@ -352,3 +460,2 @@\n-  jchar* chars = java_lang_String::as_unicode_string(string, length,\n-                                                     CHECK_NULL);\n-  oop result = intern(h_string, chars, length, CHECK_NULL);\n+  StringWrapper name(h_string);\n+  oop result = intern(name, length, CHECK_NULL);\n@@ -360,1 +467,0 @@\n-  ResourceMark rm(THREAD);\n@@ -362,4 +468,2 @@\n-  jchar* chars = NEW_RESOURCE_ARRAY(jchar, length);\n-  UTF8::convert_to_unicode(utf8_string, chars, length);\n-  Handle string;\n-  oop result = intern(string, chars, length, CHECK_NULL);\n+  StringWrapper name(utf8_string);\n+  oop result = intern(name, length, CHECK_NULL);\n@@ -369,1 +473,1 @@\n-oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {\n+oop StringTable::intern(StringWrapper name, int len, TRAPS) {\n@@ -371,1 +475,1 @@\n-  unsigned int hash = java_lang_String::hash_code(name, len);\n+  unsigned int hash = hash_wrapped_string(name, len);\n@@ -376,0 +480,1 @@\n+\n@@ -377,1 +482,4 @@\n-    hash = hash_string(name, len, true);\n+    ResourceMark rm(THREAD);\n+    \/\/ Convert to unicode for alt hashing\n+    const jchar *chars = to_unicode(name, len, CHECK_NULL);\n+    hash = hash_string(chars, len, true);\n@@ -379,0 +487,1 @@\n+\n@@ -383,1 +492,1 @@\n-  return do_intern(string_or_null_h, name, len, hash, THREAD);\n+  return do_intern(name, len, hash, THREAD);\n@@ -386,2 +495,1 @@\n-oop StringTable::do_intern(Handle string_or_null_h, const jchar* name,\n-                           int len, uintx hash, TRAPS) {\n+oop StringTable::do_intern(StringWrapper name, int len, uintx hash, TRAPS) {\n@@ -389,7 +497,1 @@\n-  Handle string_h;\n-\n-  if (!string_or_null_h.is_null()) {\n-    string_h = string_or_null_h;\n-  } else {\n-    string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL);\n-  }\n+  Handle string_h = to_handle(name, len, CHECK_NULL);\n@@ -397,1 +499,1 @@\n-  assert(java_lang_String::equals(string_h(), name, len),\n+  assert(StringTable::wrapped_string_equals(string_h(), name, len),\n@@ -413,1 +515,1 @@\n-    \/\/ Callers have already looked up the String using the jchar* name, so just go to add.\n+    \/\/ Callers have already looked up the String, so just go to add.\n@@ -778,2 +880,2 @@\n-oop StringTable::lookup_shared(const jchar* name, int len, unsigned int hash) {\n-  assert(hash == java_lang_String::hash_code(name, len),\n+oop StringTable::lookup_shared(StringWrapper name, int len, unsigned int hash) {\n+  assert(hash == hash_wrapped_string(name, len),\n@@ -785,1 +887,2 @@\n-  return _shared_table.lookup(name, java_lang_String::hash_code(name, len), len);\n+  StringWrapper wrapped_name(name);\n+  return _shared_table.lookup(wrapped_name, java_lang_String::hash_code(name, len), len);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":174,"deletions":71,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -59,0 +59,31 @@\n+  \/\/ typedef enum { obj_str, unicode_str, symbol_str, utf8_str } StringType;\n+  enum class StringType {\n+    OopStr, UnicodeStr, SymbolStr, UTF8Str\n+  };\n+\n+  struct StringWrapperInternal {\n+    union {\n+      const Handle oop_str;\n+      const jchar* unicode_str;\n+      const Symbol* symbol_str;\n+      const char* utf8_str;\n+    };\n+    const StringType type;\n+\n+    StringWrapperInternal(const Handle oop_str)     : oop_str(oop_str),         type(StringType::OopStr)     {}\n+    StringWrapperInternal(const jchar* unicode_str) : unicode_str(unicode_str), type(StringType::UnicodeStr) {}\n+    StringWrapperInternal(const Symbol* symbol_str) : symbol_str(symbol_str),   type(StringType::SymbolStr)  {}\n+    StringWrapperInternal(const char* utf8_str)     : utf8_str(utf8_str),       type(StringType::UTF8Str)    {}\n+  };\n+\n+public:\n+  typedef struct StringWrapperInternal StringWrapper;\n+\n+  static bool wrapped_string_equals(oop java_string, StringWrapper wrapped_str, int len);\n+\n+private:\n+  static unsigned int hash_wrapped_string(StringWrapper wrapped_str, int len);\n+  static const jchar *to_unicode(StringWrapper wrapped_str, int len, TRAPS);\n+  static Handle to_handle(StringWrapper wrapped_str, int len, TRAPS);\n+  static void print_string(StringWrapper wrapped_str, int len, TRAPS);\n+\n@@ -68,3 +99,3 @@\n-  static oop intern(Handle string_or_null_h, const jchar* name, int len, TRAPS);\n-  static oop do_intern(Handle string_or_null, const jchar* name, int len, uintx hash, TRAPS);\n-  static oop do_lookup(const jchar* name, int len, uintx hash);\n+  static oop intern(StringWrapper name, int len, TRAPS);\n+  static oop do_intern(StringWrapper name, int len, uintx hash, TRAPS);\n+  static oop do_lookup(StringWrapper name, int len, uintx hash);\n@@ -134,1 +165,1 @@\n-  static oop lookup_shared(const jchar* name, int len, unsigned int hash) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop lookup_shared(StringWrapper name, int len, unsigned int hash) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -261,0 +261,3 @@\n+  \/\/ Returns the non-null-terminated utf8 string stored in the symbol\n+  const char* get_utf8() const { return reinterpret_cast<const char*>(bytes()); }\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Tests that string functions (hash code\/equals) stay consistant when comparing equal strings and converting between strings types\n+\n+\/\/ Simple ASCII string \" Java(R)!! \"\n+\/\/ Same length in both UTF8 and Unicode\n+static const char static_ascii_utf8_str[] = {0x4A, 0x61, 0x76, 0x61, 0x28, 0x52, 0x29, 0x21, 0x21};\n+static const jchar static_ascii_unicode_str[] = {0x004A, 0x0061, 0x0076, 0x0061, 0x0028, 0x0052, 0x0029, 0x0021, 0x0021};\n+\n+\/\/ Complex string \" Jāvá®!☺☻ \", UTF8 has character lengths 13122133 = 16\n+static const unsigned char static_utf8_str[] = {0x4A, 0x61, 0xCC, 0x84, 0x76, 0xC3, 0xA1, 0xC2, 0xAE, 0x21, 0xE2, 0x98, 0xBA, 0xE2, 0x98, 0xBB};\n+static const jchar static_unicode_str[] = { 0x004A, 0x0061, 0x0304, 0x0076, 0x00E1, 0x00AE, 0x0021, 0x263A, 0x263B};\n+\n+static const int ASCII_LENGTH = 9;\n+static const int UTF8_LENGTH = 16;\n+static const int UNICODE_LENGTH = 9;\n+\n+void compare_utf8_utf8(const char* utf8_str1, const char* utf8_str2, int num_chars) {\n+    EXPECT_EQ(java_lang_String::hash_code(utf8_str1, num_chars), java_lang_String::hash_code(utf8_str2, num_chars));\n+    EXPECT_STREQ(utf8_str1, utf8_str2);\n+}\n+\n+void compare_utf8_unicode(const char* utf8_str, const jchar* unicode_str, int num_chars) {\n+    EXPECT_EQ(java_lang_String::hash_code(utf8_str, num_chars), java_lang_String::hash_code(unicode_str, num_chars));\n+}\n+\n+void compare_utf8_oop(const char* utf8_str, Handle oop_str, int num_chars) {\n+    EXPECT_EQ(java_lang_String::hash_code(utf8_str, num_chars), java_lang_String::hash_code(oop_str()));\n+    EXPECT_TRUE(java_lang_String::equals(oop_str(), utf8_str, num_chars));\n+}\n+\n+void compare_unicode_unicode(const jchar* unicode_str1, const jchar* unicode_str2, int num_chars) {\n+    EXPECT_EQ(java_lang_String::hash_code(unicode_str1, num_chars), java_lang_String::hash_code(unicode_str2, num_chars));\n+    for (int i = 0; i < num_chars; i++) {\n+        EXPECT_EQ(unicode_str1[i], unicode_str2[i]);\n+    }\n+}\n+\n+void compare_unicode_oop(const jchar* unicode_str, Handle oop_str, int num_chars) {\n+    EXPECT_EQ(java_lang_String::hash_code(unicode_str, num_chars), java_lang_String::hash_code(oop_str()));\n+    EXPECT_TRUE(java_lang_String::equals(oop_str(), unicode_str, num_chars));\n+}\n+\n+void compare_oop_oop(Handle oop_str1, Handle oop_str2) {\n+    EXPECT_EQ(java_lang_String::hash_code(oop_str1()), java_lang_String::hash_code(oop_str2()));\n+    EXPECT_TRUE(java_lang_String::equals(oop_str1(), oop_str2()));\n+}\n+\n+void test_utf8_convert(const char* utf8_str, int num_chars) {\n+    EXPECT_TRUE(UTF8::is_legal_utf8((unsigned char*)utf8_str, strlen(utf8_str), false));\n+\n+    JavaThread* THREAD = JavaThread::current();\n+    ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+    ResourceMark rm(THREAD);\n+    HandleMark hm(THREAD);\n+\n+    jchar* unicode_str_from_utf8 = NEW_RESOURCE_ARRAY(jchar, num_chars);\n+    UTF8::convert_to_unicode(utf8_str, unicode_str_from_utf8, num_chars);\n+    Handle oop_str_from_utf8 = java_lang_String::create_from_str(utf8_str, THREAD);\n+\n+    compare_utf8_unicode(utf8_str, unicode_str_from_utf8, num_chars);\n+    compare_utf8_oop(utf8_str, oop_str_from_utf8, num_chars);\n+\n+    size_t length = num_chars;\n+    const char* utf8_str_from_unicode = UNICODE::as_utf8(unicode_str_from_utf8, length);\n+    const char* utf8_str_from_oop = java_lang_String::as_utf8_string(oop_str_from_utf8());\n+\n+    EXPECT_TRUE(UTF8::is_legal_utf8((unsigned char*)utf8_str_from_unicode, strlen(utf8_str_from_unicode), false));\n+    EXPECT_TRUE(UTF8::is_legal_utf8((unsigned char*)utf8_str_from_oop, strlen(utf8_str_from_oop), false));\n+\n+    compare_utf8_utf8(utf8_str, utf8_str_from_unicode, num_chars);\n+    compare_utf8_utf8(utf8_str, utf8_str_from_oop, num_chars);\n+}\n+\n+void test_unicode_convert(const jchar* unicode_str, int num_chars) {\n+    JavaThread* THREAD = JavaThread::current();\n+    ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+    ResourceMark rm(THREAD);\n+    HandleMark hm(THREAD);\n+\n+    size_t length = num_chars;\n+    const char* utf8_str_from_unicode = UNICODE::as_utf8(unicode_str, length);\n+    Handle oop_str_from_unicode = java_lang_String::create_from_unicode(unicode_str, num_chars, THREAD);\n+\n+    EXPECT_TRUE(UTF8::is_legal_utf8((unsigned char*)utf8_str_from_unicode, strlen(utf8_str_from_unicode), false));\n+\n+    compare_utf8_unicode(utf8_str_from_unicode, unicode_str, num_chars);\n+    compare_unicode_oop(unicode_str, oop_str_from_unicode, num_chars);\n+\n+    int _;\n+    jchar* unicode_str_from_utf8 = NEW_RESOURCE_ARRAY(jchar, num_chars);\n+    UTF8::convert_to_unicode(utf8_str_from_unicode, unicode_str_from_utf8, num_chars);\n+    const jchar* unicode_str_from_oop = java_lang_String::as_unicode_string(oop_str_from_unicode(), _, THREAD);\n+\n+    compare_unicode_unicode(unicode_str, unicode_str_from_utf8, num_chars);\n+    compare_unicode_unicode(unicode_str, unicode_str_from_oop, num_chars);\n+}\n+\n+void test_utf8_unicode_cross(const char* utf8_str, const jchar* unicode_str, int num_chars) {\n+    compare_utf8_unicode(utf8_str, unicode_str, num_chars);\n+\n+    JavaThread* THREAD = JavaThread::current();\n+    ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+    ResourceMark rm(THREAD);\n+    HandleMark hm(THREAD);\n+\n+    size_t length = num_chars;\n+    const char* utf8_str_from_unicode = UNICODE::as_utf8(unicode_str, length);\n+\n+    jchar* unicode_str_from_utf8 = NEW_RESOURCE_ARRAY(jchar, num_chars);\n+    UTF8::convert_to_unicode(utf8_str, unicode_str_from_utf8, num_chars);\n+\n+    Handle oop_str_from_unicode = java_lang_String::create_from_unicode(unicode_str, num_chars, THREAD);\n+    Handle oop_str_from_utf8 = java_lang_String::create_from_str(utf8_str, THREAD);\n+\n+    compare_utf8_utf8(utf8_str, utf8_str_from_unicode, num_chars);\n+    compare_utf8_oop(utf8_str, oop_str_from_unicode, num_chars);\n+\n+    compare_unicode_unicode(unicode_str, unicode_str_from_utf8, num_chars);\n+    compare_unicode_oop(unicode_str, oop_str_from_utf8, num_chars);\n+\n+    compare_utf8_oop(utf8_str_from_unicode, oop_str_from_utf8, num_chars);\n+    compare_unicode_oop(unicode_str_from_utf8, oop_str_from_unicode, num_chars);\n+\n+    compare_utf8_unicode(utf8_str_from_unicode, unicode_str_from_utf8, num_chars);\n+    compare_oop_oop(oop_str_from_utf8, oop_str_from_unicode);\n+}\n+\n+TEST_VM(StringConversion, fromUTF8_ascii) {\n+    const char utf8_str[ASCII_LENGTH + 1] = { };\n+    memcpy((unsigned char*)utf8_str, static_ascii_utf8_str, ASCII_LENGTH);\n+    test_utf8_convert(utf8_str, ASCII_LENGTH);\n+}\n+\n+TEST_VM(StringConversion, fromUTF8_varlen) {\n+    const char utf8_str[UTF8_LENGTH + 1] = { };\n+    memcpy((unsigned char*)utf8_str, static_utf8_str, UTF8_LENGTH);\n+    test_utf8_convert(utf8_str, UNICODE_LENGTH);\n+}\n+\n+TEST_VM(StringConversion, fromUnicode_ascii) {\n+    jchar unicode_str[ASCII_LENGTH] = { };\n+    memcpy(unicode_str, static_ascii_unicode_str, ASCII_LENGTH * sizeof(jchar));\n+    test_unicode_convert(unicode_str, ASCII_LENGTH);\n+}\n+\n+TEST_VM(StringConversion, fromUnicode_varlen) {\n+    jchar unicode_str[UNICODE_LENGTH] = { };\n+    memcpy(unicode_str, static_unicode_str, UNICODE_LENGTH * sizeof(jchar));\n+    test_unicode_convert(unicode_str, UNICODE_LENGTH);\n+}\n+\n+TEST_VM(StringConversion, cross_ascii) {\n+    const char utf8_str[ASCII_LENGTH + 1] = { };\n+    jchar unicode_str[ASCII_LENGTH] = { };\n+    memcpy((unsigned char*)utf8_str, static_ascii_utf8_str, ASCII_LENGTH);\n+    memcpy(unicode_str, static_ascii_unicode_str, ASCII_LENGTH * sizeof(jchar));\n+\n+    test_utf8_unicode_cross(utf8_str, unicode_str, ASCII_LENGTH);\n+}\n+\n+TEST_VM(StringConversion, cross_varlen) {\n+    const char utf8_str[UTF8_LENGTH + 1] = { };\n+    jchar unicode_str[UNICODE_LENGTH] = { };\n+    memcpy((unsigned char*)utf8_str, static_utf8_str, UTF8_LENGTH);\n+    memcpy(unicode_str, static_unicode_str, UNICODE_LENGTH * sizeof(jchar));\n+\n+    test_utf8_unicode_cross(utf8_str, unicode_str, UNICODE_LENGTH);\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_stringConversion.cpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Tests that strings are interned and returns the same string when interning from different string types\n+\n+\/\/ Simple ASCII string \" Java(R)!! \"\n+static const char static_ascii_utf8_str[] = {0x4A, 0x61, 0x76, 0x61, 0x28, 0x52, 0x29, 0x21, 0x21};\n+static const int ASCII_LENGTH = 9;\n+\n+\/\/ Complex string \" Jāvá®!☺☻ \", has character lengths 13122133 = 16\n+static const unsigned char static_utf8_str[] = {0x4A, 0x61, 0xCC, 0x84, 0x76, 0xC3, 0xA1, 0xC2, 0xAE, 0x21, 0xE2, 0x98, 0xBA, 0xE2, 0x98, 0xBB};\n+static const int COMPLEX_LENGTH = 16;\n+\n+void test_intern(const char* utf8_str, int utf8_length) {\n+    JavaThread* THREAD = JavaThread::current();\n+    ThreadInVMfromNative ThreadInVMfromNative(THREAD);\n+    HandleMark hm(THREAD);\n+\n+    oop interned_string_from_utf8 = StringTable::intern(utf8_str, THREAD);\n+\n+    int num_chars = UTF8::unicode_length(utf8_str, utf8_length);\n+    EXPECT_TRUE(java_lang_String::equals(interned_string_from_utf8, utf8_str, num_chars));\n+    EXPECT_EQ(java_lang_String::hash_code(utf8_str, num_chars),java_lang_String::hash_code(interned_string_from_utf8));\n+\n+    Symbol* symbol_from_utf8 = SymbolTable::new_symbol(utf8_str, utf8_length);\n+    oop interned_string_from_symbol = StringTable::intern(symbol_from_utf8, THREAD);\n+\n+    EXPECT_EQ(interned_string_from_utf8, interned_string_from_symbol);\n+\n+    oop interned_string_from_oop1 = StringTable::intern(interned_string_from_utf8, THREAD);\n+\n+    EXPECT_EQ(interned_string_from_utf8, interned_string_from_oop1);\n+\n+}\n+\n+TEST_VM(StringIntern, intern_ascii) {\n+    const char utf8_str[ASCII_LENGTH + 1] = { };\n+    memcpy((unsigned char*)utf8_str, static_ascii_utf8_str, ASCII_LENGTH);\n+    test_intern(utf8_str, ASCII_LENGTH);\n+}\n+\n+TEST_VM(StringIntern, intern_varlen) {\n+    const char utf8_str[COMPLEX_LENGTH + 1] = { };\n+    memcpy((unsigned char*)utf8_str, static_utf8_str, COMPLEX_LENGTH);\n+    test_intern(utf8_str, COMPLEX_LENGTH);\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_stringIntern.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}