{"files":[{"patch":"@@ -1791,1 +1791,1 @@\n-void CodeCache::write_perf_map(const char* filename, outputStream* out) {\n+void CodeCache::write_perf_map(const char* filename) {\n@@ -1793,11 +1793,0 @@\n-\n-  \/\/ Perf expects to find the map file at \/tmp\/perf-<pid>.map\n-  \/\/ if the file name is not specified.\n-  char fname[JVM_MAXPATHLEN];\n-  constexpr char filename_default[] = \"\/tmp\/perf-%p.map\";\n-  const char *src = filename == nullptr ? filename_default : filename;\n-  if (!Arguments::copy_expand_pid(src, strlen(src), fname, sizeof(fname))) {\n-    out->print_cr(\"Invalid file path name specified: %s\", src);\n-    return;\n-  }\n-  filename = fname;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  LINUX_ONLY(static void write_perf_map(const char* filename, outputStream* out);)\n+  LINUX_ONLY(static void write_perf_map(const char* filename = nullptr);)\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,8 @@\n+   } else if (strcmp(type, \"FILE\") == 0) {\n+     DCmdArgument<FileArgument> *argument =\n+      new DCmdArgument<FileArgument>(name, desc, \"FILE\", mandatory);\n+     if (isarg) {\n+      parser->add_dcmd_argument(argument);\n+     } else {\n+      parser->add_dcmd_option(argument);\n+     }\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-    CodeCache::write_perf_map(nullptr, tty);\n+    CodeCache::write_perf_map();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,4 @@\n+void GenDCmdArgument::to_string(FileArgument f, char *buf, size_t len) const {\n+  jio_snprintf(buf, len, \"%s\", (f._name != nullptr) ? f._name : \"\");\n+}\n+\n@@ -353,0 +357,28 @@\n+\n+template <>\n+void DCmdArgument<FileArgument>::parse_value(const char *str, size_t len,\n+                                                   TRAPS) {\n+  if (str == NULL) {\n+    _value._name = nullptr;\n+  } else {\n+    _value._name = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtInternal);\n+    if (!Arguments::copy_expand_pid(str, len, _value._name, JVM_MAXPATHLEN)) {\n+      fatal(\"Invalid file path: %s\", str);\n+    }\n+  }\n+}\n+\n+template <> void DCmdArgument<FileArgument>::init_value(TRAPS) {\n+  if (has_default() && _default_string != NULL) {\n+    this->parse_value(_default_string, strlen(_default_string), THREAD);\n+  } else {\n+    _value._name = nullptr;\n+  }\n+}\n+\n+template <> void DCmdArgument<FileArgument>::destroy_value() {\n+  if (_value._name != nullptr) {\n+    FREE_C_HEAP_ARRAY(char, _value._name);\n+    _value._name = nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -62,0 +63,5 @@\n+class FileArgument {\n+  public:\n+    char *_name;\n+};\n+\n@@ -107,0 +113,1 @@\n+  void to_string(FileArgument f, char *buf, size_t len) const;\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -519,8 +519,0 @@\n-  \/\/ If the filename contains %p, it will be replaced by the pid.\n-  char fname[JVM_MAXPATHLEN];\n-  if (!Arguments::copy_expand_pid(_filename.value(), strlen(_filename.value()),\n-                                  fname, sizeof(fname))) {\n-    output()->print_cr(\"Invalid file path name specified: %s\", _filename.value());\n-    return;\n-  }\n-\n@@ -531,1 +523,1 @@\n-  dumper.dump(fname, output(), (int)level, _overwrite.value(),\n+  dumper.dump(_filename.value()._name, output(), (int)level, _overwrite.value(),\n@@ -864,1 +856,1 @@\n-#define DEFAULT_PERFMAP_FILENAME \"\/tmp\/perf-<pid>.map\"\n+#define DEFAULT_PERFMAP_FILENAME \"\/tmp\/perf-%p.map\"\n@@ -874,4 +866,1 @@\n-  \/\/ The check for _filename.is_set() is because we don't want to use\n-  \/\/ DEFAULT_PERFMAP_FILENAME, since it is meant as a description\n-  \/\/ of the default, not the actual default.\n-  CodeCache::write_perf_map(_filename.is_set() ? _filename.value() : nullptr, output());\n+  CodeCache::write_perf_map(_filename.value()._name);\n@@ -1028,1 +1017,1 @@\n-  const char* file = _filename.is_set() ? _filename.value() : nullptr;\n+  const char* file = _filename.is_set() ? _filename.value()._name : nullptr;\n@@ -1051,1 +1040,0 @@\n-  char fname[JVM_MAXPATHLEN];\n@@ -1053,6 +1041,1 @@\n-    \/\/ If the filename contains %p, it will be replaced by the pid.\n-    if (Arguments::copy_expand_pid(file, strlen(file), fname, sizeof(fname))) {\n-      fileh = java_lang_String::create_from_str(fname, CHECK);\n-    } else {\n-      output()->print_cr(\"Invalid file path name specified %s, fall back to default name.\", file);\n-    }\n+    fileh = java_lang_String::create_from_str(file, CHECK);\n@@ -1131,7 +1114,0 @@\n-  char path[JVM_MAXPATHLEN];\n-  if (!Arguments::copy_expand_pid(_filepath.value(), strlen(_filepath.value()),\n-                                  path, sizeof(path))) {\n-    output()->print_cr(\"Invalid file path name specified: %s\",\n-                       _filepath.value());\n-    return;\n-  }\n@@ -1140,1 +1116,1 @@\n-  dumpToFile(name, vmSymbols::string_bool_byte_array_signature(), path, overwrite, CHECK);\n+  dumpToFile(name, vmSymbols::string_bool_byte_array_signature(), _filepath.value()._name, overwrite, CHECK);\n@@ -1210,1 +1186,1 @@\n-static constexpr char default_filename[] = \"vm_memory_map_<pid>.txt\";\n+static constexpr char default_filename[] = \"vm_memory_map_%p.txt\";\n@@ -1219,9 +1195,1 @@\n-  const char *name = nullptr;\n-  char fname[JVM_MAXPATHLEN];\n-  constexpr char filename_default[] = \"vm_memory_map_%p.txt\";\n-  const char* src = _filename.is_set() ? _filename.value() : filename_default;\n-  if (!Arguments::copy_expand_pid(src, strlen(src), fname, sizeof(fname))) {\n-    output()->print_cr(\"Invalid file path name specified: %s\", src);\n-    return;\n-  }\n-  name = fname;\n+  const char *name = _filename.value()._name;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-  DCmdArgument<char*> _filename;\n+  DCmdArgument<FileArgument> _filename;\n@@ -402,1 +402,1 @@\n-  DCmdArgument<char*> _filename;    \/\/ file name, optional\n+  DCmdArgument<FileArgument> _filename;    \/\/ file name, optional\n@@ -582,1 +582,1 @@\n-  DCmdArgument<char*> _filename;\n+  DCmdArgument<FileArgument> _filename;\n@@ -940,1 +940,1 @@\n-  DCmdArgument<char*> _filepath;\n+  DCmdArgument<FileArgument> _filepath;\n@@ -1003,1 +1003,1 @@\n-  DCmdArgument<char*> _filename;\n+  DCmdArgument<FileArgument> _filename;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -52,0 +53,1 @@\n+        testFileName();\n@@ -162,0 +164,27 @@\n+    public void testFileName() throws Exception {\n+        \/\/ --- Testing options\n+        long pid = ProcessTools.getProcessId();\n+\n+        \/\/ Test pid gets injected into %p\n+        String name = \"name\";\n+        DiagnosticCommand arg = new DiagnosticCommand(name,\n+                \"desc\", DiagnosticArgumentType.FILE,\n+                false, null);\n+        DiagnosticCommand[] args = {arg};\n+        parse(name, \"file%d.txt\".formatted(pid), name + \"=file%p.txt\", args);\n+\n+        \/\/ Test custom file name with no %p\n+        parse(name, \"myFile.txt\", name + \"=myFile.txt\", args);\n+\n+        \/\/ --- Testing arguments\n+\n+        \/\/ Test pid gets injected into %p\n+        arg = new DiagnosticCommand(name, \"desc\", DiagnosticArgumentType.FILE, true,\n+                false, null);\n+        args = new DiagnosticCommand[]{arg};\n+        parse(name, \"file%d.txt\".formatted(pid), \"file%p.txt\", args);\n+\n+        \/\/ Test custom file name with no %p\n+        parse(name, \"myFile.txt\", \"myFile.txt\", args);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/ParserTest.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm TestJcmdPIDSubstitution\n+ * @run driver TestJcmdPIDSubstitution\n@@ -56,5 +56,2 @@\n-        Path path;\n-        do {\n-            path = Paths.get(\"myfile%d\".formatted(pid));\n-        } while(Files.exists(path));\n-\n+        String test_dir = System.getProperty(\"test.dir\", \".\");\n+        Path path = Paths.get(\"%s\/myfile%d\".formatted(test_dir, pid));\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdPIDSubstitution.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-        JLONG, BOOLEAN, STRING, NANOTIME, STRINGARRAY, MEMORYSIZE\n+        JLONG, BOOLEAN, STRING, NANOTIME, STRINGARRAY, MEMORYSIZE, FILE\n","filename":"test\/lib\/jdk\/test\/whitebox\/parser\/DiagnosticCommand.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}