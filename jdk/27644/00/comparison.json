{"files":[{"patch":"@@ -67,1 +67,0 @@\n-#include \"gc\/g1\/g1RootProcessor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-    G1RootProcessor root_processor(_g1h, 1);\n+    G1RootProcessor root_processor(_g1h, false \/* is_parallel *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, uint n_workers) :\n+G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, bool is_parallel) :\n@@ -52,1 +52,3 @@\n-    _srs(n_workers) {}\n+    _nmethod_marking_scope(),\n+    _threads_claim_token_scope(),\n+    _is_parallel(is_parallel) {}\n@@ -178,2 +180,1 @@\n-    bool is_par = n_workers() > 1;\n-    Threads::possibly_parallel_oops_do(is_par,\n+    Threads::possibly_parallel_oops_do(_is_parallel,\n@@ -212,4 +213,0 @@\n-\n-uint G1RootProcessor::n_workers() const {\n-  return _srs.n_threads();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -51,1 +52,3 @@\n-  StrongRootsScope _srs;\n+  NMethodMarkingScope _nmethod_marking_scope;\n+  ThreadsClaimTokenScope _threads_claim_token_scope;\n+  bool _is_parallel;\n@@ -75,1 +78,1 @@\n-  G1RootProcessor(G1CollectedHeap* g1h, uint n_workers);\n+  G1RootProcessor(G1CollectedHeap* g1h, bool is_parallel);\n@@ -91,3 +94,0 @@\n-\n-  \/\/ Number of worker threads used by the root processor.\n-  uint n_workers() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -753,1 +754,1 @@\n-    G1RootProcessor root_processor(_g1h, num_workers);\n+    G1RootProcessor root_processor(_g1h, num_workers > 1 \/* is_parallel *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,15 +37,0 @@\n-\n-StrongRootsScope::StrongRootsScope(uint n_threads) : _n_threads(n_threads) {\n-  \/\/ No need for thread claim for statically-known sequential case (_n_threads == 0)\n-  \/\/ For positive values, clients of this class often unify sequential\/parallel\n-  \/\/ cases, so they expect the thread claim token to be updated.\n-  if (_n_threads != 0) {\n-    Threads::change_thread_claim_token();\n-  }\n-}\n-\n-StrongRootsScope::~StrongRootsScope() {\n-  if (_n_threads != 0) {\n-    Threads::assert_all_threads_claimed();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,13 +36,0 @@\n-\/\/ Sets up and tears down the required state for sequential\/parallel root processing.\n-class StrongRootsScope : public MarkScope {\n-  \/\/ Number of threads participating in the roots processing.\n-  \/\/ 0 means statically-known sequential root processing; used only by Serial GC\n-  const uint _n_threads;\n-\n- public:\n-  StrongRootsScope(uint n_threads);\n-  ~StrongRootsScope();\n-\n-  uint n_threads() const { return _n_threads; }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}