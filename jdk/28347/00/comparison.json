{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -31,1 +33,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -103,0 +106,41 @@\n+\/\/ Helper for TaskQueueSuper, encoding {queue index, tag} pair in a form that\n+\/\/ supports atomic access to the pair.\n+class TaskQueueAge {\n+  friend struct PrimitiveConversions::Translate<TaskQueueAge>;\n+\n+public:\n+  \/\/ Internal type used for indexing the queue, and for the tag.\n+  using idx_t = NOT_LP64(uint16_t) LP64_ONLY(uint32_t);\n+\n+  explicit TaskQueueAge(size_t data = 0) : _data{data} {}\n+  TaskQueueAge(idx_t top, idx_t tag) : _fields{top, tag} {}\n+\n+  idx_t top() const { return _fields._top; }\n+  idx_t tag() const { return _fields._tag; }\n+\n+  bool operator==(const TaskQueueAge& other) const { return _data == other._data; }\n+\n+private:\n+  struct Fields {\n+    idx_t _top;\n+    idx_t _tag;\n+  };\n+  union {\n+    size_t _data;    \/\/ Provides access to _fields as a single integral value.\n+    Fields _fields;\n+  };\n+  \/\/ _data must be able to hold combined _fields. Must be equal to ensure\n+  \/\/ there isn't any padding that could be uninitialized by 2-arg ctor.\n+  static_assert(sizeof(_data) == sizeof(_fields));\n+};\n+\n+\/\/ Support for Atomic<TaskQueueAge>.\n+template<>\n+struct PrimitiveConversions::Translate<TaskQueueAge> : public std::true_type {\n+  using Value = TaskQueueAge;\n+  using Decayed = decltype(TaskQueueAge::_data);\n+\n+  static Decayed decay(Value x) { return x._data; }\n+  static Value recover(Decayed x) { return Value(x); }\n+};\n+\n@@ -108,3 +152,3 @@\n-  \/\/ Internal type for indexing the queue; also used for the tag.\n-  typedef NOT_LP64(uint16_t) LP64_ONLY(uint32_t) idx_t;\n-  STATIC_ASSERT(N == idx_t(N)); \/\/ Ensure N fits in an idx_t.\n+  using Age = TaskQueueAge;\n+  using idx_t = Age::idx_t;\n+  static_assert(N == idx_t(N)); \/\/ Ensure N fits in an idx_t.\n@@ -114,2 +158,2 @@\n-  STATIC_ASSERT(N >= 2);\n-  STATIC_ASSERT(is_power_of_2(N));\n+  static_assert(N >= 2);\n+  static_assert(is_power_of_2(N));\n@@ -118,24 +162,0 @@\n-  class Age {\n-    friend class TaskQueueSuper;\n-\n-  public:\n-    explicit Age(size_t data = 0) : _data(data) {}\n-    Age(idx_t top, idx_t tag) { _fields._top = top; _fields._tag = tag; }\n-\n-    idx_t top() const { return _fields._top; }\n-    idx_t tag() const { return _fields._tag; }\n-\n-    bool operator ==(const Age& other) const { return _data == other._data; }\n-\n-  private:\n-    struct fields {\n-      idx_t _top;\n-      idx_t _tag;\n-    };\n-    union {\n-      size_t _data;\n-      fields _fields;\n-    };\n-    STATIC_ASSERT(sizeof(size_t) >= sizeof(fields));\n-  };\n-\n@@ -143,1 +163,1 @@\n-    return AtomicAccess::load(&_bottom);\n+    return _bottom.load_relaxed();\n@@ -147,1 +167,1 @@\n-    return AtomicAccess::load_acquire(&_bottom);\n+    return _bottom.load_acquire();\n@@ -151,1 +171,1 @@\n-    AtomicAccess::store(&_bottom, new_bottom);\n+    _bottom.store_relaxed(new_bottom);\n@@ -155,1 +175,1 @@\n-    AtomicAccess::release_store(&_bottom, new_bottom);\n+    _bottom.release_store(new_bottom);\n@@ -159,1 +179,1 @@\n-    return Age(AtomicAccess::load(&_age._data));\n+    return _age.load_relaxed();\n@@ -163,1 +183,1 @@\n-    AtomicAccess::store(&_age._data, new_age._data);\n+    _age.store_relaxed(new_age);\n@@ -167,1 +187,1 @@\n-    return Age(AtomicAccess::cmpxchg(&_age._data, old_age._data, new_age._data));\n+    return _age.compare_exchange(old_age, new_age);\n@@ -171,2 +191,1 @@\n-    \/\/ Atomically accessing a subfield of an \"atomic\" member.\n-    return AtomicAccess::load(&_age._fields._top);\n+    return _age.load_relaxed().top();\n@@ -225,2 +244,2 @@\n-  volatile uint _bottom;\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(uint));\n+  Atomic<uint> _bottom;\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(_bottom));\n@@ -233,2 +252,2 @@\n-  volatile Age _age;\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(Age));\n+  Atomic<Age> _age;\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(_age));\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":62,"deletions":43,"binary":false,"changes":105,"status":"modified"}]}