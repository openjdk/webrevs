{"files":[{"patch":"@@ -45,1 +45,6 @@\n-            \"unusedResult\", \"repeatedlyUnused\", \"unusedResultAfterLoopOpt1\", \"unusedResultAfterLoopOpt2\"})\n+            \"unusedResult\",\n+            \"repeatedlyUnused\",\n+            \"unusedResultAfterLoopOpt1\",\n+            \"unusedResultAfterLoopOpt2\",\n+            \"unusedResultAfterLoopOpt3\",\n+    })\n@@ -57,0 +62,1 @@\n+        Asserts.assertEQ(unusedResultAfterLoopOpt3(1.1d, 2.2d), 0.d);\n@@ -142,0 +148,4 @@\n+    \/\/ The difference between unusedResultAfterLoopOpt1 and unusedResultAfterLoopOpt2\n+    \/\/ is that they exercise a slightly different reason why the node is being removed,\n+    \/\/ and thus a different execution path. In unusedResultAfterLoopOpt1 the modulo is\n+    \/\/ used in the traps of the parse predicate. In unusedResultAfterLoopOpt2, it is not.\n@@ -164,1 +174,1 @@\n-    @IR(counts = {IRNode.MOD_D, \"2\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_CLOOPS)\n@@ -167,0 +177,20 @@\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        double unused = x % y;\n+\n+        if (b == 78) { \/\/ dead\n+            return unused;\n+        }\n+        return 0.d;\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.MOD_D, \"2\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.PHASEIDEALLOOP1)\n+    public double unusedResultAfterLoopOpt3(double x, double y) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModDNodeTests.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,1 +45,6 @@\n-            \"unusedResult\", \"repeatedlyUnused\", \"unusedResultAfterLoopOpt1\", \"unusedResultAfterLoopOpt2\"})\n+            \"unusedResult\",\n+            \"repeatedlyUnused\",\n+            \"unusedResultAfterLoopOpt1\",\n+            \"unusedResultAfterLoopOpt2\",\n+            \"unusedResultAfterLoopOpt3\",\n+    })\n@@ -57,0 +62,1 @@\n+        Asserts.assertEQ(unusedResultAfterLoopOpt3(1.1f, 2.2f), 0.f);\n@@ -142,0 +148,4 @@\n+    \/\/ The difference between unusedResultAfterLoopOpt1 and unusedResultAfterLoopOpt2\n+    \/\/ is that they exercise a slightly different reason why the node is being removed,\n+    \/\/ and thus a different execution path. In unusedResultAfterLoopOpt1 the modulo is\n+    \/\/ used in the traps of the parse predicate. In unusedResultAfterLoopOpt2, it is not.\n@@ -162,0 +172,20 @@\n+    @Test\n+    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.PHASEIDEALLOOP1)\n+    public float unusedResultAfterLoopOpt2(float x, float y) {\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        float unused = x % y;\n+\n+        if (b == 78) { \/\/ dead\n+            return unused;\n+        }\n+        return 0.f;\n+    }\n+\n@@ -166,1 +196,1 @@\n-    public float unusedResultAfterLoopOpt2(float x, float y) {\n+    public float unusedResultAfterLoopOpt3(float x, float y) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModFNodeTests.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"}]}