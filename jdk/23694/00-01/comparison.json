{"files":[{"patch":"@@ -1518,0 +1518,1 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -1519,3 +1520,3 @@\n-  Node* dummy_node = remove(phase);\n-  if (dummy_node != nullptr) {\n-    return dummy_node;\n+  bool result_is_ignored = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  if (result_is_ignored) {\n+    return replace_with_con(igvn, TypeF::make(0.));\n@@ -1543,1 +1544,1 @@\n-    return replace_with_con(phase, t1);\n+    return replace_with_con(igvn, t1);\n@@ -1546,1 +1547,1 @@\n-    return replace_with_con(phase, t2);\n+    return replace_with_con(igvn, t2);\n@@ -1561,1 +1562,1 @@\n-  return replace_with_con(phase, TypeF::make(jfloat_cast(xr)));\n+  return replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n@@ -1568,0 +1569,1 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -1569,3 +1571,3 @@\n-  Node* dummy_node = remove(phase);\n-  if (dummy_node != nullptr) {\n-    return dummy_node;\n+  bool result_is_ignored = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  if (result_is_ignored) {\n+    return replace_with_con(igvn, TypeD::make(0.));\n@@ -1593,1 +1595,1 @@\n-    return replace_with_con(phase, t1);\n+    return replace_with_con(igvn, t1);\n@@ -1596,1 +1598,1 @@\n-    return replace_with_con(phase, t2);\n+    return replace_with_con(igvn, t2);\n@@ -1611,1 +1613,1 @@\n-  return replace_with_con(phase, TypeD::make(jdouble_cast(xr)));\n+  return replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n@@ -1614,1 +1616,1 @@\n-Node* ModFloatingNode::replace_with_con(PhaseGVN* phase, const Type* con) {\n+Node* ModFloatingNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n@@ -1619,1 +1621,1 @@\n-  C->gvn_replace_by(projs.fallthrough_proj, in(TypeFunc::Control));\n+  phase->replace_node(projs.fallthrough_proj, in(TypeFunc::Control));\n@@ -1621,1 +1623,1 @@\n-    C->gvn_replace_by(projs.fallthrough_catchproj, in(TypeFunc::Control));\n+    phase->replace_node(projs.fallthrough_catchproj, in(TypeFunc::Control));\n@@ -1624,1 +1626,1 @@\n-    C->gvn_replace_by(projs.fallthrough_memproj, in(TypeFunc::Memory));\n+    phase->replace_node(projs.fallthrough_memproj, in(TypeFunc::Memory));\n@@ -1627,1 +1629,1 @@\n-    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+    phase->replace_node(projs.catchall_memproj, C->top());\n@@ -1630,1 +1632,1 @@\n-    C->gvn_replace_by(projs.fallthrough_ioproj, in(TypeFunc::I_O));\n+    phase->replace_node(projs.fallthrough_ioproj, in(TypeFunc::I_O));\n@@ -1635,1 +1637,1 @@\n-    C->gvn_replace_by(projs.resproj, con_node);\n+    phase->replace_node(projs.resproj, con_node);\n@@ -1637,1 +1639,1 @@\n-  C->gvn_replace_by(this, C->top());\n+  phase->replace_node(this, C->top());\n@@ -1643,23 +1645,0 @@\n-\/\/ Will remove the node if the result is not used, rewiring input to output directly.\n-\/\/ Returns a dummy constant node if removal happens, and nullptr if nothing is changed.\n-Node* ModFloatingNode::remove(PhaseGVN* phase) {\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-  bool result_is_ignored = proj_out_or_null(TypeFunc::Parms) == nullptr;\n-  if (igvn != nullptr && result_is_ignored) {\n-    int projections[] = {\n-        TypeFunc::Control,\n-        TypeFunc::I_O,\n-        TypeFunc::Memory,\n-        TypeFunc::FramePtr,\n-        TypeFunc::ReturnAdr,\n-    };\n-    for (int projection : projections) {\n-      if (proj_out_or_null(projection) != nullptr) {\n-        igvn->replace_node(proj_out(projection), in(projection));\n-      }\n-    }\n-    return new ConINode(TypeInt::ZERO);\n-  }\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -161,2 +161,1 @@\n-  Node* replace_with_con(PhaseGVN* phase, const Type* con);\n-  Node* remove(PhaseGVN* phase);\n+  Node* replace_with_con(PhaseIterGVN* phase, const Type* con);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}