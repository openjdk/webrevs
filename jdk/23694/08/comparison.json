{"files":[{"patch":"@@ -439,0 +439,3 @@\n+        if (child->is_data_proj_of_pure_function(n)) {\n+          worklist.push(n);\n+        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1518,0 +1518,6 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  if (result_is_unused) {\n+    return replace_with_con(igvn, TypeF::make(0.));\n+  }\n@@ -1538,1 +1544,1 @@\n-    return replace_with_con(phase, t1);\n+    return replace_with_con(igvn, t1);\n@@ -1541,1 +1547,1 @@\n-    return replace_with_con(phase, t2);\n+    return replace_with_con(igvn, t2);\n@@ -1556,1 +1562,1 @@\n-  return replace_with_con(phase, TypeF::make(jfloat_cast(xr)));\n+  return replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n@@ -1563,0 +1569,6 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  if (result_is_unused) {\n+    return replace_with_con(igvn, TypeD::make(0.));\n+  }\n@@ -1583,1 +1595,1 @@\n-    return replace_with_con(phase, t1);\n+    return replace_with_con(igvn, t1);\n@@ -1586,1 +1598,1 @@\n-    return replace_with_con(phase, t2);\n+    return replace_with_con(igvn, t2);\n@@ -1601,1 +1613,1 @@\n-  return replace_with_con(phase, TypeD::make(jdouble_cast(xr)));\n+  return replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n@@ -1604,1 +1616,1 @@\n-Node* ModFloatingNode::replace_with_con(PhaseGVN* phase, const Type* con) {\n+Node* ModFloatingNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n@@ -1609,1 +1621,1 @@\n-  C->gvn_replace_by(projs.fallthrough_proj, in(TypeFunc::Control));\n+  phase->replace_node(projs.fallthrough_proj, in(TypeFunc::Control));\n@@ -1611,1 +1623,1 @@\n-    C->gvn_replace_by(projs.fallthrough_catchproj, in(TypeFunc::Control));\n+    phase->replace_node(projs.fallthrough_catchproj, in(TypeFunc::Control));\n@@ -1614,1 +1626,1 @@\n-    C->gvn_replace_by(projs.fallthrough_memproj, in(TypeFunc::Memory));\n+    phase->replace_node(projs.fallthrough_memproj, in(TypeFunc::Memory));\n@@ -1617,1 +1629,1 @@\n-    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+    phase->replace_node(projs.catchall_memproj, C->top());\n@@ -1620,1 +1632,1 @@\n-    C->gvn_replace_by(projs.fallthrough_ioproj, in(TypeFunc::I_O));\n+    phase->replace_node(projs.fallthrough_ioproj, in(TypeFunc::I_O));\n@@ -1625,1 +1637,1 @@\n-    C->gvn_replace_by(projs.resproj, con_node);\n+    phase->replace_node(projs.resproj, con_node);\n@@ -1627,1 +1639,1 @@\n-  C->gvn_replace_by(this, C->top());\n+  phase->replace_node(this, C->top());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  Node* replace_with_con(PhaseGVN* phase, const Type* con);\n+  Node* replace_with_con(PhaseIterGVN* phase, const Type* con);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1455,0 +1455,2 @@\n+          } else if (dead->is_data_proj_of_pure_function(n)) {\n+            igvn->_worklist.push(n);\n@@ -2934,0 +2936,19 @@\n+bool Node::is_pure_function() const {\n+  switch (Opcode()) {\n+  case Op_ModD:\n+  case Op_ModF:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+\/\/ `maybe_pure_function` is assumed to be the input of `this`. This is a bit redundant,\n+\/\/ but we already have and need maybe_pure_function in all the call sites, so\n+\/\/ it makes it obvious that the `maybe_pure_function` is the same node as in the caller,\n+\/\/ while it takes more thinking to realize that a locally computed in(0) must be equal to\n+\/\/ the local in the caller.\n+bool Node::is_data_proj_of_pure_function(const Node* maybe_pure_function) const {\n+  return Opcode() == Op_Proj && as_Proj()->_con == TypeFunc::Parms && maybe_pure_function->is_pure_function();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1284,0 +1284,4 @@\n+  bool is_pure_function() const;\n+\n+  bool is_data_proj_of_pure_function(const Node* maybe_pure_function) const;\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1345,0 +1345,2 @@\n+            } else if (dead->is_data_proj_of_pure_function(in)) {\n+              _worklist.push(in);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,7 @@\n-    @Run(test = {\"constant\", \"notConstant\", \"veryNotConstant\"})\n+    @Run(test = {\"constant\", \"notConstant\", \"veryNotConstant\",\n+            \"unusedResult\",\n+            \"repeatedlyUnused\",\n+            \"unusedResultAfterLoopOpt1\",\n+            \"unusedResultAfterLoopOpt2\",\n+            \"unusedResultAfterLoopOpt3\",\n+    })\n@@ -52,0 +58,5 @@\n+        unusedResult(1.1d, 2.2d);\n+        repeatedlyUnused(1.1d, 2.2d);\n+        Asserts.assertEQ(unusedResultAfterLoopOpt1(1.1d, 2.2d), 0.d);\n+        Asserts.assertEQ(unusedResultAfterLoopOpt2(1.1d, 2.2d), 0.d);\n+        Asserts.assertEQ(unusedResultAfterLoopOpt3(1.1d, 2.2d), 0.d);\n@@ -117,0 +128,76 @@\n+\n+    @Test\n+    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.ITER_GVN1)\n+    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    public void unusedResult(double x, double y) {\n+        double unused = x % y;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.ITER_GVN1)\n+    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    public void repeatedlyUnused(double x, double y) {\n+        double unused = 1.d;\n+        for (int i = 0; i < 100_000; i++) {\n+            unused = x % y;\n+        }\n+    }\n+\n+    \/\/ The difference between unusedResultAfterLoopOpt1 and unusedResultAfterLoopOpt2\n+    \/\/ is that they exercise a slightly different reason why the node is being removed,\n+    \/\/ and thus a different execution path. In unusedResultAfterLoopOpt1 the modulo is\n+    \/\/ used in the traps of the parse predicates. In unusedResultAfterLoopOpt2, it is not.\n+    @Test\n+    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.ITER_GVN2)\n+    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    public double unusedResultAfterLoopOpt1(double x, double y) {\n+        double unused = x % y;\n+\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        if (b == 78) { \/\/ dead\n+            return unused;\n+        }\n+        return 0.d;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_D, \"1\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.PHASEIDEALLOOP1)\n+    public double unusedResultAfterLoopOpt2(double x, double y) {\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        double unused = x % y;\n+\n+        if (b == 78) { \/\/ dead\n+            return unused;\n+        }\n+        return 0.d;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_D, \"2\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(failOn = IRNode.MOD_D, phase = CompilePhase.PHASEIDEALLOOP1)\n+    public double unusedResultAfterLoopOpt3(double x, double y) {\n+        double unused = x % y;\n+\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        int other = (b - 77) * (int)(x % y % 1.d);\n+        return (double)other;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModDNodeTests.java","additions":88,"deletions":1,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -44,1 +44,7 @@\n-    @Run(test = {\"constant\", \"notConstant\", \"veryNotConstant\"})\n+    @Run(test = {\"constant\", \"notConstant\", \"veryNotConstant\",\n+            \"unusedResult\",\n+            \"repeatedlyUnused\",\n+            \"unusedResultAfterLoopOpt1\",\n+            \"unusedResultAfterLoopOpt2\",\n+            \"unusedResultAfterLoopOpt3\",\n+    })\n@@ -52,0 +58,5 @@\n+        unusedResult(1.1f, 2.2f);\n+        repeatedlyUnused(1.1f, 2.2f);\n+        Asserts.assertEQ(unusedResultAfterLoopOpt1(1.1f, 2.2f), 0.f);\n+        Asserts.assertEQ(unusedResultAfterLoopOpt2(1.1f, 2.2f), 0.f);\n+        Asserts.assertEQ(unusedResultAfterLoopOpt3(1.1f, 2.2f), 0.f);\n@@ -117,0 +128,76 @@\n+\n+    @Test\n+    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.ITER_GVN1)\n+    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    public void unusedResult(float x, float y) {\n+        float unused = x % y;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.ITER_GVN1)\n+    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    public void repeatedlyUnused(float x, float y) {\n+        float unused = 1.f;\n+        for (int i = 0; i < 100_000; i++) {\n+            unused = x % y;\n+        }\n+    }\n+\n+    \/\/ The difference between unusedResultAfterLoopOpt1 and unusedResultAfterLoopOpt2\n+    \/\/ is that they exercise a slightly different reason why the node is being removed,\n+    \/\/ and thus a different execution path. In unusedResultAfterLoopOpt1 the modulo is\n+    \/\/ used in the traps of the parse predicates. In unusedResultAfterLoopOpt2, it is not.\n+    @Test\n+    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.ITER_GVN2)\n+    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    public float unusedResultAfterLoopOpt1(float x, float y) {\n+        float unused = x % y;\n+\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        if (b == 78) { \/\/ dead\n+            return unused;\n+        }\n+        return 0.f;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_F, \"1\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.PHASEIDEALLOOP1)\n+    public float unusedResultAfterLoopOpt2(float x, float y) {\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        float unused = x % y;\n+\n+        if (b == 78) { \/\/ dead\n+            return unused;\n+        }\n+        return 0.f;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_F, \"2\"}, phase = CompilePhase.AFTER_CLOOPS)\n+    @IR(failOn = IRNode.MOD_F, phase = CompilePhase.PHASEIDEALLOOP1)\n+    public float unusedResultAfterLoopOpt3(float x, float y) {\n+        float unused = x % y;\n+\n+        int a = 77;\n+        int b = 0;\n+        do {\n+            a--;\n+            b++;\n+        } while (a > 0);\n+\n+        int other = (b - 77) * (int)(x % y % 1.f);\n+        return (float)other;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModFNodeTests.java","additions":88,"deletions":1,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2534,0 +2534,10 @@\n+    public static final String MOD_F = PREFIX + \"MOD_F\" + POSTFIX;\n+    static {\n+        macroNodes(MOD_F, \"ModF\");\n+    }\n+\n+    public static final String MOD_D = PREFIX + \"MOD_D\" + POSTFIX;\n+    static {\n+        macroNodes(MOD_D, \"ModD\");\n+    }\n+\n@@ -2579,0 +2589,10 @@\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases up to and including {@link CompilePhase#BEFORE_MACRO_EXPANSION}.\n+     *\/\n+    private static void macroNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.BEFORE_MACRO_EXPANSION, regex,\n+                                                                          CompilePhase.BEFORE_STRINGOPTS,\n+                                                                          CompilePhase.BEFORE_MACRO_EXPANSION));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}