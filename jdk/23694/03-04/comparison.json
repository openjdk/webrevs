{"files":[{"patch":"@@ -439,1 +439,1 @@\n-        if (child->Opcode() == Op_Proj && static_cast<ProjNode*>(child)->_con == TypeFunc::Parms && n->is_pure_function()) {\n+        if (child->is_data_proj_of_pure_function(n)) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1455,1 +1455,1 @@\n-          } else if (dead->Opcode() == Op_Proj && static_cast<ProjNode*>(dead)->_con == TypeFunc::Parms && n->is_pure_function()) {\n+          } else if (dead->is_data_proj_of_pure_function(n)) {\n@@ -2946,0 +2946,9 @@\n+\/\/ `maybe_pure_function` is assumed to be the input of `this`. This is a bit redundant,\n+\/\/ but we already have and need maybe_pure_function in all the call sites, so\n+\/\/ it makes obvious that the `maybe_pure_function` is the same node as in the caller,\n+\/\/ while it takes more thinking to realize that a locally computed in(0) must be equal to\n+\/\/ the local in the caller.\n+bool Node::is_data_proj_of_pure_function(const Node* maybe_pure_function) const {\n+  return Opcode() == Op_Proj && static_cast<const ProjNode*>(this)->_con == TypeFunc::Parms && maybe_pure_function->is_pure_function();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1286,0 +1286,2 @@\n+  bool is_data_proj_of_pure_function(const Node* maybe_pure_function) const;\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1345,1 +1345,1 @@\n-            } else if (dead->Opcode() == Op_Proj && static_cast<ProjNode*>(dead)->_con == TypeFunc::Parms && in->is_pure_function()) {\n+            } else if (dead->is_data_proj_of_pure_function(in)) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}