{"files":[{"patch":"@@ -178,1 +178,7 @@\n-  _local_table->get(thread, lookup, rmg);\n+  bool rehash_warning = false;\n+  _local_table->get(thread, lookup, rmg, &rehash_warning);\n+  if (rehash_warning) {\n+    \/\/ if load factor is low but we need to rehash that's a problem with the hash function.\n+    log_info(membername, table)(\"Rehash warning, load factor %g\", get_load_factor());\n+    trigger_concurrent_work();\n+  }\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,5 @@\n- * @run main\/othervm\/manual -Xmx256m -XX:MaxMetaspaceSize=256m ResolvedMethodTableHash 200000\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver ResolvedMethodTableHash\n@@ -38,2 +42,5 @@\n-\/\/ The test generates thousands MethodHandles to the methods of the same name\n-\/\/ and the same signature. This should not take too long, unless Method hash\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/\/ The test generates a thousand MethodHandles to the methods of the same name\n+\/\/ and the same signature. The rehash warning shouldn't be returned, unless Method hash\n@@ -41,1 +48,1 @@\n-public class ResolvedMethodTableHash extends ClassLoader {\n+public class ResolvedMethodTableHash {\n@@ -43,7 +50,8 @@\n-    \/\/ Generate a MethodHandle for ClassName.m()\n-    private MethodHandle generate(String className) throws ReflectiveOperationException {\n-        byte[] buf = new byte[100];\n-        int size = writeClass(buf, className);\n-        Class<?> cls = defineClass(null, buf, 0, size);\n-        return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n-    }\n+    public static class ResolvedMethodTableHashTest extends ClassLoader {\n+        \/\/ Generate a MethodHandle for ClassName.m()\n+        private MethodHandle generate(String className) throws ReflectiveOperationException {\n+            byte[] buf = new byte[100];\n+            int size = writeClass(buf, className);\n+            Class<?> cls = defineClass(null, buf, 0, size);\n+            return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n+        }\n@@ -51,7 +59,7 @@\n-    private MethodHandle generateWithSameName() throws ReflectiveOperationException {\n-        byte[] buf = new byte[100];\n-        int size = writeClass(buf, \"MH$$\");\n-        \/\/ use different classloader instances to load the classes with the same name\n-        Class<?> cls = new ResolvedMethodTableHash().defineClass(null, buf, 0, size);\n-        return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n-    }\n+        private MethodHandle generateWithSameName() throws ReflectiveOperationException {\n+            byte[] buf = new byte[100];\n+            int size = writeClass(buf, \"MH$$\");\n+            \/\/ use different classloader instances to load the classes with the same name\n+            Class<?> cls = new ResolvedMethodTableHashTest().defineClass(null, buf, 0, size);\n+            return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n+        }\n@@ -59,7 +67,7 @@\n-    \/\/ Produce a class file with the given name and a single method:\n-    \/\/     public static native void m();\n-    private int writeClass(byte[] buf, String className) {\n-        return ByteBuffer.wrap(buf)\n-                .putInt(0xCAFEBABE)       \/\/ magic\n-                .putInt(50)               \/\/ version: 50\n-                .putShort((short) 7)      \/\/ constant_pool_count: 7\n+        \/\/ Produce a class file with the given name and a single method:\n+        \/\/         public static native void m();\n+        private int writeClass(byte[] buf, String className) {\n+            return ByteBuffer.wrap(buf)\n+                .putInt(0xCAFEBABE)           \/\/ magic\n+                .putInt(50)                           \/\/ version: 50\n+                .putShort((short) 7)          \/\/ constant_pool_count: 7\n@@ -73,5 +81,5 @@\n-                .putShort((short) 1)      \/\/ this_class: #1\n-                .putShort((short) 3)      \/\/ super_class: #3\n-                .putShort((short) 0)      \/\/ interfaces_count: 0\n-                .putShort((short) 0)      \/\/ fields_count: 0\n-                .putShort((short) 1)      \/\/ methods_count: 1\n+                .putShort((short) 1)          \/\/ this_class: #1\n+                .putShort((short) 3)          \/\/ super_class: #3\n+                .putShort((short) 0)          \/\/ interfaces_count: 0\n+                .putShort((short) 0)          \/\/ fields_count: 0\n+                .putShort((short) 1)          \/\/ methods_count: 1\n@@ -79,4 +87,4 @@\n-                .putShort((short) 5)      \/\/   name_index: #5\n-                .putShort((short) 6)      \/\/   descriptor_index: #6\n-                .putShort((short) 0)      \/\/   attributes_count: 0\n-                .putShort((short) 0)      \/\/ attributes_count: 0\n+                .putShort((short) 5)          \/\/   name_index: #5\n+                .putShort((short) 6)          \/\/   descriptor_index: #6\n+                .putShort((short) 0)          \/\/   attributes_count: 0\n+                .putShort((short) 0)          \/\/ attributes_count: 0\n@@ -84,1 +92,1 @@\n-    }\n+        }\n@@ -86,3 +94,1 @@\n-    public static void main(String[] args) throws Exception {\n-        ResolvedMethodTableHash generator = new ResolvedMethodTableHash();\n-        List<MethodHandle> handles = new ArrayList<>();\n+        public static void main(String[] args) throws Exception {\n@@ -90,1 +96,2 @@\n-        int count = args.length > 0 ? Integer.parseInt(args[0]) : 200000;\n+            ResolvedMethodTableHashTest generator = new ResolvedMethodTableHashTest();\n+            List<MethodHandle> handles = new ArrayList<>();\n@@ -92,9 +99,12 @@\n-        for (int i = 0; i < count; i++) {\n-            \/\/ prevents metaspace oom\n-            if (i % 20 != 0) {\n-                handles.add(generator.generate(\"MH$\" + i));\n-            } else {\n-                handles.add(generator.generateWithSameName());\n-            }\n-            if (i % 1000 == 0) {\n-                System.out.println(\"Generated \" + i + \" handles\");\n+            int count = 1001;\n+\n+            for (int i = 0; i < count; i++) {\n+                \/\/ prevents metaspace oom\n+                if (i % 20 != 0) {\n+                    handles.add(generator.generate(\"MH$\" + i));\n+                } else {\n+                    handles.add(generator.generateWithSameName());\n+                }\n+                if (i % 1000 == 0) {\n+                    System.out.println(\"Generated \" + i + \" handles\");\n+                }\n@@ -102,0 +112,2 @@\n+\n+            System.out.println(\"Test passed\");\n@@ -103,0 +115,3 @@\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n@@ -104,1 +119,7 @@\n-        System.out.println(\"Test passed\");\n+        \/\/ Running the table with only 1000 entries should not provoke a needs rehash warning, unless the hash code is bad.\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:membername+table\",\n+                                                                             ResolvedMethodTableHashTest.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"[membername,table] Rehash warning, load factor\");\n+        output.shouldContain(\"Generated 1000 handles\");\n+        output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/MemberName\/ResolvedMethodTableHash.java","additions":71,"deletions":50,"binary":false,"changes":121,"status":"modified"}]}