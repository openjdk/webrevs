{"files":[{"patch":"@@ -178,1 +178,7 @@\n-  _local_table->get(thread, lookup, rmg);\n+  bool rehash_warning = false;\n+  _local_table->get(thread, lookup, rmg, &rehash_warning);\n+  if (rehash_warning) {\n+    \/\/ if load factor is low but we need to rehash that's a problem with the hash function.\n+    log_info(membername, table)(\"Rehash warning, load factor %g\", get_load_factor());\n+    trigger_concurrent_work();\n+  }\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,5 @@\n- * @run main\/othervm\/manual -Xmx256m -XX:MaxMetaspaceSize=256m ResolvedMethodTableHash 200000\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver ResolvedMethodTableHash\n@@ -38,2 +42,5 @@\n-\/\/ The test generates thousands MethodHandles to the methods of the same name\n-\/\/ and the same signature. This should not take too long, unless Method hash\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/\/ The test generates a thousand MethodHandles to the methods of the same name\n+\/\/ and the same signature. The rehash warning shouldn't be returned, unless Method hash\n@@ -41,1 +48,1 @@\n-public class ResolvedMethodTableHash extends ClassLoader {\n+public class ResolvedMethodTableHash {\n@@ -43,7 +50,8 @@\n-    \/\/ Generate a MethodHandle for ClassName.m()\n-    private MethodHandle generate(String className) throws ReflectiveOperationException {\n-        byte[] buf = new byte[100];\n-        int size = writeClass(buf, className);\n-        Class<?> cls = defineClass(null, buf, 0, size);\n-        return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n-    }\n+    public static class ResolvedMethodTableHashTest extends ClassLoader {\n+        \/\/ Generate a MethodHandle for ClassName.m()\n+        private MethodHandle generate(String className) throws ReflectiveOperationException {\n+                byte[] buf = new byte[100];\n+                int size = writeClass(buf, className);\n+                Class<?> cls = defineClass(null, buf, 0, size);\n+                return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n+        }\n@@ -51,7 +59,7 @@\n-    private MethodHandle generateWithSameName() throws ReflectiveOperationException {\n-        byte[] buf = new byte[100];\n-        int size = writeClass(buf, \"MH$$\");\n-        \/\/ use different classloader instances to load the classes with the same name\n-        Class<?> cls = new ResolvedMethodTableHash().defineClass(null, buf, 0, size);\n-        return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n-    }\n+        private MethodHandle generateWithSameName() throws ReflectiveOperationException {\n+                byte[] buf = new byte[100];\n+                int size = writeClass(buf, \"MH$$\");\n+                \/\/ use different classloader instances to load the classes with the same name\n+                Class<?> cls = new ResolvedMethodTableHashTest().defineClass(null, buf, 0, size);\n+                return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n+        }\n@@ -59,26 +67,26 @@\n-    \/\/ Produce a class file with the given name and a single method:\n-    \/\/     public static native void m();\n-    private int writeClass(byte[] buf, String className) {\n-        return ByteBuffer.wrap(buf)\n-                .putInt(0xCAFEBABE)       \/\/ magic\n-                .putInt(50)               \/\/ version: 50\n-                .putShort((short) 7)      \/\/ constant_pool_count: 7\n-                .put((byte) 7).putShort((short) 2)\n-                .put((byte) 1).putShort((short) className.length()).put(className.getBytes())\n-                .put((byte) 7).putShort((short) 4)\n-                .put((byte) 1).putShort((short) 16).put(\"java\/lang\/Object\".getBytes())\n-                .put((byte) 1).putShort((short) 1).put(\"m\".getBytes())\n-                .put((byte) 1).putShort((short) 3).put(\"()V\".getBytes())\n-                .putShort((short) 0x21)   \/\/ access_flags: public super\n-                .putShort((short) 1)      \/\/ this_class: #1\n-                .putShort((short) 3)      \/\/ super_class: #3\n-                .putShort((short) 0)      \/\/ interfaces_count: 0\n-                .putShort((short) 0)      \/\/ fields_count: 0\n-                .putShort((short) 1)      \/\/ methods_count: 1\n-                .putShort((short) 0x109)  \/\/   access_flags: public static native\n-                .putShort((short) 5)      \/\/   name_index: #5\n-                .putShort((short) 6)      \/\/   descriptor_index: #6\n-                .putShort((short) 0)      \/\/   attributes_count: 0\n-                .putShort((short) 0)      \/\/ attributes_count: 0\n-                .position();\n-    }\n+        \/\/ Produce a class file with the given name and a single method:\n+        \/\/         public static native void m();\n+        private int writeClass(byte[] buf, String className) {\n+                return ByteBuffer.wrap(buf)\n+                                .putInt(0xCAFEBABE)           \/\/ magic\n+                                .putInt(50)                           \/\/ version: 50\n+                                .putShort((short) 7)          \/\/ constant_pool_count: 7\n+                                .put((byte) 7).putShort((short) 2)\n+                                .put((byte) 1).putShort((short) className.length()).put(className.getBytes())\n+                                .put((byte) 7).putShort((short) 4)\n+                                .put((byte) 1).putShort((short) 16).put(\"java\/lang\/Object\".getBytes())\n+                                .put((byte) 1).putShort((short) 1).put(\"m\".getBytes())\n+                                .put((byte) 1).putShort((short) 3).put(\"()V\".getBytes())\n+                                .putShort((short) 0x21)   \/\/ access_flags: public super\n+                                .putShort((short) 1)          \/\/ this_class: #1\n+                                .putShort((short) 3)          \/\/ super_class: #3\n+                                .putShort((short) 0)          \/\/ interfaces_count: 0\n+                                .putShort((short) 0)          \/\/ fields_count: 0\n+                                .putShort((short) 1)          \/\/ methods_count: 1\n+                                .putShort((short) 0x109)  \/\/   access_flags: public static native\n+                                .putShort((short) 5)          \/\/   name_index: #5\n+                                .putShort((short) 6)          \/\/   descriptor_index: #6\n+                                .putShort((short) 0)          \/\/   attributes_count: 0\n+                                .putShort((short) 0)          \/\/ attributes_count: 0\n+                                .position();\n+        }\n@@ -86,3 +94,6 @@\n-    public static void main(String[] args) throws Exception {\n-        ResolvedMethodTableHash generator = new ResolvedMethodTableHash();\n-        List<MethodHandle> handles = new ArrayList<>();\n+        public static void main(String[] args) throws Exception {\n+\n+                ResolvedMethodTableHashTest generator = new ResolvedMethodTableHashTest();\n+                List<MethodHandle> handles = new ArrayList<>();\n+\n+                int count = args.length > 0 ? Integer.parseInt(args[0]) : 200000;\n@@ -90,1 +101,11 @@\n-        int count = args.length > 0 ? Integer.parseInt(args[0]) : 200000;\n+                for (int i = 0; i < count; i++) {\n+                        \/\/ prevents metaspace oom\n+                        if (i % 20 != 0) {\n+                                handles.add(generator.generate(\"MH$\" + i));\n+                        } else {\n+                                handles.add(generator.generateWithSameName());\n+                        }\n+                        if (i % 1000 == 0) {\n+                                System.out.println(\"Generated \" + i + \" handles\");\n+                        }\n+                }\n@@ -92,10 +113,1 @@\n-        for (int i = 0; i < count; i++) {\n-            \/\/ prevents metaspace oom\n-            if (i % 20 != 0) {\n-                handles.add(generator.generate(\"MH$\" + i));\n-            } else {\n-                handles.add(generator.generateWithSameName());\n-            }\n-            if (i % 1000 == 0) {\n-                System.out.println(\"Generated \" + i + \" handles\");\n-            }\n+                System.out.println(\"Test passed\");\n@@ -103,0 +115,3 @@\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n@@ -104,1 +119,7 @@\n-        System.out.println(\"Test passed\");\n+        \/\/ Running the table with only 1000 entries should not provoke a needs rehash warning, unless the hash code is bad.\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:membername+table\",\n+                                                                             ResolvedMethodTableHashTest.class.getName(), \"1001\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"[membername,table] Rehash warning, load factor\");\n+        output.shouldContain(\"Generated 1000 handles\");\n+        output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/MemberName\/ResolvedMethodTableHash.java","additions":81,"deletions":60,"binary":false,"changes":141,"status":"modified"}]}