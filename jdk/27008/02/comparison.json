{"files":[{"patch":"@@ -1018,1 +1018,2 @@\n-        if (loadNumberData(locale) instanceof Object[] d &&\n+        \/\/ `locale` was once nullable, need to check before loading locale data\n+        if (locale != null && loadNumberData(locale) instanceof Object[] d &&\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366401\n+ * @summary Check serialization of DecimalFormatSymbols. That is, ensure the\n+ *          behavior for each stream version is correct during de-serialization.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED DFSSerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class DFSSerializationTest {\n+\n+    @Nested\n+    class VersionTests {\n+\n+        \/\/ Ensure correct monetarySeparator and exponential field defaults\n+        \/\/ Reads monetary from decimal, and sets exponential to 'E'\n+        @Test\n+        public void version0Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(0)\n+                    .set(\"monetarySeparator\", '~')\n+                    .set(\"exponential\", 'Z')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Check exponential is set to proper default 'E', not 'Z'\n+            assertEquals('E', readField(dfs, \"exponential\"));\n+            \/\/ Ensure that mSep is based on dSep, and is not '~'\n+            assertNotEquals('~', dfs.getMonetaryDecimalSeparator());\n+            assertEquals(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator());\n+        }\n+\n+        \/\/ Version 1 did not have a locale field, and it defaulted to Locale.ROOT.\n+        \/\/ Note that other versions did allow a locale field, which was nullable.\n+        \/\/ E.g. see nullableLocaleTest which does not set locale when it is `null`\n+        @Test\n+        public void version1Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(1)\n+                    .set(\"locale\", null)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(Locale.ROOT, dfs.getLocale());\n+        }\n+\n+        \/\/ Version 2 did not have an exponential separator, and created it via exponent\n+        \/\/ char field.\n+        @Test\n+        public void version2Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(2)\n+                    .set(\"exponentialSeparator\", null)\n+                    .set(\"exponential\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(\"~\", dfs.getExponentSeparator());\n+        }\n+\n+        \/\/ Version 3 didn't have perMillText, percentText, and minusSignText.\n+        \/\/ These were created from the corresponding char equivalents.\n+        @Test\n+        public void version3Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(3)\n+                    .set(\"perMillText\", null)\n+                    .set(\"percentText\", null)\n+                    .set(\"minusSignText\", null)\n+                    .set(\"perMill\", '~')\n+                    .set(\"percent\", '~')\n+                    .set(\"minusSign\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Need to check these String fields using reflection, since they\n+            \/\/ are not exposed via the public API\n+            assertEquals(\"~\", readField(dfs, \"perMillText\"));\n+            assertEquals(\"~\", readField(dfs, \"percentText\"));\n+            assertEquals(\"~\", readField(dfs, \"minusSignText\"));\n+        }\n+\n+        \/\/ Version 4 did not have monetaryGroupingSeparator. It should be based\n+        \/\/ off of groupingSeparator.\n+        @Test\n+        public void version4Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(4)\n+                    .set(\"monetaryGroupingSeparator\", 'Z')\n+                    .set(\"groupingSeparator\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator());\n+        }\n+    }\n+\n+    \/\/ Up-to-date DFS stream versions do not expect a null locale since the public\n+    \/\/ API forbids it. However, this was not always the case and previous stream\n+    \/\/ versions can contain a null locale. Thus, ensure that a null locale does\n+    \/\/ not cause number data loading to fail.\n+    @Test\n+    public void nullableLocaleTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"locale\", null)\n+                .set(\"minusSignText\", \"zFoo\")\n+                .set(\"minusSign\", 'z') \/\/ Set so that char\/String forms agree\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertNull(dfs.getLocale());\n+        \/\/ LMS should be based off of minusSignText when locale is null\n+        assertEquals(\"zFoo\", readField(dfs, \"lenientMinusSigns\"));\n+    }\n+\n+    \/\/ readObject fails when the {@code char} and {@code String} representations\n+    \/\/ of percent, per mille, and\/or minus sign disagree.\n+    @Test\n+    public void disagreeingTextTest() {\n+        var expected = \"'char' and 'String' representations of either percent, \" +\n+                \"per mille, and\/or minus sign disagree.\";\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"minusSignText\", \"Z\")\n+                        .set(\"minusSign\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"perMillText\", \"Z\")\n+                        .set(\"perMill\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"percentText\", \"Z\")\n+                        .set(\"percent\", 'X')\n+                        .build()))).getMessage());\n+    }\n+\n+    \/\/ Ensure the serial version is updated to the current after de-serialization.\n+    @Test\n+    public void updatedVersionTest() {\n+        var bytes = ser(new DFSBuilder().setVer(-25).build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(5, readField(dfs, \"serialVersionOnStream\"));\n+    }\n+\n+    \/\/ Should set currency from 4217 code when it is valid.\n+    @Test\n+    public void validIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder().set(\"intlCurrencySymbol\", \"JPY\").build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(Currency.getInstance(\"JPY\"), dfs.getCurrency());\n+    }\n+\n+    \/\/ Should not set currency when 4217 code is invalid, it remains null.\n+    @Test\n+    public void invalidIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"intlCurrencySymbol\", \">.,\")\n+                .set(\"locale\", Locale.JAPAN)\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        \/\/ Can not init off invalid 4217 code, remains null\n+        assertNull(dfs.getCurrency());\n+    }\n+\n+\/\/ Utilities ----\n+\n+    \/\/ Utility to serialize\n+    private static byte[] ser(Object obj) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                 ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream)) {\n+                oos.writeObject(obj);\n+                return byteArrayOutputStream.toByteArray();\n+            }\n+        }, \"Unexpected error during serialization\");\n+    }\n+\n+    \/\/ Utility to deserialize\n+    private static DecimalFormatSymbols deSer(byte[] bytes) throws IOException, ClassNotFoundException {\n+        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+             ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream)) {\n+            return (DecimalFormatSymbols) ois.readObject();\n+        }\n+    }\n+\n+    \/\/ Utility to read a private field\n+    private static Object readField(DecimalFormatSymbols dfs, String name) {\n+        return assertDoesNotThrow(() -> {\n+            var field = DecimalFormatSymbols.class.getDeclaredField(name);\n+            field.setAccessible(true);\n+            return field.get(dfs);\n+        }, \"Unexpected error during field reading\");\n+    }\n+\n+    \/\/ Utility class to build instances of DFS via reflection\n+    private static class DFSBuilder {\n+\n+        private final DecimalFormatSymbols dfs;\n+\n+        private DFSBuilder() {\n+            dfs = new DecimalFormatSymbols();\n+        }\n+\n+        private DFSBuilder setVer(Object value) {\n+            return set(\"serialVersionOnStream\", value);\n+        }\n+\n+        private DFSBuilder set(String field, Object value) {\n+            return assertDoesNotThrow(() -> {\n+                Field f = dfs.getClass().getDeclaredField(field);\n+                f.setAccessible(true);\n+                f.set(dfs, value);\n+                return this;\n+            }, \"Unexpected error during reflection setting\");\n+        }\n+\n+        private DecimalFormatSymbols build() {\n+            return dfs;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DFSSerializationTest.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"}]}