{"files":[{"patch":"@@ -99,0 +99,6 @@\n+\n+  Node* minmax = Ideal_minmax(phase, this);\n+  if (minmax != nullptr) {\n+    return minmax;\n+  }\n+\n@@ -189,2 +195,9 @@\n-static Node* is_minmax(PhaseGVN* phase, Node* cmov) {\n-  BoolNode* bol = cmov->in(CMoveNode::Condition)->isa_Bool();\n+Node* CMoveNode::Ideal_minmax(PhaseGVN* phase, CMoveNode* cmove) {\n+  \/\/ If we're post loop opts then don't attempt to match the min\/max pattern, as this node might have been a\n+  \/\/ MinL or MaxL that was already expanded during macro expansion.\n+  if (phase->C->post_loop_opts_phase()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ The BoolNode may have been idealized into a constant. If that's the case, then Identity should take care of it instead.\n+  BoolNode* bol = cmove->in(CMoveNode::Condition)->isa_Bool();\n@@ -196,1 +209,2 @@\n-  int opcode = cmp->Opcode();\n+  int cmove_op = cmove->Opcode();\n+  int cmp_op = cmp->Opcode();\n@@ -198,2 +212,2 @@\n-  \/\/ Ensure comparison is an integral type\n-  if (opcode != Op_CmpI && opcode != Op_CmpL) {\n+  \/\/ Ensure comparison is an integral type, and that the cmove is of the same type.\n+  if ((cmp_op != Op_CmpI || cmove_op != Op_CMoveI) && (cmp_op != Op_CmpL || cmove_op != Op_CMoveL)) {\n@@ -214,2 +228,2 @@\n-  Node* cmov_l = cmov->in(CMoveNode::IfTrue);\n-  Node* cmov_r = cmov->in(CMoveNode::IfFalse);\n+  Node* cmove_l = cmove->in(CMoveNode::IfTrue);\n+  Node* cmove_r = cmove->in(CMoveNode::IfFalse);\n@@ -219,1 +233,1 @@\n-  \/\/ comparison and cmov are the same, resulting in a minimum. For the second form, the lhs and rhs of both are flipped,\n+  \/\/ comparison and cmove are the same, resulting in a minimum. For the second form, the lhs and rhs of both are flipped,\n@@ -223,1 +237,1 @@\n-  if (cmp_l == cmov_l && cmp_r == cmov_r) {\n+  if (cmp_l == cmove_l && cmp_r == cmove_r) {\n@@ -225,1 +239,1 @@\n-  } else if (cmp_l == cmov_r && cmp_r == cmov_l) {\n+  } else if (cmp_l == cmove_r && cmp_r == cmove_l) {\n@@ -232,1 +246,1 @@\n-  if (opcode == Op_CmpL) {\n+  if (cmp_op == Op_CmpL) {\n@@ -262,5 +276,0 @@\n-  Node* minmax = is_minmax(phase, this);\n-  if (minmax != nullptr) {\n-    return minmax;\n-  }\n-\n@@ -311,21 +320,0 @@\n-Node* CMoveLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Try generic ideal first\n-  Node* x = CMoveNode::Ideal(phase, can_reshape);\n-  if (x != nullptr) {\n-    return x;\n-  }\n-\n-  \/\/ If we're post loop opts then don't attempt to match the min\/max pattern, as this node might have been a\n-  \/\/ MinL or MaxL that was already expanded during macro expansion.\n-  if (phase->C->post_loop_opts_phase()) {\n-    return nullptr;\n-  }\n-\n-  Node* minmax = is_minmax(phase, this);\n-  if (minmax != nullptr) {\n-    return minmax;\n-  }\n-\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":25,"deletions":37,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-  static Node *is_cmove_id( PhaseTransform *phase, Node *cmp, Node *t, Node *f, BoolNode *b );\n+  static Node* is_cmove_id(PhaseTransform* phase, Node* cmp, Node* t, Node* f, BoolNode* b);\n+  static Node* Ideal_minmax(PhaseGVN* phase, CMoveNode* cmov);\n@@ -84,1 +85,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n@@ -100,1 +100,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n@@ -106,1 +106,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n@@ -112,1 +112,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n@@ -118,1 +118,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n@@ -124,1 +124,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n@@ -130,1 +130,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n@@ -136,1 +136,1 @@\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -410,5 +410,0 @@\n-    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n-   }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}