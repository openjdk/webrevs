{"files":[{"patch":"@@ -1083,1 +1083,1 @@\n-static Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1091,0 +1091,8 @@\n+Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+  if (is_max) {\n+    return new MaxLNode(phase->C, a, b);\n+  } else {\n+    return new MinLNode(phase->C, a, b);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+\n+  static Node* build_min_max_int(Node* a, Node* b, bool is_max);\n+  static Node* build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1796,2 +1796,0 @@\n-  int false_path = 3 - true_path;\n-  bool is_min = false;\n@@ -1799,1 +1797,0 @@\n-  bool is_long = opcode == Op_CmpL;\n@@ -1802,7 +1799,1 @@\n-  if (opcode == Op_CmpI || opcode == Op_CmpL) {\n-    int test = bol->_test._test;\n-    \/\/ Only accept canonicalized le and lt comparisons\n-    if (test != BoolTest::le && test != BoolTest::lt) {\n-      return nullptr;\n-    }\n-  } else {\n+  if (opcode != Op_CmpI && opcode != Op_CmpL) {\n@@ -1812,0 +1803,9 @@\n+  \/\/ Only accept canonicalized le and lt comparisons\n+  int test = bol->_test._test;\n+  if (test != BoolTest::le && test != BoolTest::lt) {\n+    return nullptr;\n+  }\n+\n+  int false_path = 3 - true_path;\n+\n+  \/\/ The values being compared\n@@ -1815,7 +1815,15 @@\n-  \/\/ Identify which path would result in a minimum being created for \"a < b ? a : b\" and \"a < b ? b : a\"\n-  \/\/ If neither structure is found, exit\n-  int min_path;\n-  if ((cmp_true == phi_root->in(true_path)) && (cmp_false == phi_root->in(false_path))) {\n-    min_path = 1;\n-  } else if (cmp_true == phi_root->in(false_path) && cmp_false == phi_root->in(true_path)) {\n-    min_path = 2;\n+  \/\/ The values being selected\n+  Node* phi_true = phi_root->in(true_path);\n+  Node* phi_false = phi_root->in(false_path);\n+\n+  \/\/ For this transformation to be valid, the values being compared must be the same as the values being selected.\n+  \/\/ We accept two different forms, \"a < b ? a : b\", and \"a < b ? b : a\". For the first form, the comparison is a minimum\n+  \/\/ if 'a' (true_path == 1) is selected when the comparison is true. If 'b' (true_path == 2) is selected when it is true,\n+  \/\/ the comparison will be a maximum. For the second form, as the order of the selected values is swapped, the selected\n+  \/\/ paths must also be swapped, so the path to choose maximum is 2 instead of 1. If neither form is found, bail out.\n+\n+  int max_path;\n+  if (cmp_true == phi_true && cmp_false == phi_false) {\n+    max_path = 2;\n+  } else if (cmp_true == phi_false && cmp_false == phi_true) {\n+    max_path = 1;\n@@ -1826,4 +1834,0 @@\n-  if (true_path == min_path) {\n-    is_min = true;\n-  }\n-\n@@ -1831,6 +1835,2 @@\n-  if (is_long) {\n-    if (is_min) {\n-      return new MinLNode(phase->C, cmp_true, cmp_false);\n-    } else {\n-      return new MaxLNode(phase->C, cmp_true, cmp_false);\n-    }\n+  if (opcode == Op_CmpL) {\n+    return MaxNode::build_min_max_long(phase, cmp_true, cmp_false, true_path == max_path);\n@@ -1838,5 +1838,1 @@\n-    if (is_min) {\n-      return new MinINode(cmp_true, cmp_false);\n-    } else {\n-      return new MaxINode(cmp_true, cmp_false);\n-    }\n+    return MaxNode::build_min_max_int(cmp_true, cmp_false, true_path == max_path);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"}]}