{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1782,0 +1782,56 @@\n+static Node* is_minmax(PhaseGVN* phase, PhiNode* phi_root, int true_path) {\n+  assert(true_path != 0, \"only diamond shape graph expected\");\n+\n+  BoolNode* bol = phi_root->in(0)->in(1)->in(0)->in(1)->as_Bool();\n+  Node* cmp = bol->in(1);\n+\n+  int false_path = 3 - true_path;\n+  bool is_min = false;\n+  int opcode = cmp->Opcode();\n+  bool is_long = opcode == Op_CmpL;\n+\n+  \/\/ Ensure comparison is an integral type\n+  if (opcode == Op_CmpI || opcode == Op_CmpL) {\n+    int test = bol->_test._test;\n+    \/\/ Only accept canonicalized le and lt comparisons\n+    if (test != BoolTest::le && test != BoolTest::lt) {\n+      return nullptr;\n+    }\n+  } else {\n+    return nullptr;\n+  }\n+\n+  Node* cmp_true = cmp->in(true_path);\n+  Node* cmp_false = cmp->in(false_path);\n+\n+  \/\/ Identify which path would result in a minimum being created for \"a < b ? a : b\" and \"a < b ? b : a\"\n+  \/\/ If neither structure is found, exit\n+  int min_path;\n+  if ((cmp_true == phi_root->in(true_path)) && (cmp_false == phi_root->in(false_path))) {\n+    min_path = 1;\n+  } else if (cmp_true == phi_root->in(false_path) && cmp_false == phi_root->in(true_path)) {\n+    min_path = 2;\n+  } else {\n+    return nullptr;\n+  }\n+\n+  if (true_path == min_path) {\n+    is_min = true;\n+  }\n+\n+  \/\/ Create the Min\/Max node based on the type and kind\n+  if (is_long) {\n+    if (is_min) {\n+      return new MinLNode(phase->C, cmp_true, cmp_false);\n+    } else {\n+      return new MaxLNode(phase->C, cmp_true, cmp_false);\n+    }\n+  } else {\n+    if (is_min) {\n+      return new MinINode(cmp_true, cmp_false);\n+    } else {\n+      return new MaxINode(cmp_true, cmp_false);\n+    }\n+  }\n+}\n+\n@@ -2223,1 +2279,1 @@\n-    if( unsafe_id != nullptr && is_unsafe_data_reference(unsafe_id) )\n+    if (unsafe_id != nullptr && is_unsafe_data_reference(unsafe_id)) {\n@@ -2225,0 +2281,1 @@\n+    }\n@@ -2227,1 +2284,1 @@\n-    if( opt == nullptr )\n+    if (opt == nullptr) {\n@@ -2229,0 +2286,1 @@\n+    }\n@@ -2231,1 +2289,1 @@\n-    if( opt == nullptr )\n+    if (opt == nullptr) {\n@@ -2233,0 +2291,6 @@\n+    }\n+\n+    \/\/ Check for min\/max patterns\n+    if (opt == nullptr) {\n+      opt = is_minmax(phase, this, true_path);\n+    }\n@@ -2235,1 +2299,1 @@\n-    if( opt == nullptr && can_reshape )\n+    if (opt == nullptr && can_reshape) {\n@@ -2237,0 +2301,1 @@\n+    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":70,"deletions":5,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8324655\n+ * @summary Test that if expressions are properly folded into min\/max nodes\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestIfMinMax\n+ *\/\n+public class TestIfMinMax {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1(int a, int b) {\n+      return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2(int a, int b) {\n+      return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1(int a, int b) {\n+      return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2(int a, int b) {\n+      return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1E(int a, int b) {\n+      return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2E(int a, int b) {\n+      return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1E(int a, int b) {\n+      return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2E(int a, int b) {\n+      return a <= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL1(long a, long b) {\n+      return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL2(long a, long b) {\n+      return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL1(long a, long b) {\n+      return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL2(long a, long b) {\n+      return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL1E(long a, long b) {\n+      return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL2E(long a, long b) {\n+      return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL1E(long a, long b) {\n+      return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL2E(long a, long b) {\n+      return a <= b ? b : a;\n+    }\n+\n+    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\" })\n+    public void runTestIntegers() {\n+        testIntegers(10, 20);\n+        testIntegers(20, 10);\n+        testIntegers(10, 10);\n+        testIntegers(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testIntegers(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testIntegers(RANDOM.nextInt(), RANDOM.nextInt());\n+    }\n+\n+    @DontCompile\n+    public void testIntegers(int a, int b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinI1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinI2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxI1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxI2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinI1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinI2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxI1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxI2E(a, b));\n+\n+    }\n+\n+    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\" })\n+    public void runTestLongs() {\n+        testLongs(10, 20);\n+        testLongs(20, 10);\n+        testLongs(10, 10);\n+        testLongs(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testLongs(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testLongs(Long.MAX_VALUE, Long.MIN_VALUE);\n+        testLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n+        testLongs(RANDOM.nextLong(), RANDOM.nextLong());\n+    }\n+\n+    @DontCompile\n+    public void testLongs(long a, long b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinL1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinL2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxL1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxL2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinL1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinL2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxL1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxL2E(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,0 +405,5 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+   }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class IfMinMax {\n+    private static final int SIZE = 300;\n+\n+    @Benchmark\n+    public void testSingleInt(Blackhole blackhole, BenchState state) {\n+        blackhole.consume(state.i1[0] > state.i2[0] ? state.i1[0] : state.i2[0]);\n+    }\n+\n+    @Benchmark\n+    public void testVectorInt(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.i3[i] = state.i1[i] > state.i2[i] ? state.i1[i] : state.i2[i];\n+        }\n+\n+        blackhole.consume(state.i3);\n+    }\n+\n+    @Benchmark\n+    public void testReductionInt(Blackhole blackhole, BenchState state) {\n+        int a = 0;\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (state.i1[i] > a) {\n+                a = state.i1[i];\n+            }\n+        }\n+\n+        blackhole.consume(a);\n+    }\n+\n+    @Benchmark\n+    public void testSingleLong(Blackhole blackhole, BenchState state) {\n+        blackhole.consume(state.l1[0] > state.l2[0] ? state.l1[0] : state.l2[0]);\n+    }\n+\n+    @Benchmark\n+    public void testVectorLong(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.l3[i] = state.l1[i] > state.l2[i] ? state.l1[i] : state.l2[i];\n+        }\n+\n+        blackhole.consume(state.l3);\n+    }\n+\n+    @Benchmark\n+    public void testReductionLong(Blackhole blackhole, BenchState state) {\n+        long a = 0;\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (state.l1[i] > a) {\n+                a = state.l1[i];\n+            }\n+        }\n+\n+        blackhole.consume(a);\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        private final int[] i1 = new int[SIZE];\n+        private final int[] i2 = new int[SIZE];\n+        private final int[] i3 = new int[SIZE];\n+\n+        private final long[] l1 = new long[SIZE];\n+        private final long[] l2 = new long[SIZE];\n+        private final long[] l3 = new long[SIZE];\n+\n+        public BenchState() {\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            Random random = new Random(1000);\n+            for (int i = 0; i < SIZE; i++) {\n+                i1[i] = random.nextInt();\n+                i2[i] = random.nextInt();\n+                i3[i] = random.nextInt();\n+\n+                l1[i] = random.nextLong();\n+                l2[i] = random.nextLong();\n+                l3[i] = random.nextLong();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IfMinMax.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}