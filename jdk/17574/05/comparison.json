{"files":[{"patch":"@@ -1083,1 +1083,1 @@\n-static Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1091,0 +1091,8 @@\n+Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+  if (is_max) {\n+    return new MaxLNode(phase->C, a, b);\n+  } else {\n+    return new MinLNode(phase->C, a, b);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+\n+  static Node* build_min_max_int(Node* a, Node* b, bool is_max);\n+  static Node* build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,51 @@\n+\/\/ Try to identify min\/max patterns in CMoves\n+static Node* is_minmax(PhaseGVN* phase, Node* cmov) {\n+  BoolNode* bol = cmov->in(CMoveNode::Condition)->isa_Bool();\n+  if (bol == nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* cmp = bol->in(1);\n+  int opcode = cmp->Opcode();\n+\n+  \/\/ Ensure comparison is an integral type\n+  if (opcode != Op_CmpI && opcode != Op_CmpL) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Only accept canonicalized le and lt comparisons\n+  int test = bol->_test._test;\n+  if (test != BoolTest::le && test != BoolTest::lt) {\n+    return nullptr;\n+  }\n+\n+  \/\/ The values being compared\n+  Node* cmp_l = cmp->in(1);\n+  Node* cmp_r = cmp->in(2);\n+\n+  \/\/ The values being selected\n+  Node* cmov_l = cmov->in(CMoveNode::IfTrue);\n+  Node* cmov_r = cmov->in(CMoveNode::IfFalse);\n+\n+  \/\/ For this transformation to be valid, the values being compared must be the same as the values being selected.\n+  \/\/ We accept two different forms, \"a < b ? a : b\" and \"a < b ? b : a\". For the first form, the lhs and rhs of the\n+  \/\/ comparison and cmov are the same, resulting in a minimum. For the second form, the lhs and rhs of both are flipped,\n+  \/\/ resulting in a maximum. If neither form is found, bail out.\n+\n+  bool is_max;\n+  if (cmp_l == cmov_l && cmp_r == cmov_r) {\n+    is_max = false;\n+  } else if (cmp_l == cmov_r && cmp_r == cmov_l) {\n+    is_max = true;\n+  } else {\n+    return nullptr;\n+  }\n+\n+  \/\/ Create the Min\/Max node based on the type and kind\n+  if (opcode == Op_CmpL) {\n+    return MaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n+  } else {\n+    return MaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n+  }\n+}\n+\n@@ -211,0 +262,5 @@\n+  Node* minmax = is_minmax(phase, this);\n+  if (minmax != nullptr) {\n+    return minmax;\n+  }\n+\n@@ -255,0 +311,21 @@\n+Node* CMoveLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Try generic ideal first\n+  Node* x = CMoveNode::Ideal(phase, can_reshape);\n+  if (x != nullptr) {\n+    return x;\n+  }\n+\n+  \/\/ If we're post loop opts then don't attempt to match the min\/max pattern, as this node might have been a\n+  \/\/ MinL or MaxL that was already expanded during macro expansion.\n+  if (phase->C->post_loop_opts_phase()) {\n+    return nullptr;\n+  }\n+\n+  Node* minmax = is_minmax(phase, this);\n+  if (minmax != nullptr) {\n+    return minmax;\n+  }\n+\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8324655\n+ * @summary Test that if expressions are properly folded into min\/max nodes\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIfMinMax\n+ *\/\n+public class TestIfMinMax {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1(int a, int b) {\n+        return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2(int a, int b) {\n+        return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1(int a, int b) {\n+        return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2(int a, int b) {\n+        return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1E(int a, int b) {\n+        return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2E(int a, int b) {\n+        return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1E(int a, int b) {\n+        return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2E(int a, int b) {\n+        return a <= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL1(long a, long b) {\n+        return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL2(long a, long b) {\n+        return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL1(long a, long b) {\n+        return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL2(long a, long b) {\n+        return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL1E(long a, long b) {\n+        return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMinL2E(long a, long b) {\n+        return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL1E(long a, long b) {\n+        return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.CMOVE_L, \"1\" })\n+    public long testMaxL2E(long a, long b) {\n+        return a <= b ? b : a;\n+    }\n+\n+    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\" })\n+    public void runTestIntegers() {\n+        testIntegers(10, 20);\n+        testIntegers(20, 10);\n+        testIntegers(10, 10);\n+        testIntegers(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testIntegers(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testIntegers(RANDOM.nextInt(), RANDOM.nextInt());\n+    }\n+\n+    @DontCompile\n+    public void testIntegers(int a, int b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinI1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinI2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxI1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxI2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinI1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinI2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxI1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxI2E(a, b));\n+    }\n+\n+    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\" })\n+    public void runTestLongs() {\n+        testLongs(10, 20);\n+        testLongs(20, 10);\n+        testLongs(10, 10);\n+        testLongs(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testLongs(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testLongs(Long.MAX_VALUE, Long.MIN_VALUE);\n+        testLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n+        testLongs(RANDOM.nextLong(), RANDOM.nextLong());\n+    }\n+\n+    @DontCompile\n+    public void testLongs(long a, long b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinL1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinL2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxL1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxL2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinL1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinL2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxL1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxL2E(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -410,0 +410,5 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+   }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class IfMinMax {\n+    private static final int SIZE = 10_000;\n+\n+    @Benchmark\n+    public void testSingleInt(Blackhole blackhole, BenchState state) {\n+        int a = state.i1[state.random.nextInt(SIZE)];\n+        int b = state.i2[state.random.nextInt(SIZE)];\n+        blackhole.consume(a > b ? a : b);\n+    }\n+\n+    @Benchmark\n+    public void testVectorInt(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.i3[i] = state.i1[i] > state.i2[i] ? state.i1[i] : state.i2[i];\n+        }\n+\n+        blackhole.consume(state.i3);\n+    }\n+\n+    @Benchmark\n+    public void testReductionInt(Blackhole blackhole, BenchState state) {\n+        int a = 0;\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (state.i1[i] > a) {\n+                a = state.i1[i];\n+            }\n+        }\n+\n+        blackhole.consume(a);\n+    }\n+\n+    @Benchmark\n+    public void testSingleLong(Blackhole blackhole, BenchState state) {\n+        long a = state.l1[state.random.nextInt(SIZE)];\n+        long b = state.l2[state.random.nextInt(SIZE)];\n+        blackhole.consume(a > b ? a : b);\n+    }\n+\n+    @Benchmark\n+    public void testVectorLong(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < SIZE; i++) {\n+            state.l3[i] = state.l1[i] > state.l2[i] ? state.l1[i] : state.l2[i];\n+        }\n+\n+        blackhole.consume(state.l3);\n+    }\n+\n+    @Benchmark\n+    public void testReductionLong(Blackhole blackhole, BenchState state) {\n+        long a = 0;\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (state.l1[i] > a) {\n+                a = state.l1[i];\n+            }\n+        }\n+\n+        blackhole.consume(a);\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        private final int[] i1 = new int[SIZE];\n+        private final int[] i2 = new int[SIZE];\n+        private final int[] i3 = new int[SIZE];\n+\n+        private final long[] l1 = new long[SIZE];\n+        private final long[] l2 = new long[SIZE];\n+        private final long[] l3 = new long[SIZE];\n+\n+        private Random random;\n+\n+        public BenchState() {\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            this.random = new Random(1000);\n+\n+            for (int i = 0; i < SIZE; i++) {\n+                i1[i] = this.random.nextInt();\n+                i2[i] = this.random.nextInt();\n+                i3[i] = this.random.nextInt();\n+\n+                l1[i] = this.random.nextLong();\n+                l2[i] = this.random.nextLong();\n+                l3[i] = this.random.nextLong();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IfMinMax.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}