{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1782,60 +1782,0 @@\n-static Node* is_minmax(PhaseGVN* phase, PhiNode* phi_root, int true_path) {\n-  assert(true_path != 0, \"only diamond shape graph expected\");\n-\n-  Node* region = phi_root->in(0);\n-  IfNode* iff = region->in(1)->in(0)->as_If();\n-  BoolNode* bol = iff->in(1)->as_Bool();\n-  Node* cmp = bol->in(1);\n-\n-  \/\/ Don't transform if the branch is highly predictable\n-  constexpr float infrequent_prob = PROB_UNLIKELY_MAG(2);\n-  if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n-    return nullptr;\n-  }\n-\n-  int opcode = cmp->Opcode();\n-\n-  \/\/ Ensure comparison is an integral type\n-  if (opcode != Op_CmpI && opcode != Op_CmpL) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Only accept canonicalized le and lt comparisons\n-  int test = bol->_test._test;\n-  if (test != BoolTest::le && test != BoolTest::lt) {\n-    return nullptr;\n-  }\n-\n-  int false_path = 3 - true_path;\n-\n-  \/\/ The values being compared\n-  Node* cmp_true = cmp->in(true_path);\n-  Node* cmp_false = cmp->in(false_path);\n-\n-  \/\/ The values being selected\n-  Node* phi_true = phi_root->in(true_path);\n-  Node* phi_false = phi_root->in(false_path);\n-\n-  \/\/ For this transformation to be valid, the values being compared must be the same as the values being selected.\n-  \/\/ We accept two different forms, \"a < b ? a : b\", and \"a < b ? b : a\". For the first form, the comparison is a minimum\n-  \/\/ if 'a' (true_path == 1) is selected when the comparison is true. If 'b' (true_path == 2) is selected when it is true,\n-  \/\/ the comparison will be a maximum. For the second form, as the order of the selected values is swapped, the selected\n-  \/\/ paths must also be swapped, so the path to choose maximum is 2 instead of 1. If neither form is found, bail out.\n-\n-  int max_path;\n-  if (cmp_true == phi_true && cmp_false == phi_false) {\n-    max_path = 2;\n-  } else if (cmp_true == phi_false && cmp_false == phi_true) {\n-    max_path = 1;\n-  } else {\n-    return nullptr;\n-  }\n-\n-  \/\/ Create the Min\/Max node based on the type and kind\n-  if (opcode == Op_CmpL) {\n-    return MaxNode::build_min_max_long(phase, cmp_true, cmp_false, true_path == max_path);\n-  } else {\n-    return MaxNode::build_min_max_int(cmp_true, cmp_false, true_path == max_path);\n-  }\n-}\n-\n@@ -2279,1 +2219,1 @@\n-    if (unsafe_id != nullptr && is_unsafe_data_reference(unsafe_id)) {\n+    if( unsafe_id != nullptr && is_unsafe_data_reference(unsafe_id) )\n@@ -2281,1 +2221,0 @@\n-    }\n@@ -2284,1 +2223,1 @@\n-    if (opt == nullptr) {\n+    if( opt == nullptr )\n@@ -2286,1 +2225,0 @@\n-    }\n@@ -2289,1 +2227,1 @@\n-    if (opt == nullptr) {\n+    if( opt == nullptr )\n@@ -2291,6 +2229,0 @@\n-    }\n-\n-    \/\/ Check for min\/max patterns\n-    if (opt == nullptr) {\n-      opt = is_minmax(phase, this, true_path);\n-    }\n@@ -2299,1 +2231,1 @@\n-    if (opt == nullptr && can_reshape) {\n+    if( opt == nullptr && can_reshape )\n@@ -2301,1 +2233,0 @@\n-    }\n@@ -2303,1 +2234,1 @@\n-    \/\/ These optimizations could subsume the phi:\n+    \/\/ These 4 optimizations could subsume the phi:\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":6,"deletions":75,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,51 @@\n+\/\/ Try to identify min\/max patterns in CMoves\n+static Node* is_minmax(PhaseGVN* phase, Node* cmov) {\n+  BoolNode* bol = cmov->in(CMoveNode::Condition)->isa_Bool();\n+  if (bol == nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* cmp = bol->in(1);\n+  int opcode = cmp->Opcode();\n+\n+  \/\/ Ensure comparison is an integral type\n+  if (opcode != Op_CmpI && opcode != Op_CmpL) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Only accept canonicalized le and lt comparisons\n+  int test = bol->_test._test;\n+  if (test != BoolTest::le && test != BoolTest::lt) {\n+    return nullptr;\n+  }\n+\n+  \/\/ The values being compared\n+  Node* cmp_l = cmp->in(1);\n+  Node* cmp_r = cmp->in(2);\n+\n+  \/\/ The values being selected\n+  Node* cmov_l = cmov->in(CMoveNode::IfTrue);\n+  Node* cmov_r = cmov->in(CMoveNode::IfFalse);\n+\n+  \/\/ For this transformation to be valid, the values being compared must be the same as the values being selected.\n+  \/\/ We accept two different forms, \"a < b ? a : b\" and \"a < b ? b : a\". For the first form, the lhs and rhs of the\n+  \/\/ comparison and cmov are the same, resulting in a minimum. For the second form, the lhs and rhs of both are flipped,\n+  \/\/ resulting in a maximum. If neither form is found, bail out.\n+\n+  bool is_max;\n+  if (cmp_l == cmov_l && cmp_r == cmov_r) {\n+    is_max = false;\n+  } else if (cmp_l == cmov_r && cmp_r == cmov_l) {\n+    is_max = true;\n+  } else {\n+    return nullptr;\n+  }\n+\n+  \/\/ Create the Min\/Max node based on the type and kind\n+  if (opcode == Op_CmpL) {\n+    return MaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n+  } else {\n+    return MaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n+  }\n+}\n+\n@@ -211,0 +262,5 @@\n+  Node* minmax = is_minmax(phase, this);\n+  if (minmax != nullptr) {\n+    return minmax;\n+  }\n+\n@@ -255,0 +311,21 @@\n+Node* CMoveLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Try generic ideal first\n+  Node* x = CMoveNode::Ideal(phase, can_reshape);\n+  if (x != nullptr) {\n+    return x;\n+  }\n+\n+  \/\/ If we're post loop opts then don't attempt to match the min\/max pattern, as this node might have been a\n+  \/\/ MinL or MaxL that was already expanded during macro expansion.\n+  if (phase->C->post_loop_opts_phase()) {\n+    return nullptr;\n+  }\n+\n+  Node* minmax = is_minmax(phase, this);\n+  if (minmax != nullptr) {\n+    return minmax;\n+  }\n+\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}