{"files":[{"patch":"@@ -1295,1 +1295,1 @@\n-            var docTreeVisitor = new SimpleDocTreeVisitor<Boolean, Content>() {\n+            var docTreeVisitor = new InlineVisitor(element, tag, isLastNode, context, ch, trees);;\n@@ -1297,69 +1297,2 @@\n-                private boolean inAnAtag() {\n-                    return (tag instanceof StartElementTree st) && equalsIgnoreCase(st.getName(), \"a\");\n-                }\n-\n-                @Override\n-                public Boolean visitAttribute(AttributeTree node, Content content) {\n-                    if (!content.isEmpty()) {\n-                        content.add(\" \");\n-                    }\n-                    content.add(node.getName());\n-                    if (node.getValueKind() == ValueKind.EMPTY) {\n-                        return false;\n-                    }\n-                    content.add(\"=\");\n-                    String quote = switch (node.getValueKind()) {\n-                        case DOUBLE -> \"\\\"\";\n-                        case SINGLE -> \"'\";\n-                        default -> \"\";\n-                    };\n-                    content.add(quote);\n-\n-                    \/* In the following code for an attribute value:\n-                     * 1. {@docRoot} followed by text beginning \"\/..\" is replaced by the value\n-                     *    of the docrootParent option, followed by the remainder of the text\n-                     * 2. in the value of an \"href\" attribute in a <a> tag, an initial text\n-                     *    value will have a relative link redirected.\n-                     * Note that, realistically, it only makes sense to ever use {@docRoot}\n-                     * at the beginning of a URL in an attribute value, but this is not\n-                     * required or enforced.\n-                     *\/\n-                    boolean isHRef = inAnAtag() && equalsIgnoreCase(node.getName(), \"href\");\n-                    boolean first = true;\n-                    DocRootTree pendingDocRoot = null;\n-                    for (DocTree dt : node.getValue()) {\n-                        if (pendingDocRoot != null) {\n-                            if (dt instanceof TextTree tt) {\n-                                String text = tt.getBody();\n-                                if (text.startsWith(\"\/..\") && !options.docrootParent().isEmpty()) {\n-                                    content.add(options.docrootParent());\n-                                    content.add(textCleanup(text.substring(3), isLastNode));\n-                                    pendingDocRoot = null;\n-                                    continue;\n-                                }\n-                            }\n-                            pendingDocRoot.accept(this, content);\n-                            pendingDocRoot = null;\n-                        }\n-\n-                        if (dt instanceof TextTree tt) {\n-                            String text = tt.getBody();\n-                            if (first && isHRef) {\n-                                text = redirectRelativeLinks(element, tt);\n-                            }\n-                            content.add(textCleanup(text, isLastNode));\n-                        } else if (dt instanceof DocRootTree drt) {\n-                            \/\/ defer until we see what, if anything, follows this node\n-                            pendingDocRoot = drt;\n-                        } else {\n-                            dt.accept(this, content);\n-                        }\n-                        first = false;\n-                    }\n-                    if (pendingDocRoot != null) {\n-                        pendingDocRoot.accept(this, content);\n-                    }\n-\n-                    content.add(quote);\n-                    return false;\n-                }\n+            boolean allDone = docTreeVisitor.visit(tag, result);\n+            commentRemoved = false;\n@@ -1367,5 +1300,9 @@\n-                @Override\n-                public Boolean visitComment(CommentTree node, Content content) {\n-                    content.add(RawHtml.comment(node.getBody()));\n-                    return false;\n-                }\n+            if (allDone)\n+                break;\n+        }\n+        \/\/ Close any open inline tags\n+        while (!openTags.isEmpty()) {\n+            result.add(RawHtml.endElement(openTags.removeLast()));\n+        }\n+        return result;\n+    }\n@@ -1373,5 +1310,22 @@\n-                @Override\n-                public Boolean visitEndElement(EndElementTree node, Content content) {\n-                    content.add(RawHtml.endElement(node.getName()));\n-                    return false;\n-                }\n+    private class InlineVisitor extends SimpleDocTreeVisitor<Boolean, Content> {\n+        private final Element element;\n+        private final DocTree tag;\n+        private final boolean isLastNode;\n+        private final TagletWriter.Context context;\n+        private final CommentHelper ch;\n+        private final List<? extends DocTree> trees;\n+\n+        InlineVisitor(Element element,\n+                      DocTree tag,\n+                      boolean isLastNode,\n+                      TagletWriter.Context context,\n+                      CommentHelper ch,\n+                      List<? extends DocTree> trees) {\n+\n+            this.element = element;\n+            this.tag = tag;\n+            this.isLastNode = isLastNode;\n+            this.context = context;\n+            this.ch = ch;\n+            this.trees = trees;\n+        }\n@@ -1379,5 +1333,3 @@\n-                @Override\n-                public Boolean visitEntity(EntityTree node, Content content) {\n-                    content.add(Entity.of(node.getName()));\n-                    return false;\n-                }\n+        private boolean inAnAtag() {\n+            return (tag instanceof StartElementTree st) && equalsIgnoreCase(st.getName(), \"a\");\n+        }\n@@ -1385,17 +1337,38 @@\n-                @Override\n-                public Boolean visitErroneous(ErroneousTree node, Content content) {\n-                    DocTreePath dtp = ch.getDocTreePath(node);\n-                    if (dtp != null) {\n-                        String body = node.getBody();\n-                        Matcher m = Pattern.compile(\"(?i)\\\\{@([a-z]+).*\").matcher(body);\n-                        String tagName = m.matches() ? m.group(1) : null;\n-                        if (tagName == null) {\n-                            if (!configuration.isDocLintSyntaxGroupEnabled()) {\n-                                messages.warning(dtp, \"doclet.tag.invalid_input\", body);\n-                            }\n-                            content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", body),\n-                                    Optional.empty()));\n-                        } else {\n-                            messages.warning(dtp, \"doclet.tag.invalid_usage\", body);\n-                            content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n-                                    Optional.of(Text.of(body))));\n+        @Override\n+        public Boolean visitAttribute(AttributeTree node, Content content) {\n+            if (!content.isEmpty()) {\n+                content.add(\" \");\n+            }\n+            content.add(node.getName());\n+            if (node.getValueKind() == ValueKind.EMPTY) {\n+                return false;\n+            }\n+            content.add(\"=\");\n+            String quote = switch (node.getValueKind()) {\n+                case DOUBLE -> \"\\\"\";\n+                case SINGLE -> \"'\";\n+                default -> \"\";\n+            };\n+            content.add(quote);\n+\n+            \/* In the following code for an attribute value:\n+             * 1. {@docRoot} followed by text beginning \"\/..\" is replaced by the value\n+             *    of the docrootParent option, followed by the remainder of the text\n+             * 2. in the value of an \"href\" attribute in a <a> tag, an initial text\n+             *    value will have a relative link redirected.\n+             * Note that, realistically, it only makes sense to ever use {@docRoot}\n+             * at the beginning of a URL in an attribute value, but this is not\n+             * required or enforced.\n+             *\/\n+            boolean isHRef = inAnAtag() && equalsIgnoreCase(node.getName(), \"href\");\n+            boolean first = true;\n+            DocRootTree pendingDocRoot = null;\n+            for (DocTree dt : node.getValue()) {\n+                if (pendingDocRoot != null) {\n+                    if (dt instanceof TextTree tt) {\n+                        String text = tt.getBody();\n+                        if (text.startsWith(\"\/..\") && !options.docrootParent().isEmpty()) {\n+                            content.add(options.docrootParent());\n+                            content.add(textCleanup(text.substring(3), isLastNode));\n+                            pendingDocRoot = null;\n+                            continue;\n@@ -1404,1 +1377,2 @@\n-                    return false;\n+                    pendingDocRoot.accept(this, content);\n+                    pendingDocRoot = null;\n@@ -1407,4 +1381,11 @@\n-                @Override\n-                public Boolean visitEscape(EscapeTree node, Content content) {\n-                    result.add(node.getBody());\n-                    return false;\n+                if (dt instanceof TextTree tt) {\n+                    String text = tt.getBody();\n+                    if (first && isHRef) {\n+                        text = redirectRelativeLinks(element, tt);\n+                    }\n+                    content.add(textCleanup(text, isLastNode));\n+                } else if (dt instanceof DocRootTree drt) {\n+                    \/\/ defer until we see what, if anything, follows this node\n+                    pendingDocRoot = drt;\n+                } else {\n+                    dt.accept(this, content);\n@@ -1412,0 +1393,5 @@\n+                first = false;\n+            }\n+            if (pendingDocRoot != null) {\n+                pendingDocRoot.accept(this, content);\n+            }\n@@ -1413,7 +1399,3 @@\n-                @Override\n-                public Boolean visitInheritDoc(InheritDocTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    content.add(output);\n-                    \/\/ if we obtained the first sentence successfully, nothing more to do\n-                    return (context.isFirstSentence && !output.isEmpty());\n-                }\n+            content.add(quote);\n+            return false;\n+        }\n@@ -1421,13 +1403,5 @@\n-                @Override\n-                public Boolean visitStartElement(StartElementTree node, Content content) {\n-                    Content attrs = new ContentBuilder();\n-                    if (node.getName().toString().matches(\"(?i)h[1-6]\")\n-                            && isIndexable()) {\n-                        createSectionIdAndIndex(node, trees, attrs, element, context);\n-                    }\n-                    for (DocTree dt : node.getAttributes()) {\n-                        dt.accept(this, attrs);\n-                    }\n-                    content.add(RawHtml.startElement(node.getName(), attrs, node.isSelfClosing()));\n-                    return false;\n-                }\n+        @Override\n+        public Boolean visitComment(CommentTree node, Content content) {\n+            content.add(RawHtml.comment(node.getBody()));\n+            return false;\n+        }\n@@ -1435,3 +1409,5 @@\n-                private CharSequence textCleanup(String text, boolean isLast) {\n-                    return textCleanup(text, isLast, false);\n-                }\n+        @Override\n+        public Boolean visitEndElement(EndElementTree node, Content content) {\n+            content.add(RawHtml.endElement(node.getName()));\n+            return false;\n+        }\n@@ -1439,8 +1415,16 @@\n-                private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {\n-                    boolean stripTrailing = context.isFirstSentence && isLast;\n-                    if (stripLeading && stripTrailing) {\n-                        text = text.strip();\n-                    } else if (stripLeading) {\n-                        text = text.stripLeading();\n-                    } else if (stripTrailing) {\n-                        text = text.stripTrailing();\n+        @Override\n+        public Boolean visitEntity(EntityTree node, Content content) {\n+            content.add(Entity.of(node.getName()));\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitErroneous(ErroneousTree node, Content content) {\n+            DocTreePath dtp = ch.getDocTreePath(node);\n+            if (dtp != null) {\n+                String body = node.getBody();\n+                Matcher m = Pattern.compile(\"(?i)\\\\{@([a-z]+).*\").matcher(body);\n+                String tagName = m.matches() ? m.group(1) : null;\n+                if (tagName == null) {\n+                    if (!configuration.isDocLintSyntaxGroupEnabled()) {\n+                        messages.warning(dtp, \"doclet.tag.invalid_input\", body);\n@@ -1448,2 +1432,6 @@\n-                    text = utils.replaceTabs(text);\n-                    return Text.normalizeNewlines(text);\n+                    content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", body),\n+                            Optional.empty()));\n+                } else {\n+                    messages.warning(dtp, \"doclet.tag.invalid_usage\", body);\n+                    content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n+                            Optional.of(Text.of(body))));\n@@ -1451,0 +1439,3 @@\n+            }\n+            return false;\n+        }\n@@ -1452,8 +1443,5 @@\n-                @Override\n-                public Boolean visitText(TextTree node, Content content) {\n-                    String text = node.getBody();\n-                    result.add(text.startsWith(\"<![CDATA[\")\n-                            ? RawHtml.cdata(text)\n-                            : Text.of(textCleanup(text, isLastNode, commentRemoved)));\n-                    return false;\n-                }\n+        @Override\n+        public Boolean visitEscape(EscapeTree node, Content content) {\n+            content.add(node.getBody());\n+            return false;\n+        }\n@@ -1461,10 +1449,7 @@\n-                @Override\n-                protected Boolean defaultAction(DocTree node, Content content) {\n-                    if (node instanceof InlineTagTree itt) {\n-                        var output = getInlineTagOutput(element, itt, context);\n-                        if (output != null) {\n-                            content.add(output);\n-                        }\n-                    }\n-                    return false;\n-                }\n+        @Override\n+        public Boolean visitInheritDoc(InheritDocTree node, Content content) {\n+            Content output = getInlineTagOutput(element, node, context);\n+            content.add(output);\n+            \/\/ if we obtained the first sentence successfully, nothing more to do\n+            return (context.isFirstSentence && !output.isEmpty());\n+        }\n@@ -1472,1 +1457,13 @@\n-            };\n+        @Override\n+        public Boolean visitStartElement(StartElementTree node, Content content) {\n+            Content attrs = new ContentBuilder();\n+            if (node.getName().toString().matches(\"(?i)h[1-6]\")\n+                    && isIndexable()) {\n+                createSectionIdAndIndex(node, trees, attrs, element, context);\n+            }\n+            for (DocTree dt : node.getAttributes()) {\n+                dt.accept(this, attrs);\n+            }\n+            content.add(RawHtml.startElement(node.getName(), attrs, node.isSelfClosing()));\n+            return false;\n+        }\n@@ -1474,2 +1471,3 @@\n-            boolean allDone = docTreeVisitor.visit(tag, result);\n-            commentRemoved = false;\n+        private CharSequence textCleanup(String text, boolean isLast) {\n+            return textCleanup(text, isLast, false);\n+        }\n@@ -1477,2 +1475,11 @@\n-            if (allDone)\n-                break;\n+        private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {\n+            boolean stripTrailing = context.isFirstSentence && isLast;\n+            if (stripLeading && stripTrailing) {\n+                text = text.strip();\n+            } else if (stripLeading) {\n+                text = text.stripLeading();\n+            } else if (stripTrailing) {\n+                text = text.stripTrailing();\n+            }\n+            text = utils.replaceTabs(text);\n+            return Text.normalizeNewlines(text);\n@@ -1480,3 +1487,19 @@\n-        \/\/ Close any open inline tags\n-        while (!openTags.isEmpty()) {\n-            result.add(RawHtml.endElement(openTags.removeLast()));\n+\n+        @Override\n+        public Boolean visitText(TextTree node, Content content) {\n+            String text = node.getBody();\n+            content.add(text.startsWith(\"<![CDATA[\")\n+                    ? RawHtml.cdata(text)\n+                    : Text.of(textCleanup(text, isLastNode, commentRemoved)));\n+            return false;\n+        }\n+\n+        @Override\n+        protected Boolean defaultAction(DocTree node, Content content) {\n+            if (node instanceof InlineTagTree itt) {\n+                var output = getInlineTagOutput(element, itt, context);\n+                if (output != null) {\n+                    content.add(output);\n+                }\n+            }\n+            return false;\n@@ -1484,1 +1507,0 @@\n-        return result;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":189,"deletions":167,"binary":false,"changes":356,"status":"modified"}]}