{"files":[{"patch":"@@ -7841,1 +7841,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishld\" %}\n@@ -7895,1 +7895,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishst\\n\\tdmb ishld\" %}\n@@ -7899,1 +7899,2 @@\n-    __ membar(Assembler::LoadStore|Assembler::StoreStore);\n+    __ membar(Assembler::StoreStore);\n+    __ membar(Assembler::LoadStore);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-#define starti Instruction_aarch64 current_insn(this);\n+#define starti this->flush_pending(); Instruction_aarch64 current_insn(this);\n@@ -526,0 +526,11 @@\n+\n+void Assembler::dmb(barrier imm) {\n+  if (imm >= ISHLD && imm <= ISH) {\n+    \/\/ try to merge with previous dmb\n+    CodeBuffer::MergeableInst newdmb(imm);\n+    _code_section->outer()->fsm()->transition(&newdmb, this);\n+  } else {\n+    \/\/ HotSpot only use other barrier kind for test\n+    _dmb(imm);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-#define starti Instruction_aarch64 current_insn(this);\n+#define starti this->flush_pending(); Instruction_aarch64 current_insn(this);\n@@ -736,0 +736,8 @@\n+  void flush() {\n+    flush_pending();\n+    AbstractAssembler::flush();\n+  }\n+\n+  virtual int pending_size() const { return _code_section->outer()->pending_insts_size(); }\n+  virtual void flush_pending()     { _code_section->outer()->flush_pending(this); }\n+\n@@ -1125,1 +1133,3 @@\n-  void dmb(barrier imm) {\n+  void dmb(barrier imm);\n+\n+  void _dmb(barrier imm) {\n@@ -4154,2 +4164,1 @@\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code) {\n-  }\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code) { }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -86,0 +86,103 @@\n+\n+int CodeBuffer::pending_insts_size() const {\n+  return _fsm->pending_size();\n+}\n+\n+void CodeBuffer::InstructionFSM_AArch64::flush_and_reset(Assembler* assem) {\n+  if (_state == NoPending) return;\n+\n+  log_debug(jit,verify)(\"emit dmb %d\", _state);\n+  PendingState old_state = _state;\n+  _state = NoPending; \/\/ reset state for emit\n+  assert( _cs == assem->code_section(), \"mismatched code section\");\n+  assert( _offset == assem->code_section()->end() - assem->code_section()->start(), \"mismatched offset\");\n+  switch (old_state) {\n+    case PendingDmbLd:\n+      assem->_dmb(Assembler::ISHLD);\n+      break;\n+    case PendingDmbSt:\n+      assem->_dmb(Assembler::ISHST);\n+      break;\n+    case PendingDmbLdSt:\n+      assem->_dmb(Assembler::ISHLD);\n+      assem->_dmb(Assembler::ISHST);\n+      break;\n+    case PendingDmbISH:\n+      assem->_dmb(Assembler::ISH);\n+      break;\n+    case PendingDmbISH2:\n+      assem->_dmb(Assembler::ISH);\n+      assem->nop();\n+      break;\n+    case PendingLd:\n+    case PendingSt:\n+      assert(false, \"not implemented\");\n+      break;\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n+  }\n+#ifndef PRODUCT\n+  \/\/ TODO: add \"merged\" comment\n+  _merged = 0;\n+  _cs = nullptr;\n+  _offset = -1;\n+#endif\n+}\n+\n+void CodeBuffer::InstructionFSM_AArch64::transition(CodeBuffer::MergeableInst* inst, Assembler* assem) {\n+  assert(inst != nullptr, \"unexpected\");\n+  if (inst->is_dmb()) {\n+    Assembler::barrier kind = (Assembler::barrier) inst->barrier_kind();\n+    assert(kind == Assembler::ISHLD || kind == Assembler::ISHST || kind == Assembler::ISH,\n+           \"barrier kind(%d) is unexpected\", kind);\n+    PendingState new_state = (PendingState) kind;\n+    switch (_state) {\n+      case NoPending:\n+#ifndef PRODUCT\n+        _cs = assem->code_section();\n+        _offset = assem->code_section()->end() - assem->code_section()->start();\n+        _merged = 0;\n+#endif\n+        _state = new_state;\n+        break;\n+      case PendingDmbLd:\n+      case PendingDmbSt:\n+        if (_state == new_state || new_state == PendingDmbISH) {\n+          _state = new_state;\n+          DEBUG_ONLY(_merged++);\n+        } else if (AlwaysMergeDMB) {\n+          _state = PendingDmbISH;\n+          DEBUG_ONLY(_merged++);\n+        } else {\n+          _state = PendingDmbLdSt;\n+        }\n+        break;\n+      case PendingDmbISH:\n+      case PendingDmbISH2:\n+        DEBUG_ONLY(_merged++);\n+        break;\n+      case PendingDmbLdSt:\n+        assert(!AlwaysMergeDMB, \"must be\");\n+        if (new_state == PendingDmbISH) {\n+          _state = PendingDmbISH2;\n+          DEBUG_ONLY(_merged += 2);\n+        } else {\n+          DEBUG_ONLY(_merged++);\n+        }\n+        break;\n+      case PendingLd:\n+      case PendingSt:\n+        assert(false, \"not implemented\");\n+        \/\/ flush_and_reset(assem);\n+        \/\/ _state = new_state;\n+        break;\n+      default:\n+        assert(false, \"should not reach here\");\n+        break;\n+    }\n+  } else {\n+    assert(false, \"should not reach here\");\n+    return;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\/\/ for merging dmb\/ld\/st\n+class MergeableInst : public StackObj {\n@@ -30,1 +32,69 @@\n-  void pd_initialize() {}\n+  bool _is_dmb;\n+  bool _is_ld;\n+  bool _is_st;\n+  int  _barrier_kind;\n+\n+public:\n+  MergeableInst(int kind): _is_dmb(true), _is_ld(false), _is_st(false), _barrier_kind(kind) {}\n+\n+  bool is_dmb ()      const { return _is_dmb; };\n+  bool is_ld ()       const { return _is_ld; };\n+  bool is_st ()       const { return _is_st; };\n+  int barrier_kind()  const { assert(_is_dmb, \"must be\"); return _barrier_kind; }\n+};\n+\n+\/* Finite State Machine for merging instruction *\/\n+class InstructionFSM_AArch64 : public ResourceObj {\n+public:\n+  enum PendingState {\n+    NoPending,\n+    PendingDmbLd   = 0b1001, \/\/ Assembler::barrier::ISHLD,\n+    PendingDmbSt,            \/\/ Assembler::barrier::ISHST,\n+    PendingDmbISH,           \/\/ Assembler::barrier::ISH,\n+    PendingDmbLdSt,\n+    \/\/ It comes from DmbLdSt+DmbISH and will emit dmb.ish + nop,\n+    \/\/ because we need keep same size with PendingDmbLdSt\n+    PendingDmbISH2,\n+    PendingLd,\n+    PendingSt\n+  };\n+\n+private:\n+  PendingState _state;\n+#ifndef PRODUCT\n+  int          _merged;\n+  CodeSection* _cs;\n+  int          _offset;\n+#endif\n+\n+public:\n+  InstructionFSM_AArch64() {\n+    _state = NoPending;\n+#ifndef PRODUCT\n+    _merged = 0;\n+    _cs = nullptr;\n+    _offset = 0;\n+#endif\n+  }\n+\n+  ~InstructionFSM_AArch64() {}\n+\n+  \/\/ reset state, emit pending instruction\n+  void flush_and_reset(Assembler* assem);\n+\n+  \/\/ transition state with current instruction, may emit instructions\n+  void transition(MergeableInst* inst, Assembler* assem);\n+\n+  PendingState state() const { return _state; }\n+\n+  \/\/ report size of pending instructions\n+  int  pending_size() const {\n+    if (_state == NoPending) return 0;\n+    if (_state == PendingDmbLdSt || _state == PendingDmbISH2) return 8;\n+    return 4;\n+  }\n+};\n+\n+private:\n+  InstructionFSM_AArch64* _fsm;\n+  void pd_initialize() { _fsm = new InstructionFSM_AArch64(); };\n@@ -34,0 +104,4 @@\n+  \/\/ use finite state machine for merging instructions\n+  void flush_pending(Assembler* assem) { _fsm->flush_and_reset(assem); }\n+  InstructionFSM_AArch64* fsm() const  { return _fsm; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, AlwaysMergeDMB, true, DIAGNOSTIC,                      \\\n+          \"Always merge DMB instructions in code emission\")             \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2115,0 +2115,3 @@\n+  dmb(Assembler::barrier(order_constraint));\n+  return;\n+  \/*\n@@ -2119,7 +2122,22 @@\n-    \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-    \/\/ can do this simply by ORing them together.\n-    bar->set_kind(bar->get_kind() | order_constraint);\n-    BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-    dmb(Assembler::barrier(order_constraint));\n+    \/\/ Don't promote DMB ST|DMB LD to DMB (a full barrier) because\n+    \/\/ doing so would introduce a StoreLoad which the caller did not\n+    \/\/ intend\n+    if (AlwaysMergeDMB || bar->get_kind() == order_constraint\n+        || bar->get_kind() == AnyAny\n+        || order_constraint == AnyAny) {\n+      \/\/ We are merging two memory barrier instructions.  On AArch64 we\n+      \/\/ can do this simply by ORing them together.\n+      bar->set_kind(bar->get_kind() | order_constraint);\n+      BLOCK_COMMENT(\"merged membar\");\n+      return;\n+    } else if (!AlwaysMergeDMB){\n+      \/\/ A special case like \"DMB ST;DMB LD;DMB ST\", the last DMB can be skipped\n+      \/\/ We need check the last 2 instructions\n+      address prev2 = prev - NativeMembar::instruction_size;\n+      if (last != code()->last_label() && nativeInstruction_at(prev2)->is_Membar()) {\n+        NativeMembar *bar2 = NativeMembar_at(prev2);\n+        assert(bar2->get_kind() == order_constraint, \"it should be merged before\");\n+        BLOCK_COMMENT(\"merged membar\");\n+        return;\n+      }\n+    }\n@@ -2127,0 +2145,3 @@\n+  code()->set_last_insn(pc());\n+  _dmb(Assembler::barrier(order_constraint));\n+  *\/\n@@ -2130,0 +2151,1 @@\n+  Assembler::flush_pending();  \/\/ TODO: rewrite ld\/st merge with fsm\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    flush_pending();\n@@ -153,0 +154,1 @@\n+    code()->set_last_label(pc());\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,0 +233,3 @@\n+    if (FLAG_IS_DEFAULT(AlwaysMergeDMB)) {\n+      FLAG_SET_DEFAULT(AlwaysMergeDMB, false);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/arm\/codeBuffer_arm.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/ppc\/codeBuffer_ppc.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -88,0 +88,2 @@\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/s390\/codeBuffer_s390.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -32,0 +32,2 @@\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/zero\/codeBuffer_zero.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -59,0 +59,1 @@\n+  flush_pending();\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -368,2 +368,4 @@\n-  address       pc()           const   { return code_section()->end();   }\n-  int           offset()       const   { return code_section()->size();  }\n+  virtual int   pending_size() const   { return 0; }\n+  virtual void  flush_pending()        { }\n+  address       pc()           const   { return code_section()->end() + pending_size();   }\n+  int           offset()       const   { return code_section()->size() + pending_size();  }\n@@ -378,1 +380,2 @@\n-  void      set_inst_mark()       {        code_section()->set_mark();   }\n+  \/\/ void      set_inst_mark()       {        code_section()->set_mark();   }\n+  void      set_inst_mark()       {        code_section()->set_mark(pc());   }\n@@ -387,1 +390,2 @@\n-    code_section()->relocate(code_section()->end(), rspec, format);\n+    \/\/ code_section()->relocate(code_section()->end(), rspec, format);\n+    code_section()->relocate(pc(), rspec, format);\n@@ -390,1 +394,2 @@\n-    code_section()->relocate(code_section()->end(), rtype, format);\n+    \/\/ code_section()->relocate(code_section()->end(), rtype, format);\n+    code_section()->relocate(pc(), rtype, format);\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,2 +316,2 @@\n-  assert(start() <= at && at <= end()+1,\n-         \"cannot relocate data outside code boundaries\");\n+  \/\/assert(start() <= at && at <= end()+1,\n+  \/\/       \"cannot relocate data outside code boundaries\");\n@@ -933,0 +933,4 @@\n+  \/\/ some internal addresses, _last_insn _last_label, are used during code emission,\n+  \/\/ adjust them in expansion\n+  adjust_internal_address(insts_begin(), cb.insts_begin());\n+\n@@ -954,0 +958,9 @@\n+void CodeBuffer::adjust_internal_address(address from, address to) {\n+  if (_last_insn != nullptr) {\n+    _last_insn += to - from;\n+  }\n+  if (_last_label != nullptr) {\n+    _last_label += to - from;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class Assembler;\n@@ -201,1 +202,1 @@\n-  void    set_mark(address pc)      { assert(contains2(pc), \"not in codeBuffer\");\n+  void    set_mark(address pc)      { \/\/ assert(contains2(pc), \"not in codeBuffer\");\n@@ -436,0 +437,1 @@\n+  address      _last_label;     \/\/ record last bind label address, it's also the start of current bb.\n@@ -460,0 +462,1 @@\n+    _last_label      = nullptr;\n@@ -493,0 +496,1 @@\n+    pd_initialize();\n@@ -513,0 +517,3 @@\n+  \/\/ adjust some internal address during expand\n+  void adjust_internal_address(address from, address to);\n+\n@@ -523,1 +530,1 @@\n- public:\n+public:\n@@ -613,1 +620,2 @@\n-  address       insts_end() const        { return _insts.end();        }\n+  address       insts_end() const        { assert(pending_insts_size()==0, \"no pending instruction\");\n+                                           return _insts.end();        }\n@@ -622,1 +630,4 @@\n-  csize_t insts_size() const             { return _insts.size(); }\n+  csize_t insts_size() const             { return _insts.size() + pending_insts_size(); }\n+\n+  \/\/ size of pending instructions, like dmb in aarch64\n+  int pending_insts_size() const;\n@@ -682,0 +693,3 @@\n+  address last_label() const { return _last_label; }\n+  void set_last_label(address a) { _last_label = a; }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"asm\/macroAssembler.hpp\"\n@@ -55,0 +56,1 @@\n+  ResourceMark rm;\n@@ -84,0 +86,207 @@\n+static void asm_dump(address start, address end) {\n+  ResourceMark rm;\n+  stringStream ss;\n+  ss.print_cr(\"Insns:\");\n+  Disassembler::decode(start, end, &ss);\n+  printf(\"%s\\n\", ss.as_string());\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_dmb) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    \/\/ merge with same type\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ nop();\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ nop();\n+    \/\/ merge with high rank\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::AnyAny);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ nop();\n+    \/\/ merge with different type\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  \/\/ AlwaysMergeDMB\n+  static const unsigned int insns1[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+    0xd503201f, \/\/ nop\n+    0xd50339bf, \/\/ dmb.ishld\n+    0xd503201f, \/\/ nop\n+    0xd5033bbf, \/\/ dmb.ish\n+    0xd503201f, \/\/ nop\n+    0xd5033bbf, \/\/ dmb.ish\n+  };\n+  \/\/ !AlwaysMergeDMB\n+  static const unsigned int insns2[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+    0xd503201f, \/\/ nop\n+    0xd50339bf, \/\/ dmb.ishld\n+    0xd503201f, \/\/ nop\n+    0xd5033bbf, \/\/ dmb.ish\n+    0xd503201f, \/\/ nop\n+    0xd50339bf, \/\/ dmb.ishld\n+    0xd5033abf, \/\/ dmb.ishst\n+  };\n+  if (AlwaysMergeDMB) {\n+    EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns1));\n+    asm_check((const unsigned int *)code.insts()->start(), insns1, sizeof insns1 \/ sizeof insns1[0]);\n+  } else {\n+    EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns2));\n+    asm_check((const unsigned int *)code.insts()->start(), insns2, sizeof insns2 \/ sizeof insns2[0]);\n+  }\n+\n+  BufferBlob::free(b);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_dmb_block_by_label) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    Label l;\n+    \/\/ merge can not cross the label\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ bind(l);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+    0xd5033abf, \/\/ dmb.ishst\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns));\n+  asm_check((const unsigned int *)code.insts()->start(), insns, sizeof insns \/ sizeof insns[0]);\n+\n+  BufferBlob::free(b);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_dmb_after_expand) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  code.set_blob(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    code.insts()->maybe_expand_to_ensure_remaining(50000);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns));\n+  asm_check((const unsigned int *)code.insts()->start(), insns, sizeof insns \/ sizeof insns[0]);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_ldst) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    Label l;\n+    \/\/ merge ld\/st into ldp\/stp\n+    __ ldr(r0, Address(sp, 8));\n+    __ ldr(r1, Address(sp, 0));\n+    __ nop();\n+    __ str(r0, Address(sp, 0));\n+    __ str(r1, Address(sp, 8));\n+    __ nop();\n+    __ ldrw(r0, Address(sp, 0));\n+    __ ldrw(r1, Address(sp, 4));\n+    __ nop();\n+    __ strw(r0, Address(sp, 4));\n+    __ strw(r1, Address(sp, 0));\n+    __ nop();\n+    \/\/ can not merge\n+    __ ldrw(r0, Address(sp, 4));\n+    __ ldr(r1, Address(sp, 8));\n+    __ nop();\n+    __ ldrw(r0, Address(sp, 0));\n+    __ ldrw(r1, Address(sp, 8));\n+    __ nop();\n+    __ str(r0, Address(sp, 0));\n+    __ bind(l);                     \/\/ block by label\n+    __ str(r1, Address(sp, 8));\n+    __ nop();\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns1[] = {\n+    0xa94003e1, \/\/ ldp x1, x0, [sp]\n+    0xd503201f, \/\/ nop\n+    0xa90007e0, \/\/ stp x0, x1, [sp]\n+    0xd503201f, \/\/ nop\n+    0x294007e0, \/\/ ldp w0, w1, [sp]\n+    0xd503201f, \/\/ nop\n+    0x290003e1, \/\/ stp w1, w0, [sp]\n+    0xd503201f, \/\/ nop\n+    0xb94007e0, \/\/ ldr w0, [sp, 4]\n+    0xf94007e1, \/\/ ldr x1, [sp, 8]\n+    0xd503201f, \/\/ nop\n+    0xb94003e0, \/\/ ldr w0, [sp]\n+    0xb9400be1, \/\/ ldr w1, [sp, 8]\n+    0xd503201f, \/\/ nop\n+    0xf90003e0, \/\/ str x0, [sp]\n+    0xf90007e1, \/\/ str x1, [sp, 8]\n+    0xd503201f, \/\/ nop\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns1));\n+  asm_check((const unsigned int *)code.insts()->start(), insns1, sizeof insns1 \/ sizeof insns1[0]);\n+\n+  BufferBlob::free(b);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_ldst_after_expand) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  code.set_blob(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    __ ldr(r0, Address(sp, 8));\n+    code.insts()->maybe_expand_to_ensure_remaining(10000);\n+    __ ldr(r1, Address(sp, 0));\n+    __ nop();\n+    __ str(r0, Address(sp, 0));\n+    code.insts()->maybe_expand_to_ensure_remaining(100000);\n+    __ str(r1, Address(sp, 8));\n+    __ nop();\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns[] = {\n+    0xa94003e1, \/\/ ldp x1, x0, [sp]\n+    0xd503201f, \/\/ nop\n+    0xa90007e0, \/\/ stp x0, x1, [sp]\n+    0xd503201f, \/\/ nop\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns));\n+  asm_check((const unsigned int *)code.insts()->start(), insns, sizeof insns \/ sizeof insns[0]);\n+}\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/test_assembler_aarch64.cpp","additions":210,"deletions":1,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/* test allocation speed of object with final field *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class FinalFieldInitialize {\n+  final static int LEN = 100_000;\n+  Object arr[] = null;\n+  @Setup\n+  public void setup(){\n+    arr = new Object[LEN];\n+  }\n+\n+  @Benchmark\n+  public void testAlloc(Blackhole bh) {\n+    for (int i=0; i<LEN; i++) {\n+      arr[i] = new TObj();\n+    }\n+    bh.consume(arr);\n+  }\n+\n+  @Benchmark\n+  public void testAllocWithFinal(Blackhole bh) {\n+    for (int i=0; i<LEN; i++) {\n+      arr[i] = new TObjWithFinal();\n+    }\n+    bh.consume(arr);\n+  }\n+}\n+\n+class TObj {\n+  private int i;\n+  private long l;\n+  private boolean b;\n+\n+  public TObj() {\n+    i = 10;\n+    l = 100L;\n+    b = true;\n+  }\n+}\n+\n+class TObjWithFinal {\n+  private int i;\n+  private long l;\n+  private final boolean b;\n+\n+  public TObjWithFinal() {\n+    i = 10;\n+    l = 100L;\n+    b = true;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FinalFieldInitialize.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}