{"files":[{"patch":"@@ -7841,1 +7841,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishld\" %}\n@@ -7895,1 +7895,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishst\\n\\tdmb ishld\" %}\n@@ -7899,1 +7899,2 @@\n-    __ membar(Assembler::LoadStore|Assembler::StoreStore);\n+    __ membar(Assembler::StoreStore);\n+    __ membar(Assembler::LoadStore);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-#define starti Instruction_aarch64 current_insn(this);\n+#define starti this->flush_pending(); Instruction_aarch64 current_insn(this);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-#define starti Instruction_aarch64 current_insn(this);\n+#define starti this->flush_pending(); Instruction_aarch64 current_insn(this);\n@@ -736,0 +736,8 @@\n+  void flush() {\n+    flush_pending();\n+    AbstractAssembler::flush();\n+  }\n+\n+  virtual int pending_size() const { return _code_section->outer()->pending_insts_size(); }\n+  virtual void flush_pending()     { _code_section->outer()->flush_pending(this); }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,88 @@\n+\n+int CodeBuffer::pending_insts_size() const {\n+  return _fsm.pending_size();\n+}\n+\n+void CodeBuffer::InstructionFSM_AArch64::flush_and_reset(Assembler* assem) {\n+  if (_state == NoPending) return;\n+\n+  PendingState old_state = _state;\n+  _state = NoPending; \/\/ reset state for emit\n+  assert( _cs == assem->code_section(), \"mismatched code section\");\n+  assert( _offset == assem->code_section()->end() - assem->code_section()->start(), \"mismatched offset\");\n+  switch (old_state) {\n+    case PendingDmbLd:\n+      assem->dmb(Assembler::ISHLD);\n+      break;\n+    case PendingDmbSt:\n+      assem->dmb(Assembler::ISHST);\n+      break;\n+    case PendingDmbLdSt:\n+      assem->dmb(Assembler::ISHLD);\n+      assem->dmb(Assembler::ISHST);\n+      break;\n+    case PendingDmbISH:\n+      assem->dmb(Assembler::ISH);\n+      break;\n+    case PendingDmbISH2:\n+      assem->dmb(Assembler::ISH);\n+      assem->nop();\n+      break;\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n+  }\n+#ifndef PRODUCT\n+  if (_merged) {\n+    assem->block_comment(\"merged membar\");\n+  }\n+  _merged = 0;\n+  _cs = nullptr;\n+  _offset = -1;\n+#endif\n+}\n+\n+void CodeBuffer::InstructionFSM_AArch64::transition(unsigned int imm, Assembler* assem) {\n+  Assembler::barrier kind = (Assembler::barrier)imm;\n+  assert(kind == Assembler::ISHLD || kind == Assembler::ISHST || kind == Assembler::ISH,\n+         \"barrier kind(%d) is unexpected\", kind);\n+  PendingState new_state = (PendingState) kind;\n+  switch (_state) {\n+    case NoPending:\n+#ifndef PRODUCT\n+      _cs = assem->code_section();\n+      _offset = assem->code_section()->end() - assem->code_section()->start();\n+      _merged = 0;\n+#endif\n+      _state = new_state;\n+      break;\n+    case PendingDmbLd:\n+    case PendingDmbSt:\n+      if (_state == new_state || new_state == PendingDmbISH) {\n+        _state = new_state;\n+        DEBUG_ONLY(_merged++);\n+      } else if (AlwaysMergeDMB) {\n+        _state = PendingDmbISH;\n+        DEBUG_ONLY(_merged++);\n+      } else {\n+        _state = PendingDmbLdSt;\n+      }\n+      break;\n+    case PendingDmbISH:\n+    case PendingDmbISH2:\n+      DEBUG_ONLY(_merged++);\n+      break;\n+    case PendingDmbLdSt:\n+      assert(!AlwaysMergeDMB, \"must be\");\n+      if (new_state == PendingDmbISH) {\n+        _state = PendingDmbISH2;\n+        DEBUG_ONLY(_merged += 2);\n+      } else {\n+        DEBUG_ONLY(_merged++);\n+      }\n+      break;\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -29,0 +29,14 @@\n+\/* Finite State Machine for merging instruction *\/\n+class InstructionFSM_AArch64 : public ResourceObj {\n+public:\n+  enum PendingState {\n+    NoPending,\n+    PendingDmbLd   = 0b1001, \/\/ Assembler::barrier::ISHLD,\n+    PendingDmbSt,            \/\/ Assembler::barrier::ISHST,\n+    PendingDmbISH,           \/\/ Assembler::barrier::ISH,\n+    PendingDmbLdSt,\n+    \/\/ It comes from DmbLdSt+DmbISH and will emit dmb.ish + nop,\n+    \/\/ because we need keep same size with PendingDmbLdSt\n+    PendingDmbISH2,\n+  };\n+\n@@ -30,1 +44,36 @@\n-  void pd_initialize() {}\n+  PendingState _state;\n+#ifndef PRODUCT\n+  int          _merged;\n+  CodeSection* _cs;\n+  int          _offset;\n+#endif\n+\n+public:\n+  InstructionFSM_AArch64() {\n+    _state = NoPending;\n+#ifndef PRODUCT\n+    _merged = 0;\n+    _cs = nullptr;\n+    _offset = 0;\n+#endif\n+  }\n+\n+  \/\/ reset state, emit pending instruction\n+  void flush_and_reset(Assembler* assem);\n+\n+  \/\/ transition state with current instruction, may emit instructions\n+  void transition(unsigned int imm, Assembler* assem);\n+\n+  PendingState state() const { return _state; }\n+\n+  \/\/ report size of pending instructions\n+  int  pending_size() const {\n+    if (_state == NoPending) return 0;\n+    if (_state == PendingDmbLdSt || _state == PendingDmbISH2) return 8;\n+    return 4;\n+  }\n+};\n+\n+private:\n+  InstructionFSM_AArch64 _fsm;\n+  void pd_initialize() { }\n@@ -34,0 +83,4 @@\n+  \/\/ use finite state machine for merging dmb instructions\n+  void flush_pending(Assembler* assem) { _fsm.flush_and_reset(assem); }\n+  void push_dmb(unsigned int imm, Assembler* assem) { _fsm.transition(imm, assem); }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, AlwaysMergeDMB, true, DIAGNOSTIC,                      \\\n+          \"Always merge DMB instructions in code emission\")             \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2114,9 +2114,4 @@\n-void MacroAssembler::membar(Membar_mask_bits order_constraint) {\n-  address prev = pc() - NativeMembar::instruction_size;\n-  address last = code()->last_insn();\n-  if (last != nullptr && nativeInstruction_at(last)->is_Membar() && prev == last) {\n-    NativeMembar *bar = NativeMembar_at(prev);\n-    \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-    \/\/ can do this simply by ORing them together.\n-    bar->set_kind(bar->get_kind() | order_constraint);\n-    BLOCK_COMMENT(\"merged membar\");\n+void MacroAssembler::membar(Membar_mask_bits imm) {\n+  if (imm >= LoadStore && imm <= AnyAny) {\n+    \/\/ try to merge with previous dmb\n+    _code_section->outer()->push_dmb(imm, this);\n@@ -2124,2 +2119,2 @@\n-    code()->set_last_insn(pc());\n-    dmb(Assembler::barrier(order_constraint));\n+    \/\/ HotSpot only use other barrier kind for test\n+    Assembler::dmb((barrier)imm);\n@@ -2130,0 +2125,1 @@\n+  Assembler::flush_pending();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    flush_pending();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,0 +233,3 @@\n+    if (FLAG_IS_DEFAULT(AlwaysMergeDMB)) {\n+      FLAG_SET_DEFAULT(AlwaysMergeDMB, false);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/arm\/codeBuffer_arm.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/ppc\/codeBuffer_ppc.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -88,0 +88,2 @@\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/s390\/codeBuffer_s390.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -32,0 +32,2 @@\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/zero\/codeBuffer_zero.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -59,0 +59,1 @@\n+  flush_pending();\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -368,3 +368,5 @@\n-  address       pc()           const   { return code_section()->end();   }\n-  int           offset()       const   { return code_section()->size();  }\n-  int           locator()      const   { return CodeBuffer::locator(offset(), sect()); }\n+  virtual int   pending_size() const   { return 0; }\n+  virtual void  flush_pending()        { }\n+  address       pc()           const   { return code_section()->end() + pending_size();   }\n+  int           offset()               { flush_pending(); return code_section()->size();  }\n+  int           locator()              { return CodeBuffer::locator(offset(), sect()); }\n@@ -378,1 +380,1 @@\n-  void      set_inst_mark()       {        code_section()->set_mark();   }\n+  void      set_inst_mark()       {        code_section()->set_mark(pc());   }\n@@ -387,1 +389,1 @@\n-    code_section()->relocate(code_section()->end(), rspec, format);\n+    code_section()->relocate(pc(), rspec, format);\n@@ -390,1 +392,1 @@\n-    code_section()->relocate(code_section()->end(), rtype, format);\n+    code_section()->relocate(pc(), rtype, format);\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,1 +316,1 @@\n-  assert(start() <= at && at <= end()+1,\n+  assert(start() <= at && at <= end() + outer()->pending_insts_size() + 1,\n@@ -933,0 +933,4 @@\n+  \/\/ internal addresses like _last_insn is used during code emission,\n+  \/\/ adjust them in expansion\n+  adjust_internal_address(insts_begin(), cb.insts_begin());\n+\n@@ -954,0 +958,6 @@\n+void CodeBuffer::adjust_internal_address(address from, address to) {\n+  if (_last_insn != nullptr) {\n+    _last_insn += to - from;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class Assembler;\n@@ -201,1 +202,1 @@\n-  void    set_mark(address pc)      { assert(contains2(pc), \"not in codeBuffer\");\n+  void    set_mark(address pc)      { \/\/ assert(contains2(pc), \"not in codeBuffer\");\n@@ -493,0 +494,1 @@\n+    pd_initialize();\n@@ -513,0 +515,3 @@\n+  \/\/ adjust some internal address during expand\n+  void adjust_internal_address(address from, address to);\n+\n@@ -523,1 +528,1 @@\n- public:\n+public:\n@@ -613,1 +618,2 @@\n-  address       insts_end() const        { return _insts.end();        }\n+  address       insts_end() const        { assert(pending_insts_size()==0, \"no pending instruction\");\n+                                           return _insts.end();        }\n@@ -622,1 +628,4 @@\n-  csize_t insts_size() const             { return _insts.size(); }\n+  csize_t insts_size() const             { return _insts.size() + pending_insts_size(); }\n+\n+  \/\/ size of pending instructions, like dmb in aarch64\n+  int pending_insts_size() const;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"asm\/macroAssembler.hpp\"\n@@ -55,0 +56,1 @@\n+  ResourceMark rm;\n@@ -84,0 +86,207 @@\n+static void asm_dump(address start, address end) {\n+  ResourceMark rm;\n+  stringStream ss;\n+  ss.print_cr(\"Insns:\");\n+  Disassembler::decode(start, end, &ss);\n+  printf(\"%s\\n\", ss.as_string());\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_dmb) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    \/\/ merge with same type\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ nop();\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ nop();\n+    \/\/ merge with high rank\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::AnyAny);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ nop();\n+    \/\/ merge with different type\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ membar(Assembler::Membar_mask_bits::LoadStore);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  \/\/ AlwaysMergeDMB\n+  static const unsigned int insns1[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+    0xd503201f, \/\/ nop\n+    0xd50339bf, \/\/ dmb.ishld\n+    0xd503201f, \/\/ nop\n+    0xd5033bbf, \/\/ dmb.ish\n+    0xd503201f, \/\/ nop\n+    0xd5033bbf, \/\/ dmb.ish\n+  };\n+  \/\/ !AlwaysMergeDMB\n+  static const unsigned int insns2[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+    0xd503201f, \/\/ nop\n+    0xd50339bf, \/\/ dmb.ishld\n+    0xd503201f, \/\/ nop\n+    0xd5033bbf, \/\/ dmb.ish\n+    0xd503201f, \/\/ nop\n+    0xd50339bf, \/\/ dmb.ishld\n+    0xd5033abf, \/\/ dmb.ishst\n+  };\n+  if (AlwaysMergeDMB) {\n+    EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns1));\n+    asm_check((const unsigned int *)code.insts()->start(), insns1, sizeof insns1 \/ sizeof insns1[0]);\n+  } else {\n+    EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns2));\n+    asm_check((const unsigned int *)code.insts()->start(), insns2, sizeof insns2 \/ sizeof insns2[0]);\n+  }\n+\n+  BufferBlob::free(b);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_dmb_block_by_label) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    Label l;\n+    \/\/ merge can not cross the label\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ bind(l);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+    0xd5033abf, \/\/ dmb.ishst\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns));\n+  asm_check((const unsigned int *)code.insts()->start(), insns, sizeof insns \/ sizeof insns[0]);\n+\n+  BufferBlob::free(b);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_dmb_after_expand) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  code.set_blob(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    code.insts()->maybe_expand_to_ensure_remaining(50000);\n+    __ membar(Assembler::Membar_mask_bits::StoreStore);\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns[] = {\n+    0xd5033abf, \/\/ dmb.ishst\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns));\n+  asm_check((const unsigned int *)code.insts()->start(), insns, sizeof insns \/ sizeof insns[0]);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_ldst) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    Label l;\n+    \/\/ merge ld\/st into ldp\/stp\n+    __ ldr(r0, Address(sp, 8));\n+    __ ldr(r1, Address(sp, 0));\n+    __ nop();\n+    __ str(r0, Address(sp, 0));\n+    __ str(r1, Address(sp, 8));\n+    __ nop();\n+    __ ldrw(r0, Address(sp, 0));\n+    __ ldrw(r1, Address(sp, 4));\n+    __ nop();\n+    __ strw(r0, Address(sp, 4));\n+    __ strw(r1, Address(sp, 0));\n+    __ nop();\n+    \/\/ can not merge\n+    __ ldrw(r0, Address(sp, 4));\n+    __ ldr(r1, Address(sp, 8));\n+    __ nop();\n+    __ ldrw(r0, Address(sp, 0));\n+    __ ldrw(r1, Address(sp, 8));\n+    __ nop();\n+    __ str(r0, Address(sp, 0));\n+    __ bind(l);                     \/\/ block by label\n+    __ str(r1, Address(sp, 8));\n+    __ nop();\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns1[] = {\n+    0xa94003e1, \/\/ ldp x1, x0, [sp]\n+    0xd503201f, \/\/ nop\n+    0xa90007e0, \/\/ stp x0, x1, [sp]\n+    0xd503201f, \/\/ nop\n+    0x294007e0, \/\/ ldp w0, w1, [sp]\n+    0xd503201f, \/\/ nop\n+    0x290003e1, \/\/ stp w1, w0, [sp]\n+    0xd503201f, \/\/ nop\n+    0xb94007e0, \/\/ ldr w0, [sp, 4]\n+    0xf94007e1, \/\/ ldr x1, [sp, 8]\n+    0xd503201f, \/\/ nop\n+    0xb94003e0, \/\/ ldr w0, [sp]\n+    0xb9400be1, \/\/ ldr w1, [sp, 8]\n+    0xd503201f, \/\/ nop\n+    0xf90003e0, \/\/ str x0, [sp]\n+    0xf90007e1, \/\/ str x1, [sp, 8]\n+    0xd503201f, \/\/ nop\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns1));\n+  asm_check((const unsigned int *)code.insts()->start(), insns1, sizeof insns1 \/ sizeof insns1[0]);\n+\n+  BufferBlob::free(b);\n+}\n+\n+TEST_VM(AssemblerAArch64, merge_ldst_after_expand) {\n+  ResourceMark rm;\n+  BufferBlob* b = BufferBlob::create(\"aarch64Test\", 400);\n+  CodeBuffer code(b);\n+  code.set_blob(b);\n+  MacroAssembler _masm(&code);\n+\n+  {\n+    __ ldr(r0, Address(sp, 8));\n+    code.insts()->maybe_expand_to_ensure_remaining(10000);\n+    __ ldr(r1, Address(sp, 0));\n+    __ nop();\n+    __ str(r0, Address(sp, 0));\n+    code.insts()->maybe_expand_to_ensure_remaining(100000);\n+    __ str(r1, Address(sp, 8));\n+    __ nop();\n+    __ flush();\n+  }\n+  asm_dump(code.insts()->start(), code.insts()->end());\n+  static const unsigned int insns[] = {\n+    0xa94003e1, \/\/ ldp x1, x0, [sp]\n+    0xd503201f, \/\/ nop\n+    0xa90007e0, \/\/ stp x0, x1, [sp]\n+    0xd503201f, \/\/ nop\n+  };\n+  EXPECT_EQ(code.insts()->size(), (CodeSection::csize_t)(sizeof insns));\n+  asm_check((const unsigned int *)code.insts()->start(), insns, sizeof insns \/ sizeof insns[0]);\n+}\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/test_assembler_aarch64.cpp","additions":210,"deletions":1,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/* test allocation speed of object with final field *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class FinalFieldInitialize {\n+  final static int LEN = 100_000;\n+  Object arr[] = null;\n+  @Setup\n+  public void setup(){\n+    arr = new Object[LEN];\n+  }\n+\n+  @Benchmark\n+  public void testAlloc(Blackhole bh) {\n+    for (int i=0; i<LEN; i++) {\n+      arr[i] = new TObj();\n+    }\n+    bh.consume(arr);\n+  }\n+\n+  @Benchmark\n+  public void testAllocWithFinal(Blackhole bh) {\n+    for (int i=0; i<LEN; i++) {\n+      arr[i] = new TObjWithFinal();\n+    }\n+    bh.consume(arr);\n+  }\n+}\n+\n+class TObj {\n+  private int i;\n+  private long l;\n+  private boolean b;\n+\n+  public TObj() {\n+    i = 10;\n+    l = 100L;\n+    b = true;\n+  }\n+}\n+\n+class TObjWithFinal {\n+  private int i;\n+  private long l;\n+  private final boolean b;\n+\n+  public TObjWithFinal() {\n+    i = 10;\n+    l = 100L;\n+    b = true;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FinalFieldInitialize.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}