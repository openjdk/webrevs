{"files":[{"patch":"@@ -155,1 +155,1 @@\n-#define starti Instruction_aarch64 current_insn(this);\n+#define starti this->flush_pending(); Instruction_aarch64 current_insn(this);\n@@ -526,0 +526,11 @@\n+\n+void Assembler::dmb(barrier imm) {\n+  if (imm >= ISHLD && imm <= ISH) {\n+    \/\/ try to merge with previous dmb\n+    CodeBuffer::MergeableInst newdmb(imm);\n+    _code_section->outer()->fsm()->transition(&newdmb, this);\n+  } else {\n+    \/\/ HotSpot only use other barrier kind for test\n+    _dmb(imm);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-#define starti Instruction_aarch64 current_insn(this);\n+#define starti this->flush_pending(); Instruction_aarch64 current_insn(this);\n@@ -736,0 +736,8 @@\n+  void flush() {\n+    flush_pending();\n+    AbstractAssembler::flush();\n+  }\n+\n+  virtual int pending_size() const { return _code_section->outer()->pending_insts_size(); }\n+  virtual void flush_pending()     { _code_section->outer()->flush_pending(this); }\n+\n@@ -1125,1 +1133,3 @@\n-  void dmb(barrier imm) {\n+  void dmb(barrier imm);\n+\n+  void _dmb(barrier imm) {\n@@ -4154,2 +4164,1 @@\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code) {\n-  }\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code) { }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -86,0 +86,103 @@\n+\n+int CodeBuffer::pending_insts_size() const {\n+  return _fsm->pending_size();\n+}\n+\n+void CodeBuffer::InstructionFSM_AArch64::flush_and_reset(Assembler* assem) {\n+  if (_state == NoPending) return;\n+\n+  log_debug(jit,verify)(\"emit dmb %d\", _state);\n+  PendingState old_state = _state;\n+  _state = NoPending; \/\/ reset state for emit\n+  assert( _cs == assem->code_section(), \"mismatched code section\");\n+  assert( _offset == assem->code_section()->end() - assem->code_section()->start(), \"mismatched offset\");\n+  switch (old_state) {\n+    case PendingDmbLd:\n+      assem->_dmb(Assembler::ISHLD);\n+      break;\n+    case PendingDmbSt:\n+      assem->_dmb(Assembler::ISHST);\n+      break;\n+    case PendingDmbLdSt:\n+      assem->_dmb(Assembler::ISHLD);\n+      assem->_dmb(Assembler::ISHST);\n+      break;\n+    case PendingDmbISH:\n+      assem->_dmb(Assembler::ISH);\n+      break;\n+    case PendingDmbISH2:\n+      assem->_dmb(Assembler::ISH);\n+      assem->nop();\n+      break;\n+    case PendingLd:\n+    case PendingSt:\n+      assert(false, \"not implemented\");\n+      break;\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n+  }\n+#ifndef PRODUCT\n+  \/\/ TODO: add \"merged\" comment\n+  _merged = 0;\n+  _cs = nullptr;\n+  _offset = -1;\n+#endif\n+}\n+\n+void CodeBuffer::InstructionFSM_AArch64::transition(CodeBuffer::MergeableInst* inst, Assembler* assem) {\n+  assert(inst != nullptr, \"unexpected\");\n+  if (inst->is_dmb()) {\n+    Assembler::barrier kind = (Assembler::barrier) inst->barrier_kind();\n+    assert(kind == Assembler::ISHLD || kind == Assembler::ISHST || kind == Assembler::ISH,\n+           \"barrier kind(%d) is unexpected\", kind);\n+    PendingState new_state = (PendingState) kind;\n+    switch (_state) {\n+      case NoPending:\n+#ifndef PRODUCT\n+        _cs = assem->code_section();\n+        _offset = assem->code_section()->end() - assem->code_section()->start();\n+        _merged = 0;\n+#endif\n+        _state = new_state;\n+        break;\n+      case PendingDmbLd:\n+      case PendingDmbSt:\n+        if (_state == new_state || new_state == PendingDmbISH) {\n+          _state = new_state;\n+          DEBUG_ONLY(_merged++);\n+        } else if (AlwaysMergeDMB) {\n+          _state = PendingDmbISH;\n+          DEBUG_ONLY(_merged++);\n+        } else {\n+          _state = PendingDmbLdSt;\n+        }\n+        break;\n+      case PendingDmbISH:\n+      case PendingDmbISH2:\n+        DEBUG_ONLY(_merged++);\n+        break;\n+      case PendingDmbLdSt:\n+        assert(!AlwaysMergeDMB, \"must be\");\n+        if (new_state == PendingDmbISH) {\n+          _state = PendingDmbISH2;\n+          DEBUG_ONLY(_merged += 2);\n+        } else {\n+          DEBUG_ONLY(_merged++);\n+        }\n+        break;\n+      case PendingLd:\n+      case PendingSt:\n+        assert(false, \"not implemented\");\n+        \/\/ flush_and_reset(assem);\n+        \/\/ _state = new_state;\n+        break;\n+      default:\n+        assert(false, \"should not reach here\");\n+        break;\n+    }\n+  } else {\n+    assert(false, \"should not reach here\");\n+    return;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\/\/ for merging dmb\/ld\/st\n+class MergeableInst : public StackObj {\n@@ -30,1 +32,69 @@\n-  void pd_initialize() {}\n+  bool _is_dmb;\n+  bool _is_ld;\n+  bool _is_st;\n+  int  _barrier_kind;\n+\n+public:\n+  MergeableInst(int kind): _is_dmb(true), _is_ld(false), _is_st(false), _barrier_kind(kind) {}\n+\n+  bool is_dmb ()      const { return _is_dmb; };\n+  bool is_ld ()       const { return _is_ld; };\n+  bool is_st ()       const { return _is_st; };\n+  int barrier_kind()  const { assert(_is_dmb, \"must be\"); return _barrier_kind; }\n+};\n+\n+\/* Finite State Machine for merging instruction *\/\n+class InstructionFSM_AArch64 : public ResourceObj {\n+public:\n+  enum PendingState {\n+    NoPending,\n+    PendingDmbLd   = 0b1001, \/\/ Assembler::barrier::ISHLD,\n+    PendingDmbSt,            \/\/ Assembler::barrier::ISHST,\n+    PendingDmbISH,           \/\/ Assembler::barrier::ISH,\n+    PendingDmbLdSt,\n+    \/\/ It comes from DmbLdSt+DmbISH and will emit dmb.ish + nop,\n+    \/\/ because we need keep same size with PendingDmbLdSt\n+    PendingDmbISH2,\n+    PendingLd,\n+    PendingSt\n+  };\n+\n+private:\n+  PendingState _state;\n+#ifndef PRODUCT\n+  int          _merged;\n+  CodeSection* _cs;\n+  int          _offset;\n+#endif\n+\n+public:\n+  InstructionFSM_AArch64() {\n+    _state = NoPending;\n+#ifndef PRODUCT\n+    _merged = 0;\n+    _cs = nullptr;\n+    _offset = 0;\n+#endif\n+  }\n+\n+  ~InstructionFSM_AArch64() {}\n+\n+  \/\/ reset state, emit pending instruction\n+  void flush_and_reset(Assembler* assem);\n+\n+  \/\/ transition state with current instruction, may emit instructions\n+  void transition(MergeableInst* inst, Assembler* assem);\n+\n+  PendingState state() const { return _state; }\n+\n+  \/\/ report size of pending instructions\n+  int  pending_size() const {\n+    if (_state == NoPending) return 0;\n+    if (_state == PendingDmbLdSt || _state == PendingDmbISH2) return 8;\n+    return 4;\n+  }\n+};\n+\n+private:\n+  InstructionFSM_AArch64* _fsm;\n+  void pd_initialize() { _fsm = new InstructionFSM_AArch64(); };\n@@ -34,0 +104,4 @@\n+  \/\/ use finite state machine for merging instructions\n+  void flush_pending(Assembler* assem) { _fsm->flush_and_reset(assem); }\n+  InstructionFSM_AArch64* fsm() const  { return _fsm; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2115,0 +2115,3 @@\n+  dmb(Assembler::barrier(order_constraint));\n+  return;\n+  \/*\n@@ -2143,1 +2146,2 @@\n-  dmb(Assembler::barrier(order_constraint));\n+  _dmb(Assembler::barrier(order_constraint));\n+  *\/\n@@ -2147,0 +2151,1 @@\n+  Assembler::flush_pending();  \/\/ TODO: rewrite ld\/st merge with fsm\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    flush_pending();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/arm\/codeBuffer_arm.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/ppc\/codeBuffer_ppc.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -88,0 +88,2 @@\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/s390\/codeBuffer_s390.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -32,0 +32,2 @@\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/zero\/codeBuffer_zero.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -59,0 +59,1 @@\n+  flush_pending();\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -368,2 +368,4 @@\n-  address       pc()           const   { return code_section()->end();   }\n-  int           offset()       const   { return code_section()->size();  }\n+  virtual int   pending_size() const   { return 0; }\n+  virtual void  flush_pending()        { }\n+  address       pc()           const   { return code_section()->end() + pending_size();   }\n+  int           offset()       const   { return code_section()->size() + pending_size();  }\n@@ -378,1 +380,2 @@\n-  void      set_inst_mark()       {        code_section()->set_mark();   }\n+  \/\/ void      set_inst_mark()       {        code_section()->set_mark();   }\n+  void      set_inst_mark()       {        code_section()->set_mark(pc());   }\n@@ -387,1 +390,2 @@\n-    code_section()->relocate(code_section()->end(), rspec, format);\n+    \/\/ code_section()->relocate(code_section()->end(), rspec, format);\n+    code_section()->relocate(pc(), rspec, format);\n@@ -390,1 +394,2 @@\n-    code_section()->relocate(code_section()->end(), rtype, format);\n+    \/\/ code_section()->relocate(code_section()->end(), rtype, format);\n+    code_section()->relocate(pc(), rtype, format);\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -316,2 +316,2 @@\n-  assert(start() <= at && at <= end()+1,\n-         \"cannot relocate data outside code boundaries\");\n+  \/\/assert(start() <= at && at <= end()+1,\n+  \/\/       \"cannot relocate data outside code boundaries\");\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class Assembler;\n@@ -201,1 +202,1 @@\n-  void    set_mark(address pc)      { assert(contains2(pc), \"not in codeBuffer\");\n+  void    set_mark(address pc)      { \/\/ assert(contains2(pc), \"not in codeBuffer\");\n@@ -495,0 +496,1 @@\n+    pd_initialize();\n@@ -528,1 +530,1 @@\n- public:\n+public:\n@@ -618,1 +620,2 @@\n-  address       insts_end() const        { return _insts.end();        }\n+  address       insts_end() const        { assert(pending_insts_size()==0, \"no pending instruction\");\n+                                           return _insts.end();        }\n@@ -627,1 +630,4 @@\n-  csize_t insts_size() const             { return _insts.size(); }\n+  csize_t insts_size() const             { return _insts.size() + pending_insts_size(); }\n+\n+  \/\/ size of pending instructions, like dmb in aarch64\n+  int pending_insts_size() const;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  ResourceMark rm;\n@@ -94,0 +95,1 @@\n+  ResourceMark rm;\n@@ -121,0 +123,1 @@\n+    __ flush();\n@@ -156,0 +159,1 @@\n+  ResourceMark rm;\n@@ -166,0 +170,1 @@\n+    __ flush();\n@@ -189,0 +194,1 @@\n+    __ flush();\n@@ -199,0 +205,1 @@\n+  ResourceMark rm;\n@@ -229,0 +236,1 @@\n+    __ flush();\n@@ -272,0 +280,1 @@\n+    __ flush();\n","filename":"test\/hotspot\/gtest\/aarch64\/test_assembler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}