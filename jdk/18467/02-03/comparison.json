{"files":[{"patch":"@@ -526,11 +526,0 @@\n-\n-void Assembler::dmb(barrier imm) {\n-  if (imm >= ISHLD && imm <= ISH) {\n-    \/\/ try to merge with previous dmb\n-    CodeBuffer::MergeableInst newdmb(imm);\n-    _code_section->outer()->fsm()->transition(&newdmb, this);\n-  } else {\n-    \/\/ HotSpot only use other barrier kind for test\n-    _dmb(imm);\n-  }\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1133,3 +1133,1 @@\n-  void dmb(barrier imm);\n-\n-  void _dmb(barrier imm) {\n+  void dmb(barrier imm) {\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  return _fsm->pending_size();\n+  return _fsm.pending_size();\n@@ -100,1 +100,1 @@\n-      assem->_dmb(Assembler::ISHLD);\n+      assem->dmb(Assembler::ISHLD);\n@@ -103,1 +103,1 @@\n-      assem->_dmb(Assembler::ISHST);\n+      assem->dmb(Assembler::ISHST);\n@@ -106,2 +106,2 @@\n-      assem->_dmb(Assembler::ISHLD);\n-      assem->_dmb(Assembler::ISHST);\n+      assem->dmb(Assembler::ISHLD);\n+      assem->dmb(Assembler::ISHST);\n@@ -110,1 +110,1 @@\n-      assem->_dmb(Assembler::ISH);\n+      assem->dmb(Assembler::ISH);\n@@ -113,1 +113,1 @@\n-      assem->_dmb(Assembler::ISH);\n+      assem->dmb(Assembler::ISH);\n@@ -116,4 +116,0 @@\n-    case PendingLd:\n-    case PendingSt:\n-      assert(false, \"not implemented\");\n-      break;\n@@ -125,1 +121,3 @@\n-  \/\/ TODO: add \"merged\" comment\n+  if (_merged) {\n+    assem->block_comment(\"merged membar\");\n+  }\n@@ -132,9 +130,7 @@\n-void CodeBuffer::InstructionFSM_AArch64::transition(CodeBuffer::MergeableInst* inst, Assembler* assem) {\n-  assert(inst != nullptr, \"unexpected\");\n-  if (inst->is_dmb()) {\n-    Assembler::barrier kind = (Assembler::barrier) inst->barrier_kind();\n-    assert(kind == Assembler::ISHLD || kind == Assembler::ISHST || kind == Assembler::ISH,\n-           \"barrier kind(%d) is unexpected\", kind);\n-    PendingState new_state = (PendingState) kind;\n-    switch (_state) {\n-      case NoPending:\n+void CodeBuffer::InstructionFSM_AArch64::transition(unsigned int imm, Assembler* assem) {\n+  Assembler::barrier kind = (Assembler::barrier)imm;\n+  assert(kind == Assembler::ISHLD || kind == Assembler::ISHST || kind == Assembler::ISH,\n+         \"barrier kind(%d) is unexpected\", kind);\n+  PendingState new_state = (PendingState) kind;\n+  switch (_state) {\n+    case NoPending:\n@@ -142,3 +138,3 @@\n-        _cs = assem->code_section();\n-        _offset = assem->code_section()->end() - assem->code_section()->start();\n-        _merged = 0;\n+      _cs = assem->code_section();\n+      _offset = assem->code_section()->end() - assem->code_section()->start();\n+      _merged = 0;\n@@ -146,0 +142,5 @@\n+      _state = new_state;\n+      break;\n+    case PendingDmbLd:\n+    case PendingDmbSt:\n+      if (_state == new_state || new_state == PendingDmbISH) {\n@@ -147,15 +148,0 @@\n-        break;\n-      case PendingDmbLd:\n-      case PendingDmbSt:\n-        if (_state == new_state || new_state == PendingDmbISH) {\n-          _state = new_state;\n-          DEBUG_ONLY(_merged++);\n-        } else if (AlwaysMergeDMB) {\n-          _state = PendingDmbISH;\n-          DEBUG_ONLY(_merged++);\n-        } else {\n-          _state = PendingDmbLdSt;\n-        }\n-        break;\n-      case PendingDmbISH:\n-      case PendingDmbISH2:\n@@ -163,23 +149,23 @@\n-        break;\n-      case PendingDmbLdSt:\n-        assert(!AlwaysMergeDMB, \"must be\");\n-        if (new_state == PendingDmbISH) {\n-          _state = PendingDmbISH2;\n-          DEBUG_ONLY(_merged += 2);\n-        } else {\n-          DEBUG_ONLY(_merged++);\n-        }\n-        break;\n-      case PendingLd:\n-      case PendingSt:\n-        assert(false, \"not implemented\");\n-        \/\/ flush_and_reset(assem);\n-        \/\/ _state = new_state;\n-        break;\n-      default:\n-        assert(false, \"should not reach here\");\n-        break;\n-    }\n-  } else {\n-    assert(false, \"should not reach here\");\n-    return;\n+      } else if (AlwaysMergeDMB) {\n+        _state = PendingDmbISH;\n+        DEBUG_ONLY(_merged++);\n+      } else {\n+        _state = PendingDmbLdSt;\n+      }\n+      break;\n+    case PendingDmbISH:\n+    case PendingDmbISH2:\n+      DEBUG_ONLY(_merged++);\n+      break;\n+    case PendingDmbLdSt:\n+      assert(!AlwaysMergeDMB, \"must be\");\n+      if (new_state == PendingDmbISH) {\n+        _state = PendingDmbISH2;\n+        DEBUG_ONLY(_merged += 2);\n+      } else {\n+        DEBUG_ONLY(_merged++);\n+      }\n+      break;\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":48,"deletions":62,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -29,17 +29,0 @@\n-\/\/ for merging dmb\/ld\/st\n-class MergeableInst : public StackObj {\n-private:\n-  bool _is_dmb;\n-  bool _is_ld;\n-  bool _is_st;\n-  int  _barrier_kind;\n-\n-public:\n-  MergeableInst(int kind): _is_dmb(true), _is_ld(false), _is_st(false), _barrier_kind(kind) {}\n-\n-  bool is_dmb ()      const { return _is_dmb; };\n-  bool is_ld ()       const { return _is_ld; };\n-  bool is_st ()       const { return _is_st; };\n-  int barrier_kind()  const { assert(_is_dmb, \"must be\"); return _barrier_kind; }\n-};\n-\n@@ -58,2 +41,0 @@\n-    PendingLd,\n-    PendingSt\n@@ -84,1 +65,1 @@\n-  void transition(MergeableInst* inst, Assembler* assem);\n+  void transition(unsigned int imm, Assembler* assem);\n@@ -97,2 +78,2 @@\n-  InstructionFSM_AArch64* _fsm;\n-  void pd_initialize() { _fsm = new InstructionFSM_AArch64(); };\n+  InstructionFSM_AArch64 _fsm;\n+  void pd_initialize() { }\n@@ -102,3 +83,3 @@\n-  \/\/ use finite state machine for merging instructions\n-  void flush_pending(Assembler* assem) { _fsm->flush_and_reset(assem); }\n-  InstructionFSM_AArch64* fsm() const  { return _fsm; }\n+  \/\/ use finite state machine for merging dmb instructions\n+  void flush_pending(Assembler* assem) { _fsm.flush_and_reset(assem); }\n+  void push_dmb(unsigned int imm, Assembler* assem) { _fsm.transition(imm, assem); }\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.hpp","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2114,30 +2114,7 @@\n-void MacroAssembler::membar(Membar_mask_bits order_constraint) {\n-  dmb(Assembler::barrier(order_constraint));\n-  return;\n-  \/*\n-  address prev = pc() - NativeMembar::instruction_size;\n-  address last = code()->last_insn();\n-  if (last != nullptr && nativeInstruction_at(last)->is_Membar() && prev == last) {\n-    NativeMembar *bar = NativeMembar_at(prev);\n-    \/\/ Don't promote DMB ST|DMB LD to DMB (a full barrier) because\n-    \/\/ doing so would introduce a StoreLoad which the caller did not\n-    \/\/ intend\n-    if (AlwaysMergeDMB || bar->get_kind() == order_constraint\n-        || bar->get_kind() == AnyAny\n-        || order_constraint == AnyAny) {\n-      \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-      \/\/ can do this simply by ORing them together.\n-      bar->set_kind(bar->get_kind() | order_constraint);\n-      BLOCK_COMMENT(\"merged membar\");\n-      return;\n-    } else if (!AlwaysMergeDMB){\n-      \/\/ A special case like \"DMB ST;DMB LD;DMB ST\", the last DMB can be skipped\n-      \/\/ We need check the last 2 instructions\n-      address prev2 = prev - NativeMembar::instruction_size;\n-      if (last != code()->last_label() && nativeInstruction_at(prev2)->is_Membar()) {\n-        NativeMembar *bar2 = NativeMembar_at(prev2);\n-        assert(bar2->get_kind() == order_constraint, \"it should be merged before\");\n-        BLOCK_COMMENT(\"merged membar\");\n-        return;\n-      }\n-    }\n+void MacroAssembler::membar(Membar_mask_bits imm) {\n+  if (imm >= LoadStore && imm <= AnyAny) {\n+    \/\/ try to merge with previous dmb\n+    _code_section->outer()->push_dmb(imm, this);\n+  } else {\n+    \/\/ HotSpot only use other barrier kind for test\n+    Assembler::dmb((barrier)imm);\n@@ -2145,3 +2122,0 @@\n-  code()->set_last_insn(pc());\n-  _dmb(Assembler::barrier(order_constraint));\n-  *\/\n@@ -2151,1 +2125,1 @@\n-  Assembler::flush_pending();  \/\/ TODO: rewrite ld\/st merge with fsm\n+  Assembler::flush_pending();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":34,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/codeBuffer_arm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/codeBuffer_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/codeBuffer_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-int CodeBuffer::pending_insts_size() const { return 0; }\n\\ No newline at end of file\n+int CodeBuffer::pending_insts_size() const { return 0; }\n","filename":"src\/hotspot\/cpu\/x86\/codeBuffer_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n","filename":"src\/hotspot\/cpu\/zero\/codeBuffer_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -371,2 +371,2 @@\n-  int           offset()       const   { return code_section()->size() + pending_size();  }\n-  int           locator()      const   { return CodeBuffer::locator(offset(), sect()); }\n+  int           offset()               { flush_pending(); return code_section()->size();  }\n+  int           locator()              { return CodeBuffer::locator(offset(), sect()); }\n@@ -380,1 +380,0 @@\n-  \/\/ void      set_inst_mark()       {        code_section()->set_mark();   }\n@@ -390,1 +389,0 @@\n-    \/\/ code_section()->relocate(code_section()->end(), rspec, format);\n@@ -394,1 +392,0 @@\n-    \/\/ code_section()->relocate(code_section()->end(), rtype, format);\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-  \/\/assert(start() <= at && at <= end()+1,\n+  \/\/ TODO: assert(start() <= at && at <= end()+1,\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/aarch64\/test_assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FinalFieldInitialize.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}