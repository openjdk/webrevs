{"files":[{"patch":"@@ -8292,1 +8292,1 @@\n-            \"dmb ishld\" %}\n+            \"dmb ish\" %}\n@@ -8346,1 +8346,1 @@\n-            \"dmb ishst\\n\\tdmb ishld\" %}\n+            \"dmb ish\" %}\n@@ -8350,2 +8350,1 @@\n-    __ membar(Assembler::StoreStore);\n-    __ membar(Assembler::LoadStore);\n+    __ membar(Assembler::LoadStore|Assembler::StoreStore);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -130,2 +130,0 @@\n-  product(bool, AlwaysMergeDMB, false, DIAGNOSTIC,                      \\\n-          \"Always merge DMB instructions in code emission\")             \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2069,12 +2069,7 @@\n-    \/\/ Don't promote DMB ST|DMB LD to DMB (a full barrier) because\n-    \/\/ doing so would introduce a StoreLoad which the caller did not\n-    \/\/ intend\n-    if (AlwaysMergeDMB || bar->get_kind() == order_constraint\n-        || bar->get_kind() == AnyAny\n-        || order_constraint == AnyAny) {\n-      \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-      \/\/ can do this simply by ORing them together.\n-      bar->set_kind(bar->get_kind() | order_constraint);\n-      BLOCK_COMMENT(\"merged membar\");\n-      return;\n-    }\n+    \/\/ We are merging two memory barrier instructions.  On AArch64 we\n+    \/\/ can do this simply by ORing them together.\n+    bar->set_kind(bar->get_kind() | order_constraint);\n+    BLOCK_COMMENT(\"merged membar\");\n+  } else {\n+    code()->set_last_insn(pc());\n+    dmb(Assembler::barrier(order_constraint));\n@@ -2082,2 +2077,0 @@\n-  code()->set_last_insn(pc());\n-  dmb(Assembler::barrier(order_constraint));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -194,3 +194,0 @@\n-    if (FLAG_IS_DEFAULT(AlwaysMergeDMB)) {\n-      FLAG_SET_DEFAULT(AlwaysMergeDMB, true);\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.compiler;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.*;\n-\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-\/* test allocation speed of object with final field *\/\n-@BenchmarkMode(Mode.Throughput)\n-@OutputTimeUnit(TimeUnit.SECONDS)\n-@State(Scope.Benchmark)\n-@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 3, time = 3, timeUnit = TimeUnit.SECONDS)\n-@Fork(value = 3)\n-public class FinalFieldInitialize {\n-  final static int LEN = 100_000;\n-  Object arr[] = null;\n-  @Setup\n-  public void setup(){\n-    arr = new Object[LEN];\n-  }\n-\n-  @Benchmark\n-  public void testAlloc(Blackhole bh) {\n-    for (int i=0; i<LEN; i++) {\n-      arr[i] = new TObj();\n-    }\n-    bh.consume(arr);\n-  }\n-\n-  @Benchmark\n-  public void testAllocWithFinal(Blackhole bh) {\n-    for (int i=0; i<LEN; i++) {\n-      arr[i] = new TObjWithFinal();\n-    }\n-    bh.consume(arr);\n-  }\n-}\n-\n-class TObj {\n-  private int i;\n-  private long l;\n-  private boolean b;\n-\n-  public TObj() {\n-    i = 10;\n-    l = 100L;\n-    b = true;\n-  }\n-}\n-\n-class TObjWithFinal {\n-  private int i;\n-  private long l;\n-  private final boolean b;\n-\n-  public TObjWithFinal() {\n-    i = 10;\n-    l = 100L;\n-    b = true;\n-  }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FinalFieldInitialize.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"}]}