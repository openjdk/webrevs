{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,4 @@\n- * elements.\n+ * elements, {@link #getExtension() getExtension} to obtain its file name\n+ * extension, and {@link #withoutExtension withoutExtension} and\n+ * {@link #withExtension withExtension} to remove or alter the extension,\n+ * respectively.\n@@ -252,0 +255,173 @@\n+    \/**\n+     * Returns the file extension of this path's file name as a {@code String}.\n+     * The extension is acquired from this {@code Path} by obtaining the file\n+     * name element, locating the position of the last period character\n+     * ('.', U+002E FULL STOP) within the file name element, and then extracting\n+     * the portion of the file name element after the last period as a string.\n+     * If the file name element is {@code null}, the file name does not contain\n+     * a period, the last character in the file name is a period, or the content\n+     * of the file name before the last period is empty, then the extension is\n+     * {@linkplain String#isEmpty empty}.\n+     *\n+     * <p> A typical case is where a file name contains a single period\n+     * character followed by an extension which usually indicates the contents\n+     * or purpose of the file. For example, a file named {@code \"archive.zip\"}\n+     * has extension {@code \"zip\"} which signals that the file is in the\n+     * <i>ZIP<\/i> losslessly compressed archive file format.\n+     *\n+     * <p> A compound file name extension has two or more concatenated\n+     * extensions such as in {@code \"archive.tar.gz\"}, which signifies that\n+     * the file is an archive file ({@code \"tar\"}) losslessly compressed\n+     * according to the <i>gzip<\/i> format.\n+     *\n+     * @implSpec\n+     * The default implementation is in most cases equivalent for this path to:\n+     * {@snippet lang=\"java\" :\n+     *     int lastPeriod = fileNameString.lastIndexOf('.');\n+     *     return lastPeriod <= 0\n+     *        ? \"\"\n+     *        : fileNameString.substring(lastPeriod + 1);\n+     * }\n+     *\n+     * @return  the file name extension of this path, which might be the\n+     *          {@linkplain String#isEmpty empty string}\n+     *\n+     * @see #withExtension\n+     * @see #withoutExtension\n+     *\n+     * @since 24\n+     *\/\n+    default String getExtension() {\n+        Path fileName = getFileName();\n+        if (fileName == null)\n+            return \"\";\n+\n+        String fileNameString = fileName.toString();\n+        int lastPeriodIndex = fileNameString.lastIndexOf('.');\n+\n+        if (lastPeriodIndex <= 0)\n+            return \"\";\n+\n+        \/\/ If lastPeriodIndex == fileNameString.length() - 1 then \"\" is returned\n+        return fileNameString.substring(lastPeriodIndex + 1);\n+    }\n+\n+    \/**\n+     * Returns a {@code Path} with the same sequence of elements as this\n+     * path, but with no file name extension. If this path has no extension,\n+     * then the path is returned unchanged.\n+     *\n+     * <p> For example, an audio track's extension might be removed as:\n+     * {@snippet lang=\"java\" :\n+     *     Path music = Path.of(\"library\/audio\/track.flac\");\n+     *     Path noise = music.withoutExtension();\n+     * }\n+     * where {@code noise.toString()} would return\n+     * {@code \"library\/audio\/track\"}.\n+     *\n+     * <p> A compound extension may be replaced by invoking this method and\n+     * then the {@linkplain #withExtension withExtension} method on the result.\n+     * For example, to convert the {@code \"tar.gz\"} compound extension\n+     * to {@code \"zip\"}:\n+     * {@snippet lang=\"java\" :\n+     *    Path p = Path.of(\"archive.tar.gz\");\n+     *    Path q = p.withoutExtension().withExtension(\"zip\");\n+     * }\n+     * where {@code q.toString()} would return {@code \"archive.zip\"}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * {@snippet lang=\"java\" :\n+     *     if (getExtension().isEmpty()) {\n+     *         return this;\n+     *     } else {\n+     *         String str = getFileName().toString();\n+     *         return resolveSibling(str.substring(0,\n+     *                               str.length() - ext.length() - 1));\n+     *     }\n+     * }\n+     *\n+     * @return the resulting path or this path if it does not contain a file\n+     *         name extension\n+     *\n+     * @see #getExtension\n+     * @see #withExtension\n+     *\n+     * @since 24\n+     *\/\n+    default Path withoutExtension() {\n+        String ext = getExtension();\n+        if (ext.isEmpty())\n+            return this;\n+        String str = getFileName().toString();\n+        return resolveSibling(str.substring(0, str.length() - ext.length() - 1));\n+    }\n+\n+    \/**\n+     * Returns a {@code Path} with the same sequence of elements as this path,\n+     * but with an altered file name extension. If the specified extension is\n+     * non-{@linkplain String#isEmpty empty}, then a {@code '.'} and then\n+     * {@code extension} are appended to the path returned by\n+     * {@linkplain #withoutExtension wihoutExtension}, otherwise the path\n+     * returned by {@linkplain #withoutExtension wihoutExtension} is returned.\n+     *\n+     * <p> For example, an audio track's extension might be changed as:\n+     * {@snippet lang=\"java\" :\n+     *     Path lossless = Path.of(\"library\/audio\/track.flac\");\n+     *     Path lossy = lossless.withExtension(\"mp3\");\n+     * }\n+     * where {@code lossy.toString()} would return\n+     * {@code \"library\/audio\/track.mp3\"}.\n+     *\n+     * <p> A compound extension may be formed by appending an additional\n+     * extension as:\n+     * {@snippet lang=\"java\" :\n+     *     Path p = Path.of(\"archive.tar\");\n+     *     Path q = p.withExtension(p.getExtension() + \".\" + \"gz\");\n+     * }\n+     * where {@code q.toString()} would return {@code \"archive.tar.gz\"}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     *\n+     * {@snippet lang=\"java\" :\n+     *     Path p = withoutExtension();\n+     *     if (extension == null || extension.isEmpty()) {\n+     *         return p;\n+     *     } else {\n+     *         return p.resolveSibling(p.getFileName() + \".\" + extension);\n+     *     }\n+     * }\n+     *\n+     * This method must satisfy the invariant:\n+     * {@snippet lang=\"java\" :\n+     *     assert equals(withExtension(getExtension()));\n+     * }\n+     *\n+     * @param extension\n+     *        the extension to append\n+     *\n+     * @return a {@code Path} with the requested extension replacing the\n+     *         existing extension, if any\n+     *\n+     * @throws IllegalArgumentException\n+     *         if {@code extension} starts with a period character\n+     *\n+     * @see #getExtension\n+     * @see #withoutExtension\n+     *\n+     * @since 24\n+     *\/\n+    default Path withExtension(String extension) {\n+        Objects.requireNonNull(extension);\n+\n+        if (extension.startsWith(\".\"))\n+            throw new IllegalArgumentException(\"extension starts with '.'\");\n+\n+        Path path = withoutExtension();\n+        if (extension.isEmpty())\n+            return path;\n+\n+        return path.resolveSibling(path.getFileName() + \".\" + extension);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":178,"deletions":2,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8057113\n+ * @summary Verify getExtension method\n+ * @run testng Extensions\n+ *\/\n+public class Extensions {\n+    \/**\n+     * Returns path name string and expected extension pairs.\n+     *\n+     * @return {@code {{\"pathname\", \"extension\"},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] pathExtProvider() {\n+        Object[][] pairs = {\n+            {\"\",               \"\"},\n+            {\".\",              \"\"},\n+            {\"..\",             \"\"},\n+            {\"...\",            \"\"},\n+            {\"....\",           \"\"},\n+            {\".....\",          \"\"},\n+            {\"aa\",             \"\"},\n+            {\"a.\",             \"\"},\n+            {\".a\",             \"\"},\n+            {\"..a\",            \"a\"},\n+            {\"...a\",           \"a\"},\n+            {\"....a\",          \"a\"},\n+            {\"a...gus\",        \"gus\"},\n+            {\".a.b\",           \"b\"},\n+            {\"...a.b\",         \"b\"},\n+            {\"...a.b.\",        \"\"},\n+            {\".foo\",           \"\"},\n+            {\"..foo\",          \"foo\"},\n+            {\"foo.\",           \"\"},\n+            {\"foo..\",          \"\"},\n+            {\"foo..b\",         \"b\"},\n+            {\"test.\",          \"\"},\n+            {\"test..\",         \"\"},\n+            {\"test...\",        \"\"},\n+            {\"test.rb\",        \"rb\"},\n+            {\"a\/b\/d\/test.rb\" , \"rb\"},\n+            {\".a\/b\/d\/test.rb\", \"rb\"},\n+            {\"test\",           \"\"},\n+            {\".profile\",       \"\"},\n+            {\".profile.sh\",    \"sh\"},\n+            {\"foo.tar.gz\",     \"gz\"},\n+            {\"foo.bar\",        \"bar\"},\n+            {\"foo.bar.\",       \"\"},\n+            {\"archive.zip\",    \"zip\"},\n+            {\"compress.gzip\",  \"gzip\"},\n+            {\"waitwhat.&$!#%\", \"&$!#%\"},\n+            {\"6.283185307\",    \"283185307\"}\n+        };\n+        return pairs;\n+    }\n+\n+    @Test(dataProvider = \"pathExtProvider\")\n+    public static void get(String pathname, String extension) {\n+        Assert.assertEquals(Path.of(pathname).getExtension(), extension);\n+    }\n+\n+    @Test(dataProvider = \"pathExtProvider\")\n+    public static void with(String pathname, String extension) {\n+        Path p = Path.of(pathname);\n+        Path expected = p;\n+        Path actual = p.withExtension(extension);\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    @Test (expectedExceptions = NullPointerException.class)\n+    public static void withNPE() {\n+        Path.of(\"foo.bar\").withExtension(null);\n+    }\n+\n+    @Test (expectedExceptions = IllegalArgumentException.class)\n+    public static void withIAE() {\n+        Path.of(\"foo.bar\").withExtension(\".gus\");\n+    }\n+\n+    @Test(dataProvider = \"pathExtProvider\")\n+    public static void without(String pathname, String extension) {\n+        Path p = Path.of(pathname);\n+        Path expected = p;\n+        String ext = p.getExtension();\n+        Path actual = Path.of(p.withoutExtension().toString()\n+                              + (ext.isEmpty() ? \"\" : (\".\" + extension)));\n+        Assert.assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}