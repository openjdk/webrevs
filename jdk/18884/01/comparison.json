{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n- * @library \/test\/lib\n- * @run main\/othervm B5045306\n@@ -30,0 +28,2 @@\n+ * @library \/test\/lib\n+ * @run main B5045306\n@@ -45,0 +45,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -51,0 +52,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -52,1 +55,1 @@\n- * The http client makes a connection to a URL whos content contains a lot of\n+ * The http client makes a connection to a URL who's content contains a lot of\n@@ -66,5 +69,1 @@\n-\n-    public static void main(String[] args) {\n-        startHttpServer();\n-        clientHttpCalls();\n-    }\n+    static ExecutorService executor = Executors.newSingleThreadExecutor();\n@@ -75,2 +74,0 @@\n-            server.setExecutor(Executors.newSingleThreadExecutor());\n-            server.start();\n@@ -78,1 +75,1 @@\n-            e.printStackTrace();\n+            throw new RuntimeException(e);\n@@ -80,0 +77,7 @@\n+        server.setExecutor(executor);\n+        server.start();\n+    }\n+\n+    public static void stopHttpServer() {\n+        server.stop(1);\n+        executor.shutdown();\n@@ -82,1 +86,1 @@\n-    public static void clientHttpCalls() {\n+    public static void clientHttpCalls() throws Exception {\n@@ -87,13 +91,20 @@\n-        try {\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr =  InetAddress.getLocalHost().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n-\n-            URL bigDataURL = new URL (baseURLStr + \"firstCall\");\n-            URL smallDataURL = new URL (baseURLStr + \"secondCall\");\n-\n-            HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n-\n-            \/\/Only read 1 byte of response data and close the stream\n-            InputStream is = uc.getInputStream();\n+        System.out.println(\"http server listens on: \" + server.getAddress().getPort());\n+\n+        URL bigDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .host(InetAddress.getLocalHost())\n+                .port(server.getAddress().getPort())\n+                .path(\"\/firstCall\")\n+                .toURL();\n+\n+        URL smallDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .host(InetAddress.getLocalHost())\n+                .port(server.getAddress().getPort())\n+                .path(\"\/secondCall\")\n+                .toURL();\n+\n+        HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n+\n+        \/\/ Only read 1 byte of response data and close the stream\n+        try (InputStream is = uc.getInputStream()) {\n@@ -102,41 +113,45 @@\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n-            uc.getResponseCode();\n-\n-            if (SimpleHttpTransactionHandler.failed)\n-                throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n-\n-            \/\/ Part 2\n-            URL part2Url = new URL (baseURLStr + \"part2\");\n-            uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n-            is = uc.getInputStream();\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n-            if (threadMXBean.isThreadCpuTimeSupported()) {\n-                long[] threads = threadMXBean.getAllThreadIds();\n-                ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n-                for (int i=0; i<threadInfo.length; i++) {\n-                    if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\"))  {\n-                        System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n-                        long threadID = threadInfo[i].getThreadId();\n-                        long before = threadMXBean.getThreadCpuTime(threadID);\n-                        try { Thread.sleep(2000); } catch (Exception e) {}\n-                        long after = threadMXBean.getThreadCpuTime(threadID);\n-\n-                        if (before ==-1 || after == -1)\n-                            break;  \/\/ thread has died, OK\n-\n-                        \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n-                        \/\/ can assume a recursive loop.\n-                        long total = after - before;\n-                        if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n-                            throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n-                    }\n+        }\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n+        uc.getResponseCode();\n+\n+        if (SimpleHttpTransactionHandler.failed)\n+            throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n+\n+        \/\/ Part 2\n+        URL part2Url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .host(InetAddress.getLocalHost())\n+                .port(server.getAddress().getPort())\n+                .path(\"\/part2\")\n+                .toURL();\n+\n+        uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n+        try (InputStream is = uc.getInputStream()) {}\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n+        if (threadMXBean.isThreadCpuTimeSupported()) {\n+            long[] threads = threadMXBean.getAllThreadIds();\n+            ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n+            for (int i=0; i<threadInfo.length; i++) {\n+                if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\")) {\n+                    System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n+                    long threadID = threadInfo[i].getThreadId();\n+                    long before = threadMXBean.getThreadCpuTime(threadID);\n+                    try { Thread.sleep(2000); } catch (Exception e) {}\n+                    long after = threadMXBean.getThreadCpuTime(threadID);\n+\n+                    if (before ==-1 || after == -1)\n+                        break;  \/\/ thread has died, OK\n+\n+                    \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n+                    \/\/ can assume a recursive loop.\n+                    long total = after - before;\n+                    if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n+                        throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n@@ -145,5 +160,0 @@\n-\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        } finally {\n-            server.stop(1);\n@@ -155,1 +165,0 @@\n-}\n@@ -157,3 +166,2 @@\n-class SimpleHttpTransactionHandler implements HttpHandler\n-{\n-    static volatile boolean failed = false;\n+    static class SimpleHttpTransactionHandler implements HttpHandler {\n+        static volatile boolean failed = false;\n@@ -161,3 +169,3 @@\n-    \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n-    \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n-    static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n+        \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n+        \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n+        static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n@@ -165,1 +173,1 @@\n-    int port1;\n+        int port1;\n@@ -167,12 +175,36 @@\n-    public void handle(HttpExchange trans) {\n-        try {\n-            String path = trans.getRequestURI().getPath();\n-            if (path.equals(\"\/firstCall\")) {\n-                port1 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"First connection on client port = \" + port1);\n-\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                trans.sendResponseHeaders(200, responseBody.length);\n-                try (OutputStream os = trans.getResponseBody()) {\n+        public void handle(HttpExchange trans) {\n+            try {\n+                String path = trans.getRequestURI().getPath();\n+                if (path.equals(\"\/firstCall\")) {\n+                    port1 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"First connection on client port = \" + port1);\n+\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    trans.sendResponseHeaders(200, responseBody.length);\n+                    try (OutputStream os = trans.getResponseBody()) {\n+                        os.write(responseBody);\n+                    }\n+                } else if (path.equals(\"\/secondCall\")) {\n+                    int port2 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"Second connection on client port = \" + port2);\n+\n+                    if (port1 != port2)\n+                        failed = true;\n+\n+                     \/* Force the server to not respond for more that the timeout\n+                      * set by the keepalive cleaner (5000 millis). This ensures the\n+                      * timeout is correctly resets the default read timeout,\n+                      * infinity. See 6993490. *\/\n+                    System.out.println(\"server sleeping...\");\n+                    try {Thread.sleep(6000); } catch (InterruptedException e) {}\n+                    trans.sendResponseHeaders(200, -1);\n+                } else if (path.equals(\"\/part2\")) {\n+                    System.out.println(\"Call to \/part2\");\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    \/\/ override the Content-length header to be greater than the actual response body\n+                    trans.sendResponseHeaders(200, responseBody.length+1);\n+                    OutputStream os = trans.getResponseBody();\n@@ -180,0 +212,3 @@\n+                    \/\/ now close the socket\n+                    \/\/ closing the stream here would throw; close the exchange instead\n+                    trans.close();\n@@ -181,26 +216,3 @@\n-            } else if (path.equals(\"\/secondCall\")) {\n-                int port2 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"Second connection on client port = \" + port2);\n-\n-                if (port1 != port2)\n-                    failed = true;\n-\n-                 \/* Force the server to not respond for more that the timeout\n-                  * set by the keepalive cleaner (5000 millis). This ensures the\n-                  * timeout is correctly resets the default read timeout,\n-                  * infinity. See 6993490. *\/\n-                System.out.println(\"server sleeping...\");\n-                try {Thread.sleep(6000); } catch (InterruptedException e) {}\n-                trans.sendResponseHeaders(200, -1);\n-            } else if(path.equals(\"\/part2\")) {\n-                System.out.println(\"Call to \/part2\");\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                \/\/ override the Content-length header to be greater than the actual response body\n-                trans.sendResponseHeaders(200, responseBody.length+1);\n-                OutputStream os = trans.getResponseBody();\n-                os.write(responseBody);\n-                \/\/ now close the socket\n-                \/\/ closing the stream here would throw; close the exchange instead\n-                trans.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                failed = true;\n@@ -208,2 +220,9 @@\n-        } catch (Exception e) {\n-            e.printStackTrace();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        startHttpServer();\n+        try {\n+            clientHttpCalls();\n+        } finally {\n+            stopHttpServer();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B5045306.java","additions":139,"deletions":120,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 timeout\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 max\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637\n@@ -34,1 +34,4 @@\n-import java.net.*;\n+import java.net.HttpURLConnection;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n@@ -38,0 +41,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -128,2 +133,2 @@\n-    public static void main(String[] args) throws Exception {\n-        Server server = new Server(args[0]);\n+    public static void runTest(String param) throws Exception {\n+        Server server = new Server(param);\n@@ -132,1 +137,6 @@\n-        URL url = new URL(\"http:\/\/127.0.0.1:\" + Integer.toString(port) + \"\/\");\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(port)\n+                .path(\"\/firstCall\")\n+                .toURL();\n@@ -134,5 +144,7 @@\n-        InputStream i = urlc.getInputStream();\n-        int c,count=0;\n-        byte[] buf = new byte[256];\n-        while ((c=i.read(buf)) != -1) {\n-            count+=c;\n+        int count=0;\n+        try (InputStream i = urlc.getInputStream()) {\n+            int c;\n+            byte[] buf = new byte[256];\n+            while ((c=i.read(buf)) != -1) {\n+                count+=c;\n+            }\n@@ -140,2 +152,1 @@\n-        i.close();\n-        System.out.println(\"Read \" + count );\n+        System.out.println(\"Read \" + count);\n@@ -152,0 +163,5 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(\"timeout\");\n+        runTest(\"max\");\n+    }\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8291637.java","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -32,9 +32,0 @@\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import javax.net.ssl.HandshakeCompletedListener;\n-import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n@@ -56,0 +47,12 @@\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -76,4 +79,1 @@\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr = InetAddress.getLoopbackAddress().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n+            System.out.println(\"http server listens on: \" + server.getAddress().getPort());\n@@ -81,1 +81,5 @@\n-            URL testUrl = new URL (baseURLStr);\n+            URL testUrl = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .toURL();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8293562.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -28,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -33,4 +33,14 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.charset.*;\n-import java.util.logging.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n@@ -38,0 +48,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -29,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -33,2 +33,11 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+\n@@ -36,0 +45,1 @@\n+\n@@ -134,2 +144,0 @@\n-\n-        grp.destroy();\n@@ -137,1 +145,0 @@\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveTimerThread.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"}]}