{"files":[{"patch":"@@ -39,1 +39,0 @@\n-import java.util.function.Function;\n@@ -44,1 +43,0 @@\n-import jdk.internal.net.http.common.TimeSource;\n@@ -60,1 +58,0 @@\n-    private volatile int unsuccessfulAttempts;\n@@ -64,2 +61,2 @@\n-    \/\/ Indicates whether a connection attempt has succeeded or should be retried.\n-    \/\/ If the attempt failed, and shouldn't be retried, there will be an exception\n+    \/\/ Indicates whether a connection attempt has succeeded.\n+    \/\/ If the attempt failed there will be an exception\n@@ -67,1 +64,3 @@\n-    private enum ConnectState { SUCCESS, RETRY }\n+    \/\/ CONNECTED is used when connect() succeeded immediately\n+    \/\/ CONNECT_FINISHED is used when connect succeeded asynchronously\n+    private enum ConnectState { CONNECTED, CONNECT_FINISHED }\n@@ -118,1 +117,1 @@\n-        private final CompletableFuture<ConnectState> cf;\n+        private final CompletableFuture<Void> cf;\n@@ -121,1 +120,1 @@\n-        ConnectEvent(CompletableFuture<ConnectState> cf, Exchange<?> exchange) {\n+        ConnectEvent(CompletableFuture<Void> cf, Exchange<?> exchange) {\n@@ -150,1 +149,2 @@\n-                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                    if (debug.on()) debug.log(\"%s has been connected asynchronously\", label());\n+                    cf.completeAsync(() -> null, client().theExecutor());\n@@ -153,6 +153,0 @@\n-                if (canRetryConnect(e)) {\n-                    unsuccessfulAttempts++;\n-                    \/\/ complete async since the event runs on the SelectorManager thread\n-                    cf.completeAsync(() -> ConnectState.RETRY, client().theExecutor());\n-                    return;\n-                }\n@@ -177,1 +171,1 @@\n-        CompletableFuture<ConnectState> cf = new MinimalFuture<>();\n+        CompletableFuture<Void> cf = new MinimalFuture<>();\n@@ -215,1 +209,2 @@\n-                    cf.complete(ConnectState.SUCCESS);\n+                    if (debug.on()) debug.log(\"%s has been connected\", label());\n+                    cf.complete(null);\n@@ -235,2 +230,1 @@\n-        return cf.handle((r,t) -> checkRetryConnect(r, t, exchange))\n-                .thenCompose(Function.identity());\n+        return cf;\n@@ -257,36 +251,0 @@\n-    \/**\n-     * On some platforms, a ConnectEvent may be raised and a ConnectionException\n-     * may occur with the message \"Connection timed out: no further information\"\n-     * before our actual connection timeout has expired. In this case, this\n-     * method will be called with a {@code connect} state of {@code ConnectState.RETRY)}\n-     * and we will retry once again.\n-     * @param connect indicates whether the connection was successful or should be retried\n-     * @param failed the failure if the connection failed\n-     * @param exchange the exchange\n-     * @return a completable future that will take care of retrying the connection if needed.\n-     *\/\n-    private CompletableFuture<Void> checkRetryConnect(ConnectState connect, Throwable failed, Exchange<?> exchange) {\n-        \/\/ first check if the connection failed\n-        if (failed != null) return MinimalFuture.failedFuture(failed);\n-        \/\/ then check if the connection should be retried\n-        if (connect == ConnectState.RETRY) {\n-            int attempts = unsuccessfulAttempts;\n-            assert attempts <= 1;\n-            if (debug.on())\n-                debug.log(\"Retrying connect after %d attempts\", attempts);\n-            return connectAsync(exchange);\n-        }\n-        \/\/ Otherwise, the connection was successful;\n-        assert connect == ConnectState.SUCCESS;\n-        return MinimalFuture.completedFuture(null);\n-    }\n-\n-    private boolean canRetryConnect(Throwable e) {\n-        if (!MultiExchange.RETRY_CONNECT) return false;\n-        if (!(e instanceof ConnectException)) return false;\n-        if (unsuccessfulAttempts > 0) return false;\n-        ConnectTimerEvent timer = connectTimerEvent;\n-        if (timer == null) return true;\n-        return timer.deadline().isAfter(TimeSource.now());\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":13,"deletions":55,"binary":false,"changes":68,"status":"modified"}]}