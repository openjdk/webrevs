{"files":[{"patch":"@@ -64,2 +64,2 @@\n-    \/\/ Indicates whether a connection attempt has succeeded or should be retried.\n-    \/\/ If the attempt failed, and shouldn't be retried, there will be an exception\n+    \/\/ Indicates whether a connection attempt has succeeded.\n+    \/\/ If the attempt failed there will be an exception\n@@ -67,1 +67,3 @@\n-    private enum ConnectState { SUCCESS, RETRY }\n+    \/\/ CONNECTED is used when connect() succeeded immediately\n+    \/\/ CONNECT_FINISHED is used when connect succeeded asynchronously\n+    private enum ConnectState { CONNECTED, CONNECT_FINISHED }\n@@ -150,1 +152,1 @@\n-                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                    cf.completeAsync(() -> ConnectState.CONNECT_FINISHED, client().theExecutor());\n@@ -153,6 +155,0 @@\n-                if (canRetryConnect(e)) {\n-                    unsuccessfulAttempts++;\n-                    \/\/ complete async since the event runs on the SelectorManager thread\n-                    cf.completeAsync(() -> ConnectState.RETRY, client().theExecutor());\n-                    return;\n-                }\n@@ -215,1 +211,1 @@\n-                    cf.complete(ConnectState.SUCCESS);\n+                    cf.complete(ConnectState.CONNECTED);\n@@ -235,2 +231,4 @@\n-        return cf.handle((r,t) -> checkRetryConnect(r, t, exchange))\n-                .thenCompose(Function.identity());\n+        return cf.thenApply((state)->{\n+            if (debug.on()) debug.log(\"%s: %s\", label(), state);\n+            return null;\n+        });\n@@ -257,36 +255,0 @@\n-    \/**\n-     * On some platforms, a ConnectEvent may be raised and a ConnectionException\n-     * may occur with the message \"Connection timed out: no further information\"\n-     * before our actual connection timeout has expired. In this case, this\n-     * method will be called with a {@code connect} state of {@code ConnectState.RETRY)}\n-     * and we will retry once again.\n-     * @param connect indicates whether the connection was successful or should be retried\n-     * @param failed the failure if the connection failed\n-     * @param exchange the exchange\n-     * @return a completable future that will take care of retrying the connection if needed.\n-     *\/\n-    private CompletableFuture<Void> checkRetryConnect(ConnectState connect, Throwable failed, Exchange<?> exchange) {\n-        \/\/ first check if the connection failed\n-        if (failed != null) return MinimalFuture.failedFuture(failed);\n-        \/\/ then check if the connection should be retried\n-        if (connect == ConnectState.RETRY) {\n-            int attempts = unsuccessfulAttempts;\n-            assert attempts <= 1;\n-            if (debug.on())\n-                debug.log(\"Retrying connect after %d attempts\", attempts);\n-            return connectAsync(exchange);\n-        }\n-        \/\/ Otherwise, the connection was successful;\n-        assert connect == ConnectState.SUCCESS;\n-        return MinimalFuture.completedFuture(null);\n-    }\n-\n-    private boolean canRetryConnect(Throwable e) {\n-        if (!MultiExchange.RETRY_CONNECT) return false;\n-        if (!(e instanceof ConnectException)) return false;\n-        if (unsuccessfulAttempts > 0) return false;\n-        ConnectTimerEvent timer = connectTimerEvent;\n-        if (timer == null) return true;\n-        return timer.deadline().isAfter(TimeSource.now());\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":11,"deletions":49,"binary":false,"changes":60,"status":"modified"}]}