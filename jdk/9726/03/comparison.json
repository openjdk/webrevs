{"files":[{"patch":"@@ -299,0 +299,18 @@\n+\n+  if (ResizePLAB) {\n+    \/\/ See G1EvacStats::compute_desired_plab_sz for the reasoning why this is the\n+    \/\/ expected number of refills.\n+    double const ExpectedNumberOfRefills = G1LastPLABAverageOccupancy \/ TargetPLABWastePct;\n+    \/\/ Add some padding to the threshold to not boost exactly when the targeted refills\n+    \/\/ were reached.\n+    \/\/ E.g. due to limitation of PLAB size to non-humongous objects and region boundaries\n+    \/\/ a thread may experience more refills than expected. Keeping the PLAB waste low\n+    \/\/ is the main goal, so being a bit conservative is better.\n+    double const PadFactor = 1.5;\n+    _tolerated_refills = MAX2(ExpectedNumberOfRefills, 1.0) * PadFactor;\n+  } else {\n+    \/\/ Make the tolerated refills a huge number; -1 because we add one to this\n+    \/\/ value later and it would overflow otherwise.\n+    _tolerated_refills = SIZE_MAX - 1;\n+  }\n+\n@@ -308,0 +326,2 @@\n+    \/\/ The initial PLAB refill should not count, hence the +1 for the first boost.\n+    _plab_fill_counter[state] = _tolerated_refills + 1;\n@@ -309,0 +329,1 @@\n+    _cur_desired_plab_size[state] = word_sz;\n@@ -330,1 +351,8 @@\n-  size_t plab_word_size = _g1h->desired_plab_sz(dest);\n+  size_t plab_word_size = plab_size(dest.type());\n+  size_t next_plab_word_size = plab_word_size;\n+\n+  bool const should_boost_plab = _plab_fill_counter[dest.type()] == 0;\n+  if (should_boost_plab) {\n+    next_plab_word_size = _g1h->clamp_plab_size(next_plab_word_size * 2);\n+  }\n+\n@@ -333,3 +361,4 @@\n-  \/\/ Only get a new PLAB if the allocation fits and it would not waste more than\n-  \/\/ ParallelGCBufferWastePct in the existing buffer.\n-  if ((required_in_plab <= plab_word_size) &&\n+  \/\/ Only get a new PLAB if the allocation fits into the to-be-allocated PLAB and\n+  \/\/ it would not waste more than ParallelGCBufferWastePct in the current PLAB.\n+  \/\/ Boosting the PLAB also increasingly allows more waste to occur.\n+  if ((required_in_plab <= next_plab_word_size) &&\n@@ -339,1 +368,1 @@\n-    alloc_buf->retire();\n+    guarantee(alloc_buf->words_remaining() <= required_in_plab, \"must be\");\n@@ -342,0 +371,9 @@\n+    alloc_buf->retire();\n+\n+    if (should_boost_plab) {\n+      _plab_fill_counter[dest.type()] = _tolerated_refills;\n+    } else {\n+      _plab_fill_counter[dest.type()]--;\n+    }\n+    plab_word_size = next_plab_word_size;\n+    _cur_desired_plab_size[dest.type()] = plab_word_size;\n@@ -379,1 +417,1 @@\n-void G1PLABAllocator::flush_and_retire_stats() {\n+void G1PLABAllocator::flush_and_retire_stats(uint num_workers) {\n@@ -392,0 +430,10 @@\n+\n+  log_trace(gc, plab)(\"PLAB boost: Young %zu -> %zu refills %zu (tolerated %zu) Old %zu -> %zu refills %zu (tolerated %zu)\",\n+                      _g1h->alloc_buffer_stats(G1HeapRegionAttr::Young)->desired_plab_size(num_workers),\n+                      plab_size(G1HeapRegionAttr::Young),\n+                      _num_plab_fills[G1HeapRegionAttr::Young],\n+                      _tolerated_refills,\n+                      _g1h->alloc_buffer_stats(G1HeapRegionAttr::Old)->desired_plab_size(num_workers),\n+                      plab_size(G1HeapRegionAttr::Old),\n+                      _num_plab_fills[G1HeapRegionAttr::Old],\n+                      _tolerated_refills);\n@@ -407,0 +455,4 @@\n+size_t G1PLABAllocator::plab_size(G1HeapRegionAttr which) const {\n+  return _cur_desired_plab_size[which.type()];\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":58,"deletions":6,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -168,1 +168,10 @@\n-  void flush_and_retire_stats();\n+  size_t _plab_fill_counter[G1HeapRegionAttr::Num];\n+  \/\/ Current desired PLAB size incorporating eventual boosting.\n+  size_t _cur_desired_plab_size[G1HeapRegionAttr::Num];\n+\n+  \/\/ The amount of PLAB refills tolerated until boosting PLAB size.\n+  \/\/ This value is the same for all generations because they all use the same\n+  \/\/ resizing logic.\n+  size_t _tolerated_refills;\n+\n+  void flush_and_retire_stats(uint num_workers);\n@@ -184,0 +193,1 @@\n+  size_t plab_size(G1HeapRegionAttr which) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -563,0 +563,6 @@\n+  \/\/ Clamp the given PLAB word size to allowed values. Prevents humongous PLAB sizes\n+  \/\/ for two reasons:\n+  \/\/ * PLABs are allocated using a similar paths as oops, but should\n+  \/\/   never be in a humongous region\n+  \/\/ * Allowing humongous PLABs needlessly churns the region free lists\n+  inline size_t clamp_plab_size(size_t value) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,5 +70,5 @@\n-  \/\/ Prevent humongous PLAB sizes for two reasons:\n-  \/\/ * PLABs are allocated using a similar paths as oops, but should\n-  \/\/   never be in a humongous region\n-  \/\/ * Allowing humongous PLABs needlessly churns the region free lists\n-  return MIN2(_humongous_object_threshold_in_words, gclab_word_size);\n+  return clamp_plab_size(gclab_word_size);\n+}\n+\n+inline size_t G1CollectedHeap::clamp_plab_size(size_t value) const {\n+  return clamp(value, PLAB::min_size(), _humongous_object_threshold_in_words);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,2 +85,5 @@\n-  \/\/ also assume that that buffer is typically half-full, the new desired PLAB\n-  \/\/ size is set to 20 words.\n+  \/\/ also assume that that buffer is typically half-full (G1LastPLABAverageOccupancy),\n+  \/\/ the new desired PLAB size is set to 20 words.\n+  \/\/\n+  \/\/ (This also implies that we expect G1LastPLABAverageOccupancy\/TargetPLABWastePct\n+  \/\/ number of refills during allocation).\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacStats.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+    MergePSSLABSize,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-size_t G1ParScanThreadState::flush(size_t* surviving_young_words) {\n+size_t G1ParScanThreadState::flush(size_t* surviving_young_words, uint num_workers) {\n@@ -118,1 +118,1 @@\n-  _plab_allocator->flush_and_retire_stats();\n+  _plab_allocator->flush_and_retire_stats(num_workers);\n@@ -595,1 +595,1 @@\n-    size_t copied_bytes = pss->flush(_surviving_young_words_total) * HeapWordSize;\n+    size_t copied_bytes = pss->flush(_surviving_young_words_total, _n_workers) * HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-  size_t flush(size_t* surviving_young_words);\n+  size_t flush(size_t* surviving_young_words, uint num_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}