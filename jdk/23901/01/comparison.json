{"files":[{"patch":"@@ -113,0 +113,6 @@\n+  <Event name=\"JavaMonitorNotify\" category=\"Java Application\" label=\"Java Monitor Notify\" description=\"Notifying a Java monitor\" thread=\"true\" stackTrace=\"true\">\n+    <Field type=\"Class\" name=\"monitorClass\" label=\"Monitor Class\" description=\"Class of object waited on\" \/>\n+    <Field type=\"uint\" name=\"notifiedCount\" label=\"Notified Threads\" description=\"Number of actually notified threads\" \/>\n+    <Field type=\"ulong\" contentType=\"address\" name=\"address\" label=\"Monitor Address\" description=\"Address of object waited on\" relation=\"JavaMonitorAddress\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1913,1 +1913,2 @@\n-void ObjectMonitor::INotify(JavaThread* current) {\n+bool ObjectMonitor::INotify(JavaThread* current) {\n+  bool did_notify = false;\n@@ -1945,0 +1946,1 @@\n+    did_notify = true;\n@@ -1981,0 +1983,19 @@\n+  return did_notify;\n+}\n+\n+static void post_monitor_notify_event(EventJavaMonitorNotify* event,\n+                                    ObjectMonitor* monitor,\n+                                    int notified_count) {\n+  assert(event != nullptr, \"invariant\");\n+  assert(monitor != nullptr, \"invariant\");\n+  const Klass* monitor_klass = monitor->object()->klass();\n+  if (is_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n+  \/\/ Set an address that is 'unique enough', such that events close in\n+  \/\/ time and with the same address are likely (but not guaranteed) to\n+  \/\/ belong to the same object.\n+  event->set_address((uintptr_t)monitor);\n+  event->set_notifiedCount(notified_count);\n+  event->commit();\n@@ -1999,0 +2020,2 @@\n+\n+  EventJavaMonitorNotify event;\n@@ -2000,2 +2023,6 @@\n-  INotify(current);\n-  OM_PERFDATA_OP(Notifications, inc(1));\n+  int tally = INotify(current) ? 1 : 0;\n+  OM_PERFDATA_OP(Notifications, inc(tally));\n+\n+  if (event.should_commit()) {\n+    post_monitor_notify_event(&event, this, \/* notified_count = *\/ tally);\n+  }\n@@ -2019,0 +2046,1 @@\n+  EventJavaMonitorNotify event;\n@@ -2022,2 +2050,3 @@\n-    tally++;\n-    INotify(current);\n+    if (INotify(current)) {\n+      tally++;\n+    }\n@@ -2027,0 +2056,4 @@\n+\n+  if (event.should_commit()) {\n+    post_monitor_notify_event(&event, this, \/* notified_count = *\/ tally);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-  void      INotify(JavaThread* current);\n+  bool      INotify(JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,6 @@\n+    <event name=\"jdk.JavaMonitorNotify\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,0 +98,6 @@\n+    <event name=\"jdk.JavaMonitorNotify\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.thread.TestThread;\n+import jdk.test.lib.thread.XRun;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.runtime.TestJavaMonitorNotifyEvent\n+ *\/\n+public class TestJavaMonitorNotifyEvent {\n+\n+    private final static String EVENT_NAME = EventNames.JavaMonitorNotify;\n+    private static final long WAIT_TIME = 123456;\n+\n+    static class Lock {\n+    }\n+\n+    static boolean silenceFindBugsNakedNotify;\n+\n+    public static void main(String[] args) throws Throwable {\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n+\n+        final Lock lock = new Lock();\n+        final CountDownLatch latch = new CountDownLatch(1);\n+\n+        TestThread waitThread = new TestThread(new XRun() {\n+            @Override\n+            public void xrun() throws Throwable {\n+                synchronized (lock) {\n+                    latch.countDown();\n+                    lock.wait(WAIT_TIME);\n+                    silenceFindBugsNakedNotify = false;\n+                }\n+            }\n+        });\n+\n+        try {\n+            recording.start();\n+            waitThread.start();\n+            latch.await();\n+            synchronized (lock) {\n+                silenceFindBugsNakedNotify = true;\n+                lock.notifyAll();\n+            }\n+        } finally {\n+            waitThread.join();\n+            recording.stop();\n+        }\n+\n+        boolean isAnyFound = false;\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            System.out.println(\"Event:\" + event);\n+            if (event.getThread().getJavaThreadId() != Thread.currentThread().threadId()) {\n+                \/\/ Some other notification, skip.\n+                continue;\n+            }\n+            assertFalse(isAnyFound, \"Found more than 1 event\");\n+            isAnyFound = true;\n+            final String lockClassName = lock.getClass().getName().replace('.', '\/');\n+            Events.assertField(event, \"monitorClass.name\").equal(lockClassName);\n+            Events.assertField(event, \"address\").notEqual(0L);\n+            Events.assertField(event, \"notifiedCount\").equal(1);\n+        }\n+        assertTrue(isAnyFound, \"Correct event not found\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaMonitorNotifyEvent.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+    public static final String JavaMonitorNotify = PREFIX + \"JavaMonitorNotify\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}