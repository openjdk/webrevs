{"files":[{"patch":"@@ -951,1 +951,3 @@\n-            \/\/ key is equal to the key of the current element\n+            \/\/ internal path bytes equal the internal path bytes of the current\n+            \/\/ element, or whose key is equal to the key  of the current element\n+            boolean found = false;\n@@ -953,0 +955,1 @@\n+            \/\/ compare path bytes until a match is found or no more entries\n@@ -954,1 +957,0 @@\n-                boolean found = false;\n@@ -956,9 +958,32 @@\n-                    UnixPath p = path.resolve(entry.getFileName());\n-                    UnixFileAttributes attributes = null;\n-                    try {\n-                        attributes = UnixFileAttributes.get(p, false);\n-                        UnixFileKey key = attributes.fileKey();\n-                        if (key.equals(elementKey)) {\n-                            path = path.resolve(entry);\n-                            found = true;\n-                            break;\n+                    Path name = entry.getFileName();\n+                    if (name.compareTo(element) == 0) {\n+                        found = true;\n+                        path = path.resolve(entry);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            \/\/ if no path match found, compare file keys\n+            if (!found) {\n+                try {\n+                    dp = opendir(path);\n+                } catch (UnixException x) {\n+                    x.rethrowAsIOException(path);\n+                }\n+\n+                try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n+                    for (Path entry : entries) {\n+                        Path name = entry.getFileName();\n+                        UnixPath p = path.resolve(name);\n+                        UnixFileAttributes attributes = null;\n+                        try {\n+                            attributes = UnixFileAttributes.get(p, false);\n+                            UnixFileKey key = attributes.fileKey();\n+                            if (key.equals(elementKey)) {\n+                                found = true;\n+                                path = path.resolve(entry);\n+                                break;\n+                            }\n+                        } catch (UnixException ignore) {\n+                            continue;\n@@ -966,2 +991,0 @@\n-                    } catch (UnixException ignore) {\n-                        continue;\n@@ -971,1 +994,0 @@\n-                \/\/ Fallback which should in theory never happen\n@@ -973,0 +995,1 @@\n+                    \/\/ Fallback which should in theory never happen\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-        System.out.println(\"sub: \" + sub);\n+        System.err.println(\"sub: \" + sub);\n@@ -156,1 +156,1 @@\n-        System.out.println(\"LINK: \" + LINK + \" -> \" + sub);\n+        System.err.println(\"LINK: \" + LINK + \" -> \" + sub);\n@@ -158,1 +158,1 @@\n-        System.out.println(\"p: \" + p);\n+        System.err.println(\"p: \" + p);\n@@ -160,1 +160,1 @@\n-        System.out.println(\"path:      \" + path);\n+        System.err.println(\"path:      \" + path);\n@@ -165,1 +165,1 @@\n-        System.out.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n+        System.err.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n@@ -184,1 +184,1 @@\n-        System.out.println(\"aaa: \" + aaa + \" -> \" + sub);\n+        System.err.println(\"aaa: \" + aaa + \" -> \" + sub);\n@@ -187,1 +187,1 @@\n-        System.out.println(\"bbb: \" + bbb + \" -> \" + sub);\n+        System.err.println(\"bbb: \" + bbb + \" -> \" + sub);\n@@ -190,1 +190,1 @@\n-        System.out.println(\"path:      \" + path);\n+        System.err.println(\"path:      \" + path);\n@@ -195,1 +195,1 @@\n-        System.out.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n+        System.err.println(\"no follow: \" + path.toRealPath(NOFOLLOW_LINKS));\n@@ -200,1 +200,1 @@\n-        System.out.println(path.toRealPath());\n+        System.err.println(path.toRealPath());\n","filename":"test\/jdk\/java\/nio\/file\/Path\/ToRealPath.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio.file;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Random;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+@State(Scope.Benchmark)\n+public class ToRealPath {\n+\n+    static Random RND = new Random(17_000_126);\n+\n+    static final String NAME = \"RealPath\";\n+    static final int LEN = NAME.length();\n+\n+    Path root;\n+    Path[] files;\n+\n+    @Setup\n+    public void init() throws IOException {\n+        \/\/ root the test files at CWD\/NAME\n+        root = Path.of(System.getProperty(\"user.dir\")).resolve(NAME);\n+\n+        \/\/ populate files array\n+        StringBuilder sb = new StringBuilder();\n+        files = new Path[100];\n+        for (int i = 0; i < files.length; i++) {\n+            \/\/ create directories up to a depth of 9, inclusive\n+            sb.setLength(0);\n+            int depth = RND.nextInt(10);\n+            for (int j = 0; j < depth; j++) {\n+                sb.append(\"dir\");\n+                sb.append(j);\n+                sb.append(File.separatorChar);\n+            }\n+            Path dir = root.resolve(sb.toString());\n+            Files.createDirectories(dir);\n+\n+            \/\/ set the file prefix with random case conversion\n+            String prefix;\n+            if (RND.nextBoolean()) {\n+                sb.setLength(0);\n+                for (int k = 0; k < LEN; k++) {\n+                    char c = NAME.charAt(k);\n+                    sb.append(RND.nextBoolean()\n+                              ? Character.toLowerCase(c)\n+                              : Character.toUpperCase(c));\n+                }\n+                prefix = sb.append(i).toString();\n+            } else {\n+                prefix = NAME + i;\n+            }\n+\n+            \/\/ create the file\n+            Path tmpFile = Files.createTempFile(dir, prefix, \".tmp\");\n+\n+            \/\/ set the array path to a version with a lower case name\n+            String tmpName = tmpFile.getFileName().toString().toLowerCase();\n+            files[i] = tmpFile.getParent().resolve(tmpName);\n+        }\n+    }\n+\n+    @TearDown\n+    public void cleanup() throws IOException {\n+        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file,\n+                                                 BasicFileAttributes attrs)\n+                    throws IOException\n+                {\n+                    Files.delete(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir,\n+                                                          IOException e)\n+                    throws IOException\n+                {\n+                    if (e == null) {\n+                        Files.delete(dir);\n+                        return FileVisitResult.CONTINUE;\n+                    } else {\n+                        \/\/ directory iteration failed\n+                        throw e;\n+                    }\n+                }\n+            });\n+    }\n+\n+    @Benchmark\n+    public Path noFollowLinks() throws IOException {\n+        int i = RND.nextInt(0, files.length);\n+        return files[i].toRealPath(LinkOption.NOFOLLOW_LINKS);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/file\/ToRealPath.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}