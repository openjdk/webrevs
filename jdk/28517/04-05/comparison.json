{"files":[{"patch":"@@ -1723,0 +1723,3 @@\n+\/\/ Matches exact and inexact type check IR shapes during parsing.\n+\/\/ On successful match, returns type checked object node and its type after successful check\n+\/\/ as out parameters.\n@@ -1728,2 +1731,3 @@\n-  \/\/ Look for opportunities to sharpen the type of a node\n-  \/\/ whose klass is compared with a constant klass.\n+  \/\/ Look for opportunities to sharpen the type of a node whose klass is compared with a constant klass.\n+  \/\/ The constant klass being tested against can come from many bytecode instructions (implicitly or explicitly),\n+  \/\/ and also from profile data used by speculative casts.\n@@ -1800,0 +1804,1 @@\n+  \/\/ Insert a cast node with a narrowed type after a successful type check.\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.HashSet;\n@@ -44,0 +45,1 @@\n+import java.util.Set;\n@@ -48,1 +50,2 @@\n-    static final String TEST_CLASS_NAME = TestSubtypeCheckTypeInfo.class.getName();\n+    static final Class<TestSubtypeCheckTypeInfo> THIS_CLASS = TestSubtypeCheckTypeInfo.class;\n+    static final String TEST_CLASS_NAME = THIS_CLASS.getName();\n@@ -68,9 +71,2 @@\n-            int total = 18; \/\/ 18 test cases in total\n-            int success = parseOutput(output);\n-            if (success == total) {\n-                System.out.println(\"TEST PASSED\");\n-            } else {\n-                System.out.printf(\"TEST FAILED: %d out of %d test cases passed\\n\", success, total);\n-                System.out.println(analyzer.getOutput());\n-                throw new AssertionError(\"TEST FAILED\");\n-            }\n+            parseOutput(output);\n+            System.out.println(\"TEST PASSED\");\n@@ -105,0 +101,3 @@\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfNulls);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceNulls);\n@@ -289,0 +288,22 @@\n+    @InlineFailure\n+    \/\/ @ 20   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfNulls(A o, boolean cond) {\n+        A recv = (cond ? o : null);\n+        if (recv instanceof B) {\n+            o.m();\n+        }\n+    }\n+\n+    @InlineFailure\n+    \/\/Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 13   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 20   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceNulls(A o, boolean cond) {\n+        A recv = (cond ? o : null);\n+        if (B.class.isInstance(recv)) {\n+            o.m();\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n@@ -343,2 +364,1 @@\n-    static int parseOutput(List<String> output) {\n-        int successCount = 0;\n+    static void parseOutput(List<String> output) {\n@@ -347,0 +367,2 @@\n+        Set<String> passedTests = new HashSet();\n+        Set<String> failedTests = new HashSet();\n@@ -351,1 +373,1 @@\n-                successCount += (validateInliningOutput(inlineTree.toString()) ? 1 : 0);\n+                validateInliningOutput(inlineTree.toString(), passedTests, failedTests);\n@@ -357,2 +379,9 @@\n-        successCount += (validateInliningOutput(inlineTree.toString()) ? 1 : 0);\n-        return successCount;\n+        validateInliningOutput(inlineTree.toString(), passedTests, failedTests);\n+\n+        if (!failedTests.isEmpty()) {\n+            String msg = String.format(\"TEST FAILED: %d test cases failed\", failedTests.size());\n+            throw new AssertionError(msg);\n+        } else if (passedTests.size() != totalTestCount()) {\n+            String msg = String.format(\"TEST FAILED: %d out of %d test cases passed\", passedTests.size(), totalTestCount());\n+            throw new AssertionError(msg);\n+        }\n@@ -365,1 +394,1 @@\n-    static boolean validateInliningOutput(String inlineTree) {\n+    static boolean validateInliningOutput(String inlineTree, Set<String> passedTests, Set<String> failedTests) {\n@@ -372,2 +401,7 @@\n-                if (!validate(inlineTree, testMethod.getAnnotation(InlineSuccess.class)) ||\n-                    !validate(inlineTree, testMethod.getAnnotation(InlineFailure.class))) {\n+                if (validate(inlineTree, testMethod.getAnnotation(InlineSuccess.class)) &&\n+                    validate(inlineTree, testMethod.getAnnotation(InlineFailure.class))) {\n+                    System.out.println(\": SUCCESS\");\n+                    passedTests.add(testName);\n+                    return true;\n+                } else {\n+                    failedTests.add(testName);\n@@ -376,2 +410,0 @@\n-                System.out.println(\": SUCCESS\");\n-                return true;\n@@ -396,1 +428,1 @@\n-            validatePatterns(message, ann.shouldContain(), ann.shouldNotContain());\n+            return validatePatterns(message, ann.shouldContain(), ann.shouldNotContain());\n@@ -417,0 +449,15 @@\n+    static int totalTestCount() {\n+        int count = 0;\n+        for (Method m : THIS_CLASS.getDeclaredMethods()) {\n+            if (m.isAnnotationPresent(InlineSuccess.class) || m.isAnnotationPresent(InlineFailure.class)) {\n+                String testName = m.getName();\n+                if (testName.startsWith(\"test\")) {\n+                    count++;\n+                } else {\n+                    throw new InternalError(\"wrong test name: \" + testName);\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestSubtypeCheckTypeInfo.java","additions":68,"deletions":21,"binary":false,"changes":89,"status":"modified"}]}