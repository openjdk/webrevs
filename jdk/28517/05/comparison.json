{"files":[{"patch":"@@ -564,0 +564,14 @@\n+bool DirectiveSet::should_delay_inline(ciMethod* inlinee) {\n+  inlinee->check_is_loaded();\n+  VM_ENTRY_MARK;\n+  methodHandle mh(THREAD, inlinee->get_Method());\n+\n+  if (_inlinematchers != nullptr) {\n+    return matches_inline(mh, InlineMatcher::delay_inline);\n+  }\n+  if (!CompilerDirectivesIgnoreCompileCommandsOption) {\n+    return CompilerOracle::should_delay_inline(mh);\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+  bool should_delay_inline(ciMethod* inlinee);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,0 +483,4 @@\n+bool CompilerOracle::should_delay_inline(const methodHandle& method) {\n+  return (check_predicate(CompileCommandEnum::DelayInline, method));\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  option(DelayInline,  \"delayinline\", Bool) \\\n@@ -153,0 +154,3 @@\n+  \/\/ Tells whether we want to delay inlining of this method\n+  static bool should_delay_inline(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+      delay_inline,\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -985,1 +985,2 @@\n-    return should_delay_string_inlining(call_method, jvms) ||\n+    return C->directive()->should_delay_inline(call_method) ||\n+           should_delay_string_inlining(call_method, jvms) ||\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-      bool should_delay = C->should_delay_inlining();\n+      bool should_delay = C->should_delay_inlining() || C->directive()->should_delay_inline(callee);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/subtypenode.hpp\"\n@@ -1722,0 +1723,76 @@\n+\/\/ Matches exact and inexact type check IR shapes during parsing.\n+\/\/ On successful match, returns type checked object node and its type after successful check\n+\/\/ as out parameters.\n+static bool match_type_check(PhaseGVN& gvn,\n+                             BoolTest::mask btest,\n+                             Node* con, const Type* tcon,\n+                             Node* val, const Type* tval,\n+                             Node** obj, const TypeOopPtr** cast_type) { \/\/ out-parameters\n+  \/\/ Look for opportunities to sharpen the type of a node whose klass is compared with a constant klass.\n+  \/\/ The constant klass being tested against can come from many bytecode instructions (implicitly or explicitly),\n+  \/\/ and also from profile data used by speculative casts.\n+  if (btest == BoolTest::eq && tcon->isa_klassptr()) {\n+    \/\/ Found:\n+    \/\/   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])\n+    \/\/ or the narrowOop equivalent.\n+    (*obj) = extract_obj_from_klass_load(&gvn, val);\n+    (*cast_type) = tcon->isa_klassptr()->as_instance_type();\n+    return true; \/\/ found\n+  }\n+\n+  \/\/ Match an instanceof check.\n+  \/\/ During parsing its IR shape is not canonicalized yet.\n+  \/\/\n+  \/\/             obj superklass\n+  \/\/              |    |\n+  \/\/           SubTypeCheck\n+  \/\/                |\n+  \/\/               Bool [eq] \/ [ne]\n+  \/\/                |\n+  \/\/                If\n+  \/\/               \/ \\\n+  \/\/              T   F\n+  \/\/               \\ \/\n+  \/\/              Region\n+  \/\/                 \\  ConI ConI\n+  \/\/                  \\  |  \/\n+  \/\/          val ->    Phi  ConI  <- con\n+  \/\/                     \\  \/\n+  \/\/                     CmpI\n+  \/\/                      |\n+  \/\/                    Bool [btest]\n+  \/\/                      |\n+  \/\/\n+  if (tval->isa_int() && val->is_Phi() && val->in(0)->as_Region()->is_diamond()) {\n+    RegionNode* diamond = val->in(0)->as_Region();\n+    IfNode* if1 = diamond->in(1)->in(0)->as_If();\n+    BoolNode* b1 = if1->in(1)->isa_Bool();\n+    if (b1 != nullptr && b1->in(1)->isa_SubTypeCheck()) {\n+      assert(b1->_test._test == BoolTest::eq ||\n+             b1->_test._test == BoolTest::ne, \"%d\", b1->_test._test);\n+\n+      ProjNode* success_proj = if1->proj_out(b1->_test._test == BoolTest::eq ? 1 : 0);\n+      int idx = diamond->find_edge(success_proj);\n+      assert(idx == 1 || idx == 2, \"\");\n+      Node* vcon = val->in(idx);\n+\n+      assert(val->find_edge(con) > 0, \"\");\n+      if ((btest == BoolTest::eq && vcon == con) || (btest == BoolTest::ne && vcon != con)) {\n+        SubTypeCheckNode* sub = b1->in(1)->as_SubTypeCheck();\n+        Node* obj_or_subklass = sub->in(SubTypeCheckNode::ObjOrSubKlass);\n+        Node* superklass = sub->in(SubTypeCheckNode::SuperKlass);\n+\n+        if (gvn.type(obj_or_subklass)->isa_oopptr()) {\n+          const TypeKlassPtr* klass_ptr_type = gvn.type(superklass)->is_klassptr();\n+          const TypeKlassPtr* improved_klass_ptr_type = klass_ptr_type->try_improve();\n+\n+          (*obj) = obj_or_subklass;\n+          (*cast_type) = improved_klass_ptr_type->cast_to_exactness(false)->as_instance_type();\n+          return true; \/\/ found\n+        }\n+      }\n+    }\n+  }\n+  return false; \/\/ not found\n+}\n+\n@@ -1725,29 +1802,23 @@\n-  \/\/ Look for opportunities to sharpen the type of a node\n-  \/\/ whose klass is compared with a constant klass.\n-  if (btest == BoolTest::eq && tcon->isa_klassptr()) {\n-    Node* obj = extract_obj_from_klass_load(&_gvn, val);\n-    const TypeOopPtr* con_type = tcon->isa_klassptr()->as_instance_type();\n-    if (obj != nullptr && (con_type->isa_instptr() || con_type->isa_aryptr())) {\n-       \/\/ Found:\n-       \/\/   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])\n-       \/\/ or the narrowOop equivalent.\n-       const Type* obj_type = _gvn.type(obj);\n-       const TypeOopPtr* tboth = obj_type->join_speculative(con_type)->isa_oopptr();\n-       if (tboth != nullptr && tboth->klass_is_exact() && tboth != obj_type &&\n-           tboth->higher_equal(obj_type)) {\n-          \/\/ obj has to be of the exact type Foo if the CmpP succeeds.\n-          int obj_in_map = map()->find_edge(obj);\n-          JVMState* jvms = this->jvms();\n-          if (obj_in_map >= 0 &&\n-              (jvms->is_loc(obj_in_map) || jvms->is_stk(obj_in_map))) {\n-            TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);\n-            const Type* tcc = ccast->as_Type()->type();\n-            assert(tcc != obj_type && tcc->higher_equal(obj_type), \"must improve\");\n-            \/\/ Delay transform() call to allow recovery of pre-cast value\n-            \/\/ at the control merge.\n-            _gvn.set_type_bottom(ccast);\n-            record_for_igvn(ccast);\n-            \/\/ Here's the payoff.\n-            replace_in_map(obj, ccast);\n-          }\n-       }\n+  Node* obj = nullptr;\n+  const TypeOopPtr* cast_type = nullptr;\n+  \/\/ Insert a cast node with a narrowed type after a successful type check.\n+  if (match_type_check(_gvn, btest, con, tcon, val, tval,\n+                       &obj, &cast_type)) {\n+    assert(obj != nullptr && cast_type != nullptr, \"missing type check info\");\n+    const Type* obj_type = _gvn.type(obj);\n+    const TypeOopPtr* tboth = obj_type->join_speculative(cast_type)->isa_oopptr();\n+    if (tboth != nullptr && tboth != obj_type && tboth->higher_equal(obj_type)) {\n+      int obj_in_map = map()->find_edge(obj);\n+      JVMState* jvms = this->jvms();\n+      if (obj_in_map >= 0 &&\n+          (jvms->is_loc(obj_in_map) || jvms->is_stk(obj_in_map))) {\n+        TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);\n+        const Type* tcc = ccast->as_Type()->type();\n+        assert(tcc != obj_type && tcc->higher_equal(obj_type), \"must improve\");\n+        \/\/ Delay transform() call to allow recovery of pre-cast value\n+        \/\/ at the control merge.\n+        _gvn.set_type_bottom(ccast);\n+        record_for_igvn(ccast);\n+        \/\/ Here's the payoff.\n+        replace_in_map(obj, ccast);\n+      }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":100,"deletions":29,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -0,0 +1,479 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary 8372634\n+ *\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/\n+ *\n+ * @run driver compiler.inlining.TestSubtypeCheckTypeInfo\n+ *\/\n+package compiler.inlining;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Method;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestSubtypeCheckTypeInfo {\n+    static final Class<TestSubtypeCheckTypeInfo> THIS_CLASS = TestSubtypeCheckTypeInfo.class;\n+    static final String TEST_CLASS_NAME = THIS_CLASS.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-showversion\",\n+                \"-XX:-TieredCompilation\", \"-Xbatch\", \"-XX:CICompilerCount=1\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                \"-XX:CompileCommand=quiet\",\n+                \"-XX:CompileCommand=compileonly,\" +  TEST_CLASS_NAME + \"::test*\",\n+                \"-XX:CompileCommand=delayinline,\" +  TEST_CLASS_NAME + \"::lateInline*\",\n+                TestSubtypeCheckTypeInfo.Launcher.class.getName());\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        \/\/ The test is applicable only to C2 (present in Server VM).\n+        if (analyzer.getStderr().contains(\"Server VM\")) {\n+            List<String> output = analyzer.asLinesWithoutVMWarnings();\n+\n+            parseOutput(output);\n+            System.out.println(\"TEST PASSED\");\n+        }\n+    }\n+\n+    static class Launcher {\n+        public static void main(String[] args) {\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOf);\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfCondPre);\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfCondPost);\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstance);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceCondPre);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceCondPost);\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfLate);\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfLateCondPre);\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfLateCondPost);\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceLate);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceLateCondPre);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceLateCondPost);\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfCondLate);\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfCondLatePre);\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfCondLatePost);\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceCondLate);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceCondLatePre);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceCondLatePost);\n+\n+            runTestCase(TestSubtypeCheckTypeInfo::testInstanceOfNulls);\n+            runTestCase(TestSubtypeCheckTypeInfo::testIsInstanceNulls);\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineSuccess\n+    \/\/ @ 8   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testInstanceOf(A o, boolean cond) {\n+        if (o instanceof B) {\n+            o.m();\n+        }\n+    }\n+\n+    @InlineSuccess\n+    \/\/ @ 12   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testInstanceOfCondPre(A o, boolean cond) {\n+        if (cond && (o instanceof B)) {\n+            o.m();\n+        }\n+    }\n+\n+    @InlineSuccess\n+    \/\/ @ 12   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testInstanceOfCondPost(A o, boolean cond) {\n+        if ((o instanceof B) && cond) {\n+            o.m();\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineSuccess\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 3   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 10   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testIsInstance(A o, boolean cond) {\n+        if (B.class.isInstance(o)) {\n+            o.m();\n+        }\n+    }\n+\n+    @InlineSuccess\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 7   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 14   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testIsInstanceCondPre(A o, boolean cond) {\n+        if (cond && B.class.isInstance(o)) {\n+            o.m();\n+        }\n+    }\n+\n+    @InlineSuccess\n+    \/\/ @ 3   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 14   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testIsInstanceCondPost(A o, boolean cond) {\n+        if (B.class.isInstance(o) && cond) {\n+            o.m();\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineSuccess\n+    \/\/ @ 5   compiler.inlining.TestSubtypeCheckTypeInfo::lateInline (9 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 5   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testInstanceOfLate(A o, boolean cond) {\n+        \/\/ if (o instanceof B) { o.m(); }\n+        lateInline(o, o instanceof B);\n+    }\n+\n+    @InlineFailure\n+    \/\/ @ 17   compiler.inlining.TestSubtypeCheckTypeInfo::lateInline (9 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 5   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfLateCondPre(A o, boolean cond) {\n+        \/\/ if (cond && o instanceof B) { o.m(); }\n+        lateInline(o, cond && (o instanceof B));\n+    }\n+\n+    @InlineFailure\n+    \/\/ @ 17   compiler.inlining.TestSubtypeCheckTypeInfo::lateInline (9 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 5   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfLateCondPost(A o, boolean cond) {\n+        \/\/ if ((o instanceof B) && cond) { o.m(); }\n+        lateInline(o, (o instanceof B) && cond);\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineSuccess\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 4   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 7   compiler.inlining.TestSubtypeCheckTypeInfo::lateInline (9 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 5   compiler.inlining.TestSubtypeCheckTypeInfo$B::m (1 bytes)   inline (hot)\n+    static void testIsInstanceLate(A o, boolean cond) {\n+        \/\/ if (B.class.isInstance(o)) { o.m(); }\n+        lateInline(o, B.class.isInstance(o));\n+    }\n+\n+    @InlineFailure\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 8   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 19   compiler.inlining.TestSubtypeCheckTypeInfo::lateInline (9 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 5   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceLateCondPre(A o, boolean cond) {\n+        \/\/ if (cond && B.class.isInstance(o)) { o.m(); }\n+        lateInline(o, cond && (B.class.isInstance(o)));\n+    }\n+\n+    @InlineFailure\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 4   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 19   compiler.inlining.TestSubtypeCheckTypeInfo::lateInline (9 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 5   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceLateCondPost(A o, boolean cond) {\n+        \/\/ if (B.class.isInstance(o) && cond) { o.m(); }\n+        lateInline(o, (B.class.isInstance(o) && cond));\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineFailure\n+    \/\/ @ 2   compiler.inlining.TestSubtypeCheckTypeInfo::lateInlineInstanceOfCondPre (17 bytes)   inline (hot)   late inline succeeded\n+    \/\/ @ 9   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfCondLate(A a, boolean cond) {\n+        if (lateInlineInstanceOfCondPre(a, true)) {\n+            a.m();\n+        }\n+    }\n+\n+    @InlineFailure\n+    \/\/ @ 2   compiler.inlining.TestSubtypeCheckTypeInfo::lateInlineInstanceOfCondPre (17 bytes)   inline (hot)   late inline succeeded\n+    \/\/ @ 9   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfCondLatePre(A a, boolean cond) {\n+        if (lateInlineInstanceOfCondPre(a, cond)) {\n+            a.m();\n+        }\n+    }\n+\n+    @InlineFailure\n+    \/\/ @ 2   compiler.inlining.TestSubtypeCheckTypeInfo::lateInlineInstanceOfCondPost (17 bytes)   inline (hot)   late inline succeeded\n+    \/\/ @ 9   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfCondLatePost(A a, boolean cond) {\n+        if (lateInlineInstanceOfCondPost(a, cond)) {\n+            a.m();\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineFailure\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 2   compiler.inlining.TestSubtypeCheckTypeInfo::lateInlineIsInstanceCondPre (19 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 7   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 9   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceCondLate(A a, boolean cond) {\n+        if (lateInlineIsInstanceCondPre(a, true)) {\n+            a.m();\n+        }\n+    }\n+\n+    @InlineFailure\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 2   compiler.inlining.TestSubtypeCheckTypeInfo::lateInlineIsInstanceCondPre (19 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 7   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 9   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceCondLatePre(A a, boolean cond) {\n+        if (lateInlineIsInstanceCondPre(a, cond)) {\n+            a.m();\n+        }\n+    }\n+\n+    @InlineFailure\n+    \/\/ Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 2   compiler.inlining.TestSubtypeCheckTypeInfo::lateInlineIsInstanceCondPost (19 bytes)   inline (hot)   late inline succeeded\n+    \/\/   @ 3   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 9   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceCondLatePost(A a, boolean cond) {\n+        if (lateInlineIsInstanceCondPost(a, cond)) {\n+            a.m();\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    @InlineFailure\n+    \/\/ @ 20   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testInstanceOfNulls(A o, boolean cond) {\n+        A recv = (cond ? o : null);\n+        if (recv instanceof B) {\n+            o.m();\n+        }\n+    }\n+\n+    @InlineFailure\n+    \/\/Inlining _isInstance on constant Class compiler\/inlining\/TestSubtypeCheckTypeInfo$B\n+    \/\/ @ 13   java.lang.Class::isInstance (0 bytes)   (intrinsic)\n+    \/\/ @ 20   compiler.inlining.TestSubtypeCheckTypeInfo$A::m (0 bytes)   failed to inline: virtual call\n+    static void testIsInstanceNulls(A o, boolean cond) {\n+        A recv = (cond ? o : null);\n+        if (B.class.isInstance(recv)) {\n+            o.m();\n+        }\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    static abstract class A {\n+        public abstract void m();\n+    }\n+    static abstract class B extends A {\n+        public void m() {}\n+    }\n+\n+    static class C extends A {\n+        public void m() {}\n+    }\n+\n+    static void lateInline(A o, boolean cond) {\n+        if (cond) {\n+            o.m();\n+        }\n+    }\n+\n+    static boolean lateInlineInstanceOfCondPre(A o, boolean cond) {\n+        return cond && (o instanceof B);\n+    }\n+\n+    static boolean lateInlineInstanceOfCondPost(A o, boolean cond) {\n+        return (o instanceof B) && cond;\n+    }\n+\n+    static boolean lateInlineIsInstanceCondPre(A o, boolean cond) {\n+        return cond && B.class.isInstance(o);\n+    }\n+    static boolean lateInlineIsInstanceCondPost(A o, boolean cond) {\n+        return B.class.isInstance(o) && cond;\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    static final String INLINE_SUCCESS_MESSAGE = \"B::m (1 bytes)   inline (hot)\";\n+    static final String INLINE_FAILURE_MESSAGE = \"A::m (0 bytes)   failed to inline: virtual call\";\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    public @interface InlineSuccess {\n+        String[] shouldContain()    default INLINE_SUCCESS_MESSAGE;\n+        String[] shouldNotContain() default INLINE_FAILURE_MESSAGE;\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    public @interface InlineFailure {\n+        String[] shouldContain()    default INLINE_FAILURE_MESSAGE;\n+        String[] shouldNotContain() default INLINE_SUCCESS_MESSAGE;\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    \/\/ Parse compilation log (-XX:+PrintCompilation -XX:+PrintInlining output).\n+    static void parseOutput(List<String> output) {\n+        Pattern compilation = Pattern.compile(\"^\\\\d+\\\\s+\\\\d+.*\");\n+        StringBuilder inlineTree = new StringBuilder();\n+        Set<String> passedTests = new HashSet();\n+        Set<String> failedTests = new HashSet();\n+        for (String line : output) {\n+            \/\/ Detect start of next compilation.\n+            if (compilation.matcher(line).matches()) {\n+                \/\/ Parse output for previous compilation.\n+                validateInliningOutput(inlineTree.toString(), passedTests, failedTests);\n+                inlineTree = new StringBuilder(); \/\/ reset\n+            }\n+            inlineTree.append(line);\n+        }\n+        \/\/ Process last compilation\n+        validateInliningOutput(inlineTree.toString(), passedTests, failedTests);\n+\n+        if (!failedTests.isEmpty()) {\n+            String msg = String.format(\"TEST FAILED: %d test cases failed\", failedTests.size());\n+            throw new AssertionError(msg);\n+        } else if (passedTests.size() != totalTestCount()) {\n+            String msg = String.format(\"TEST FAILED: %d out of %d test cases passed\", passedTests.size(), totalTestCount());\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    \/\/ Sample:\n+    \/\/    213   42    b        compiler.inlining.TestSubtypeCheckTypeInfo::testIsInstanceCondLatePost (13 bytes)\n+    static final Pattern TEST_CASE = Pattern.compile(\"^\\\\d+\\\\s+\\\\d+\\\\s+b\\\\s+\" + TEST_CLASS_NAME + \"::(\\\\w+) .*\");\n+\n+    static boolean validateInliningOutput(String inlineTree, Set<String> passedTests, Set<String> failedTests) {\n+        Matcher m = TEST_CASE.matcher(inlineTree);\n+        if (m.matches()) {\n+            String testName = m.group(1);\n+            System.out.print(testName);\n+            try {\n+                Method testMethod = TestSubtypeCheckTypeInfo.class.getDeclaredMethod(testName, A.class, boolean.class);\n+                if (validate(inlineTree, testMethod.getAnnotation(InlineSuccess.class)) &&\n+                    validate(inlineTree, testMethod.getAnnotation(InlineFailure.class))) {\n+                    System.out.println(\": SUCCESS\");\n+                    passedTests.add(testName);\n+                    return true;\n+                } else {\n+                    failedTests.add(testName);\n+                    return false;\n+                }\n+            } catch (NoSuchMethodException e) {\n+                System.out.println(\": FAILURE: Missing test info for \" + testName + \": \" + inlineTree);\n+                throw new InternalError(e);\n+            }\n+        } else {\n+            return false; \/\/ not a test method; ignored\n+        }\n+    }\n+\n+    static boolean validate(String message, InlineSuccess ann) {\n+        if (ann != null) {\n+            return validatePatterns(message, ann.shouldContain(), ann.shouldNotContain());\n+        }\n+        return true; \/\/ no patterns to validate\n+    }\n+\n+    static boolean validate(String message, InlineFailure ann) {\n+        if (ann != null) {\n+            return validatePatterns(message, ann.shouldContain(), ann.shouldNotContain());\n+        }\n+        return true; \/\/ no patterns to validate\n+    }\n+\n+    static boolean validatePatterns(String message, String[] shouldContain, String[] shouldNotContain) {\n+        for (String pattern : shouldContain) {\n+            if (!message.contains(pattern)) {\n+                System.out.printf(\": FAILURE: '%s' not found in '%s'\\n\", pattern, message);\n+                return false;\n+            }\n+        }\n+        for (String pattern : shouldNotContain) {\n+            if (message.contains(pattern)) {\n+                System.out.printf(\": FAILURE: '%s' found in '%s'\\n\", pattern, message);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    static int totalTestCount() {\n+        int count = 0;\n+        for (Method m : THIS_CLASS.getDeclaredMethods()) {\n+            if (m.isAnnotationPresent(InlineSuccess.class) || m.isAnnotationPresent(InlineFailure.class)) {\n+                String testName = m.getName();\n+                if (testName.startsWith(\"test\")) {\n+                    count++;\n+                } else {\n+                    throw new InternalError(\"wrong test name: \" + testName);\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    \/* =========================================================== *\/\n+\n+    interface TestCase {\n+        void run(A o, boolean cond);\n+    }\n+\n+    static void runTestCase(TestCase t) {\n+        A[] receivers = new A[] { new B() {}, new B() {}, new B() {}, new C() {}, new C() {}};\n+        for (int i = 0; i < 20_000; i++) {\n+            \/\/ Pollute type profile and branch frequencies.\n+            A recv = receivers[i % receivers.length];\n+            boolean cond = (i % 2 == 0);\n+            t.run(recv, cond);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestSubtypeCheckTypeInfo.java","additions":479,"deletions":0,"binary":false,"changes":479,"status":"added"},{"patch":"@@ -135,1 +135,1 @@\n-        t.runTest(methodObjClassCast,  false,  svalue);\n+        t.runTest(methodObjClassCast,  false, svalue);\n@@ -137,1 +137,1 @@\n-        t.runTest(methodIntClassCast,  true,  svalue);\n+        t.runTest(methodIntClassCast,  false, svalue);\n@@ -141,1 +141,1 @@\n-        t.runTest(methodPrimClassCast, true,  svalue);\n+        t.runTest(methodPrimClassCast, false, svalue);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}