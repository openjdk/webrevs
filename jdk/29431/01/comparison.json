{"files":[{"patch":"@@ -1,258 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.ConnectException;\n-import java.net.InetSocketAddress;\n-import java.net.NoRouteToHostException;\n-import java.net.ProxySelector;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpClient.Version;\n-import java.net.http.HttpConnectTimeoutException;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.net.http.HttpResponse;\n-import java.net.http.HttpResponse.BodyHandlers;\n-import java.nio.channels.UnresolvedAddressException;\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.CompletionException;\n-import org.testng.annotations.DataProvider;\n-import static java.lang.System.out;\n-import static java.net.http.HttpClient.Builder.NO_PROXY;\n-import static java.net.http.HttpClient.Version.HTTP_1_1;\n-import static java.net.http.HttpClient.Version.HTTP_2;\n-import static java.time.Duration.*;\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-import static org.testng.Assert.fail;\n-\n-public abstract class AbstractConnectTimeout {\n-\n-    static final Duration NO_DURATION = null;\n-\n-    static List<List<Duration>> TIMEOUTS = List.of(\n-                    \/\/ connectTimeout   HttpRequest timeout\n-            Arrays.asList( NO_DURATION,   ofMillis(100) ),\n-            Arrays.asList( NO_DURATION,   ofNanos(1)    ),\n-\n-            Arrays.asList( ofMillis(100), NO_DURATION   ),\n-            Arrays.asList( ofNanos(1),    NO_DURATION   ),\n-\n-            Arrays.asList( ofMillis(100), ofMinutes(1)  ),\n-            Arrays.asList( ofNanos(1),    ofMinutes(1)  )\n-    );\n-\n-    static final List<String> METHODS = List.of(\"GET\", \"POST\");\n-    static final List<Version> VERSIONS = List.of(HTTP_2, HTTP_1_1);\n-    static final List<String> SCHEMES = List.of(\"https\", \"http\");\n-\n-    @DataProvider(name = \"variants\")\n-    public Object[][] variants() {\n-        List<Object[]> l = new ArrayList<>();\n-        for (List<Duration> timeouts : TIMEOUTS) {\n-           Duration connectTimeout = timeouts.get(0);\n-           Duration requestTimeout = timeouts.get(1);\n-           for (String method: METHODS) {\n-            for (String scheme : SCHEMES) {\n-             for (Version requestVersion : VERSIONS) {\n-              l.add(new Object[] {requestVersion, scheme, method, connectTimeout, requestTimeout});\n-        }}}}\n-        return l.stream().toArray(Object[][]::new);\n-    }\n-\n-    static final ProxySelector EXAMPLE_DOT_COM_PROXY = ProxySelector.of(\n-            InetSocketAddress.createUnresolved(\"example.com\", 8080));\n-\n-    \/\/@Test(dataProvider = \"variants\")\n-    protected void timeoutNoProxySync(Version requestVersion,\n-                                      String scheme,\n-                                      String method,\n-                                      Duration connectTimeout,\n-                                      Duration requestTimeout)\n-        throws Exception\n-    {\n-        timeoutSync(requestVersion, scheme, method, connectTimeout, requestTimeout, NO_PROXY);\n-    }\n-\n-    \/\/@Test(dataProvider = \"variants\")\n-    protected void timeoutWithProxySync(Version requestVersion,\n-                                        String scheme,\n-                                        String method,\n-                                        Duration connectTimeout,\n-                                        Duration requestTimeout)\n-        throws Exception\n-    {\n-        timeoutSync(requestVersion, scheme, method, connectTimeout, requestTimeout, EXAMPLE_DOT_COM_PROXY);\n-    }\n-\n-    private void timeoutSync(Version requestVersion,\n-                             String scheme,\n-                             String method,\n-                             Duration connectTimeout,\n-                             Duration requestTimeout,\n-                             ProxySelector proxy)\n-        throws Exception\n-    {\n-        out.printf(\"%ntimeoutSync(requestVersion=%s, scheme=%s, method=%s,\"\n-                   + \" connectTimeout=%s, requestTimeout=%s, proxy=%s)%n\",\n-                   requestVersion, scheme, method, connectTimeout, requestTimeout, proxy);\n-\n-        HttpClient client = newClient(connectTimeout, proxy);\n-        HttpRequest request = newRequest(scheme, requestVersion, method, requestTimeout);\n-\n-        for (int i = 0; i < 2; i++) {\n-            out.printf(\"iteration %d%n\", i);\n-            long startTime = System.nanoTime();\n-            try {\n-                HttpResponse<?> resp = client.send(request, BodyHandlers.ofString());\n-                printResponse(resp);\n-                fail(\"Unexpected response: \" + resp);\n-            } catch (HttpConnectTimeoutException expected) { \/\/ blocking thread-specific exception\n-                long elapsedTime = NANOSECONDS.toMillis(System.nanoTime() - startTime);\n-                out.printf(\"Client: received in %d millis%n\", elapsedTime);\n-                assertExceptionTypeAndCause(expected.getCause());\n-            } catch (ConnectException e) {\n-                long elapsedTime = NANOSECONDS.toMillis(System.nanoTime() - startTime);\n-                out.printf(\"Client: received in %d millis%n\", elapsedTime);\n-                Throwable t = e.getCause().getCause();  \/\/ blocking thread-specific exception\n-                if (!isAcceptableCause(t)) { \/\/ tolerate only NRTHE or UAE\n-                    e.printStackTrace(out);\n-                    fail(\"Unexpected exception:\" + e);\n-                } else {\n-                    out.printf(\"Caught ConnectException with \"\n-                            + \" cause: %s - skipping%n\", t.getCause());\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/@Test(dataProvider = \"variants\")\n-    protected void timeoutNoProxyAsync(Version requestVersion,\n-                                       String scheme,\n-                                       String method,\n-                                       Duration connectTimeout,\n-                                       Duration requestTimeout) {\n-        timeoutAsync(requestVersion, scheme, method, connectTimeout, requestTimeout, NO_PROXY);\n-    }\n-\n-    \/\/@Test(dataProvider = \"variants\")\n-    protected void timeoutWithProxyAsync(Version requestVersion,\n-                                         String scheme,\n-                                         String method,\n-                                         Duration connectTimeout,\n-                                         Duration requestTimeout) {\n-        timeoutAsync(requestVersion, scheme, method, connectTimeout, requestTimeout, EXAMPLE_DOT_COM_PROXY);\n-    }\n-\n-    private void timeoutAsync(Version requestVersion,\n-                              String scheme,\n-                              String method,\n-                              Duration connectTimeout,\n-                              Duration requestTimeout,\n-                              ProxySelector proxy) {\n-        out.printf(\"%ntimeoutAsync(requestVersion=%s, scheme=%s, method=%s, \"\n-                   + \"connectTimeout=%s, requestTimeout=%s, proxy=%s)%n\",\n-                   requestVersion, scheme, method, connectTimeout, requestTimeout, proxy);\n-\n-        HttpClient client = newClient(connectTimeout, proxy);\n-        HttpRequest request = newRequest(scheme, requestVersion, method, requestTimeout);\n-        for (int i = 0; i < 2; i++) {\n-            out.printf(\"iteration %d%n\", i);\n-            long startTime = System.nanoTime();\n-            try {\n-                HttpResponse<?> resp = client.sendAsync(request, BodyHandlers.ofString()).join();\n-                printResponse(resp);\n-                fail(\"Unexpected response: \" + resp);\n-            } catch (CompletionException e) {\n-                long elapsedTime = NANOSECONDS.toMillis(System.nanoTime() - startTime);\n-                out.printf(\"Client: received in %d millis%n\", elapsedTime);\n-                Throwable t = e.getCause();\n-                if (t instanceof ConnectException && isAcceptableCause(t.getCause())) {\n-                    \/\/ tolerate only NRTHE and UAE\n-                    out.printf(\"Caught ConnectException with \"\n-                            + \"cause: %s - skipping%n\", t.getCause());\n-                } else {\n-                    assertExceptionTypeAndCause(t);\n-                }\n-            }\n-        }\n-    }\n-\n-    static boolean isAcceptableCause(Throwable cause) {\n-        if (cause instanceof NoRouteToHostException) return true;\n-        if (cause instanceof UnresolvedAddressException) return true;\n-        return false;\n-    }\n-\n-    static HttpClient newClient(Duration connectTimeout, ProxySelector proxy) {\n-        HttpClient.Builder builder = HttpClient.newBuilder().proxy(proxy);\n-        if (connectTimeout != NO_DURATION)\n-            builder.connectTimeout(connectTimeout);\n-        return builder.build();\n-    }\n-\n-    static HttpRequest newRequest(String scheme,\n-                                  Version reqVersion,\n-                                  String method,\n-                                  Duration requestTimeout) {\n-        \/\/ Resolvable address. Most tested environments just ignore the TCP SYN,\n-        \/\/ or occasionally return ICMP no route to host\n-        URI uri = URI.create(scheme +\":\/\/example.com:81\/\");\n-        HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(uri);\n-        reqBuilder = reqBuilder.version(reqVersion);\n-        switch (method) {\n-            case \"GET\"   : reqBuilder.GET();                         break;\n-            case \"POST\"  : reqBuilder.POST(BodyPublishers.noBody()); break;\n-            default: throw new AssertionError(\"Unknown method:\" + method);\n-        }\n-        if (requestTimeout != NO_DURATION)\n-            reqBuilder.timeout(requestTimeout);\n-        return reqBuilder.build();\n-    }\n-\n-    static void assertExceptionTypeAndCause(Throwable t) {\n-        if (!(t instanceof HttpConnectTimeoutException)) {\n-            t.printStackTrace(out);\n-            fail(\"Expected HttpConnectTimeoutException, got:\" + t);\n-        }\n-        Throwable connEx = t.getCause();\n-        if (!(connEx instanceof ConnectException)) {\n-            t.printStackTrace(out);\n-            fail(\"Expected ConnectException cause in:\" + connEx);\n-        }\n-        out.printf(\"Caught expected HttpConnectTimeoutException with ConnectException\"\n-                + \" cause: %n%s%n%s%n\", t, connEx);\n-        final String EXPECTED_MESSAGE = \"HTTP connect timed out\"; \/\/ impl dependent\n-        if (!connEx.getMessage().equals(EXPECTED_MESSAGE))\n-            fail(\"Expected: \\\"\" + EXPECTED_MESSAGE + \"\\\", got: \\\"\" + connEx.getMessage() + \"\\\"\");\n-\n-    }\n-\n-    static void printResponse(HttpResponse<?> response) {\n-        out.println(\"Unexpected response: \" + response);\n-        out.println(\"Headers: \" + response.headers());\n-        out.println(\"Body: \" + response.body());\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeout.java","additions":0,"deletions":258,"binary":false,"changes":258,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.http.HttpClient.Version;\n-import java.time.Duration;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @summary Tests for connection related timeouts\n- * @bug 8208391\n- * @run testng\/othervm ConnectTimeoutNoProxyAsync\n- *\/\n-\n-public class ConnectTimeoutNoProxyAsync extends AbstractConnectTimeout {\n-\n-    @Test(dataProvider = \"variants\")\n-    @Override\n-    public void timeoutNoProxyAsync(Version requestVersion,\n-                                    String scheme,\n-                                    String method,\n-                                    Duration connectTimeout,\n-                                    Duration requestduration)\n-    {\n-        super.timeoutNoProxyAsync(requestVersion, scheme, method, connectTimeout, requestduration);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/ConnectTimeoutNoProxyAsync.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.http.HttpClient.Version;\n-import java.time.Duration;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @summary Tests for connection related timeouts\n- * @bug 8208391\n- * @run testng\/othervm ConnectTimeoutNoProxySync\n- *\/\n-\n-public class ConnectTimeoutNoProxySync extends AbstractConnectTimeout {\n-\n-    @Test(dataProvider = \"variants\")\n-    @Override\n-    public void timeoutNoProxySync(Version requestVersion,\n-                                   String scheme,\n-                                   String method,\n-                                   Duration connectTimeout,\n-                                   Duration requestTimeout)\n-        throws Exception\n-    {\n-        super.timeoutNoProxySync(requestVersion, scheme, method, connectTimeout, requestTimeout);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/ConnectTimeoutNoProxySync.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.net.ConnectException;\n+import java.net.InetAddress;\n+import java.net.NoRouteToHostException;\n+import java.net.Proxy;\n+import java.net.ProxySelector;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpConnectTimeoutException;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.UnresolvedAddressException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.stream.Stream;\n+\n+import static java.lang.Boolean.parseBoolean;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.time.Duration.*;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test id=sync\n+ * @bug 8208391 8375352\n+ * @summary Verifies behavior on `connect()` timeouts\n+ * @requires os.family != \"windows\"\n+ * @run junit\/othervm ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=sync-proxy\n+ * @bug 8208391 8375352\n+ * @summary Verifies behavior on `connect()` timeouts\n+ * @requires os.family != \"windows\"\n+ * @run junit\/othervm -Dtest.proxy=true ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=async\n+ * @bug 8208391 8375352\n+ * @summary Verifies behavior on `connect()` timeouts\n+ * @requires os.family != \"windows\"\n+ * @run junit\/othervm -Dtest.async=true ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=async-proxy\n+ * @bug 8208391 8375352\n+ * @summary Verifies behavior on `connect()` timeouts\n+ * @requires os.family != \"windows\"\n+ * @run junit\/othervm -Dtest.async=true -Dtest.proxy=true ${test.main.class}\n+ *\/\n+\n+class ConnectTimeoutTest {\n+\n+    \/\/ This test verifies the `HttpClient` behavior on `connect()` failures.\n+    \/\/\n+    \/\/ Earlier, the test was trying to connect `example.com:8080` to trigger a `connect()` failure.\n+    \/\/ This worked, until it doesn't â€” `example.com:8080` started responding in certain test environments.\n+    \/\/\n+    \/\/ Now we create a `ServerSocket` and exhaust all its \"SYN backlog\" and \"Accept queue\".\n+    \/\/ The expectation is that the platform socket in this state will block on `connect()`.\n+    \/\/ Well... It doesn't on Windows, whereas it does on Linux and macOS.\n+    \/\/ Windows doesn't block and immediately responds with `java.net.ConnectException: Connection refused: connect`.\n+    \/\/ Neither it is deterministic how many connections are needed to exhaust a socket admission queue.\n+    \/\/ Hence, we took the following decisions:\n+    \/\/\n+    \/\/ 1. Skip this test on Windows\n+    \/\/ 2. Exhaust server socket admission queue by going into a loop\n+\n+    private static final PrintStream LOGGER = System.out;\n+\n+    private static final int BACKLOG = 1;\n+\n+    \/**\n+     * A {@link ServerSocket} whose admission will be blocked by exhausting all its \"SYN backlog\" and \"Accept queue\".\n+     *\/\n+    private static final ServerSocket SERVER_SOCKET = createServerSocket();\n+\n+    \/**\n+     * Client sockets exhausting the admission to {@link #SERVER_SOCKET}.\n+     *\/\n+    private static final List<Socket> CLIENT_SOCKETS = createClientSocketsExhaustingServerSocketAdmission();\n+\n+    private static ServerSocket createServerSocket() {\n+        try {\n+            LOGGER.println(\"Creating server socket\");\n+            return new ServerSocket(0, BACKLOG, InetAddress.getLoopbackAddress());\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static List<Socket> createClientSocketsExhaustingServerSocketAdmission() {\n+        List<Socket> sockets = new ArrayList<>();\n+        int maxSocketCount = BACKLOG   \/\/ To fill up the backlog\n+                + 512;                 \/\/ Giving some slack, should be enough to exhaust the admission queue.\n+        int socketIndex = 0;\n+        for (; socketIndex < maxSocketCount; socketIndex++) {\n+            try {\n+                LOGGER.printf(\n+                        \"Creating client socket %s\/%s to exhaust the server socket admission%n\",\n+                        (socketIndex + 1), maxSocketCount);\n+                Socket socket = new Socket();\n+                socket.connect(SERVER_SOCKET.getLocalSocketAddress(), 5000);\n+                sockets.add(socket);\n+            } catch (ConnectException | SocketTimeoutException exception) {\n+                LOGGER.printf(\n+                        \"Received expected `%s` while creating client socket %s\/%s%n\",\n+                        exception.getClass().getName(), (socketIndex + 1), maxSocketCount);\n+                return sockets;\n+            } catch (IOException ioe) {\n+                String message = String.format(\n+                        \"Received unexpected exception while creating client socket %s\/%s\",\n+                        (socketIndex + 1), maxSocketCount);\n+                closeSockets(SERVER_SOCKET, sockets);\n+                throw new RuntimeException(message, ioe);\n+            }\n+        }\n+        String message = String.format(\n+                \"Connected %s sockets, but still could not exhaust the socket admission\",\n+                maxSocketCount);\n+        closeSockets(SERVER_SOCKET, sockets);\n+        throw new RuntimeException(message);\n+    }\n+\n+    @AfterAll\n+    public static void closeSockets() {\n+        closeSockets(SERVER_SOCKET, CLIENT_SOCKETS);\n+    }\n+\n+    private static void closeSockets(ServerSocket serverSocket, List<Socket> clientSockets) {\n+        Throwable[] throwable = {null};\n+        Stream.concat(clientSockets.stream(), Stream.of(serverSocket)).forEach(closeable -> {\n+            try {\n+                closeable.close();\n+            } catch (Exception exception) {\n+                if (throwable[0] == null) {\n+                    throwable[0] = exception;\n+                } else {\n+                    throwable[0].addSuppressed(exception);\n+                }\n+            }\n+        });\n+        if (throwable[0] != null) {\n+            throwable[0].printStackTrace(System.out);\n+        }\n+    }\n+\n+    \/**\n+     * {@link ProxySelector} <em>always<\/em> pointing to {@link #SERVER_SOCKET}.\n+     *\/\n+    private static final ProxySelector PROXY_SELECTOR = new ProxySelector() {\n+\n+        private static final List<Proxy> PROXIES =\n+                List.of(new Proxy(Proxy.Type.HTTP, SERVER_SOCKET.getLocalSocketAddress()));\n+\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+            return PROXIES;\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n+            \/\/ Do nothing\n+        }\n+\n+    };\n+\n+    private static final Duration NO_DURATION = null;\n+\n+    private static List<List<Duration>> TIMEOUTS = List.of(\n+                    \/\/ connectTimeout   HttpRequest timeout\n+            Arrays.asList( NO_DURATION,   ofMillis(100) ),\n+            Arrays.asList( NO_DURATION,   ofNanos(1)    ),\n+\n+            Arrays.asList( ofMillis(100), NO_DURATION   ),\n+            Arrays.asList( ofNanos(1),    NO_DURATION   ),\n+\n+            Arrays.asList( ofMillis(100), ofMinutes(1)  ),\n+            Arrays.asList( ofNanos(1),    ofMinutes(1)  )\n+    );\n+\n+    private static final List<String> METHODS = List.of(\"GET\", \"POST\");\n+    private static final List<Version> VERSIONS = List.of(HTTP_2, HTTP_1_1);\n+    private static final List<String> SCHEMES = List.of(\"https\", \"http\");\n+\n+    static Object[][] variants() {\n+        List<Object[]> l = new ArrayList<>();\n+        for (List<Duration> timeouts : TIMEOUTS) {\n+           Duration connectTimeout = timeouts.get(0);\n+           Duration requestTimeout = timeouts.get(1);\n+           for (String method: METHODS) {\n+            for (String scheme : SCHEMES) {\n+             for (Version requestVersion : VERSIONS) {\n+              l.add(new Object[] {requestVersion, scheme, method, connectTimeout, requestTimeout});\n+        }}}}\n+        return l.stream().toArray(Object[][]::new);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"variants\")\n+    void test(\n+            Version requestVersion,\n+            String scheme,\n+            String method,\n+            Duration connectTimeout,\n+            Duration requestTimeout)\n+            throws Exception {\n+        ProxySelector proxySelector = parseBoolean(System.getProperty(\"test.proxy\")) ? PROXY_SELECTOR : NO_PROXY;\n+        boolean async = parseBoolean(System.getProperty(\"test.async\"));\n+        if (async) {\n+            timeoutAsync(requestVersion, scheme, method, connectTimeout, requestTimeout, proxySelector);\n+        } else {\n+            timeoutSync(requestVersion, scheme, method, connectTimeout, requestTimeout, proxySelector);\n+        }\n+    }\n+\n+    private void timeoutSync(Version requestVersion,\n+                             String scheme,\n+                             String method,\n+                             Duration connectTimeout,\n+                             Duration requestTimeout,\n+                             ProxySelector proxy)\n+        throws Exception\n+    {\n+        HttpClient client = newClient(connectTimeout, proxy);\n+        HttpRequest request = newRequest(scheme, requestVersion, method, requestTimeout);\n+\n+        for (int i = 0; i < 2; i++) {\n+            LOGGER.printf(\"iteration %d%n\", i);\n+            long startTime = System.nanoTime();\n+            try {\n+                HttpResponse<?> resp = client.send(request, BodyHandlers.ofString());\n+                printResponse(resp);\n+                fail(\"Unexpected response: \" + resp);\n+            } catch (HttpConnectTimeoutException expected) { \/\/ blocking thread-specific exception\n+                long elapsedTime = NANOSECONDS.toMillis(System.nanoTime() - startTime);\n+                LOGGER.printf(\"Client: received in %d millis%n\", elapsedTime);\n+                assertExceptionTypeAndCause(expected.getCause());\n+            } catch (ConnectException e) {\n+                long elapsedTime = NANOSECONDS.toMillis(System.nanoTime() - startTime);\n+                LOGGER.printf(\"Client: received in %d millis%n\", elapsedTime);\n+                Throwable t = e.getCause().getCause();  \/\/ blocking thread-specific exception\n+                if (!isAcceptableCause(t)) { \/\/ tolerate only NRTHE or UAE\n+                    e.printStackTrace(LOGGER);\n+                    fail(\"Unexpected exception:\" + e);\n+                } else {\n+                    LOGGER.printf(\"Caught ConnectException with \"\n+                            + \" cause: %s - skipping%n\", t.getCause());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void timeoutAsync(Version requestVersion,\n+                              String scheme,\n+                              String method,\n+                              Duration connectTimeout,\n+                              Duration requestTimeout,\n+                              ProxySelector proxy) {\n+        HttpClient client = newClient(connectTimeout, proxy);\n+        HttpRequest request = newRequest(scheme, requestVersion, method, requestTimeout);\n+        for (int i = 0; i < 2; i++) {\n+            LOGGER.printf(\"iteration %d%n\", i);\n+            long startTime = System.nanoTime();\n+            try {\n+                HttpResponse<?> resp = client.sendAsync(request, BodyHandlers.ofString()).join();\n+                printResponse(resp);\n+                fail(\"Unexpected response: \" + resp);\n+            } catch (CompletionException e) {\n+                long elapsedTime = NANOSECONDS.toMillis(System.nanoTime() - startTime);\n+                LOGGER.printf(\"Client: received in %d millis%n\", elapsedTime);\n+                Throwable t = e.getCause();\n+                if (t instanceof ConnectException && isAcceptableCause(t.getCause())) {\n+                    \/\/ tolerate only NRTHE and UAE\n+                    LOGGER.printf(\"Caught ConnectException with \"\n+                            + \"cause: %s - skipping%n\", t.getCause());\n+                } else {\n+                    assertExceptionTypeAndCause(t);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isAcceptableCause(Throwable cause) {\n+        if (cause instanceof NoRouteToHostException) return true;\n+        if (cause instanceof UnresolvedAddressException) return true;\n+        return false;\n+    }\n+\n+    private static HttpClient newClient(Duration connectTimeout, ProxySelector proxy) {\n+        HttpClient.Builder builder = HttpClient.newBuilder().proxy(proxy);\n+        if (connectTimeout != NO_DURATION)\n+            builder.connectTimeout(connectTimeout);\n+        return builder.build();\n+    }\n+\n+    private static HttpRequest newRequest(String scheme,\n+                                  Version reqVersion,\n+                                  String method,\n+                                  Duration requestTimeout) {\n+        String hostAddress = SERVER_SOCKET.getInetAddress().getHostAddress();\n+        int hostPort = SERVER_SOCKET.getLocalPort();\n+        URI uri = URI.create(scheme + \":\/\/\" + hostAddress + ':' + hostPort);\n+        HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(uri);\n+        reqBuilder = reqBuilder.version(reqVersion);\n+        switch (method) {\n+            case \"GET\"   : reqBuilder.GET();                         break;\n+            case \"POST\"  : reqBuilder.POST(BodyPublishers.noBody()); break;\n+            default: throw new AssertionError(\"Unknown method:\" + method);\n+        }\n+        if (requestTimeout != NO_DURATION)\n+            reqBuilder.timeout(requestTimeout);\n+        return reqBuilder.build();\n+    }\n+\n+    private static void assertExceptionTypeAndCause(Throwable t) {\n+        if (!(t instanceof HttpConnectTimeoutException)) {\n+            t.printStackTrace(LOGGER);\n+            fail(\"Expected HttpConnectTimeoutException, got:\" + t);\n+        }\n+        Throwable connEx = t.getCause();\n+        if (!(connEx instanceof ConnectException)) {\n+            t.printStackTrace(LOGGER);\n+            fail(\"Expected ConnectException cause in:\" + connEx);\n+        }\n+        LOGGER.printf(\"Caught expected HttpConnectTimeoutException with ConnectException\"\n+                + \" cause: %n%s%n%s%n\", t, connEx);\n+        final String EXPECTED_MESSAGE = \"HTTP connect timed out\"; \/\/ impl dependent\n+        if (!connEx.getMessage().equals(EXPECTED_MESSAGE))\n+            fail(\"Expected: \\\"\" + EXPECTED_MESSAGE + \"\\\", got: \\\"\" + connEx.getMessage() + \"\\\"\");\n+\n+    }\n+\n+    private static void printResponse(HttpResponse<?> response) {\n+        LOGGER.println(\"Unexpected response: \" + response);\n+        LOGGER.println(\"Headers: \" + response.headers());\n+        LOGGER.println(\"Body: \" + response.body());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ConnectTimeoutTest.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.http.HttpClient.Version;\n-import java.time.Duration;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @summary Tests for connection related timeouts\n- * @bug 8208391\n- * @run testng\/othervm ConnectTimeoutWithProxyAsync\n- *\/\n-\n-public class ConnectTimeoutWithProxyAsync extends AbstractConnectTimeout {\n-\n-    @Test(dataProvider = \"variants\")\n-    @Override\n-    public void timeoutWithProxyAsync(Version requestVersion,\n-                                      String scheme,\n-                                      String method,\n-                                      Duration connectTimeout,\n-                                      Duration requestTimeout)\n-    {\n-        super.timeoutWithProxyAsync(requestVersion, scheme, method, connectTimeout, requestTimeout);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/ConnectTimeoutWithProxyAsync.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.http.HttpClient.Version;\n-import java.time.Duration;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @summary Tests for connection related timeouts\n- * @bug 8208391\n- * @run testng\/othervm ConnectTimeoutWithProxySync\n- *\/\n-\n-public class ConnectTimeoutWithProxySync extends AbstractConnectTimeout {\n-\n-    @Test(dataProvider = \"variants\")\n-    @Override\n-    public void timeoutWithProxySync(Version requestVersion,\n-                                     String scheme,\n-                                     String method,\n-                                     Duration connectTimeout,\n-                                     Duration requestTimeout)\n-        throws Exception\n-    {\n-        super.timeoutWithProxySync(requestVersion, scheme, method, connectTimeout, requestTimeout);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/ConnectTimeoutWithProxySync.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"}]}