{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,3 @@\n-import java.io.File;\n+import jdk.internal.jimage.BasicImageReader;\n+import jtreg.SkippedException;\n+\n@@ -27,1 +29,3 @@\n-import java.nio.file.DirectoryStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n@@ -30,3 +34,0 @@\n-import java.nio.file.Paths;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n@@ -35,0 +36,1 @@\n+import java.util.HashSet;\n@@ -44,0 +46,1 @@\n+import java.util.stream.StreamSupport;\n@@ -45,2 +48,1 @@\n-import jdk.internal.jimage.BasicImageReader;\n-import jdk.internal.jimage.ImageLocation;\n+import static java.util.stream.Collectors.joining;\n@@ -49,2 +51,3 @@\n- * @test\n- * @summary Verify jimage\n+ * @test id=load\n+ * @summary Load all classes defined in JRT file system.\n+ * @library \/test\/lib\n@@ -55,8 +58,6 @@\n-\/**\n- * This test runs in two modes:\n- * (1) No argument: it verifies the jimage by loading all classes in the runtime\n- * (2) path of exploded modules: it compares bytes of each file in the exploded\n- *     module with the entry in jimage\n- *\n- * FIXME: exception thrown when findLocation from jimage by multiple threads\n- * -Djdk.test.threads=<n> to specify the number of threads.\n+\/*\n+ * @test id=compare\n+ * @summary Compare an exploded directory of module classes with the system jimage.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.jimage\n+ * @run main\/othervm --add-modules ALL-SYSTEM -Djdk.test.threads=10 VerifyJimage ..\/..\/jdk\/modules\n@@ -64,1 +65,1 @@\n-public class VerifyJimage {\n+public abstract class VerifyJimage implements Runnable {\n@@ -66,1 +67,0 @@\n-    private static final Deque<String> failed = new ConcurrentLinkedDeque<>();\n@@ -69,3 +69,4 @@\n-\n-        String home = System.getProperty(\"java.home\");\n-        Path bootimagePath = Paths.get(home, \"lib\", \"modules\");\n+        \/\/ Best practice is to read \"test.jdk\" in preference to \"java.home\".\n+        String testJdk = System.getProperty(\"test.jdk\", System.getProperty(\"java.home\"));\n+        Path jdkRoot = Path.of(testJdk);\n+        Path bootimagePath = jdkRoot.resolve(\"lib\", \"modules\");\n@@ -73,2 +74,1 @@\n-             System.out.println(\"Test skipped, not an images build\");\n-             return;\n+            throw new SkippedException(\"No boot image: \" + bootimagePath);\n@@ -77,4 +77,7 @@\n-        long start = System.nanoTime();\n-        int numThreads = Integer.getInteger(\"jdk.test.threads\", 1);\n-        JImageReader reader = newJImageReader();\n-        VerifyJimage verify = new VerifyJimage(reader, numThreads);\n+        FileSystem jrtFs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        Path modulesRoot = jrtFs.getPath(\"\/\").resolve(\"modules\");\n+        List<String> modules;\n+        try (Stream<Path> moduleDirs = Files.list(modulesRoot)) {\n+            modules = moduleDirs.map(Path::getFileName).map(Object::toString).toList();\n+        }\n+        VerifyJimage verifier;\n@@ -82,2 +85,1 @@\n-            \/\/ load classes from jimage\n-            verify.loadClasses();\n+            verifier = new ClassLoadingVerifier(modules, modulesRoot);\n@@ -85,3 +87,5 @@\n-            Path dir = Paths.get(args[0]);\n-            if (Files.notExists(dir) || !Files.isDirectory(dir)) {\n-                throw new RuntimeException(\"Invalid argument: \" + dir);\n+            Path pathArg = Path.of(args[0].replace(\"\/\", FileSystems.getDefault().getSeparator()));\n+            \/\/ The path argument may be relative.\n+            Path rootDir = jdkRoot.resolve(pathArg);\n+            if (!Files.isDirectory(rootDir)) {\n+                throw new SkippedException(\"No modules directory found: \" + rootDir);\n@@ -89,1 +93,2 @@\n-            verify.compareExplodedModules(dir);\n+            int maxThreads = Integer.getInteger(\"jdk.test.threads\", 1);\n+            verifier = new DirectoryContentVerifier(modules, rootDir, maxThreads, bootimagePath);\n@@ -91,1 +96,16 @@\n-        verify.waitForCompletion();\n+        verifier.verify();\n+    }\n+\n+    final List<String> modules;\n+    \/\/ Count of items which have passed verification.\n+    final AtomicInteger verifiedCount = new AtomicInteger(0);\n+    \/\/ Error messages for verification failures.\n+    final Deque<String> failed = new ConcurrentLinkedDeque<>();\n+\n+    private VerifyJimage(List<String> modules) {\n+        this.modules = modules;\n+    }\n+\n+    void verify() {\n+        long start = System.nanoTime();\n+        run();\n@@ -93,7 +113,5 @@\n-        int entries = reader.entries();\n-        System.out.format(\"%d entries %d files verified: %d ms %d errors%n\",\n-                          entries, verify.count.get(),\n-                          TimeUnit.NANOSECONDS.toMillis(end - start), failed.size());\n-        for (String f : failed) {\n-            System.err.println(f);\n-        }\n+\n+        System.out.format(\"Verified %d entries: %d ms, %d errors%n\",\n+                verifiedCount.get(),\n+                TimeUnit.NANOSECONDS.toMillis(end - start),\n+                failed.size());\n@@ -101,0 +119,1 @@\n+            failed.forEach(System.err::println);\n@@ -105,3 +124,4 @@\n-    private final AtomicInteger count = new AtomicInteger(0);\n-    private final JImageReader reader;\n-    private final ExecutorService pool;\n+    private static final class DirectoryContentVerifier extends VerifyJimage {\n+        private final Path rootDir;\n+        private final ExecutorService pool;\n+        private final Path jimagePath;\n@@ -109,9 +129,6 @@\n-    VerifyJimage(JImageReader reader, int numThreads) {\n-        this.reader = reader;\n-        this.pool = Executors.newFixedThreadPool(numThreads);\n-    }\n-\n-    private void waitForCompletion() throws InterruptedException {\n-        pool.shutdown();\n-        pool.awaitTermination(20, TimeUnit.SECONDS);\n-    }\n+        DirectoryContentVerifier(List<String> modules, Path rootDir, int maxThreads, Path jimagePath) {\n+            super(modules);\n+            this.rootDir = rootDir;\n+            this.pool = Executors.newFixedThreadPool(maxThreads);\n+            this.jimagePath = jimagePath;\n+        }\n@@ -119,20 +136,15 @@\n-    private void compareExplodedModules(Path dir) throws IOException {\n-        System.out.println(\"comparing jimage with \" + dir);\n-\n-        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n-            for (Path mdir : stream) {\n-                if (Files.isDirectory(mdir)) {\n-                    pool.execute(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            try {\n-                                Files.find(mdir, Integer.MAX_VALUE, (Path p, BasicFileAttributes attr)\n-                                           -> !Files.isDirectory(p) &&\n-                                              !mdir.relativize(p).toString().startsWith(\"_\") &&\n-                                              !p.getFileName().toString().equals(\"MANIFEST.MF\"))\n-                                     .forEach(p -> compare(mdir, p, reader));\n-                            } catch (IOException e) {\n-                                throw new UncheckedIOException(e);\n-                            }\n-                        }\n-                    });\n+        @Override\n+        public void run() {\n+            System.out.println(\"Comparing jimage with: \" + rootDir);\n+            try (BasicImageReader jimage = BasicImageReader.open(jimagePath)) {\n+                for (String modName : modules) {\n+                    Path modDir = rootDir.resolve(modName);\n+                    if (!Files.isDirectory(modDir)) {\n+                        failed.add(\"Missing module directory: \" + modDir);\n+                    } else {\n+                        pool.execute(new ModuleResourceComparator(rootDir, modName, jimage));\n+                    }\n+                }\n+                pool.shutdown();\n+                if (!pool.awaitTermination(20, TimeUnit.SECONDS)) {\n+                    failed.add(\"Directory verification timed out\");\n@@ -140,0 +152,5 @@\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            } catch (InterruptedException e) {\n+                failed.add(\"Directory verification was interrupted\");\n+                Thread.currentThread().interrupt();\n@@ -142,1 +159,0 @@\n-    }\n@@ -144,23 +160,12 @@\n-    private final List<String> BOOT_RESOURCES = Arrays.asList(\n-        \"java.base\/META-INF\/services\/java.nio.file.spi.FileSystemProvider\"\n-    );\n-    private final List<String> EXT_RESOURCES = Arrays.asList(\n-        \"jdk.zipfs\/META-INF\/services\/java.nio.file.spi.FileSystemProvider\"\n-    );\n-    private final List<String> APP_RESOURCES = Arrays.asList(\n-        \"jdk.hotspot.agent\/META-INF\/services\/com.sun.jdi.connect.Connector\",\n-        \"jdk.jdi\/META-INF\/services\/com.sun.jdi.connect.Connector\"\n-    );\n-\n-    private void compare(Path mdir, Path p, JImageReader reader) {\n-        String entry = p.getFileName().toString().equals(MODULE_INFO)\n-                ? mdir.getFileName().toString() + \"\/\" + MODULE_INFO\n-                : mdir.relativize(p).toString().replace(File.separatorChar, '\/');\n-\n-        count.incrementAndGet();\n-        String file = mdir.getFileName().toString() + \"\/\" + entry;\n-        if (APP_RESOURCES.contains(file)) {\n-            \/\/ skip until the service config file is merged\n-            System.out.println(\"Skipped \" + file);\n-            return;\n-        }\n+        \/**\n+         * Verifies the contents of the current runtime jimage file by comparing\n+         * entries with the on-disk resources in a given directory.\n+         *\/\n+        private class ModuleResourceComparator implements Runnable {\n+            private final Path rootDir;\n+            private final String moduleName;\n+            private final BasicImageReader jimage;\n+            private final String moduleInfoName;\n+            \/\/ Entries we expect to find in the jimage module.\n+            private final Set<String> moduleEntries;\n+            private final Set<String> handledEntries = new HashSet<>();\n@@ -168,4 +173,12 @@\n-        if (reader.findLocation(entry) != null) {\n-            reader.compare(entry, p);\n-        }\n-    }\n+            public ModuleResourceComparator(Path rootDir, String moduleName, BasicImageReader jimage) {\n+                this.rootDir = rootDir;\n+                this.moduleName = moduleName;\n+                this.jimage = jimage;\n+                String moduleEntryPrefix = \"\/\" + moduleName + \"\/\";\n+                this.moduleInfoName = moduleEntryPrefix + MODULE_INFO;\n+                this.moduleEntries =\n+                        Arrays.stream(jimage.getEntryNames())\n+                                .filter(n -> n.startsWith(moduleEntryPrefix))\n+                                .filter(n -> !isJimageOnly(n))\n+                                .collect(Collectors.toSet());\n+            }\n@@ -173,18 +186,12 @@\n-    private void loadClasses() {\n-        ClassLoader loader = ClassLoader.getSystemClassLoader();\n-        Stream.of(reader.getEntryNames())\n-              .filter(this::accept)\n-              .map(this::toClassName)\n-              .forEach(cn -> {\n-                  count.incrementAndGet();\n-                  try {\n-                      System.out.println(\"Loading \" + cn);\n-                      Class.forName(cn, false, loader);\n-                  } catch (VerifyError ve) {\n-                      System.err.println(\"VerifyError for \" + cn);\n-                      failed.add(reader.imageName() + \": \" + cn + \" not verified: \" + ve.getMessage());\n-                  } catch (ClassNotFoundException e) {\n-                      failed.add(reader.imageName() + \": \" + cn + \" not found\");\n-                  }\n-              });\n-    }\n+            @Override\n+            public void run() {\n+                try (Stream<Path> files = Files.walk(rootDir.resolve(moduleName))) {\n+                    files.filter(this::shouldVerify).forEach(this::compareEntry);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+                moduleEntries.stream()\n+                        .filter(n -> !handledEntries.contains(n))\n+                        .sorted()\n+                        .forEach(n -> failed.add(\"Untested jimage entry: \" + n));\n+            }\n@@ -192,5 +199,29 @@\n-    private String toClassName(String entry) {\n-        int index = entry.indexOf('\/', 1);\n-        return entry.substring(index + 1, entry.length())\n-                    .replaceAll(\"\\\\.class$\", \"\").replace('\/', '.');\n-    }\n+            void compareEntry(Path path) {\n+                String entryName = getEntryName(path);\n+                if (!moduleEntries.contains(entryName)) {\n+                    \/\/ Corresponds to an on-disk file which is not expected to\n+                    \/\/ be present in the jimage. This is normal and is skipped.\n+                    return;\n+                }\n+                \/\/ Mark valid entries as \"handled\" to track if we've seen them\n+                \/\/ (even if we don't test their content).\n+                if (!handledEntries.add(entryName)) {\n+                    failed.add(\"Duplicate entry name: \" + entryName);\n+                    return;\n+                }\n+                if (isExpectedToDiffer(entryName)) {\n+                    return;\n+                }\n+                try {\n+                    int mismatch = Arrays.mismatch(\n+                            Files.readAllBytes(path),\n+                            jimage.getResource(entryName));\n+                    if (mismatch == -1) {\n+                        verifiedCount.incrementAndGet();\n+                    } else {\n+                        failed.add(\"Content diff (byte offset \" + mismatch + \"): \" + entryName);\n+                    }\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n@@ -198,3 +229,29 @@\n-    \/\/ All JVMCI packages other than jdk.vm.ci.services are dynamically\n-    \/\/ exported to jdk.graal.compiler\n-    private static Set<String> EXCLUDED_MODULES = Set.of(\"jdk.graal.compiler\");\n+            \/**\n+             * Predicate for files which correspond to entries in the jimage.\n+             *\n+             * <p>This should be a narrow test with minimal chance of\n+             * false-negative matching, primarily focusing on excluding build\n+             * artifacts.\n+             *\/\n+            boolean shouldVerify(Path path) {\n+                \/\/ Use the entry name because we know it uses the '\/' separator.\n+                String entryName = getEntryName(path);\n+                return Files.isRegularFile(path)\n+                        && !entryName.contains(\"\/_the.\")\n+                        && !entryName.contains(\"\/_element_lists.\");\n+            }\n+\n+            \/**\n+             * Predicate for the limited subset of entries which are expected to\n+             * exist in the file system, but are not expected to have the same\n+             * content as the associated jimage entry. This is to handle files\n+             * which are modified\/patched by jlink plugins.\n+             *\n+             * <p>This should be a narrow test with minimal chance of\n+             * false-positive matching.\n+             *\/\n+            private boolean isExpectedToDiffer(String entryName) {\n+                return entryName.equals(moduleInfoName)\n+                        || (entryName.startsWith(\"\/java.base\/java\/lang\/invoke\/\") && entryName.endsWith(\"$Holder.class\"))\n+                        || entryName.equals(\"\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\");\n+            }\n@@ -202,5 +259,17 @@\n-    private boolean accept(String entry) {\n-        int index = entry.indexOf('\/', 1);\n-        String mn = index > 1 ? entry.substring(1, index) : \"\";\n-        if (mn.isEmpty() || EXCLUDED_MODULES.contains(mn)) {\n-            return false;\n+            \/**\n+             * Predicate for the limited subset of entries which are not expected\n+             * to exist in the file system, such as those created synthetically\n+             * by jlink plugins.\n+             *\n+             * <p>This should be a narrow test with minimal chance of\n+             * false-positive matching.\n+             *\/\n+            private boolean isJimageOnly(String entryName) {\n+                return entryName.startsWith(\"\/java.base\/jdk\/internal\/module\/SystemModules$\")\n+                        || entryName.startsWith(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\");\n+            }\n+\n+            private String getEntryName(Path path) {\n+                return StreamSupport.stream(rootDir.relativize(path).spliterator(), false)\n+                        .map(Object::toString).collect(joining(\"\/\", \"\/\", \"\"));\n+            }\n@@ -208,1 +277,0 @@\n-        return entry.endsWith(\".class\") && !entry.endsWith(MODULE_INFO);\n@@ -211,6 +279,6 @@\n-    private static JImageReader newJImageReader() throws IOException {\n-        String home = System.getProperty(\"java.home\");\n-        Path jimage = Paths.get(home, \"lib\", \"modules\");\n-        System.out.println(\"opened \" + jimage);\n-        return new JImageReader(jimage);\n-    }\n+    \/**\n+     * Verifies the contents of the current runtime jimage file by attempting to\n+     * load every available class based on the content of the JRT file system.\n+     *\/\n+    static final class ClassLoadingVerifier extends VerifyJimage {\n+        private static final String CLASS_SUFFIX = \".class\";\n@@ -218,6 +286,1 @@\n-    static class JImageReader extends BasicImageReader {\n-        final Path jimage;\n-        JImageReader(Path p) throws IOException {\n-            super(p);\n-            this.jimage = p;\n-        }\n+        private final Path modulesRoot;\n@@ -225,2 +288,3 @@\n-        String imageName() {\n-            return jimage.getFileName().toString();\n+        ClassLoadingVerifier(List<String> modules, Path modulesRoot) {\n+            super(modules);\n+            this.modulesRoot = modulesRoot;\n@@ -229,2 +293,15 @@\n-        int entries() {\n-            return getHeader().getTableLength();\n+        @Override\n+        public void run() {\n+            ClassLoader loader = ClassLoader.getSystemClassLoader();\n+            for (String modName : modules) {\n+                Path modDir = modulesRoot.resolve(modName);\n+                try (Stream<Path> files = Files.walk(modDir)) {\n+                    files.map(modDir::relativize)\n+                            .filter(ClassLoadingVerifier::isClassFile)\n+                            .map(Object::toString)\n+                            .map(ClassLoadingVerifier::toClassName)\n+                            .forEach(cn -> loadClass(cn, loader));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }\n@@ -233,1 +310,1 @@\n-        void compare(String entry, Path p) {\n+        private void loadClass(String cn, ClassLoader loader) {\n@@ -235,7 +312,8 @@\n-                byte[] bytes = Files.readAllBytes(p);\n-                byte[] imagebytes = getResource(entry);\n-                if (!Arrays.equals(bytes, imagebytes)) {\n-                    failed.add(imageName() + \": bytes differs than \" + p.toString());\n-                }\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n+                System.out.println(\"Loading \" + cn);\n+                Class.forName(cn, false, loader);\n+                verifiedCount.incrementAndGet();\n+            } catch (VerifyError ve) {\n+                System.err.println(\"VerifyError for \" + cn);\n+                failed.add(\"Class: \" + cn + \" not verified: \" + ve.getMessage());\n+            } catch (ClassNotFoundException e) {\n+                failed.add(\"Class: \" + cn + \" not found\");\n@@ -244,0 +322,12 @@\n+\n+        \/** Maps a module-relative JRT path to its corresponding class name. *\/\n+        private static String toClassName(String path) {\n+            return path.substring(0, path.length() - CLASS_SUFFIX.length()).replace('\/', '.');\n+        }\n+\n+        \/** Whether a module-relative JRT file system path is a class file. *\/\n+        private static boolean isClassFile(Path path) {\n+            String classFileName = path.getFileName().toString();\n+            return classFileName.endsWith(CLASS_SUFFIX)\n+                    && !classFileName.equals(MODULE_INFO);\n+        }\n","filename":"test\/jdk\/tools\/jimage\/VerifyJimage.java","additions":249,"deletions":159,"binary":false,"changes":408,"status":"modified"}]}