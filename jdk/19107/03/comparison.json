{"files":[{"patch":"@@ -149,1 +149,1 @@\n-  _current_dump_space(nullptr),\n+  _current_dump_region(nullptr),\n@@ -344,1 +344,1 @@\n-  _current_dump_space = &_rw_region;\n+  _current_dump_region = &_rw_region;\n@@ -347,1 +347,1 @@\n-  _current_dump_space->init(&_shared_rs, &_shared_vs);\n+  _current_dump_region->init(&_shared_rs, &_shared_vs);\n@@ -563,1 +563,1 @@\n-void ArchiveBuilder::start_dump_space(DumpRegion* next) {\n+void ArchiveBuilder::start_dump_region(DumpRegion* next) {\n@@ -565,1 +565,1 @@\n-  address top = (address)(current_dump_space()->top());\n+  address top = (address)(current_dump_region()->top());\n@@ -568,2 +568,2 @@\n-  current_dump_space()->pack(next);\n-  _current_dump_space = next;\n+  current_dump_region()->pack(next);\n+  _current_dump_region = next;\n@@ -572,1 +572,1 @@\n-  _last_verified_top = (address)(current_dump_space()->top());\n+  _last_verified_top = (address)(current_dump_region()->top());\n@@ -577,1 +577,1 @@\n-  address top = (address)(current_dump_space()->top());\n+  address top = (address)(current_dump_region()->top());\n@@ -633,1 +633,1 @@\n-  start_dump_space(&_ro_region);\n+  start_dump_region(&_ro_region);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  DumpRegion* _current_dump_space;\n+  DumpRegion* _current_dump_region;\n@@ -117,1 +117,1 @@\n-  DumpRegion* current_dump_space() const {  return _current_dump_space;  }\n+  DumpRegion* current_dump_region() const {  return _current_dump_region;  }\n@@ -281,1 +281,1 @@\n-  void start_dump_space(DumpRegion* next);\n+  void start_dump_region(DumpRegion* next);\n@@ -287,5 +287,5 @@\n-  address buffer_bottom()                    const { return _buffer_bottom;                       }\n-  address buffer_top()                       const { return (address)current_dump_space()->top(); }\n-  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;    }\n-  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;       }\n-  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;           }\n+  address buffer_bottom()                    const { return _buffer_bottom;                        }\n+  address buffer_top()                       const { return (address)current_dump_region()->top(); }\n+  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;     }\n+  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;        }\n+  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;            }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -313,11 +313,3 @@\n-  _dump_region->append_intptr_t((intptr_t)ptr, true);\n-}\n-\n-void WriteClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    do_ptr((void**)start);\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n+  \/\/ null pointers do not need to be converted to offsets\n+  if (ptr != nullptr) {\n+    ptr = (address)ArchiveBuilder::current()->buffer_to_offset(ptr);\n@@ -325,0 +317,1 @@\n+  _dump_region->append_intptr_t((intptr_t)ptr, false);\n@@ -332,1 +325,1 @@\n-  *p = (void*)obj;\n+  *p = (void*)obj != nullptr ? (void*)(SharedBaseAddress + obj) : (void*)obj;\n@@ -358,11 +351,0 @@\n-void ReadClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    *(intptr_t*)start = nextPtr();\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -218,1 +218,4 @@\n-  void do_region(u_char* start, size_t size);\n+  char* region_top() {\n+    return _dump_region->top();\n+  }\n+\n@@ -241,1 +244,0 @@\n-  void do_region(u_char* start, size_t size);\n@@ -243,0 +245,1 @@\n+  char* region_top() { return nullptr; }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-CppVtableInfo** CppVtables::_index = nullptr;\n+static CppVtableInfo* _index[_num_cloned_vtable_kinds];\n@@ -218,1 +218,7 @@\n-char* CppVtables::dumptime_init(ArchiveBuilder* builder) {\n+\/\/ Vtables are all fixed offsets from ArchiveBuilder::current()->mapped_base()\n+\/\/ E.g. ConstantPool is at offset 0x58. We can archive these offsets in the\n+\/\/ RO region and use them to alculate their location at runtime without storing\n+\/\/ the pointers in the RW region\n+char* CppVtables::_vtables_serialized_base = nullptr;\n+\n+void CppVtables::dumptime_init(ArchiveBuilder* builder) {\n@@ -220,2 +226,0 @@\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(CppVtableInfo*);\n-  _index = (CppVtableInfo**)builder->rw_region()->allocate(vtptrs_bytes);\n@@ -227,2 +231,0 @@\n-\n-  return (char*)_index;\n@@ -232,1 +234,6 @@\n-  soc->do_ptr(&_index);\n+  if (!soc->reading()) {\n+    _vtables_serialized_base = (char*)ArchiveBuilder::current()->buffer_top();\n+  }\n+  for (int i = 0; i < _num_cloned_vtable_kinds; i++) {\n+    soc->do_ptr(&_index[i]);\n+  }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  static CppVtableInfo** _index;\n+  static char* _vtables_serialized_base;\n@@ -41,1 +41,1 @@\n-  static char* dumptime_init(ArchiveBuilder* builder);\n+  static void dumptime_init(ArchiveBuilder* builder);\n@@ -46,0 +46,1 @@\n+  static char* vtables_serialized_base() { return _vtables_serialized_base; }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-      assert(current_dump_space() == ro_region(), \"Must be RO space\");\n+      assert(current_dump_region() == ro_region(), \"Must be RO space\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-  char* cloned_vtables = CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&builder);\n@@ -545,1 +545,1 @@\n-  mapinfo->set_cloned_vtables(cloned_vtables);\n+  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,14 @@\n-  \/\/ Read\/write the region specified.\n-  virtual void do_region(u_char* start, size_t size) = 0;\n+  \/\/ Iterate on the pointers from p[0] through p[num_pointers-1]\n+  void do_ptrs(void** p, size_t size) {\n+    assert((intptr_t)p % sizeof(intptr_t) == 0, \"bad alignment\");\n+    assert(size % sizeof(intptr_t) == 0, \"bad size\");\n+    do_tag((int)size);\n+    while (size > 0) {\n+      do_ptr(p);\n+      p++;\n+      size -= sizeof(intptr_t);\n+    }\n+  }\n+\n+  \/\/ Address of the first element being written (write only)\n+  virtual char* region_top() = 0;\n","filename":"src\/hotspot\/share\/cds\/serializeClosure.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  soc->do_region((u_char*)&Symbol::_vm_symbols[FIRST_SID],\n+  soc->do_ptrs((void**)&Symbol::_vm_symbols[FIRST_SID],\n@@ -210,1 +210,1 @@\n-  soc->do_region((u_char*)_type_signatures, sizeof(_type_signatures));\n+  soc->do_ptrs((void**)_type_signatures, sizeof(_type_signatures));\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  private static Address mapped_base_address;\n@@ -101,1 +102,1 @@\n-    Address mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n+    mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n@@ -171,8 +172,20 @@\n-      \/\/ vtablesIndex points to this:\n-      \/\/     class CppVtableInfo {\n-      \/\/         intptr_t _vtable_size;\n-      \/\/         intptr_t _cloned_vtable[1];\n-      \/\/         ...\n-      \/\/     };\n-      \/\/     CppVtableInfo** CppVtables::_index;\n-      \/\/ This is the index of all the cloned vtables. E.g., for\n+      \/\/ vtablesIndex points to to an array like this:\n+      \/\/ long info[] = {\n+      \/\/   offset of the CppVtableInfo for ConstantPool,\n+      \/\/   offset of the CppVtableInfo for InstanceKlass,\n+      \/\/   offset of the CppVtableInfo for InstanceClassLoaderKlass,\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ class CppVtableInfo {\n+      \/\/   intptr_t _vtable_size;\n+      \/\/   intptr_t _cloned_vtable[1];\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ The loop below computes the following\n+      \/\/     CppVtableInfo* t_ConstantPool  = mapped_base_address + info[0];\n+      \/\/     CppVtableInfo* t_InstanceKlass = mapped_base_address + info[1];\n+      \/\/     ...\n+      \/\/\n+      \/\/ If we have the following objects\n@@ -181,3 +194,19 @@\n-      \/\/ the following holds true:\n-      \/\/     &_index[ConstantPool_Kind]->_cloned_vtable[0]  == ((intptr_t**)cp)[0]\n-      \/\/     &_index[InstanceKlass_Kind]->_cloned_vtable[0] == ((intptr_t**)ik)[0]\n+      \/\/\n+      \/\/ then the following holds true:\n+      \/\/     ((intptr_t**)cp)[0] == &t_ConstantPool->_cloned_vtable[0]  \/\/ The vtable for archived ConstantPools\n+      \/\/     ((intptr_t**)ik)[0] == &t_InstanceKlass->_cloned_vtable[0] \/\/ The vtable for archived InstanceKlasses\n+      \/\/\n+      \/\/ To get an idea what these address look like, do this:\n+      \/\/\n+      \/\/ $ java -Xlog:cds+vtables=debug -XX:+UnlockDiagnosticVMOptions -XX:ArchiveRelocationMode=0 --version\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for ConstantPool to 0x800000018\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceKlass to 0x800000090\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceClassLoaderKlass to 0x8000001e0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceMirrorKlass to 0x800000330\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceRefKlass to 0x800000480\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceStackChunkKlass to 0x8000005d0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for Method to 0x800000720\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for ObjArrayKlass to 0x800000798\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for TypeArrayKlass to 0x8000008f0\n+      \/\/ java 23-internal 2024-09-17\n+      \/\/ ...\n@@ -186,2 +215,8 @@\n-        Address vtableInfoAddress = vtablesIndex.getAddressAt(i * addressSize); \/\/ = _index[i]\n-        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize); \/\/ = &_index[i]->_cloned_vtable[0]\n+        long vtable_offset = vtablesIndex.getJLongAt(i * addressSize); \/\/ long offset = _index[i]\n+\n+        \/\/ CppVtableInfo* t = the address of the CppVtableInfo for the i-th table\n+        Address vtableInfoAddress = mapped_base_address.addOffsetTo(vtable_offset);\n+\n+        \/\/ vtableAddress = &t->_cloned_vtable[0]\n+        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize);\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"}]}