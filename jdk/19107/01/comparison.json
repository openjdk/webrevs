{"files":[{"patch":"@@ -313,11 +313,3 @@\n-  _dump_region->append_intptr_t((intptr_t)ptr, true);\n-}\n-\n-void WriteClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    do_ptr((void**)start);\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n+  \/\/ null pointers do not need to be converted to offsets\n+  if (ptr != nullptr) {\n+    ptr = (address)ArchiveBuilder::current()->buffer_to_offset(ptr);\n@@ -325,0 +317,1 @@\n+  _dump_region->append_intptr_t((intptr_t)ptr, false);\n@@ -332,1 +325,1 @@\n-  *p = (void*)obj;\n+  *p = obj != 0 ? (void*)(SharedBaseAddress + obj) : (void*)obj;\n@@ -358,11 +351,0 @@\n-void ReadClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    *(intptr_t*)start = nextPtr();\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -218,1 +218,4 @@\n-  void do_region(u_char* start, size_t size);\n+  char* region_top() {\n+    return _dump_region->top();\n+  }\n+\n@@ -241,1 +244,0 @@\n-  void do_region(u_char* start, size_t size);\n@@ -243,0 +245,1 @@\n+  char* region_top() { return nullptr; }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-CppVtableInfo** CppVtables::_index = nullptr;\n+static CppVtableInfo* _index[_num_cloned_vtable_kinds];\n@@ -218,1 +218,7 @@\n-char* CppVtables::dumptime_init(ArchiveBuilder* builder) {\n+\/\/ Vtables are all fixed offsets from ArchiveBuilder::current()->mapped_base()\n+\/\/ E.g. ConstantPool is at offset 0x58. We can archive these offsets in the\n+\/\/ RO region and use them to alculate their location at runtime without storing\n+\/\/ the pointers in the RW region\n+char* CppVtables::_vtables_serialized_base = nullptr;\n+\n+void CppVtables::dumptime_init(ArchiveBuilder* builder) {\n@@ -220,2 +226,0 @@\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(CppVtableInfo*);\n-  _index = (CppVtableInfo**)builder->rw_region()->allocate(vtptrs_bytes);\n@@ -227,2 +231,0 @@\n-\n-  return (char*)_index;\n@@ -232,1 +234,6 @@\n-  soc->do_ptr(&_index);\n+  if (!soc->reading()) {\n+    _vtables_serialized_base = soc->region_top();\n+  }\n+  for (int i = 0; i < _num_cloned_vtable_kinds; i++) {\n+    soc->do_ptr(&_index[i]);\n+  }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  static CppVtableInfo** _index;\n+  static char* _vtables_serialized_base;\n@@ -41,1 +41,1 @@\n-  static char* dumptime_init(ArchiveBuilder* builder);\n+  static void dumptime_init(ArchiveBuilder* builder);\n@@ -46,0 +46,1 @@\n+  static char* vtables_serialized_base() { return _vtables_serialized_base; }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-  char* cloned_vtables = CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&builder);\n@@ -545,1 +545,1 @@\n-  mapinfo->set_cloned_vtables(cloned_vtables);\n+  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,13 @@\n-  virtual void do_region(u_char* start, size_t size) = 0;\n+  void do_region(u_char* start, size_t size) {\n+    assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n+    assert(size % sizeof(intptr_t) == 0, \"bad size\");\n+    do_tag((int)size);\n+    while (size > 0) {\n+      do_ptr((void**)start);\n+      start += sizeof(intptr_t);\n+      size -= sizeof(intptr_t);\n+    }\n+  }\n+\n+  \/\/ Address of the first element being written (write only)\n+  virtual char* region_top() = 0;\n","filename":"src\/hotspot\/share\/cds\/serializeClosure.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  private static Address mapped_base_address;\n@@ -101,1 +102,1 @@\n-    Address mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n+    mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n@@ -171,8 +172,20 @@\n-      \/\/ vtablesIndex points to this:\n-      \/\/     class CppVtableInfo {\n-      \/\/         intptr_t _vtable_size;\n-      \/\/         intptr_t _cloned_vtable[1];\n-      \/\/         ...\n-      \/\/     };\n-      \/\/     CppVtableInfo** CppVtables::_index;\n-      \/\/ This is the index of all the cloned vtables. E.g., for\n+      \/\/ vtablesIndex points to to an array like this:\n+      \/\/ long info[] = {\n+      \/\/   offset of the CppVtableInfo for ConstantPool,\n+      \/\/   offset of the CppVtableInfo for InstanceKlass,\n+      \/\/   offset of the CppVtableInfo for InstanceClassLoaderKlass,\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ class CppVtableInfo {\n+      \/\/   intptr_t _vtable_size;\n+      \/\/   intptr_t _cloned_vtable[1];\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ The loop below computes the following\n+      \/\/     CppVtableInfo* t_ConstantPool  = mapped_base_address + info[0];\n+      \/\/     CppVtableInfo* t_InstanceKlass = mapped_base_address + info[1];\n+      \/\/     ...\n+      \/\/\n+      \/\/ If we have the following objects\n@@ -181,3 +194,19 @@\n-      \/\/ the following holds true:\n-      \/\/     &_index[ConstantPool_Kind]->_cloned_vtable[0]  == ((intptr_t**)cp)[0]\n-      \/\/     &_index[InstanceKlass_Kind]->_cloned_vtable[0] == ((intptr_t**)ik)[0]\n+      \/\/\n+      \/\/ then the following holds true:\n+      \/\/     ((intptr_t**)cp)[0] == &t_ConstantPool->_cloned_vtable[0]  \/\/ The vtable for archived ConstantPools\n+      \/\/     ((intptr_t**)ik)[0] == &t_InstanceKlass->_cloned_vtable[0] \/\/ The vtable for archived InstanceKlasses\n+      \/\/\n+      \/\/ To get an idea what these address look like, do this:\n+      \/\/\n+      \/\/ $ java -Xlog:cds+vtables=debug -XX:+UnlockDiagnosticVMOptions -XX:ArchiveRelocationMode=0 --version\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for ConstantPool to 0x800000018\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceKlass to 0x800000090\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceClassLoaderKlass to 0x8000001e0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceMirrorKlass to 0x800000330\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceRefKlass to 0x800000480\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceStackChunkKlass to 0x8000005d0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for Method to 0x800000720\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for ObjArrayKlass to 0x800000798\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for TypeArrayKlass to 0x8000008f0\n+      \/\/ java 23-internal 2024-09-17\n+      \/\/ ...\n@@ -186,2 +215,8 @@\n-        Address vtableInfoAddress = vtablesIndex.getAddressAt(i * addressSize); \/\/ = _index[i]\n-        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize); \/\/ = &_index[i]->_cloned_vtable[0]\n+        long vtable_offset = vtablesIndex.getJLongAt(i * addressSize); \/\/ long offset = _index[i]\n+\n+        \/\/ CppVtableInfo* t = the address of the CppVtableInfo for the i-th table\n+        Address vtableInfoAddress = mapped_base_address.addOffsetTo(vtable_offset);\n+\n+        \/\/ vtableAddress = &t->_cloned_vtable[0]\n+        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize);\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"}]}