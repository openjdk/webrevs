{"files":[{"patch":"@@ -25,0 +25,5 @@\n+#ifndef SHARE_OPTO_DIVCONSTANTS_HPP\n+#define SHARE_OPTO_DIVCONSTANTS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -31,0 +36,2 @@\n+\n+#endif \/\/ SHARE_OPTO_DIVCONSTANTS_HPP\n","filename":"src\/hotspot\/share\/opto\/divconstants.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -52,0 +51,1 @@\n+#ifdef __SIZEOF_INT128__\n@@ -54,1 +54,1 @@\n-  juint bits = juint(os::random()) & 63 + 1;\n+  juint bits = juint(os::random()) % 63 + 1;\n@@ -62,1 +62,1 @@\n-  juint bits = juint(os::random()) & 64 + 1;\n+  juint bits = juint(os::random()) % 64 + 1;\n@@ -67,0 +67,1 @@\n+#endif \/\/ __SIZEOF_INT128__\n@@ -68,13 +69,2 @@\n-template <class T, class U>\n-static void test_division(T d, T N_neg, T N_pos, juint min_s) {\n-  constexpr juint W = sizeof(T) * 8;\n-\n-  if ((N_neg < d && N_pos < d) || (d & (d - 1)) == 0) {\n-    return;\n-  }\n-\n-  T c;\n-  bool c_ovf;\n-  juint s;\n-  magic_divide_constants(d, N_neg, N_pos, min_s, c, c_ovf, s);\n-\n+template <class UT, class U, class F>\n+static void test_op(UT d, UT N_neg, UT N_pos, F op) {\n@@ -84,1 +74,0 @@\n-  U c_long = c;\n@@ -92,13 +81,1 @@\n-    U actual;\n-    if (!c_ovf) {\n-      actual = ((l * U(c)) >> s) + (l < 0 ? U(1) : U(0));\n-    } else {\n-      ASSERT_EQ(N_neg, T(0));\n-      if (sizeof(U) > sizeof(T) * 2) {\n-        constexpr U wrap_amount = U(T(-1)) + 1;\n-        actual = (l * (U(c) + wrap_amount)) >> s;\n-      } else {\n-        U mul_hi = (l * U(c)) >> W;\n-        actual = (((l - mul_hi) >> 1) + mul_hi) >> (s - 1 - W);\n-      }\n-    }\n+    U actual = op(l);\n@@ -119,0 +96,30 @@\n+template <class UT, class U>\n+static void test_division(UT d, UT N_neg, UT N_pos, juint min_s) {\n+  constexpr juint W = sizeof(UT) * 8;\n+\n+  if ((N_neg < d && N_pos < d) || (d & (d - 1)) == 0) {\n+    return;\n+  }\n+\n+  UT c;\n+  bool c_ovf;\n+  juint s;\n+  magic_divide_constants(d, N_neg, N_pos, min_s, c, c_ovf, s);\n+\n+  auto op = [&](U l) -> U {\n+    if (!c_ovf) {\n+      return ((l * U(c)) >> s) + (l < 0 ? U(1) : U(0));\n+    } else {\n+      if (sizeof(U) > sizeof(UT) * 2) {\n+        constexpr U wrap_amount = U(UT(-1)) + 1;\n+        return (l * (U(c) + wrap_amount)) >> s;\n+      } else {\n+        U mul_hi = (l * U(c)) >> W;\n+        return (((l - mul_hi) >> 1) + mul_hi) >> (s - 1 - W);\n+      }\n+    }\n+  };\n+\n+  test_op<UT, U>(d, N_neg, N_pos, op);\n+}\n+\n@@ -121,1 +128,1 @@\n-  constexpr int ITER = 10000;\n+  constexpr int iter_num = 10000;\n@@ -123,1 +130,1 @@\n-  for (int i = 0; i < ITER; i++) {\n+  for (int i = 0; i < iter_num;) {\n@@ -125,0 +132,4 @@\n+    if ((d & (d - 1)) == 0) {\n+      continue;\n+    }\n+\n@@ -127,0 +138,4 @@\n+    if (N_neg < d && N_pos < d) {\n+      continue;\n+    }\n+\n@@ -128,0 +143,1 @@\n+\n@@ -129,0 +145,1 @@\n+    i++;\n@@ -152,0 +169,24 @@\n+static void test_division_round_down() {\n+  constexpr int iter_num = 10000;\n+  for (int i = 0; i < iter_num;) {\n+    constexpr juint W = 32;\n+    juint d = random<juint, juint>();\n+    juint s = log2i_graceful(d) + W;\n+    julong t = (julong(1) << s) \/ julong(d);\n+    julong r = ((t + 1) * julong(d)) & julong(max_juint);\n+    if (r <= (julong(1) << (s - W))) {\n+      continue;\n+    }\n+\n+    juint c;\n+    s = -1;\n+    magic_divide_constants_round_down(d, c, s);\n+    auto op = [&](julong l) -> julong {\n+      return ((l + 1) * c) >> s;\n+    };\n+\n+    test_op<juint, julong>(d, 0, std::numeric_limits<juint>::max(), op);\n+    i++;\n+  }\n+}\n+\n@@ -176,0 +217,2 @@\n+\n+  test_division_round_down();\n","filename":"test\/hotspot\/gtest\/opto\/test_constant_division.cpp","additions":75,"deletions":32,"binary":false,"changes":107,"status":"modified"}]}