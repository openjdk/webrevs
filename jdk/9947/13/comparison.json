{"files":[{"patch":"@@ -39,51 +39,0 @@\n-\/\/ Portions of code courtesy of Clifford Click\n-\n-\/\/ Optimization - Graph Style\n-\n-#include <math.h>\n-\n-\/\/----------------------magic_int_divide_constants-----------------------------\n-\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n-\/\/\n-\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n-\/\/ minor type name and parameter changes.\n-static bool magic_int_divide_constants(jint d, jint &M, jint &s) {\n-  int32_t p;\n-  uint32_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint32_t two31 = 0x80000000L;     \/\/ 2**31.\n-\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two31 + ((uint32_t)d >> 31);\n-  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n-  p = 31;                 \/\/ Init. p.\n-  q1 = two31\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n-  r1 = two31 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n-  q2 = two31\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n-  r2 = two31 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n-  do {\n-    p = p + 1;\n-    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n-    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n-    if (r1 >= anc) {      \/\/ (Must be an unsigned\n-      q1 = q1 + 1;        \/\/ comparison here).\n-      r1 = r1 - anc;\n-    }\n-    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n-    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n-    if (r2 >= ad) {       \/\/ (Must be an unsigned\n-      q2 = q2 + 1;        \/\/ comparison here).\n-      r2 = r2 - ad;\n-    }\n-    delta = ad - r2;\n-  } while (q1 < delta || (q1 == delta && r1 == 0));\n-\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n-  s = p - 32;             \/\/ shift amount to return.\n-\n-  return true;\n-}\n-\n@@ -93,1 +42,1 @@\n-static Node *transform_int_divide( PhaseGVN *phase, Node *dividend, jint divisor ) {\n+static Node* transform_int_divide(PhaseGVN* phase, Node* dividend, jint divisor) {\n@@ -101,1 +50,1 @@\n-  const int N = 32;\n+  constexpr int N = 32;\n@@ -104,1 +53,1 @@\n-  Node *q = nullptr;\n+  Node* q = nullptr;\n@@ -117,2 +66,2 @@\n-    const Type *dt = phase->type(dividend);\n-    const TypeInt *dti = dt->isa_int();\n+    const Type* dt = phase->type(dividend);\n+    const TypeInt* dti = dt->isa_int();\n@@ -125,1 +74,1 @@\n-      const TypeInt *andconi_t = phase->type( dividend->in(2) )->isa_int();\n+      const TypeInt* andconi_t = phase->type( dividend->in(2) )->isa_int();\n@@ -147,1 +96,1 @@\n-      Node *sign = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n+      Node* sign = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n@@ -149,1 +98,1 @@\n-      Node *round = phase->transform(new URShiftINode(sign, phase->intcon(N - l)));\n+      Node* round = phase->transform(new URShiftINode(sign, phase->intcon(N - l)));\n@@ -165,0 +114,3 @@\n+    \/\/\n+    \/\/ Some modifications are made since we multiply high by performing\n+    \/\/ long multiplication\n@@ -166,1 +118,1 @@\n-    jint magic_const;\n+    jlong magic_const;\n@@ -168,3 +120,23 @@\n-    if (magic_int_divide_constants(d, magic_const, shift_const)) {\n-      Node *magic = phase->longcon(magic_const);\n-      Node *dividend_long = phase->transform(new ConvI2LNode(dividend));\n+    magic_int_divide_constants(d, magic_const, shift_const);\n+    \/\/ magic_const should be a u32\n+    assert(magic_const >= 0 && magic_const <= jlong(max_juint), \"sanity\");\n+    assert(shift_const >= 0 && shift_const < 32, \"sanity\");\n+    Node* magic = phase->longcon(magic_const);\n+    Node* dividend_long = phase->transform(new ConvI2LNode(dividend));\n+\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    Node* mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n+    \/\/ i32 * u32 <: i64 so there should be no overflow\n+    \/\/ No add is required, we can merge the shifts together.\n+    mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n+    mul_hi = phase->transform(new ConvL2INode(mul_hi));\n+\n+    \/\/ Get a 0 or -1 from the sign of the dividend.\n+    Node* addend0 = mul_hi;\n+    Node* addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N-1)));\n+\n+    \/\/ If the divisor is negative, swap the order of the input addends;\n+    \/\/ this has the effect of negating the quotient.\n+    if (!d_pos) {\n+      Node* temp = addend0; addend0 = addend1; addend1 = temp;\n+    }\n@@ -172,2 +144,7 @@\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n+    \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n+    \/\/ from the mul_hi.\n+    q = new SubINode(addend0, addend1);\n+  }\n+\n+  return q;\n+}\n@@ -175,3 +152,6 @@\n-      if (magic_const < 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n+\/\/--------------------------transform_int_udivide------------------------------\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+\/\/ Return NULL if no transformation occurs.\n+static Node* transform_int_udivide( PhaseGVN* phase, Node* dividend, juint divisor ) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  constexpr int N = 32;\n@@ -179,4 +159,10 @@\n-        \/\/ The magic multiplier is too large for a 32 bit constant. We've adjusted\n-        \/\/ it down by 2^32, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddINode(dividend, mul_hi));\n+  \/\/ Result\n+  Node* q = NULL;\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    q = new URShiftINode(dividend, phase->intcon(l));\n+  } else {\n+    \/\/ Attempt the juint constant divide -> multiply transform found in\n+    \/\/   \"Division by Invariant Integers using Multiplication\"\n+    \/\/     by Granlund and Montgomery\n+    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n@@ -184,4 +170,22 @@\n-        \/\/ Shift over the (adjusted) mulhi\n-        if (shift_const != 0) {\n-          mul_hi = phase->transform(new RShiftINode(mul_hi, phase->intcon(shift_const)));\n-        }\n+    \/\/ Unsigned extension of dividend\n+    Node* dividend_long = phase->transform(new ConvI2LNode(dividend));\n+    dividend_long = phase->transform(new AndLNode(dividend_long, phase->longcon(max_juint)));\n+\n+    jlong magic_const;\n+    jint shift_const;\n+    magic_int_unsigned_divide_constants_down(divisor, magic_const, shift_const);\n+    assert(magic_const >= 0 && magic_const <= 0x1FFFFFFFFL, \"sanity\");\n+    assert(shift_const >= 0 && shift_const < 33, \"sanity\");\n+\n+    \/\/ magic_const is u33, max_abs_dividend is u32, so we must check for overflow\n+    const TypeInt* dividend_type = phase->type(dividend)->is_int();\n+    julong max_dividend;\n+    if (dividend_type->_hi < 0 || dividend_type->_lo >= 0) {\n+      max_dividend = julong(juint(dividend_type->_hi));\n+    } else {\n+      max_dividend = max_juint;\n+    }\n+    if (julong(magic_const) <= max_julong \/ max_dividend) {\n+      \/\/ No overflow here, just do the transformation\n+      if (shift_const == 32) {\n+        q = phase->intcon(0);\n@@ -189,4 +193,1 @@\n-        \/\/ No add is required, we can merge the shifts together.\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n-      }\n+        Node* magic = phase->longcon(magic_const);\n@@ -194,3 +195,2 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N-1)));\n+        \/\/ Compute the high half of the dividend x magic multiplication\n+        Node* mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n@@ -198,4 +198,3 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n+        \/\/ Merge the shifts together.\n+        mul_hi = phase->transform(new URShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n+        q = new ConvL2INode(mul_hi);\n@@ -203,0 +202,8 @@\n+    } else {\n+      \/\/ Original plan fails, rounding down of 1\/divisor does not work, change\n+      \/\/ to rounding up, now it is guaranteed to not overflow, according to\n+      \/\/ N-Bit Unsigned Division Via N-Bit Multiply-Add by Arch D. Robison\n+      magic_int_unsigned_divide_constants_up(divisor, magic_const, shift_const);\n+      assert(magic_const >= 0 && magic_const <= jlong(max_juint), \"sanity\");\n+      assert(shift_const >= 0 && shift_const < 32, \"sanity\");\n+      Node* magic = phase->longcon(magic_const);\n@@ -204,3 +211,7 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubINode(addend0, addend1);\n+      \/\/ Compute the high half of the dividend x magic multiplication\n+      Node* mul_hi = phase->transform(new AddLNode(dividend_long, phase->longcon(1)));\n+      mul_hi = phase->transform(new MulLNode(mul_hi, magic));\n+\n+      \/\/ Merge the shifts together.\n+      mul_hi = phase->transform(new URShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n+      q = new ConvL2INode(mul_hi);\n@@ -213,45 +224,0 @@\n-\/\/---------------------magic_long_divide_constants-----------------------------\n-\/\/ Compute magic multiplier and shift constant for converting a 64 bit divide\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n-\/\/\n-\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n-\/\/ minor type name and parameter changes.  Adjusted to 64 bit word width.\n-static bool magic_long_divide_constants(jlong d, jlong &M, jint &s) {\n-  int64_t p;\n-  uint64_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint64_t two63 = UCONST64(0x8000000000000000);     \/\/ 2**63.\n-\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two63 + ((uint64_t)d >> 63);\n-  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n-  p = 63;                 \/\/ Init. p.\n-  q1 = two63\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n-  r1 = two63 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n-  q2 = two63\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n-  r2 = two63 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n-  do {\n-    p = p + 1;\n-    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n-    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n-    if (r1 >= anc) {      \/\/ (Must be an unsigned\n-      q1 = q1 + 1;        \/\/ comparison here).\n-      r1 = r1 - anc;\n-    }\n-    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n-    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n-    if (r2 >= ad) {       \/\/ (Must be an unsigned\n-      q2 = q2 + 1;        \/\/ comparison here).\n-      r2 = r2 - ad;\n-    }\n-    delta = ad - r2;\n-  } while (q1 < delta || (q1 == delta && r1 == 0));\n-\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n-  s = p - 64;             \/\/ shift amount to return.\n-\n-  return true;\n-}\n-\n@@ -345,1 +311,1 @@\n-  const int N = 64;\n+  constexpr int N = 64;\n@@ -415,11 +381,12 @@\n-    if (magic_long_divide_constants(d, magic_const, shift_const)) {\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n-\n-      \/\/ The high half of the 128-bit multiply is computed.\n-      if (magic_const < 0) {\n-        \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n-        \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n-      }\n+    magic_long_divide_constants(d, magic_const, shift_const);\n+    assert(shift_const >= 0 && shift_const < 64, \"sanity\");\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    Node *mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n+\n+    \/\/ The high half of the 128-bit multiply is computed.\n+    if (magic_const < 0) {\n+      \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n+      \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n+      \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n+      mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n+    }\n@@ -427,4 +394,4 @@\n-      \/\/ Shift over the (adjusted) mulhi\n-      if (shift_const != 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const)));\n-      }\n+    \/\/ Shift over the (adjusted) mulhi\n+    if (shift_const != 0) {\n+      mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const)));\n+    }\n@@ -432,3 +399,3 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N-1)));\n+    \/\/ Get a 0 or -1 from the sign of the dividend.\n+    Node *addend0 = mul_hi;\n+    Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N-1)));\n@@ -436,4 +403,57 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n+    \/\/ If the divisor is negative, swap the order of the input addends;\n+    \/\/ this has the effect of negating the quotient.\n+    if (!d_pos) {\n+      Node *temp = addend0; addend0 = addend1; addend1 = temp;\n+    }\n+\n+    \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n+    \/\/ from the mul_hi.\n+    q = new SubLNode(addend0, addend1);\n+  }\n+\n+  return q;\n+}\n+\n+\/\/--------------------------transform_long_udivide-----------------------------\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+\/\/ Return NULL if no transformation occurs.\n+static Node* transform_long_udivide( PhaseGVN* phase, Node* dividend, julong divisor ) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+\n+  \/\/ Result\n+  Node* q = NULL;\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    q = new URShiftLNode(dividend, phase->intcon(l));\n+  } else {\n+    if (!Matcher::match_rule_supported(Op_UMulHiL)) {\n+      return nullptr; \/\/ Don't bother\n+    }\n+\n+    \/\/ Attempt the julong constant divide -> multiply transform found in\n+    \/\/   \"Division by Invariant Integers using Multiplication\"\n+    \/\/     by Granlund and Montgomery\n+    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n+\n+    \/\/ Unsigned extension of dividend\n+    jlong magic_const;\n+    jint shift_const;\n+    bool magic_const_ovf;\n+    magic_long_unsigned_divide_constants(divisor, magic_const, shift_const, magic_const_ovf);\n+    assert(shift_const >= 0 && shift_const < 65, \"sanity\");\n+\n+    Node* magic = phase->longcon(magic_const);\n+    Node* mul_hi = phase->transform(new UMulHiLNode(dividend, magic));\n+\n+    if (!magic_const_ovf) {\n+      assert(shift_const < 64, \"sanity\");\n+      q = new URShiftLNode(mul_hi, phase->intcon(shift_const));\n+    } else {\n+      \/\/ If the multiplication does not overflow 128-bit unsigned int, we can\n+      \/\/ do the addition right after\n+      const TypeLong* dividend_type = phase->type(dividend)->is_long();\n+      julong max_dividend;\n+      if (dividend_type->_hi < 0 || dividend_type->_lo >= 0) {\n+        max_dividend = julong(dividend_type->_hi);\n+      } else {\n+        max_dividend = max_julong;\n@@ -442,3 +462,23 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubLNode(addend0, addend1);\n+      \/\/ Just do the minimum for now\n+      if (max_dividend <= julong(min_jlong) || shift_const == 0) {\n+        if (shift_const == 64) {\n+          q = phase->longcon(0);\n+        } else {\n+          mul_hi = phase->transform(new AddLNode(mul_hi, dividend));\n+          q = new URShiftLNode(mul_hi, phase->intcon(shift_const));\n+        }\n+      } else {\n+        \/\/ q = floor((x * c) \/ 2**(64 + m)) = floor(((x * (c - 2**64)) \/ 2**64 + x) \/ 2**m)\n+        \/\/\n+        \/\/ Given: floor((x \/ m + y) \/ n) = floor((floor(x \/ m) + y) \/ n), we have\n+        \/\/ q = floor((floor((x * (c - 2**64)) \/ 2**64) + x) \/ 2**m)\n+        \/\/   = floor((mul_hi + x) \/ 2**m)\n+        \/\/ Let p = floor((mul_hi + x) \/ 2)\n+        \/\/       = floor((x - mul_hi) \/ 2 + mul_hi)\n+        \/\/       = floor((x - mul_hi) \/ 2) + mul_hi\n+        \/\/ Since x > mul_hi, this operation can be done precisely using Z\/2**64Z arithmetic\n+        Node* diff = phase->transform(new SubLNode(dividend, mul_hi));\n+        diff = phase->transform(new URShiftLNode(diff, phase->intcon(1)));\n+        Node* p = phase->transform(new AddLNode(diff, mul_hi));\n+        q = new URShiftLNode(p, phase->intcon(shift_const - 1));\n+      }\n@@ -855,4 +895,5 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -865,5 +906,7 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeInt* i1 = t1->isa_int();\n+  const TypeInt* i2 = t2->isa_int();\n+  assert(i1 != nullptr && i2 != nullptr, \"\");\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) \/ juint(i2->get_con()));\n+  }\n@@ -876,1 +919,1 @@\n-Node *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* UDivINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -878,2 +921,48 @@\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n+  if (in(0) && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if(in(0) && in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  const Type* t = phase->type(in(2));\n+  if(t == TypeInt::ONE) {       \/\/ Identity?\n+    return nullptr;             \/\/ Skip it\n+  }\n+\n+  const TypeInt* ti = t->isa_int();\n+  if(ti == nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);           \/\/ Yank control input\n+    return this;\n+  }\n+\n+  \/\/ Divisor very large, constant 2**31 can be transform to a shift\n+  if (ti->_hi <= 0 && ti->_hi > min_jint) {\n+    Node* cmp = phase->transform(new CmpUNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveINode(bol, phase->intcon(0), phase->intcon(1), TypeInt::BOOL);\n+  }\n+\n+  if(!ti->is_con()) {\n+    return nullptr;\n+  }\n+  juint i = ti->get_con();       \/\/ Get divisor\n+\n+  if (i == 0) {\n+    return nullptr;   \/\/ Dividing by zero constant does not idealize\n+  }\n+\n+  \/\/ Don't transform a constant-foldable\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_int() || u->is_int()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  return transform_int_udivide( phase, in(1), i );\n@@ -894,4 +983,5 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type( in(1) );\n+  const Type* t2 = phase->type( in(2) );\n+  if(t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -904,5 +994,7 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeLong* i1 = t1->isa_long();\n+  const TypeLong* i2 = t2->isa_long();\n+  assert(i1 != nullptr && i2 != nullptr, \"\");\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) \/ julong(i2->get_con()));\n+  }\n@@ -915,1 +1007,1 @@\n-Node *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* UDivLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -917,3 +1009,7 @@\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n-}\n+  if (in(0) && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if(in(0) && in(0)->is_top()) {\n+    return nullptr;\n+  }\n@@ -921,0 +1017,41 @@\n+  const Type* t = phase->type(in(2));\n+  if(t == TypeLong::ONE) {      \/\/ Identity?\n+    return nullptr;             \/\/ Skip it\n+  }\n+\n+  const TypeLong* ti = t->isa_long();\n+  if(ti == nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);           \/\/ Yank control input\n+    return this;\n+  }\n+\n+  \/\/ Divisor very large, constant 2**63 can be transform to a shift\n+  if (ti->_hi <= 0 && ti->_hi > min_jlong) {\n+    Node* cmp = phase->transform(new CmpULNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveLNode(bol, phase->longcon(0), phase->longcon(1), TypeLong::make(0, 1, Type::WidenMin));\n+  }\n+\n+  if(!ti->is_con()) {\n+    return nullptr;\n+  }\n+  julong i = ti->get_con();       \/\/ Get divisor\n+\n+  if (i == 0) {\n+    return nullptr;   \/\/ Dividing by zero constant does not idealize\n+  }\n+\n+  \/\/ Don't transform a constant-foldable\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_long() || u->is_long()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  return transform_long_udivide( phase, in(1), i );\n+}\n@@ -1086,8 +1223,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n-}\n-\n@@ -1260,0 +1389,146 @@\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node* UModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if(in(0) && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if(in(0) && in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Get the modulus\n+  const Type* t = phase->type(in(2));\n+  if(t == Type::TOP) {\n+    return nullptr;\n+  }\n+  const TypeInt* ti = t->is_int();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding mod-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);        \/\/ Yank control input\n+    return this;\n+  }\n+\n+  if(!ti->is_con()) {\n+    return nullptr;\n+  }\n+  juint con = ti->get_con();\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_int() || u->is_int()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ See if we are MOD'ing by 2^k\n+  if (is_power_of_2(con)) {\n+    return new AndINode(in(1), phase->intcon(con - 1));\n+  }\n+  \/\/ TODO: This can be calculated directly, see https:\/\/arxiv.org\/abs\/1902.01961\n+  Node* q = transform_int_udivide(phase, in(1), con);\n+  if (q == nullptr) {\n+    return nullptr;\n+  }\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulINode(q, phase->intcon(con)));\n+  return new SubINode(in(1), mul);\n+}\n+\n+\/\/------------------------------Value------------------------------------------\n+const Type* UModINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type( in(1) );\n+  const Type* t2 = phase->type( in(2) );\n+  if(t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeInt::ONE) {\n+    return TypeInt::ZERO;\n+  }\n+\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) % juint(i2->get_con()));\n+  }\n+\n+  return TypeInt::INT;\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node* UModLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if(in(0) && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  \/\/ Don't bother trying to transform a dead node\n+  if(in(0) && in(0)->is_top()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Get the modulus\n+  const Type* t = phase->type(in(2));\n+  if(t == Type::TOP) {\n+    return nullptr;\n+  }\n+  const TypeLong* ti = t->is_long();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding mod-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);        \/\/ Yank control input\n+    return this;\n+  }\n+\n+  if(!ti->is_con()) {\n+    return nullptr;\n+  }\n+  julong con = ti->get_con();\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_long() || u->is_long()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ See if we are MOD'ing by 2^k\n+  if (is_power_of_2(con)) {\n+    return new AndLNode(in(1), phase->longcon(con - 1));\n+  }\n+  Node* q = transform_long_udivide(phase, in(1), con);\n+  if (q == nullptr) {\n+    return nullptr;\n+  }\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulLNode(q, phase->longcon(con)));\n+  return new SubLNode(in(1), mul);\n+}\n+\n+\/\/------------------------------Value------------------------------------------\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeLong::ONE) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) % julong(i2->get_con()));\n+  }\n+\n+  return TypeLong::LONG;\n+}\n@@ -1304,9 +1579,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":469,"deletions":203,"binary":false,"changes":672,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModINode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -171,2 +171,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -180,1 +181,1 @@\n-  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModLNode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -182,2 +183,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/javaArithmetic.hpp\"\n@@ -307,10 +308,0 @@\n-const jlong min_jlong = CONST64(0x8000000000000000);\n-const jlong max_jlong = CONST64(0x7fffffffffffffff);\n-\n-\/\/-------------------------------------------\n-\/\/ Constant for jdouble\n-const jlong min_jlongDouble = CONST64(0x0000000000000001);\n-const jdouble min_jdouble = jdouble_cast(min_jlongDouble);\n-const jlong max_jlongDouble = CONST64(0x7fefffffffffffff);\n-const jdouble max_jdouble = jdouble_cast(max_jlongDouble);\n-\n@@ -439,3 +430,0 @@\n-typedef unsigned int uint;   NEEDS_CLEANUP\n-\n-\n@@ -530,7 +518,0 @@\n-\/\/ Additional Java basic types\n-\n-typedef uint8_t  jubyte;\n-typedef uint16_t jushort;\n-typedef uint32_t juint;\n-typedef uint64_t julong;\n-\n@@ -547,5 +528,0 @@\n-const jubyte  max_jubyte  = (jubyte)-1;  \/\/ 0xFF       largest jubyte\n-const jushort max_jushort = (jushort)-1; \/\/ 0xFFFF     largest jushort\n-const juint   max_juint   = (juint)-1;   \/\/ 0xFFFFFFFF largest juint\n-const julong  max_julong  = (julong)-1;  \/\/ 0xFF....FF largest julong\n-\n@@ -557,13 +533,0 @@\n-const jbyte min_jbyte = -(1 << 7);       \/\/ smallest jbyte\n-const jbyte max_jbyte = (1 << 7) - 1;    \/\/ largest jbyte\n-const jshort min_jshort = -(1 << 15);    \/\/ smallest jshort\n-const jshort max_jshort = (1 << 15) - 1; \/\/ largest jshort\n-\n-const jint min_jint = (jint)1 << (sizeof(jint)*BitsPerByte-1); \/\/ 0x80000000 == smallest jint\n-const jint max_jint = (juint)min_jint - 1;                     \/\/ 0x7FFFFFFF == largest jint\n-\n-const jint min_jintFloat = (jint)(0x00000001);\n-const jfloat min_jfloat = jfloat_cast(min_jintFloat);\n-const jint max_jintFloat = (jint)(0x7f7fffff);\n-const jfloat max_jfloat = jfloat_cast(max_jintFloat);\n-\n@@ -1194,122 +1157,0 @@\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ Sum and product which can never overflow: they wrap, just like the\n-\/\/ Java operations.  Note that we don't intend these to be used for\n-\/\/ general-purpose arithmetic: their purpose is to emulate Java\n-\/\/ operations.\n-\n-\/\/ The goal of this code to avoid undefined or implementation-defined\n-\/\/ behavior.  The use of an lvalue to reference cast is explicitly\n-\/\/ permitted by Lvalues and rvalues [basic.lval].  [Section 3.10 Para\n-\/\/ 15 in C++03]\n-#define JAVA_INTEGER_OP(OP, NAME, TYPE, UNSIGNED_TYPE)  \\\n-inline TYPE NAME (TYPE in1, TYPE in2) {                 \\\n-  UNSIGNED_TYPE ures = static_cast<UNSIGNED_TYPE>(in1); \\\n-  ures OP ## = static_cast<UNSIGNED_TYPE>(in2);         \\\n-  return reinterpret_cast<TYPE&>(ures);                 \\\n-}\n-\n-JAVA_INTEGER_OP(+, java_add, jint, juint)\n-JAVA_INTEGER_OP(-, java_subtract, jint, juint)\n-JAVA_INTEGER_OP(*, java_multiply, jint, juint)\n-JAVA_INTEGER_OP(+, java_add, jlong, julong)\n-JAVA_INTEGER_OP(-, java_subtract, jlong, julong)\n-JAVA_INTEGER_OP(*, java_multiply, jlong, julong)\n-\n-#undef JAVA_INTEGER_OP\n-\n-\/\/ Provide integer shift operations with Java semantics.  No overflow\n-\/\/ issues - left shifts simply discard shifted out bits.  No undefined\n-\/\/ behavior for large or negative shift quantities; instead the actual\n-\/\/ shift distance is the argument modulo the lhs value's size in bits.\n-\/\/ No undefined or implementation defined behavior for shifting negative\n-\/\/ values; left shift discards bits, right shift sign extends.  We use\n-\/\/ the same safe conversion technique as above for java_add and friends.\n-#define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)    \\\n-inline TYPE NAME (TYPE lhs, jint rhs) {                 \\\n-  const uint rhs_mask = (sizeof(TYPE) * 8) - 1;         \\\n-  STATIC_ASSERT(rhs_mask == 31 || rhs_mask == 63);      \\\n-  XTYPE xres = static_cast<XTYPE>(lhs);                 \\\n-  xres OP ## = (rhs & rhs_mask);                        \\\n-  return reinterpret_cast<TYPE&>(xres);                 \\\n-}\n-\n-JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jint, juint)\n-JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jlong, julong)\n-\n-\/\/ For signed shift right, assume C++ implementation >> sign extends.\n-\/\/\n-\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n-\/\/ and a negative value, the resulting value is implementation-defined.\"\n-\/\/\n-\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n-\/\/ requiring two's-complement behavior.\n-\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n-\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n-\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n-\/\/ arithmetic right shift, which performs sign-extension.\"\n-\/\/\n-\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n-\/\/ already behave that way. And it is unlikely any would go off and do something\n-\/\/ different now, with C++20 tightening things up.\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jint, jint)\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jlong, jlong)\n-\/\/ For >>> use C++ unsigned >>.\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jint, juint)\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jlong, julong)\n-\n-#undef JAVA_INTEGER_SHIFT_OP\n-\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ The goal of this code is to provide saturating operations for int\/uint.\n-\/\/ Checks overflow conditions and saturates the result to min_jint\/max_jint.\n-#define SATURATED_INTEGER_OP(OP, NAME, TYPE1, TYPE2) \\\n-inline int NAME (TYPE1 in1, TYPE2 in2) {             \\\n-  jlong res = static_cast<jlong>(in1);               \\\n-  res OP ## = static_cast<jlong>(in2);               \\\n-  if (res > max_jint) {                              \\\n-    res = max_jint;                                  \\\n-  } else if (res < min_jint) {                       \\\n-    res = min_jint;                                  \\\n-  }                                                  \\\n-  return static_cast<int>(res);                      \\\n-}\n-\n-SATURATED_INTEGER_OP(+, saturated_add, int, int)\n-SATURATED_INTEGER_OP(+, saturated_add, int, uint)\n-SATURATED_INTEGER_OP(+, saturated_add, uint, int)\n-SATURATED_INTEGER_OP(+, saturated_add, uint, uint)\n-\n-#undef SATURATED_INTEGER_OP\n-\n-\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n-inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n-  const uint64_t x1 = x >> 32u;\n-  const uint64_t x2 = x & 0xFFFFFFFF;\n-  const uint64_t y1 = y >> 32u;\n-  const uint64_t y2 = y & 0xFFFFFFFF;\n-  const uint64_t z2 = x2 * y2;\n-  const uint64_t t = x1 * y2 + (z2 >> 32u);\n-  uint64_t z1 = t & 0xFFFFFFFF;\n-  const uint64_t z0 = t >> 32u;\n-  z1 += x2 * y1;\n-\n-  return x1 * y1 + z0 + (z1 >> 32u);\n-}\n-\n-\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n-\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n-inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n-  const jlong x1 = java_shift_right((jlong)x, 32);\n-  const jlong x2 = x & 0xFFFFFFFF;\n-  const jlong y1 = java_shift_right((jlong)y, 32);\n-  const jlong y2 = y & 0xFFFFFFFF;\n-\n-  const uint64_t z2 = x2 * y2;\n-  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n-  int64_t z1 = t & 0xFFFFFFFF;\n-  const int64_t z0 = java_shift_right((jlong)t, 32);\n-  z1 += x2 * y1;\n-\n-  return x1 * y1 + z0 + java_shift_right((jlong)z1, 32);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":160,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+\/\/----------------------magic_int_divide_constants-----------------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n+\/\/ by constant into a multiply\/shift series.\n+\/\/\n+\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n+\/\/ minor type name and parameter changes.\n+\/\/\n+void magic_int_divide_constants(jint d, jlong& M, jint& s) {\n+  assert(d > 1, \"sanity\");\n+  int32_t p;\n+  jlong ad, anc, delta, q1, r1, q2, r2, t;\n+  const jlong two31 = 0x80000000L; \/\/ 2**31.\n+\n+  ad = jlong(d);\n+  t = two31;\n+  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n+  p = 31;                 \/\/ Init. p.\n+  q1 = two31\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n+  r1 = two31 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n+  q2 = two31\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n+  r2 = two31 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n+  do {\n+    p = p + 1;\n+    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n+    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n+    if (r1 >= anc) {      \/\/ (Must be an unsigned\n+      q1 = q1 + 1;        \/\/ comparison here).\n+      r1 = r1 - anc;\n+    }\n+    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n+    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n+    if (r2 >= ad) {       \/\/ (Must be an unsigned\n+      q2 = q2 + 1;        \/\/ comparison here).\n+      r2 = r2 - ad;\n+    }\n+    delta = ad - r2;\n+  } while (q1 < delta || (q1 == delta && r1 == 0));\n+\n+  M = q2 + 1;             \/\/ Magic number and\n+  s = p - 32;             \/\/ shift amount to return.\n+\n+  assert(M < java_shift_left(jlong(1), 32), \"\");\n+  assert(s < 32, \"\");\n+}\n+\n+\/\/---------------magic_int_unsigned_divide_constants_down----------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n+\/\/ by constant into a multiply\/add\/shift series.\n+\/\/\n+\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n+\/\/ minor type name and parameter changes.\n+void magic_int_unsigned_divide_constants_down(juint d, jlong& M, jint& s) {\n+  assert(d > 1, \"sanity\");\n+  jlong two31 = jlong(juint(min_jint));\n+  jlong two31m1 = jlong(juint(max_jint));\n+\n+  jint p;\n+  jlong nc, delta, q1, r1, q2, r2;\n+\n+  jlong ad = jlong(d);\n+  nc = jlong(max_juint) - (two31 * 2 - ad)%ad;\n+  p = 31;                  \/\/ Init. p.\n+  q1 = two31\/nc;           \/\/ Init. q1 = 2**p\/nc.\n+  r1 = two31 - q1*nc;      \/\/ Init. r1 = rem(2**p, nc).\n+  q2 = two31m1\/ad;         \/\/ Init. q2 = (2**p - 1)\/d.\n+  r2 = two31m1 - q2*ad;    \/\/ Init. r2 = rem(2**p - 1, d).\n+  do {\n+    p = p + 1;\n+    if (r1 >= nc - r1) {\n+      q1 = 2*q1 + 1;       \/\/ Update q1.\n+      r1 = 2*r1 - nc;      \/\/ Update r1.\n+    } else {\n+      q1 = 2*q1;\n+      r1 = 2*r1;\n+    }\n+    if (r2 + 1 >= ad - r2) {\n+      q2 = 2*q2 + 1;       \/\/ Update q2.\n+      r2 = 2*r2 + 1 - ad;  \/\/ Update r2.\n+    } else {\n+      q2 = 2*q2;\n+      r2 = 2*r2 + 1;\n+    }\n+    delta = ad - 1 - r2;\n+  } while (p < 64 && (q1 < delta || (q1 == delta && r1 == 0)));\n+  M = q2 + 1; \/\/ Magic number\n+  s = p - 32; \/\/ and shift amount to return\n+}\n+\n+\/\/-----------------magic_int_unsigned_divide_constants_up----------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n+\/\/ by constant into a multiply\/add\/shift series.\n+\/\/\n+\/\/ Borrowed almost verbatim from N-Bit Unsigned Division Via N-Bit Multiply-Add\n+\/\/ by Arch D. Robison\n+\/\/\n+\/\/ Call this up since we do this after failing with the down attempt\n+void magic_int_unsigned_divide_constants_up(juint d, jlong& M, jint& s) {\n+  assert(d > 1, \"sanity\");\n+  jint N = 32;\n+  s = log2i_graceful(d);\n+  julong t = (julong(1) << (s + N)) \/ julong(d);\n+  M = t;\n+#ifdef ASSERT\n+  julong r = ((t + 1) * julong(d)) & julong(max_juint);\n+  assert(r > (julong(1) << s), \"Should call down first since it is more efficient\");\n+#endif\n+}\n+\n+\/\/---------------------magic_long_divide_constants-----------------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 64 bit divide\n+\/\/ by constant into a multiply\/shift\/add series.\n+\/\/\n+\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n+\/\/ minor type name and parameter changes.  Adjusted to 64 bit word width.\n+void magic_long_divide_constants(jlong d, jlong& M, jint& s) {\n+  assert(d > 1, \"sanity\");\n+\n+  int64_t p;\n+  uint64_t ad, anc, delta, q1, r1, q2, r2, t;\n+  const uint64_t two63 = UCONST64(0x8000000000000000);     \/\/ 2**63.\n+\n+  ad = ABS(d);\n+  t = two63;\n+  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n+  p = 63;                 \/\/ Init. p.\n+  q1 = two63\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n+  r1 = two63 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n+  q2 = two63\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n+  r2 = two63 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n+  do {\n+    p = p + 1;\n+    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n+    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n+    if (r1 >= anc) {      \/\/ (Must be an unsigned\n+      q1 = q1 + 1;        \/\/ comparison here).\n+      r1 = r1 - anc;\n+    }\n+    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n+    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n+    if (r2 >= ad) {       \/\/ (Must be an unsigned\n+      q2 = q2 + 1;        \/\/ comparison here).\n+      r2 = r2 - ad;\n+    }\n+    delta = ad - r2;\n+  } while (q1 < delta || (q1 == delta && r1 == 0));\n+\n+  M = q2 + 1;\n+  s = p - 64;             \/\/ shift amount to return.\n+}\n+\n+\/\/-----------------magic_long_unsigned_divide_constants------------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 64 bit divide\n+\/\/ by constant into a multiply\/shift\/add series.\n+\/\/\n+\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n+\/\/ minor type name and parameter changes.  Adjusted to 64 bit word width.\n+void magic_long_unsigned_divide_constants(julong d, jlong& M, jint& s, bool& magic_const_ovf) {\n+  assert(d > 1, \"sanity\");\n+  julong two63 = julong(min_jlong);\n+  julong two63m1 = julong(max_jlong);\n+\n+  jint p;\n+  julong nc, delta, q1, r1, q2, r2;\n+\n+  nc = -1 - (-d)%d;       \/\/ Unsigned arithmetic here.\n+  p = 63;                 \/\/ Init. p.\n+  q1 = two63\/nc;          \/\/ Init. q1 = 2**p\/nc.\n+  r1 = two63 - q1*nc;     \/\/ Init. r1 = rem(2**p, nc).\n+  q2 = two63m1\/d;         \/\/ Init. q2 = (2**p - 1)\/d.\n+  r2 = two63m1 - q2*d;    \/\/ Init. r2 = rem(2**p - 1, d).\n+  magic_const_ovf = false;\n+  do {\n+    p = p + 1;\n+    if (r1 >= nc - r1) {\n+      q1 = 2*q1 + 1;      \/\/ Update q1.\n+      r1 = 2*r1 - nc;     \/\/ Update r1.\n+    } else {\n+      q1 = 2*q1;\n+      r1 = 2*r1;\n+    }\n+    if (r2 + 1 >= d - r2) {\n+      if (q2 >= two63m1) {\n+        magic_const_ovf = true;\n+      }\n+      q2 = 2*q2 + 1;      \/\/ Update q2.\n+      r2 = 2*r2 + 1 - d;  \/\/ Update r2.\n+    } else {\n+      if (q2 >= two63) {\n+        magic_const_ovf = true;\n+      }\n+      q2 = 2*q2;\n+      r2 = 2*r2 + 1;\n+    }\n+    delta = d - 1 - r2;\n+  } while (p < 128 && (q1 < delta || (q1 == delta && r1 == 0)));\n+  M = q2 + 1;             \/\/ Magic number\n+  s = p - 64;             \/\/ and shift amount to return\n+}\n","filename":"src\/hotspot\/share\/utilities\/javaArithmetic.cpp","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_JAVAARITHMETIC_HPP\n+#define SHARE_UTILITIES_JAVAARITHMETIC_HPP\n+\n+#include <cstdint>\n+#include <limits>\n+#include \"jni.h\"\n+\n+\/\/ Basic types' bounds\n+constexpr jbyte  min_jbyte  = std::numeric_limits<jbyte>::min();\n+constexpr jbyte  max_jbyte  = std::numeric_limits<jbyte>::max();\n+constexpr jshort min_jshort = std::numeric_limits<jshort>::min();\n+constexpr jshort max_jshort = std::numeric_limits<jshort>::max();\n+constexpr jint   min_jint   = std::numeric_limits<jint>::min();\n+constexpr jint   max_jint   = std::numeric_limits<jint>::max();\n+constexpr jlong  min_jlong  = std::numeric_limits<jlong>::min();\n+constexpr jlong  max_jlong  = std::numeric_limits<jlong>::max();\n+\n+constexpr jfloat  min_jfloat      = std::numeric_limits<jfloat>::min();\n+constexpr jint    min_jintFloat   = 0x00000001;\n+constexpr jfloat  max_jfloat      = std::numeric_limits<jfloat>::max();\n+constexpr jint    max_jintFloat   = 0x7f7fffff;\n+constexpr jdouble min_jdouble     = std::numeric_limits<jdouble>::min();\n+constexpr jlong   min_jlongDouble = 0x0000000000000001;\n+constexpr jdouble max_jdouble     = std::numeric_limits<jdouble>::max();\n+constexpr jlong   max_jlongDouble = 0x7fefffffffffffff;\n+\n+\/\/ Additional Java basic types\n+using jubyte  = uint8_t;\n+using jushort = uint16_t;\n+using juint   = uint32_t;\n+using julong  = uint64_t;\n+\n+constexpr jubyte  max_jubyte  = std::numeric_limits<jubyte>::max();\n+constexpr jushort max_jushort = std::numeric_limits<jushort>::max();\n+constexpr juint   max_juint   = std::numeric_limits<juint>::max();\n+constexpr julong  max_julong  = std::numeric_limits<julong>::max();\n+\n+using uint = unsigned int;\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Sum and product which can never overflow: they wrap, just like the\n+\/\/ Java operations.  Note that we don't intend these to be used for\n+\/\/ general-purpose arithmetic: their purpose is to emulate Java\n+\/\/ operations.\n+\n+\/\/ The goal of this code to avoid undefined or implementation-defined\n+\/\/ behavior.\n+#define JAVA_INTEGER_OP(OP, NAME, TYPE, UNSIGNED_TYPE)  \\\n+inline constexpr TYPE NAME (TYPE in1, TYPE in2) {       \\\n+  UNSIGNED_TYPE ures = static_cast<UNSIGNED_TYPE>(in1); \\\n+  ures OP ## = static_cast<UNSIGNED_TYPE>(in2);         \\\n+  return ures;                                          \\\n+}\n+\n+JAVA_INTEGER_OP(+, java_add, jint, juint)\n+JAVA_INTEGER_OP(-, java_subtract, jint, juint)\n+JAVA_INTEGER_OP(*, java_multiply, jint, juint)\n+JAVA_INTEGER_OP(+, java_add, jlong, julong)\n+JAVA_INTEGER_OP(-, java_subtract, jlong, julong)\n+JAVA_INTEGER_OP(*, java_multiply, jlong, julong)\n+\n+#undef JAVA_INTEGER_OP\n+\n+\/\/ Provide integer shift operations with Java semantics.  No overflow\n+\/\/ issues - left shifts simply discard shifted out bits.  No undefined\n+\/\/ behavior for large or negative shift quantities; instead the actual\n+\/\/ shift distance is the argument modulo the lhs value's size in bits.\n+\/\/ No undefined or implementation defined behavior for shifting negative\n+\/\/ values; left shift discards bits, right shift sign extends.  We use\n+\/\/ the same safe conversion technique as above for java_add and friends.\n+#define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)         \\\n+inline constexpr TYPE NAME (TYPE lhs, jint rhs) {            \\\n+  constexpr juint rhs_mask = (sizeof(TYPE) * 8) - 1;         \\\n+  static_assert(rhs_mask == 31 || rhs_mask == 63, \"sanity\"); \\\n+  XTYPE xres = static_cast<XTYPE>(lhs);                      \\\n+  xres OP ## = (rhs & rhs_mask);                             \\\n+  return xres;                                               \\\n+}\n+\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jlong, julong)\n+\n+\/\/ For signed shift right, assume C++ implementation >> sign extends.\n+\/\/\n+\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n+\/\/ and a negative value, the resulting value is implementation-defined.\"\n+\/\/\n+\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n+\/\/ requiring two's-complement behavior.\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n+\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n+\/\/ arithmetic right shift, which performs sign-extension.\"\n+\/\/\n+\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n+\/\/ already behave that way. And it is unlikely any would go off and do something\n+\/\/ different now, with C++20 tightening things up.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jint, jint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jlong, jlong)\n+\n+\/\/ For >>> use C++ unsigned >>.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jlong, julong)\n+\n+#undef JAVA_INTEGER_SHIFT_OP\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ The goal of this code is to provide saturating operations for int\/uint.\n+\/\/ Checks overflow conditions and saturates the result to min_jint\/max_jint.\n+#define SATURATED_INTEGER_OP(OP, NAME, TYPE1, TYPE2) \\\n+inline constexpr int NAME (TYPE1 in1, TYPE2 in2) {   \\\n+  jlong res = static_cast<jlong>(in1);               \\\n+  res OP ## = static_cast<jlong>(in2);               \\\n+  if (res > max_jint) {                              \\\n+    res = max_jint;                                  \\\n+  } else if (res < min_jint) {                       \\\n+    res = min_jint;                                  \\\n+  }                                                  \\\n+  return res;                                        \\\n+}\n+\n+SATURATED_INTEGER_OP(+, saturated_add, int, int)\n+SATURATED_INTEGER_OP(+, saturated_add, int, uint)\n+SATURATED_INTEGER_OP(+, saturated_add, uint, int)\n+SATURATED_INTEGER_OP(+, saturated_add, uint, uint)\n+\n+#undef SATURATED_INTEGER_OP\n+\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline constexpr uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const julong x1 = java_shift_right_unsigned(jlong(x), 32);\n+  const julong x2 = juint(x);\n+  const julong y1 = java_shift_right_unsigned(jlong(y), 32);\n+  const julong y2 = juint(y);\n+  const julong z2 = x2 * y2;\n+  const julong t = x1 * y2 + java_shift_right_unsigned(jlong(z2), 32);\n+  julong z1 = juint(t);\n+  const julong z0 = java_shift_right_unsigned(jlong(t), 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right_unsigned(jlong(z1), 32);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline constexpr int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = java_shift_right((jlong)x, 32);\n+  const jlong x2 = juint(x);\n+  const jlong y1 = java_shift_right((jlong)y, 32);\n+  const jlong y2 = juint(y);\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + java_shift_right_unsigned(jlong(z2), 32); \/\/ Unsigned shift\n+  int64_t z1 = juint(t);\n+  const int64_t z0 = java_shift_right((jlong)t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right((jlong)z1, 32);\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Provide methods to calculate the magic constants in transforming divisions\n+\/\/ by constants into series of multiplications and shifts\n+\/\/ TODO: have magic_long_unsigned_divide up and down when we can do 128-bit\n+\/\/ addition\n+void magic_int_divide_constants(jint d, jlong& M, jint& s);\n+void magic_int_unsigned_divide_constants_down(juint d, jlong& M, jint& s);\n+void magic_int_unsigned_divide_constants_up(juint d, jlong& M, jint& s);\n+void magic_long_divide_constants(jlong d, jlong& M, jint& s);\n+void magic_long_unsigned_divide_constants(julong d, jlong& M, jint& s, bool& magic_const_ovf);\n+\n+#endif \/\/ SHARE_UTILITIES_JAVAARITHMETIC_HPP\n","filename":"src\/hotspot\/share\/utilities\/javaArithmetic.hpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include <vector>\n+\n+#include \"unittest.hpp\"\n+#include \"utilities\/javaArithmetic.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+static void test_magic_int_divide_coefs(jint divisor, jlong expected_magic_const, jint expected_shift) {\n+  jlong magic_const;\n+  jint shift;\n+  magic_int_divide_constants(divisor, magic_const, shift);\n+  ASSERT_EQ(expected_magic_const, magic_const);\n+  ASSERT_EQ(expected_shift, shift);\n+}\n+\n+static void test_magic_int_unsigned_divide_down_coefs(juint divisor, jlong expected_magic_const, jint expected_shift) {\n+  jlong magic_const;\n+  jint shift;\n+  magic_int_unsigned_divide_constants_down(divisor, magic_const, shift);\n+  ASSERT_EQ(expected_magic_const, magic_const);\n+  ASSERT_EQ(expected_shift, shift);\n+}\n+\n+static void test_magic_int_unsigned_divide_up_coefs(juint divisor, jlong expected_magic_const, jint expected_shift) {\n+  jlong magic_const;\n+  jint shift;\n+  magic_int_unsigned_divide_constants_up(divisor, magic_const, shift);\n+  ASSERT_EQ(expected_magic_const, magic_const);\n+  ASSERT_EQ(expected_shift, shift);\n+}\n+\n+static void test_magic_long_divide_coefs(jlong divisor, jlong expected_magic_const, jint expected_shift) {\n+  jlong magic_const;\n+  jint shift;\n+  magic_long_divide_constants(divisor, magic_const, shift);\n+  ASSERT_EQ(expected_magic_const, magic_const);\n+  ASSERT_EQ(expected_shift, shift);\n+}\n+\n+static void test_magic_long_unsigned_divide_coefs(julong divisor, jlong expected_magic_const, jint expected_shift, bool expected_ovf) {\n+  jlong magic_const;\n+  jint shift;\n+  bool ovf;\n+  magic_long_unsigned_divide_constants(divisor, magic_const, shift, ovf);\n+  ASSERT_EQ(expected_magic_const, magic_const);\n+  ASSERT_EQ(expected_shift, shift);\n+  ASSERT_EQ(expected_ovf, ovf);\n+}\n+\n+template <class T>\n+static void test_divide(T dividend, T divisor) {}\n+\n+template <>\n+void test_divide<jint>(jint dividend, jint divisor) {\n+  if (divisor == 0 || divisor == 1 || divisor == -1 || divisor == min_jint) {\n+    return;\n+  }\n+\n+  jint expected = divisor == -1 ? java_subtract(0, dividend) : (dividend \/ divisor);\n+\n+  jint abs_divisor = divisor > 0 ? divisor : java_subtract(0, divisor);\n+  if (is_power_of_2(abs_divisor)) {\n+    jint l = log2i_exact(abs_divisor);\n+    if (dividend > 0 || (dividend & (abs_divisor - 1)) == 0) {\n+      jint result = java_shift_right(dividend, l);\n+      ASSERT_EQ(expected, divisor > 0 ? result : java_subtract(0, result));\n+    }\n+    jint rounded_dividend = java_add(dividend, java_shift_right_unsigned(java_shift_right(dividend, 31), 32 - l));\n+    jint result = java_shift_right(rounded_dividend, l);\n+    ASSERT_EQ(expected, divisor > 0 ? result : java_subtract(0, result));\n+  }\n+\n+  jlong magic_const;\n+  jint shift;\n+  magic_int_divide_constants(abs_divisor, magic_const, shift);\n+  jint result = jint(java_shift_right(java_multiply(jlong(dividend), magic_const), shift + 32));\n+  if (divisor < 0) {\n+    result = java_subtract(java_shift_right(dividend, 31), result);\n+  } else {\n+    result = java_subtract(result, java_shift_right(dividend, 31));\n+  }\n+  ASSERT_EQ(expected, result);\n+}\n+\n+template <>\n+void test_divide<juint>(juint dividend, juint divisor) {\n+  if (divisor == 0 || divisor == 1) {\n+    return;\n+  }\n+\n+  juint expected = dividend \/ divisor;\n+\n+  if (is_power_of_2(divisor)) {\n+    jint l = log2i_exact(divisor);\n+    juint result = java_shift_right_unsigned(jint(dividend), l);\n+    ASSERT_EQ(expected, result);\n+  }\n+\n+  jlong magic_const;\n+  jint shift;\n+  magic_int_unsigned_divide_constants_down(divisor, magic_const, shift);\n+  if (julong(magic_const) <= max_julong \/ dividend) {\n+    if (shift == 32) {\n+      juint result = 0;\n+      ASSERT_EQ(expected, result);\n+    } else {\n+      juint result = java_shift_right_unsigned(java_multiply(jlong(dividend), magic_const), shift + 32);\n+      ASSERT_EQ(expected, result);\n+    }\n+  }\n+  if (magic_const > max_juint) {\n+    magic_int_unsigned_divide_constants_up(divisor, magic_const, shift);\n+    \/\/ This case guarantee shift < 32 so we do not need to special case like above\n+    juint result = java_shift_right_unsigned(java_multiply(jlong(dividend) + 1, magic_const), shift + 32);\n+    ASSERT_EQ(expected, result);\n+  }\n+}\n+\n+template <>\n+void test_divide<jlong>(jlong dividend, jlong divisor) {\n+  if (divisor == 0 || divisor == -1 || divisor == 1 || divisor == min_jlong) {\n+    return;\n+  }\n+\n+  jlong expected = divisor == -1 ? java_subtract(jlong(0), dividend) : (dividend \/ divisor);\n+\n+  jlong abs_divisor = divisor > 0 ? divisor : java_subtract(jlong(0), divisor);\n+  if (abs_divisor > 0 && is_power_of_2(abs_divisor)) {\n+    jint l = log2i_exact(abs_divisor);\n+    if (dividend > 0 || (dividend & (abs_divisor - 1)) == 0) {\n+      jlong result = java_shift_right(dividend, l);\n+      ASSERT_EQ(expected, divisor > 0 ? result : java_subtract(jlong(0), result));\n+    }\n+    jlong rounded_dividend = java_add(dividend, java_shift_right_unsigned(java_shift_right(dividend, 63), 64 - l));\n+    jlong result = java_shift_right(rounded_dividend, l);\n+    ASSERT_EQ(expected, divisor > 0 ? result : java_subtract(jlong(0), result));\n+  }\n+\n+  jlong magic_const;\n+  jint shift;\n+  magic_long_divide_constants(abs_divisor, magic_const, shift);\n+  jlong result = multiply_high_signed(dividend, magic_const);\n+  if (magic_const < 0) {\n+    result += dividend;\n+  }\n+  result = java_shift_right(result, shift);\n+  if (divisor < 0) {\n+    result = java_subtract(java_shift_right(dividend, 63), result);\n+  } else {\n+    result = java_subtract(result, java_shift_right(dividend, 63));\n+  }\n+  ASSERT_EQ(expected, result);\n+}\n+\n+template <>\n+void test_divide<julong>(julong dividend, julong divisor) {\n+  if (divisor == 0 || divisor == 1) {\n+    return;\n+  }\n+\n+  julong expected = dividend \/ divisor;\n+\n+  if (is_power_of_2(divisor)) {\n+    jint l = log2i_exact(divisor);\n+    julong result = java_shift_right_unsigned(jlong(dividend), l);\n+    ASSERT_EQ(expected, result);\n+  }\n+\n+  jlong magic_const;\n+  jint shift;\n+  bool magic_const_ovf;\n+  magic_long_unsigned_divide_constants(divisor, magic_const, shift, magic_const_ovf);\n+  jlong mul_hi = multiply_high_unsigned(dividend, magic_const);\n+  if (!magic_const_ovf) {\n+    julong result = java_shift_right_unsigned(mul_hi, shift);\n+    ASSERT_EQ(expected, result);\n+  } else {\n+    if (dividend <= julong(min_jlong) || shift == 0) {\n+      if (shift == 64) {\n+        julong result = 0;\n+        ASSERT_EQ(expected, result);\n+      } else {\n+        jlong mul_hi_corrected = java_add(mul_hi, dividend);\n+        julong result = java_shift_right_unsigned(mul_hi_corrected, shift);\n+        ASSERT_EQ(expected, result);\n+      }\n+    }\n+\n+    jlong diff = java_subtract(dividend, mul_hi);\n+    diff = java_shift_right_unsigned(diff, 1);\n+    diff = java_add(diff, mul_hi);\n+    \/\/ shift <= 64 so we do not need to special case like above\n+    julong result = java_shift_right_unsigned(diff, shift - 1);\n+    ASSERT_EQ(expected, result);\n+  }\n+  \n+}\n+\n+static void test_hardcoded_coefs() {\n+  \/\/ These numbers are taken from the output of gcc 12.2 or msvc 19.33\n+  test_magic_int_divide_coefs(3, 1431655766, 0);\n+  test_magic_int_divide_coefs(5, 1717986919, 1);\n+  test_magic_int_divide_coefs(6, 715827883, 0);\n+  test_magic_int_divide_coefs(7, 2454267027, 2);\n+  test_magic_int_divide_coefs(9, 954437177, 1);\n+  test_magic_int_divide_coefs(14, 2454267027, 3);\n+  test_magic_int_divide_coefs(101, 680390859, 4);\n+  test_magic_int_divide_coefs(1000, 274877907, 6);\n+  test_magic_int_divide_coefs(1000000, 1125899907, 18);\n+  test_magic_int_divide_coefs(1000000000, 1152921505, 28);\n+  test_magic_int_divide_coefs(2147483647, 1073741825, 29);\n+\n+  \/\/ These numbers are taken from the output of gcc 12.2 or msvc 19.33\n+  test_magic_int_unsigned_divide_down_coefs(3, 2863311531, 1);\n+  test_magic_int_unsigned_divide_down_coefs(5, 3435973837, 2);\n+  test_magic_int_unsigned_divide_down_coefs(6, 2863311531, 2);\n+  test_magic_int_unsigned_divide_down_coefs(7, 4908534053, 3);\n+  test_magic_int_unsigned_divide_down_coefs(9, 954437177, 1);\n+  test_magic_int_unsigned_divide_down_coefs(14, 4908534053, 4);\n+  test_magic_int_unsigned_divide_down_coefs(101, 5443126871, 7);\n+  test_magic_int_unsigned_divide_down_coefs(1000, 274877907, 6);\n+  test_magic_int_unsigned_divide_down_coefs(1000000, 1125899907, 18);\n+  test_magic_int_unsigned_divide_down_coefs(1000000000, 4611686019, 30);\n+  test_magic_int_unsigned_divide_down_coefs(2147483647, 4294967299, 31);\n+\n+  \/\/ These numbers are calculated manually according to\n+  \/\/ N-Bit Unsigned Division Via N-Bit Multiply-Add by Arch D. Robison\n+  \/\/ shift = floor(log(2, divisor))\n+  \/\/ magic_const = floor(2^(shift + 32) \/ divisor)\n+  test_magic_int_unsigned_divide_up_coefs(7, 2454267026, 2);\n+  test_magic_int_unsigned_divide_up_coefs(14, 2454267026, 3);\n+  test_magic_int_unsigned_divide_up_coefs(101, 2721563435, 6);\n+  test_magic_int_unsigned_divide_up_coefs(1000000000, 2305843009, 29);\n+  test_magic_int_unsigned_divide_up_coefs(2147483647, 2147483649, 30);\n+\n+  \/\/ These numbers are taken from the output of gcc 12.2 or msvc 19.33\n+  test_magic_long_divide_coefs(3, 6148914691236517206, 0);\n+  test_magic_long_divide_coefs(5, 7378697629483820647, 1);\n+  test_magic_long_divide_coefs(6, 3074457345618258603, 0);\n+  test_magic_long_divide_coefs(7, 5270498306774157605, 1);\n+  test_magic_long_divide_coefs(9, 2049638230412172402, 0);\n+  test_magic_long_divide_coefs(14, 5270498306774157605, 2);\n+  test_magic_long_divide_coefs(101, -6757718126012409997, 6);\n+  test_magic_long_divide_coefs(1000, 2361183241434822607, 7);\n+  test_magic_long_divide_coefs(1000000, 4835703278458516699, 18);\n+  test_magic_long_divide_coefs(1000000000, 1237940039285380275, 26);\n+  test_magic_long_divide_coefs(2147483647, -9223372032559808509, 30);\n+  test_magic_long_divide_coefs(2147483649, 4611686016279904257, 29);\n+  test_magic_long_divide_coefs(4294967295, -9223372034707292159, 31);\n+  test_magic_long_divide_coefs(4294967297, 9223372034707292161, 31);\n+  test_magic_long_divide_coefs(9223372036854775807, 4611686018427387905, 61);\n+\n+  \/\/ These numbers are taken from the output of gcc 12.2 or or msvc 19.33\n+  test_magic_long_unsigned_divide_coefs(3, -6148914691236517205, 1, false);\n+  test_magic_long_unsigned_divide_coefs(5, -3689348814741910323, 2, false);\n+  test_magic_long_unsigned_divide_coefs(6, -6148914691236517205, 2, false);\n+  test_magic_long_unsigned_divide_coefs(7, 2635249153387078803, 3, true);\n+  test_magic_long_unsigned_divide_coefs(9, -2049638230412172401, 3, false);\n+  test_magic_long_unsigned_divide_coefs(14, 2635249153387078803, 4, true);\n+  test_magic_long_unsigned_divide_coefs(101, 4931307821684731621, 7, true);\n+  test_magic_long_unsigned_divide_coefs(1000, 442721857769029239, 10, true);\n+  test_magic_long_unsigned_divide_coefs(1000000, 4835703278458516699, 18, false);\n+  test_magic_long_unsigned_divide_coefs(1000000000, 1360296554856532783, 30, true);\n+  test_magic_long_unsigned_divide_coefs(2147483647, 8589934597, 31, true);\n+  test_magic_long_unsigned_divide_coefs(2147483649, 4611686016279904257, 29, false);\n+  test_magic_long_unsigned_divide_coefs(4294967295, -9223372034707292159, 31, false);\n+  test_magic_long_unsigned_divide_coefs(4292967297, 8593932156542825, 32, true);\n+  test_magic_long_unsigned_divide_coefs(9223372036854775807, 3, 63, true);\n+}\n+\n+template <class T>\n+static void test_division() {\n+  using U = std::make_unsigned_t<T>;\n+  constexpr T min_value = std::numeric_limits<T>::min();\n+  constexpr T max_value = std::numeric_limits<T>::max();\n+  std::vector<T> operands;\n+\n+  operands.push_back(0);\n+  operands.push_back(1); operands.push_back(2); operands.push_back(3);\n+  operands.push_back(-1); operands.push_back(-2); operands.push_back(-3);\n+  operands.push_back(min_value); operands.push_back(min_value + 1); operands.push_back(min_value + 2);\n+  operands.push_back(max_value); operands.push_back(max_value - 1); operands.push_back(max_value - 2);\n+\n+  for (juint i = 2; i < sizeof(T) * 8 - 2; i += 4) {\n+    T twoPowI = java_shift_left(T(1), i);\n+    operands.push_back(twoPowI);\n+    operands.push_back(twoPowI + 1);\n+    operands.push_back(twoPowI - 1);\n+  }\n+\n+  juint current_size = juint(operands.size());\n+  for (juint i = 0; i < current_size; i++) {\n+    for (juint j = 0; j <= i; j++) {\n+      operands.push_back(java_multiply(operands.at(i), operands.at(j)));\n+    }\n+  }\n+\n+  for (juint i = 0; i < operands.size(); i++) {\n+    for (juint j = 0; j < operands.size(); j++) {\n+      T dividend = operands.at(i);\n+      T divisor = operands.at(j);\n+      test_divide<T>(dividend, divisor);\n+      test_divide<U>(dividend, divisor);\n+    }\n+  }\n+}\n+\n+TEST(opto, divide_by_constants) {\n+  test_hardcoded_coefs();\n+  test_division<jint>();\n+  test_division<jlong>();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_constant_division.cpp","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-                 \"magicDiv\"})\n+                 \"magicDiv13\", \"magicDiv7\"})\n@@ -92,1 +92,2 @@\n-        Asserts.assertEQ(a \/ 13       , magicDiv(a));\n+        Asserts.assertEQ(a \/ 13       , magicDiv13(a));\n+        Asserts.assertEQ(a \/ 7        , magicDiv7(a));\n@@ -199,4 +200,2 @@\n-    \/\/ More tests can be made to cover the specific cases for differences in the\n-    \/\/ graph that depend upon different values for the \"magic constant\" and the\n-    \/\/ \"shift constant\"\n-    public int magicDiv(int x) {\n+    \/\/ The constant derived from 13 lies inside the limit of an i32\n+    public int magicDiv13(int x) {\n@@ -205,0 +204,14 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of an i32 but inside the limit\n+    \/\/ of a u32\n+    public int magicDiv7(int x) {\n+        return x \/ 7;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.bits == 64\n@@ -42,1 +43,2 @@\n-                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\"})\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\",\n+                 \"magicDiv19\", \"magicDiv15\"})\n@@ -91,0 +93,2 @@\n+        Asserts.assertEQ(a \/ 19       , magicDiv19(a));\n+        Asserts.assertEQ(a \/ 15       , magicDiv15(a));\n@@ -190,0 +194,26 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.MUL_HI_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an i64\n+    public long magicDiv19(long x) {\n+        return x \/ 19L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"2\",\n+                  IRNode.MUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 15 lies outside the limit of an i64 but inside the limit\n+    \/\/ of a u64\n+    public long magicDiv15(long x) {\n+        return x \/ 15L;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivINode and UModINode are\n+ * being performed as expected.\n+ *\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivINodeIdealizationTests\n+ *\/\n+public class UDivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisor\",\n+                 \"magicDiv13\", \"magicDiv7\",\n+                \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod13\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+            a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+            b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public int udiv(int a, int b) {\n+        return Integer.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public int umod(int a, int b) {\n+        return Integer.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(1, constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(0, constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a           , identity(a));\n+        Asserts.assertEQ(a           , identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8) , divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7) , largeDivisor(a));\n+        Asserts.assertEQ(udiv(a, 13), magicDiv13(a));\n+        Asserts.assertEQ(udiv(a, 7) , magicDiv7(a));\n+        Asserts.assertEQ(umod(a, 1) , constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8) , modByPow2(a));\n+        Asserts.assertEQ(umod(a, 13), magicMod13(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constantDiv(int x) {\n+        return Integer.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return Integer.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.UDIV_I, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return Integer.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.URSHIFT_I, \"1\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public int divByPow2(int x) {\n+        return Integer.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.CMP_U, \"1\",\n+                  IRNode.CMOVE_I, \"1\"\n+                 })\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public int largeDivisor(int x) {\n+        return Integer.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of a u32\n+    public int magicDiv13(int x) {\n+        return Integer.divideUnsigned(x, 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of a u32 but inside the limit\n+    \/\/ of a u33\n+    public int magicDiv7(int x) {\n+        return Integer.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constantMod(int x) {\n+        return Integer.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantModAgain(int x) {\n+        return Integer.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public int modByPow2(int x) {\n+        return Integer.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                  IRNode.MUL_I, \"1\",\n+                  IRNode.SUB_I, \"1\"\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of an u32\n+    public int magicMod13(int x) {\n+        return Integer.remainderUnsigned(x, 13);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivLNode and UModLNode are\n+ * being performed as expected.\n+ *\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivLNodeIdealizationTests\n+ *\/\n+public class UDivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisor\",\n+                 \"magicDiv19\", \"magicDiv7\",\n+                 \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod19\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+             a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+             b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public long udiv(long a, long b) {\n+        return Long.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public long umod(long a, long b) {\n+        return Long.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(udiv(a, a), constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(umod(a, a), constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a           , identity(a));\n+        Asserts.assertEQ(a           , identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8) , divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7) , largeDivisor(a));\n+        Asserts.assertEQ(udiv(a, 19), magicDiv19(a));\n+        Asserts.assertEQ(udiv(a, 7) , magicDiv7(a));\n+        Asserts.assertEQ(umod(a, 1) , constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8) , modByPow2(a));\n+        Asserts.assertEQ(umod(a, 19), magicMod19(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constantDiv(long x) {\n+        return Long.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return Long.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.UDIV_L, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return Long.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public long divByPow2(long x) {\n+        return Long.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.CMP_UL, \"1\",\n+                  IRNode.CMOVE_L, \"1\"\n+                 })\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public long largeDivisor(long x) {\n+        return Long.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an u64\n+    public long magicDiv19(long x) {\n+        return Long.divideUnsigned(x, 19);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of an u64 but inside the limit\n+    \/\/ of a u65\n+    public long magicDiv7(long x) {\n+        return Long.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constantMod(long x) {\n+        return Long.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantModAgain(long x) {\n+        return Long.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.AND_L, \"1\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public long modByPow2(long x) {\n+        return Long.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an u64\n+    public long magicMod19(long x) {\n+        return Long.remainderUnsigned(x, 19);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -307,0 +307,5 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+    }\n+\n@@ -712,0 +717,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGeneratorFactory;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,3 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n@@ -58,0 +54,1 @@\n+\n@@ -66,1 +63,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGeneratorFactory.getDefault().create(0);\n@@ -70,2 +67,12 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisor = divisor == 0 ? 1 : divisor;\n+            if (divisorType.equals(\"positive\")) {\n+                if (divisor == Integer.MIN_VALUE) {\n+                    divisor = Integer.MAX_VALUE;\n+                } else if (divisor < 0) {\n+                    divisor = -divisor;\n+                }\n+            } else if (divisorType.equals(\"negative\")) {\n+                if (divisor > 0) {\n+                    divisor = -divisor;\n+                }\n+            }\n@@ -93,1 +100,11 @@\n-            divmod(dividends[i], divisors[i], i);\n+            int dividend = dividends[i];\n+            int divisor = divisors[i];\n+            quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+            remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ 7;\n@@ -97,3 +114,5 @@\n-    public void divmod(int dividend, int divisor, int i) {\n-        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n-        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned(dividends[i], 7);\n+        }\n@@ -102,0 +121,6 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Integer.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -103,3 +128,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGeneratorFactory;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,3 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n@@ -58,0 +54,1 @@\n+\n@@ -66,1 +63,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGeneratorFactory.getDefault().create(0);\n@@ -70,2 +67,12 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisor = divisor == 0 ? 1 : divisor;\n+            if (divisorType.equals(\"positive\")) {\n+                if (divisor == Long.MIN_VALUE) {\n+                    divisor = Long.MAX_VALUE;\n+                } else if (divisor < 0) {\n+                    divisor = -divisor;\n+                }\n+            } else if (divisorType.equals(\"negative\")) {\n+                if (divisor > 0) {\n+                    divisor = -divisor;\n+                }\n+            }\n@@ -93,1 +100,4 @@\n-            divmod(dividends[i], divisors[i], i);\n+            long dividend = dividends[i];\n+            long divisor = divisors[i];\n+            quotients[i] = Long.divideUnsigned(dividend, divisor);\n+            remainders[i] = Long.remainderUnsigned(dividend, divisor);\n@@ -97,3 +107,5 @@\n-    public void divmod(long dividend, long divisor, int i) {\n-        quotients[i] = Long.divideUnsigned(dividend, divisor);\n-        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(dividends[i], 7);\n+        }\n@@ -102,0 +114,6 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Long.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -103,3 +121,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":32,"deletions":17,"binary":false,"changes":49,"status":"modified"}]}