{"files":[{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#include <limits>\n+#include <type_traits>\n+\n+\/\/ Compute magic multiplier and shift constant for converting a 32\/64 bit\n+\/\/ division by constant into a multiply\/shift series.\n+\/\/\n+\/\/ (1) Theory:\n+\/\/ Motivated by Henry S. Warren. 2012. Hacker's Delight (2nd. ed.). Addison-Wesley Professional.\n+\/\/\n+\/\/ Given positive integers d <= N, call v the largest integer not larger than\n+\/\/ N such that v + 1 is divisible by d.\n+\/\/\n+\/\/ (a) For positive values c, m such that:\n+\/\/\n+\/\/ m <= c * d < m + m \/ v\n+\/\/\n+\/\/ We have:\n+\/\/\n+\/\/ floor(x \/ d) = floor(x * c \/ m) for every integer x in [0, N]\n+\/\/\n+\/\/ (b) For positive values c, m such that:\n+\/\/\n+\/\/ m < c * d <= m + m \/ v\n+\/\/\n+\/\/ We have:\n+\/\/\n+\/\/ ceil(x \/ d) = floor(x * c \/ m) + 1 for every integer x in [-N, 0)\n+\/\/\n+\/\/ (2) Proof:\n+\/\/\n+\/\/ (a) The conclusion is trivial for x = 0\n+\/\/\n+\/\/ For 0 < x <= v\n+\/\/\n+\/\/ Since 1 \/ d <= c \/ m < (1 \/ d) * ((v + 1) \/ v)\n+\/\/\n+\/\/ We have x \/ d <= x * c \/ m < (x * ((v + 1) \/ v)) \/ d\n+\/\/\n+\/\/ As a result, since x * ((v + 1) \/ v) <= x * ((x + 1) \/ x) = x + 1\n+\/\/\n+\/\/ x \/ d <= x * c \/ m < (x + 1) \/ d, which implies floor(x \/ d) = floor(x * c \/ m) since\n+\/\/ there can be no integer in (x \/ d, (x + 1) \/ d)\n+\/\/\n+\/\/ For v + 1 <= x <= v + d - 1, since v >= d - 1, we have x <= 2v\n+\/\/ As a result, x * ((v + 1) \/ v) <= x * ((x + 2) \/ x)\n+\/\/\n+\/\/ floor(x \/ d) = (v + 1) \/ d\n+\/\/ x * c \/ m < x * ((v + 1) \/ v) \/ d) <= x * ((x + 2) \/ x) \/ d = (x + 2) \/ d\n+\/\/           <= (v + d - 1 + 2) \/ d = (v + 1) \/ d + 1\n+\/\/ Which means (v + 1) \/ d <= floor(x * c \/ m) < (v + 1) \/ d + 1 with (v + 1) \/ d being an integer\n+\/\/ This implies floor(x \/ d) = floor(x * c \/ m) for v + 1 <= x <= v + d - 1\n+\/\/\n+\/\/ Combining all the cases gives us the conclusion.\n+\/\/\n+\/\/ (b) Since ceil(a \/ b) = floor((a - 1) \/ b) + 1, we need to prove:\n+\/\/\n+\/\/ floor((x - 1) \/ d) = floor(x * c \/ m)\n+\/\/\n+\/\/ For 0 > x >= -v\n+\/\/\n+\/\/ Since 1 \/ d < c \/ m <= (1 \/ d) * ((v + 1) \/ v)\n+\/\/\n+\/\/ We have x \/ d > x * c \/ m >= (x \/ d) * ((v + 1) \/ v)\n+\/\/\n+\/\/ since x * ((v + 1) \/ v) >= x * ((x - 1) \/ x) = x - 1\n+\/\/ x \/ d > x * c \/ m >= (x - 1) \/ d, which implies floor((x - 1) \/ d) = floor(x * c \/ m) since\n+\/\/ there can be no integer in ((x - 1) \/ d, x \/ d)\n+\/\/\n+\/\/ For -v - d + 1 <= x <= -v - 1, since v >= d - 1, we have x >= -2v\n+\/\/ As a result, x * ((v + 1) \/ v) >= x * ((x - 2) \/ x) = x - 2\n+\/\/\n+\/\/ x \/ d <= (-v - 1) \/ d\n+\/\/ floor((x - 1) \/ d) = (-v - 1) \/ d - 1\n+\/\/ x * c \/ m >= x * ((v + 1) \/ v) \/ d) >= (x - 2) \/ d\n+\/\/           >= (-v - d + 1 - 2) \/ d = (-v - 1) \/ d - 1\n+\/\/ which means (-v - 1) \/ d >= x \/ d > x * c \/ m >= (-v - 1) \/ d - 1\n+\/\/ This implies floor((x - 1) \/ d) = floor(x * c \/ m) for -v - 1 >= x >= -v - d + 1\n+\/\/\n+\/\/ Combining all the cases gives us the conclusion.\n+\/\/\n+\/\/ (3) Discussion:\n+\/\/\n+\/\/ Let x be v, v - d + 1, -v, -v + d - 1, it can be seen that these bounds are indeed optimal\n+\/\/\n+\/\/ (4) Implementation:\n+\/\/\n+\/\/ For computation efficiency, we only consider the values m = 2**s.\n+\/\/ This function does not handle the cases d being a power of 2, which means\n+\/\/ that c * d is never equal to m.\n+\/\/\n+\/\/ We find the value of c, m such that it satisfies the bounds for both the nonnegative\n+\/\/ and negative ranges of x. This can be done by finding v_neg and v_pos and the bounds of\n+\/\/ c * d - m is the intersection of (0, m \/ v_neg] and (0, m \/ v_pos). Which is (0, m \/ v_pos)\n+\/\/ if v_pos >= v_neg and (0, m \/ v_neg] otherwise.\n+\/\/\n+\/\/ Given v = max(v_neg, v_pos). For each value of s, the function inductively calculates\n+\/\/ c, rc, qv, rv such that:\n+\/\/\n+\/\/ c = floor(2**s \/ d) + 1 (c is the smallest integer such that c * d > 2**s)\n+\/\/ rc = c * d - 2**s\n+\/\/ qv = floor(2**s \/ v)\n+\/\/ rv = 2**s - qv * v (qv and rv are the quotient and the remainder of the floor division of\n+\/\/                     2**s by v)\n+template <class T>\n+void magic_divide_constants(T d, T N_neg, T N_pos, juint min_s, T& c, bool& c_ovf, juint& s) {\n+  static_assert(std::is_unsigned<T>::value, \"calculations must be done in the unsigned domain\");\n+  assert(!is_power_of_2(d), \"this case should be handled separately\");\n+  assert(d <= N_neg || d <= N_pos, \"this should just be idealized to 0\");\n+  constexpr T min_signed = std::numeric_limits<std::make_signed_t<T>>::min();\n+  T v_neg = N_neg < d - 1 ? 0 : N_neg - ((N_neg - d + 1) % d);\n+  T v_pos = N_pos < d - 1 ? 0 : N_pos - ((N_pos - d + 1) % d);\n+  T v = MAX2(v_neg, v_pos);\n+  bool tolerate_equal = v_neg > v_pos;\n+\n+  \/\/ base case, s = 0\n+  s = 0;\n+  c_ovf = false;\n+  c = 1;\n+  T rc = d - 1;\n+  bool qv_ovf = false;\n+  T qv = 0;\n+  T rv = 1;\n+\n+  while (true) {\n+    if (s >= min_s) {\n+      \/\/ qv_ovf || rc < qv is the test for rc < qv with overflow taken into\n+      \/\/ consideration\n+      if (qv_ovf || rc < qv || (rc == qv && (tolerate_equal || rv > 0))) {\n+        break;\n+      }\n+    }\n+    assert(!c_ovf, \"must be\");\n+    s++;\n+\n+    if (rc > d - rc) {  \/\/ 2 * rc > d\n+      c_ovf = c > min_signed;\n+      c = c * 2 - 1;\n+      rc = rc * 2 - d;\n+    } else {            \/\/ 2 * rc <= d\n+      c_ovf = c >= min_signed;\n+      c = c * 2;\n+      rc = rc * 2;\n+    }\n+    if (rv >= v - rv) { \/\/ 2 * rv >= v\n+      qv_ovf = qv >= min_signed;\n+      qv = qv * 2 + 1;\n+      rv = rv * 2 - v;\n+    } else {            \/\/ 2 * rv < v\n+      qv_ovf = qv >= min_signed;\n+      qv = qv * 2;\n+      rv = rv * 2;\n+    }\n+  }\n+}\n+template void magic_divide_constants<juint>(juint, juint, juint, juint, juint&, bool&, juint&);\n+template void magic_divide_constants<julong>(julong, julong, julong, juint, julong&, bool&, juint&);\n+\n+\/\/ The constant of a W-bit signed division lies in the range of W-bit unsigned\n+\/\/ integers. As a result, the product of the dividend and the magic constant cannot\n+\/\/ overflow a 2W-bit signed integer.\n+\/\/\n+\/\/ For unsigned division however, the magic constant may lie outside the range\n+\/\/ of W-bit unsigned integers, which means the product of it and the dividend can\n+\/\/ overflow a 2W-bit unsigned integer. In those cases, we use another algorithm.\n+\/\/\n+\/\/ Given s = floor(log2(d)) + W, c = floor(2**s \/ d) we have\n+\/\/\n+\/\/ floor(x \/ d) = floor((x + 1) * c \/ 2**s) for every integer x in [0, 2**W).\n+\/\/\n+\/\/ The proof can be found at: Robison, A.D.. (2005). N-bit unsigned division via\n+\/\/ N-bit multiply-add. Proceedings - Symposium on Computer Arithmetic. 131- 139.\n+\/\/ 10.1109\/ARITH.2005.31.\n+\/\/\n+\/\/ This is called round down because we round 1 \/ d down to c \/ 2**s\n+void magic_divide_constants_round_down(juint d, juint& c, juint& s) {\n+  assert(!is_power_of_2(d), \"this case should be handled separately\");\n+  constexpr juint W = 32;\n+\n+  s = log2i_graceful(d) + W;\n+  julong t = (julong(1) << s) \/ julong(d);\n+  c = t;\n+#ifdef ASSERT\n+  julong r = ((t + 1) * julong(d)) & julong(max_juint);\n+  assert(r > (julong(1) << (s - W)), \"Should call up first since it is more efficient\");\n+#endif\n+}\n","filename":"src\/hotspot\/share\/opto\/divconstants.cpp","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_DIVCONSTANTS_HPP\n+#define SHARE_OPTO_DIVCONSTANTS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ Provide methods to calculate the magic constants in transforming divisions\n+\/\/ by constants into series of multiplications and shifts.\n+template <class T>\n+void magic_divide_constants(T d, T N_neg, T N_pos, juint min_s, T& c, bool& c_ovf, juint& s);\n+void magic_divide_constants_round_down(juint d, juint& c, juint& s);\n+\n+#endif \/\/ SHARE_OPTO_DIVCONSTANTS_HPP\n","filename":"src\/hotspot\/share\/opto\/divconstants.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"opto\/divconstants.hpp\"\n@@ -39,0 +40,3 @@\n+#include <limits>\n+#include <type_traits>\n+\n@@ -41,41 +45,5 @@\n-\/\/ Optimization - Graph Style\n-\n-#include <math.h>\n-\n-\/\/----------------------magic_int_divide_constants-----------------------------\n-\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n-\/\/\n-\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n-\/\/ minor type name and parameter changes.\n-static bool magic_int_divide_constants(jint d, jint &M, jint &s) {\n-  int32_t p;\n-  uint32_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint32_t two31 = 0x80000000L;     \/\/ 2**31.\n-\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two31 + ((uint32_t)d >> 31);\n-  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n-  p = 31;                 \/\/ Init. p.\n-  q1 = two31\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n-  r1 = two31 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n-  q2 = two31\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n-  r2 = two31 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n-  do {\n-    p = p + 1;\n-    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n-    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n-    if (r1 >= anc) {      \/\/ (Must be an unsigned\n-      q1 = q1 + 1;        \/\/ comparison here).\n-      r1 = r1 - anc;\n-    }\n-    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n-    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n-    if (r2 >= ad) {       \/\/ (Must be an unsigned\n-      q2 = q2 + 1;        \/\/ comparison here).\n-      r2 = r2 - ad;\n-    }\n-    delta = ad - r2;\n-  } while (q1 < delta || (q1 == delta && r1 == 0));\n+template <class T>\n+static T max_unsigned_from_signed_bounds(T slo, T shi) {\n+  static_assert(std::is_unsigned<T>::value, \"must be\");\n+  return slo <= shi ? shi : std::numeric_limits<T>::max();\n+}\n@@ -83,3 +51,5 @@\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n-  s = p - 32;             \/\/ shift amount to return.\n+static bool jint_mul_no_ovf(jint lo, jint hi, juint c) {\n+  jlong prod_lo = jlong(lo) * jlong(c);\n+  jlong prod_hi = jlong(hi) * jlong(c);\n+  return jlong(jint(prod_lo)) == prod_lo && jlong(jint(prod_hi)) == prod_hi;\n+}\n@@ -87,1 +57,3 @@\n-  return true;\n+static bool juint_mul_no_ovf(juint hi, juint c) {\n+  julong prod_hi = julong(hi) * julong(c);\n+  return julong(juint(prod_hi)) == prod_hi;\n@@ -90,4 +62,23 @@\n-\/\/--------------------------transform_int_divide-------------------------------\n-\/\/ Convert a division by constant divisor into an alternate Ideal graph.\n-\/\/ Return null if no transformation occurs.\n-static Node *transform_int_divide( PhaseGVN *phase, Node *dividend, jint divisor ) {\n+static bool jlong_mul_no_ovf(jlong lo, jlong hi, julong c) {\n+  if (jlong(c) < 0) {\n+    return lo == 0 && hi == 0;\n+  }\n+\n+  jlong prod_lo_hi = multiply_high_signed(lo, c);\n+  jlong prod_lo_lo = java_multiply(lo, c);\n+  jlong prod_hi_hi = multiply_high_signed(hi, c);\n+  jlong prod_hi_lo = java_multiply(hi, c);\n+  return ((prod_lo_hi == 0 && prod_lo_lo >= 0) || (prod_lo_hi == -1 && prod_lo_lo < 0)) &&\n+      ((prod_hi_hi == 0 && prod_hi_lo >= 0) || (prod_hi_hi == -1 && prod_hi_lo < 0));\n+}\n+\n+static bool julong_mul_no_ovf(julong hi, julong c) {\n+  julong prod_hi_hi = multiply_high_unsigned(hi, c);\n+  return prod_hi_hi == 0;\n+}\n+\n+static bool uint128_t_mul_no_ovf(julong hi, julong c_wrapped) {\n+  julong mul_hi_c_wrapped = multiply_high_unsigned(hi, c_wrapped);\n+  julong mul_hi_wrapped = mul_hi_c_wrapped + hi;\n+  return mul_hi_wrapped >= mul_hi_c_wrapped;\n+}\n@@ -95,0 +86,8 @@\n+\/\/ magic_divide_constants in divconstants.cpp calculates the constant c, s\n+\/\/ such that division(x \/ d) = floor(x * c \/ 2**s) + (x < 0 ? 1 : 0) for every integer x in\n+\/\/ the input range. The functions in this file try to derive from the formula in real\n+\/\/ arithmetic to arrive at a formula in int\/long arithmetic. More details can be found in\n+\/\/ each individual function.\n+\n+\/\/ Convert a division by constant divisor into an alternate Ideal graph.\n+static Node* transform_int_divide(PhaseGVN* phase, Node* dividend, jint divisor) {\n@@ -96,2 +95,5 @@\n-  assert( divisor != 0 && divisor != min_jint,\n-          \"bad divisor for transforming to long multiply\" );\n+  assert(divisor != 0 && divisor != 1,\n+         \"bad divisor for transforming to long multiply\");\n+  if (divisor == -1) {\n+    return new SubINode(phase->intcon(0), dividend);\n+  }\n@@ -100,5 +102,8 @@\n-  jint d = d_pos ? divisor : -divisor;\n-  const int N = 32;\n-\n-  \/\/ Result\n-  Node *q = nullptr;\n+  juint d = uabs(divisor);\n+  constexpr int N = 32;\n+  const TypeInt* dti = phase->type(dividend)->is_int();\n+  juint min_neg = dti->_lo < 0 ? -juint(dti->_lo) : 0;\n+  juint max_pos = dti->_hi > 0 ? juint(dti->_hi) : 0;\n+  if (min_neg < d && max_pos < d) {\n+    return new ConINode(TypeInt::ZERO);\n+  }\n@@ -106,7 +111,1 @@\n-  if (d == 1) {\n-    \/\/ division by +\/- 1\n-    if (!d_pos) {\n-      \/\/ Just negate the value\n-      q = new SubINode(phase->intcon(0), dividend);\n-    }\n-  } else if ( is_power_of_2(d) ) {\n+  if (is_power_of_2(d)) {\n@@ -114,0 +113,1 @@\n+    juint l = log2i_exact(d);\n@@ -117,3 +117,1 @@\n-    const Type *dt = phase->type(dividend);\n-    const TypeInt *dti = dt->isa_int();\n-    if (dti && dti->_lo >= 0) {\n+    if (dti->_lo >= 0) {\n@@ -122,1 +120,1 @@\n-    } else if( dividend->Opcode() == Op_AndI ) {\n+    } else if (dividend->Opcode() == Op_AndI) {\n@@ -125,5 +123,6 @@\n-      const TypeInt *andconi_t = phase->type( dividend->in(2) )->isa_int();\n-      if( andconi_t && andconi_t->is_con() ) {\n-        jint andconi = andconi_t->get_con();\n-        if( andconi < 0 && is_power_of_2(-andconi) && (-andconi) >= d ) {\n-          if( (-andconi) == d ) \/\/ Remove AND if it clears bits which will be shifted\n+      const TypeInt* andconi_t = phase->type(dividend->in(2))->isa_int();\n+      if (andconi_t && andconi_t->is_con()) {\n+        juint andconi = andconi_t->get_con();\n+        if (count_trailing_zeros(andconi) >= l) {\n+          if (-andconi == d) {\n+            \/\/ Remove AND if it clears bits which will be shifted\n@@ -131,0 +130,1 @@\n+          }\n@@ -136,2 +136,0 @@\n-    \/\/ Add rounding to the shift to handle the sign bit\n-    int l = log2i_graceful(d - 1) + 1;\n@@ -147,1 +145,1 @@\n-      Node *sign = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n+      Node* sign = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n@@ -149,1 +147,1 @@\n-      Node *round = phase->transform(new URShiftINode(sign, phase->intcon(N - l)));\n+      Node* round = phase->transform(new URShiftINode(sign, phase->intcon(N - l)));\n@@ -155,2 +153,1 @@\n-    q = new RShiftINode(dividend, phase->intcon(l));\n-\n+    Node* q = new RShiftINode(dividend, phase->intcon(l));\n@@ -160,0 +157,19 @@\n+\n+    return q;\n+  }\n+\n+  juint magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<juint>(d, min_neg, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+  assert(!magic_const_ovf, \"signed magic constant cannot overflow\");\n+\n+  \/\/ x is an i32 and c is a u32, the value of x * c will always lie in the range\n+  \/\/ of an i64, so we can just perform the calculation directly.\n+  Node* addend0;\n+  if (jint_mul_no_ovf(dti->_lo, dti->_hi, magic_const)) {\n+    \/\/ If x * c can fit into an i32, we do int multiplication, this may help\n+    \/\/ auto vectorization\n+    Node* magic = phase->intcon(magic_const);\n+    Node* mul = phase->transform(new MulINode(dividend, magic));\n+    addend0 = phase->transform(new RShiftINode(mul, phase->intcon(shift_const)));\n@@ -161,32 +177,6 @@\n-    \/\/ Attempt the jint constant divide -> multiply transform found in\n-    \/\/   \"Division by Invariant Integers using Multiplication\"\n-    \/\/     by Granlund and Montgomery\n-    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n-\n-    jint magic_const;\n-    jint shift_const;\n-    if (magic_int_divide_constants(d, magic_const, shift_const)) {\n-      Node *magic = phase->longcon(magic_const);\n-      Node *dividend_long = phase->transform(new ConvI2LNode(dividend));\n-\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n-\n-      if (magic_const < 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n-\n-        \/\/ The magic multiplier is too large for a 32 bit constant. We've adjusted\n-        \/\/ it down by 2^32, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddINode(dividend, mul_hi));\n-\n-        \/\/ Shift over the (adjusted) mulhi\n-        if (shift_const != 0) {\n-          mul_hi = phase->transform(new RShiftINode(mul_hi, phase->intcon(shift_const)));\n-        }\n-      } else {\n-        \/\/ No add is required, we can merge the shifts together.\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n-      }\n+    Node* magic = phase->longcon(magic_const);\n+    Node* dividend_long = phase->transform(new ConvI2LNode(dividend));\n+    Node* mul = phase->transform(new MulLNode(dividend_long, magic));\n+    addend0 = phase->transform(new RShiftLNode(mul, phase->intcon(shift_const)));\n+    addend0 = phase->transform(new ConvL2INode(addend0));\n+  }\n@@ -194,3 +184,2 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N-1)));\n+  \/\/ q = (x * c) >> s + (x < 0 ? 1 : 0) = (x * c) >> s - (x >> (W - 1))\n+  Node* addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n@@ -198,5 +187,7 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n-      }\n+  \/\/ If the divisor is negative, swap the order of the input addends;\n+  \/\/ this has the effect of negating the quotient\n+  if (!d_pos) {\n+    swap(addend0, addend1);\n+  }\n+  return new SubINode(addend0, addend1);\n+}\n@@ -204,4 +195,9 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubINode(addend0, addend1);\n-    }\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+static Node* transform_int_udivide(PhaseGVN* phase, Node* dividend, juint divisor) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  constexpr int N = 32;\n+  const TypeInt* i1 = phase->type(dividend)->is_int();\n+  juint max_pos = max_unsigned_from_signed_bounds<juint>(i1->_lo, i1->_hi);\n+\n+  if (max_pos < divisor) {\n+    return new ConINode(TypeInt::ZERO);\n@@ -210,2 +206,5 @@\n-  return q;\n-}\n+  \/\/ Result\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    return new URShiftINode(dividend, phase->intcon(l));\n+  }\n@@ -213,34 +212,22 @@\n-\/\/---------------------magic_long_divide_constants-----------------------------\n-\/\/ Compute magic multiplier and shift constant for converting a 64 bit divide\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n-\/\/\n-\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n-\/\/ minor type name and parameter changes.  Adjusted to 64 bit word width.\n-static bool magic_long_divide_constants(jlong d, jlong &M, jint &s) {\n-  int64_t p;\n-  uint64_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint64_t two63 = UCONST64(0x8000000000000000);     \/\/ 2**63.\n-\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two63 + ((uint64_t)d >> 63);\n-  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n-  p = 63;                 \/\/ Init. p.\n-  q1 = two63\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n-  r1 = two63 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n-  q2 = two63\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n-  r2 = two63 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n-  do {\n-    p = p + 1;\n-    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n-    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n-    if (r1 >= anc) {      \/\/ (Must be an unsigned\n-      q1 = q1 + 1;        \/\/ comparison here).\n-      r1 = r1 - anc;\n-    }\n-    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n-    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n-    if (r2 >= ad) {       \/\/ (Must be an unsigned\n-      q2 = q2 + 1;        \/\/ comparison here).\n-      r2 = r2 - ad;\n+  juint magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<juint>(divisor, 0, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+\n+  if (!magic_const_ovf && juint_mul_no_ovf(max_pos, magic_const)) {\n+    \/\/ If x * c can fit into a u32, use int multiplication\n+    Node* mul = phase->transform(new MulINode(dividend, phase->intcon(magic_const)));\n+    return new URShiftINode(mul, phase->intcon(shift_const));\n+  }\n+\n+  julong magic_const_long = julong(magic_const) + (magic_const_ovf ? julong(max_juint) + 1 : 0);\n+  \/\/ Unsigned extension of dividend\n+  Node* dividend_long = phase->transform(new ConvI2LNode(dividend));\n+  dividend_long = phase->transform(new AndLNode(dividend_long, phase->longcon(max_juint)));\n+\n+  if (julong_mul_no_ovf(julong(max_pos), magic_const_long)) {\n+    \/\/ If x * c can fit into a u64, use long multiplication\n+\n+    \/\/ Java shifts are modular so we need this special case\n+    if (shift_const == N * 2) {\n+      return new ConINode(TypeInt::ZERO);\n@@ -248,2 +235,0 @@\n-    delta = ad - r2;\n-  } while (q1 < delta || (q1 == delta && r1 == 0));\n@@ -251,3 +236,10 @@\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n-  s = p - 64;             \/\/ shift amount to return.\n+    \/\/ q = (x * c) >> s\n+    Node* mul = phase->transform(new MulLNode(dividend_long, phase->longcon(magic_const_long)));\n+    Node* q = phase->transform(new URShiftLNode(mul, phase->intcon(shift_const)));\n+    return new ConvL2INode(q);\n+  }\n+\n+  \/\/ Original plan fails, rounding up of 1\/divisor does not work, change\n+  \/\/ to rounding down, now it is guaranteed to be correct, according to\n+  \/\/ N-Bit Unsigned Division Via N-Bit Multiply-Add by Arch D. Robison\n+  magic_divide_constants_round_down(divisor, magic_const, shift_const);\n@@ -255,1 +247,5 @@\n-  return true;\n+  \/\/ q = ((x + 1) * c) >> s, use long arithmetic\n+  Node* mul = phase->transform(new AddLNode(dividend_long, phase->longcon(1)));\n+  mul = phase->transform(new MulLNode(mul, phase->longcon(magic_const)));\n+  Node* q = phase->transform(new URShiftLNode(mul, phase->intcon(shift_const)));\n+  return new ConvL2INode(q);\n@@ -258,1 +254,0 @@\n-\/\/---------------------long_by_long_mulhi--------------------------------------\n@@ -334,2 +329,0 @@\n-\n-\/\/--------------------------transform_long_divide------------------------------\n@@ -338,1 +331,1 @@\n-static Node *transform_long_divide( PhaseGVN *phase, Node *dividend, jlong divisor ) {\n+static Node* transform_long_divide(PhaseGVN* phase, Node* dividend, jlong divisor) {\n@@ -340,2 +333,5 @@\n-  assert( divisor != 0L && divisor != min_jlong,\n-          \"bad divisor for transforming to long multiply\" );\n+  assert(divisor != 0L && divisor != 1L,\n+         \"bad divisor for transforming to long multiply\");\n+  if (divisor == -1L) {\n+    return new SubLNode(phase->longcon(0), dividend);\n+  }\n@@ -344,13 +340,8 @@\n-  jlong d = d_pos ? divisor : -divisor;\n-  const int N = 64;\n-\n-  \/\/ Result\n-  Node *q = nullptr;\n-\n-  if (d == 1) {\n-    \/\/ division by +\/- 1\n-    if (!d_pos) {\n-      \/\/ Just negate the value\n-      q = new SubLNode(phase->longcon(0), dividend);\n-    }\n-  } else if ( is_power_of_2(d) ) {\n+  julong d = uabs(divisor);\n+  constexpr int N = 64;\n+  const TypeLong* dtl = phase->type(dividend)->is_long();\n+  julong min_neg = dtl->_lo < 0 ? -julong(dtl->_lo) : 0;\n+  julong max_pos = dtl->_hi > 0 ? julong(dtl->_hi) : 0;\n+  if (min_neg < d && max_pos < d) {\n+    return new ConLNode(TypeLong::ZERO);\n+  }\n@@ -358,0 +349,1 @@\n+  if (is_power_of_2(d)) {\n@@ -359,0 +351,1 @@\n+    juint l = log2i_exact(d);\n@@ -362,4 +355,1 @@\n-    const Type *dt = phase->type(dividend);\n-    const TypeLong *dtl = dt->isa_long();\n-\n-    if (dtl && dtl->_lo > 0) {\n+    if (dtl->_lo > 0) {\n@@ -368,1 +358,1 @@\n-    } else if( dividend->Opcode() == Op_AndL ) {\n+    } else if (dividend->Opcode() == Op_AndL) {\n@@ -371,5 +361,6 @@\n-      const TypeLong *andconl_t = phase->type( dividend->in(2) )->isa_long();\n-      if( andconl_t && andconl_t->is_con() ) {\n-        jlong andconl = andconl_t->get_con();\n-        if( andconl < 0 && is_power_of_2(-andconl) && (-andconl) >= d ) {\n-          if( (-andconl) == d ) \/\/ Remove AND if it clears bits which will be shifted\n+      const TypeLong* andconl_t = phase->type(dividend->in(2))->isa_long();\n+      if (andconl_t && andconl_t->is_con()) {\n+        julong andconl = andconl_t->get_con();\n+        if (count_trailing_zeros(andconl) >= l) {\n+          if (-andconl == d) {\n+            \/\/ Remove AND if it clears bits which will be shifted\n@@ -377,0 +368,1 @@\n+          }\n@@ -382,2 +374,0 @@\n-    \/\/ Add rounding to the shift to handle the sign bit\n-    int l = log2i_graceful(d - 1) + 1;\n@@ -393,1 +383,1 @@\n-      Node *sign = phase->transform(new RShiftLNode(dividend, phase->intcon(N - 1)));\n+      Node* sign = phase->transform(new RShiftLNode(dividend, phase->intcon(N - 1)));\n@@ -395,1 +385,1 @@\n-      Node *round = phase->transform(new URShiftLNode(sign, phase->intcon(N - l)));\n+      Node* round = phase->transform(new URShiftLNode(sign, phase->intcon(N - l)));\n@@ -401,2 +391,1 @@\n-    q = new RShiftLNode(dividend, phase->intcon(l));\n-\n+    Node* q = new RShiftLNode(dividend, phase->intcon(l));\n@@ -406,20 +395,2 @@\n-  } else if ( !Matcher::use_asm_for_ldiv_by_con(d) ) { \/\/ Use hardware DIV instruction when\n-                                                       \/\/ it is faster than code generated below.\n-    \/\/ Attempt the jlong constant divide -> multiply transform found in\n-    \/\/   \"Division by Invariant Integers using Multiplication\"\n-    \/\/     by Granlund and Montgomery\n-    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n-\n-    jlong magic_const;\n-    jint shift_const;\n-    if (magic_long_divide_constants(d, magic_const, shift_const)) {\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n-\n-      \/\/ The high half of the 128-bit multiply is computed.\n-      if (magic_const < 0) {\n-        \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n-        \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n-      }\n+    return q;\n+  }\n@@ -427,4 +398,5 @@\n-      \/\/ Shift over the (adjusted) mulhi\n-      if (shift_const != 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const)));\n-      }\n+  if (Matcher::use_asm_for_ldiv_by_con(divisor)) {\n+    \/\/ Use hardware DIV instruction when\n+    \/\/ it is faster than code generated below.\n+    return nullptr;\n+  }\n@@ -432,3 +404,18 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N-1)));\n+  julong magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<julong>(d, min_neg, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+  assert(!magic_const_ovf, \"signed magic constant cannot overflow\");\n+\n+  Node* addend0;\n+  if (jlong_mul_no_ovf(dtl->_lo, dtl->_hi, magic_const)) {\n+    \/\/ If c * m can fit into an i64, do the multiplication directly\n+    Node* mul = phase->transform(new MulLNode(dividend, phase->longcon(magic_const)));\n+    addend0 = phase->transform(new RShiftLNode(mul, phase->intcon(shift_const)));\n+  } else {\n+    if (shift_const < N) {\n+      \/\/ We need i128 arithmetic here, if s < 64 we need to combine the high and low half of the full\n+      \/\/ product, force s to be >= 64 so we only need to use the high half\n+      magic_divide_constants<julong>(d, min_neg, max_pos, N, magic_const, magic_const_ovf, shift_const);\n+      assert(!magic_const_ovf, \"signed magic constant cannot overflow\");\n+    }\n@@ -436,5 +423,67 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n-      }\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    \/\/ (x * c) >> s = ((x * c) >> 64) >> (s - 64) = mul_hi(x, c) >> (s - 64)\n+    Node* mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n+    if (jlong(magic_const) < 0) {\n+      \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n+      \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n+      mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n+    }\n+\n+    \/\/ Shift over the (adjusted) mulhi\n+    addend0 = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const - N)));\n+  }\n+\n+  \/\/ q = mul_hi(x, c) >> (s - 64) + (x < 0 ? 1 : 0) = mul_hi(x, c) >> (x - 64) - (x >> 63)\n+  Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N - 1)));\n+\n+  \/\/ If the divisor is negative, swap the order of the input addends;\n+  \/\/ this has the effect of negating the quotient.\n+  if (!d_pos) {\n+    swap(addend0, addend1);\n+  }\n+  return new SubLNode(addend0, addend1);\n+}\n+\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+\/\/ Return null if no transformation occurs.\n+static Node* transform_long_udivide(PhaseGVN* phase, Node* dividend, julong divisor) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  constexpr int N = 64;\n+  const TypeLong* i1 = phase->type(dividend)->is_long();\n+  julong max_pos = max_unsigned_from_signed_bounds<julong>(i1->_lo, i1->_hi);\n+\n+  if (max_pos < divisor) {\n+    return new ConLNode(TypeLong::ZERO);\n+  }\n+\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    return new URShiftLNode(dividend, phase->intcon(l));\n+  }\n+\n+  if (!Matcher::match_rule_supported(Op_UMulHiL)) {\n+    return nullptr; \/\/ Don't bother\n+  }\n+\n+  julong magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<julong>(divisor, 0, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+\n+  if (!magic_const_ovf && julong_mul_no_ovf(max_pos, magic_const)) {\n+    \/\/ If x * c can fit into a u64, use long arithmetic\n+    Node* mul = phase->transform(new MulLNode(dividend, phase->longcon(magic_const)));\n+    return new URShiftLNode(mul, phase->intcon(shift_const));\n+  }\n+\n+  if (shift_const < N) {\n+    \/\/ We need i128 arithmetic here, if s < 64 we need to combine the high and low half of the full\n+    \/\/ product, force s to be >= 64 so we only need to use the high half\n+    magic_divide_constants<julong>(divisor, 0, max_pos, N, magic_const, magic_const_ovf, shift_const);\n+  }\n+\n+  if (!magic_const_ovf || uint128_t_mul_no_ovf(max_pos, magic_const)) {\n+    \/\/ Java shifts are modular so we need this special case\n+    if (shift_const == N * 2) {\n+      return new ConLNode(TypeLong::ZERO);\n+    }\n@@ -442,3 +491,6 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubLNode(addend0, addend1);\n+    \/\/ q = (x * c) >> s = ((x * c) >> 64) >> (s - 64) = umul_hi(x, c) >> (s - 64)\n+    Node* mul_hi = phase->transform(new UMulHiLNode(dividend, phase->longcon(magic_const)));\n+    if (magic_const_ovf) {\n+      \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n+      \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n+      mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n@@ -446,0 +498,1 @@\n+    return new URShiftLNode(mul_hi, phase->intcon(shift_const - N));\n@@ -448,1 +501,52 @@\n-  return q;\n+  if ((divisor & 1) == 0) {\n+    \/\/ x \/ (2 * d) = (x \/ 2) \/ d. This helps decrease the upper bound of the dividend,\n+    \/\/ guarantee that the product of the new dividend and the new magic constant does not\n+    \/\/ overflow\n+    juint ctz = count_trailing_zeros(divisor);\n+    dividend = phase->transform(new URShiftLNode(dividend, phase->intcon(ctz)));\n+    return new UDivLNode(nullptr, dividend, phase->longcon(divisor >> ctz));\n+  }\n+\n+  \/\/ q = floor((x * c) \/ 2**(s + 64))) = floor(((x * (c - 2**64)) \/ 2**64 + x) \/ 2**s)\n+  \/\/\n+  \/\/ Given: floor((x \/ s + y) \/ n) = floor((floor(x \/ s) + y) \/ n), we have\n+  \/\/ q = floor((floor((x * (c - 2**64)) \/ 2**64) + x) \/ 2**s)\n+  \/\/   = floor((mul_hi + x) \/ 2**s)\n+  \/\/ Let p = floor((mul_hi + x) \/ 2)\n+  \/\/       = floor((x - mul_hi) \/ 2 + mul_hi)\n+  \/\/       = floor((x - mul_hi) \/ 2) + mul_hi\n+  \/\/ Since x > mul_hi, this operation can be done precisely using Z\/2**64Z arithmetic\n+  Node* mul_hi = phase->transform(new UMulHiLNode(dividend, phase->longcon(magic_const)));\n+  Node* diff = phase->transform(new SubLNode(dividend, mul_hi));\n+  diff = phase->transform(new URShiftLNode(diff, phase->intcon(1)));\n+  Node* p = phase->transform(new AddLNode(diff, mul_hi));\n+  return new URShiftLNode(p, phase->intcon(shift_const - N - 1));\n+}\n+\n+static Node* divModIdealCommon(Node* n, BasicType bt, PhaseGVN* phase, bool need_const_divisor) {\n+  \/\/ Don't bother trying to transform a dead node\n+  if (n->in(0) != nullptr && n->in(0)->is_top()) {\n+    return nullptr;\n+  }\n+  const Type* t2 = phase->type(n->in(2));\n+  if (phase->type(n->in(1)) == Type::TOP || t2 == Type::TOP) {\n+    return nullptr;\n+  }\n+\n+  const TypeInteger* i2 = t2->is_integer(bt);\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (n->in(0) != nullptr && (i2->lo_as_long() > 0L || i2->hi_as_long() < 0L)) {\n+    n->set_req(0, nullptr);\n+    return n;\n+  }\n+\n+  if (i2->is_con()) {\n+    jlong i2_con = i2->get_con_as_long(bt);\n+    if (i2_con == 0) {\n+      return nullptr;\n+    }\n+    return NodeSentinel;\n+  }\n+\n+  return need_const_divisor ? nullptr : NodeSentinel;\n@@ -460,16 +564,2 @@\n-Node *DivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  const Type *t = phase->type( in(2) );\n-  if( t == TypeInt::ONE )      \/\/ Identity?\n-    return nullptr;            \/\/ Skip it\n-\n-  const TypeInt *ti = t->isa_int();\n-  if( !ti ) return nullptr;\n-\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding div-zero case\n-  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n-    set_req(0, nullptr);           \/\/ Yank control input\n+Node* DivINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -479,2 +569,4 @@\n-  if( !ti->is_con() ) return nullptr;\n-  jint i = ti->get_con();       \/\/ Get divisor\n+  Node* q = divModIdealCommon(this, T_INT, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n@@ -482,1 +574,1 @@\n-  if (i == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n+  jint i2_con = phase->type(in(2))->is_int()->get_con();\n@@ -484,2 +576,3 @@\n-  \/\/ Dividing by MININT does not optimize as a power-of-2 shift.\n-  if( i == min_jint ) return nullptr;\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n@@ -487,1 +580,3 @@\n-  return transform_int_divide( phase, in(1), i );\n+  q = transform_int_divide(phase, in(1), i2_con);\n+  assert(q != nullptr, \"sanity\");\n+  return q;\n@@ -566,16 +661,2 @@\n-Node *DivLNode::Ideal( PhaseGVN *phase, bool can_reshape) {\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  const Type *t = phase->type( in(2) );\n-  if( t == TypeLong::ONE )      \/\/ Identity?\n-    return nullptr;             \/\/ Skip it\n-\n-  const TypeLong *tl = t->isa_long();\n-  if( !tl ) return nullptr;\n-\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding div-zero case\n-  if (in(0) && (tl->_hi < 0 || tl->_lo > 0)) {\n-    set_req(0, nullptr);         \/\/ Yank control input\n+Node* DivLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -585,2 +666,4 @@\n-  if( !tl->is_con() ) return nullptr;\n-  jlong l = tl->get_con();      \/\/ Get divisor\n+  Node* q = divModIdealCommon(this, T_LONG, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n@@ -588,1 +671,1 @@\n-  if (l == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n+  jlong i2_con = phase->type(in(2))->is_long()->get_con();\n@@ -590,2 +673,3 @@\n-  \/\/ Dividing by MINLONG does not optimize as a power-of-2 shift.\n-  if( l == min_jlong ) return nullptr;\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n@@ -593,1 +677,3 @@\n-  return transform_long_divide( phase, in(1), l );\n+  q = transform_long_divide(phase, in(1), i2_con);\n+  assert(q != nullptr || Matcher::use_asm_for_ldiv_by_con(i2_con), \"sanity\");\n+  return q;\n@@ -662,0 +748,126 @@\n+Node* UDivINode::Identity(PhaseGVN* phase) {\n+  return (phase->type(in(2))->higher_equal(TypeInt::ONE)) ? in(1) : this;\n+}\n+\n+Node* UDivINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  Node* q = divModIdealCommon(this, T_INT, phase, false);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  const TypeInt* i2 = phase->type(in(2))->is_int();\n+  \/\/ Divisor very large, constant 2**31 can be transform to a shift\n+  if (i2->_hi <= 0 && i2->_hi > min_jint) {\n+    Node* cmp = phase->transform(new CmpUNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveINode(bol, phase->intcon(0), phase->intcon(1), TypeInt::BOOL);\n+  }\n+\n+  if (!i2->is_con()) {\n+    return nullptr;\n+  }\n+  juint i2_con = i2->get_con();\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n+  if (phase->type(in(1))->is_int()->is_con()) {\n+    \/\/ Don't transform a constant-foldable\n+    return nullptr;\n+  }\n+\n+  q = transform_int_udivide(phase, in(1), i2_con);\n+  assert(q != nullptr, \"sanity\");\n+  return q;\n+}\n+\n+const Type* UDivINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeInt::ONE;\n+  }\n+\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) \/ juint(i2->get_con()));\n+  }\n+\n+  return TypeInt::INT;\n+}\n+\n+Node* UDivLNode::Identity(PhaseGVN* phase) {\n+  return (phase->type(in(2))->higher_equal(TypeLong::ONE)) ? in(1) : this;\n+}\n+\n+Node* UDivLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  Node* q = divModIdealCommon(this, T_LONG, phase, false);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  const TypeLong* i2 = phase->type(in(2))->is_long();\n+  \/\/ Divisor very large, constant 2**63 can be transform to a shift\n+  if (i2->_hi <= 0 && i2->_hi > min_jlong) {\n+    Node* cmp = phase->transform(new CmpULNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveLNode(bol, phase->longcon(0), phase->longcon(1), TypeLong::make(0, 1, Type::WidenMin));\n+  }\n+\n+  if (!i2->is_con()) {\n+    return nullptr;\n+  }\n+  julong i2_con = i2->get_con();\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n+  if (phase->type(in(1))->is_long()->is_con()) {\n+    \/\/ Don't transform a constant-foldable\n+    return nullptr;\n+  }\n+\n+  q = transform_long_udivide(phase, in(1), i2_con);\n+  assert(q != nullptr || !Matcher::match_rule_supported(Op_UMulHiL), \"sanity\");\n+  return q;\n+}\n+\n+const Type* UDivLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeLong::ONE;\n+  }\n+\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) \/ julong(i2->get_con()));\n+  }\n+\n+  \/\/ Otherwise we give up all hope\n+  return TypeLong::LONG;\n+}\n@@ -844,72 +1056,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ If the divisor is 1, we are an identity on the dividend.\n-Node* UDivINode::Identity(PhaseGVN* phase) {\n-  return (phase->type( in(2) )->higher_equal(TypeInt::ONE)) ? in(1) : this;\n-}\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A UDivINode divides its inputs.  The third input is a Control input, used to\n-\/\/ prevent hoisting the divide above an unsafe test.\n-const Type* UDivINode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n-  if (in(1) == in(2)) {\n-    return TypeInt::ONE;\n-  }\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Otherwise we give up all hope\n-  return TypeInt::INT;\n-}\n-\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n-}\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ If the divisor is 1, we are an identity on the dividend.\n-Node* UDivLNode::Identity(PhaseGVN* phase) {\n-  return (phase->type( in(2) )->higher_equal(TypeLong::ONE)) ? in(1) : this;\n-}\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A UDivLNode divides its inputs.  The third input is a Control input, used to\n-\/\/ prevent hoisting the divide above an unsafe test.\n-const Type* UDivLNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n-  if (in(1) == in(2)) {\n-    return TypeLong::ONE;\n-  }\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Otherwise we give up all hope\n-  return TypeLong::LONG;\n-}\n-\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -917,22 +1058,1 @@\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n-}\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *ModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  \/\/ Get the modulus\n-  const Type *t = phase->type( in(2) );\n-  if( t == Type::TOP ) return nullptr;\n-  const TypeInt *ti = t->is_int();\n-\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding mod-zero case\n-  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n-    set_req(0, nullptr);        \/\/ Yank control input\n+  if(in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -942,3 +1062,4 @@\n-  \/\/ See if we are MOD'ing by 2^k or 2^k-1.\n-  if( !ti->is_con() ) return nullptr;\n-  jint con = ti->get_con();\n+  Node* q = divModIdealCommon(this, T_INT, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n@@ -946,0 +1067,1 @@\n+  jint con = phase->type(in(2))->is_int()->get_con();\n@@ -947,1 +1069,0 @@\n-\n@@ -1086,8 +1207,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n-}\n-\n@@ -1099,7 +1212,0 @@\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  \/\/ Get the modulus\n-  const Type *t = phase->type( in(2) );\n-  if( t == Type::TOP ) return nullptr;\n-  const TypeLong *tl = t->is_long();\n@@ -1107,5 +1213,3 @@\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding mod-zero case\n-  if (in(0) && (tl->_hi < 0 || tl->_lo > 0)) {\n-    set_req(0, nullptr);        \/\/ Yank control input\n-    return this;\n+  Node* q = divModIdealCommon(this, T_LONG, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n@@ -1114,4 +1218,1 @@\n-  \/\/ See if we are MOD'ing by 2^k or 2^k-1.\n-  if( !tl->is_con() ) return nullptr;\n-  jlong con = tl->get_con();\n-\n+  jlong con = phase->type(in(2))->is_long()->get_con();\n@@ -1119,1 +1220,0 @@\n-\n@@ -1260,0 +1360,104 @@\n+Node* UModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  Node* q = divModIdealCommon(this, T_INT, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  if (phase->type(in(1))->is_int()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  juint i2_con = phase->type(in(2))->is_int()->get_con();\n+  if (is_power_of_2(i2_con)) {\n+    return new AndINode(in(1), phase->intcon(i2_con - 1));\n+  }\n+\n+  \/\/ TODO: This can be calculated directly, see https:\/\/arxiv.org\/abs\/1902.01961\n+  q = transform_int_udivide(phase, in(1), i2_con);\n+  assert(q != nullptr, \"sanity\");\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulINode(q, phase->intcon(i2_con)));\n+  return new SubINode(in(1), mul);\n+}\n+\n+const Type* UModINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeInt::ONE) {\n+    return TypeInt::ZERO;\n+  }\n+\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) % juint(i2->get_con()));\n+  }\n+\n+  return TypeInt::INT;\n+}\n+\n+Node* UModLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  Node* q = divModIdealCommon(this, T_LONG, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  if (phase->type(in(1))->is_long()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  julong i2_con = phase->type(in(2))->is_long()->get_con();\n+  if (is_power_of_2(i2_con)) {\n+    return new AndLNode(in(1), phase->longcon(i2_con - 1));\n+  }\n+\n+  q = transform_long_udivide(phase, in(1), i2_con);\n+  if (q == nullptr) {\n+    assert(!Matcher::match_rule_supported(Op_UMulHiL), \"sanity\");\n+    return nullptr;\n+  }\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulLNode(q, phase->longcon(i2_con)));\n+  return new SubLNode(in(1), mul);\n+}\n+\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeLong::ONE) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) % julong(i2->get_con()));\n+  }\n+\n+  return TypeLong::LONG;\n+}\n@@ -1304,9 +1508,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":607,"deletions":412,"binary":false,"changes":1019,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-\n-\n@@ -169,1 +167,1 @@\n-  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModINode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -171,2 +169,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -180,1 +179,1 @@\n-  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModLNode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -182,2 +181,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/divconstants.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <type_traits>\n+\n+\/\/ Generate a random positive integer of type T in a way that biases\n+\/\/ towards smaller values\n+\/\/ We are dealing with inputs of divisions so it makes more sense\n+\/\/ to have inputs following approximately a reciprocal (log-uniform)\n+\/\/ distribution\n+template <class T, class UT>\n+static UT random();\n+\n+template <>\n+juint random<jint, juint>() {\n+  juint bits = (juint(os::random()) % 31) + 1;\n+  juint mask = (juint(1) << bits) - 1;\n+  return os::random() & mask;\n+}\n+\n+template <>\n+juint random<juint, juint>() {\n+  juint bits = (juint(os::random()) % 32) + 1;\n+  juint mask = bits == 32 ? std::numeric_limits<juint>::max() : (juint(1) << bits) - 1;\n+  return os::random() & mask;\n+}\n+\n+#ifdef __SIZEOF_INT128__\n+template <>\n+julong random<jlong, julong>() {\n+  juint bits = (juint(os::random()) % 63) + 1;\n+  julong mask = (julong(1) << bits) - 1;\n+  julong full = (julong(os::random()) << 32) | os::random();\n+  return full & mask;\n+}\n+\n+template <>\n+julong random<julong, julong>() {\n+  juint bits = (juint(os::random()) % 64) + 1;\n+  julong mask = bits == 64 ? std::numeric_limits<julong>::max() : (julong(1) << bits) - 1;\n+  julong full = (julong(os::random()) << 32) | os::random();\n+  return full & mask;\n+}\n+#endif \/\/ __SIZEOF_INT128__\n+\n+template <class UT, class U, class F>\n+static void test_op(UT d, UT N_neg, UT N_pos, F op) {\n+  U lo = -U(N_neg);\n+  U hi = N_pos;\n+  U d_long = d;\n+\n+  auto test = [&](U l) {\n+    if (l < lo || l > hi) {\n+      return;\n+    }\n+\n+    U expected = l \/ d;\n+    U actual = op(l);\n+    ASSERT_EQ(expected, actual);\n+  };\n+\n+  test(0);\n+  if (hi >= d_long) {\n+    test(d_long);\n+    test(hi - (hi + 1) % d_long);\n+  }\n+  if (N_neg >= d_long) {\n+    test(-d_long);\n+    test(lo - (lo - 1) % d_long);\n+  }\n+}\n+\n+template <class UT, class U>\n+static void test_division(UT d, UT N_neg, UT N_pos, juint min_s) {\n+  constexpr juint W = sizeof(UT) * 8;\n+\n+  \/\/ This also filters out d = 0 so don't use is_power_of_2\n+  if ((N_neg < d && N_pos < d) || (d & (d - 1)) == 0) {\n+    return;\n+  }\n+\n+  UT c;\n+  bool c_ovf;\n+  juint s;\n+  magic_divide_constants(d, N_neg, N_pos, min_s, c, c_ovf, s);\n+\n+  auto op = [&](U l) -> U {\n+    if (!c_ovf) {\n+      return ((l * U(c)) >> s) + (l < 0 ? U(1) : U(0));\n+    } else {\n+      if (sizeof(U) > sizeof(UT) * 2) {\n+        constexpr U wrap_amount = U(UT(-1)) + 1;\n+        return (l * (U(c) + wrap_amount)) >> s;\n+      } else {\n+        U mul_hi = (l * U(c)) >> W;\n+        return (((l - mul_hi) >> 1) + mul_hi) >> (s - 1 - W);\n+      }\n+    }\n+  };\n+\n+  test_op<UT, U>(d, N_neg, N_pos, op);\n+}\n+\n+template <class T, class U>\n+static void test_division_random() {\n+  constexpr int iter_num = 10000;\n+  using UT = std::conditional_t<std::is_same<T, jlong>::value, julong, std::make_unsigned_t<T>>;\n+  for (int i = 0; i < iter_num;) {\n+    UT d = random<T, UT>();\n+    if ((d & (d - 1)) == 0) {\n+      d = 7;\n+    }\n+\n+    UT N_neg = std::is_signed<T>::value ? random<T, UT>() + 1 : 0;\n+    UT N_pos = random<T, UT>();\n+    if (N_neg < d && N_pos < d) {\n+      N_pos = d;\n+    }\n+\n+    juint min_s = juint(os::random()) % (sizeof(T) * 8 + 1);\n+\n+    test_division<UT, U>(d, N_neg, N_pos, min_s);\n+    i++;\n+  }\n+}\n+\n+template <class T, class U>\n+static void test_division_fixed(const GrowableArrayView<const julong>& values) {\n+  using UT = std::conditional_t<std::is_same<T, jlong>::value, julong, std::make_unsigned_t<T>>;\n+  for (julong N_neg : values) {\n+    if (N_neg > UT(std::numeric_limits<T>::min())) {\n+      continue;\n+    }\n+    for (julong N_pos : values) {\n+      if (N_pos > UT(std::numeric_limits<T>::max())) {\n+        continue;\n+      }\n+      for (julong d : values) {\n+        for (juint min_s = 0; min_s <= sizeof(T) * 8; min_s++) {\n+          test_division<UT, U>(d, N_neg, N_pos, min_s);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+static void test_division_round_down() {\n+  constexpr int iter_num = 10000;\n+  for (int i = 0; i < iter_num;) {\n+    constexpr juint W = 32;\n+    juint d = random<juint, juint>();\n+    if ((d & (d - 1)) == 0) {\n+      d = 7;\n+    }\n+    juint s = log2i_graceful(d) + W;\n+    julong t = (julong(1) << s) \/ julong(d);\n+    julong r = ((t + 1) * julong(d)) & julong(max_juint);\n+    if (r <= (julong(1) << (s - W))) {\n+      d = 7;\n+    }\n+\n+    juint c;\n+    s = -1;\n+    magic_divide_constants_round_down(d, c, s);\n+    auto op = [&](julong l) -> julong {\n+      return ((l + 1) * c) >> s;\n+    };\n+\n+    test_op<juint, julong>(d, 0, std::numeric_limits<juint>::max(), op);\n+    i++;\n+  }\n+}\n+\n+TEST(opto, divide_by_constants) {\n+  static const julong raw_values[] = {0, 1, 2, 3, 5, 6, 7, 8, 11, 14, 15, 19, 29, 60, 101, 1000, 9999, 1000000,\n+    max_jint - 10, max_jint - 1, max_jint, julong(max_jint) + 1, julong(max_jint) + 2, julong(max_jint) + 11,\n+    max_juint - 10, max_juint - 1, max_juint, julong(max_juint) + 1, julong(max_juint) + 2, julong(max_juint) + 11,\n+    max_jlong - 10, max_jlong - 1, max_jlong, julong(max_jlong) + 1, julong(max_jlong) + 2, julong(max_jlong) + 11,\n+    max_julong - 10, max_julong - 1, max_julong};\n+\n+  GrowableArrayFromArray<const julong> values(raw_values, sizeof(raw_values) \/ sizeof(julong));\n+\n+#ifdef __SIZEOF_INT128__\n+  test_division_fixed<jint, __int128>(values);\n+  test_division_fixed<juint, __int128>(values);\n+  test_division_fixed<jlong, __int128>(values);\n+  test_division_fixed<julong, unsigned __int128>(values);\n+  test_division_random<jint, __int128>();\n+  test_division_random<juint, __int128>();\n+  test_division_random<jlong, __int128>();\n+  test_division_random<julong, unsigned __int128>();\n+#else\n+  test_division_fixed<jint, jlong>(values);\n+  test_division_fixed<juint, julong>(values);\n+  test_division_random<jint, jlong>();\n+  test_division_random<juint, julong>();\n+#endif \/\/ __SIZEOF_INT128__\n+\n+  test_division_round_down();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_constant_division.cpp","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -518,3 +518,1 @@\n-    @IR(counts = { IRNode.ADD_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n-                   IRNode.RSHIFT_VI,\n+    @IR(counts = { IRNode.RSHIFT_VI,\n@@ -538,3 +536,1 @@\n-    @IR(counts = { IRNode.ADD_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n-                   IRNode.RSHIFT_VI,\n+    @IR(counts = { IRNode.RSHIFT_VI,\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestIntVect.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\",\n-                 \"magicDiv\"})\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\", \"divByMin\",\n+                 \"magicDiv13\", \"magicDiv7\", \"magicDiv7Bounded\"})\n@@ -85,1 +85,1 @@\n-        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ 1, identity(a));\n@@ -87,6 +87,10 @@\n-        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n-        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n-        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n-        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n-        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n-        Asserts.assertEQ(a \/ 13       , magicDiv(a));\n+        Asserts.assertEQ(a \/ -1, divByNegOne(a));\n+        Asserts.assertEQ((a & -6) \/ 2, divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2, divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8, divByPow2(a));\n+        Asserts.assertEQ(a \/ -8, divByNegPow2(a));\n+        Asserts.assertEquals(a \/ Integer.MIN_VALUE, divByMin(a));\n+        Asserts.assertEquals(1, divByMin(Integer.MIN_VALUE));\n+        Asserts.assertEQ(a \/ 13, magicDiv13(a));\n+        Asserts.assertEQ(a \/ 7, magicDiv7(a));\n+        Asserts.assertEQ((short)a \/ 7, magicDiv7Bounded(a));\n@@ -151,1 +155,1 @@\n-        return (x & -4) \/ 2;\n+        return (x & -6) \/ 2;\n@@ -193,2 +197,15 @@\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.MUL, \"1\",\n+    @IR(counts = {IRNode.URSHIFT_I, \"2\",\n+                  IRNode.RSHIFT_I, \"1\",\n+                  IRNode.ADD_I, \"1\"\n+                 })\n+\n+    \/\/ Similar to above, 0 - (v >> 31) = v >>> 31\n+    public int divByMin(int x) {\n+        return x \/ Integer.MIN_VALUE;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB_I, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n@@ -199,4 +216,2 @@\n-    \/\/ More tests can be made to cover the specific cases for differences in the\n-    \/\/ graph that depend upon different values for the \"magic constant\" and the\n-    \/\/ \"shift constant\"\n-    public int magicDiv(int x) {\n+    \/\/ The constant derived from 13 lies inside the limit of an i32\n+    public int magicDiv13(int x) {\n@@ -205,0 +220,28 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB_I, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of an i32 but inside the limit\n+    \/\/ of a u32\n+    public int magicDiv7(int x) {\n+        return x \/ 7;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL_I, \"1\",\n+                  IRNode.RSHIFT_I, \"3\"\n+                  })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ i64 arithmetic\n+    public int magicDiv7Bounded(int x) {\n+        return (short)x \/ 7;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\"})\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\", \"divByMin\",\n+                 \"magicDiv19\", \"magicDiv15\", \"magicDiv15Bounded\"})\n@@ -84,1 +85,1 @@\n-        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ 1, identity(a));\n@@ -86,5 +87,10 @@\n-        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n-        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n-        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n-        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n-        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n+        Asserts.assertEQ(a \/ -1, divByNegOne(a));\n+        Asserts.assertEQ((a & -6) \/ 2, divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2, divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8, divByPow2(a));\n+        Asserts.assertEQ(a \/ -8, divByNegPow2(a));\n+        Asserts.assertEQ(a \/ Long.MIN_VALUE, divByMin(a));\n+        Asserts.assertEQ(1L, divByMin(Long.MIN_VALUE));\n+        Asserts.assertEQ(a \/ 19, magicDiv19(a));\n+        Asserts.assertEQ(a \/ 15, magicDiv15(a));\n+        Asserts.assertEQ((int)a \/ 15L, magicDiv15Bounded(a));\n@@ -150,1 +156,1 @@\n-        return (x & -4L) \/ 2L;\n+        return (x & -6L) \/ 2L;\n@@ -190,0 +196,50 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.ADD_L, \"1\"\n+                 })\n+    \/\/ Similar to above\n+    public long divByMin(long x) {\n+        return x \/ Long.MIN_VALUE;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L}, applyIfPlatform = {\"64-bit\", \"true\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.MUL_HI_L, \"1\"\n+                 }, applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an i64\n+    public long magicDiv19(long x) {\n+        return x \/ 19L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L}, applyIfPlatform = {\"64-bit\", \"true\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"2\",\n+                  IRNode.MUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\"\n+                 }, applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 15 lies outside the limit of an i64 but inside the limit\n+    \/\/ of a u64\n+    public long magicDiv15(long x) {\n+        return x \/ 15L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L}, applyIfPlatform = {\"64-bit\", \"true\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.RSHIFT_L, \"2\"\n+                 }, applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ i128 arithmetic\n+    public long magicDiv15Bounded(long x) {\n+        return (int)x \/ 15L;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":65,"deletions":9,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivINode and UModINode are\n+ * being performed as expected.\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivINodeIdealizationTests\n+ *\/\n+public class UDivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisorCon\", \"largeDivisorVar\",\n+                 \"magicDiv13\", \"magicDiv7\", \"magicDiv13Bounded\",\n+                 \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod13\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+            a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+            b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public int udiv(int a, int b) {\n+        return Integer.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public int umod(int a, int b) {\n+        return Integer.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(1, constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(0, constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a, identity(a));\n+        Asserts.assertEQ(a, identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8), divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7), largeDivisorCon(a));\n+        Asserts.assertEQ(udiv(a, Math.min(b, -1)), largeDivisorVar(a, b));\n+        Asserts.assertEQ(udiv(a, 13), magicDiv13(a));\n+        Asserts.assertEQ(udiv(a, 7), magicDiv7(a));\n+        Asserts.assertEQ(udiv((char)a, 13), magicDiv13Bounded(a));\n+        Asserts.assertEQ(umod(a, 1), constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8), modByPow2(a));\n+        Asserts.assertEQ(umod(a, 13), magicMod13(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constantDiv(int x) {\n+        return Integer.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return Integer.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.UDIV_I, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return Integer.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.URSHIFT_I, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public int divByPow2(int x) {\n+        return Integer.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.CMP_U, \"1\",\n+                  IRNode.CMOVE_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public int largeDivisorCon(int x) {\n+        return Integer.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.CMP_U, \"1\",\n+                  IRNode.CMOVE_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public int largeDivisorVar(int x, int y) {\n+        return Integer.divideUnsigned(x, Math.min(y, -1));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of a u32\n+    public int magicDiv13(int x) {\n+        return Integer.divideUnsigned(x, 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of a u32 but inside the limit\n+    \/\/ of a u33\n+    public int magicDiv7(int x) {\n+        return Integer.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.URSHIFT_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ u64 arithmetic\n+    public int magicDiv13Bounded(int x) {\n+        return Integer.divideUnsigned((char)x, 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constantMod(int x) {\n+        return Integer.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantModAgain(int x) {\n+        return Integer.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.AND_I, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public int modByPow2(int x) {\n+        return Integer.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                  IRNode.MUL_I, \"1\",\n+                  IRNode.SUB_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of a u32\n+    public int magicMod13(int x) {\n+        return Integer.remainderUnsigned(x, 13);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivLNode and UModLNode are\n+ * being performed as expected.\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivLNodeIdealizationTests\n+ *\/\n+public class UDivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisorCon\", \"largeDivisorVar\",\n+                 \"magicDiv19\", \"magicDiv7\", \"magicDiv28\", \"magicDiv13Bounded\",\n+                 \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod19\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+             a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+             b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public long udiv(long a, long b) {\n+        return Long.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public long umod(long a, long b) {\n+        return Long.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(udiv(a, a), constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(umod(a, a), constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a, identity(a));\n+        Asserts.assertEQ(a, identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8), divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7), largeDivisorCon(a));\n+        Asserts.assertEQ(udiv(a, Math.min((int)b, -1)), largeDivisorVar(a, b));\n+        Asserts.assertEQ(udiv(a, 19), magicDiv19(a));\n+        Asserts.assertEQ(udiv(a, 7), magicDiv7(a));\n+        Asserts.assertEQ(udiv(a, 28), magicDiv28(a));\n+        Asserts.assertEQ(udiv(Integer.toUnsignedLong((int)a), 13), magicDiv13Bounded(a));\n+        Asserts.assertEQ(umod(a, 1), constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8), modByPow2(a));\n+        Asserts.assertEQ(umod(a, 19), magicMod19(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constantDiv(long x) {\n+        return Long.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return Long.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.UDIV_L, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return Long.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public long divByPow2(long x) {\n+        return Long.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.CMP_UL, \"1\",\n+                  IRNode.CMOVE_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public long largeDivisorCon(long x) {\n+        return Long.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.CMP_UL, \"1\",\n+                  IRNode.CMOVE_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public long largeDivisorVar(long x, long y) {\n+        return Long.divideUnsigned(x, Math.min((int)y, -1));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of a u64\n+    public long magicDiv19(long x) {\n+        return Long.divideUnsigned(x, 19);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of a u64 but inside the limit\n+    \/\/ of a u65\n+    public long magicDiv7(long x) {\n+        return Long.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.UMUL_HI_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 28 lies outside the limit of a u64 but we can transform\n+    \/\/ x \/ 28 into (x \/ 4) \/ 7\n+    public long magicDiv28(long x) {\n+        return Long.divideUnsigned(x, 28);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.MUL_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ u128 arithmetic\n+    public long magicDiv13Bounded(long x) {\n+        return Long.divideUnsigned(Integer.toUnsignedLong((int)x), 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constantMod(long x) {\n+        return Long.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantModAgain(long x) {\n+        return Long.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.AND_L, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public long modByPow2(long x) {\n+        return Long.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of a u64\n+    public long magicMod19(long x) {\n+        return Long.remainderUnsigned(x, 19);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.integerArithmetic;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of division nodes provide correct\n+ * result.\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.integerArithmetic.DivisionByConstant\n+ *\/\n+public class DivisionByConstant {\n+    private static final int TRIALS = 10;\n+    private static final int INVOCATIONS = 100;\n+\n+    private static final int I_DIV;\n+    private static final int I_1;\n+    private static final int I_2;\n+    private static final long L_DIV;\n+    private static final long L_1;;\n+    private static final long L_2;\n+\n+    static {\n+        int iDiv = 0;\n+        int i1 = 0;\n+        int i2 = 0;\n+        long lDiv = 0;\n+        long l1 = 0;\n+        long l2 = 0;\n+        try {\n+            iDiv = Integer.parseUnsignedInt(System.getProperty(\"iDiv\"));\n+            i1 = Integer.parseUnsignedInt(System.getProperty(\"i1\"));\n+            i2 = Integer.parseUnsignedInt(System.getProperty(\"i2\"));\n+            lDiv = Long.parseUnsignedLong(System.getProperty(\"lDiv\"));\n+            l1 = Long.parseUnsignedLong(System.getProperty(\"l1\"));\n+            l2 = Long.parseUnsignedLong(System.getProperty(\"l2\"));\n+        } catch (Exception e) {}\n+\n+        I_DIV = iDiv;\n+        I_1 = i1;\n+        I_2 = i2;\n+        L_DIV = lDiv;\n+        L_1 = l1;\n+        L_2 = l2;\n+    }\n+    private static final int I_LO = Math.min(I_1, I_2);\n+    private static final int I_HI = Math.max(I_1, I_2);\n+    private static final int I_UHI = I_1;\n+    private static final long L_LO = Math.min(L_1, L_2);\n+    private static final long L_HI = Math.max(L_1, L_2);\n+    private static final long L_UHI = L_1;\n+\n+    public static void main(String[] args) {\n+        Random r = Utils.getRandomInstance();\n+        for (int i = 0; i < TRIALS; i++) {\n+            String iDiv = Long.toUnsignedString(logRandom(r, Integer.SIZE));\n+            String i1 = Long.toUnsignedString(logRandom(r, Integer.SIZE));\n+            String i2 = Long.toUnsignedString(logRandom(r, Integer.SIZE));\n+            String lDiv = Long.toUnsignedString(logRandom(r, Long.SIZE));\n+            String l1 = Long.toUnsignedString(logRandom(r, Long.SIZE));\n+            String l2 = Long.toUnsignedString(logRandom(r, Long.SIZE));\n+\n+            var test = new TestFramework(DivisionByConstant.class);\n+            test.setDefaultWarmup(1);\n+            test.addFlags(\"-DiDiv=\" + iDiv, \"-Di1=\" + i1, \"-Di2=\" + i2,\n+                    \"-DlDiv=\" + lDiv, \"-Dl1=\" + l1, \"-Dl2=\" + l2);\n+            test.start();\n+        }\n+    }\n+\n+    static long logRandom(Random r, int bits) {\n+        int highestBit = r.nextInt(bits);\n+        long res = r.nextLong() & (-1L >>> (Long.SIZE - 1 - highestBit));\n+        return res == 0 ? 1 : res;\n+    }\n+\n+    @Run(test = {\"sDivInt\", \"uDivInt\", \"sDivLong\", \"uDivLong\"})\n+    public void run() {\n+        Random r = Utils.getRandomInstance();\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            {\n+                int x;\n+                if (I_HI != Integer.MAX_VALUE) {\n+                    x = r.nextInt(I_LO, I_HI + 1);\n+                } else if (I_LO != Integer.MIN_VALUE) {\n+                    x = r.nextInt(I_LO - 1, I_HI) + 1;\n+                } else {\n+                    x = r.nextInt();\n+                }\n+                Asserts.assertEQ(sDiv(x, I_DIV), sDivInt(x));\n+            }\n+            {\n+                int x;\n+                if (I_UHI >= 0) {\n+                    x = r.nextInt(-1, I_UHI) + 1;\n+                } else {\n+                    x = r.nextInt(Integer.MIN_VALUE, I_UHI + 1);\n+                }\n+                Asserts.assertEQ(uDiv(x, I_DIV), uDivInt(x));\n+            }\n+            {\n+                long y; int x;\n+                if (L_LO >= Integer.MIN_VALUE && L_HI <= Integer.MAX_VALUE) {\n+                    y = r.nextLong(L_LO, L_HI + 1);\n+                    x = (int)y;\n+                } else {\n+                    x = r.nextInt();\n+                    if (x > 0) {\n+                        y = L_LO - 1 + x;\n+                    } else {\n+                        y = L_HI + x;\n+                    }\n+                }\n+                Asserts.assertEQ(sDiv(y, L_DIV), sDivLong(x));\n+            }\n+            {\n+                long y; int x;\n+                if (L_UHI >= 0 && L_UHI <= Integer.MAX_VALUE) {\n+                    y = r.nextLong(L_UHI + 1);\n+                    x = (int)y;\n+                } else {\n+                    x = r.nextInt();\n+                    if (x > 0) {\n+                        y = x;\n+                    } else {\n+                        y = L_UHI + x;\n+                    }\n+                }\n+                Asserts.assertEQ(uDiv(y, L_DIV), uDivLong(x));\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    static int sDiv(int x, int y) {\n+        return x \/ y;\n+    }\n+\n+    @DontCompile\n+    static int uDiv(int x, int y) {\n+        return Integer.divideUnsigned(x, y);\n+    }\n+\n+    @DontCompile\n+    static long sDiv(long x, long y) {\n+        return x \/ y;\n+    }\n+\n+    @DontCompile\n+    static long uDiv(long x, long y) {\n+        return Long.divideUnsigned(x, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.DIV)\n+    public int sDivInt(int x) {\n+        int dividend = Math.min(I_HI, Math.max(I_LO, x));\n+        return dividend \/ I_DIV;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.UDIV_I, applyIfPlatform = {\"x64\", \"true\"})\n+    static int uDivInt(int x) {\n+        int dividend = I_UHI < 0\n+                ? Math.min(I_UHI, x)\n+                : Math.min(I_UHI, Math.max(0, x));\n+        return Integer.divideUnsigned(dividend, I_DIV);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.DIV_L, applyIfPlatform = {\"64-bit\", \"true\"})\n+    static long sDivLong(int x) {\n+        long dividend;\n+        if (L_LO >= Integer.MIN_VALUE && L_HI <= Integer.MAX_VALUE) {\n+            dividend = Math.min((int)L_HI, Math.max((int)L_LO, x));\n+        } else if (x > 0) {\n+            dividend = L_LO - 1 + x;\n+        } else {\n+            dividend = L_HI + x;\n+        }\n+        return dividend \/ L_DIV;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.UDIV_L, applyIfPlatform = {\"x64\", \"true\"})\n+    static long uDivLong(int x) {\n+        long dividend;\n+        if (L_UHI >= 0 && L_UHI <= Integer.MAX_VALUE) {\n+            dividend = Math.min((int)L_UHI, Math.max(0, x));\n+        } else if (x > 0) {\n+            dividend = x;\n+        } else {\n+            dividend = L_UHI + x;\n+        }\n+        return Long.divideUnsigned(dividend, L_DIV);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/integerArithmetic\/DivisionByConstant.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -430,0 +430,15 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+    }\n+\n+    public static final String CMOVE_VD = PREFIX + \"CMOVE_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VD, \"CMoveVD\");\n+    }\n+\n+    public static final String CMOVE_VF = PREFIX + \"CMOVE_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VF, \"CMoveVF\");\n+    }\n+\n@@ -1041,0 +1056,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGeneratorFactory;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,3 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n@@ -58,0 +54,1 @@\n+\n@@ -66,1 +63,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGeneratorFactory.getDefault().create(0);\n@@ -70,2 +67,12 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisor = divisor == 0 ? 1 : divisor;\n+            if (divisorType.equals(\"positive\")) {\n+                if (divisor == Integer.MIN_VALUE) {\n+                    divisor = Integer.MAX_VALUE;\n+                } else if (divisor < 0) {\n+                    divisor = -divisor;\n+                }\n+            } else if (divisorType.equals(\"negative\")) {\n+                if (divisor > 0) {\n+                    divisor = -divisor;\n+                }\n+            }\n@@ -93,1 +100,4 @@\n-            divmod(dividends[i], divisors[i], i);\n+            int dividend = dividends[i];\n+            int divisor = divisors[i];\n+            quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+            remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n@@ -97,3 +107,5 @@\n-    public void divmod(int dividend, int divisor, int i) {\n-        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n-        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ 7;\n+        }\n@@ -102,1 +114,6 @@\n-}\n+    @Benchmark\n+    public void testDivideConstantBounded() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = (short)dividends[i] \/ 7;\n+        }\n+    }\n@@ -104,0 +121,6 @@\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -105,0 +128,6 @@\n+    @Benchmark\n+    public void testDivideUnsignedConstantBounded() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned((char)dividends[i], 15);\n+        }\n+    }\n@@ -106,0 +135,7 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Integer.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":52,"deletions":16,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGeneratorFactory;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,3 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n@@ -58,0 +54,1 @@\n+\n@@ -66,1 +63,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGeneratorFactory.getDefault().create(0);\n@@ -70,2 +67,12 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisor = divisor == 0 ? 1 : divisor;\n+            if (divisorType.equals(\"positive\")) {\n+                if (divisor == Long.MIN_VALUE) {\n+                    divisor = Long.MAX_VALUE;\n+                } else if (divisor < 0) {\n+                    divisor = -divisor;\n+                }\n+            } else if (divisorType.equals(\"negative\")) {\n+                if (divisor > 0) {\n+                    divisor = -divisor;\n+                }\n+            }\n@@ -93,1 +100,4 @@\n-            divmod(dividends[i], divisors[i], i);\n+            long dividend = dividends[i];\n+            long divisor = divisors[i];\n+            quotients[i] = Long.divideUnsigned(dividend, divisor);\n+            remainders[i] = Long.remainderUnsigned(dividend, divisor);\n@@ -97,3 +107,5 @@\n-    public void divmod(long dividend, long divisor, int i) {\n-        quotients[i] = Long.divideUnsigned(dividend, divisor);\n-        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideConstantBounded() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = (int)dividends[i] \/ 7L;\n+        }\n@@ -102,2 +114,6 @@\n-}\n-\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -105,0 +121,6 @@\n+    @Benchmark\n+    public void testDivideUnsignedConstantBounded() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(Integer.toUnsignedLong((int)dividends[i]), 15);\n+        }\n+    }\n@@ -106,0 +128,7 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Long.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":46,"deletions":17,"binary":false,"changes":63,"status":"modified"}]}