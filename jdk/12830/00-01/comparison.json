{"files":[{"patch":"@@ -196,22 +196,8 @@\n-HeapWord*\n-G1CollectedHeap::humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n-                                                           uint num_regions,\n-                                                           size_t word_size) {\n-  assert(first_hr != NULL, \"pre-condition\");\n-  assert(is_humongous(word_size), \"word_size should be humongous\");\n-  assert(num_regions * HeapRegion::GrainWords >= word_size, \"pre-condition\");\n-\n-  \/\/ Index of last region in the series.\n-  uint first = first_hr->hrm_index();\n-  uint last = first + num_regions - 1;\n-\n-  \/\/ We need to initialize the region(s) we just discovered. This is\n-  \/\/ a bit tricky given that it can happen concurrently with\n-  \/\/ refinement threads refining cards on these regions and\n-  \/\/ potentially wanting to refine the BOT as they are scanning\n-  \/\/ those cards (this can happen shortly after a cleanup; see CR\n-  \/\/ 6991377). So we have to set up the region(s) carefully and in\n-  \/\/ a specific order.\n-\n-  \/\/ The word size sum of all the regions we will allocate.\n-  size_t word_size_sum = (size_t) num_regions * HeapRegion::GrainWords;\n+void G1CollectedHeap::reset_humongous_metadata(HeapRegion* first_hr,\n+                                               uint num_regions,\n+                                               size_t word_size,\n+                                               bool update_remsets) {\n+  \/\/ Calculate the new top of the humongous object.\n+  HeapWord* obj_top = first_hr->bottom() + word_size;\n+  \/\/ The word size sum of all the regions used\n+  size_t word_size_sum = num_regions * HeapRegion::GrainWords;\n@@ -220,20 +206,2 @@\n-  \/\/ The passed in hr will be the \"starts humongous\" region. The header\n-  \/\/ of the new object will be placed at the bottom of this region.\n-  HeapWord* new_obj = first_hr->bottom();\n-  \/\/ This will be the new top of the new object.\n-  HeapWord* obj_top = new_obj + word_size;\n-\n-  \/\/ First, we need to zero the header of the space that we will be\n-  \/\/ allocating. When we update top further down, some refinement\n-  \/\/ threads might try to scan the region. By zeroing the header we\n-  \/\/ ensure that any thread that will try to scan the region will\n-  \/\/ come across the zero klass word and bail out.\n-  \/\/\n-  \/\/ NOTE: It would not have been correct to have used\n-  \/\/ CollectedHeap::fill_with_object() and make the space look like\n-  \/\/ an int array. The thread that is doing the allocation will\n-  \/\/ later update the object header to a potentially different array\n-  \/\/ type and, for a very short period of time, the klass and length\n-  \/\/ fields will be inconsistent. This could cause a refinement\n-  \/\/ thread to calculate the object size incorrectly.\n-  Copy::fill_to_words(new_obj, oopDesc::header_size(), 0);\n+  \/\/ How many words memory we \"waste\" which cannot hold a filler object.\n+  size_t words_not_fillable = 0;\n@@ -241,1 +209,1 @@\n-  \/\/ Next, pad out the unused tail of the last region with filler\n+  \/\/ Pad out the unused tail of the last region with filler\n@@ -243,2 +211,0 @@\n-  \/\/ How many words we use for filler objects.\n-  size_t word_fill_size = word_size_sum - word_size;\n@@ -246,2 +212,2 @@\n-  \/\/ How many words memory we \"waste\" which cannot hold a filler object.\n-  size_t words_not_fillable = 0;\n+  \/\/ How many words can we use for filler objects.\n+  size_t words_fillable = word_size_sum - word_size;\n@@ -249,3 +215,3 @@\n-  if (word_fill_size >= min_fill_size()) {\n-    fill_with_objects(obj_top, word_fill_size);\n-  } else if (word_fill_size > 0) {\n+  if (words_fillable >= G1CollectedHeap::min_fill_size()) {\n+    G1CollectedHeap::fill_with_objects(obj_top, words_fillable);\n+  } else {\n@@ -253,2 +219,2 @@\n-    words_not_fillable = word_fill_size;\n-    word_fill_size = 0;\n+    words_not_fillable = words_fillable;\n+    words_fillable = 0;\n@@ -261,5 +227,12 @@\n-  first_hr->set_starts_humongous(obj_top, word_fill_size);\n-  _policy->remset_tracker()->update_at_allocate(first_hr);\n-  \/\/ Then, if there are any, we will set up the \"continues\n-  \/\/ humongous\" regions.\n-  HeapRegion* hr = NULL;\n+  first_hr->hr_clear(false \/* clear_space *\/);\n+  first_hr->set_starts_humongous(obj_top, words_fillable);\n+\n+  if (update_remsets) {\n+    _policy->remset_tracker()->update_at_allocate(first_hr);\n+  }\n+\n+  \/\/ Indices of first and last regions in the series.\n+  uint first = first_hr->hrm_index();\n+  uint last = first + num_regions - 1;\n+\n+  HeapRegion* hr = nullptr;\n@@ -268,0 +241,1 @@\n+    hr->hr_clear(false \/* clear_space *\/);\n@@ -269,1 +243,3 @@\n-    _policy->remset_tracker()->update_at_allocate(hr);\n+    if (update_remsets) {\n+      _policy->remset_tracker()->update_at_allocate(hr);\n+    }\n@@ -300,0 +276,21 @@\n+}\n+\n+HeapWord*\n+G1CollectedHeap::humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n+                                                           uint num_regions,\n+                                                           size_t word_size) {\n+  assert(first_hr != NULL, \"pre-condition\");\n+  assert(is_humongous(word_size), \"word_size should be humongous\");\n+  assert(num_regions * HeapRegion::GrainWords >= word_size, \"pre-condition\");\n+\n+  \/\/ Index of last region in the series.\n+  uint first = first_hr->hrm_index();\n+  uint last = first + num_regions - 1;\n+\n+  \/\/ We need to initialize the region(s) we just discovered. This is\n+  \/\/ a bit tricky given that it can happen concurrently with\n+  \/\/ refinement threads refining cards on these regions and\n+  \/\/ potentially wanting to refine the BOT as they are scanning\n+  \/\/ those cards (this can happen shortly after a cleanup; see CR\n+  \/\/ 6991377). So we have to set up the region(s) carefully and in\n+  \/\/ a specific order.\n@@ -301,1 +298,26 @@\n-  increase_used((word_size_sum - words_not_fillable) * HeapWordSize);\n+  \/\/ The passed in hr will be the \"starts humongous\" region. The header\n+  \/\/ of the new object will be placed at the bottom of this region.\n+  HeapWord* new_obj = first_hr->bottom();\n+\n+  \/\/ First, we need to zero the header of the space that we will be\n+  \/\/ allocating. When we update top further down, some refinement\n+  \/\/ threads might try to scan the region. By zeroing the header we\n+  \/\/ ensure that any thread that will try to scan the region will\n+  \/\/ come across the zero klass word and bail out.\n+  \/\/\n+  \/\/ NOTE: It would not have been correct to have used\n+  \/\/ CollectedHeap::fill_with_object() and make the space look like\n+  \/\/ an int array. The thread that is doing the allocation will\n+  \/\/ later update the object header to a potentially different array\n+  \/\/ type and, for a very short period of time, the klass and length\n+  \/\/ fields will be inconsistent. This could cause a refinement\n+  \/\/ thread to calculate the object size incorrectly.\n+  Copy::fill_to_words(new_obj, oopDesc::header_size(), 0);\n+\n+  \/\/ Next, update the metadata for the regions.\n+  reset_humongous_metadata(first_hr, num_regions, word_size, true);\n+\n+  HeapRegion* last_hr = region_at(last);\n+  size_t used = byte_size(first_hr->bottom(), last_hr->top());\n+\n+  increase_used(used);\n@@ -304,1 +326,1 @@\n-    hr = region_at(i);\n+    HeapRegion *hr = region_at(i);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":82,"deletions":60,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -609,0 +609,5 @@\n+  void reset_humongous_metadata(HeapRegion* first_hr,\n+                                uint num_regions,\n+                                size_t word_size,\n+                                bool update_remsets);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+    _humongous_compaction_regions(8),\n@@ -139,2 +140,0 @@\n-  _humongous_compaction_regions = new (mtGC) GrowableArray<HeapRegion*>(8, mtGC);\n-\n@@ -162,1 +161,1 @@\n-  delete _humongous_compaction_regions;\n+\n@@ -482,1 +481,1 @@\n-  if (!_humongous_compaction_regions->is_empty()) {\n+  if (!_humongous_compaction_regions.is_empty()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-  GrowableArray<HeapRegion*>* _humongous_compaction_regions;\n@@ -91,0 +90,1 @@\n+  GrowableArrayCHeap<HeapRegion*, mtGC> _humongous_compaction_regions;\n@@ -149,2 +149,2 @@\n-  inline void add_humongous_region(HeapRegion* hr) { _humongous_compaction_regions->append(hr); }\n-  GrowableArray<HeapRegion*>* humongous_compaction_regions() { return _humongous_compaction_regions; }\n+  inline void add_humongous_region(HeapRegion* hr);\n+  inline GrowableArrayCHeap<HeapRegion*, mtGC>& humongous_compaction_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,0 +97,8 @@\n+void G1FullCollector::add_humongous_region(HeapRegion* hr) {\n+  _humongous_compaction_regions.append(hr);\n+}\n+\n+GrowableArrayCHeap<HeapRegion*, mtGC>& G1FullCollector::humongous_compaction_regions() {\n+  return _humongous_compaction_regions;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  \/\/ copy object and reinit its mark\n+  \/\/ Copy object and reinit its mark.\n@@ -111,1 +111,1 @@\n-  for (HeapRegion* hr : *(collector()->humongous_compaction_regions())) {\n+  for (HeapRegion* hr : collector()->humongous_compaction_regions()) {\n@@ -117,51 +117,0 @@\n-void G1FullGCCompactTask::reset_humongous_metadata(HeapRegion* start_hr, uint num_regions, size_t word_size) {\n-  \/\/ Calculate the new top of the humongous object\n-  HeapWord* dest_top = start_hr->bottom() + word_size;\n-  \/\/ The word size sum of all the regions used\n-  size_t word_size_sum = num_regions * HeapRegion::GrainWords;\n-  assert(word_size <= word_size_sum, \"sanity\");\n-\n-  \/\/ How many words memory we \"waste\" which cannot hold a filler object.\n-  size_t words_not_fillable = 0;\n-  \/\/ Next, pad out the unused tail of the last region with filler\n-  \/\/ objects, for improved usage accounting.\n-\n-  \/\/ How many words can we use for filler objects.\n-  size_t words_fillable = word_size_sum - word_size;\n-\n-  if (words_fillable >= G1CollectedHeap::min_fill_size()) {\n-    G1CollectedHeap::fill_with_objects(dest_top, words_fillable);\n-  } else {\n-    \/\/ We have space to fill, but we cannot fit an object there.\n-    words_not_fillable = words_fillable;\n-    words_fillable = 0;\n-  }\n-\n-  \/\/ Set up the first region as \"starts humongous\". This will also update\n-  \/\/ the BOT covering all the regions to reflect that there is a single\n-  \/\/ object that starts at the bottom of the first region.\n-\n-  start_hr->set_free(); \/\/ Avoid triggering asserts when changing region type\n-  start_hr->set_top(start_hr->bottom());\n-  start_hr->set_starts_humongous(dest_top, words_fillable);\n-  start_hr->reset_compacted_after_full_gc(start_hr->end());\n-\n-  uint start_idx = start_hr->hrm_index();\n-  uint end_idx   = start_idx + num_regions - 1;\n-\n-  \/\/ If there are any, we set up the \"continues humongous\" regions.\n-  for (uint i = start_idx + 1; i <= end_idx; i++) {\n-    HeapRegion* hr = _g1h->region_at(i);\n-    hr->set_free();\n-    hr->set_top(hr->bottom());\n-    hr->set_continues_humongous(start_hr);\n-    hr->reset_compacted_after_full_gc(hr->end());\n-  }\n-\n-  \/\/ If we cannot fit a filler object, we must set top to the end\n-  \/\/ of the humongous object, otherwise we cannot iterate the heap\n-  \/\/ and the BOT will not be complete.\n-  HeapRegion* end_hr = _g1h->region_at(end_idx);\n-  end_hr->set_top(end_hr->end() - words_not_fillable);\n-}\n-\n@@ -174,1 +123,1 @@\n-  uint num_regions = (uint) G1CollectedHeap::humongous_obj_size_in_regions(word_size);\n+  uint num_regions = (uint)G1CollectedHeap::humongous_obj_size_in_regions(word_size);\n@@ -184,1 +133,1 @@\n-  reset_humongous_metadata(_g1h->region_at(dest_start_idx), num_regions, word_size);\n+  _g1h->reset_humongous_metadata(_g1h->region_at(dest_start_idx), num_regions, word_size, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":4,"deletions":55,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  void reset_humongous_metadata(HeapRegion* start_hr, uint num_regions, size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  int num_regions = (int) G1CollectedHeap::humongous_obj_size_in_regions(obj_size);\n+  uint num_regions = (uint)G1CollectedHeap::humongous_obj_size_in_regions(obj_size);\n@@ -159,1 +159,1 @@\n-  \/\/ Find contiguous compaction target regions for the humongous object\n+  \/\/ Find contiguous compaction target regions for the humongous object.\n@@ -165,1 +165,1 @@\n-    \/\/ No contiguous compaction target regions found, so the object cannot be moved\n+    \/\/ No contiguous compaction target regions found, so the object cannot be moved.\n@@ -172,2 +172,2 @@\n-  HeapRegion* destn_hr = _compaction_regions->at(range_begin);\n-  obj->forward_to(cast_to_oop(destn_hr->bottom()));\n+  HeapRegion* dest_hr = _compaction_regions->at(range_begin);\n+  obj->forward_to(cast_to_oop(dest_hr->bottom()));\n@@ -176,1 +176,1 @@\n-  \/\/ Add the humongous object regions to the compaction point\n+  \/\/ Add the humongous object regions to the compaction point.\n@@ -180,1 +180,1 @@\n-  _compaction_regions->erase(range_begin, (range_begin + num_regions));\n+  _compaction_regions->remove_range(range_begin, (range_begin + num_regions));\n@@ -205,1 +205,1 @@\n-    contiguous_region_count =  regions_are_contiguous ? contiguous_region_count + 1 : 1;\n+    contiguous_region_count = regions_are_contiguous ? contiguous_region_count + 1 : 1;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -119,3 +119,1 @@\n-  assert(_humongous_start_region == NULL,\n-         \"we should have already filtered out humongous regions\");\n-\n+  set_top(bottom());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,3 +182,0 @@\n-  \/\/ Update heap region that has been compacted to be consistent after Full GC.\n-  void reset_compacted_humongous_after_full_gc(HeapWord* new_top);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,9 +192,0 @@\n-inline void HeapRegion::reset_compacted_humongous_after_full_gc(HeapWord* new_top) {\n-  set_top(new_top);\n-  \/\/ After a compaction the mark bitmap in a non-pinned regions is invalid.\n-  \/\/ But all objects are live, we get this by setting TAMS to bottom.\n-  init_top_at_mark_start();\n-\n-  reset_after_full_gc_common();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-    erase(0, idx);\n+    remove_range(0, idx);\n@@ -261,1 +261,1 @@\n-  void erase(int start, int end) {\n+  void remove_range(int start, int end) {\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}